diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/access.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/access.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/access.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/access.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Routines to authenticate access to a daemon (hosts allow/deny).
  *
  * Copyright (C) 1998 Andrew Tridgell
- * Copyright (C) 2004-2009 Wayne Davison
+ * Copyright (C) 2004-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,20 +17,56 @@
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
-static int match_hostname(char *host, char *tok)
+static int allow_forward_dns;
+
+extern const char undetermined_hostname[];
+
+static int match_hostname(const char **host_ptr, const char *addr, const char *tok)
 {
+	struct hostent *hp;
+	unsigned int i;
+	const char *host = *host_ptr;
+
 	if (!host || !*host)
 		return 0;
-	return wildmatch(tok, host);
+
+	/* First check if the reverse-DNS-determined hostname matches. */
+	if (iwildmatch(tok, host))
+		return 1;
+
+	if (!allow_forward_dns)
+		return 0;
+
+	/* Fail quietly if tok is an address or wildcarded entry, not a simple hostname. */
+	if (!tok[strspn(tok, ".0123456789")] || tok[strcspn(tok, ":/*?[")])
+		return 0;
+
+	/* Now try forward-DNS on the token (config-specified hostname) and see if the IP matches. */
+	if (!(hp = gethostbyname(tok)))
+		return 0;
+
+	for (i = 0; hp->h_addr_list[i] != NULL; i++) {
+		if (strcmp(addr, inet_ntoa(*(struct in_addr*)(hp->h_addr_list[i]))) == 0) {
+			/* If reverse lookups are off, we'll use the conf-specified
+			 * hostname in preference to UNDETERMINED. */
+			if (host == undetermined_hostname) {
+				if (!(*host_ptr = strdup(tok)))
+					*host_ptr = undetermined_hostname;
+			}
+			return 1;
+		}
+	}
+
+	return 0;
 }
 
-static int match_binary(char *b1, char *b2, char *mask, int addrlen)
+static int match_binary(const char *b1, const char *b2, const char *mask, int addrlen)
 {
 	int i;
 
 	for (i = 0; i < addrlen; i++) {
 		if ((b1[i] ^ b2[i]) & mask[i])
 			return 0;
@@ -53,13 +89,13 @@
 	if (w+1 < addrlen)
 		memset(mask+w+1, 0, addrlen-w-1);
 
 	return;
 }
 
-static int match_address(char *addr, char *tok)
+static int match_address(const char *addr, const char *tok)
 {
 	char *p;
 	struct addrinfo hints, *resa, *rest;
 	int gai;
 	int ret = 0;
 	int addrlen = 0;
@@ -67,30 +103,22 @@
 	long int bits;
 #else
 	int bits;
 #endif
 	char mask[16];
 	char *a = NULL, *t = NULL;
-	unsigned int len;
 
 	if (!addr || !*addr)
 		return 0;
 
 	p = strchr(tok,'/');
-	if (p) {
+	if (p)
 		*p = '\0';
-		len = p - tok;
-	} else
-		len = strlen(tok);
 
-	/* Fail quietly if tok is a hostname (not an address) */
-	if (strspn(tok, ".0123456789") != len
-#ifdef INET6
-	    && strchr(tok, ':') == NULL
-#endif
-	) {
+	/* Fail quietly if tok is a hostname, not an address. */
+	if (tok[strspn(tok, ".0123456789")] && strchr(tok, ':') == NULL) {
 		if (p)
 			*p = '/';
 		return 0;
 	}
 
 	memset(&hints, 0, sizeof(hints));
@@ -207,53 +235,56 @@
   out:
 	freeaddrinfo(resa);
 	freeaddrinfo(rest);
 	return ret;
 }
 
-static int access_match(char *list, char *addr, char *host)
+static int access_match(const char *list, const char *addr, const char **host_ptr)
 {
 	char *tok;
 	char *list2 = strdup(list);
 
 	if (!list2)
 		out_of_memory("access_match");
 
 	strlower(list2);
-	if (host)
-		strlower(host);
 
 	for (tok = strtok(list2, " ,\t"); tok; tok = strtok(NULL, " ,\t")) {
-		if (match_hostname(host, tok) || match_address(addr, tok)) {
+		if (match_hostname(host_ptr, addr, tok) || match_address(addr, tok)) {
 			free(list2);
 			return 1;
 		}
 	}
 
 	free(list2);
 	return 0;
 }
 
-int allow_access(char *addr, char *host, char *allow_list, char *deny_list)
+int allow_access(const char *addr, const char **host_ptr, int i)
 {
+	const char *allow_list = lp_hosts_allow(i);
+	const char *deny_list = lp_hosts_deny(i);
+
 	if (allow_list && !*allow_list)
 		allow_list = NULL;
 	if (deny_list && !*deny_list)
 		deny_list = NULL;
 
+	allow_forward_dns = lp_forward_lookup(i);
+
 	/* If we match an allow-list item, we always allow access. */
 	if (allow_list) {
-		if (access_match(allow_list, addr, host))
+		if (access_match(allow_list, addr, host_ptr))
 			return 1;
 		/* For an allow-list w/o a deny-list, disallow non-matches. */
 		if (!deny_list)
 			return 0;
 	}
 
 	/* If we match a deny-list item (and got past any allow-list
 	 * items), we always disallow access. */
-	if (deny_list && access_match(deny_list, addr, host))
+	if (deny_list && access_match(deny_list, addr, host_ptr))
 		return 0;
 
 	/* Allow all other access. */
 	return 1;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/acls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/acls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/acls.c	2011-05-30 23:39:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/acls.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Handle passing Access Control Lists between systems.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2006-2009 Wayne Davison
+ * Copyright (C) 2006-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -1140,13 +1140,13 @@
 		return perms;
 	}
 
 	/* Apply the permission-bit entries of the default ACL, if any. */
 	if (racl.user_obj != NO_ENTRY) {
 		perms = rsync_acl_get_perms(&racl);
-		if (verbose > 2)
+		if (DEBUG_GTE(ACL, 1))
 			rprintf(FINFO, "got ACL-based default perms %o for directory %s\n", perms, dir);
 	}
 
 	rsync_acl_free(&racl);
 	return perms;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/authenticate.c	2011-09-11 04:38:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/authenticate.c	2013-06-10 03:11:53.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Support rsync daemon authentication.
  *
  * Copyright (C) 1998-2000 Andrew Tridgell
- * Copyright (C) 2002-2009 Wayne Davison
+ * Copyright (C) 2002-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -16,13 +16,15 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "itypes.h"
 
+extern int read_only;
 extern char *password_file;
 
 /***************************************************************************
 encode a buffer using base64 - simple and slow algorithm. null terminates
 the result.
   ***************************************************************************/
@@ -73,209 +75,271 @@
 	sum_update(input, sizeof input);
 	len = sum_end(digest);
 
 	base64_encode(digest, len, challenge, 0);
 }
 
+/* Generate an MD4 hash created from the combination of the password
+ * and the challenge string and return it base64-encoded. */
+static void generate_hash(const char *in, const char *challenge, char *out)
+{
+	char buf[MAX_DIGEST_LEN];
+	int len;
+
+	sum_init(0);
+	sum_update(in, strlen(in));
+	sum_update(challenge, strlen(challenge));
+	len = sum_end(buf);
+
+	base64_encode(buf, len, out, 0);
+}
 
 /* Return the secret for a user from the secret file, null terminated.
  * Maximum length is len (not counting the null). */
-static int get_secret(int module, const char *user, char *secret, int len)
+static const char *check_secret(int module, const char *user, const char *group,
+				const char *challenge, const char *pass)
 {
+	char line[1024];
+	char pass2[MAX_DIGEST_LEN*2];
 	const char *fname = lp_secrets_file(module);
 	STRUCT_STAT st;
 	int fd, ok = 1;
-	const char *p;
-	char ch, *s;
-
-	if (!fname || !*fname)
-		return 0;
+	int user_len = strlen(user);
+	int group_len = group ? strlen(group) : 0;
+	char *err;
 
-	if ((fd = open(fname, O_RDONLY)) < 0)
-		return 0;
+	if (!fname || !*fname || (fd = open(fname, O_RDONLY)) < 0)
+		return "no secrets file";
 
-	if (do_stat(fname, &st) == -1) {
-		rsyserr(FLOG, errno, "stat(%s)", fname);
+	if (do_fstat(fd, &st) == -1) {
+		rsyserr(FLOG, errno, "fstat(%s)", fname);
 		ok = 0;
 	} else if (lp_strict_modes(module)) {
 		if ((st.st_mode & 06) != 0) {
 			rprintf(FLOG, "secrets file must not be other-accessible (see strict modes option)\n");
 			ok = 0;
 		} else if (MY_UID() == 0 && st.st_uid != 0) {
 			rprintf(FLOG, "secrets file must be owned by root when running as root (see strict modes)\n");
 			ok = 0;
 		}
 	}
 	if (!ok) {
-		rprintf(FLOG, "continuing without secrets file\n");
 		close(fd);
-		return 0;
+		return "ignoring secrets file";
 	}
 
 	if (*user == '#') {
 		/* Reject attempt to match a comment. */
 		close(fd);
-		return 0;
+		return "invalid username";
 	}
 
-	/* Try to find a line that starts with the user name and a ':'. */
-	p = user;
-	while (1) {
-		if (read(fd, &ch, 1) != 1) {
-			close(fd);
-			return 0;
+	/* Try to find a line that starts with the user (or @group) name and a ':'. */
+	err = "secret not found";
+	while ((user || group) && read_line_old(fd, line, sizeof line, 1)) {
+		const char **ptr, *s;
+		int len;
+		if (*line == '@') {
+			ptr = &group;
+			len = group_len;
+			s = line+1;
+		} else {
+			ptr = &user;
+			len = user_len;
+			s = line;
 		}
-		if (ch == '\n')
-			p = user;
-		else if (p) {
-			if (*p == ch)
-				p++;
-			else if (!*p && ch == ':')
-				break;
-			else
-				p = NULL;
+		if (!*ptr || strncmp(s, *ptr, len) != 0 || s[len] != ':')
+			continue;
+		generate_hash(s+len+1, challenge, pass2);
+		if (strcmp(pass, pass2) == 0) {
+			err = NULL;
+			break;
 		}
+		err = "password mismatch";
+		*ptr = NULL; /* Don't look for name again. */
 	}
 
-	/* Slurp the secret into the "secret" buffer. */
-	s = secret;
-	while (len > 0) {
-		if (read(fd, s, 1) != 1 || *s == '\n')
-			break;
-		if (*s == '\r')
-			continue;
-		s++;
-		len--;
-	}
-	*s = '\0';
 	close(fd);
 
-	return 1;
+	memset(line, 0, sizeof line);
+	memset(pass2, 0, sizeof pass2);
+
+	return err;
 }
 
 static const char *getpassf(const char *filename)
 {
 	STRUCT_STAT st;
 	char buffer[512], *p;
-	int fd, n;
+	int n;
 
 	if (!filename)
 		return NULL;
 
-	if ((fd = open(filename,O_RDONLY)) < 0) {
-		rsyserr(FERROR, errno, "could not open password file %s", filename);
-		exit_cleanup(RERR_SYNTAX);
-	}
+	if (strcmp(filename, "-") == 0) {
+		n = fgets(buffer, sizeof buffer, stdin) == NULL ? -1 : (int)strlen(buffer);
+	} else {
+		int fd;
+
+		if ((fd = open(filename,O_RDONLY)) < 0) {
+			rsyserr(FERROR, errno, "could not open password file %s", filename);
+			exit_cleanup(RERR_SYNTAX);
+		}
 
-	if (do_stat(filename, &st) == -1) {
-		rsyserr(FERROR, errno, "stat(%s)", filename);
-		exit_cleanup(RERR_SYNTAX);
-	}
-	if ((st.st_mode & 06) != 0) {
-		rprintf(FERROR, "ERROR: password file must not be other-accessible\n");
-		exit_cleanup(RERR_SYNTAX);
-	}
-	if (MY_UID() == 0 && st.st_uid != 0) {
-		rprintf(FERROR, "ERROR: password file must be owned by root when running as root\n");
-		exit_cleanup(RERR_SYNTAX);
+		if (do_stat(filename, &st) == -1) {
+			rsyserr(FERROR, errno, "stat(%s)", filename);
+			exit_cleanup(RERR_SYNTAX);
+		}
+		if ((st.st_mode & 06) != 0) {
+			rprintf(FERROR, "ERROR: password file must not be other-accessible\n");
+			exit_cleanup(RERR_SYNTAX);
+		}
+		if (MY_UID() == 0 && st.st_uid != 0) {
+			rprintf(FERROR, "ERROR: password file must be owned by root when running as root\n");
+			exit_cleanup(RERR_SYNTAX);
+		}
+
+		n = read(fd, buffer, sizeof buffer - 1);
+		close(fd);
 	}
 
-	n = read(fd, buffer, sizeof buffer - 1);
-	close(fd);
 	if (n > 0) {
 		buffer[n] = '\0';
 		if ((p = strtok(buffer, "\n\r")) != NULL)
 			return strdup(p);
 	}
 
 	rprintf(FERROR, "ERROR: failed to read a password from %s\n", filename);
 	exit_cleanup(RERR_SYNTAX);
 }
 
-/* Generate an MD4 hash created from the combination of the password
- * and the challenge string and return it base64-encoded. */
-static void generate_hash(const char *in, const char *challenge, char *out)
-{
-	char buf[MAX_DIGEST_LEN];
-	int len;
-
-	sum_init(0);
-	sum_update(in, strlen(in));
-	sum_update(challenge, strlen(challenge));
-	len = sum_end(buf);
-
-	base64_encode(buf, len, out, 0);
-}
-
 /* Possibly negotiate authentication with the client.  Use "leader" to
  * start off the auth if necessary.
  *
  * Return NULL if authentication failed.  Return "" if anonymous access.
  * Otherwise return username.
  */
 char *auth_server(int f_in, int f_out, int module, const char *host,
 		  const char *addr, const char *leader)
 {
 	char *users = lp_auth_users(module);
 	char challenge[MAX_DIGEST_LEN*2];
 	char line[BIGPATHBUFLEN];
-	char secret[512];
-	char pass2[MAX_DIGEST_LEN*2];
+	char **auth_uid_groups = NULL;
+	int auth_uid_groups_cnt = -1;
+	const char *err = NULL;
+	int group_match = -1;
 	char *tok, *pass;
+	char opt_ch = '\0';
 
 	/* if no auth list then allow anyone in! */
 	if (!users || !*users)
 		return "";
 
 	gen_challenge(addr, challenge);
 
 	io_printf(f_out, "%s%s\n", leader, challenge);
 
-	if (!read_line_old(f_in, line, sizeof line)
+	if (!read_line_old(f_in, line, sizeof line, 0)
 	 || (pass = strchr(line, ' ')) == NULL) {
 		rprintf(FLOG, "auth failed on module %s from %s (%s): "
 			"invalid challenge response\n",
 			lp_name(module), host, addr);
 		return NULL;
 	}
 	*pass++ = '\0';
 
 	if (!(users = strdup(users)))
 		out_of_memory("auth_server");
 
 	for (tok = strtok(users, " ,\t"); tok; tok = strtok(NULL, " ,\t")) {
-		if (wildmatch(tok, line))
-			break;
+		char *opts;
+		/* See if the user appended :deny, :ro, or :rw. */
+		if ((opts = strchr(tok, ':')) != NULL) {
+			*opts++ = '\0';
+			opt_ch = isUpper(opts) ? toLower(opts) : *opts;
+			if (opt_ch == 'r') { /* handle ro and rw */
+				opt_ch = isUpper(opts+1) ? toLower(opts+1) : opts[1];
+				if (opt_ch == 'o')
+					opt_ch = 'r';
+				else if (opt_ch != 'w')
+					opt_ch = '\0';
+			} else if (opt_ch != 'd') /* if it's not deny, ignore it */
+				opt_ch = '\0';
+		} else
+			opt_ch = '\0';
+		if (*tok != '@') {
+			/* Match the username */
+			if (wildmatch(tok, line))
+				break;
+		} else {
+#ifdef HAVE_GETGROUPLIST
+			int j;
+			/* See if authorizing user is a real user, and if so, see
+			 * if it is in a group that matches tok+1 wildmat. */
+			if (auth_uid_groups_cnt < 0) {
+				gid_t gid_list[64];
+				uid_t auth_uid;
+				auth_uid_groups_cnt = sizeof gid_list / sizeof (gid_t);
+				if (!user_to_uid(line, &auth_uid, False)
+				 || getallgroups(auth_uid, gid_list, &auth_uid_groups_cnt) != NULL)
+					auth_uid_groups_cnt = 0;
+				else {
+					if ((auth_uid_groups = new_array(char *, auth_uid_groups_cnt)) == NULL)
+						out_of_memory("auth_server");
+					for (j = 0; j < auth_uid_groups_cnt; j++)
+						auth_uid_groups[j] = gid_to_group(gid_list[j]);
+				}
+			}
+			for (j = 0; j < auth_uid_groups_cnt; j++) {
+				if (auth_uid_groups[j] && wildmatch(tok+1, auth_uid_groups[j])) {
+					group_match = j;
+					break;
+				}
+			}
+			if (group_match >= 0)
+				break;
+#else
+			rprintf(FLOG, "your computer doesn't support getgrouplist(), so no @group authorization is possible.\n");
+#endif
+		}
 	}
+
 	free(users);
 
-	if (!tok) {
-		rprintf(FLOG, "auth failed on module %s from %s (%s): "
-			"unauthorized user\n",
-			lp_name(module), host, addr);
-		return NULL;
+	if (!tok)
+		err = "no matching rule";
+	else if (opt_ch == 'd')
+		err = "denied by rule";
+	else {
+		char *group = group_match >= 0 ? auth_uid_groups[group_match] : NULL;
+		err = check_secret(module, line, group, challenge, pass);
+	}
+
+	memset(challenge, 0, sizeof challenge);
+	memset(pass, 0, strlen(pass));
+
+	if (auth_uid_groups) {
+		int j;
+		for (j = 0; j < auth_uid_groups_cnt; j++) {
+			if (auth_uid_groups[j])
+				free(auth_uid_groups[j]);
+		}
+		free(auth_uid_groups);
 	}
 
-	memset(secret, 0, sizeof secret);
-	if (!get_secret(module, line, secret, sizeof secret - 1)) {
-		memset(secret, 0, sizeof secret);
-		rprintf(FLOG, "auth failed on module %s from %s (%s): "
-			"missing secret for user \"%s\"\n",
-			lp_name(module), host, addr, line);
+	if (err) {
+		rprintf(FLOG, "auth failed on module %s from %s (%s) for %s: %s\n",
+			lp_name(module), host, addr, line, err);
 		return NULL;
 	}
 
-	generate_hash(secret, challenge, pass2);
-	memset(secret, 0, sizeof secret);
-
-	if (strcmp(pass, pass2) != 0) {
-		rprintf(FLOG, "auth failed on module %s from %s (%s): "
-			"password mismatch\n",
-			lp_name(module), host, addr);
-		return NULL;
-	}
+	if (opt_ch == 'r')
+		read_only = 1;
+	else if (opt_ch == 'w')
+		read_only = 0;
 
 	return strdup(line);
 }
 
 void auth_client(int fd, const char *user, const char *challenge)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/backup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/backup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/backup.c	2010-07-04 00:19:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/backup.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Backup handling code.
  *
  * Copyright (C) 1999 Andrew Tridgell
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -16,14 +16,14 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "ifuncs.h"
 
-extern int verbose;
 extern int am_root;
 extern int preserve_acls;
 extern int preserve_xattrs;
 extern int preserve_devices;
 extern int preserve_specials;
 extern int preserve_links;
@@ -31,216 +31,224 @@
 extern int backup_dir_len;
 extern unsigned int backup_dir_remainder;
 extern char backup_dir_buf[MAXPATHLEN];
 extern char *backup_suffix;
 extern char *backup_dir;
 
-/* make a complete pathname for backup file */
-char *get_backup_name(const char *fname)
+/* Returns -1 on error, 0 on missing dir, and 1 on present dir. */
+static int validate_backup_dir(void)
 {
-	if (backup_dir) {
-		if (stringjoin(backup_dir_buf + backup_dir_len, backup_dir_remainder,
-			       fname, backup_suffix, NULL) < backup_dir_remainder)
-			return backup_dir_buf;
-	} else {
-		if (stringjoin(backup_dir_buf, MAXPATHLEN,
-			       fname, backup_suffix, NULL) < MAXPATHLEN)
-			return backup_dir_buf;
-	}
+	STRUCT_STAT st;
 
-	rprintf(FERROR, "backup filename too long\n");
-	return NULL;
-}
-
-/* simple backup creates a backup with a suffix in the same directory */
-static int make_simple_backup(const char *fname)
-{
-	int rename_errno;
-	const char *fnamebak = get_backup_name(fname);
-
-	if (!fnamebak)
-		return 0;
-
-	while (1) {
-		if (do_rename(fname, fnamebak) == 0) {
-			if (verbose > 1) {
-				rprintf(FINFO, "backed up %s to %s\n",
-					fname, fnamebak);
-			}
-			break;
-		}
-		/* cygwin (at least version b19) reports EINVAL */
-		if (errno == ENOENT || errno == EINVAL)
-			break;
-
-		rename_errno = errno;
-		if (errno == EISDIR && do_rmdir(fnamebak) == 0)
-			continue;
-		if (errno == ENOTDIR && do_unlink(fnamebak) == 0)
-			continue;
-
-		rsyserr(FERROR, rename_errno, "rename %s to backup %s",
-			fname, fnamebak);
-		errno = rename_errno;
-		return 0;
+	if (do_lstat(backup_dir_buf, &st) < 0) {
+		if (errno == ENOENT)
+			return 0;
+		rsyserr(FERROR, errno, "backup lstat %s failed", backup_dir_buf);
+		return -1;
+	}
+	if (!S_ISDIR(st.st_mode)) {
+		int flags = get_del_for_flag(st.st_mode) | DEL_FOR_BACKUP | DEL_RECURSE;
+		if (delete_item(backup_dir_buf, st.st_mode, flags) == 0)
+			return 0;
+		return -1;
 	}
-
 	return 1;
 }
 
-
-/****************************************************************************
-Create a directory given an absolute path, perms based upon another directory
-path
-****************************************************************************/
-int make_bak_dir(const char *fullpath)
+/* Create a backup path from the given fname, putting the result into
+ * backup_dir_buf.  Any new directories (compared to the prior backup
+ * path) are ensured to exist as directories, replacing anything else
+ * that may be in the way (e.g. a symlink). */
+static BOOL copy_valid_path(const char *fname)
 {
-	char fbuf[MAXPATHLEN], *rel, *end, *p;
-	struct file_struct *file;
-	int len = backup_dir_len;
+	const char *f;
+	int val;
+	BOOL ret = True;
 	stat_x sx;
+	char *b, *rel = backup_dir_buf + backup_dir_len, *name = rel;
 
-	while (*fullpath == '.' && fullpath[1] == '/') {
-		fullpath += 2;
-		len -= 2;
+	for (f = fname, b = rel; *f && *f == *b; f++, b++) {
+		if (*b == '/')
+			name = b + 1;
 	}
 
-	if (strlcpy(fbuf, fullpath, sizeof fbuf) >= sizeof fbuf)
-		return -1;
+	if (stringjoin(rel, backup_dir_remainder, fname, backup_suffix, NULL) >= backup_dir_remainder) {
+		rprintf(FERROR, "backup filename too long\n");
+		*name = '\0';
+		return False;
+	}
 
-	rel = fbuf + len;
-	end = p = rel + strlen(rel);
+	for ( ; ; name = b + 1) {
+		if ((b = strchr(name, '/')) == NULL)
+			return True;
+		*b = '\0';
 
-	/* Try to find an existing dir, starting from the deepest dir. */
-	while (1) {
-		if (--p == fbuf)
-			return -1;
-		if (*p == '/') {
-			*p = '\0';
-			if (mkdir_defmode(fbuf) == 0)
-				break;
-			if (errno != ENOENT) {
-				rsyserr(FERROR, errno,
-					"make_bak_dir mkdir %s failed",
-					full_fname(fbuf));
-				return -1;
-			}
+		val = validate_backup_dir();
+		if (val == 0)
+			break;
+		if (val < 0) {
+			*name = '\0';
+			return False;
 		}
+
+		*b = '/';
 	}
 
-	/* Make all the dirs that we didn't find on the way here. */
-	while (1) {
-		if (p >= rel) {
-			/* Try to transfer the directory settings of the
-			 * actual dir that the files are coming from. */
-			if (x_stat(rel, &sx.st, NULL) < 0) {
-				rsyserr(FERROR, errno,
-					"make_bak_dir stat %s failed",
-					full_fname(rel));
-			} else {
-#ifdef SUPPORT_ACLS
-				sx.acc_acl = sx.def_acl = NULL;
-#endif
-#ifdef SUPPORT_XATTRS
-				sx.xattr = NULL;
-#endif
-				if (!(file = make_file(rel, NULL, NULL, 0, NO_FILTERS)))
+	init_stat_x(&sx);
+
+	for ( ; b; name = b + 1, b = strchr(name, '/')) {
+		*b = '\0';
+
+		while (do_mkdir(backup_dir_buf, ACCESSPERMS) < 0) {
+			if (errno == EEXIST) {
+				val = validate_backup_dir();
+				if (val > 0)
+					break;
+				if (val == 0)
 					continue;
+			} else
+				rsyserr(FERROR, errno, "backup mkdir %s failed", backup_dir_buf);
+			*name = '\0';
+			ret = False;
+			goto cleanup;
+		}
+
+		/* Try to transfer the directory settings of the actual dir
+		 * that the files are coming from. */
+		if (x_stat(rel, &sx.st, NULL) < 0)
+			rsyserr(FERROR, errno, "backup stat %s failed", full_fname(rel));
+		else {
+			struct file_struct *file;
+			if (!(file = make_file(rel, NULL, NULL, 0, NO_FILTERS)))
+				continue;
 #ifdef SUPPORT_ACLS
-				if (preserve_acls && !S_ISLNK(file->mode)) {
-					get_acl(rel, &sx);
-					cache_tmp_acl(file, &sx);
-					free_acl(&sx);
-				}
+			if (preserve_acls && !S_ISLNK(file->mode)) {
+				get_acl(rel, &sx);
+				cache_tmp_acl(file, &sx);
+				free_acl(&sx);
+			}
 #endif
 #ifdef SUPPORT_XATTRS
-				if (preserve_xattrs) {
-					get_xattr(rel, &sx);
-					cache_tmp_xattr(file, &sx);
-					free_xattr(&sx);
-				}
+			if (preserve_xattrs) {
+				get_xattr(rel, &sx);
+				cache_tmp_xattr(file, &sx);
+				free_xattr(&sx);
+			}
 #endif
-				set_file_attrs(fbuf, file, NULL, NULL, 0);
-				unmake_file(file);
+			set_file_attrs(backup_dir_buf, file, NULL, NULL, 0);
+			unmake_file(file);
+		}
+
+		*b = '/';
+	}
+
+  cleanup:
+
 #ifdef SUPPORT_ACLS
-				uncache_tmp_acls();
+	uncache_tmp_acls();
 #endif
 #ifdef SUPPORT_XATTRS
-				uncache_tmp_xattrs();
+	uncache_tmp_xattrs();
 #endif
-			}
-		}
-		*p = '/';
-		p += strlen(p);
-		if (p == end)
-			break;
-		if (mkdir_defmode(fbuf) < 0) {
-			rsyserr(FERROR, errno, "make_bak_dir mkdir %s failed",
-				full_fname(fbuf));
-			return -1;
-		}
+
+	return ret;
+}
+
+/* Make a complete pathname for backup file and verify any new path elements. */
+char *get_backup_name(const char *fname)
+{
+	if (backup_dir) {
+		/* copy fname into backup_dir_buf while validating the dirs. */
+		if (copy_valid_path(fname))
+			return backup_dir_buf;
+		/* copy_valid_path() has printed an error message. */
+		return NULL;
 	}
 
-	return 0;
+	if (stringjoin(backup_dir_buf, MAXPATHLEN, fname, backup_suffix, NULL) < MAXPATHLEN)
+		return backup_dir_buf;
+
+	rprintf(FERROR, "backup filename too long\n");
+	return NULL;
 }
 
-/* robustly move a file, creating new directory structures if necessary */
-static int robust_move(const char *src, char *dst)
+/* Has same return codes as make_backup(). */
+static inline int link_or_rename(const char *from, const char *to,
+				 BOOL prefer_rename, STRUCT_STAT *stp)
 {
-	if (robust_rename(src, dst, NULL, 0755) < 0) {
-		int save_errno = errno ? errno : EINVAL; /* 0 paranoia */
-		if (errno == ENOENT && make_bak_dir(dst) == 0) {
-			if (robust_rename(src, dst, NULL, 0755) < 0)
-				save_errno = errno ? errno : save_errno;
-			else
-				save_errno = 0;
-		}
-		if (save_errno) {
-			errno = save_errno;
-			return -1;
+#ifdef SUPPORT_HARD_LINKS
+	if (!prefer_rename) {
+#ifndef CAN_HARDLINK_SYMLINK
+		if (S_ISLNK(stp->st_mode))
+			return 0; /* Use copy code. */
+#endif
+#ifndef CAN_HARDLINK_SPECIAL
+		if (IS_SPECIAL(stp->st_mode) || IS_DEVICE(stp->st_mode))
+			return 0; /* Use copy code. */
+#endif
+		if (do_link(from, to) == 0) {
+			if (DEBUG_GTE(BACKUP, 1))
+				rprintf(FINFO, "make_backup: HLINK %s successful.\n", from);
+			return 2;
+		}
+		/* We prefer to rename a regular file rather than copy it. */
+		if (!S_ISREG(stp->st_mode) || errno == EEXIST || errno == EISDIR)
+			return 0;
+	}
+#endif
+	if (do_rename(from, to) == 0) {
+		if (stp->st_nlink > 1 && !S_ISDIR(stp->st_mode)) {
+			/* If someone has hard-linked the file into the backup
+			 * dir, rename() might return success but do nothing! */
+			robust_unlink(from); /* Just in case... */
 		}
+		if (DEBUG_GTE(BACKUP, 1))
+			rprintf(FINFO, "make_backup: RENAME %s successful.\n", from);
+		return 1;
 	}
 	return 0;
 }
 
-
-/* If we have a --backup-dir, then we get here from make_backup().
- * We will move the file to be deleted into a parallel directory tree. */
-static int keep_backup(const char *fname)
+/* Hard-link, rename, or copy an item to the backup name.  Returns 2 if item
+ * was duplicated into backup area, 1 if item was moved, or 0 for failure.*/
+int make_backup(const char *fname, BOOL prefer_rename)
 {
 	stat_x sx;
 	struct file_struct *file;
-	char *buf;
-	int save_preserve_xattrs = preserve_xattrs;
-	int kept = 0;
-	int ret_code;
+	int save_preserve_xattrs;
+	char *buf = get_backup_name(fname);
+	int ret = 0;
 
-	/* return if no file to keep */
+	if (!buf)
+		return 0;
+
+	init_stat_x(&sx);
+	/* Return success if no file to keep. */
 	if (x_lstat(fname, &sx.st, NULL) < 0)
 		return 1;
-#ifdef SUPPORT_ACLS
-	sx.acc_acl = sx.def_acl = NULL;
-#endif
-#ifdef SUPPORT_XATTRS
-	sx.xattr = NULL;
-#endif
 
-	if (!(file = make_file(fname, NULL, NULL, 0, NO_FILTERS)))
-		return 1; /* the file could have disappeared */
-
-	if (!(buf = get_backup_name(fname))) {
-		unmake_file(file);
-#ifdef SUPPORT_ACLS
-		uncache_tmp_acls();
-#endif
-#ifdef SUPPORT_XATTRS
-		uncache_tmp_xattrs();
-#endif
-		return 0;
+	/* Try a hard-link or a rename first.  Using rename is not atomic, but
+	 * is more efficient than forcing a copy for larger files when no hard-
+	 * linking is possible. */
+	if ((ret = link_or_rename(fname, buf, prefer_rename, &sx.st)) != 0)
+		goto success;
+	if (errno == EEXIST || errno == EISDIR) {
+		STRUCT_STAT bakst;
+		if (do_lstat(buf, &bakst) == 0) {
+			int flags = get_del_for_flag(bakst.st_mode) | DEL_FOR_BACKUP | DEL_RECURSE;
+			if (delete_item(buf, bakst.st_mode, flags) != 0)
+				return 0;
+		}
+		if ((ret = link_or_rename(fname, buf, prefer_rename, &sx.st)) != 0)
+			goto success;
 	}
 
+	/* Fall back to making a copy. */
+	if (!(file = make_file(fname, NULL, &sx.st, 0, NO_FILTERS)))
+		return 1; /* the file could have disappeared */
+
 #ifdef SUPPORT_ACLS
 	if (preserve_acls && !S_ISLNK(file->mode)) {
 		get_acl(fname, &sx);
 		cache_tmp_acl(file, &sx);
 		free_acl(&sx);
 	}
@@ -253,117 +261,74 @@
 	}
 #endif
 
 	/* Check to see if this is a device file, or link */
 	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
 	 || (preserve_specials && IS_SPECIAL(file->mode))) {
-		int save_errno;
-		do_unlink(buf);
-		if (do_mknod(buf, file->mode, sx.st.st_rdev) < 0) {
-			save_errno = errno ? errno : EINVAL; /* 0 paranoia */
-			if (errno == ENOENT && make_bak_dir(buf) == 0) {
-				if (do_mknod(buf, file->mode, sx.st.st_rdev) < 0)
-					save_errno = errno ? errno : save_errno;
-				else
-					save_errno = 0;
-			}
-			if (save_errno) {
-				rsyserr(FERROR, save_errno, "mknod %s failed",
-					full_fname(buf));
-			}
-		} else
-			save_errno = 0;
-		if (verbose > 2 && save_errno == 0) {
-			rprintf(FINFO, "make_backup: DEVICE %s successful.\n",
-				fname);
-		}
-		kept = 1;
-		do_unlink(fname);
-	}
-
-	if (!kept && S_ISDIR(file->mode)) {
-		/* make an empty directory */
-		if (do_mkdir(buf, file->mode) < 0) {
-			int save_errno = errno ? errno : EINVAL; /* 0 paranoia */
-			if (errno == ENOENT && make_bak_dir(buf) == 0) {
-				if (do_mkdir(buf, file->mode) < 0)
-					save_errno = errno ? errno : save_errno;
-				else
-					save_errno = 0;
-			}
-			if (save_errno) {
-				rsyserr(FINFO, save_errno, "mkdir %s failed",
-					full_fname(buf));
-			}
-		}
-
-		ret_code = do_rmdir(fname);
-		if (verbose > 2) {
-			rprintf(FINFO, "make_backup: RMDIR %s returns %i\n",
-				full_fname(fname), ret_code);
-		}
-		kept = 1;
+		if (do_mknod(buf, file->mode, sx.st.st_rdev) < 0)
+			rsyserr(FERROR, errno, "mknod %s failed", full_fname(buf));
+		else if (DEBUG_GTE(BACKUP, 1))
+			rprintf(FINFO, "make_backup: DEVICE %s successful.\n", fname);
+		ret = 2;
 	}
 
 #ifdef SUPPORT_LINKS
-	if (!kept && preserve_links && S_ISLNK(file->mode)) {
+	if (!ret && preserve_links && S_ISLNK(file->mode)) {
 		const char *sl = F_SYMLINK(file);
 		if (safe_symlinks && unsafe_symlink(sl, fname)) {
-			if (verbose) {
+			if (INFO_GTE(SYMSAFE, 1)) {
 				rprintf(FINFO, "not backing up unsafe symlink \"%s\" -> \"%s\"\n",
 					fname, sl);
 			}
-			kept = 1;
+			ret = 2;
 		} else {
-			do_unlink(buf);
-			if (do_symlink(sl, buf) < 0) {
-				int save_errno = errno ? errno : EINVAL; /* 0 paranoia */
-				if (errno == ENOENT && make_bak_dir(buf) == 0) {
-					if (do_symlink(sl, buf) < 0)
-						save_errno = errno ? errno : save_errno;
-					else
-						save_errno = 0;
-				}
-				if (save_errno) {
-					rsyserr(FERROR, save_errno, "link %s -> \"%s\"",
-						full_fname(buf), sl);
-				}
-			}
-			do_unlink(fname);
-			kept = 1;
+			if (do_symlink(sl, buf) < 0)
+				rsyserr(FERROR, errno, "link %s -> \"%s\"", full_fname(buf), sl);
+			else if (DEBUG_GTE(BACKUP, 1))
+				rprintf(FINFO, "make_backup: SYMLINK %s successful.\n", fname);
+			ret = 2;
 		}
 	}
 #endif
 
-	if (!kept && !S_ISREG(file->mode)) {
-		rprintf(FINFO, "make_bak: skipping non-regular file %s\n",
-			fname);
+	if (!ret && !S_ISREG(file->mode)) {
+		rprintf(FINFO, "make_bak: skipping non-regular file %s\n", fname);
 		unmake_file(file);
 #ifdef SUPPORT_ACLS
 		uncache_tmp_acls();
 #endif
 #ifdef SUPPORT_XATTRS
 		uncache_tmp_xattrs();
 #endif
-		return 1;
+		return 2;
 	}
 
-	/* move to keep tree if a file */
-	if (!kept) {
-		if (robust_move(fname, buf) != 0) {
+	/* Copy to backup tree if a file. */
+	if (!ret) {
+		if (copy_file(fname, buf, -1, file->mode) < 0) {
 			rsyserr(FERROR, errno, "keep_backup failed: %s -> \"%s\"",
 				full_fname(fname), buf);
-		} else if (sx.st.st_nlink > 1) {
-			/* If someone has hard-linked the file into the backup
-			 * dir, rename() might return success but do nothing! */
-			robust_unlink(fname); /* Just in case... */
+			unmake_file(file);
+#ifdef SUPPORT_ACLS
+			uncache_tmp_acls();
+#endif
+#ifdef SUPPORT_XATTRS
+			uncache_tmp_xattrs();
+#endif
+			return 0;
 		}
+		if (DEBUG_GTE(BACKUP, 1))
+			rprintf(FINFO, "make_backup: COPY %s successful.\n", fname);
+		ret = 2;
 	}
+
+	save_preserve_xattrs = preserve_xattrs;
 	preserve_xattrs = 0;
 	set_file_attrs(buf, file, NULL, fname, 0);
 	preserve_xattrs = save_preserve_xattrs;
+
 	unmake_file(file);
 #ifdef SUPPORT_ACLS
 	uncache_tmp_acls();
 #endif
 #ifdef SUPPORT_XATTRS
 	uncache_tmp_xattrs();
@@ -366,21 +331,11 @@
 	uncache_tmp_acls();
 #endif
 #ifdef SUPPORT_XATTRS
 	uncache_tmp_xattrs();
 #endif
 
-	if (verbose > 1) {
-		rprintf(FINFO, "backed up %s to %s\n",
-			fname, buf);
-	}
-	return 1;
-}
-
-
-/* main backup switch routine */
-int make_backup(const char *fname)
-{
-	if (backup_dir)
-		return keep_backup(fname);
-	return make_simple_backup(fname);
+  success:
+	if (INFO_GTE(BACKUP, 1))
+		rprintf(FINFO, "backed up %s to %s\n", fname, buf);
+	return ret;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/batch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/batch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/batch.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/batch.c	2013-05-20 06:01:29.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Support for the batch-file options.
  *
  * Copyright (C) 1999 Weiss
  * Copyright (C) 2004 Chris Shoemaker
- * Copyright (C) 2004-2009 Wayne Davison
+ * Copyright (C) 2004-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,13 +17,13 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
-#include "zlib/zlib.h"
+#include <zlib.h>
 #include <time.h>
 
 extern int eol_nulls;
 extern int recurse;
 extern int xfer_dirs;
 extern int preserve_links;
@@ -40,13 +40,13 @@
 extern int protocol_version;
 extern char *batch_name;
 #ifdef ICONV_OPTION
 extern char *iconv_opt;
 #endif
 
-extern struct filter_list_struct filter_list;
+extern filter_rule_list filter_list;
 
 int batch_stream_flags;
 
 static int tweaked_append;
 static int tweaked_append_verify;
 static int tweaked_iconv;
@@ -132,13 +132,13 @@
 			if (i == 9) {
 				rprintf(FERROR,
 					"%s specify the --iconv option to use this batch file.\n",
 					set ? "Please" : "Do not");
 				exit_cleanup(RERR_SYNTAX);
 			}
-			if (verbose) {
+			if (INFO_GTE(MISC, 1)) {
 				rprintf(FINFO,
 					"%sing the %s option to match the batchfile.\n",
 					set ? "Sett" : "Clear", flag_name[i]);
 			}
 			*flag_ptr[i] = set;
 		}
@@ -188,21 +188,21 @@
 
 	return ret;
 }
 
 static void write_filter_rules(int fd)
 {
-	struct filter_struct *ent;
+	filter_rule *ent;
 
 	write_sbuf(fd, " <<'#E#'\n");
 	for (ent = filter_list.head; ent; ent = ent->next) {
 		unsigned int plen;
-		char *p = get_rule_prefix(ent->match_flags, "- ", 0, &plen);
+		char *p = get_rule_prefix(ent, "- ", 0, &plen);
 		write_buf(fd, p, plen);
 		write_sbuf(fd, ent->pattern);
-		if (ent->match_flags & MATCHFLG_DIRECTORY)
+		if (ent->rflags & FILTRULE_DIRECTORY)
 			write_byte(fd, '/');
 		write_byte(fd, eol_nulls ? 0 : '\n');
 	}
 	if (eol_nulls)
 		write_sbuf(fd, ";\n");
 	write_sbuf(fd, "#E#");
@@ -218,13 +218,13 @@
 	int fd, i, len, err = 0;
 	char *p, filename[MAXPATHLEN];
 
 	stringjoin(filename, sizeof filename,
 		   batch_name, ".sh", NULL);
 	fd = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-		     S_IRUSR | S_IWUSR | S_IEXEC);
+		     S_IRUSR | S_IWUSR | S_IXUSR);
 	if (fd < 0) {
 		rsyserr(FERROR, errno, "Batch file %s open error",
 			filename);
 		exit_cleanup(RERR_FILESELECT);
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/byteorder.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/byteorder.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/byteorder.h	2009-12-13 09:24:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/byteorder.h	2013-01-20 03:05:53.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Simple byteorder handling.
  *
  * Copyright (C) 1992-1995 Andrew Tridgell
- * Copyright (C) 2007-2008 Wayne Davison
+ * Copyright (C) 2007-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/case_N.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/case_N.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/case_N.h	2011-02-22 02:20:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/case_N.h	2013-01-20 03:05:53.000000000 +0800
@@ -1,10 +1,10 @@
 /*
  * Allow an arbitrary sequence of case labels.
  *
- * Copyright (C) 2006-2010 Wayne Davison
+ * Copyright (C) 2006-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/checksum.c	2010-07-01 00:17:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/checksum.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Routines to support checksumming of bytes.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2004-2009 Wayne Davison
+ * Copyright (C) 2004-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/chmod.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/chmod.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/chmod.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/chmod.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Implement the core of the --chmod option.
  *
  * Copyright (C) 2002 Scott Howard
- * Copyright (C) 2005-2009 Wayne Davison
+ * Copyright (C) 2005-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -16,12 +16,13 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "itypes.h"
 
 extern mode_t orig_umask;
 
 #define FLAG_X_KEEP (1<<0)
 #define FLAG_DIRS_ONLY (1<<1)
 #define FLAG_FILES_ONLY (1<<2)
@@ -32,16 +33,18 @@
 	char flags;
 };
 
 #define CHMOD_ADD 1
 #define CHMOD_SUB 2
 #define CHMOD_EQ  3
+#define CHMOD_SET 4
 
 #define STATE_ERROR 0
 #define STATE_1ST_HALF 1
 #define STATE_2ND_HALF 2
+#define STATE_OCTAL_NUM 3
 
 /* Parse a chmod-style argument, and break it down into one or more AND/OR
  * pairs in a linked list.  We return a pointer to new items on succcess
  * (appending the items to the specified list), or NULL on error. */
 struct chmod_mode_struct *parse_chmod(const char *modestr,
 				      struct chmod_mode_struct **root_mode_ptr)
@@ -84,25 +87,30 @@
 				curr_mode->ModeOR  = 0;
 				break;
 			case CHMOD_EQ:
 				curr_mode->ModeAND = CHMOD_BITS - (where * 7) - (topoct ? topbits : 0);
 				curr_mode->ModeOR  = bits + topoct;
 				break;
+			case CHMOD_SET:
+				curr_mode->ModeAND = 0;
+				curr_mode->ModeOR  = bits;
+				break;
 			}
 
 			curr_mode->flags = flags;
 
 			if (!*modestr)
 				break;
 			modestr++;
 
 			state = STATE_1ST_HALF;
 			where = what = op = topoct = topbits = flags = 0;
 		}
 
-		if (state != STATE_2ND_HALF) {
+		switch (state) {
+		case STATE_1ST_HALF:
 			switch (*modestr) {
 			case 'D':
 				if (flags & FLAG_FILES_ONLY)
 					state = STATE_ERROR;
 				flags |= FLAG_DIRS_ONLY;
 				break;
@@ -135,16 +143,23 @@
 				break;
 			case '=':
 				op = CHMOD_EQ;
 				state = STATE_2ND_HALF;
 				break;
 			default:
-				state = STATE_ERROR;
+				if (isDigit(modestr) && *modestr < '8' && !where) {
+					op = CHMOD_SET;
+					state =  STATE_OCTAL_NUM;
+					where = 1;
+					what = *modestr - '0';
+				} else
+					state = STATE_ERROR;
 				break;
 			}
-		} else {
+			break;
+		case STATE_2ND_HALF:
 			switch (*modestr) {
 			case 'r':
 				what |= 4;
 				break;
 			case 'w':
 				what |= 2;
@@ -165,12 +180,21 @@
 				topoct |= 01000;
 				break;
 			default:
 				state = STATE_ERROR;
 				break;
 			}
+			break;
+		case STATE_OCTAL_NUM:
+			if (isDigit(modestr) && *modestr < '8') {
+				what = what*8 + *modestr - '0';
+				if (what > CHMOD_BITS)
+					state = STATE_ERROR;
+			} else
+				state = STATE_ERROR;
+			break;
 		}
 		modestr++;
 	}
 
 	if (state == STATE_ERROR) {
 		free_chmod_mode(first_mode);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/cleanup.c	2011-02-22 02:20:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/cleanup.c	2013-09-29 01:40:27.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * End-of-run cleanup routines.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -25,15 +25,20 @@
 extern int am_server;
 extern int am_daemon;
 extern int am_receiver;
 extern int io_error;
 extern int keep_partial;
 extern int got_xfer_error;
+extern int protocol_version;
+extern int output_needs_newline;
 extern char *partial_dir;
 extern char *logfile_name;
 
+BOOL shutting_down = False;
+BOOL flush_ok_after_signal = False;
+
 #ifdef HAVE_SIGACTION
 static struct sigaction sigact;
 #endif
 
 /**
  * Close all open sockets and files, allowing a (somewhat) graceful
@@ -79,13 +84,13 @@
  **/
 int cleanup_got_literal = 0;
 
 static const char *cleanup_fname;
 static const char *cleanup_new_fname;
 static struct file_struct *cleanup_file;
-static int cleanup_fd_r, cleanup_fd_w;
+static int cleanup_fd_r = -1, cleanup_fd_w = -1;
 static pid_t cleanup_pid = 0;
 
 pid_t cleanup_child_pid = -1;
 
 /**
  * Eventually calls exit(), passing @p code, therefore does not return.
@@ -94,21 +99,21 @@
  **/
 NORETURN void _exit_cleanup(int code, const char *file, int line)
 {
 	static int switch_step = 0;
 	static int exit_code = 0, exit_line = 0;
 	static const char *exit_file = NULL;
-	static int unmodified_code = 0;
+	static int first_code = 0;
 
 	SIGACTION(SIGUSR1, SIG_IGN);
 	SIGACTION(SIGUSR2, SIG_IGN);
 
-	if (exit_code) { /* Preserve first exit info when recursing. */
-		code = exit_code;
-		file = exit_file;
-		line = exit_line;
+	if (!exit_code) { /* Preserve first error exit info when recursing. */
+		exit_code = code;
+		exit_file = file;
+		exit_line = line < 0 ? -line : line;
 	}
 
 	/* If this is the exit at the end of the run, the server side
 	 * should not attempt to output a message (see log_exit()). */
 	if (am_server && code == 0)
 		am_server = 2;
@@ -116,17 +121,20 @@
 	/* Some of our actions might cause a recursive call back here, so we
 	 * keep track of where we are in the cleanup and never repeat a step. */
 	switch (switch_step) {
 #include "case_N.h" /* case 0: */
 		switch_step++;
 
-		exit_code = unmodified_code = code;
-		exit_file = file;
-		exit_line = line;
+		first_code = code;
+
+		if (output_needs_newline) {
+			fputc('\n', stdout);
+			output_needs_newline = 0;
+		}
 
-		if (verbose > 3) {
+		if (DEBUG_GTE(EXIT, 2)) {
 			rprintf(FINFO,
 				"[%s] _exit_cleanup(code=%d, file=%s, line=%d): entered\n",
 				who_am_i(), code, file, line);
 		}
 
 		/* FALLTHROUGH */
@@ -135,98 +143,138 @@
 
 		if (cleanup_child_pid != -1) {
 			int status;
 			int pid = wait_process(cleanup_child_pid, &status, WNOHANG);
 			if (pid == cleanup_child_pid) {
 				status = WEXITSTATUS(status);
-				if (status > code)
-					code = exit_code = status;
+				if (status > exit_code)
+					exit_code = status;
 			}
 		}
 
 		/* FALLTHROUGH */
 #include "case_N.h"
 		switch_step++;
 
-		if (cleanup_got_literal && cleanup_fname && cleanup_new_fname
-		 && keep_partial && handle_partial_dir(cleanup_new_fname, PDIR_CREATE)) {
+		if (cleanup_got_literal && (cleanup_fname || cleanup_fd_w != -1)) {
 			const char *fname = cleanup_fname;
 			cleanup_fname = NULL;
-			if (cleanup_fd_r != -1)
+			if (cleanup_fd_r != -1) {
 				close(cleanup_fd_r);
+				cleanup_fd_r = -1;
+			}
 			if (cleanup_fd_w != -1) {
 				flush_write_file(cleanup_fd_w);
 				close(cleanup_fd_w);
+				cleanup_fd_w = -1;
+			}
+			if (fname && cleanup_new_fname && keep_partial
+			 && handle_partial_dir(cleanup_new_fname, PDIR_CREATE)) {
+				int tweak_modtime = 0;
+				if (!partial_dir) {
+				    /* We don't want to leave a partial file with a modern time or it
+				     * could be skipped via --update.  Setting the time to something
+				     * really old also helps it to stand out as unfinished in an ls. */
+				    tweak_modtime = 1;
+				    cleanup_file->modtime = 0;
+				}
+				finish_transfer(cleanup_new_fname, fname, NULL, NULL,
+						cleanup_file, tweak_modtime, !partial_dir);
 			}
-			finish_transfer(cleanup_new_fname, fname, NULL, NULL,
-					cleanup_file, 0, !partial_dir);
 		}
 
 		/* FALLTHROUGH */
 #include "case_N.h"
 		switch_step++;
 
-		if (!code || am_server || am_receiver)
+		if (flush_ok_after_signal) {
+			flush_ok_after_signal = False;
+			if (code == RERR_SIGNAL)
+				io_flush(FULL_FLUSH);
+		}
+		if (!exit_code && !code)
 			io_flush(FULL_FLUSH);
 
 		/* FALLTHROUGH */
 #include "case_N.h"
 		switch_step++;
 
 		if (cleanup_fname)
 			do_unlink(cleanup_fname);
-		if (code)
+		if (exit_code)
 			kill_all(SIGUSR1);
 		if (cleanup_pid && cleanup_pid == getpid()) {
 			char *pidf = lp_pid_file();
 			if (pidf && *pidf)
 				unlink(lp_pid_file());
 		}
 
-		if (code == 0) {
+		if (exit_code == 0) {
+			if (code)
+				exit_code = code;
 			if (io_error & IOERR_DEL_LIMIT)
-				code = exit_code = RERR_DEL_LIMIT;
+				exit_code = RERR_DEL_LIMIT;
 			if (io_error & IOERR_VANISHED)
-				code = exit_code = RERR_VANISHED;
+				exit_code = RERR_VANISHED;
 			if (io_error & IOERR_GENERAL || got_xfer_error)
-				code = exit_code = RERR_PARTIAL;
+				exit_code = RERR_PARTIAL;
 		}
 
-		if (code || am_daemon || (logfile_name && (am_server || !verbose)))
-			log_exit(code, file, line);
+		/* If line < 0, this exit is after a MSG_ERROR_EXIT event, so
+		 * we don't want to output a duplicate error. */
+		if ((exit_code && line > 0)
+		 || am_daemon || (logfile_name && (am_server || !INFO_GTE(STATS, 1))))
+			log_exit(exit_code, exit_file, exit_line);
 
 		/* FALLTHROUGH */
 #include "case_N.h"
 		switch_step++;
 
-		if (verbose > 2) {
+		if (DEBUG_GTE(EXIT, 1)) {
 			rprintf(FINFO,
 				"[%s] _exit_cleanup(code=%d, file=%s, line=%d): "
 				"about to call exit(%d)\n",
-				who_am_i(), unmodified_code, file, line, code);
+				who_am_i(), first_code, exit_file, exit_line, exit_code);
+		}
+
+		/* FALLTHROUGH */
+#include "case_N.h"
+		switch_step++;
+
+		if (exit_code && exit_code != RERR_SOCKETIO && exit_code != RERR_STREAMIO && exit_code != RERR_SIGNAL1
+		 && exit_code != RERR_TIMEOUT && !shutting_down && (protocol_version >= 31 || am_receiver)) {
+			if (line > 0) {
+				if (DEBUG_GTE(EXIT, 3)) {
+					rprintf(FINFO, "[%s] sending MSG_ERROR_EXIT with exit_code %d\n",
+						who_am_i(), exit_code);
+				}
+				send_msg_int(MSG_ERROR_EXIT, exit_code);
+			}
+			noop_io_until_death();
 		}
 
 		/* FALLTHROUGH */
 #include "case_N.h"
 		switch_step++;
 
-		if (am_server && code)
+		if (am_server && exit_code)
 			msleep(100);
 		close_all();
 
 		/* FALLTHROUGH */
 	default:
 		break;
 	}
 
-	exit(code);
+	exit(exit_code);
 }
 
 void cleanup_disable(void)
 {
 	cleanup_fname = cleanup_new_fname = NULL;
+	cleanup_fd_r = cleanup_fd_w = -1;
 	cleanup_got_literal = 0;
 }
 
 
 void cleanup_set(const char *fnametmp, const char *fname, struct file_struct *file,
 		 int fd_r, int fd_w)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/clientname.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/clientname.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/clientname.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/clientname.c	2013-07-13 06:24:58.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Functions for looking up the remote name or addr of a socket.
  *
  * Copyright (C) 1992-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2002-2009 Wayne Davison
+ * Copyright (C) 2002-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -38,25 +38,27 @@
 char *client_addr(int fd)
 {
 	static char addr_buf[100];
 	static int initialised;
 	struct sockaddr_storage ss;
 	socklen_t length = sizeof ss;
-	char *ssh_info, *p;
 
 	if (initialised)
 		return addr_buf;
 
 	initialised = 1;
 
 	if (am_server) {	/* daemon over --rsh mode */
+		char *env_str;
 		strlcpy(addr_buf, "0.0.0.0", sizeof addr_buf);
-		if ((ssh_info = getenv("SSH_CONNECTION")) != NULL
-		    || (ssh_info = getenv("SSH_CLIENT")) != NULL
-		    || (ssh_info = getenv("SSH2_CLIENT")) != NULL) {
-			strlcpy(addr_buf, ssh_info, sizeof addr_buf);
+		if ((env_str = getenv("REMOTE_HOST")) != NULL
+		 || (env_str = getenv("SSH_CONNECTION")) != NULL
+		 || (env_str = getenv("SSH_CLIENT")) != NULL
+		 || (env_str = getenv("SSH2_CLIENT")) != NULL) {
+			char *p;
+			strlcpy(addr_buf, env_str, sizeof addr_buf);
 			/* Truncate the value to just the IP address. */
 			if ((p = strchr(addr_buf, ' ')) != NULL)
 				*p = '\0';
 		}
 	} else {
 		client_sockaddr(fd, &ss, &length);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/clientserver.c	2011-07-17 07:14:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/clientserver.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * The socket based protocol for setting up a connection with rsyncd.
  *
  * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2001-2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2002-2009 Wayne Davison
+ * Copyright (C) 2002-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,16 +17,15 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
-#include "ifuncs.h"
+#include "itypes.h"
 
 extern int quiet;
-extern int verbose;
 extern int dry_run;
 extern int output_motd;
 extern int list_only;
 extern int am_sender;
 extern int am_server;
 extern int am_daemon;
@@ -34,40 +33,41 @@
 extern int rsync_port;
 extern int protect_args;
 extern int ignore_errors;
 extern int preserve_xattrs;
 extern int kluge_around_eof;
 extern int daemon_over_rsh;
+extern int munge_symlinks;
 extern int sanitize_paths;
 extern int numeric_ids;
 extern int filesfrom_fd;
 extern int remote_protocol;
 extern int protocol_version;
 extern int io_timeout;
 extern int no_detach;
 extern int write_batch;
 extern int default_af_hint;
 extern int logfile_format_has_i;
 extern int logfile_format_has_o_or_i;
-extern mode_t orig_umask;
 extern char *bind_address;
 extern char *config_file;
 extern char *logfile_format;
 extern char *files_from;
 extern char *tmpdir;
 extern struct chmod_mode_struct *chmod_modes;
-extern struct filter_list_struct daemon_filter_list;
+extern filter_rule_list daemon_filter_list;
 #ifdef ICONV_OPTION
 extern char *iconv_opt;
 extern iconv_t ic_send, ic_recv;
 #endif
 
+#define MAX_GID_LIST 32
+
 char *auth_user;
 int read_only = 0;
 int module_id = -1;
-int munge_symlinks = 0;
 struct chmod_mode_struct *daemon_chmod_modes;
 
 /* module_dirlen is the length of the module_dir string when in daemon
  * mode and module_dir is not "/"; otherwise 0.  (Note that a chroot-
  * enabled module can have a non-"/" module_dir these days.) */
 char *module_dir = NULL;
@@ -78,12 +78,18 @@
 static int rl_nulls = 0;
 
 #ifdef HAVE_SIGACTION
 static struct sigaction sigact;
 #endif
 
+static gid_t gid_list[MAX_GID_LIST];
+static int gid_count = 0;
+
+/* Used when "reverse lookup" is off. */
+const char undetermined_hostname[] = "UNDETERMINED";
+
 /**
  * Run a client connected to an rsyncd.  The alternative to this
  * function for remote-shell connections is do_cmd().
  *
  * After negotiating which module to use and reading the server's
  * motd, this hands over to client_run().  Telling the server the
@@ -155,13 +161,13 @@
 				fclose(f);
 			write_sbuf(f_out, "\n");
 		}
 	}
 
 	/* This strips the \n. */
-	if (!read_line_old(f_in, buf, bufsiz)) {
+	if (!read_line_old(f_in, buf, bufsiz, 0)) {
 		if (am_client)
 			rprintf(FERROR, "rsync: did not see server greeting\n");
 		return -1;
 	}
 
 	if (sscanf(buf, "@RSYNCD: %d.%d", &remote_protocol, &remote_sub) < 1) {
@@ -267,23 +273,23 @@
 		argv++;
 		argc--;
 	}
 
 	sargs[sargc] = NULL;
 
-	if (verbose > 1)
+	if (DEBUG_GTE(CMD, 1))
 		print_child_argv("sending daemon args:", sargs);
 
 	io_printf(f_out, "%.*s\n", modlen, modname);
 
 	/* Old servers may just drop the connection here,
 	 rather than sending a proper EXIT command.  Yuck. */
 	kluge_around_eof = list_only && protocol_version < 25 ? 1 : 0;
 
 	while (1) {
-		if (!read_line_old(f_in, line, sizeof line)) {
+		if (!read_line_old(f_in, line, sizeof line, 0)) {
 			rprintf(FERROR, "rsync: didn't get server startup line\n");
 			return -1;
 		}
 
 		if (strncmp(line,"@RSYNCD: AUTHREQD ",18) == 0) {
 			auth_client(f_out, user, line+18);
@@ -331,108 +337,208 @@
 
 	if (protect_args)
 		send_protected_args(f_out, sargs);
 
 	if (protocol_version < 23) {
 		if (protocol_version == 22 || !am_sender)
-			io_start_multiplex_in();
+			io_start_multiplex_in(f_in);
 	}
 
 	free(modname);
 
 	return 0;
 }
 
-static char *finish_pre_exec(pid_t pid, int fd, char *request,
+static char *finish_pre_exec(pid_t pid, int write_fd, int read_fd, char *request,
 			     char **early_argv, char **argv)
 {
-	int j = 0, status = -1;
+	char buf[BIGPATHBUFLEN], *bp;
+	int j = 0, status = -1, msglen = sizeof buf - 1;
 
 	if (!request)
 		request = "(NONE)";
 
-	write_buf(fd, request, strlen(request)+1);
+	write_buf(write_fd, request, strlen(request)+1);
 	if (early_argv) {
 		for ( ; *early_argv; early_argv++)
-			write_buf(fd, *early_argv, strlen(*early_argv)+1);
+			write_buf(write_fd, *early_argv, strlen(*early_argv)+1);
 		j = 1; /* Skip arg0 name in argv. */
 	}
-	for ( ; argv[j]; j++) {
-		write_buf(fd, argv[j], strlen(argv[j])+1);
-		if (argv[j][0] == '.' && argv[j][1] == '\0')
-			break;
+	for ( ; argv[j]; j++)
+		write_buf(write_fd, argv[j], strlen(argv[j])+1);
+	write_byte(write_fd, 0);
+
+	close(write_fd);
+
+	/* Read the stdout from the pre-xfer exec program.  This it is only
+	 * displayed to the user if the script also returns an error status. */
+	for (bp = buf; msglen > 0; msglen -= j) {
+		if ((j = read(read_fd, bp, msglen)) <= 0) {
+			if (j == 0)
+				break;
+			if (errno == EINTR)
+				continue;
+			break; /* Just ignore the read error for now... */
+		}
+		bp += j;
+		if (j > 1 && bp[-1] == '\n' && bp[-2] == '\r') {
+			bp--;
+			j--;
+			bp[-1] = '\n';
+		}
 	}
-	write_byte(fd, 0);
+	*bp = '\0';
 
-	close(fd);
+	close(read_fd);
 
 	if (wait_process(pid, &status, 0) < 0
 	 || !WIFEXITED(status) || WEXITSTATUS(status) != 0) {
 		char *e;
-		if (asprintf(&e, "pre-xfer exec returned failure (%d)%s%s\n",
+		if (asprintf(&e, "pre-xfer exec returned failure (%d)%s%s%s\n%s",
 			     status, status < 0 ? ": " : "",
-			     status < 0 ? strerror(errno) : "") < 0)
-			out_of_memory("finish_pre_exec");
+			     status < 0 ? strerror(errno) : "",
+			     *buf ? ":" : "", buf) < 0)
+			return "out_of_memory in finish_pre_exec\n";
 		return e;
 	}
 	return NULL;
 }
 
+#ifdef HAVE_PUTENV
 static int read_arg_from_pipe(int fd, char *buf, int limit)
 {
 	char *bp = buf, *eob = buf + limit - 1;
 
 	while (1) {
-	    int got = read(fd, bp, 1);
-	    if (got != 1) {
-		if (got < 0 && errno == EINTR)
-			continue;
-		return -1;
-	    }
-	    if (*bp == '\0')
-		break;
-	    if (bp < eob)
-		bp++;
+		int got = read(fd, bp, 1);
+		if (got != 1) {
+			if (got < 0 && errno == EINTR)
+				continue;
+			return -1;
+		}
+		if (*bp == '\0')
+			break;
+		if (bp < eob)
+			bp++;
 	}
 	*bp = '\0';
 
 	return bp - buf;
 }
+#endif
 
 static int path_failure(int f_out, const char *dir, BOOL was_chdir)
 {
 	if (was_chdir)
 		rsyserr(FLOG, errno, "chdir %s failed\n", dir);
 	else
 		rprintf(FLOG, "normalize_path(%s) failed\n", dir);
 	io_printf(f_out, "@ERROR: chdir failed\n");
 	return -1;
 }
 
-static int rsync_module(int f_in, int f_out, int i, char *addr, char *host)
+static int add_a_group(int f_out, const char *gname)
+{
+	gid_t gid;
+	if (!group_to_gid(gname, &gid, True)) {
+		rprintf(FLOG, "Invalid gid %s\n", gname);
+		io_printf(f_out, "@ERROR: invalid gid %s\n", gname);
+		return -1;
+	}
+	if (gid_count == MAX_GID_LIST) {
+		rprintf(FLOG, "Too many groups specified via gid parameter.\n");
+		io_printf(f_out, "@ERROR: too many groups\n");
+		return -1;
+	}
+	gid_list[gid_count++] = gid;
+	return 0;
+}
+
+#ifdef HAVE_GETGROUPLIST
+static int want_all_groups(int f_out, uid_t uid)
+{
+	const char *err;
+	gid_count = MAX_GID_LIST;
+	if ((err = getallgroups(uid, gid_list, &gid_count)) != NULL) {
+		rsyserr(FLOG, errno, "%s", err);
+		io_printf(f_out, "@ERROR: %s\n", err);
+		return -1;
+	}
+	return 0;
+}
+#elif defined HAVE_INITGROUPS
+static struct passwd *want_all_groups(int f_out, uid_t uid)
+{
+	struct passwd *pw;
+	if ((pw = getpwuid(uid)) == NULL) {
+		rsyserr(FLOG, errno, "getpwuid failed");
+		io_printf(f_out, "@ERROR: getpwuid failed\n");
+		return NULL;
+	}
+	/* Start with the default group and initgroups() will add the reset. */
+	gid_count = 1;
+	gid_list[0] = pw->pw_gid;
+	return pw;
+}
+#endif
+
+static void set_env_str(const char *var, const char *str)
+{
+#ifdef HAVE_PUTENV
+	char *mem;
+	if (asprintf(&mem, "%s=%s", var, str) < 0)
+		out_of_memory("set_env_str");
+	putenv(mem);
+#endif
+}
+
+#ifdef HAVE_PUTENV
+static void set_env_num(const char *var, long num)
+{
+	char *mem;
+	if (asprintf(&mem, "%s=%ld", var, num) < 0)
+		out_of_memory("set_env_num");
+	putenv(mem);
+}
+#endif
+
+static int rsync_module(int f_in, int f_out, int i, const char *addr, const char *host)
 {
 	int argc;
 	char **argv, **orig_argv, **orig_early_argv, *module_chdir;
 	char line[BIGPATHBUFLEN];
-	uid_t uid = (uid_t)-2;  /* canonically "nobody" */
-	gid_t gid = (gid_t)-2;
+#if defined HAVE_INITGROUPS && !defined HAVE_GETGROUPLIST
+	struct passwd *pw = NULL;
+#endif
+	uid_t uid;
+	int set_uid;
 	char *p, *err_msg = NULL;
 	char *name = lp_name(i);
 	int use_chroot = lp_use_chroot(i);
-	int ret, pre_exec_fd = -1;
+	int ret, pre_exec_arg_fd = -1, pre_exec_error_fd = -1;
+	int save_munge_symlinks;
 	pid_t pre_exec_pid = 0;
 	char *request = NULL;
 
+	set_env_str("RSYNC_MODULE_NAME", name);
+
 #ifdef ICONV_OPTION
 	iconv_opt = lp_charset(i);
 	if (*iconv_opt)
 		setup_iconv();
 	iconv_opt = NULL;
 #endif
 
-	if (!allow_access(addr, host, lp_hosts_allow(i), lp_hosts_deny(i))) {
+	/* If reverse lookup is disabled globally but enabled for this module,
+	 * we need to do it now before the access check. */
+	if (host == undetermined_hostname && lp_reverse_lookup(i))
+		host = client_name(f_in);
+	set_env_str("RSYNC_HOST_NAME", host);
+	set_env_str("RSYNC_HOST_ADDR", addr);
+
+	if (!allow_access(addr, &host, i)) {
 		rprintf(FLOG, "rsync denied on module %s from %s (%s)\n",
 			name, host, addr);
 		if (!lp_list(i))
 			io_printf(f_out, "@ERROR: Unknown module '%s'\n", name);
 		else {
 			io_printf(f_out,
@@ -458,62 +564,77 @@
 			io_printf(f_out, "@ERROR: max connections (%d) reached -- try again later\n",
 				lp_max_connections(i));
 		}
 		return -1;
 	}
 
+	read_only = lp_read_only(i); /* may also be overridden by auth_server() */
 	auth_user = auth_server(f_in, f_out, i, host, addr, "@RSYNCD: AUTHREQD ");
 
 	if (!auth_user) {
 		io_printf(f_out, "@ERROR: auth failed on module %s\n", name);
 		return -1;
 	}
+	set_env_str("RSYNC_USER_NAME", auth_user);
 
 	module_id = i;
 
-	if (lp_read_only(i))
-		read_only = 1;
-
 	if (lp_transfer_logging(i) && !logfile_format)
 		logfile_format = lp_log_format(i);
 	if (log_format_has(logfile_format, 'i'))
 		logfile_format_has_i = 1;
 	if (logfile_format_has_i || log_format_has(logfile_format, 'o'))
 		logfile_format_has_o_or_i = 1;
 
-	am_root = (MY_UID() == 0);
+	uid = MY_UID();
+	am_root = (uid == 0);
 
-	if (am_root) {
-		p = lp_uid(i);
-		if (!name_to_uid(p, &uid)) {
-			if (!isDigit(p)) {
-				rprintf(FLOG, "Invalid uid %s\n", p);
-				io_printf(f_out, "@ERROR: invalid uid %s\n", p);
-				return -1;
-			}
-			uid = atoi(p);
+	p = *lp_uid(i) ? lp_uid(i) : am_root ? NOBODY_USER : NULL;
+	if (p) {
+		if (!user_to_uid(p, &uid, True)) {
+			rprintf(FLOG, "Invalid uid %s\n", p);
+			io_printf(f_out, "@ERROR: invalid uid %s\n", p);
+			return -1;
 		}
+		set_uid = 1;
+	} else
+		set_uid = 0;
 
-		p = lp_gid(i);
-		if (!name_to_gid(p, &gid)) {
-			if (!isDigit(p)) {
-				rprintf(FLOG, "Invalid gid %s\n", p);
-				io_printf(f_out, "@ERROR: invalid gid %s\n", p);
+	p = *lp_gid(i) ? strtok(lp_gid(i), ", ") : NULL;
+	if (p) {
+		/* The "*" gid must be the first item in the list. */
+		if (strcmp(p, "*") == 0) {
+#ifdef HAVE_GETGROUPLIST
+			if (want_all_groups(f_out, uid) < 0)
+				return -1;
+#elif defined HAVE_INITGROUPS
+			if ((pw = want_all_groups(f_out, uid)) == NULL)
+				return -1;
+#else
+			rprintf(FLOG, "This rsync does not support a gid of \"*\"\n");
+			io_printf(f_out, "@ERROR: invalid gid setting.\n");
+			return -1;
+#endif
+		} else if (add_a_group(f_out, p) < 0)
+			return -1;
+		while ((p = strtok(NULL, ", ")) != NULL) {
+#if defined HAVE_INITGROUPS && !defined HAVE_GETGROUPLIST
+			if (pw) {
+				rprintf(FLOG, "This rsync cannot add groups after \"*\".\n");
+				io_printf(f_out, "@ERROR: invalid gid setting.\n");
 				return -1;
 			}
-			gid = atoi(p);
+#endif
+			if (add_a_group(f_out, p) < 0)
+				return -1;
 		}
+	} else if (am_root) {
+		if (add_a_group(f_out, NOBODY_GROUP) < 0)
+			return -1;
 	}
 
-	/* TODO: If we're not root, but the configuration requests
-	 * that we change to some uid other than the current one, then
-	 * log a warning. */
-
-	/* TODO: Perhaps take a list of gids, and make them into the
-	 * supplementary groups. */
-
 	module_dir = lp_path(i);
 	if (*module_dir == '\0') {
 		rprintf(FLOG, "No path specified for module %s\n", name);
 		io_printf(f_out, "@ERROR: no path setting.\n");
 		return -1;
 	}
@@ -537,133 +658,126 @@
 		}
 	} else {
 		if (!(module_chdir = normalize_path(module_dir, False, &module_dirlen)))
 			return path_failure(f_out, module_dir, False);
 		full_module_path = module_dir = module_chdir;
 	}
+	set_env_str("RSYNC_MODULE_PATH", full_module_path);
 
 	if (module_dirlen == 1) {
 		module_dirlen = 0;
 		set_filter_dir("/", 1);
 	} else
 		set_filter_dir(module_dir, module_dirlen);
 
 	p = lp_filter(i);
-	parse_rule(&daemon_filter_list, p, MATCHFLG_WORD_SPLIT,
+	parse_filter_str(&daemon_filter_list, p, rule_template(FILTRULE_WORD_SPLIT),
 		   XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3);
 
 	p = lp_include_from(i);
-	parse_filter_file(&daemon_filter_list, p, MATCHFLG_INCLUDE,
+	parse_filter_file(&daemon_filter_list, p, rule_template(FILTRULE_INCLUDE),
 	    XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
 
 	p = lp_include(i);
-	parse_rule(&daemon_filter_list, p,
-		   MATCHFLG_INCLUDE | MATCHFLG_WORD_SPLIT,
+	parse_filter_str(&daemon_filter_list, p,
+		   rule_template(FILTRULE_INCLUDE | FILTRULE_WORD_SPLIT),
 		   XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES);
 
 	p = lp_exclude_from(i);
-	parse_filter_file(&daemon_filter_list, p, 0,
+	parse_filter_file(&daemon_filter_list, p, rule_template(0),
 	    XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
 
 	p = lp_exclude(i);
-	parse_rule(&daemon_filter_list, p, MATCHFLG_WORD_SPLIT,
+	parse_filter_str(&daemon_filter_list, p, rule_template(FILTRULE_WORD_SPLIT),
 		   XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES);
 
 	log_init(1);
 
 #ifdef HAVE_PUTENV
 	if (*lp_prexfer_exec(i) || *lp_postxfer_exec(i)) {
-		char *modname, *modpath, *hostaddr, *hostname, *username;
 		int status;
 
-		if (asprintf(&modname, "RSYNC_MODULE_NAME=%s", name) < 0
-		 || asprintf(&modpath, "RSYNC_MODULE_PATH=%s", full_module_path) < 0
-		 || asprintf(&hostaddr, "RSYNC_HOST_ADDR=%s", addr) < 0
-		 || asprintf(&hostname, "RSYNC_HOST_NAME=%s", host) < 0
-		 || asprintf(&username, "RSYNC_USER_NAME=%s", auth_user) < 0)
-			out_of_memory("rsync_module");
-		putenv(modname);
-		putenv(modpath);
-		putenv(hostaddr);
-		putenv(hostname);
-		putenv(username);
-		umask(orig_umask);
 		/* For post-xfer exec, fork a new process to run the rsync
 		 * daemon while this process waits for the exit status and
 		 * runs the indicated command at that point. */
 		if (*lp_postxfer_exec(i)) {
 			pid_t pid = fork();
 			if (pid < 0) {
 				rsyserr(FLOG, errno, "fork failed");
 				io_printf(f_out, "@ERROR: fork failed\n");
 				return -1;
 			}
 			if (pid) {
-				if (asprintf(&p, "RSYNC_PID=%ld", (long)pid) > 0)
-					putenv(p);
+				close(f_in);
+				if (f_out != f_in)
+					close(f_out);
+				set_env_num("RSYNC_PID", (long)pid);
 				if (wait_process(pid, &status, 0) < 0)
 					status = -1;
-				if (asprintf(&p, "RSYNC_RAW_STATUS=%d", status) > 0)
-					putenv(p);
+				set_env_num("RSYNC_RAW_STATUS", status);
 				if (WIFEXITED(status))
 					status = WEXITSTATUS(status);
 				else
 					status = -1;
-				if (asprintf(&p, "RSYNC_EXIT_STATUS=%d", status) > 0)
-					putenv(p);
+				set_env_num("RSYNC_EXIT_STATUS", status);
 				if (system(lp_postxfer_exec(i)) < 0)
 					status = -1;
 				_exit(status);
 			}
 		}
 		/* For pre-xfer exec, fork a child process to run the indicated
 		 * command, though it first waits for the parent process to
 		 * send us the user's request via a pipe. */
 		if (*lp_prexfer_exec(i)) {
-			int fds[2];
-			if (asprintf(&p, "RSYNC_PID=%ld", (long)getpid()) > 0)
-				putenv(p);
-			if (pipe(fds) < 0 || (pre_exec_pid = fork()) < 0) {
+			int arg_fds[2], error_fds[2];
+			set_env_num("RSYNC_PID", (long)getpid());
+			if (pipe(arg_fds) < 0 || pipe(error_fds) < 0 || (pre_exec_pid = fork()) < 0) {
 				rsyserr(FLOG, errno, "pre-xfer exec preparation failed");
 				io_printf(f_out, "@ERROR: pre-xfer exec preparation failed\n");
 				return -1;
 			}
 			if (pre_exec_pid == 0) {
 				char buf[BIGPATHBUFLEN];
 				int j, len;
-				close(fds[1]);
-				set_blocking(fds[0]);
-				len = read_arg_from_pipe(fds[0], buf, BIGPATHBUFLEN);
+				close(arg_fds[1]);
+				close(error_fds[0]);
+				pre_exec_arg_fd = arg_fds[0];
+				pre_exec_error_fd = error_fds[1];
+				set_blocking(pre_exec_arg_fd);
+				set_blocking(pre_exec_error_fd);
+				len = read_arg_from_pipe(pre_exec_arg_fd, buf, BIGPATHBUFLEN);
 				if (len <= 0)
 					_exit(1);
-				if (asprintf(&p, "RSYNC_REQUEST=%s", buf) > 0)
-					putenv(p);
+				set_env_str("RSYNC_REQUEST", buf);
 				for (j = 0; ; j++) {
-					len = read_arg_from_pipe(fds[0], buf,
+					len = read_arg_from_pipe(pre_exec_arg_fd, buf,
 								 BIGPATHBUFLEN);
 					if (len <= 0) {
 						if (!len)
 							break;
 						_exit(1);
 					}
-					if (asprintf(&p, "RSYNC_ARG%d=%s", j, buf) > 0)
+					if (asprintf(&p, "RSYNC_ARG%d=%s", j, buf) >= 0)
 						putenv(p);
 				}
-				close(fds[0]);
+				close(pre_exec_arg_fd);
 				close(STDIN_FILENO);
-				close(STDOUT_FILENO);
+				dup2(pre_exec_error_fd, STDOUT_FILENO);
+				close(pre_exec_error_fd);
 				status = system(lp_prexfer_exec(i));
 				if (!WIFEXITED(status))
 					_exit(1);
 				_exit(WEXITSTATUS(status));
 			}
-			close(fds[0]);
-			set_blocking(fds[1]);
-			pre_exec_fd = fds[1];
+			close(arg_fds[0]);
+			close(error_fds[1]);
+			pre_exec_arg_fd = arg_fds[1];
+			pre_exec_error_fd = error_fds[0];
+			set_blocking(pre_exec_arg_fd);
+			set_blocking(pre_exec_error_fd);
 		}
-		umask(0);
 	}
 #endif
 
 	if (use_chroot) {
 		/*
 		 * XXX: The 'use chroot' flag is a fairly reliable
@@ -691,52 +805,53 @@
 		sanitize_paths = 1;
 
 	if ((munge_symlinks = lp_munge_symlinks(i)) < 0)
 		munge_symlinks = !use_chroot || module_dirlen;
 	if (munge_symlinks) {
 		STRUCT_STAT st;
-		if (do_stat(SYMLINK_PREFIX, &st) == 0 && S_ISDIR(st.st_mode)) {
-			rprintf(FLOG, "Symlink munging is unsupported when a %s directory exists.\n",
-				SYMLINK_PREFIX);
+		char prefix[SYMLINK_PREFIX_LEN]; /* NOT +1 ! */
+		strlcpy(prefix, SYMLINK_PREFIX, sizeof prefix); /* trim the trailing slash */
+		if (do_stat(prefix, &st) == 0 && S_ISDIR(st.st_mode)) {
+			rprintf(FLOG, "Symlink munging is unsafe when a %s directory exists.\n",
+				prefix);
 			io_printf(f_out, "@ERROR: daemon security issue -- contact admin\n", name);
 			exit_cleanup(RERR_UNSUPPORTED);
 		}
 	}
 
-	if (am_root) {
-		/* XXXX: You could argue that if the daemon is started
-		 * by a non-root user and they explicitly specify a
-		 * gid, then we should try to change to that gid --
-		 * this could be possible if it's already in their
-		 * supplementary groups. */
-
-		/* TODO: Perhaps we need to document that if rsyncd is
-		 * started by somebody other than root it will inherit
-		 * all their supplementary groups. */
-
-		if (setgid(gid)) {
-			rsyserr(FLOG, errno, "setgid %d failed", (int)gid);
+	if (gid_count) {
+		if (setgid(gid_list[0])) {
+			rsyserr(FLOG, errno, "setgid %ld failed", (long)gid_list[0]);
 			io_printf(f_out, "@ERROR: setgid failed\n");
 			return -1;
 		}
 #ifdef HAVE_SETGROUPS
-		/* Get rid of any supplementary groups this process
-		 * might have inheristed. */
-		if (setgroups(1, &gid)) {
+		/* Set the group(s) we want to be active. */
+		if (setgroups(gid_count, gid_list)) {
 			rsyserr(FLOG, errno, "setgroups failed");
 			io_printf(f_out, "@ERROR: setgroups failed\n");
 			return -1;
 		}
 #endif
+#if defined HAVE_INITGROUPS && !defined HAVE_GETGROUPLIST
+		/* pw is set if the user wants all the user's groups. */
+		if (pw && initgroups(pw->pw_name, pw->pw_gid) < 0) {
+			rsyserr(FLOG, errno, "initgroups failed");
+			io_printf(f_out, "@ERROR: initgroups failed\n");
+			return -1;
+		}
+#endif
+	}
 
+	if (set_uid) {
 		if (setuid(uid) < 0
 #ifdef HAVE_SETEUID
 		 || seteuid(uid) < 0
 #endif
 		) {
-			rsyserr(FLOG, errno, "setuid %d failed", (int)uid);
+			rsyserr(FLOG, errno, "setuid %ld failed", (long)uid);
 			io_printf(f_out, "@ERROR: setuid failed\n");
 			return -1;
 		}
 
 		am_root = (MY_UID() == 0);
 	}
@@ -753,26 +868,30 @@
 
 	io_printf(f_out, "@RSYNCD: OK\n");
 
 	read_args(f_in, name, line, sizeof line, rl_nulls, &argv, &argc, &request);
 	orig_argv = argv;
 
-	verbose = 0; /* future verbosity is controlled by client options */
+	save_munge_symlinks = munge_symlinks;
+
+	reset_output_levels(); /* future verbosity is controlled by client options */
 	ret = parse_arguments(&argc, (const char ***) &argv);
 	if (protect_args && ret) {
 		orig_early_argv = orig_argv;
 		protect_args = 2;
 		read_args(f_in, name, line, sizeof line, 1, &argv, &argc, &request);
 		orig_argv = argv;
 		ret = parse_arguments(&argc, (const char ***) &argv);
 	} else
 		orig_early_argv = NULL;
 
+	munge_symlinks = save_munge_symlinks; /* The client mustn't control this. */
+
 	if (pre_exec_pid) {
-		err_msg = finish_pre_exec(pre_exec_pid, pre_exec_fd, request,
-					  orig_early_argv, orig_argv);
+		err_msg = finish_pre_exec(pre_exec_pid, pre_exec_arg_fd, pre_exec_error_fd,
+					  request, orig_early_argv, orig_argv);
 	}
 
 	if (orig_early_argv)
 		free(orig_early_argv);
 
 	am_server = 1; /* Don't let someone try to be tricky. */
@@ -804,19 +923,18 @@
 		}
 		free(request);
 	}
 
 #ifndef DEBUG
 	/* don't allow the logs to be flooded too fast */
-	if (verbose > lp_max_verbosity(i))
-		verbose = lp_max_verbosity(i);
+	limit_output_verbosity(lp_max_verbosity(i));
 #endif
 
 	if (protocol_version < 23
 	    && (protocol_version == 22 || am_sender))
-		io_start_multiplex_out();
+		io_start_multiplex_out(f_out);
 	else if (!ret || err_msg) {
 		/* We have to get I/O multiplexing started so that we can
 		 * get the error back to the client.  This means getting
 		 * the protocol setup finished first in later versions. */
 		setup_protocol(f_out, f_in);
 		if (!am_sender) {
@@ -834,19 +952,25 @@
 					}
 				}
 			}
 			if (files_from)
 				write_byte(f_out, 0);
 		}
-		io_start_multiplex_out();
+		io_start_multiplex_out(f_out);
 	}
 
 	if (!ret || err_msg) {
-		if (err_msg)
-			rwrite(FERROR, err_msg, strlen(err_msg), 0);
-		else
+		if (err_msg) {
+			while ((p = strchr(err_msg, '\n')) != NULL) {
+				int len = p - err_msg + 1;
+				rwrite(FERROR, err_msg, len, 0);
+				err_msg += len;
+			}
+			if (*err_msg)
+				rprintf(FERROR, "%s\n", err_msg);
+		} else
 			option_error();
 		msleep(400);
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
 
 #ifdef ICONV_OPTION
@@ -888,13 +1012,13 @@
 }
 
 /* send a list of available modules to the client. Don't list those
    with "list = False". */
 static void send_listing(int fd)
 {
-	int n = lp_numservices();
+	int n = lp_num_modules();
 	int i;
 
 	for (i = 0; i < n; i++) {
 		if (lp_list(i))
 			io_printf(fd, "%-15s\t%s\n", lp_name(i), lp_comment(i));
 	}
@@ -917,38 +1041,38 @@
 /* this is called when a connection is established to a client
    and we want to start talking. The setup of the system is done from
    here */
 int start_daemon(int f_in, int f_out)
 {
 	char line[1024];
-	char *addr, *host;
+	const char *addr, *host;
 	int i;
 
 	io_set_sock_fds(f_in, f_out);
 
 	/* We must load the config file before calling any function that
 	 * might cause log-file output to occur.  This ensures that the
 	 * "log file" param gets honored for the 2 non-forked use-cases
 	 * (when rsync is run by init and run by a remote shell). */
 	if (!load_config(0))
 		exit_cleanup(RERR_SYNTAX);
 
 	addr = client_addr(f_in);
-	host = client_name(f_in);
+	host = lp_reverse_lookup(-1) ? client_name(f_in) : undetermined_hostname;
 	rprintf(FLOG, "connect from %s (%s)\n", host, addr);
 
 	if (!am_server) {
 		set_socket_options(f_in, "SO_KEEPALIVE");
 		set_nonblocking(f_in);
 	}
 
 	if (exchange_protocols(f_in, f_out, line, sizeof line, 0) < 0)
 		return -1;
 
 	line[0] = 0;
-	if (!read_line_old(f_in, line, sizeof line))
+	if (!read_line_old(f_in, line, sizeof line, 0))
 		return -1;
 
 	if (!*line || strcmp(line, "#list") == 0) {
 		rprintf(FLOG, "module-list request from %s (%s)\n",
 			host, addr);
 		send_listing(f_out);
@@ -984,20 +1108,20 @@
 	int fd, len;
 
 	if (!pid_file || !*pid_file)
 		return;
 
 	cleanup_set_pid(pid);
-	if ((fd = do_open(pid_file, O_WRONLY|O_CREAT|O_EXCL, 0666 & ~orig_umask)) == -1) {
+	if ((fd = do_open(pid_file, O_WRONLY|O_CREAT|O_EXCL, 0666)) == -1) {
 	  failure:
 		cleanup_set_pid(0);
 		fprintf(stderr, "failed to create pid file %s: %s\n", pid_file, strerror(errno));
 		rsyserr(FLOG, errno, "failed to create pid file %s", pid_file);
 		exit_cleanup(RERR_FILEIO);
 	}
-	snprintf(pidbuf, sizeof pidbuf, "%ld\n", (long)pid);
+	snprintf(pidbuf, sizeof pidbuf, "%d\n", (int)pid);
 	len = strlen(pidbuf);
 	if (write(fd, pidbuf, len) != len)
 		goto failure;
 	close(fd);
 }
 
@@ -1052,12 +1176,13 @@
 	}
 
 	if (!load_config(1)) {
 		fprintf(stderr, "Failed to parse config file: %s\n", config_file);
 		exit_cleanup(RERR_SYNTAX);
 	}
+	set_dparams(0);
 
 	if (no_detach)
 		create_pid_file();
 	else
 		become_daemon();
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/compat.c	2011-02-22 03:32:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/compat.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Compatibility routines for older rsync protocol versions.
  *
  * Copyright (C) Andrew Tridgell 1996
  * Copyright (C) Paul Mackerras 1996
- * Copyright (C) 2004-2009 Wayne Davison
+ * Copyright (C) 2004-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -24,20 +24,20 @@
 int remote_protocol = 0;
 int file_extra_cnt = 0; /* count of file-list extras that everyone gets */
 int inc_recurse = 0;
 int compat_flags = 0;
 int use_safe_inc_flist = 0;
 
-extern int verbose;
 extern int am_server;
 extern int am_sender;
 extern int local_server;
 extern int inplace;
 extern int recurse;
 extern int use_qsort;
 extern int allow_inc_recurse;
+extern int preallocate_files;
 extern int append_mode;
 extern int fuzzy_basis;
 extern int read_batch;
 extern int delay_updates;
 extern int checksum_seed;
 extern int basis_dir_cnt;
@@ -52,13 +52,13 @@
 extern int delete_mode, delete_before, delete_during, delete_after;
 extern char *shell_cmd;
 extern char *partial_dir;
 extern char *dest_option;
 extern char *files_from;
 extern char *filesfrom_host;
-extern struct filter_list_struct filter_list;
+extern filter_rule_list filter_list;
 extern int need_unsorted_flist;
 #ifdef ICONV_OPTION
 extern iconv_t ic_send, ic_recv;
 extern char *iconv_opt;
 #endif
 
@@ -160,13 +160,13 @@
 	if (read_batch && remote_protocol > protocol_version) {
 		rprintf(FERROR, "The protocol version in the batch file is too new (%d > %d).\n",
 			remote_protocol, protocol_version);
 		exit_cleanup(RERR_PROTOCOL);
 	}
 
-	if (verbose > 3) {
+	if (DEBUG_GTE(PROTO, 1)) {
 		rprintf(FINFO, "(%s) Protocol versions: remote=%d, negotiated=%d\n",
 			am_server? "Server" : "Client", remote_protocol, protocol_version);
 	}
 	if (remote_protocol < MIN_PROTOCOL_VERSION
 	 || remote_protocol > MAX_PROTOCOL_VERSION) {
 		rprintf(FERROR,"protocol version mismatch -- is your shell clean?\n");
@@ -187,12 +187,20 @@
 			PROTOCOL_VERSION, am_server? "Server" : "Client");
 		exit_cleanup(RERR_PROTOCOL);
 	}
 	if (read_batch)
 		check_batch_flags();
 
+#ifndef SUPPORT_PREALLOCATION
+	if (preallocate_files && !am_sender) {
+		rprintf(FERROR, "preallocation is not supported on this %s\n",
+			am_server ? "Server" : "Client");
+		exit_cleanup(RERR_SYNTAX);
+	}
+#endif
+
 	if (protocol_version < 30) {
 		if (append_mode == 1)
 			append_mode = 2;
 		if (preserve_acls && !local_server) {
 			rprintf(FERROR,
 			    "--acls requires protocol 30 or higher"
@@ -282,28 +290,28 @@
 			/* This should only be able to happen in a batch. */
 			fprintf(stderr,
 			    "Incompatible options specified for inc-recursive %s.\n",
 			    read_batch ? "batch file" : "connection");
 			exit_cleanup(RERR_SYNTAX);
 		}
-		use_safe_inc_flist = !!(compat_flags & CF_SAFE_FLIST);
+		use_safe_inc_flist = (compat_flags & CF_SAFE_FLIST) || protocol_version >= 31;
 		need_messages_from_generator = 1;
 #ifdef CAN_SET_SYMLINK_TIMES
 	} else if (!am_sender) {
 		receiver_symlink_times = 1;
 #endif
 	}
 
 	if (need_unsorted_flist && (!am_sender || inc_recurse))
 		unsort_ndx = ++file_extra_cnt;
 
 	if (partial_dir && *partial_dir != '/' && (!am_server || local_server)) {
-		int flags = MATCHFLG_NO_PREFIXES | MATCHFLG_DIRECTORY;
+		int rflags = FILTRULE_NO_PREFIXES | FILTRULE_DIRECTORY;
 		if (!am_sender || protocol_version >= 30)
-			flags |= MATCHFLG_PERISHABLE;
-		parse_rule(&filter_list, partial_dir, flags, 0);
+			rflags |= FILTRULE_PERISHABLE;
+		parse_filter_str(&filter_list, partial_dir, rule_template(rflags), 0);
 	}
 
 
 #ifdef ICONV_OPTION
 	if (protect_args && files_from) {
 		if (am_sender)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/config.guess /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/config.guess
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/config.guess	2006-11-02 10:01:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/config.guess	2013-05-20 06:00:44.000000000 +0800
@@ -1,45 +1,39 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,
-#   Inc.
+#   Copyright 1992-2013 Free Software Foundation, Inc.
 
-timestamp='2006-07-02'
+timestamp='2013-05-16'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
 # WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner <per@bothner.com>.
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+#
+# Originally written by Per Bothner.
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
 #
-# The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
+# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
 usage="\
 Usage: $0 [OPTION]
 
@@ -53,14 +47,13 @@
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
-Free Software Foundation, Inc.
+Copyright 1992-2013 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
@@ -136,18 +129,39 @@
 
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
 UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
 	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
 	# compatibility and a consistent mechanism for selecting the
 	# object file format.
 	#
@@ -158,21 +172,22 @@
 	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
 	case "${UNAME_MACHINE_ARCH}" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
 	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently, or will in the future.
 	case "${UNAME_MACHINE_ARCH}" in
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep __ELF__ >/dev/null
+			| grep -q __ELF__
 		then
 		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
 		    # Return netbsd for either.  FIX?
 		    os=netbsd
 		else
 		    os=netbsdelf
@@ -197,12 +212,16 @@
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
 	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
+	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
 	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
 	exit ;;
     *:ekkoBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
@@ -265,13 +284,16 @@
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
 	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit ;;
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	exitcode=$?
+	trap '' 0
+	exit $exitcode ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
 	# of the specific Alpha model?
 	echo alpha-pc-interix
 	exit ;;
@@ -296,13 +318,13 @@
     *:OS400:*:*)
         echo powerpc-ibm-os400
 	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
 	exit ;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
@@ -320,20 +342,39 @@
 	echo sparc-icl-nx6
 	exit ;;
     DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
 	case `/usr/bin/uname -p` in
 	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
+    s390x:SunOS:*:*)
+	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
-    i86pc:SunOS:5.*:*)
-	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	echo i386-pc-auroraux${UNAME_RELEASE}
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	eval $set_cc_for_build
+	SUN_ARCH="i386"
+	# If there is a compiler, see if it is configured for 64-bit objects.
+	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
+	# This test works for both compilers.
+	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		SUN_ARCH="x86_64"
+	    fi
+	fi
+	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
 	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
@@ -528,13 +569,13 @@
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
 	exit ;;
-    *:AIX:*:[45])
+    *:AIX:*:[4567])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
@@ -585,44 +626,44 @@
 			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
                         esac ;;
                     esac
 		fi
 		if [ "${HP_ARCH}" = "" ]; then
 		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
+		    sed 's/^		//' << EOF >$dummy.c
 
-              #define _HPUX_SOURCE
-              #include <stdlib.h>
-              #include <unistd.h>
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
 
-                  switch (cpu)
+		int main ()
               	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
+
+		    switch (cpu)
               		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
               	}
-                  exit (0);
-              }
 EOF
 		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
 	if [ ${HP_ARCH} = "hppa2.0w" ]
@@ -636,13 +677,13 @@
 	    # $ CC_FOR_BUILD=cc ./config.guess
 	    # => hppa2.0w-hp-hpux11.23
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
 	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
-		grep __LP64__ >/dev/null
+		grep -q __LP64__
 	    then
 		HP_ARCH="hppa2.0w"
 	    else
 		HP_ARCH="hppa64"
 	    fi
 	fi
@@ -765,43 +806,57 @@
 	echo sparc-unknown-bsdi${UNAME_RELEASE}
 	exit ;;
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
 	exit ;;
     *:FreeBSD:*:*)
-	case ${UNAME_MACHINE} in
-	    pc98)
-		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case ${UNAME_PROCESSOR} in
 	    amd64)
 		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
 	    *)
-		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+		echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
 	esac
 	exit ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit ;;
-    i*:MINGW*:*)
+    *:MINGW64*:*)
+	echo ${UNAME_MACHINE}-pc-mingw64
+	exit ;;
+    *:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit ;;
+    i*:MSYS*:*)
+	echo ${UNAME_MACHINE}-pc-msys
+	exit ;;
     i*:windows32*:*)
     	# uname -m includes "-pc" on this system.
     	echo ${UNAME_MACHINE}-mingw32
 	exit ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
 	exit ;;
-    x86:Interix*:[3456]*)
-	echo i586-pc-interix${UNAME_RELEASE}
-	exit ;;
-    EM64T:Interix*:[3456]*)
-	echo x86_64-unknown-interix${UNAME_RELEASE}
-	exit ;;
+    *:Interix*:*)
+	case ${UNAME_MACHINE} in
+	    x86)
+		echo i586-pc-interix${UNAME_RELEASE}
+		exit ;;
+	    authenticamd | genuineintel | EM64T)
+		echo x86_64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	esac ;;
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
 	exit ;;
+    8664:Windows_NT:*)
+	echo x86_64-pc-mks
+	exit ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
 	# UNAME_MACHINE based on the output of uname instead of i386?
 	echo i586-pc-interix
 	exit ;;
@@ -816,206 +871,157 @@
 	exit ;;
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
 	exit ;;
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit ;;
+    aarch64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+	esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
     arm*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	eval $set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	else
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
+	    else
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
+	    fi
+	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     cris:Linux:*:*)
-	echo cris-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
 	exit ;;
     frv:Linux:*:*)
-    	echo frv-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    hexagon:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    i*86:Linux:*:*)
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
-    mips:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips
-	#undef mipsel
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mipsel
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips
-	#else
-	CPU=
-	#endif
-	#endif
-EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
-	;;
-    mips64:Linux:*:*)
+    mips:Linux:*:* | mips64:Linux:*:*)
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#undef CPU
-	#undef mips64
-	#undef mips64el
+	#undef ${UNAME_MACHINE}
+	#undef ${UNAME_MACHINE}el
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=mips64el
+	CPU=${UNAME_MACHINE}el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=mips64
+	CPU=${UNAME_MACHINE}
 	#else
 	CPU=
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^CPU/{
-		s: ::g
-		p
-	    }'`"
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
 	;;
-    or32:Linux:*:*)
-	echo or32-unknown-linux-gnu
+    or1k:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+    or32:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+    padre:Linux:*:*)
+	echo sparc-unknown-linux-${LIBC}
 	exit ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
-	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-${LIBC}
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
 	esac
 	exit ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-${LIBC}
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-${LIBC}
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
 	exit ;;
     sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    tile*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
 	exit ;;
     x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    xtensa*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
-    i*86:Linux:*:*)
-	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
-	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
-			 | sed -ne '/supported targets:/!d
-				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
-				    s/ .*//
-				    p'`
-        case "$ld_supported_targets" in
-	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
-		;;
-	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit ;;
-	  coff-i386)
-		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit ;;
-	  "")
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ >= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#if defined(__INTEL_COMPILER) || defined(__PGI) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval "`$CC_FOR_BUILD -E $dummy.c 2>/dev/null | sed -n '
-	    /^LIBC/{
-		s: ::g
-		p
-	    }'`"
-	test x"${LIBC}" != x && {
-		echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
-		exit
-	}
-	test x"${TENTATIVE}" != x && { echo "${TENTATIVE}"; exit; }
-	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
 	echo i386-sequent-sysv4
 	exit ;;
@@ -1038,13 +1044,13 @@
     i*86:atheos:*:*)
 	echo ${UNAME_MACHINE}-unknown-atheos
 	exit ;;
     i*86:syllable:*:*)
 	echo ${UNAME_MACHINE}-pc-syllable
 	exit ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
 	echo i386-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     i*86:*DOS:*:*)
 	echo ${UNAME_MACHINE}-pc-msdosdjgpp
 	exit ;;
     i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
@@ -1082,14 +1088,17 @@
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
 	exit ;;
     pc:*:*:*)
 	# Left here for compatibility:
         # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
-	echo i386-pc-msdosdjgpp
+	# the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configury will decide that
+	# this is a cross-build.
+	echo i586-pc-msdosdjgpp
         exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
 	exit ;;
     paragon:*:*:*)
 	echo i860-intel-osf1
@@ -1121,25 +1130,35 @@
 	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
 	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
         /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
           && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
 	exit ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
 	echo powerpc-unknown-lynxos${UNAME_RELEASE}
 	exit ;;
     SM[BE]S:UNIX_SV:*:*)
 	echo mips-dde-sysv${UNAME_RELEASE}
 	exit ;;
     RM*:ReliantUNIX-*:*:*)
@@ -1153,14 +1172,14 @@
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
 		echo ${UNAME_MACHINE}-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
 	exit ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel@ccMail.Census.GOV>
+    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
         echo i586-unisys-sysv4
         exit ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
 	echo hppa1.1-stratus-sysv4
@@ -1196,32 +1215,59 @@
     BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
 	echo powerpc-apple-beos
 	exit ;;
     BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
 	echo i586-pc-beos
 	exit ;;
+    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
+	echo i586-pc-haiku
+	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
 	exit ;;
     SX-5:SUPER-UX:*:*)
 	echo sx5-nec-superux${UNAME_RELEASE}
 	exit ;;
     SX-6:SUPER-UX:*:*)
 	echo sx6-nec-superux${UNAME_RELEASE}
 	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux${UNAME_RELEASE}
+	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	fi
 	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
 	if test "$UNAME_PROCESSOR" = "x86"; then
 		UNAME_PROCESSOR=i386
@@ -1229,13 +1275,16 @@
 	fi
 	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
 	exit ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
 	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
+    NEO-?:NONSTOP_KERNEL:*:*)
+	echo neo-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSE-*:NONSTOP_KERNEL:*:*)
 	echo nse-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     NSR-?:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
 	exit ;;
     *:NonStop-UX:*:*)
@@ -1295,17 +1344,20 @@
     i*86:skyos:*:*)
 	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
 	exit ;;
     i*86:rdos:*:*)
 	echo ${UNAME_MACHINE}-pc-rdos
 	exit ;;
+    i*86:AROS:*:*)
+	echo ${UNAME_MACHINE}-pc-aros
+	exit ;;
+    x86_64:VMkernel:*:*)
+	echo ${UNAME_MACHINE}-unknown-esx
+	exit ;;
 esac
 
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
 eval $set_cc_for_build
 cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
 # include <sys/types.h>
 # include <sys/utsname.h>
 #endif
@@ -1317,17 +1369,17 @@
      I don't know....  */
   printf ("mips-sony-bsd\n"); exit (0);
 #else
 #include <sys/param.h>
   printf ("m68k-sony-newsos%s\n",
 #ifdef NEWSOS4
-          "4"
+	"4"
 #else
-	  ""
+	""
 #endif
-         ); exit (0);
+	); exit (0);
 #endif
 #endif
 
 #if defined (__arm) && defined (__acorn) && defined (__unix)
   printf ("arm-acorn-riscix\n"); exit (0);
 #endif
@@ -1455,15 +1507,15 @@
 $0: unable to guess system type
 
 This script, last modified $timestamp, has failed to recognize
 the operating system you are using. It is advised that you
 download the most up to date version of the config scripts from
 
-  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.guess
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
 and
-  http://savannah.gnu.org/cgi-bin/viewcvs/*checkout*/config/config/config.sub
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
 
 If the version you run ($0) is already up to date, please
 send the following data and any information you think might be
 pertinent to <config-patches@gnu.org> in order to provide the needed
 information to handle your system.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/config.h.in	2011-09-24 00:41:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/config.h.in	2013-09-29 10:57:20.000000000 +0800
@@ -58,12 +58,15 @@
 /* Define to 1 if you have the <arpa/nameser.h> header file. */
 #undef HAVE_ARPA_NAMESER_H
 
 /* Define to 1 if you have the `asprintf' function. */
 #undef HAVE_ASPRINTF
 
+/* Define to 1 if you have the `attropen' function. */
+#undef HAVE_ATTROPEN
+
 /* Define to 1 if you have the <attr/xattr.h> header file. */
 #undef HAVE_ATTR_XATTR_H
 
 /* Define to 1 if readdir() is broken */
 #undef HAVE_BROKEN_READDIR
 
@@ -86,18 +89,25 @@
 #undef HAVE_CTYPE_H
 
 /* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
    */
 #undef HAVE_DIRENT_H
 
+/* Define if posix_fallocate is efficient (Cygwin) */
+#undef HAVE_EFFICIENT_POSIX_FALLOCATE
+
 /* Define to 1 if errno is declared in errno.h */
 #undef HAVE_ERRNO_DECL
 
 /* Define to 1 if you have the `extattr_get_link' function. */
 #undef HAVE_EXTATTR_GET_LINK
 
+/* Define to 1 if you have the fallocate function and it compiles and links
+   without error */
+#undef HAVE_FALLOCATE
+
 /* Define to 1 if you have the `fchmod' function. */
 #undef HAVE_FCHMOD
 
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
@@ -122,15 +132,21 @@
 /* Define to 1 if you have the `getegid' function. */
 #undef HAVE_GETEGID
 
 /* Define to 1 if you have the `geteuid' function. */
 #undef HAVE_GETEUID
 
+/* Define to 1 if you have the `getgrouplist' function. */
+#undef HAVE_GETGROUPLIST
+
 /* Define to 1 if you have the `getgroups' function. */
 #undef HAVE_GETGROUPS
 
+/* Define to 1 if you have the `getpass' function. */
+#undef HAVE_GETPASS
+
 /* Define to 1 if you have the `getpgrp' function. */
 #undef HAVE_GETPGRP
 
 /* Define to 1 if gettimeofday() takes a time-zone arg */
 #undef HAVE_GETTIMEOFDAY_TZ
 
@@ -155,12 +171,15 @@
 /* Define to 1 if you have the `inet_ntop' function. */
 #undef HAVE_INET_NTOP
 
 /* Define to 1 if you have the `inet_pton' function. */
 #undef HAVE_INET_PTON
 
+/* Define to 1 if you have the `initgroups' function. */
+#undef HAVE_INITGROUPS
+
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
 /* true if you have IRIX ACLs */
 #undef HAVE_IRIX_ACLS
 
@@ -197,18 +216,24 @@
 /* Define to 1 if you have the `sec' library (-lsec). */
 #undef HAVE_LIBSEC
 
 /* Define to 1 if you have the `socket' library (-lsocket). */
 #undef HAVE_LIBSOCKET
 
+/* Define to 1 if you have the `z' library (-lz). */
+#undef HAVE_LIBZ
+
 /* Define to 1 if you have the <limits.h> header file. */
 #undef HAVE_LIMITS_H
 
 /* Define to 1 if you have the `link' function. */
 #undef HAVE_LINK
 
+/* Define to 1 if you have the <linux/falloc.h> header file. */
+#undef HAVE_LINUX_FALLOC_H
+
 /* True if you have Linux xattrs */
 #undef HAVE_LINUX_XATTRS
 
 /* Define to 1 if you have the `locale_charset' function. */
 #undef HAVE_LOCALE_CHARSET
 
@@ -295,12 +320,15 @@
 /* Define to 1 if you have the <popt/popt.h> header file. */
 #undef HAVE_POPT_POPT_H
 
 /* true if you have posix ACLs */
 #undef HAVE_POSIX_ACLS
 
+/* Define to 1 if you have the `posix_fallocate' function. */
+#undef HAVE_POSIX_FALLOCATE
+
 /* Define to 1 if you have the `putenv' function. */
 #undef HAVE_PUTENV
 
 /* Define to 1 if you have the `readlink' function. */
 #undef HAVE_READLINK
 
@@ -325,12 +353,15 @@
 /* Define to 1 if you have the `setmode' function. */
 #undef HAVE_SETMODE
 
 /* Define to 1 if you have the `setsid' function. */
 #undef HAVE_SETSID
 
+/* Define to 1 if you have the `setvbuf' function. */
+#undef HAVE_SETVBUF
+
 /* Define to 1 if you have the `sigaction' function. */
 #undef HAVE_SIGACTION
 
 /* Define to 1 if you have the `sigprocmask' function. */
 #undef HAVE_SIGPROCMASK
 
@@ -355,12 +386,15 @@
 /* Define to 1 if you have the "socketpair" function */
 #undef HAVE_SOCKETPAIR
 
 /* true if you have solaris ACLs */
 #undef HAVE_SOLARIS_ACLS
 
+/* True if you have Solaris xattrs */
+#undef HAVE_SOLARIS_XATTRS
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
 /* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
@@ -403,12 +437,18 @@
 /* Define to 1 if the system has the type `struct sockaddr_storage'. */
 #undef HAVE_STRUCT_SOCKADDR_STORAGE
 
 /* Define to 1 if the system has the type `struct stat64'. */
 #undef HAVE_STRUCT_STAT64
 
+/* Define to 1 if `st_mtimensec' is a member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_MTIMENSEC
+
+/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
+
 /* Define to 1 if `st_rdev' is a member of `struct stat'. */
 #undef HAVE_STRUCT_STAT_ST_RDEV
 
 /* Define to 1 if you have the "struct utimbuf" type */
 #undef HAVE_STRUCT_UTIMBUF
 
@@ -422,12 +462,15 @@
    */
 #undef HAVE_SYS_DIR_H
 
 /* Define to 1 if you have the <sys/extattr.h> header file. */
 #undef HAVE_SYS_EXTATTR_H
 
+/* Define to 1 if you have the SYS_fallocate syscall number */
+#undef HAVE_SYS_FALLOCATE
+
 /* Define to 1 if you have the <sys/fcntl.h> header file. */
 #undef HAVE_SYS_FCNTL_H
 
 /* Define to 1 if you have the <sys/filio.h> header file. */
 #undef HAVE_SYS_FILIO_H
 
@@ -510,12 +553,15 @@
 /* Define to 1 if you have the `wait4' function. */
 #undef HAVE_WAIT4
 
 /* Define to 1 if you have the `waitpid' function. */
 #undef HAVE_WAITPID
 
+/* Define to 1 if you have the <zlib.h> header file. */
+#undef HAVE_ZLIB_H
+
 /* Define to 1 if you have the `_acl' function. */
 #undef HAVE__ACL
 
 /* Define to 1 if you have the `_facl' function. */
 #undef HAVE__FACL
 
@@ -564,12 +610,15 @@
 /* True if device files do not support xattrs */
 #undef NO_DEVICE_XATTRS
 
 /* True if special files do not support xattrs */
 #undef NO_SPECIAL_XATTRS
 
+/* True if symlinks do not support user xattrs */
+#undef NO_SYMLINK_USER_XATTRS
+
 /* True if symlinks do not support xattrs */
 #undef NO_SYMLINK_XATTRS
 
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
@@ -597,12 +646,15 @@
 /* location of rsync on remote machine */
 #undef RSYNC_PATH
 
 /* default -e command */
 #undef RSYNC_RSH
 
+/* Define to 1 if --protected-args should be the default */
+#undef RSYNC_USE_PROTECTED_ARGS
+
 /* rsync release version */
 #undef RSYNC_VERSION
 
 /* Define to 1 if sockets need to be shutdown */
 #undef SHUTDOWN_ALL_SOCKETS
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/config.sub /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/config.sub
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/config.sub	2006-11-02 10:01:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/config.sub	2013-05-20 06:01:07.000000000 +0800
@@ -1,47 +1,43 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,
-#   Inc.
-
-timestamp='2006-07-02'
-
-# This file is (in principle) common to ALL GNU software.
-# The presence of a machine in this file suggests that SOME GNU software
-# can handle that machine.  It does not imply ALL GNU software can.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+#   Copyright 1992-2013 Free Software Foundation, Inc.
+
+timestamp='2013-04-24'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# Please send patches with a ChangeLog entry to config-patches@gnu.org.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
 # This file is supposed to be the same for all GNU packages
 # and recognize all the CPU types, system types and aliases
 # that are meaningful with *any* GNU software.
 # Each package is responsible for reporting which valid configurations
 # it does not support.  The user should be able to distinguish
 # a failure to support a valid configuration from a meaningless
@@ -69,14 +65,13 @@
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
-Free Software Foundation, Inc.
+Copyright 1992-2013 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
@@ -117,18 +112,24 @@
 esac
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | linux-newlib* | linux-uclibc* | \
-  uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* | \
+  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | \
+  kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
+  android-linux)
+    os=-linux-android
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
+    ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
     then os=`echo $1 | sed 's/.*-/-/'`
     else os=; fi
     ;;
@@ -145,16 +146,19 @@
 	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
 	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
 	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray)
+	-apple | -axis | -knuth | -cray | -microblaze*)
 		os=
 		basic_machine=$1
 		;;
+	-bluegene*)
+		os=-cnk
+		;;
 	-sim | -cisco | -oki | -wec | -winbond)
 		os=
 		basic_machine=$1
 		;;
 	-scout)
 		;;
@@ -211,12 +215,18 @@
 	-clix*)
 		basic_machine=clipper-intergraph
 		;;
 	-isc*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
 		;;
+	-lynx*178)
+		os=-lynxos178
+		;;
+	-lynx*5)
+		os=-lynxos5
+		;;
 	-lynx*)
 		os=-lynxos
 		;;
 	-ptx*)
 		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
 		;;
@@ -235,73 +245,113 @@
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
 	1750a | 580 \
 	| a29k \
+	| aarch64 | aarch64_be \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| arc | arceb \
+	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
+	| avr | avr32 \
+	| be32 | be64 \
 	| bfin \
 	| c4x | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| fr30 | frv \
+	| epiphany \
+	| fido | fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| hexagon \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
+	| le32 | le64 \
+	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
-	| mips64vr | mips64vrel \
+	| mips64octeon | mips64octeonel \
 	| mips64orion | mips64orionel \
+	| mips64r5900 | mips64r5900el \
+	| mips64vr | mips64vrel \
 	| mips64vr4100 | mips64vr4100el \
 	| mips64vr4300 | mips64vr4300el \
 	| mips64vr5000 | mips64vr5000el \
 	| mips64vr5900 | mips64vr5900el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
 	| mipsisa64 | mipsisa64el \
 	| mipsisa64r2 | mipsisa64r2el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
+	| moxie \
 	| mt \
 	| msp430 \
-	| nios | nios2 \
+	| nds32 | nds32le | nds32be \
+	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
-	| or32 \
+	| open8 \
+	| or1k | or32 \
 	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
-	| sh | sh[1234] | sh[24]a | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| rl78 | rx \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
-	| spu | strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
-	| v850 | v850e \
+	| spu \
+	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
+	| ubicom32 \
+	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
 	| we32k \
-	| x86 | xscale | xscalee[bl] | xstormy16 | xtensa \
-	| z8k)
+	| x86 | xc16x | xstormy16 | xtensa \
+	| z8k | z80)
 		basic_machine=$basic_machine-unknown
 		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
-		# Motorola 68HC11/12.
+	c54x)
+		basic_machine=tic54x-unknown
+		;;
+	c55x)
+		basic_machine=tic55x-unknown
+		;;
+	c6x)
+		basic_machine=tic6x-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
 		;;
 	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
 		;;
 	ms1)
 		basic_machine=mt-unknown
 		;;
 
+	strongarm | thumb | xscale)
+		basic_machine=arm-unknown
+		;;
+	xgate)
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	xscaleeb)
+		basic_machine=armeb-unknown
+		;;
+
+	xscaleel)
+		basic_machine=armel-unknown
+		;;
+
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
 	i*86 | x86_64)
 	  basic_machine=$basic_machine-pc
 	  ;;
@@ -310,70 +360,88 @@
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
 	580-* \
 	| a29k-* \
+	| aarch64-* | aarch64_be-* \
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* \
 	| clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| hexagon-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
+	| le32-* | le64-* \
+	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
-	| mips64vr-* | mips64vrel-* \
+	| mips64octeon-* | mips64octeonel-* \
 	| mips64orion-* | mips64orionel-* \
+	| mips64r5900-* | mips64r5900el-* \
+	| mips64vr-* | mips64vrel-* \
 	| mips64vr4100-* | mips64vr4100el-* \
 	| mips64vr4300-* | mips64vr4300el-* \
 	| mips64vr5000-* | mips64vr5000el-* \
 	| mips64vr5900-* | mips64vr5900el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
 	| mipsisa64-* | mipsisa64el-* \
 	| mipsisa64r2-* | mipsisa64r2el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
 	| mipstx39-* | mipstx39el-* \
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
-	| nios-* | nios2-* \
+	| nds32-* | nds32le-* | nds32be-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
+	| open8-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
 	| pyramid-* \
-	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh[24]a-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
+	| rl78-* | romp-* | rs6000-* | rx-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tile*-* \
 	| tron-* \
-	| v850-* | v850e-* | vax-* \
+	| ubicom32-* \
+	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
+	| vax-* \
 	| we32k-* \
-	| x86-* | x86_64-* | xps100-* | xscale-* | xscalee[bl]-* \
-	| xstormy16-* | xtensa-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* \
+	| xstormy16-* | xtensa*-* \
 	| ymp-* \
-	| z8k-*)
+	| z8k-* | z80-*)
+		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
 		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
 		basic_machine=i386-unknown
 		os=-bsd
@@ -431,24 +499,53 @@
 		os=-sysv
 		;;
 	apollo68bsd)
 		basic_machine=m68k-apollo
 		os=-bsd
 		;;
+	aros)
+		basic_machine=i386-pc
+		os=-aros
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
 		;;
 	balance)
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	bluegene*)
+		basic_machine=powerpc-ibm
+		os=-cnk
+		;;
+	c54x-*)
+		basic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c55x-*)
+		basic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c6x-*)
+		basic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	c90)
 		basic_machine=c90-cray
 		os=-unicos
 		;;
+	cegcc)
+		basic_machine=arm-unknown
+		os=-cegcc
+		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
 		;;
 	convex-c2)
 		basic_machine=c2-convex
@@ -471,14 +568,14 @@
 		os=-unicos
 		;;
 	craynv)
 		basic_machine=craynv-cray
 		os=-unicosmp
 		;;
-	cr16c)
-		basic_machine=cr16c-unknown
+	cr16 | cr16-*)
+		basic_machine=cr16-unknown
 		os=-elf
 		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
 	crisv32 | crisv32-* | etraxfs*)
@@ -510,12 +607,16 @@
 		basic_machine=m68k-motorola
 		;;
 	delta88)
 		basic_machine=m88k-motorola
 		os=-sysv3
 		;;
+	dicos)
+		basic_machine=i686-pc
+		os=-dicos
+		;;
 	djgpp)
 		basic_machine=i586-pc
 		os=-msdosdjgpp
 		;;
 	dpx20 | dpx20-*)
 		basic_machine=rs6000-bull
@@ -625,13 +726,12 @@
 		basic_machine=hppa1.1-hp
 		os=-proelf
 		;;
 	i370-ibm* | ibm*)
 		basic_machine=i370-ibm
 		;;
-# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
 	i*86v32)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv32
 		;;
 	i*86v4*)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
@@ -664,27 +764,46 @@
 		esac
 		;;
 	isi68 | isi)
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	m88k-omron*)
 		basic_machine=m88k-omron
 		;;
 	magnum | m3230)
 		basic_machine=mips-mips
 		os=-sysv
 		;;
 	merlin)
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
+	microblaze*)
+		basic_machine=microblaze-xilinx
+		;;
+	mingw64)
+		basic_machine=x86_64-pc
+		os=-mingw64
+		;;
 	mingw32)
 		basic_machine=i386-pc
 		os=-mingw32
 		;;
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
+		;;
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
 	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
 		basic_machine=m68k-atari
 		os=-mint
@@ -707,16 +826,24 @@
 		basic_machine=i386-pc
 		os=-msdos
 		;;
 	ms1-*)
 		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
 		;;
+	msys)
+		basic_machine=i386-pc
+		os=-msys
+		;;
 	mvs)
 		basic_machine=i370-ibm
 		os=-mvs
 		;;
+	nacl)
+		basic_machine=le32-unknown
+		os=-nacl
+		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
 		;;
 	netbsd386)
 		basic_machine=i386-unknown
@@ -775,12 +902,18 @@
 		basic_machine=mips-compaq
 		os=-nonstopux
 		;;
 	np1)
 		basic_machine=np1-gould
 		;;
+	neo-tandem)
+		basic_machine=neo-tandem
+		;;
+	nse-tandem)
+		basic_machine=nse-tandem
+		;;
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
 	op50n-* | op60c-*)
 		basic_machine=hppa1.1-oki
 		os=-proelf
@@ -805,12 +938,20 @@
 		os=-hiuxwe2
 		;;
 	paragon)
 		basic_machine=i860-intel
 		os=-osf
 		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
 	pbd)
 		basic_machine=sparc-tti
 		;;
 	pbb)
 		basic_machine=m68k-tti
 		;;
@@ -849,15 +990,16 @@
 		;;
 	pn)
 		basic_machine=pn-gould
 		;;
 	power)	basic_machine=power-ibm
 		;;
-	ppc)	basic_machine=powerpc-unknown
+	ppc | ppcbe)	basic_machine=powerpc-unknown
 		;;
-	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+	ppc-* | ppcbe-*)
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppcle | powerpclittle | ppc-le | powerpc-little)
 		basic_machine=powerpcle-unknown
 		;;
 	ppcle-* | powerpclittle-*)
 		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
@@ -876,13 +1018,17 @@
 		basic_machine=i386-ibm
 		;;
 	pw32)
 		basic_machine=i586-unknown
 		os=-pw32
 		;;
-	rdos)
+	rdos | rdos64)
+		basic_machine=x86_64-pc
+		os=-rdos
+		;;
+	rdos32)
 		basic_machine=i386-pc
 		os=-rdos
 		;;
 	rom68k)
 		basic_machine=m68k-rom68k
 		os=-coff
@@ -906,23 +1052,30 @@
 	sb1)
 		basic_machine=mipsisa64sb1-unknown
 		;;
 	sb1el)
 		basic_machine=mipsisa64sb1el-unknown
 		;;
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
+		;;
 	sei)
 		basic_machine=mips-sei
 		os=-seiux
 		;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
 	sh)
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
+	sh5el)
+		basic_machine=sh5le-unknown
+		;;
 	sh64)
 		basic_machine=sh64-unknown
 		;;
 	sparclite-wrs | simso-wrs)
 		basic_machine=sparclite-wrs
 		os=-vxworks
@@ -938,12 +1091,15 @@
 		basic_machine=m68k-tandem
 		;;
 	stratus)
 		basic_machine=i860-stratus
 		os=-sysv4
 		;;
+	strongarm-* | thumb-*)
+		basic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	sun2)
 		basic_machine=m68000-sun
 		;;
 	sun2os3)
 		basic_machine=m68000-sun
 		os=-sunos3
@@ -994,23 +1150,15 @@
 		os=-unicos
 		;;
 	t90)
 		basic_machine=t90-cray
 		os=-unicos
 		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
-	tic55x | c55x*)
-		basic_machine=tic55x-unknown
-		os=-coff
-		;;
-	tic6x | c6x*)
-		basic_machine=tic6x-unknown
-		os=-coff
+	tile*)
+		basic_machine=$basic_machine-unknown
+		os=-linux-gnu
 		;;
 	tx39)
 		basic_machine=mipstx39-unknown
 		;;
 	tx39el)
 		basic_machine=mipstx39el-unknown
@@ -1073,20 +1221,27 @@
 		basic_machine=i686-pc
 		os=-mingw32
 		;;
 	xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
+	xscale-* | xscalee[bl]-*)
+		basic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`
+		;;
 	ymp)
 		basic_machine=ymp-cray
 		os=-unicos
 		;;
 	z8k-*-coff)
 		basic_machine=z8k-unknown
 		os=-sim
 		;;
+	z80-*-coff)
+		basic_machine=z80-unknown
+		os=-sim
+		;;
 	none)
 		basic_machine=none-none
 		os=-none
 		;;
 
 # Here we handle the default manufacturer of certain CPU types.  It is in
@@ -1119,13 +1274,13 @@
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh[1234] | sh[24]a | sh[34]eb | sh[1234]le | sh[23]ele)
+	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
 		basic_machine=sh-unknown
 		;;
 	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
 		basic_machine=sparc-sun
 		;;
 	cydra)
@@ -1169,12 +1324,15 @@
 if [ x"$os" != x"" ]
 then
 case $os in
         # First match some system type aliases
         # that might get confused with valid system types.
 	# -solaris* is a basic system type, with this one exception.
+	-auroraux)
+		os=-auroraux
+		;;
 	-solaris1 | -solaris1.*)
 		os=`echo $os | sed -e 's|solaris1|sunos4|'`
 		;;
 	-solaris)
 		os=-solaris2
 		;;
@@ -1189,35 +1347,37 @@
 		;;
 	# First accept the basic system types.
 	# The portable systems comes first.
 	# Each alternative MUST END IN A *, to match a version number.
 	# -sysv* is not here because it comes later, after sysvr4.
 	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
-	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
-	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* \
+	      | -aos* | -aros* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
-	      | -openbsd* | -solidbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* \
 	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
 	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* \
-	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
-	      | -mingw32* | -linux-gnu* | -linux-newlib* | -linux-uclibc* \
+	      | -chorusos* | -chorusrdb* | -cegcc* \
+	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
 	      | -uxpv* | -beos* | -mpeix* | -udk* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
 	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
-	      | -skyos* | -haiku* | -rdos* | -toppers*)
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
 		case $basic_machine in
 		    x86-* | i*86-*)
 			;;
@@ -1335,18 +1495,20 @@
 	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
 		os=-mint
 		;;
 	-aros*)
 		os=-aros
 		;;
-	-kaos*)
-		os=-kaos
-		;;
 	-zvmoe)
 		os=-zvmoe
 		;;
+	-dicos*)
+		os=-dicos
+		;;
+	-nacl*)
+		;;
 	-none)
 		;;
 	*)
 		# Get rid of the `-' at the beginning of $os.
 		os=`echo $os | sed 's/[^-]*-//'`
 		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
@@ -1363,12 +1525,15 @@
 # "-sun"), then you have to tell the case statement up towards the top
 # that MANUFACTURER isn't an operating system.  Otherwise, code above
 # will signal an error saying that MANUFACTURER isn't an operating
 # system, and we'll never get to this point.
 
 case $basic_machine in
+	score-*)
+		os=-elf
+		;;
         spu-*)
 		os=-elf
 		;;
 	*-acorn)
 		os=-riscix1.2
 		;;
@@ -1378,12 +1543,24 @@
 	arm*-semi)
 		os=-aout
 		;;
         c4x-* | tic4x-*)
         	os=-coff
 		;;
+	hexagon-*)
+		os=-elf
+		;;
+	tic54x-*)
+		os=-coff
+		;;
+	tic55x-*)
+		os=-coff
+		;;
+	tic6x-*)
+		os=-coff
+		;;
 	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
 		;;
 	pdp11-*)
 		os=-none
@@ -1396,25 +1573,28 @@
 		;;
 	i386-sun)
 		os=-sunos4.0.2
 		;;
 	m68000-sun)
 		os=-sunos3
-		# This also exists in the configure program, but was not the
-		# default.
-		# os=-sunos4
 		;;
 	m68*-cisco)
 		os=-aout
 		;;
+	mep-*)
+		os=-elf
+		;;
 	mips*-cisco)
 		os=-elf
 		;;
 	mips*-*)
 		os=-elf
 		;;
+	or1k-*)
+		os=-elf
+		;;
 	or32-*)
 		os=-coff
 		;;
 	*-tti)	# must be before sparc entry or we get the wrong os.
 		os=-sysv3
 		;;
@@ -1532,13 +1712,13 @@
 			-riscix*)
 				vendor=acorn
 				;;
 			-sunos*)
 				vendor=sun
 				;;
-			-aix*)
+			-cnk*|-aix*)
 				vendor=ibm
 				;;
 			-beos*)
 				vendor=be
 				;;
 			-hpux*)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/configure	2007-12-18 15:32:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/configure	2011-01-05 00:00:31.000000000 +0800
@@ -5,12 +5,14 @@
 
 dir=`dirname $0`
 realconfigure="$dir/configure.sh"
 
 if test ! -f "$realconfigure"; then
     if test -f "$HOME/build_farm/build_test.fns"; then
+	# Test the included popt
+	set -- --with-included-popt "${@}"
 	# Allow the build farm to grab latest files via rsync.
 	actions='build fetch'
     else
 	actions='build'
     fi
     if "$dir/prepare-source" $actions; then
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/configure.ac	2011-09-24 00:13:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/configure.ac	2013-09-29 04:55:54.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.59)
 
-RSYNC_VERSION=3.0.9
+RSYNC_VERSION=3.1.0
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -36,12 +36,13 @@
 
 dnl Checks for programs.
 AC_PROG_CC
 AC_PROG_CPP
 AC_PROG_EGREP
 AC_PROG_INSTALL
+AC_PROG_MKDIR_P
 AC_PROG_CC_STDC
 AC_SUBST(SHELL)
 
 AC_DEFINE([_GNU_SOURCE], 1,
           [Define _GNU_SOURCE so that we get all necessary prototypes])
 
@@ -75,12 +76,21 @@
 	CFLAGS="$CFLAGS -Wall -W"
 fi
 
 AC_ARG_WITH(included-popt,
         AC_HELP_STRING([--with-included-popt], [use bundled popt library, not from system]))
 
+AC_ARG_WITH(included-zlib,
+        AC_HELP_STRING([--with-included-zlib], [use bundled zlib library, not from system]))
+
+AC_ARG_WITH(protected-args,
+        AC_HELP_STRING([--with-protected-args], [make --protected-args option the default]))
+if test x"$with_protected_args" = x"yes"; then
+	AC_DEFINE_UNQUOTED(RSYNC_USE_PROTECTED_ARGS, 1, [Define to 1 if --protected-args should be the default])
+fi
+
 AC_ARG_WITH(rsync-path,
 	AC_HELP_STRING([--with-rsync-path=PATH], [set default --rsync-path to PATH (default: rsync)]),
 	[ RSYNC_PATH="$with_rsync_path" ],
 	[ RSYNC_PATH="rsync" ])
 
 AC_DEFINE_UNQUOTED(RSYNC_PATH, "$RSYNC_PATH", [location of rsync on remote machine])
@@ -121,14 +131,20 @@
 fi
 AC_DEFINE_UNQUOTED(RSYNC_RSH, "$RSYNC_RSH", [default -e command])
 
 AC_CHECK_PROG(HAVE_YODL2MAN, yodl2man, 1, 0)
 if test x$HAVE_YODL2MAN = x1; then
     MAKE_MAN=man
+else
+    MAKE_MAN=man-copy
 fi
 
+# Some programs on solaris are only found in /usr/xpg4/bin (or work better than others versions).
+AC_PATH_PROG(SHELL_PATH, sh, /bin/sh, [/usr/xpg4/bin$PATH_SEPARATOR$PATH])
+AC_PATH_PROG(FAKEROOT_PATH, fakeroot, /usr/bin/fakeroot, [/usr/xpg4/bin$PATH_SEPARATOR$PATH])
+
 AC_ARG_WITH(nobody-group,
     AC_HELP_STRING([--with-nobody-group=GROUP],
 		   [set the default unprivileged group (default nobody or nogroup)]),
     [ NOBODY_GROUP="$with_nobody_group" ])
 
 if test x"$with_nobody_group" = x; then
@@ -328,13 +344,14 @@
 AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
     sys/un.h sys/attr.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
     netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h \
     sys/acl.h acl/libacl.h attr/xattr.h sys/xattr.h sys/extattr.h \
-    popt.h popt/popt.h netinet/in_systm.h netinet/ip.h)
+    popt.h popt/popt.h linux/falloc.h netinet/in_systm.h netinet/ip.h \
+    zlib.h)
 AC_HEADER_MAJOR
 
 AC_CACHE_CHECK([if makedev takes 3 args],rsync_cv_MAKEDEV_TAKES_3_ARGS,[
 AC_TRY_RUN([
 #include <sys/types.h>
 #ifdef MAJOR_IN_MKDEV
@@ -376,13 +393,24 @@
 AC_C_LONG_DOUBLE
 
 AC_TYPE_SIGNAL
 AC_TYPE_UID_T
 AC_CHECK_TYPES([mode_t,off_t,size_t,pid_t,id_t])
 AC_TYPE_GETGROUPS
-AC_CHECK_MEMBERS([struct stat.st_rdev])
+AC_CHECK_MEMBERS([struct stat.st_rdev,
+		  struct stat.st_mtimensec,
+		  struct stat.st_mtim.tv_nsec],,,[
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif])
 
 TYPE_SOCKLEN_T
 
 AC_CACHE_CHECK([for errno in errno.h],rsync_cv_errno, [
     AC_TRY_COMPILE([#include <errno.h>],[int i = errno],
 	rsync_cv_errno=yes,rsync_cv_have_errno_decl=no)])
@@ -570,20 +598,56 @@
 AC_CHECK_FUNCS(waitpid wait4 getcwd strdup chown chmod lchmod mknod mkfifo \
     fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \
     memmove lchown vsnprintf snprintf vasprintf asprintf setsid strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
     setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
     seteuid strerror putenv iconv_open locale_charset nl_langinfo getxattr \
-    extattr_get_link sigaction sigprocmask setattrlist \
-    utimensat)
+    extattr_get_link sigaction sigprocmask setattrlist getgrouplist \
+    initgroups utimensat posix_fallocate attropen setvbuf)
 
 dnl cygwin iconv.h defines iconv_open as libiconv_open
 if test x"$ac_cv_func_iconv_open" != x"yes"; then
     AC_CHECK_FUNC(libiconv_open, [ac_cv_func_iconv_open=yes; AC_DEFINE(HAVE_ICONV_OPEN, 1)])
 fi
 
+dnl Preallocation stuff (also fallocate, posix_fallocate function tests above):
+
+AC_CACHE_CHECK([for useable fallocate],rsync_cv_have_fallocate,[
+AC_TRY_LINK([#include <fcntl.h>
+#include <sys/types.h>],
+[fallocate(0, 0, 0, 0);],
+rsync_cv_have_fallocate=yes,rsync_cv_have_fallocate=no)])
+if test x"$rsync_cv_have_fallocate" = x"yes"; then
+    AC_DEFINE(HAVE_FALLOCATE, 1, [Define to 1 if you have the fallocate function and it compiles and links without error])
+fi
+
+AC_CACHE_CHECK([for SYS_fallocate],rsync_cv_have_sys_fallocate,[
+AC_TRY_COMPILE([#include <sys/syscall.h>
+#include <sys/types.h>],
+[syscall(SYS_fallocate, 0, 0, (loff_t)0, (loff_t)0);],
+rsync_cv_have_sys_fallocate=yes,rsync_cv_have_sys_fallocate=no)])
+if test x"$rsync_cv_have_sys_fallocate" = x"yes"; then
+    AC_DEFINE(HAVE_SYS_FALLOCATE, 1, [Define to 1 if you have the SYS_fallocate syscall number])
+fi
+
+if test x"$ac_cv_func_posix_fallocate" = x"yes"; then
+    AC_MSG_CHECKING([whether posix_fallocate is efficient])
+    case $host_os in
+    *cygwin*)
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(HAVE_EFFICIENT_POSIX_FALLOCATE, 1,
+		  [Define if posix_fallocate is efficient (Cygwin)])
+	;;
+    *)
+	AC_MSG_RESULT(no)
+	;;
+    esac
+fi
+
+dnl End of preallocation stuff
+
 AC_CHECK_FUNCS(getpgrp tcgetpgrp)
 if test $ac_cv_func_getpgrp = yes; then
     AC_FUNC_GETPGRP
 fi
 
 AC_ARG_ENABLE(iconv-open,
@@ -683,12 +747,14 @@
 }],
 rsync_cv_HAVE_SOCKETPAIR=yes,rsync_cv_HAVE_SOCKETPAIR=no,rsync_cv_HAVE_SOCKETPAIR=cross)])
 if test x"$rsync_cv_HAVE_SOCKETPAIR" = x"yes"; then
     AC_DEFINE(HAVE_SOCKETPAIR, 1, [Define to 1 if you have the "socketpair" function])
 fi
 
+AC_CHECK_FUNCS(getpass, , [AC_LIBOBJ(lib/getpass)])
+
 if test x"$with_included_popt" != x"yes"; then
     AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])
 fi
 if test x"$ac_cv_header_popt_popt_h" = x"yes"; then
     # If the system has /usr/include/popt/popt.h, we enable the
     # included popt because an attempt to "#include <popt/popt.h>"
@@ -711,12 +777,31 @@
 	AC_MSG_WARN([included libpopt will use malloc, not alloca (which wastes a small amount of memory)])
     fi
 else
     AC_MSG_RESULT(no)
 fi
 
+# We default to using our zlib unless --with-included-zlib=no is given.
+if test x"$with_included_zlib" != x"no"; then
+    with_included_zlib=yes
+elif test x"$ac_cv_header_zlib_h" != x"yes"; then
+    with_included_zlib=yes
+fi
+if test x"$with_included_zlib" != x"yes"; then
+    AC_CHECK_LIB(z, deflateParams, , [with_included_zlib=yes])
+fi
+
+AC_MSG_CHECKING([whether to use included zlib])
+if test x"$with_included_zlib" = x"yes"; then
+    AC_MSG_RESULT($srcdir/zlib)
+    BUILD_ZLIB='$(zlib_OBJS)'
+    CFLAGS="$CFLAGS -I$srcdir/zlib"
+else
+    AC_MSG_RESULT(no)
+fi
+
 AC_CACHE_CHECK([for unsigned char],rsync_cv_SIGNED_CHAR_OK,[
 AC_TRY_COMPILE([],[signed char *s = ""],
 rsync_cv_SIGNED_CHAR_OK=yes,rsync_cv_SIGNED_CHAR_OK=no)])
 if test x"$rsync_cv_SIGNED_CHAR_OK" = x"yes"; then
     AC_DEFINE(SIGNED_CHAR_OK, 1, [Define to 1 if "signed char" is a valid type])
 fi
@@ -864,14 +949,18 @@
 fi
 
 AC_SUBST(OBJ_SAVE)
 AC_SUBST(OBJ_RESTORE)
 AC_SUBST(CC_SHOBJ_FLAG)
 AC_SUBST(BUILD_POPT)
+AC_SUBST(BUILD_ZLIB)
 AC_SUBST(MAKE_MAN)
 
+AC_PATH_PROG([STUNNEL], [stunnel], [stunnel], [$PATH$PATH_SEPARATOR/usr/sbin$PATH_SEPARATOR/sbin])
+AC_PATH_PROG([STUNNEL4], [stunnel4], [$STUNNEL], [$PATH$PATH_SEPARATOR/usr/sbin$PATH_SEPARATOR/sbin])
+
 AC_CHECK_FUNCS(_acl __acl _facl __facl)
 #################################################
 # check for ACL support
 
 AC_MSG_CHECKING([whether to support ACLs])
 AC_ARG_ENABLE(acl-support,
@@ -884,13 +973,13 @@
     case "$host_os" in
     *sysv5*)
 	AC_MSG_RESULT(Using UnixWare ACLs)
 	AC_DEFINE(HAVE_UNIXWARE_ACLS, 1, [true if you have UnixWare ACLs])
 	AC_DEFINE(SUPPORT_ACLS, 1, [Define to 1 to add support for ACLs])
 	;;
-    *solaris*|*cygwin*)
+    solaris*|*cygwin*)
 	AC_MSG_RESULT(Using solaris ACLs)
 	AC_DEFINE(HAVE_SOLARIS_ACLS, 1, [true if you have solaris ACLs])
 	AC_DEFINE(SUPPORT_ACLS, 1)
 	;;
     *hpux*)
 	AC_MSG_RESULT(Using HPUX ACLs)
@@ -953,13 +1042,13 @@
 #################################################
 # check for extended attribute support
 AC_MSG_CHECKING(whether to support extended attributes)
 AC_ARG_ENABLE(xattr-support,
     AC_HELP_STRING([--disable-xattr-support],
 	    [disable extended attributes]),
-    [], [case "$ac_cv_func_getxattr$ac_cv_func_extattr_get_link" in
+    [], [case "$ac_cv_func_getxattr$ac_cv_func_extattr_get_link$ac_cv_func_attropen" in
 	*yes*) enable_xattr_support=maybe ;;
 	*) enable_xattr_support=no ;;
 	esac])
 AH_TEMPLATE([SUPPORT_XATTRS],
 [Define to 1 to add support for extended attributes])
 if test x"$enable_xattr_support" = x"no"; then
@@ -967,12 +1056,13 @@
 else
     case "$host_os" in
     *linux*)
 	AC_MSG_RESULT(Using Linux xattrs)
 	AC_DEFINE(HAVE_LINUX_XATTRS, 1, [True if you have Linux xattrs])
 	AC_DEFINE(SUPPORT_XATTRS, 1)
+	AC_DEFINE(NO_SYMLINK_USER_XATTRS, 1, [True if symlinks do not support user xattrs])
 	;;
     darwin*)
 	AC_MSG_RESULT(Using OS X xattrs)
 	AC_DEFINE(HAVE_OSX_XATTRS, 1, [True if you have Mac OS X xattrs])
 	AC_DEFINE(SUPPORT_XATTRS, 1)
 	AC_DEFINE(NO_DEVICE_XATTRS, 1, [True if device files do not support xattrs])
@@ -981,13 +1071,15 @@
     freebsd*)
 	AC_MSG_RESULT(Using FreeBSD extattrs)
 	AC_DEFINE(HAVE_FREEBSD_XATTRS, 1, [True if you have FreeBSD xattrs])
 	AC_DEFINE(SUPPORT_XATTRS, 1)
 	;;
     solaris*)
-	# Better Solaris support coming in 3.1.0...
+	AC_MSG_RESULT(Using Solaris xattrs)
+	AC_DEFINE(HAVE_SOLARIS_XATTRS, 1, [True if you have Solaris xattrs])
+	AC_DEFINE(SUPPORT_XATTRS, 1)
 	AC_DEFINE(NO_SYMLINK_XATTRS, 1, [True if symlinks do not support xattrs])
 	;;
     *)
 	if test x"$enable_xattr_support" = x"yes"; then
 	    AC_MSG_ERROR(Failed to find extended attribute support)
 	else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/configure.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/configure.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/configure.sh	2011-09-24 00:41:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/configure.sh	2013-09-29 10:57:19.000000000 +0800
@@ -598,21 +598,27 @@
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif"
 
 ac_header_list=
 ac_subst_vars='LTLIBOBJS
+STUNNEL4
+STUNNEL
 MAKE_MAN
+BUILD_ZLIB
 BUILD_POPT
 CC_SHOBJ_FLAG
 OBJ_RESTORE
 OBJ_SAVE
 ALLOCA
 LIBOBJS
+FAKEROOT_PATH
+SHELL_PATH
 HAVE_YODL2MAN
 HAVE_REMSH
+MKDIR_P
 INSTALL_DATA
 INSTALL_SCRIPT
 INSTALL_PROGRAM
 EGREP
 GREP
 CPP
@@ -674,12 +680,14 @@
 ac_user_opts='
 enable_option_checking
 enable_debug
 enable_profile
 enable_maintainer_mode
 with_included_popt
+with_included_zlib
+with_protected_args
 with_rsync_path
 with_rsyncd_conf
 with_rsh
 with_nobody_group
 enable_largefile
 enable_ipv6
@@ -1324,12 +1332,14 @@
   --disable-xattr-support disable extended attributes
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-included-popt    use bundled popt library, not from system
+  --with-included-zlib    use bundled zlib library, not from system
+  --with-protected-args   make --protected-args option the default
   --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)
   --with-rsyncd-conf=PATH set configuration file for rsync server to PATH
                           (default: /etc/rsyncd.conf)
   --with-rsh=CMD          set remote shell command to CMD (default: ssh)
   --with-nobody-group=GROUP
                           set the default unprivileged group (default nobody
@@ -2416,13 +2426,13 @@
 
 
 ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=3.0.9
+RSYNC_VERSION=3.1.0
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: Configuring rsync $RSYNC_VERSION" >&5
 $as_echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -3703,12 +3713,54 @@
 test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
 
 test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
+$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
+if test -z "$MKDIR_P"; then
+  if ${ac_cv_path_mkdir+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in mkdir gmkdir; do
+	 for ac_exec_ext in '' $ac_executable_extensions; do
+	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
+	     'mkdir (GNU coreutils) '* | \
+	     'mkdir (coreutils) '* | \
+	     'mkdir (fileutils) '4.1*)
+	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
+	       break 3;;
+	   esac
+	 done
+       done
+  done
+IFS=$as_save_IFS
+
+fi
+
+  test -d ./--version && rmdir ./--version
+  if test "${ac_cv_path_mkdir+set}" = set; then
+    MKDIR_P="$ac_cv_path_mkdir -p"
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for MKDIR_P within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    MKDIR_P="$ac_install_sh -d"
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
+$as_echo "$MKDIR_P" >&6; }
+
    case $ac_cv_prog_cc_stdc in #(
   no) :
     ac_cv_prog_cc_c99=no; ac_cv_prog_cc_c89=no ;; #(
   *) :
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C99" >&5
 $as_echo_n "checking for $CC option to accept ISO C99... " >&6; }
@@ -4045,12 +4097,33 @@
 if test "${with_included_popt+set}" = set; then :
   withval=$with_included_popt;
 fi
 
 
 
+# Check whether --with-included-zlib was given.
+if test "${with_included_zlib+set}" = set; then :
+  withval=$with_included_zlib;
+fi
+
+
+
+# Check whether --with-protected-args was given.
+if test "${with_protected_args+set}" = set; then :
+  withval=$with_protected_args;
+fi
+
+if test x"$with_protected_args" = x"yes"; then
+
+cat >>confdefs.h <<_ACEOF
+#define RSYNC_USE_PROTECTED_ARGS 1
+_ACEOF
+
+fi
+
+
 # Check whether --with-rsync-path was given.
 if test "${with_rsync_path+set}" = set; then :
   withval=$with_rsync_path;  RSYNC_PATH="$with_rsync_path"
 else
    RSYNC_PATH="rsync"
 fi
@@ -4190,14 +4263,100 @@
 $as_echo "no" >&6; }
 fi
 
 
 if test x$HAVE_YODL2MAN = x1; then
     MAKE_MAN=man
+else
+    MAKE_MAN=man-copy
 fi
 
+# Some programs on solaris are only found in /usr/xpg4/bin (or work better than others versions).
+# Extract the first word of "sh", so it can be a program name with args.
+set dummy sh; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_SHELL_PATH+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $SHELL_PATH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_SHELL_PATH="$SHELL_PATH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /usr/xpg4/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_SHELL_PATH="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_SHELL_PATH" && ac_cv_path_SHELL_PATH="/bin/sh"
+  ;;
+esac
+fi
+SHELL_PATH=$ac_cv_path_SHELL_PATH
+if test -n "$SHELL_PATH"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $SHELL_PATH" >&5
+$as_echo "$SHELL_PATH" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+# Extract the first word of "fakeroot", so it can be a program name with args.
+set dummy fakeroot; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_FAKEROOT_PATH+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $FAKEROOT_PATH in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_FAKEROOT_PATH="$FAKEROOT_PATH" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /usr/xpg4/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_FAKEROOT_PATH="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_FAKEROOT_PATH" && ac_cv_path_FAKEROOT_PATH="/usr/bin/fakeroot"
+  ;;
+esac
+fi
+FAKEROOT_PATH=$ac_cv_path_FAKEROOT_PATH
+if test -n "$FAKEROOT_PATH"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $FAKEROOT_PATH" >&5
+$as_echo "$FAKEROOT_PATH" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
 
 # Check whether --with-nobody-group was given.
 if test "${with_nobody_group+set}" = set; then :
   withval=$with_nobody_group;  NOBODY_GROUP="$with_nobody_group"
 fi
 
@@ -5359,13 +5518,14 @@
 for ac_header in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
     sys/un.h sys/attr.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
     netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h \
     sys/acl.h acl/libacl.h attr/xattr.h sys/xattr.h sys/extattr.h \
-    popt.h popt/popt.h netinet/in_systm.h netinet/ip.h
+    popt.h popt/popt.h linux/falloc.h netinet/in_systm.h netinet/ip.h \
+    zlib.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
 if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
@@ -6147,21 +6307,69 @@
 
 cat >>confdefs.h <<_ACEOF
 #define GETGROUPS_T $ac_cv_type_getgroups
 _ACEOF
 
 
-ac_fn_c_check_member "$LINENO" "struct stat" "st_rdev" "ac_cv_member_struct_stat_st_rdev" "$ac_includes_default"
+ac_fn_c_check_member "$LINENO" "struct stat" "st_rdev" "ac_cv_member_struct_stat_st_rdev" "
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+"
 if test "x$ac_cv_member_struct_stat_st_rdev" = xyes; then :
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_STRUCT_STAT_ST_RDEV 1
 _ACEOF
 
 
 fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_mtimensec" "ac_cv_member_struct_stat_st_mtimensec" "
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+"
+if test "x$ac_cv_member_struct_stat_st_mtimensec" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_STAT_ST_MTIMENSEC 1
+_ACEOF
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_mtim.tv_nsec" "ac_cv_member_struct_stat_st_mtim_tv_nsec" "
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+"
+if test "x$ac_cv_member_struct_stat_st_mtim_tv_nsec" = xyes; then :
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+_ACEOF
+
+
+fi
 
 
 
    ac_fn_c_check_type "$LINENO" "socklen_t" "ac_cv_type_socklen_t" "#include <sys/types.h>
 #include <sys/socket.h>
 "
@@ -7445,14 +7653,14 @@
 for ac_func in waitpid wait4 getcwd strdup chown chmod lchmod mknod mkfifo \
     fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \
     memmove lchown vsnprintf snprintf vasprintf asprintf setsid strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
     setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
     seteuid strerror putenv iconv_open locale_charset nl_langinfo getxattr \
-    extattr_get_link sigaction sigprocmask setattrlist \
-    utimensat
+    extattr_get_link sigaction sigprocmask setattrlist getgrouplist \
+    initgroups utimensat posix_fallocate attropen setvbuf
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
 if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
 #define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
@@ -7468,12 +7676,99 @@
   ac_cv_func_iconv_open=yes; $as_echo "#define HAVE_ICONV_OPEN 1" >>confdefs.h
 
 fi
 
 fi
 
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for useable fallocate" >&5
+$as_echo_n "checking for useable fallocate... " >&6; }
+if ${rsync_cv_have_fallocate+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <fcntl.h>
+#include <sys/types.h>
+int
+main ()
+{
+fallocate(0, 0, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  rsync_cv_have_fallocate=yes
+else
+  rsync_cv_have_fallocate=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $rsync_cv_have_fallocate" >&5
+$as_echo "$rsync_cv_have_fallocate" >&6; }
+if test x"$rsync_cv_have_fallocate" = x"yes"; then
+
+$as_echo "#define HAVE_FALLOCATE 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for SYS_fallocate" >&5
+$as_echo_n "checking for SYS_fallocate... " >&6; }
+if ${rsync_cv_have_sys_fallocate+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/syscall.h>
+#include <sys/types.h>
+int
+main ()
+{
+syscall(SYS_fallocate, 0, 0, (loff_t)0, (loff_t)0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  rsync_cv_have_sys_fallocate=yes
+else
+  rsync_cv_have_sys_fallocate=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $rsync_cv_have_sys_fallocate" >&5
+$as_echo "$rsync_cv_have_sys_fallocate" >&6; }
+if test x"$rsync_cv_have_sys_fallocate" = x"yes"; then
+
+$as_echo "#define HAVE_SYS_FALLOCATE 1" >>confdefs.h
+
+fi
+
+if test x"$ac_cv_func_posix_fallocate" = x"yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether posix_fallocate is efficient" >&5
+$as_echo_n "checking whether posix_fallocate is efficient... " >&6; }
+    case $host_os in
+    *cygwin*)
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+$as_echo "#define HAVE_EFFICIENT_POSIX_FALLOCATE 1" >>confdefs.h
+
+	;;
+    *)
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	;;
+    esac
+fi
+
+
 for ac_func in getpgrp tcgetpgrp
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
 if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
@@ -7724,12 +8019,31 @@
 if test x"$rsync_cv_HAVE_SOCKETPAIR" = x"yes"; then
 
 $as_echo "#define HAVE_SOCKETPAIR 1" >>confdefs.h
 
 fi
 
+for ac_func in getpass
+do :
+  ac_fn_c_check_func "$LINENO" "getpass" "ac_cv_func_getpass"
+if test "x$ac_cv_func_getpass" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GETPASS 1
+_ACEOF
+
+else
+  case " $LIBOBJS " in
+  *" lib/getpass.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS lib/getpass.$ac_objext"
+ ;;
+esac
+
+fi
+done
+
+
 if test x"$with_included_popt" != x"yes"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for poptGetContext in -lpopt" >&5
 $as_echo_n "checking for poptGetContext in -lpopt... " >&6; }
 if ${ac_cv_lib_popt_poptGetContext+:} false; then :
   $as_echo_n "(cached) " >&6
 else
@@ -7802,12 +8116,80 @@
     fi
 else
     { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
+# We default to using our zlib unless --with-included-zlib=no is given.
+if test x"$with_included_zlib" != x"no"; then
+    with_included_zlib=yes
+elif test x"$ac_cv_header_zlib_h" != x"yes"; then
+    with_included_zlib=yes
+fi
+if test x"$with_included_zlib" != x"yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for deflateParams in -lz" >&5
+$as_echo_n "checking for deflateParams in -lz... " >&6; }
+if ${ac_cv_lib_z_deflateParams+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char deflateParams ();
+int
+main ()
+{
+return deflateParams ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_z_deflateParams=yes
+else
+  ac_cv_lib_z_deflateParams=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_deflateParams" >&5
+$as_echo "$ac_cv_lib_z_deflateParams" >&6; }
+if test "x$ac_cv_lib_z_deflateParams" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBZ 1
+_ACEOF
+
+  LIBS="-lz $LIBS"
+
+else
+  with_included_zlib=yes
+fi
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to use included zlib" >&5
+$as_echo_n "checking whether to use included zlib... " >&6; }
+if test x"$with_included_zlib" = x"yes"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $srcdir/zlib" >&5
+$as_echo "$srcdir/zlib" >&6; }
+    BUILD_ZLIB='$(zlib_OBJS)'
+    CFLAGS="$CFLAGS -I$srcdir/zlib"
+else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for unsigned char" >&5
 $as_echo_n "checking for unsigned char... " >&6; }
 if ${rsync_cv_SIGNED_CHAR_OK+:} false; then :
   $as_echo_n "(cached) " >&6
 else
 
@@ -8154,12 +8536,96 @@
 
 
 
 
 
 
+
+# Extract the first word of "stunnel", so it can be a program name with args.
+set dummy stunnel; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_STUNNEL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $STUNNEL in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_STUNNEL="$STUNNEL" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/sbin$PATH_SEPARATOR/sbin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_STUNNEL="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_STUNNEL" && ac_cv_path_STUNNEL="stunnel"
+  ;;
+esac
+fi
+STUNNEL=$ac_cv_path_STUNNEL
+if test -n "$STUNNEL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STUNNEL" >&5
+$as_echo "$STUNNEL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+# Extract the first word of "stunnel4", so it can be a program name with args.
+set dummy stunnel4; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_STUNNEL4+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $STUNNEL4 in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_STUNNEL4="$STUNNEL4" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/sbin$PATH_SEPARATOR/sbin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_STUNNEL4="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_STUNNEL4" && ac_cv_path_STUNNEL4="$STUNNEL"
+  ;;
+esac
+fi
+STUNNEL4=$ac_cv_path_STUNNEL4
+if test -n "$STUNNEL4"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STUNNEL4" >&5
+$as_echo "$STUNNEL4" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
 for ac_func in _acl __acl _facl __facl
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
 if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
   cat >>confdefs.h <<_ACEOF
@@ -8192,13 +8658,13 @@
 $as_echo "#define HAVE_UNIXWARE_ACLS 1" >>confdefs.h
 
 
 $as_echo "#define SUPPORT_ACLS 1" >>confdefs.h
 
 	;;
-    *solaris*|*cygwin*)
+    solaris*|*cygwin*)
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Using solaris ACLs" >&5
 $as_echo "Using solaris ACLs" >&6; }
 
 $as_echo "#define HAVE_SOLARIS_ACLS 1" >>confdefs.h
 
 	$as_echo "#define SUPPORT_ACLS 1" >>confdefs.h
@@ -8386,13 +8852,13 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to support extended attributes" >&5
 $as_echo_n "checking whether to support extended attributes... " >&6; }
 # Check whether --enable-xattr-support was given.
 if test "${enable_xattr_support+set}" = set; then :
   enableval=$enable_xattr_support;
 else
-  case "$ac_cv_func_getxattr$ac_cv_func_extattr_get_link" in
+  case "$ac_cv_func_getxattr$ac_cv_func_extattr_get_link$ac_cv_func_attropen" in
 	*yes*) enable_xattr_support=maybe ;;
 	*) enable_xattr_support=no ;;
 	esac
 fi
 
 
@@ -8406,12 +8872,15 @@
 $as_echo "Using Linux xattrs" >&6; }
 
 $as_echo "#define HAVE_LINUX_XATTRS 1" >>confdefs.h
 
 	$as_echo "#define SUPPORT_XATTRS 1" >>confdefs.h
 
+
+$as_echo "#define NO_SYMLINK_USER_XATTRS 1" >>confdefs.h
+
 	;;
     darwin*)
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Using OS X xattrs" >&5
 $as_echo "Using OS X xattrs" >&6; }
 
 $as_echo "#define HAVE_OSX_XATTRS 1" >>confdefs.h
@@ -8432,13 +8901,19 @@
 $as_echo "#define HAVE_FREEBSD_XATTRS 1" >>confdefs.h
 
 	$as_echo "#define SUPPORT_XATTRS 1" >>confdefs.h
 
 	;;
     solaris*)
-	# Better Solaris support coming in 3.1.0...
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: Using Solaris xattrs" >&5
+$as_echo "Using Solaris xattrs" >&6; }
+
+$as_echo "#define HAVE_SOLARIS_XATTRS 1" >>confdefs.h
+
+	$as_echo "#define SUPPORT_XATTRS 1" >>confdefs.h
+
 
 $as_echo "#define NO_SYMLINK_XATTRS 1" >>confdefs.h
 
 	;;
     *)
 	if test x"$enable_xattr_support" = x"yes"; then
@@ -9080,12 +9555,13 @@
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
 ac_pwd='$ac_pwd'
 srcdir='$srcdir'
 INSTALL='$INSTALL'
+MKDIR_P='$MKDIR_P'
 test -n "\$AWK" || AWK=awk
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # The default lists apply if the user does not specify any file.
 ac_need_defaults=:
@@ -9644,12 +10120,17 @@
   #
 
   case $INSTALL in
   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
   *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
   esac
+  ac_MKDIR_P=$MKDIR_P
+  case $MKDIR_P in
+  [\\/$]* | ?:[\\/]* ) ;;
+  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
+  esac
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # If the template does not know about datarootdir, expand it.
 # FIXME: This hack should be removed a few years after 2.60.
 ac_datarootdir_hack=; ac_datarootdir_seen=
@@ -9698,12 +10179,13 @@
 s&@top_srcdir@&$ac_top_srcdir&;t t
 s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
 s&@builddir@&$ac_builddir&;t t
 s&@abs_builddir@&$ac_abs_builddir&;t t
 s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
 s&@INSTALL@&$ac_INSTALL&;t t
+s&@MKDIR_P@&$ac_MKDIR_P&;t t
 $ac_datarootdir_hack
 "
 eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
   >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0: delete.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/errcode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/errcode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/errcode.h	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/errcode.h	2013-01-20 03:05:53.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Error codes returned by rsync.
  *
  * Copyright (C) 1998-2000 Andrew Tridgell
- * Copyright (C) 2003-2008 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/exclude.c	2011-09-15 22:48:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/exclude.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * The filter include/exclude routines.
  *
  * Copyright (C) 1996-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -19,13 +19,12 @@
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
-extern int verbose;
 extern int am_server;
 extern int am_sender;
 extern int eol_nulls;
 extern int io_error;
 extern int local_server;
 extern int prune_empty_dirs;
@@ -38,23 +37,19 @@
 extern int module_id;
 
 extern char curr_dir[MAXPATHLEN];
 extern unsigned int curr_dir_len;
 extern unsigned int module_dirlen;
 
-struct filter_list_struct filter_list = { 0, 0, "" };
-struct filter_list_struct cvs_filter_list = { 0, 0, " [global CVS]" };
-struct filter_list_struct daemon_filter_list = { 0, 0, " [daemon]" };
+filter_rule_list filter_list = { .debug_type = "" };
+filter_rule_list cvs_filter_list = { .debug_type = " [global CVS]" };
+filter_rule_list daemon_filter_list = { .debug_type = " [daemon]" };
 
 /* Need room enough for ":MODS " prefix plus some room to grow. */
 #define MAX_RULE_PREFIX (16)
 
-#define MODIFIERS_MERGE_FILE "-+Cenw"
-#define MODIFIERS_INCL_EXCL "/!Crsp"
-#define MODIFIERS_HIDE_PROTECT "/!p"
-
 #define SLASH_WILD3_SUFFIX "/***"
 
 /* The dirbuf is set by push_local_filters() to the current subdirectory
  * relative to curr_dir that is being processed.  The path always has a
  * trailing slash appended, and the variable dirbuf_len contains the length
  * of this path prefix.  The path is always absolute. */
@@ -65,13 +60,13 @@
 /* This is True when we're scanning parent dirs for per-dir merge-files. */
 static BOOL parent_dirscan = False;
 
 /* This array contains a list of all the currently active per-dir merge
  * files.  This makes it easier to save the appropriate values when we
  * "push" down into each subdirectory. */
-static struct filter_struct **mergelist_parents;
+static filter_rule **mergelist_parents;
 static int mergelist_cnt = 0;
 static int mergelist_size = 0;
 
 /* Each filter_list_struct describes a singly-linked list by keeping track
  * of both the head and tail pointers.  The list is slightly unusual in that
  * a parent-dir's content can be appended to the end of the local list in a
@@ -100,187 +95,218 @@
  * The easiest way to handle this is to simply truncate the list after the
  * tail item and then free the local list from the head.  When inheriting
  * the list for a new local dir, we just save off the filter_list_struct
  * values (so we can pop back to them later) and set the tail to NULL.
  */
 
-static void free_filter(struct filter_struct *ex)
+static void teardown_mergelist(filter_rule *ex)
 {
-	if (ex->match_flags & MATCHFLG_PERDIR_MERGE) {
-		free(ex->u.mergelist->debug_type);
-		free(ex->u.mergelist);
-		mergelist_cnt--;
+	if (DEBUG_GTE(FILTER, 2)) {
+		rprintf(FINFO, "[%s] deactivating mergelist #%d%s\n",
+			who_am_i(), mergelist_cnt - 1,
+			ex->u.mergelist->debug_type);
 	}
+
+	/* We should deactivate mergelists in LIFO order. */
+	assert(mergelist_cnt > 0);
+	assert(ex == mergelist_parents[mergelist_cnt - 1]);
+
+	/* The parent_dirscan filters should have been freed. */
+	assert(ex->u.mergelist->parent_dirscan_head == NULL);
+
+	free(ex->u.mergelist->debug_type);
+	free(ex->u.mergelist);
+	mergelist_cnt--;
+}
+
+static void free_filter(filter_rule *ex)
+{
 	free(ex->pattern);
 	free(ex);
 }
 
+static void free_filters(filter_rule *head)
+{
+	filter_rule *rev_head = NULL;
+
+	/* Reverse the list so we deactivate mergelists in the proper LIFO
+	 * order. */
+	while (head) {
+		filter_rule *next = head->next;
+		head->next = rev_head;
+		rev_head = head;
+		head = next;
+	}
+
+	while (rev_head) {
+		filter_rule *prev = rev_head->next;
+		/* Tear down mergelists here, not in free_filter, so that we
+		 * affect only real filter lists and not temporarily allocated
+		 * filters. */
+		if (rev_head->rflags & FILTRULE_PERDIR_MERGE)
+			teardown_mergelist(rev_head);
+		free_filter(rev_head);
+		rev_head = prev;
+	}
+}
+
 /* Build a filter structure given a filter pattern.  The value in "pat"
- * is not null-terminated. */
-static void add_rule(struct filter_list_struct *listp, const char *pat,
-		     unsigned int pat_len, uint32 mflags, int xflags)
+ * is not null-terminated.  "rule" is either held or freed, so the
+ * caller should not free it. */
+static void add_rule(filter_rule_list *listp, const char *pat, unsigned int pat_len,
+		     filter_rule *rule, int xflags)
 {
-	struct filter_struct *ret;
 	const char *cp;
 	unsigned int pre_len, suf_len, slash_cnt = 0;
 
-	if (verbose > 2) {
+	if (DEBUG_GTE(FILTER, 2)) {
 		rprintf(FINFO, "[%s] add_rule(%s%.*s%s)%s\n",
-			who_am_i(), get_rule_prefix(mflags, pat, 0, NULL),
+			who_am_i(), get_rule_prefix(rule, pat, 0, NULL),
 			(int)pat_len, pat,
-			(mflags & MATCHFLG_DIRECTORY) ? "/" : "",
+			(rule->rflags & FILTRULE_DIRECTORY) ? "/" : "",
 			listp->debug_type);
 	}
 
 	/* These flags also indicate that we're reading a list that
 	 * needs to be filtered now, not post-filtered later. */
-	if (xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH)) {
-		uint32 mf = mflags & (MATCHFLG_RECEIVER_SIDE|MATCHFLG_SENDER_SIDE);
-		if (am_sender) {
-			if (mf == MATCHFLG_RECEIVER_SIDE)
-				return;
-		} else {
-			if (mf == MATCHFLG_SENDER_SIDE)
-				return;
-		}
+	if (xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH)
+		&& (rule->rflags & FILTRULES_SIDES)
+			== (am_sender ? FILTRULE_RECEIVER_SIDE : FILTRULE_SENDER_SIDE)) {
+		/* This filter applies only to the other side.  Drop it. */
+		free_filter(rule);
+		return;
 	}
 
-	if (!(ret = new0(struct filter_struct)))
-		out_of_memory("add_rule");
-
 	if (pat_len > 1 && pat[pat_len-1] == '/') {
 		pat_len--;
-		mflags |= MATCHFLG_DIRECTORY;
+		rule->rflags |= FILTRULE_DIRECTORY;
 	}
 
 	for (cp = pat; cp < pat + pat_len; cp++) {
 		if (*cp == '/')
 			slash_cnt++;
 	}
 
-	if (!(mflags & (MATCHFLG_ABS_PATH | MATCHFLG_MERGE_FILE))
+	if (!(rule->rflags & (FILTRULE_ABS_PATH | FILTRULE_MERGE_FILE))
 	 && ((xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH) && *pat == '/')
 	  || (xflags & XFLG_ABS_IF_SLASH && slash_cnt))) {
-		mflags |= MATCHFLG_ABS_PATH;
+		rule->rflags |= FILTRULE_ABS_PATH;
 		if (*pat == '/')
 			pre_len = dirbuf_len - module_dirlen - 1;
 		else
 			pre_len = 0;
 	} else
 		pre_len = 0;
 
 	/* The daemon wants dir-exclude rules to get an appended "/" + "***". */
 	if (xflags & XFLG_DIR2WILD3
-	 && BITS_SETnUNSET(mflags, MATCHFLG_DIRECTORY, MATCHFLG_INCLUDE)) {
-		mflags &= ~MATCHFLG_DIRECTORY;
+	 && BITS_SETnUNSET(rule->rflags, FILTRULE_DIRECTORY, FILTRULE_INCLUDE)) {
+		rule->rflags &= ~FILTRULE_DIRECTORY;
 		suf_len = sizeof SLASH_WILD3_SUFFIX - 1;
 	} else
 		suf_len = 0;
 
-	if (!(ret->pattern = new_array(char, pre_len + pat_len + suf_len + 1)))
+	if (!(rule->pattern = new_array(char, pre_len + pat_len + suf_len + 1)))
 		out_of_memory("add_rule");
 	if (pre_len) {
-		memcpy(ret->pattern, dirbuf + module_dirlen, pre_len);
-		for (cp = ret->pattern; cp < ret->pattern + pre_len; cp++) {
+		memcpy(rule->pattern, dirbuf + module_dirlen, pre_len);
+		for (cp = rule->pattern; cp < rule->pattern + pre_len; cp++) {
 			if (*cp == '/')
 				slash_cnt++;
 		}
 	}
-	strlcpy(ret->pattern + pre_len, pat, pat_len + 1);
+	strlcpy(rule->pattern + pre_len, pat, pat_len + 1);
 	pat_len += pre_len;
 	if (suf_len) {
-		memcpy(ret->pattern + pat_len, SLASH_WILD3_SUFFIX, suf_len+1);
+		memcpy(rule->pattern + pat_len, SLASH_WILD3_SUFFIX, suf_len+1);
 		pat_len += suf_len;
 		slash_cnt++;
 	}
 
-	if (strpbrk(ret->pattern, "*[?")) {
-		mflags |= MATCHFLG_WILD;
-		if ((cp = strstr(ret->pattern, "**")) != NULL) {
-			mflags |= MATCHFLG_WILD2;
+	if (strpbrk(rule->pattern, "*[?")) {
+		rule->rflags |= FILTRULE_WILD;
+		if ((cp = strstr(rule->pattern, "**")) != NULL) {
+			rule->rflags |= FILTRULE_WILD2;
 			/* If the pattern starts with **, note that. */
-			if (cp == ret->pattern)
-				mflags |= MATCHFLG_WILD2_PREFIX;
+			if (cp == rule->pattern)
+				rule->rflags |= FILTRULE_WILD2_PREFIX;
 			/* If the pattern ends with ***, note that. */
 			if (pat_len >= 3
-			 && ret->pattern[pat_len-3] == '*'
-			 && ret->pattern[pat_len-2] == '*'
-			 && ret->pattern[pat_len-1] == '*')
-				mflags |= MATCHFLG_WILD3_SUFFIX;
+			 && rule->pattern[pat_len-3] == '*'
+			 && rule->pattern[pat_len-2] == '*'
+			 && rule->pattern[pat_len-1] == '*')
+				rule->rflags |= FILTRULE_WILD3_SUFFIX;
 		}
 	}
 
-	if (mflags & MATCHFLG_PERDIR_MERGE) {
-		struct filter_list_struct *lp;
+	if (rule->rflags & FILTRULE_PERDIR_MERGE) {
+		filter_rule_list *lp;
 		unsigned int len;
 		int i;
 
-		if ((cp = strrchr(ret->pattern, '/')) != NULL)
+		if ((cp = strrchr(rule->pattern, '/')) != NULL)
 			cp++;
 		else
-			cp = ret->pattern;
+			cp = rule->pattern;
 
 		/* If the local merge file was already mentioned, don't
 		 * add it again. */
 		for (i = 0; i < mergelist_cnt; i++) {
-			struct filter_struct *ex = mergelist_parents[i];
+			filter_rule *ex = mergelist_parents[i];
 			const char *s = strrchr(ex->pattern, '/');
 			if (s)
 				s++;
 			else
 				s = ex->pattern;
 			len = strlen(s);
-			if (len == pat_len - (cp - ret->pattern)
-			    && memcmp(s, cp, len) == 0) {
-				free_filter(ret);
+			if (len == pat_len - (cp - rule->pattern) && memcmp(s, cp, len) == 0) {
+				free_filter(rule);
 				return;
 			}
 		}
 
-		if (!(lp = new_array(struct filter_list_struct, 1)))
+		if (!(lp = new_array(filter_rule_list, 1)))
 			out_of_memory("add_rule");
-		lp->head = lp->tail = NULL;
+		lp->head = lp->tail = lp->parent_dirscan_head = NULL;
 		if (asprintf(&lp->debug_type, " [per-dir %s]", cp) < 0)
 			out_of_memory("add_rule");
-		ret->u.mergelist = lp;
+		rule->u.mergelist = lp;
 
 		if (mergelist_cnt == mergelist_size) {
 			mergelist_size += 5;
 			mergelist_parents = realloc_array(mergelist_parents,
-						struct filter_struct *,
+						filter_rule *,
 						mergelist_size);
 			if (!mergelist_parents)
 				out_of_memory("add_rule");
 		}
-		mergelist_parents[mergelist_cnt++] = ret;
+		if (DEBUG_GTE(FILTER, 2)) {
+			rprintf(FINFO, "[%s] activating mergelist #%d%s\n",
+				who_am_i(), mergelist_cnt, lp->debug_type);
+		}
+		mergelist_parents[mergelist_cnt++] = rule;
 	} else
-		ret->u.slash_cnt = slash_cnt;
-
-	ret->match_flags = mflags;
+		rule->u.slash_cnt = slash_cnt;
 
 	if (!listp->tail) {
-		ret->next = listp->head;
-		listp->head = listp->tail = ret;
+		rule->next = listp->head;
+		listp->head = listp->tail = rule;
 	} else {
-		ret->next = listp->tail->next;
-		listp->tail->next = ret;
-		listp->tail = ret;
+		rule->next = listp->tail->next;
+		listp->tail->next = rule;
+		listp->tail = rule;
 	}
 }
 
-static void clear_filter_list(struct filter_list_struct *listp)
+static void clear_filter_list(filter_rule_list *listp)
 {
 	if (listp->tail) {
-		struct filter_struct *ent, *next;
 		/* Truncate any inherited items from the local list. */
 		listp->tail->next = NULL;
 		/* Now free everything that is left. */
-		for (ent = listp->head; ent; ent = next) {
-			next = ent->next;
-			free_filter(ent);
-		}
+		free_filters(listp->head);
 	}
 
 	listp->head = listp->tail = NULL;
 }
 
 /* This returns an expanded (absolute) filename for the merge-file name if
@@ -374,22 +400,26 @@
 
 /* This routine takes a per-dir merge-file entry and finishes its setup.
  * If the name has a path portion then we check to see if it refers to a
  * parent directory of the first transfer dir.  If it does, we scan all the
  * dirs from that point through the parent dir of the transfer dir looking
  * for the per-dir merge-file in each one. */
-static BOOL setup_merge_file(struct filter_struct *ex,
-			     struct filter_list_struct *lp)
+static BOOL setup_merge_file(int mergelist_num, filter_rule *ex,
+			     filter_rule_list *lp)
 {
 	char buf[MAXPATHLEN];
 	char *x, *y, *pat = ex->pattern;
 	unsigned int len;
 
 	if (!(x = parse_merge_name(pat, NULL, 0)) || *x != '/')
 		return 0;
 
+	if (DEBUG_GTE(FILTER, 2)) {
+		rprintf(FINFO, "[%s] performing parent_dirscan for mergelist #%d%s\n",
+			who_am_i(), mergelist_num, lp->debug_type);
+	}
 	y = strrchr(x, '/');
 	*y = '\0';
 	ex->pattern = strdup(y+1);
 	if (!*x)
 		x = "/";
 	if (*x == '/')
@@ -411,71 +441,97 @@
 	while (*y) {
 		char save[MAXPATHLEN];
 		strlcpy(save, y, MAXPATHLEN);
 		*y = '\0';
 		dirbuf_len = y - dirbuf;
 		strlcpy(x, ex->pattern, MAXPATHLEN - (x - buf));
-		parse_filter_file(lp, buf, ex->match_flags, XFLG_ANCHORED2ABS);
-		if (ex->match_flags & MATCHFLG_NO_INHERIT)
+		parse_filter_file(lp, buf, ex, XFLG_ANCHORED2ABS);
+		if (ex->rflags & FILTRULE_NO_INHERIT) {
+			/* Free the undesired rules to clean up any per-dir
+			 * mergelists they defined.  Otherwise pop_local_filters
+			 * may crash trying to restore nonexistent state for
+			 * those mergelists. */
+			free_filters(lp->head);
 			lp->head = NULL;
+		}
 		lp->tail = NULL;
 		strlcpy(y, save, MAXPATHLEN);
 		while ((*x++ = *y++) != '/') {}
 	}
+	/* Save current head for freeing when the mergelist becomes inactive. */
+	lp->parent_dirscan_head = lp->head;
 	parent_dirscan = False;
+	if (DEBUG_GTE(FILTER, 2)) {
+		rprintf(FINFO, "[%s] completed parent_dirscan for mergelist #%d%s\n",
+			who_am_i(), mergelist_num, lp->debug_type);
+	}
 	free(pat);
 	return 1;
 }
 
+struct local_filter_state {
+	int mergelist_cnt;
+	filter_rule_list mergelists[1];
+};
+
 /* Each time rsync changes to a new directory it call this function to
  * handle all the per-dir merge-files.  The "dir" value is the current path
  * relative to curr_dir (which might not be null-terminated).  We copy it
  * into dirbuf so that we can easily append a file name on the end. */
 void *push_local_filters(const char *dir, unsigned int dirlen)
 {
-	struct filter_list_struct *ap, *push;
+	struct local_filter_state *push;
 	int i;
 
 	set_filter_dir(dir, dirlen);
+	if (DEBUG_GTE(FILTER, 2)) {
+		rprintf(FINFO, "[%s] pushing local filters for %s\n",
+			who_am_i(), dirbuf);
+	}
 
-	if (!mergelist_cnt)
+	if (!mergelist_cnt) {
+		/* No old state to save and no new merge files to push. */
 		return NULL;
+	}
 
-	push = new_array(struct filter_list_struct, mergelist_cnt);
+	push = (struct local_filter_state *)new_array(char,
+			  sizeof (struct local_filter_state)
+			+ (mergelist_cnt-1) * sizeof (filter_rule_list));
 	if (!push)
 		out_of_memory("push_local_filters");
 
-	for (i = 0, ap = push; i < mergelist_cnt; i++) {
-		memcpy(ap++, mergelist_parents[i]->u.mergelist,
-		       sizeof (struct filter_list_struct));
+	push->mergelist_cnt = mergelist_cnt;
+	for (i = 0; i < mergelist_cnt; i++) {
+		memcpy(&push->mergelists[i], mergelist_parents[i]->u.mergelist,
+		       sizeof (filter_rule_list));
 	}
 
 	/* Note: parse_filter_file() might increase mergelist_cnt, so keep
 	 * this loop separate from the above loop. */
 	for (i = 0; i < mergelist_cnt; i++) {
-		struct filter_struct *ex = mergelist_parents[i];
-		struct filter_list_struct *lp = ex->u.mergelist;
+		filter_rule *ex = mergelist_parents[i];
+		filter_rule_list *lp = ex->u.mergelist;
 
-		if (verbose > 2) {
-			rprintf(FINFO, "[%s] pushing filter list%s\n",
-				who_am_i(), lp->debug_type);
+		if (DEBUG_GTE(FILTER, 2)) {
+			rprintf(FINFO, "[%s] pushing mergelist #%d%s\n",
+				who_am_i(), i, lp->debug_type);
 		}
 
 		lp->tail = NULL; /* Switch any local rules to inherited. */
-		if (ex->match_flags & MATCHFLG_NO_INHERIT)
+		if (ex->rflags & FILTRULE_NO_INHERIT)
 			lp->head = NULL;
 
-		if (ex->match_flags & MATCHFLG_FINISH_SETUP) {
-			ex->match_flags &= ~MATCHFLG_FINISH_SETUP;
-			if (setup_merge_file(ex, lp))
+		if (ex->rflags & FILTRULE_FINISH_SETUP) {
+			ex->rflags &= ~FILTRULE_FINISH_SETUP;
+			if (setup_merge_file(i, ex, lp))
 				set_filter_dir(dir, dirlen);
 		}
 
 		if (strlcpy(dirbuf + dirbuf_len, ex->pattern,
 		    MAXPATHLEN - dirbuf_len) < MAXPATHLEN - dirbuf_len) {
-			parse_filter_file(lp, dirbuf, ex->match_flags,
+			parse_filter_file(lp, dirbuf, ex,
 					  XFLG_ANCHORED2ABS);
 		} else {
 			io_error |= IOERR_GENERAL;
 			rprintf(FERROR,
 			    "cannot add local filter rules in long-named directory: %s\n",
 			    full_fname(dirbuf));
@@ -485,33 +541,59 @@
 
 	return (void*)push;
 }
 
 void pop_local_filters(void *mem)
 {
-	struct filter_list_struct *ap, *pop = (struct filter_list_struct*)mem;
+	struct local_filter_state *pop = (struct local_filter_state *)mem;
 	int i;
+	int old_mergelist_cnt = pop ? pop->mergelist_cnt : 0;
+
+	if (DEBUG_GTE(FILTER, 2))
+		rprintf(FINFO, "[%s] popping local filters\n", who_am_i());
 
 	for (i = mergelist_cnt; i-- > 0; ) {
-		struct filter_struct *ex = mergelist_parents[i];
-		struct filter_list_struct *lp = ex->u.mergelist;
+		filter_rule *ex = mergelist_parents[i];
+		filter_rule_list *lp = ex->u.mergelist;
 
-		if (verbose > 2) {
-			rprintf(FINFO, "[%s] popping filter list%s\n",
-				who_am_i(), lp->debug_type);
+		if (DEBUG_GTE(FILTER, 2)) {
+			rprintf(FINFO, "[%s] popping mergelist #%d%s\n",
+				who_am_i(), i, lp->debug_type);
 		}
 
 		clear_filter_list(lp);
+
+		if (i >= old_mergelist_cnt) {
+			/* This mergelist does not exist in the state to be
+			 * restored.  Free its parent_dirscan list to clean up
+			 * any per-dir mergelists defined there so we don't
+			 * crash trying to restore nonexistent state for them
+			 * below.  (Counterpart to setup_merge_file call in
+			 * push_local_filters.  Must be done here, not in
+			 * free_filter, for LIFO order.) */
+			if (DEBUG_GTE(FILTER, 2)) {
+				rprintf(FINFO, "[%s] freeing parent_dirscan filters of mergelist #%d%s\n",
+					who_am_i(), i, ex->u.mergelist->debug_type);
+			}
+			free_filters(lp->parent_dirscan_head);
+			lp->parent_dirscan_head = NULL;
+		}
 	}
 
-	if (!pop)
+	/* If we cleaned things up properly, the only still-active mergelists
+	 * should be those with a state to be restored. */
+	assert(mergelist_cnt == old_mergelist_cnt);
+
+	if (!pop) {
+		/* No state to restore. */
 		return;
+	}
 
-	for (i = 0, ap = pop; i < mergelist_cnt; i++) {
-		memcpy(mergelist_parents[i]->u.mergelist, ap++,
-		       sizeof (struct filter_list_struct));
+	for (i = 0; i < mergelist_cnt; i++) {
+		memcpy(mergelist_parents[i]->u.mergelist, &pop->mergelists[i],
+		       sizeof (filter_rule_list));
 	}
 
 	free(pop);
 }
 
 void change_local_filter_dir(const char *dname, int dlen, int dir_depth)
@@ -539,69 +621,69 @@
 	}
 
 	cur_depth = dir_depth;
 	filt_array[cur_depth] = push_local_filters(dname, dlen);
 }
 
-static int rule_matches(const char *fname, struct filter_struct *ex, int name_is_dir)
+static int rule_matches(const char *fname, filter_rule *ex, int name_is_dir)
 {
 	int slash_handling, str_cnt = 0, anchored_match = 0;
-	int ret_match = ex->match_flags & MATCHFLG_NEGATE ? 0 : 1;
+	int ret_match = ex->rflags & FILTRULE_NEGATE ? 0 : 1;
 	char *p, *pattern = ex->pattern;
 	const char *strings[16]; /* more than enough */
 	const char *name = fname + (*fname == '/');
 
 	if (!*name)
 		return 0;
 
-	if (!ex->u.slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
+	if (!ex->u.slash_cnt && !(ex->rflags & FILTRULE_WILD2)) {
 		/* If the pattern does not have any slashes AND it does
 		 * not have a "**" (which could match a slash), then we
 		 * just match the name portion of the path. */
 		if ((p = strrchr(name,'/')) != NULL)
 			name = p+1;
-	} else if (ex->match_flags & MATCHFLG_ABS_PATH && *fname != '/'
+	} else if (ex->rflags & FILTRULE_ABS_PATH && *fname != '/'
 	    && curr_dir_len > module_dirlen + 1) {
 		/* If we're matching against an absolute-path pattern,
 		 * we need to prepend our full path info. */
 		strings[str_cnt++] = curr_dir + module_dirlen + 1;
 		strings[str_cnt++] = "/";
-	} else if (ex->match_flags & MATCHFLG_WILD2_PREFIX && *fname != '/') {
+	} else if (ex->rflags & FILTRULE_WILD2_PREFIX && *fname != '/') {
 		/* Allow "**"+"/" to match at the start of the string. */
 		strings[str_cnt++] = "/";
 	}
 	strings[str_cnt++] = name;
 	if (name_is_dir) {
 		/* Allow a trailing "/"+"***" to match the directory. */
-		if (ex->match_flags & MATCHFLG_WILD3_SUFFIX)
+		if (ex->rflags & FILTRULE_WILD3_SUFFIX)
 			strings[str_cnt++] = "/";
-	} else if (ex->match_flags & MATCHFLG_DIRECTORY)
+	} else if (ex->rflags & FILTRULE_DIRECTORY)
 		return !ret_match;
 	strings[str_cnt] = NULL;
 
 	if (*pattern == '/') {
 		anchored_match = 1;
 		pattern++;
 	}
 
 	if (!anchored_match && ex->u.slash_cnt
-	    && !(ex->match_flags & MATCHFLG_WILD2)) {
+	    && !(ex->rflags & FILTRULE_WILD2)) {
 		/* A non-anchored match with an infix slash and no "**"
 		 * needs to match the last slash_cnt+1 name elements. */
 		slash_handling = ex->u.slash_cnt + 1;
-	} else if (!anchored_match && !(ex->match_flags & MATCHFLG_WILD2_PREFIX)
-				   && ex->match_flags & MATCHFLG_WILD2) {
+	} else if (!anchored_match && !(ex->rflags & FILTRULE_WILD2_PREFIX)
+				   && ex->rflags & FILTRULE_WILD2) {
 		/* A non-anchored match with an infix or trailing "**" (but not
 		 * a prefixed "**") needs to try matching after every slash. */
 		slash_handling = -1;
 	} else {
 		/* The pattern matches only at the start of the path or name. */
 		slash_handling = 0;
 	}
 
-	if (ex->match_flags & MATCHFLG_WILD) {
+	if (ex->rflags & FILTRULE_WILD) {
 		if (wildmatch_array(pattern, strings, slash_handling))
 			return ret_match;
 	} else if (str_cnt > 1) {
 		if (litmatch_array(pattern, strings, slash_handling))
 			return ret_match;
 	} else if (anchored_match) {
@@ -617,63 +699,59 @@
 		}
 	}
 
 	return !ret_match;
 }
 
-
 static void report_filter_result(enum logcode code, char const *name,
-                                 struct filter_struct const *ent,
+				 filter_rule const *ent,
                                  int name_is_dir, const char *type)
 {
 	/* If a trailing slash is present to match only directories,
 	 * then it is stripped out by add_rule().  So as a special
 	 * case we add it back in here. */
 
-	if (verbose >= 2) {
+	if (DEBUG_GTE(FILTER, 1)) {
 		static char *actions[2][2]
 		    = { {"show", "hid"}, {"risk", "protect"} };
 		const char *w = who_am_i();
 		rprintf(code, "[%s] %sing %s %s because of pattern %s%s%s\n",
-		    w, actions[*w!='s'][!(ent->match_flags&MATCHFLG_INCLUDE)],
+		    w, actions[*w!='s'][!(ent->rflags & FILTRULE_INCLUDE)],
 		    name_is_dir ? "directory" : "file", name, ent->pattern,
-		    ent->match_flags & MATCHFLG_DIRECTORY ? "/" : "", type);
+		    ent->rflags & FILTRULE_DIRECTORY ? "/" : "", type);
 	}
 }
 
-
-/*
- * Return -1 if file "name" is defined to be excluded by the specified
- * exclude list, 1 if it is included, and 0 if it was not matched.
- */
-int check_filter(struct filter_list_struct *listp, enum logcode code,
+/* Return -1 if file "name" is defined to be excluded by the specified
+ * exclude list, 1 if it is included, and 0 if it was not matched. */
+int check_filter(filter_rule_list *listp, enum logcode code,
 		 const char *name, int name_is_dir)
 {
-	struct filter_struct *ent;
+	filter_rule *ent;
 
 	for (ent = listp->head; ent; ent = ent->next) {
-		if (ignore_perishable && ent->match_flags & MATCHFLG_PERISHABLE)
+		if (ignore_perishable && ent->rflags & FILTRULE_PERISHABLE)
 			continue;
-		if (ent->match_flags & MATCHFLG_PERDIR_MERGE) {
+		if (ent->rflags & FILTRULE_PERDIR_MERGE) {
 			int rc = check_filter(ent->u.mergelist, code, name,
 					      name_is_dir);
 			if (rc)
 				return rc;
 			continue;
 		}
-		if (ent->match_flags & MATCHFLG_CVS_IGNORE) {
+		if (ent->rflags & FILTRULE_CVS_IGNORE) {
 			int rc = check_filter(&cvs_filter_list, code, name,
 					      name_is_dir);
 			if (rc)
 				return rc;
 			continue;
 		}
 		if (rule_matches(name, ent, name_is_dir)) {
 			report_filter_result(code, name, ent, name_is_dir,
 					     listp->debug_type);
-			return ent->match_flags & MATCHFLG_INCLUDE ? 1 : -1;
+			return ent->rflags & FILTRULE_INCLUDE ? 1 : -1;
 		}
 	}
 
 	return 0;
 }
 
@@ -687,58 +765,70 @@
 		return str + rule_len - 1;
 	if (str[rule_len] == ',')
 		return str + rule_len;
 	return NULL;
 }
 
-/* Get the next include/exclude arg from the string.  The token will not
- * be '\0' terminated, so use the returned length to limit the string.
- * Also, be sure to add this length to the returned pointer before passing
- * it back to ask for the next token.  This routine parses the "!" (list-
- * clearing) token and (depending on the mflags) the various prefixes.
- * The *mflags_ptr value will be set on exit to the new MATCHFLG_* bits
- * for the current token. */
-static const char *parse_rule_tok(const char *p, uint32 mflags, int xflags,
-				  unsigned int *len_ptr, uint32 *mflags_ptr)
+#define FILTRULES_FROM_CONTAINER (FILTRULE_ABS_PATH | FILTRULE_INCLUDE \
+				| FILTRULE_DIRECTORY | FILTRULE_NEGATE \
+				| FILTRULE_PERISHABLE)
+
+/* Gets the next include/exclude rule from *rulestr_ptr and advances
+ * *rulestr_ptr to point beyond it.  Stores the pattern's start (within
+ * *rulestr_ptr) and length in *pat_ptr and *pat_len_ptr, and returns a newly
+ * allocated filter_rule containing the rest of the information.  Returns
+ * NULL if there are no more rules in the input.
+ *
+ * The template provides defaults for the new rule to inherit, and the
+ * template rflags and the xflags additionally affect parsing. */
+static filter_rule *parse_rule_tok(const char **rulestr_ptr,
+				   const filter_rule *template, int xflags,
+				   const char **pat_ptr, unsigned int *pat_len_ptr)
 {
-	const uchar *s = (const uchar *)p;
-	uint32 new_mflags;
+	const uchar *s = (const uchar *)*rulestr_ptr;
+	filter_rule *rule;
 	unsigned int len;
 
-	if (mflags & MATCHFLG_WORD_SPLIT) {
+	if (template->rflags & FILTRULE_WORD_SPLIT) {
 		/* Skip over any initial whitespace. */
 		while (isspace(*s))
 			s++;
 		/* Update to point to real start of rule. */
-		p = (const char *)s;
+		*rulestr_ptr = (const char *)s;
 	}
 	if (!*s)
 		return NULL;
 
-	new_mflags = mflags & MATCHFLGS_FROM_CONTAINER;
+	if (!(rule = new0(filter_rule)))
+		out_of_memory("parse_rule_tok");
+
+	/* Inherit from the template.  Don't inherit FILTRULES_SIDES; we check
+	 * that later. */
+	rule->rflags = template->rflags & FILTRULES_FROM_CONTAINER;
 
 	/* Figure out what kind of a filter rule "s" is pointing at.  Note
-	 * that if MATCHFLG_NO_PREFIXES is set, the rule is either an include
-	 * or an exclude based on the inheritance of the MATCHFLG_INCLUDE
+	 * that if FILTRULE_NO_PREFIXES is set, the rule is either an include
+	 * or an exclude based on the inheritance of the FILTRULE_INCLUDE
 	 * flag (above).  XFLG_OLD_PREFIXES indicates a compatibility mode
 	 * for old include/exclude patterns where just "+ " and "- " are
 	 * allowed as optional prefixes.  */
-	if (mflags & MATCHFLG_NO_PREFIXES) {
-		if (*s == '!' && mflags & MATCHFLG_CVS_IGNORE)
-			new_mflags |= MATCHFLG_CLEAR_LIST; /* Tentative! */
+	if (template->rflags & FILTRULE_NO_PREFIXES) {
+		if (*s == '!' && template->rflags & FILTRULE_CVS_IGNORE)
+			rule->rflags |= FILTRULE_CLEAR_LIST; /* Tentative! */
 	} else if (xflags & XFLG_OLD_PREFIXES) {
 		if (*s == '-' && s[1] == ' ') {
-			new_mflags &= ~MATCHFLG_INCLUDE;
+			rule->rflags &= ~FILTRULE_INCLUDE;
 			s += 2;
 		} else if (*s == '+' && s[1] == ' ') {
-			new_mflags |= MATCHFLG_INCLUDE;
+			rule->rflags |= FILTRULE_INCLUDE;
 			s += 2;
 		} else if (*s == '!')
-			new_mflags |= MATCHFLG_CLEAR_LIST; /* Tentative! */
+			rule->rflags |= FILTRULE_CLEAR_LIST; /* Tentative! */
 	} else {
-		char ch = 0, *mods = "";
+		char ch = 0;
+		BOOL prefix_specifies_side = False;
 		switch (*s) {
 		case 'c':
 			if ((s = RULE_STRCMP(s, "clear")) != NULL)
 				ch = '!';
 			break;
 		case 'd':
@@ -778,143 +868,165 @@
 			if (s[1] == ',')
 				s++;
 			break;
 		}
 		switch (ch) {
 		case ':':
-			new_mflags |= MATCHFLG_PERDIR_MERGE
-				    | MATCHFLG_FINISH_SETUP;
+			rule->rflags |= FILTRULE_PERDIR_MERGE
+				       | FILTRULE_FINISH_SETUP;
 			/* FALL THROUGH */
 		case '.':
-			new_mflags |= MATCHFLG_MERGE_FILE;
-			mods = MODIFIERS_INCL_EXCL MODIFIERS_MERGE_FILE;
+			rule->rflags |= FILTRULE_MERGE_FILE;
 			break;
 		case '+':
-			new_mflags |= MATCHFLG_INCLUDE;
-			/* FALL THROUGH */
+			rule->rflags |= FILTRULE_INCLUDE;
+			break;
 		case '-':
-			mods = MODIFIERS_INCL_EXCL;
 			break;
 		case 'S':
-			new_mflags |= MATCHFLG_INCLUDE;
+			rule->rflags |= FILTRULE_INCLUDE;
 			/* FALL THROUGH */
 		case 'H':
-			new_mflags |= MATCHFLG_SENDER_SIDE;
-			mods = MODIFIERS_HIDE_PROTECT;
+			rule->rflags |= FILTRULE_SENDER_SIDE;
+			prefix_specifies_side = True;
 			break;
 		case 'R':
-			new_mflags |= MATCHFLG_INCLUDE;
+			rule->rflags |= FILTRULE_INCLUDE;
 			/* FALL THROUGH */
 		case 'P':
-			new_mflags |= MATCHFLG_RECEIVER_SIDE;
-			mods = MODIFIERS_HIDE_PROTECT;
+			rule->rflags |= FILTRULE_RECEIVER_SIDE;
+			prefix_specifies_side = True;
 			break;
 		case '!':
-			new_mflags |= MATCHFLG_CLEAR_LIST;
-			mods = NULL;
+			rule->rflags |= FILTRULE_CLEAR_LIST;
 			break;
 		default:
-			rprintf(FERROR, "Unknown filter rule: `%s'\n", p);
+			rprintf(FERROR, "Unknown filter rule: `%s'\n", *rulestr_ptr);
 			exit_cleanup(RERR_SYNTAX);
 		}
-		while (mods && *++s && *s != ' ' && *s != '_') {
-			if (strchr(mods, *s) == NULL) {
-				if (mflags & MATCHFLG_WORD_SPLIT && isspace(*s)) {
-					s--;
-					break;
-				}
+		while (ch != '!' && *++s && *s != ' ' && *s != '_') {
+			if (template->rflags & FILTRULE_WORD_SPLIT && isspace(*s)) {
+				s--;
+				break;
+			}
+			switch (*s) {
+			default:
 			    invalid:
 				rprintf(FERROR,
-					"invalid modifier sequence at '%c' in filter rule: %s\n",
-					*s, p);
+					"invalid modifier '%c' at position %d in filter rule: %s\n",
+					*s, (int)(s - (const uchar *)*rulestr_ptr), *rulestr_ptr);
 				exit_cleanup(RERR_SYNTAX);
-			}
-			switch (*s) {
 			case '-':
-				if (new_mflags & MATCHFLG_NO_PREFIXES)
-				    goto invalid;
-				new_mflags |= MATCHFLG_NO_PREFIXES;
+				if (!BITS_SETnUNSET(rule->rflags, FILTRULE_MERGE_FILE, FILTRULE_NO_PREFIXES))
+					goto invalid;
+				rule->rflags |= FILTRULE_NO_PREFIXES;
 				break;
 			case '+':
-				if (new_mflags & MATCHFLG_NO_PREFIXES)
-				    goto invalid;
-				new_mflags |= MATCHFLG_NO_PREFIXES
-					    | MATCHFLG_INCLUDE;
+				if (!BITS_SETnUNSET(rule->rflags, FILTRULE_MERGE_FILE, FILTRULE_NO_PREFIXES))
+					goto invalid;
+				rule->rflags |= FILTRULE_NO_PREFIXES
+					      | FILTRULE_INCLUDE;
 				break;
 			case '/':
-				new_mflags |= MATCHFLG_ABS_PATH;
+				rule->rflags |= FILTRULE_ABS_PATH;
 				break;
 			case '!':
-				new_mflags |= MATCHFLG_NEGATE;
+				/* Negation really goes with the pattern, so it
+				 * isn't useful as a merge-file default. */
+				if (rule->rflags & FILTRULE_MERGE_FILE)
+					goto invalid;
+				rule->rflags |= FILTRULE_NEGATE;
 				break;
 			case 'C':
-				if (new_mflags & MATCHFLG_NO_PREFIXES)
-				    goto invalid;
-				new_mflags |= MATCHFLG_NO_PREFIXES
-					    | MATCHFLG_WORD_SPLIT
-					    | MATCHFLG_NO_INHERIT
-					    | MATCHFLG_CVS_IGNORE;
+				if (rule->rflags & FILTRULE_NO_PREFIXES || prefix_specifies_side)
+					goto invalid;
+				rule->rflags |= FILTRULE_NO_PREFIXES
+					      | FILTRULE_WORD_SPLIT
+					      | FILTRULE_NO_INHERIT
+					      | FILTRULE_CVS_IGNORE;
 				break;
 			case 'e':
-				new_mflags |= MATCHFLG_EXCLUDE_SELF;
+				if (!(rule->rflags & FILTRULE_MERGE_FILE))
+					goto invalid;
+				rule->rflags |= FILTRULE_EXCLUDE_SELF;
 				break;
 			case 'n':
-				new_mflags |= MATCHFLG_NO_INHERIT;
+				if (!(rule->rflags & FILTRULE_MERGE_FILE))
+					goto invalid;
+				rule->rflags |= FILTRULE_NO_INHERIT;
 				break;
 			case 'p':
-				new_mflags |= MATCHFLG_PERISHABLE;
+				rule->rflags |= FILTRULE_PERISHABLE;
 				break;
 			case 'r':
-				new_mflags |= MATCHFLG_RECEIVER_SIDE;
+				if (prefix_specifies_side)
+					goto invalid;
+				rule->rflags |= FILTRULE_RECEIVER_SIDE;
 				break;
 			case 's':
-				new_mflags |= MATCHFLG_SENDER_SIDE;
+				if (prefix_specifies_side)
+					goto invalid;
+				rule->rflags |= FILTRULE_SENDER_SIDE;
 				break;
 			case 'w':
-				new_mflags |= MATCHFLG_WORD_SPLIT;
+				if (!(rule->rflags & FILTRULE_MERGE_FILE))
+					goto invalid;
+				rule->rflags |= FILTRULE_WORD_SPLIT;
 				break;
 			}
 		}
 		if (*s)
 			s++;
 	}
+	if (template->rflags & FILTRULES_SIDES) {
+		if (rule->rflags & FILTRULES_SIDES) {
+			/* The filter and template both specify side(s).  This
+			 * is dodgy (and won't work correctly if the template is
+			 * a one-sided per-dir merge rule), so reject it. */
+			rprintf(FERROR,
+				"specified-side merge file contains specified-side filter: %s\n",
+				*rulestr_ptr);
+			exit_cleanup(RERR_SYNTAX);
+		}
+		rule->rflags |= template->rflags & FILTRULES_SIDES;
+	}
 
-	if (mflags & MATCHFLG_WORD_SPLIT) {
+	if (template->rflags & FILTRULE_WORD_SPLIT) {
 		const uchar *cp = s;
 		/* Token ends at whitespace or the end of the string. */
 		while (!isspace(*cp) && *cp != '\0')
 			cp++;
 		len = cp - s;
 	} else
 		len = strlen((char*)s);
 
-	if (new_mflags & MATCHFLG_CLEAR_LIST) {
-		if (!(mflags & MATCHFLG_NO_PREFIXES)
+	if (rule->rflags & FILTRULE_CLEAR_LIST) {
+		if (!(rule->rflags & FILTRULE_NO_PREFIXES)
 		 && !(xflags & XFLG_OLD_PREFIXES) && len) {
 			rprintf(FERROR,
-				"'!' rule has trailing characters: %s\n", p);
+				"'!' rule has trailing characters: %s\n", *rulestr_ptr);
 			exit_cleanup(RERR_SYNTAX);
 		}
 		if (len > 1)
-			new_mflags &= ~MATCHFLG_CLEAR_LIST;
-	} else if (!len && !(new_mflags & MATCHFLG_CVS_IGNORE)) {
-		rprintf(FERROR, "unexpected end of filter rule: %s\n", p);
+			rule->rflags &= ~FILTRULE_CLEAR_LIST;
+	} else if (!len && !(rule->rflags & FILTRULE_CVS_IGNORE)) {
+		rprintf(FERROR, "unexpected end of filter rule: %s\n", *rulestr_ptr);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
-	/* --delete-excluded turns an un-modified include/exclude into a sender-side rule. */
+	/* --delete-excluded turns an un-modified include/exclude into a sender-side rule.  */
 	if (delete_excluded
-	 && !(new_mflags & (MATCHFLG_RECEIVER_SIDE|MATCHFLG_SENDER_SIDE|MATCHFLG_MERGE_FILE|MATCHFLG_PERDIR_MERGE)))
-		new_mflags |= MATCHFLG_SENDER_SIDE;
+	 && !(rule->rflags & (FILTRULES_SIDES|FILTRULE_MERGE_FILE|FILTRULE_PERDIR_MERGE)))
+		rule->rflags |= FILTRULE_SENDER_SIDE;
 
-	*len_ptr = len;
-	*mflags_ptr = new_mflags;
-	return (const char *)s;
+	*pat_ptr = (const char *)s;
+	*pat_len_ptr = len;
+	*rulestr_ptr = *pat_ptr + len;
+	return rule;
 }
 
-
 static char default_cvsignore[] =
 	/* These default ignored items come from the CVS manual. */
 	"RCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS"
 	" .make.state .nse_depinfo *~ #* .#* ,* _$* *$"
 	" *.old *.bak *.BAK *.orig *.rej .del-*"
 	" *.a *.olb *.o *.obj *.so *.exe"
@@ -919,116 +1031,125 @@
 	" *.old *.bak *.BAK *.orig *.rej .del-*"
 	" *.a *.olb *.o *.obj *.so *.exe"
 	" *.Z *.elc *.ln core"
 	/* The rest we added to suit ourself. */
 	" .svn/ .git/ .hg/ .bzr/";
 
-static void get_cvs_excludes(uint32 mflags)
+static void get_cvs_excludes(uint32 rflags)
 {
 	static int initialized = 0;
 	char *p, fname[MAXPATHLEN];
 
 	if (initialized)
 		return;
 	initialized = 1;
 
-	parse_rule(&cvs_filter_list, default_cvsignore,
-		   mflags | (protocol_version >= 30 ? MATCHFLG_PERISHABLE : 0),
-		   0);
+	parse_filter_str(&cvs_filter_list, default_cvsignore,
+			 rule_template(rflags | (protocol_version >= 30 ? FILTRULE_PERISHABLE : 0)),
+			 0);
 
 	p = module_id >= 0 && lp_use_chroot(module_id) ? "/" : getenv("HOME");
 	if (p && pathjoin(fname, MAXPATHLEN, p, ".cvsignore") < MAXPATHLEN)
-		parse_filter_file(&cvs_filter_list, fname, mflags, 0);
+		parse_filter_file(&cvs_filter_list, fname, rule_template(rflags), 0);
 
-	parse_rule(&cvs_filter_list, getenv("CVSIGNORE"), mflags, 0);
+	parse_filter_str(&cvs_filter_list, getenv("CVSIGNORE"), rule_template(rflags), 0);
 }
 
+const filter_rule *rule_template(uint32 rflags)
+{
+	static filter_rule template; /* zero-initialized */
+	template.rflags = rflags;
+	return &template;
+}
 
-void parse_rule(struct filter_list_struct *listp, const char *pattern,
-		uint32 mflags, int xflags)
+void parse_filter_str(filter_rule_list *listp, const char *rulestr,
+		     const filter_rule *template, int xflags)
 {
+	filter_rule *rule;
+	const char *pat;
 	unsigned int pat_len;
-	uint32 new_mflags;
-	const char *cp, *p;
 
-	if (!pattern)
+	if (!rulestr)
 		return;
 
 	while (1) {
+		uint32 new_rflags;
+
 		/* Remember that the returned string is NOT '\0' terminated! */
-		cp = parse_rule_tok(pattern, mflags, xflags,
-				    &pat_len, &new_mflags);
-		if (!cp)
+		if (!(rule = parse_rule_tok(&rulestr, template, xflags, &pat, &pat_len)))
 			break;
 
-		pattern = cp + pat_len;
-
 		if (pat_len >= MAXPATHLEN) {
 			rprintf(FERROR, "discarding over-long filter: %.*s\n",
-				(int)pat_len, cp);
+				(int)pat_len, pat);
+		    free_continue:
+			free_filter(rule);
 			continue;
 		}
 
-		if (new_mflags & MATCHFLG_CLEAR_LIST) {
-			if (verbose > 2) {
+		new_rflags = rule->rflags;
+		if (new_rflags & FILTRULE_CLEAR_LIST) {
+			if (DEBUG_GTE(FILTER, 2)) {
 				rprintf(FINFO,
 					"[%s] clearing filter list%s\n",
 					who_am_i(), listp->debug_type);
 			}
 			clear_filter_list(listp);
-			continue;
+			goto free_continue;
 		}
 
-		if (new_mflags & MATCHFLG_MERGE_FILE) {
-			unsigned int len;
+		if (new_rflags & FILTRULE_MERGE_FILE) {
 			if (!pat_len) {
-				cp = ".cvsignore";
+				pat = ".cvsignore";
 				pat_len = 10;
 			}
-			len = pat_len;
-			if (new_mflags & MATCHFLG_EXCLUDE_SELF) {
-				const char *name = cp + len;
-				while (name > cp && name[-1] != '/') name--;
-				len -= name - cp;
-				add_rule(listp, name, len, 0, 0);
-				new_mflags &= ~MATCHFLG_EXCLUDE_SELF;
-				len = pat_len;
+			if (new_rflags & FILTRULE_EXCLUDE_SELF) {
+				const char *name;
+				filter_rule *excl_self;
+
+				if (!(excl_self = new0(filter_rule)))
+					out_of_memory("parse_filter_str");
+				/* Find the beginning of the basename and add an exclude for it. */
+				for (name = pat + pat_len; name > pat && name[-1] != '/'; name--) {}
+				add_rule(listp, name, (pat + pat_len) - name, excl_self, 0);
+				rule->rflags &= ~FILTRULE_EXCLUDE_SELF;
 			}
-			if (new_mflags & MATCHFLG_PERDIR_MERGE) {
+			if (new_rflags & FILTRULE_PERDIR_MERGE) {
 				if (parent_dirscan) {
-					if (!(p = parse_merge_name(cp, &len,
-								module_dirlen)))
-						continue;
-					add_rule(listp, p, len, new_mflags, 0);
+					const char *p;
+					unsigned int len = pat_len;
+					if ((p = parse_merge_name(pat, &len, module_dirlen)))
+						add_rule(listp, p, len, rule, 0);
+					else
+						free_filter(rule);
 					continue;
 				}
 			} else {
-				if (!(p = parse_merge_name(cp, &len, 0)))
-					continue;
-				parse_filter_file(listp, p, new_mflags,
-						  XFLG_FATAL_ERRORS);
+				const char *p;
+				unsigned int len = pat_len;
+				if ((p = parse_merge_name(pat, &len, 0)))
+					parse_filter_file(listp, p, rule, XFLG_FATAL_ERRORS);
+				free_filter(rule);
 				continue;
 			}
 		}
 
-		add_rule(listp, cp, pat_len, new_mflags, xflags);
+		add_rule(listp, pat, pat_len, rule, xflags);
 
-		if (new_mflags & MATCHFLG_CVS_IGNORE
-		    && !(new_mflags & MATCHFLG_MERGE_FILE))
-			get_cvs_excludes(new_mflags);
+		if (new_rflags & FILTRULE_CVS_IGNORE
+		    && !(new_rflags & FILTRULE_MERGE_FILE))
+			get_cvs_excludes(new_rflags);
 	}
 }
 
-
-void parse_filter_file(struct filter_list_struct *listp, const char *fname,
-		       uint32 mflags, int xflags)
+void parse_filter_file(filter_rule_list *listp, const char *fname, const filter_rule *template, int xflags)
 {
 	FILE *fp;
 	char line[BIGPATHBUFLEN];
 	char *eob = line + sizeof line - 1;
-	int word_split = mflags & MATCHFLG_WORD_SPLIT;
+	BOOL word_split = (template->rflags & FILTRULE_WORD_SPLIT) != 0;
 
 	if (!fname || !*fname)
 		return;
 
 	if (*fname != '-' || fname[1] || am_server) {
 		if (daemon_filter_list.head) {
@@ -1040,23 +1161,23 @@
 				fp = fopen(line, "rb");
 		} else
 			fp = fopen(fname, "rb");
 	} else
 		fp = stdin;
 
-	if (verbose > 2) {
+	if (DEBUG_GTE(FILTER, 2)) {
 		rprintf(FINFO, "[%s] parse_filter_file(%s,%x,%x)%s\n",
-			who_am_i(), fname, mflags, xflags,
+			who_am_i(), fname, template->rflags, xflags,
 			fp ? "" : " [not found]");
 	}
 
 	if (!fp) {
 		if (xflags & XFLG_FATAL_ERRORS) {
 			rsyserr(FERROR, errno,
 				"failed to open %sclude file %s",
-				mflags & MATCHFLG_INCLUDE ? "in" : "ex",
+				template->rflags & FILTRULE_INCLUDE ? "in" : "ex",
 				fname);
 			exit_cleanup(RERR_FILEIO);
 		}
 		return;
 	}
 	dirbuf[dirbuf_len] = '\0';
@@ -1085,69 +1206,69 @@
 			rprintf(FERROR, "discarding over-long filter: %s...\n", line);
 			s = line;
 		}
 		*s = '\0';
 		/* Skip an empty token and (when line parsing) comments. */
 		if (*line && (word_split || (*line != ';' && *line != '#')))
-			parse_rule(listp, line, mflags, xflags);
+			parse_filter_str(listp, line, template, xflags);
 		if (ch == EOF)
 			break;
 	}
 	fclose(fp);
 }
 
 /* If the "for_xfer" flag is set, the prefix is made compatible with the
  * current protocol_version (if possible) or a NULL is returned (if not
  * possible). */
-char *get_rule_prefix(int match_flags, const char *pat, int for_xfer,
+char *get_rule_prefix(filter_rule *rule, const char *pat, int for_xfer,
 		      unsigned int *plen_ptr)
 {
 	static char buf[MAX_RULE_PREFIX+1];
 	char *op = buf;
 	int legal_len = for_xfer && protocol_version < 29 ? 1 : MAX_RULE_PREFIX-1;
 
-	if (match_flags & MATCHFLG_PERDIR_MERGE) {
+	if (rule->rflags & FILTRULE_PERDIR_MERGE) {
 		if (legal_len == 1)
 			return NULL;
 		*op++ = ':';
-	} else if (match_flags & MATCHFLG_INCLUDE)
+	} else if (rule->rflags & FILTRULE_INCLUDE)
 		*op++ = '+';
 	else if (legal_len != 1
 	    || ((*pat == '-' || *pat == '+') && pat[1] == ' '))
 		*op++ = '-';
 	else
 		legal_len = 0;
 
-	if (match_flags & MATCHFLG_ABS_PATH)
+	if (rule->rflags & FILTRULE_ABS_PATH)
 		*op++ = '/';
-	if (match_flags & MATCHFLG_NEGATE)
+	if (rule->rflags & FILTRULE_NEGATE)
 		*op++ = '!';
-	if (match_flags & MATCHFLG_CVS_IGNORE)
+	if (rule->rflags & FILTRULE_CVS_IGNORE)
 		*op++ = 'C';
 	else {
-		if (match_flags & MATCHFLG_NO_INHERIT)
+		if (rule->rflags & FILTRULE_NO_INHERIT)
 			*op++ = 'n';
-		if (match_flags & MATCHFLG_WORD_SPLIT)
+		if (rule->rflags & FILTRULE_WORD_SPLIT)
 			*op++ = 'w';
-		if (match_flags & MATCHFLG_NO_PREFIXES) {
-			if (match_flags & MATCHFLG_INCLUDE)
+		if (rule->rflags & FILTRULE_NO_PREFIXES) {
+			if (rule->rflags & FILTRULE_INCLUDE)
 				*op++ = '+';
 			else
 				*op++ = '-';
 		}
 	}
-	if (match_flags & MATCHFLG_EXCLUDE_SELF)
+	if (rule->rflags & FILTRULE_EXCLUDE_SELF)
 		*op++ = 'e';
-	if (match_flags & MATCHFLG_SENDER_SIDE
+	if (rule->rflags & FILTRULE_SENDER_SIDE
 	    && (!for_xfer || protocol_version >= 29))
 		*op++ = 's';
-	if (match_flags & MATCHFLG_RECEIVER_SIDE
+	if (rule->rflags & FILTRULE_RECEIVER_SIDE
 	    && (!for_xfer || protocol_version >= 29
 	     || (delete_excluded && am_sender)))
 		*op++ = 'r';
-	if (match_flags & MATCHFLG_PERISHABLE) {
+	if (rule->rflags & FILTRULE_PERISHABLE) {
 		if (!for_xfer || protocol_version >= 30)
 			*op++ = 'p';
 		else if (am_sender)
 			return NULL;
 	}
 	if (op - buf > legal_len)
@@ -1157,15 +1278,15 @@
 	*op = '\0';
 	if (plen_ptr)
 		*plen_ptr = op - buf;
 	return buf;
 }
 
-static void send_rules(int f_out, struct filter_list_struct *flp)
+static void send_rules(int f_out, filter_rule_list *flp)
 {
-	struct filter_struct *ent, *prev = NULL;
+	filter_rule *ent, *prev = NULL;
 
 	for (ent = flp->head; ent; ent = ent->next) {
 		unsigned int len, plen, dlen;
 		int elide = 0;
 		char *p;
 
@@ -1173,46 +1294,46 @@
 		 * the code in parse_rule_tok() because some rules may have
 		 * been added before we found the --delete-excluded option.
 		 * We must also elide any CVS merge-file rules to avoid a
 		 * backward compatibility problem, and we elide any no-prefix
 		 * merge files as an optimization (since they can only have
 		 * include/exclude rules). */
-		if (ent->match_flags & MATCHFLG_SENDER_SIDE)
+		if (ent->rflags & FILTRULE_SENDER_SIDE)
 			elide = am_sender ? 1 : -1;
-		if (ent->match_flags & MATCHFLG_RECEIVER_SIDE)
+		if (ent->rflags & FILTRULE_RECEIVER_SIDE)
 			elide = elide ? 0 : am_sender ? -1 : 1;
 		else if (delete_excluded && !elide
-		 && (!(ent->match_flags & MATCHFLG_PERDIR_MERGE)
-		  || ent->match_flags & MATCHFLG_NO_PREFIXES))
+		 && (!(ent->rflags & FILTRULE_PERDIR_MERGE)
+		  || ent->rflags & FILTRULE_NO_PREFIXES))
 			elide = am_sender ? 1 : -1;
 		if (elide < 0) {
 			if (prev)
 				prev->next = ent->next;
 			else
 				flp->head = ent->next;
 		} else
 			prev = ent;
 		if (elide > 0)
 			continue;
-		if (ent->match_flags & MATCHFLG_CVS_IGNORE
-		    && !(ent->match_flags & MATCHFLG_MERGE_FILE)) {
+		if (ent->rflags & FILTRULE_CVS_IGNORE
+		    && !(ent->rflags & FILTRULE_MERGE_FILE)) {
 			int f = am_sender || protocol_version < 29 ? f_out : -2;
 			send_rules(f, &cvs_filter_list);
 			if (f == f_out)
 				continue;
 		}
-		p = get_rule_prefix(ent->match_flags, ent->pattern, 1, &plen);
+		p = get_rule_prefix(ent, ent->pattern, 1, &plen);
 		if (!p) {
 			rprintf(FERROR,
 				"filter rules are too modern for remote rsync.\n");
 			exit_cleanup(RERR_PROTOCOL);
 		}
 		if (f_out < 0)
 			continue;
 		len = strlen(ent->pattern);
-		dlen = ent->match_flags & MATCHFLG_DIRECTORY ? 1 : 0;
+		dlen = ent->rflags & FILTRULE_DIRECTORY ? 1 : 0;
 		if (!(plen + len + dlen))
 			continue;
 		write_int(f_out, plen + len + dlen);
 		if (plen)
 			write_buf(f_out, p, plen);
 		write_buf(f_out, ent->pattern, len);
@@ -1229,26 +1350,26 @@
 	    || (delete_mode && (!delete_excluded || protocol_version >= 29));
 
 	if (local_server || (am_sender && !receiver_wants_list))
 		f_out = -1;
 	if (cvs_exclude && am_sender) {
 		if (protocol_version >= 29)
-			parse_rule(&filter_list, ":C", 0, 0);
-		parse_rule(&filter_list, "-C", 0, 0);
+			parse_filter_str(&filter_list, ":C", rule_template(0), 0);
+		parse_filter_str(&filter_list, "-C", rule_template(0), 0);
 	}
 
 	send_rules(f_out, &filter_list);
 
 	if (f_out >= 0)
 		write_int(f_out, 0);
 
 	if (cvs_exclude) {
 		if (!am_sender || protocol_version < 29)
-			parse_rule(&filter_list, ":C", 0, 0);
+			parse_filter_str(&filter_list, ":C", rule_template(0), 0);
 		if (!am_sender)
-			parse_rule(&filter_list, "-C", 0, 0);
+			parse_filter_str(&filter_list, "-C", rule_template(0), 0);
 	}
 }
 
 /* This is only called by the server. */
 void recv_filter_list(int f_in)
 {
@@ -1261,20 +1382,20 @@
 
 	if (!local_server && (am_sender || receiver_wants_list)) {
 		while ((len = read_int(f_in)) != 0) {
 			if (len >= sizeof line)
 				overflow_exit("recv_rules");
 			read_sbuf(f_in, line, len);
-			parse_rule(&filter_list, line, 0, xflags);
+			parse_filter_str(&filter_list, line, rule_template(0), xflags);
 		}
 	}
 
 	if (cvs_exclude) {
 		if (local_server || am_sender || protocol_version < 29)
-			parse_rule(&filter_list, ":C", 0, 0);
+			parse_filter_str(&filter_list, ":C", rule_template(0), 0);
 		if (local_server || am_sender)
-			parse_rule(&filter_list, "-C", 0, 0);
+			parse_filter_str(&filter_list, "-C", rule_template(0), 0);
 	}
 
 	if (local_server) /* filter out any rules that aren't for us. */
 		send_rules(-1, &filter_list);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/fileio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/fileio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/fileio.c	2011-02-22 03:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/fileio.c	2013-09-17 00:02:46.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * File IO utilities used in rsync.
  *
  * Copyright (C) 1998 Andrew Tridgell
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2004-2009 Wayne Davison
+ * Copyright (C) 2004-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,17 +17,25 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "inums.h"
 
 #ifndef ENODATA
 #define ENODATA EAGAIN
 #endif
 
+/* We want all reads to be aligned on 1K boundries. */
+#define ALIGN_BOUNDRY 1024
+/* How far past the boundary is an offset? */
+#define ALIGNED_OVERSHOOT(oft) ((oft) & (ALIGN_BOUNDRY-1))
+/* Round up a length to the next boundary */
+#define ALIGNED_LENGTH(len) ((((len) - 1) | (ALIGN_BOUNDRY-1)) + 1)
+
 extern int sparse_files;
 
 static OFF_T sparse_seek = 0;
 
 int sparse_end(int f, OFF_T size)
 {
@@ -73,17 +81,20 @@
 		do_lseek(f, sparse_seek, SEEK_CUR);
 	sparse_seek = l2;
 
 	while ((ret = write(f, buf + l1, len - (l1+l2))) <= 0) {
 		if (ret < 0 && errno == EINTR)
 			continue;
+		sparse_seek = 0;
 		return ret;
 	}
 
-	if (ret != (int)(len - (l1+l2)))
+	if (ret != (int)(len - (l1+l2))) {
+		sparse_seek = 0;
 		return l1+ret;
+	}
 
 	return len;
 }
 
 
 static char *wf_writeBuf;
@@ -155,37 +166,35 @@
 
 
 /* This provides functionality somewhat similar to mmap() but using read().
  * It gives sliding window access to a file.  mmap() is not used because of
  * the possibility of another program (such as a mailer) truncating the
  * file thus giving us a SIGBUS. */
-struct map_struct *map_file(int fd, OFF_T len, int32 read_size,
-			    int32 blk_size)
+struct map_struct *map_file(int fd, OFF_T len, int32 read_size, int32 blk_size)
 {
 	struct map_struct *map;
 
 	if (!(map = new0(struct map_struct)))
 		out_of_memory("map_file");
 
 	if (blk_size && (read_size % blk_size))
 		read_size += blk_size - (read_size % blk_size);
 
 	map->fd = fd;
 	map->file_size = len;
-	map->def_window_size = read_size;
+	map->def_window_size = ALIGNED_LENGTH(read_size);
 
 	return map;
 }
 
 
 /* slide the read window in the file */
 char *map_ptr(struct map_struct *map, OFF_T offset, int32 len)
 {
-	int32 nread;
 	OFF_T window_start, read_start;
-	int32 window_size, read_size, read_offset;
+	int32 window_size, read_size, read_offset, align_fudge;
 
 	if (len == 0)
 		return NULL;
 	if (len < 0) {
 		rprintf(FERROR, "invalid len passed to map_ptr: %ld\n",
 			(long)len);
@@ -194,32 +203,31 @@
 
 	/* in most cases the region will already be available */
 	if (offset >= map->p_offset && offset+len <= map->p_offset+map->p_len)
 		return map->p + (offset - map->p_offset);
 
 	/* nope, we are going to have to do a read. Work out our desired window */
-	window_start = offset;
+	align_fudge = (int32)ALIGNED_OVERSHOOT(offset);
+	window_start = offset - align_fudge;
 	window_size = map->def_window_size;
 	if (window_start + window_size > map->file_size)
 		window_size = (int32)(map->file_size - window_start);
-	if (len > window_size)
-		window_size = len;
+	if (window_size < len + align_fudge)
+		window_size = ALIGNED_LENGTH(len + align_fudge);
 
 	/* make sure we have allocated enough memory for the window */
 	if (window_size > map->p_size) {
 		map->p = realloc_array(map->p, char, window_size);
 		if (!map->p)
 			out_of_memory("map_ptr");
 		map->p_size = window_size;
 	}
 
-	/* Now try to avoid re-reading any bytes by reusing any bytes
-	 * from the previous buffer. */
-	if (window_start >= map->p_offset &&
-	    window_start < map->p_offset + map->p_len &&
-	    window_start + window_size >= map->p_offset + map->p_len) {
+	/* Now try to avoid re-reading any bytes by reusing any bytes from the previous buffer. */
+	if (window_start >= map->p_offset && window_start < map->p_offset + map->p_len
+	 && window_start + window_size >= map->p_offset + map->p_len) {
 		read_start = map->p_offset + map->p_len;
 		read_offset = (int32)(read_start - window_start);
 		read_size = window_size - read_offset;
 		memmove(map->p, map->p + (map->p_len - read_offset), read_offset);
 	} else {
 		read_start = window_start;
@@ -233,23 +241,23 @@
 		exit_cleanup(RERR_FILEIO);
 	}
 
 	if (map->p_fd_offset != read_start) {
 		OFF_T ret = do_lseek(map->fd, read_start, SEEK_SET);
 		if (ret != read_start) {
-			rsyserr(FERROR, errno, "lseek returned %.0f, not %.0f",
-				(double)ret, (double)read_start);
+			rsyserr(FERROR, errno, "lseek returned %s, not %s",
+				big_num(ret), big_num(read_start));
 			exit_cleanup(RERR_FILEIO);
 		}
 		map->p_fd_offset = read_start;
 	}
 	map->p_offset = window_start;
 	map->p_len = window_size;
 
 	while (read_size > 0) {
-		nread = read(map->fd, map->p + read_offset, read_size);
+		int32 nread = read(map->fd, map->p + read_offset, read_size);
 		if (nread <= 0) {
 			if (!map->status)
 				map->status = nread ? errno : ENODATA;
 			/* The best we can do is zero the buffer -- the file
 			 * has changed mid transfer! */
 			memset(map->p + read_offset, 0, read_size);
@@ -257,13 +265,13 @@
 		}
 		map->p_fd_offset += nread;
 		read_offset += nread;
 		read_size -= nread;
 	}
 
-	return map->p;
+	return map->p + align_fudge;
 }
 
 
 int unmap_file(struct map_struct *map)
 {
 	int	ret;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/flist.c	2011-08-28 05:58:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/flist.c	2013-06-17 07:33:32.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * Generate and receive file lists.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2002-2009 Wayne Davison
+ * Copyright (C) 2002-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -20,22 +20,21 @@
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 #include "ifuncs.h"
 #include "rounding.h"
+#include "inums.h"
 #include "io.h"
 
-extern int verbose;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
 extern int am_sender;
 extern int am_generator;
 extern int inc_recurse;
-extern int do_progress;
 extern int always_checksum;
 extern int module_id;
 extern int ignore_errors;
 extern int numeric_ids;
 extern int recurse;
 extern int use_qsort;
@@ -49,12 +48,13 @@
 extern int preserve_xattrs;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_devices;
 extern int preserve_specials;
 extern int delete_during;
+extern int missing_args;
 extern int eol_nulls;
 extern int relative_paths;
 extern int implied_dirs;
 extern int ignore_perishable;
 extern int non_perishable_cnt;
 extern int prune_empty_dirs;
@@ -63,23 +63,26 @@
 extern int protocol_version;
 extern int sanitize_paths;
 extern int munge_symlinks;
 extern int use_safe_inc_flist;
 extern int need_unsorted_flist;
 extern int sender_symlink_iconv;
+extern int output_needs_newline;
+extern int sender_keeps_checksum;
 extern int unsort_ndx;
 extern uid_t our_uid;
 extern struct stats stats;
 extern char *filesfrom_host;
+extern char *usermap, *groupmap;
 
 extern char curr_dir[MAXPATHLEN];
 
 extern struct chmod_mode_struct *chmod_modes;
 
-extern struct filter_list_struct filter_list;
-extern struct filter_list_struct daemon_filter_list;
+extern filter_rule_list filter_list;
+extern filter_rule_list daemon_filter_list;
 
 #ifdef ICONV_OPTION
 extern int filesfrom_convert;
 extern iconv_t ic_send, ic_recv;
 #endif
 
@@ -90,17 +93,19 @@
 dev_t filesystem_dev; /* used to implement -x */
 
 struct file_list *cur_flist, *first_flist, *dir_flist;
 int send_dir_ndx = -1, send_dir_depth = -1;
 int flist_cnt = 0; /* how many (non-tmp) file list objects exist */
 int file_total = 0; /* total of all active items over all file-lists */
+int file_old_total = 0; /* total of active items that will soon be gone */
 int flist_eof = 0; /* all the file-lists are now known */
 
 #define NORMAL_NAME 0
 #define SLASH_ENDING_NAME 1
 #define DOTDIR_NAME 2
+#define MISSING_NAME 3
 
 /* Starting from protocol version 26, we always use 64-bit ino_t and dev_t
  * internally, even if this platform does not allow files to have 64-bit inums.
  * The only exception is if we're on a platform with no 64-bit type at all.
  *
  * Because we use read_longint() to get these off the wire, if you transfer
@@ -119,60 +124,60 @@
 static int64 tmp_dev = -1, tmp_ino;
 #endif
 static char tmp_sum[MAX_DIGEST_LEN];
 
 static char empty_sum[MAX_DIGEST_LEN];
 static int flist_count_offset; /* for --delete --progress */
-static int dir_count = 0;
 
 static void flist_sort_and_clean(struct file_list *flist, int strip_root);
 static void output_flist(struct file_list *flist);
 
 void init_flist(void)
 {
-	if (verbose > 4) {
+	if (DEBUG_GTE(FLIST, 4)) {
 		rprintf(FINFO, "FILE_STRUCT_LEN=%d, EXTRA_LEN=%d\n",
 			(int)FILE_STRUCT_LEN, (int)EXTRA_LEN);
 	}
 	checksum_len = protocol_version < 21 ? 2
 		     : protocol_version < 30 ? MD4_DIGEST_LEN
 		     : MD5_DIGEST_LEN;
 }
 
 static int show_filelist_p(void)
 {
-	return verbose && xfer_dirs && !am_server && !inc_recurse;
+	return INFO_GTE(FLIST, 1) && xfer_dirs && !am_server && !inc_recurse;
 }
 
 static void start_filelist_progress(char *kind)
 {
 	rprintf(FCLIENT, "%s ... ", kind);
-	if (verbose > 1 || do_progress)
-		rprintf(FCLIENT, "\n");
+	output_needs_newline = 1;
 	rflush(FINFO);
 }
 
 static void emit_filelist_progress(int count)
 {
 	rprintf(FCLIENT, " %d files...\r", count);
 }
 
 static void maybe_emit_filelist_progress(int count)
 {
-	if (do_progress && show_filelist_p() && (count % 100) == 0)
+	if (INFO_GTE(FLIST, 2) && show_filelist_p() && (count % 100) == 0)
 		emit_filelist_progress(count);
 }
 
 static void finish_filelist_progress(const struct file_list *flist)
 {
-	if (do_progress) {
+	if (INFO_GTE(FLIST, 2)) {
 		/* This overwrites the progress line */
 		rprintf(FINFO, "%d file%sto consider\n",
 			flist->used, flist->used == 1 ? " " : "s ");
-	} else
+	} else {
+		output_needs_newline = 0;
 		rprintf(FINFO, "done\n");
+	}
 }
 
 void show_flist_stats(void)
 {
 	/* Nothing yet */
 }
@@ -188,18 +193,18 @@
 static int readlink_stat(const char *path, STRUCT_STAT *stp, char *linkbuf)
 {
 #ifdef SUPPORT_LINKS
 	if (link_stat(path, stp, copy_dirlinks) < 0)
 		return -1;
 	if (S_ISLNK(stp->st_mode)) {
-		int llen = readlink(path, linkbuf, MAXPATHLEN - 1);
+		int llen = do_readlink(path, linkbuf, MAXPATHLEN - 1);
 		if (llen < 0)
 			return -1;
 		linkbuf[llen] = '\0';
 		if (copy_unsafe_links && unsafe_symlink(linkbuf, path)) {
-			if (verbose > 1) {
+			if (INFO_GTE(SYMSAFE, 1)) {
 				rprintf(FINFO,"copying unsafe symlink \"%s\" -> \"%s\"\n",
 					path, linkbuf);
 			}
 			return x_stat(path, stp, NULL);
 		}
 		if (munge_symlinks && am_sender && llen > SYMLINK_PREFIX_LEN
@@ -313,16 +318,16 @@
 	if (flist->malloced < flist->used + extra)
 		flist->malloced = flist->used + extra;
 
 	new_ptr = realloc_array(flist->files, struct file_struct *,
 				flist->malloced);
 
-	if (verbose >= 2 && flist->malloced != FLIST_START) {
-		rprintf(FCLIENT, "[%s] expand file_list pointer array to %.0f bytes, did%s move\n",
+	if (DEBUG_GTE(FLIST, 1) && flist->malloced != FLIST_START) {
+		rprintf(FCLIENT, "[%s] expand file_list pointer array to %s bytes, did%s move\n",
 		    who_am_i(),
-		    (double)sizeof flist->files[0] * flist->malloced,
+		    big_num(sizeof flist->files[0] * flist->malloced),
 		    (new_ptr == flist->files) ? " not" : "");
 	}
 
 	flist->files = new_ptr;
 
 	if (!flist->files)
@@ -400,27 +405,41 @@
 	static dev_t rdev;
 	static uint32 rdev_major;
 	static uid_t uid;
 	static gid_t gid;
 	static const char *user_name, *group_name;
 	static char lastname[MAXPATHLEN];
+#ifdef SUPPORT_HARD_LINKS
 	int first_hlink_ndx = -1;
+#endif
 	int l1, l2;
 	int xflags;
 
-	/* Initialize starting value of xflags. */
-	if (protocol_version >= 30 && S_ISDIR(file->mode)) {
-		dir_count++;
-		if (file->flags & FLAG_CONTENT_DIR)
-			xflags = file->flags & FLAG_TOP_DIR;
-		else if (file->flags & FLAG_IMPLIED_DIR)
-			xflags = XMIT_TOP_DIR | XMIT_NO_CONTENT_DIR;
-		else
-			xflags = XMIT_NO_CONTENT_DIR;
-	} else
-		xflags = file->flags & FLAG_TOP_DIR; /* FLAG_TOP_DIR == XMIT_TOP_DIR */
+	/* Initialize starting value of xflags and adjust counts. */
+	if (S_ISREG(file->mode))
+		xflags = 0;
+	else if (S_ISDIR(file->mode)) {
+		stats.num_dirs++;
+		if (protocol_version >= 30) {
+			if (file->flags & FLAG_CONTENT_DIR)
+				xflags = file->flags & FLAG_TOP_DIR;
+			else if (file->flags & FLAG_IMPLIED_DIR)
+				xflags = XMIT_TOP_DIR | XMIT_NO_CONTENT_DIR;
+			else
+				xflags = XMIT_NO_CONTENT_DIR;
+		} else
+			xflags = file->flags & FLAG_TOP_DIR; /* FLAG_TOP_DIR == XMIT_TOP_DIR */
+	} else {
+		if (S_ISLNK(file->mode))
+			stats.num_symlinks++;
+		else if (IS_DEVICE(file->mode))
+			stats.num_devices++;
+		else if (IS_SPECIAL(file->mode))
+			stats.num_specials++;
+		xflags = 0;
+	}
 
 	if (file->mode == mode)
 		xflags |= XMIT_SAME_MODE;
 	else
 		mode = file->mode;
 
@@ -436,13 +455,13 @@
 				xflags |= XMIT_SAME_RDEV_MAJOR;
 			else
 				rdev_major = major(rdev);
 			if (protocol_version < 30 && (uint32)minor(rdev) <= 0xFFu)
 				xflags |= XMIT_RDEV_MINOR_8_pre30;
 		}
-	} else if (preserve_specials && IS_SPECIAL(mode)) {
+	} else if (preserve_specials && IS_SPECIAL(mode) && protocol_version < 31) {
 		/* Special files don't need an rdev number, so just make
 		 * the historical transmission of the value efficient. */
 		if (protocol_version < 28)
 			xflags |= XMIT_SAME_RDEV_pre28;
 		else {
 			rdev = MAKEDEV(major(rdev), 0);
@@ -473,22 +492,35 @@
 		}
 	}
 	if (file->modtime == modtime)
 		xflags |= XMIT_SAME_TIME;
 	else
 		modtime = file->modtime;
+	if (NSEC_BUMP(file) && protocol_version >= 31)
+		xflags |= XMIT_MOD_NSEC;
 
 #ifdef SUPPORT_HARD_LINKS
 	if (tmp_dev != -1) {
 		if (protocol_version >= 30) {
 			struct ht_int64_node *np = idev_find(tmp_dev, tmp_ino);
 			first_hlink_ndx = (int32)(long)np->data - 1;
 			if (first_hlink_ndx < 0) {
 				np->data = (void*)(long)(first_ndx + ndx + 1);
 				xflags |= XMIT_HLINK_FIRST;
 			}
+			if (DEBUG_GTE(HLINK, 1)) {
+				if (first_hlink_ndx >= 0) {
+					rprintf(FINFO, "[%s] #%d hard-links #%d (%sabbrev)\n",
+						who_am_i(), first_ndx + ndx, first_hlink_ndx,
+						first_hlink_ndx >= first_ndx ? "" : "un");
+				} else if (DEBUG_GTE(HLINK, 3)) {
+					rprintf(FINFO, "[%s] dev:inode for #%d is %s:%s\n",
+						who_am_i(), first_ndx + ndx,
+						big_num(tmp_dev), big_num(tmp_ino));
+				}
+			}
 		} else {
 			if (tmp_dev == dev) {
 				if (protocol_version >= 28)
 					xflags |= XMIT_SAME_DEV_pre30;
 			} else
 				dev = tmp_dev;
@@ -529,25 +561,29 @@
 	if (xflags & XMIT_LONG_NAME)
 		write_varint30(f, l2);
 	else
 		write_byte(f, l2);
 	write_buf(f, fname + l1, l2);
 
+#ifdef SUPPORT_HARD_LINKS
 	if (first_hlink_ndx >= 0) {
 		write_varint(f, first_hlink_ndx);
 		if (first_hlink_ndx >= first_ndx)
 			goto the_end;
 	}
+#endif
 
 	write_varlong30(f, F_LENGTH(file), 3);
 	if (!(xflags & XMIT_SAME_TIME)) {
 		if (protocol_version >= 30)
 			write_varlong(f, modtime, 4);
 		else
 			write_int(f, modtime);
 	}
+	if (xflags & XMIT_MOD_NSEC)
+		write_varint(f, F_MOD_NSEC(file));
 	if (!(xflags & XMIT_SAME_MODE))
 		write_int(f, to_wire_mode(mode));
 	if (preserve_uid && !(xflags & XMIT_SAME_UID)) {
 		if (protocol_version < 30)
 			write_int(f, uid);
 		else {
@@ -569,13 +605,13 @@
 				write_byte(f, len);
 				write_buf(f, group_name, len);
 			}
 		}
 	}
 	if ((preserve_devices && IS_DEVICE(mode))
-	 || (preserve_specials && IS_SPECIAL(mode))) {
+	 || (preserve_specials && IS_SPECIAL(mode) && protocol_version < 31)) {
 		if (protocol_version < 28) {
 			if (!(xflags & XMIT_SAME_RDEV_pre28))
 				write_int(f, (int)rdev);
 		} else {
 			if (!(xflags & XMIT_SAME_RDEV_MAJOR))
 				write_varint30(f, major(rdev));
@@ -620,13 +656,15 @@
 			/* Prior to 28, we sent a useless set of nulls. */
 			sum = empty_sum;
 		}
 		write_buf(f, sum, checksum_len);
 	}
 
+#ifdef SUPPORT_HARD_LINKS
   the_end:
+#endif
 	strlcpy(lastname, fname, MAXPATHLEN);
 
 	if (S_ISREG(mode) || S_ISLNK(mode))
 		stats.total_size += F_LENGTH(file);
 }
 
@@ -649,12 +687,13 @@
 	char thisname[MAXPATHLEN];
 	unsigned int l1 = 0, l2 = 0;
 	int alloc_len, basename_len, linkname_len;
 	int extra_len = file_extra_cnt * EXTRA_LEN;
 	int first_hlink_ndx = -1;
 	int64 file_length;
+	uint32 modtime_nsec;
 	const char *basename;
 	struct file_struct *file;
 	alloc_pool_t *pool;
 	char *bp;
 
 	if (xflags & XMIT_SAME_NAME)
@@ -681,15 +720,15 @@
 
 #ifdef ICONV_OPTION
 	if (ic_recv != (iconv_t)-1) {
 		xbuf outbuf, inbuf;
 
 		INIT_CONST_XBUF(outbuf, thisname);
-		INIT_XBUF(inbuf, lastname, basename_len, -1);
+		INIT_XBUF(inbuf, lastname, basename_len, (size_t)-1);
 
-		if (iconvbufs(ic_recv, &inbuf, &outbuf, 0) < 0) {
+		if (iconvbufs(ic_recv, &inbuf, &outbuf, ICB_INIT) < 0) {
 			io_error |= IOERR_GENERAL;
 			rprintf(FERROR_UTF8,
 			    "[%s] cannot convert filename: %s (%s)\n",
 			    who_am_i(), lastname, strerror(errno));
 			outbuf.len = 0;
 		}
@@ -723,16 +762,22 @@
 		if (first_hlink_ndx < 0 || first_hlink_ndx >= flist->ndx_start + flist->used) {
 			rprintf(FERROR,
 				"hard-link reference out of range: %d (%d)\n",
 				first_hlink_ndx, flist->ndx_start + flist->used);
 			exit_cleanup(RERR_PROTOCOL);
 		}
+		if (DEBUG_GTE(HLINK, 1)) {
+			rprintf(FINFO, "[%s] #%d hard-links #%d (%sabbrev)\n",
+				who_am_i(), flist->used+flist->ndx_start, first_hlink_ndx,
+				first_hlink_ndx >= flist->ndx_start ? "" : "un");
+		}
 		if (first_hlink_ndx >= flist->ndx_start) {
 			struct file_struct *first = flist->files[first_hlink_ndx - flist->ndx_start];
 			file_length = F_LENGTH(first);
 			modtime = first->modtime;
+			modtime_nsec = F_MOD_NSEC(first);
 			mode = first->mode;
 			if (preserve_uid)
 				uid = F_OWNER(first);
 			if (preserve_gid)
 				gid = F_GROUP(first);
 			if (preserve_devices && IS_DEVICE(mode)) {
@@ -760,44 +805,48 @@
 				    lastname);
 			}
 #endif
 		} else
 			modtime = read_int(f);
 	}
+	if (xflags & XMIT_MOD_NSEC)
+		modtime_nsec = read_varint(f);
+	else
+		modtime_nsec = 0;
 	if (!(xflags & XMIT_SAME_MODE))
 		mode = from_wire_mode(read_int(f));
 
-	if (chmod_modes && !S_ISLNK(mode))
+	if (chmod_modes && !S_ISLNK(mode) && mode)
 		mode = tweak_mode(mode, chmod_modes);
 
 	if (preserve_uid && !(xflags & XMIT_SAME_UID)) {
 		if (protocol_version < 30)
 			uid = (uid_t)read_int(f);
 		else {
 			uid = (uid_t)read_varint(f);
 			if (xflags & XMIT_USER_NAME_FOLLOWS)
 				uid = recv_user_name(f, uid);
-			else if (inc_recurse && am_root && !numeric_ids)
+			else if (inc_recurse && am_root && (!numeric_ids || usermap))
 				uid = match_uid(uid);
 		}
 	}
 	if (preserve_gid && !(xflags & XMIT_SAME_GID)) {
 		if (protocol_version < 30)
 			gid = (gid_t)read_int(f);
 		else {
 			gid = (gid_t)read_varint(f);
 			gid_flags = 0;
 			if (xflags & XMIT_GROUP_NAME_FOLLOWS)
 				gid = recv_group_name(f, gid, &gid_flags);
-			else if (inc_recurse && (!am_root || !numeric_ids))
+			else if (inc_recurse && (!am_root || !numeric_ids || groupmap))
 				gid = match_gid(gid, &gid_flags);
 		}
 	}
 
 	if ((preserve_devices && IS_DEVICE(mode))
-	 || (preserve_specials && IS_SPECIAL(mode))) {
+	 || (preserve_specials && IS_SPECIAL(mode) && protocol_version < 31)) {
 		if (protocol_version < 28) {
 			if (!(xflags & XMIT_SAME_RDEV_pre28))
 				rdev = (dev_t)read_int(f);
 		} else {
 			uint32 rdev_minor;
 			if (!(xflags & XMIT_SAME_RDEV_MAJOR))
@@ -858,12 +907,16 @@
 		extra_len += SUM_EXTRA_CNT * EXTRA_LEN;
 
 #if SIZEOF_INT64 >= 8
 	if (file_length > 0xFFFFFFFFu && S_ISREG(mode))
 		extra_len += EXTRA_LEN;
 #endif
+#ifdef HAVE_UTIMENSAT
+	if (modtime_nsec)
+		extra_len += EXTRA_LEN;
+#endif
 	if (file_length < 0) {
 		rprintf(FERROR, "Offset underflow: file-length is negative\n");
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
 
 	if (inc_recurse && S_ISDIR(mode)) {
@@ -893,21 +946,27 @@
 
 #ifdef SUPPORT_HARD_LINKS
 	if (xflags & XMIT_HLINKED)
 		file->flags |= FLAG_HLINKED;
 #endif
 	file->modtime = (time_t)modtime;
+#ifdef HAVE_UTIMENSAT
+	if (modtime_nsec) {
+		file->flags |= FLAG_MOD_NSEC;
+		OPT_EXTRA(file, 0)->unum = modtime_nsec;
+	}
+#endif
 	file->len32 = (uint32)file_length;
 #if SIZEOF_INT64 >= 8
 	if (file_length > 0xFFFFFFFFu && S_ISREG(mode)) {
 #if SIZEOF_CAPITAL_OFF_T < 8
 		rprintf(FERROR, "Offset overflow: attempted 64-bit file-length\n");
 		exit_cleanup(RERR_UNSUPPORTED);
 #else
 		file->flags |= FLAG_LENGTH64;
-		OPT_EXTRA(file, 0)->unum = (uint32)(file_length >> 32);
+		OPT_EXTRA(file, NSEC_BUMP(file))->unum = (uint32)(file_length >> 32);
 #endif
 	}
 #endif
 	file->mode = mode;
 	if (preserve_uid)
 		F_OWNER(file) = uid;
@@ -981,13 +1040,13 @@
 				 * buffer and then convert it into the right spot. */
 				INIT_XBUF(inbuf, bp + alloc_len - linkname_len,
 					  linkname_len - 1, (size_t)-1);
 				read_sbuf(f, inbuf.buf, inbuf.len);
 				INIT_XBUF(outbuf, bp, 0, alloc_len);
 
-				if (iconvbufs(ic_recv, &inbuf, &outbuf, 0) < 0) {
+				if (iconvbufs(ic_recv, &inbuf, &outbuf, ICB_INIT) < 0) {
 					io_error |= IOERR_GENERAL;
 					rprintf(FERROR_XFER,
 					    "[%s] cannot convert symlink data for: %s (%s)\n",
 					    who_am_i(), full_fname(thisname), strerror(errno));
 					bp = (char*)file->basename;
 					*bp++ = '\0';
@@ -1094,14 +1153,16 @@
 		return NULL;
 	}
 	clean_fname(thisname, 0);
 	if (sanitize_paths)
 		sanitize_path(thisname, thisname, "", 0, SP_DEFAULT);
 
-	if (stp && S_ISDIR(stp->st_mode)) {
-		st = *stp; /* Needed for "symlink/." with --relative. */
+	if (stp && (S_ISDIR(stp->st_mode) || stp->st_mode == 0)) {
+		/* This is needed to handle a "symlink/." with a --relative
+		 * dir, or a request to delete a specific file. */
+		st = *stp;
 		*linkname = '\0'; /* make IBM code checker happy */
 	} else if (readlink_stat(thisname, &st, linkname) != 0) {
 		int save_errno = errno;
 		/* See if file is excluded before reporting an error. */
 		if (filter_level != NO_FILTERS
 		 && (is_excluded(thisname, 0, filter_level)
@@ -1136,12 +1197,17 @@
 		} else {
 			io_error |= IOERR_GENERAL;
 			rsyserr(FERROR_XFER, save_errno, "readlink_stat(%s) failed",
 				full_fname(thisname));
 		}
 		return NULL;
+	} else if (st.st_mode == 0) {
+		io_error |= IOERR_GENERAL;
+		rprintf(FINFO, "skipping file with bogus (zero) st_mode: %s\n",
+			full_fname(thisname));
+		return NULL;
 	}
 
 	if (filter_level == NO_FILTERS)
 		goto skip_filters;
 
 	if (S_ISDIR(st.st_mode)) {
@@ -1152,13 +1218,13 @@
 		/* -x only affects dirs because we need to avoid recursing
 		 * into a mount-point directory, not to avoid copying a
 		 * symlinked file if -L (or similar) was specified. */
 		if (one_file_system && st.st_dev != filesystem_dev
 		 && BITS_SETnUNSET(flags, FLAG_CONTENT_DIR, FLAG_TOP_DIR)) {
 			if (one_file_system > 1) {
-				if (verbose > 1) {
+				if (INFO_GTE(MOUNT, 1)) {
 					rprintf(FINFO,
 					    "[%s] skipping mount-point dir %s\n",
 					    who_am_i(), thisname);
 				}
 				return NULL;
 			}
@@ -1201,13 +1267,13 @@
 		if (preserve_acls && S_ISDIR(st.st_mode))
 			extra_len += EXTRA_LEN;
 #endif
 		pool = NULL;
 	}
 
-	if (verbose > 2) {
+	if (DEBUG_GTE(FLIST, 2)) {
 		rprintf(FINFO, "[%s] make_file(%s,*,%d)\n",
 			who_am_i(), thisname, filter_level);
 	}
 
 	if ((basename = strrchr(thisname, '/')) != NULL) {
 		int len = basename++ - thisname;
@@ -1224,17 +1290,27 @@
 #ifdef SUPPORT_LINKS
 	linkname_len = S_ISLNK(st.st_mode) ? strlen(linkname) + 1 : 0;
 #else
 	linkname_len = 0;
 #endif
 
+#ifdef ST_MTIME_NSEC
+	if (st.ST_MTIME_NSEC && protocol_version >= 31)
+		extra_len += EXTRA_LEN;
+#endif
 #if SIZEOF_CAPITAL_OFF_T >= 8
 	if (st.st_size > 0xFFFFFFFFu && S_ISREG(st.st_mode))
 		extra_len += EXTRA_LEN;
 #endif
 
+	if (always_checksum && am_sender && S_ISREG(st.st_mode)) {
+		file_checksum(thisname, tmp_sum, st.st_size);
+		if (sender_keeps_checksum)
+			extra_len += SUM_EXTRA_CNT * EXTRA_LEN;
+	}
+
 #if EXTRA_ROUNDING > 0
 	if (extra_len & (EXTRA_ROUNDING * EXTRA_LEN))
 		extra_len = (extra_len | (EXTRA_ROUNDING * EXTRA_LEN)) + EXTRA_LEN;
 #endif
 
 	alloc_len = FILE_STRUCT_LEN + extra_len + basename_len
@@ -1272,17 +1348,23 @@
 	} else if (IS_SPECIAL(st.st_mode))
 		st.st_size = 0;
 #endif
 
 	file->flags = flags;
 	file->modtime = st.st_mtime;
+#ifdef ST_MTIME_NSEC
+	if (st.ST_MTIME_NSEC && protocol_version >= 31) {
+		file->flags |= FLAG_MOD_NSEC;
+		OPT_EXTRA(file, 0)->unum = st.ST_MTIME_NSEC;
+	}
+#endif
 	file->len32 = (uint32)st.st_size;
 #if SIZEOF_CAPITAL_OFF_T >= 8
 	if (st.st_size > 0xFFFFFFFFu && S_ISREG(st.st_mode)) {
 		file->flags |= FLAG_LENGTH64;
-		OPT_EXTRA(file, 0)->unum = (uint32)(st.st_size >> 32);
+		OPT_EXTRA(file, NSEC_BUMP(file))->unum = (uint32)(st.st_size >> 32);
 	}
 #endif
 	file->mode = st.st_mode;
 	if (preserve_uid)
 		F_OWNER(file) = st.st_uid;
 	if (preserve_gid)
@@ -1295,28 +1377,28 @@
 
 #ifdef SUPPORT_LINKS
 	if (linkname_len)
 		memcpy(bp + basename_len, linkname, linkname_len);
 #endif
 
-	if (always_checksum && am_sender && S_ISREG(st.st_mode))
-		file_checksum(thisname, tmp_sum, st.st_size);
-
 	if (am_sender)
 		F_PATHNAME(file) = pathname;
 	else if (!pool)
 		F_DEPTH(file) = extra_len / EXTRA_LEN;
 
 	if (basename_len == 0+1) {
 		if (!pool)
 			unmake_file(file);
 		return NULL;
 	}
 
+	if (sender_keeps_checksum && S_ISREG(st.st_mode))
+		memcpy(F_SUM(file), tmp_sum, checksum_len);
+
 	if (unsort_ndx)
-		F_NDX(file) = dir_count;
+		F_NDX(file) = stats.num_dirs;
 
 	return file;
 }
 
 /* Only called for temporary file_struct entries created by make_file(). */
 void unmake_file(struct file_struct *file)
@@ -1331,13 +1413,13 @@
 	struct file_struct *file;
 
 	file = make_file(fname, flist, stp, flags, filter_level);
 	if (!file)
 		return NULL;
 
-	if (chmod_modes && !S_ISLNK(file->mode))
+	if (chmod_modes && !S_ISLNK(file->mode) && file->mode)
 		file->mode = tweak_mode(file->mode, chmod_modes);
 
 	if (f >= 0) {
 		char fbuf[MAXPATHLEN];
 #ifdef SUPPORT_LINKS
 		const char *symlink_name;
@@ -1345,12 +1427,13 @@
 #ifdef ICONV_OPTION
 		char symlink_buf[MAXPATHLEN];
 #endif
 #endif
 #if defined SUPPORT_ACLS || defined SUPPORT_XATTRS
 		stat_x sx;
+		init_stat_x(&sx);
 #endif
 
 #ifdef SUPPORT_LINKS
 		if (preserve_links && S_ISLNK(file->mode)) {
 			symlink_name = F_SYMLINK(file);
 			symlink_len = strlen(symlink_name);
@@ -1374,20 +1457,20 @@
 
 			INIT_CONST_XBUF(outbuf, fbuf);
 
 			if (file->dirname) {
 				INIT_XBUF_STRLEN(inbuf, (char*)file->dirname);
 				outbuf.size -= 2; /* Reserve room for '/' & 1 more char. */
-				if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0)
+				if (iconvbufs(ic_send, &inbuf, &outbuf, ICB_INIT) < 0)
 					goto convert_error;
 				outbuf.size += 2;
 				fbuf[outbuf.len++] = '/';
 			}
 
 			INIT_XBUF_STRLEN(inbuf, (char*)file->basename);
-			if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0) {
+			if (iconvbufs(ic_send, &inbuf, &outbuf, ICB_INIT) < 0) {
 			  convert_error:
 				io_error |= IOERR_GENERAL;
 				rprintf(FERROR_XFER,
 				    "[%s] cannot convert filename: %s (%s)\n",
 				    who_am_i(), f_name(file, fbuf), strerror(errno));
 				return NULL;
@@ -1395,13 +1478,13 @@
 			fbuf[outbuf.len] = '\0';
 
 #ifdef SUPPORT_LINKS
 			if (symlink_len && sender_symlink_iconv) {
 				INIT_XBUF(inbuf, (char*)symlink_name, symlink_len, (size_t)-1);
 				INIT_CONST_XBUF(outbuf, symlink_buf);
-				if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0) {
+				if (iconvbufs(ic_send, &inbuf, &outbuf, ICB_INIT) < 0) {
 					io_error |= IOERR_GENERAL;
 					f_name(file, fbuf);
 					rprintf(FERROR_XFER,
 					    "[%s] cannot convert symlink data for: %s (%s)\n",
 					    who_am_i(), full_fname(fbuf), strerror(errno));
 					return NULL;
@@ -1416,23 +1499,21 @@
 #endif
 			f_name(file, fbuf);
 
 #ifdef SUPPORT_ACLS
 		if (preserve_acls && !S_ISLNK(file->mode)) {
 			sx.st.st_mode = file->mode;
-			sx.acc_acl = sx.def_acl = NULL;
 			if (get_acl(fname, &sx) < 0) {
 				io_error |= IOERR_GENERAL;
 				return NULL;
 			}
 		}
 #endif
 #ifdef SUPPORT_XATTRS
 		if (preserve_xattrs) {
 			sx.st.st_mode = file->mode;
-			sx.xattr = NULL;
 			if (get_xattr(fname, &sx) < 0) {
 				io_error |= IOERR_GENERAL;
 				return NULL;
 			}
 		}
 #endif
@@ -1697,13 +1778,13 @@
 	static int lastpath_len = 0;
 	static struct file_struct *lastpath_struct = NULL;
 	struct file_struct *file;
 	item_list *relname_list;
 	relnamecache **rnpp;
 	int len, need_new_dir, depth = 0;
-	struct filter_list_struct save_filter_list = filter_list;
+	filter_rule_list save_filter_list = filter_list;
 
 	flags = (flags | FLAG_IMPLIED_DIR) & ~(FLAG_TOP_DIR | FLAG_CONTENT_DIR);
 	filter_list.head = filter_list.tail = NULL; /* Don't filter implied dirs. */
 
 	if (inc_recurse) {
 		if (lastpath_struct && F_PATHNAME(lastpath_struct) == pathname
@@ -1793,13 +1874,14 @@
 
 static NORETURN void fatal_unsafe_io_error(void)
 {
 	/* This (sadly) can only happen when pushing data because
 	 * the sender does not know about what kind of delete
 	 * is in effect on the receiving side when pulling. */
-	rprintf(FERROR_XFER, "FATAL I/O ERROR: dying to avoid a --delete-during issue with a pre-3.0.7 receiver.\n");
+	rprintf(FERROR_XFER, "FATAL I/O ERROR: dying to avoid a --delete-%s issue with a pre-3.0.7 receiver.\n",
+		delete_during == 2 ? "delay" : "during");
 	exit_cleanup(RERR_UNSUPPORTED);
 }
 
 static void send1extra(int f, struct file_struct *file, struct file_list *flist)
 {
 	char fbuf[MAXPATHLEN];
@@ -1850,13 +1932,15 @@
 			send_implied_dirs(f, flist, fbuf, fbuf+dlen+1, slash, flags, name_type);
 			continue;
 		}
 
 		if (name_type != NORMAL_NAME) {
 			STRUCT_STAT st;
-			if (link_stat(fbuf, &st, 1) != 0) {
+			if (name_type == MISSING_NAME)
+				memset(&st, 0, sizeof st);
+			else if (link_stat(fbuf, &st, 1) != 0) {
 				interpret_stat_error(fbuf, True);
 				continue;
 			}
 			send_file_name(f, flist, fbuf, &st, FLAG_TOP_DIR | flags, ALL_FILTERS);
 		} else
 			send_file_name(f, flist, fbuf, NULL, FLAG_TOP_DIR | flags, ALL_FILTERS);
@@ -1867,25 +1951,25 @@
 
 void send_extra_file_list(int f, int at_least)
 {
 	struct file_list *flist;
 	int64 start_write;
 	uint16 prev_flags;
-	int old_cnt, save_io_error = io_error;
+	int save_io_error = io_error;
 
 	if (flist_eof)
 		return;
 
+	if (at_least < 0)
+		at_least = file_total - file_old_total + 1;
+
 	/* Keep sending data until we have the requested number of
 	 * files in the upcoming file-lists. */
-	old_cnt = cur_flist->used;
-	for (flist = first_flist; flist != cur_flist; flist = flist->next)
-		old_cnt += flist->used;
-	while (file_total - old_cnt < at_least) {
+	while (file_total - file_old_total < at_least) {
 		struct file_struct *file = dir_flist->sorted[send_dir_ndx];
-		int dir_ndx, dstart = dir_count;
+		int dir_ndx, dstart = stats.num_dirs;
 		const char *pathname = F_PATHNAME(file);
 		int32 *dp;
 
 		flist = flist_new(0, "send_extra_file_list");
 		start_write = stats.total_written;
 
@@ -1933,42 +2017,44 @@
 			       flist->used * sizeof (struct file_struct*));
 		} else
 			flist->sorted = flist->files;
 
 		flist_sort_and_clean(flist, 0);
 
-		add_dirs_to_tree(send_dir_ndx, flist, dir_count - dstart);
+		add_dirs_to_tree(send_dir_ndx, flist, stats.num_dirs - dstart);
 		flist_done_allocating(flist);
 
 		file_total += flist->used;
 		stats.flist_size += stats.total_written - start_write;
 		stats.num_files += flist->used;
-		if (verbose > 3)
+		if (DEBUG_GTE(FLIST, 3))
 			output_flist(flist);
 
 		if (DIR_FIRST_CHILD(dp) >= 0) {
 			send_dir_ndx = DIR_FIRST_CHILD(dp);
 			send_dir_depth++;
 		} else {
 			while (DIR_NEXT_SIBLING(dp) < 0) {
 				if ((send_dir_ndx = DIR_PARENT(dp)) < 0) {
 					write_ndx(f, NDX_FLIST_EOF);
 					flist_eof = 1;
+					if (DEBUG_GTE(FLIST, 3))
+						rprintf(FINFO, "[%s] flist_eof=1\n", who_am_i());
 					change_local_filter_dir(NULL, 0, 0);
 					goto finish;
 				}
 				send_dir_depth--;
 				file = dir_flist->sorted[send_dir_ndx];
 				dp = F_DIR_NODE_P(file);
 			}
 			send_dir_ndx = DIR_NEXT_SIBLING(dp);
 		}
 	}
 
   finish:
-	if (io_error != save_io_error && !ignore_errors)
+	if (io_error != save_io_error && protocol_version == 30 && !ignore_errors)
 		send_msg_int(MSG_IO_ERROR, io_error);
 }
 
 struct file_list *send_file_list(int f, int argc, char *argv[])
 {
 	static const char *lastdir;
@@ -1977,26 +2063,26 @@
 	STRUCT_STAT st;
 	char *p, *dir;
 	struct file_list *flist;
 	struct timeval start_tv, end_tv;
 	int64 start_write;
 	int use_ff_fd = 0;
-	int disable_buffering;
+	int disable_buffering, reenable_multiplex = -1;
 	int flags = recurse ? FLAG_CONTENT_DIR : 0;
 	int reading_remotely = filesfrom_host != NULL;
 	int rl_flags = (reading_remotely ? 0 : RL_DUMP_COMMENTS)
 #ifdef ICONV_OPTION
 		     | (filesfrom_convert ? RL_CONVERT : 0)
 #endif
 		     | (eol_nulls || reading_remotely ? RL_EOL_NULLS : 0);
 	int implied_dot_dir = 0;
 
 	rprintf(FLOG, "building file list\n");
 	if (show_filelist_p())
 		start_filelist_progress("building file list");
-	else if (inc_recurse && verbose && !am_server)
+	else if (inc_recurse && INFO_GTE(FLIST, 1) && !am_server)
 		rprintf(FCLIENT, "sending incremental file list\n");
 
 	start_write = stats.total_written;
 	gettimeofday(&start_tv, NULL);
 
 	if (relative_paths && protocol_version >= 30)
@@ -2018,12 +2104,18 @@
 	if (filesfrom_fd >= 0) {
 		if (argv[0] && !change_dir(argv[0], CD_NORMAL)) {
 			rsyserr(FERROR_XFER, errno, "change_dir %s failed",
 				full_fname(argv[0]));
 			exit_cleanup(RERR_FILESELECT);
 		}
+		if (protocol_version < 31) {
+			/* Older protocols send the files-from data w/o packaging
+			 * it in multiplexed I/O packets, so temporarily switch
+			 * to buffered I/O to match this behavior. */
+			reenable_multiplex = io_end_multiplex_in(MPLX_TO_BUFFERED);
+		}
 		use_ff_fd = 1;
 	}
 
 	if (!orig_dir)
 		orig_dir = strdup(curr_dir);
 
@@ -2159,20 +2251,32 @@
 		if (fn != fbuf)
 			memmove(fbuf, fn, len + 1);
 
 		if (link_stat(fbuf, &st, copy_dirlinks || name_type != NORMAL_NAME) != 0
 		 || (name_type != DOTDIR_NAME && is_daemon_excluded(fbuf, S_ISDIR(st.st_mode)))
 		 || (relative_paths && path_is_daemon_excluded(fbuf, 1))) {
-			io_error |= IOERR_GENERAL;
-			rsyserr(FERROR_XFER, errno, "link_stat %s failed",
-				full_fname(fbuf));
-			continue;
+			if (errno != ENOENT || missing_args == 0) {
+				/* This is a transfer error, but inhibit deletion
+				 * only if we might be omitting an existing file. */
+				if (errno != ENOENT)
+					io_error |= IOERR_GENERAL;
+				rsyserr(FERROR_XFER, errno, "link_stat %s failed",
+					full_fname(fbuf));
+				continue;
+			} else if (missing_args == 1) {
+				/* Just ignore the arg. */
+				continue;
+			} else /* (missing_args == 2) */ {
+				/* Send the arg as a "missing" entry with
+				 * mode 0, which tells the generator to delete it. */
+				memset(&st, 0, sizeof st);
+			}
 		}
 
 		/* A dot-dir should not be excluded! */
-		if (name_type != DOTDIR_NAME
+		if (name_type != DOTDIR_NAME && st.st_mode != 0
 		 && is_excluded(fbuf, S_ISDIR(st.st_mode) != 0, ALL_FILTERS))
 			continue;
 
 		if (S_ISDIR(st.st_mode) && !xfer_dirs) {
 			rprintf(FINFO, "skipping directory %s\n", fbuf);
 			continue;
@@ -2182,13 +2286,14 @@
 			if ((p = strchr(fbuf+1, '/')) != NULL) {
 				if (p - fbuf == 1 && *fbuf == '.') {
 					if ((fn = strchr(p+1, '/')) != NULL)
 						p = fn;
 				} else
 					fn = p;
-				send_implied_dirs(f, flist, fbuf, fbuf, p, flags, name_type);
+				send_implied_dirs(f, flist, fbuf, fbuf, p, flags,
+						  st.st_mode == 0 ? MISSING_NAME : name_type);
 				if (fn == p)
 					continue;
 			}
 		} else if (implied_dirs && (p=strrchr(fbuf,'/')) && p != fbuf) {
 			/* Send the implied directories at the start of the
 			 * source spec, so we get their permissions right. */
@@ -2216,12 +2321,15 @@
 			} else
 				send_if_directory(f, flist, file, fbuf, len, flags);
 		} else
 			send_file_name(f, flist, fbuf, &st, flags, NO_FILTERS);
 	}
 
+	if (reenable_multiplex >= 0)
+		io_start_multiplex_in(reenable_multiplex);
+
 	gettimeofday(&end_tv, NULL);
 	stats.flist_buildtime = (int64)(end_tv.tv_sec - start_tv.tv_sec) * 1000
 			      + (end_tv.tv_usec - start_tv.tv_usec) / 1000;
 	if (stats.flist_buildtime == 0)
 		stats.flist_buildtime = 1;
 	start_tv = end_tv;
@@ -2264,70 +2372,79 @@
 		memcpy(flist->sorted, flist->files,
 		       flist->used * sizeof (struct file_struct*));
 	} else
 		flist->sorted = flist->files;
 	flist_sort_and_clean(flist, 0);
 	file_total += flist->used;
+	file_old_total += flist->used;
 
 	if (numeric_ids <= 0 && !inc_recurse)
 		send_id_list(f);
 
-	set_msg_fd_in(-1);
-
 	/* send the io_error flag */
 	if (protocol_version < 30)
 		write_int(f, ignore_errors ? 0 : io_error);
 	else if (!use_safe_inc_flist && io_error && !ignore_errors)
 		send_msg_int(MSG_IO_ERROR, io_error);
 
 	if (disable_buffering)
-		io_end_buffering_out();
+		io_end_buffering_out(IOBUF_FREE_BUFS);
 
 	stats.flist_size = stats.total_written - start_write;
 	stats.num_files = flist->used;
 
-	if (verbose > 3)
+	if (DEBUG_GTE(FLIST, 3))
 		output_flist(flist);
 
-	if (verbose > 2)
+	if (DEBUG_GTE(FLIST, 2))
 		rprintf(FINFO, "send_file_list done\n");
 
 	if (inc_recurse) {
 		send_dir_depth = 1;
-		add_dirs_to_tree(-1, flist, dir_count);
+		add_dirs_to_tree(-1, flist, stats.num_dirs);
 		if (!file_total || strcmp(flist->sorted[flist->low]->basename, ".") != 0)
 			flist->parent_ndx = -1;
 		flist_done_allocating(flist);
 		if (send_dir_ndx < 0) {
 			write_ndx(f, NDX_FLIST_EOF);
 			flist_eof = 1;
+			if (DEBUG_GTE(FLIST, 3))
+				rprintf(FINFO, "[%s] flist_eof=1\n", who_am_i());
 		}
 		else if (file_total == 1) {
 			/* If we're creating incremental file-lists and there
 			 * was just 1 item in the first file-list, send 1 more
 			 * file-list to check if this is a 1-file xfer. */
 			send_extra_file_list(f, 1);
 		}
+	} else {
+		flist_eof = 1;
+		if (DEBUG_GTE(FLIST, 3))
+			rprintf(FINFO, "[%s] flist_eof=1\n", who_am_i());
 	}
 
 	return flist;
 }
 
 struct file_list *recv_file_list(int f)
 {
 	struct file_list *flist;
 	int dstart, flags;
 	int64 start_read;
-	int save_verbose = verbose;
 
-	if (!first_flist)
+	if (!first_flist) {
+		if (show_filelist_p())
+			start_filelist_progress("receiving file list");
+		else if (inc_recurse && INFO_GTE(FLIST, 1) && !am_server)
+			rprintf(FCLIENT, "receiving incremental file list\n");
 		rprintf(FLOG, "receiving file list\n");
-	if (show_filelist_p())
-		start_filelist_progress("receiving file list");
-	else if (inc_recurse && verbose && !am_server && !first_flist)
-		rprintf(FCLIENT, "receiving incremental file list\n");
+		if (usermap)
+			parse_name_map(usermap, True);
+		if (groupmap)
+			parse_name_map(groupmap, False);
+	}
 
 	start_read = stats.total_read;
 
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && !first_flist)
 		init_hard_links();
@@ -2341,14 +2458,12 @@
 		dstart = dir_flist->used;
 	} else {
 		dir_flist = flist;
 		dstart = 0;
 	}
 
-	if (am_server && verbose > 2)
-		verbose = 2;
 	while ((flags = read_byte(f)) != 0) {
 		struct file_struct *file;
 
 		if (protocol_version >= 28 && (flags & XMIT_EXTENDED_FLAGS))
 			flags |= read_byte(f) << 8;
 
@@ -2364,30 +2479,39 @@
 			break;
 		}
 
 		flist_expand(flist, 1);
 		file = recv_file_entry(f, flist, flags);
 
-		if (inc_recurse && S_ISDIR(file->mode)) {
-			flist_expand(dir_flist, 1);
-			dir_flist->files[dir_flist->used++] = file;
-		}
+		if (S_ISREG(file->mode)) {
+			/* Already counted */
+		} else if (S_ISDIR(file->mode)) {
+			if (inc_recurse) {
+				flist_expand(dir_flist, 1);
+				dir_flist->files[dir_flist->used++] = file;
+			}
+			stats.num_dirs++;
+		} else if (S_ISLNK(file->mode))
+			stats.num_symlinks++;
+		else if (IS_DEVICE(file->mode))
+			stats.num_symlinks++;
+		else
+			stats.num_specials++;
 
 		flist->files[flist->used++] = file;
 
 		maybe_emit_filelist_progress(flist->used);
 
-		if (verbose > 2) {
+		if (DEBUG_GTE(FLIST, 2)) {
 			char *name = f_name(file, NULL);
 			rprintf(FINFO, "recv_file_name(%s)\n", NS(name));
 		}
 	}
 	file_total += flist->used;
-	verbose = save_verbose;
 
-	if (verbose > 2)
+	if (DEBUG_GTE(FLIST, 2))
 		rprintf(FINFO, "received %d names\n", flist->used);
 
 	if (show_filelist_p())
 		finish_filelist_progress(flist);
 
 	if (need_unsorted_flist) {
@@ -2419,32 +2543,35 @@
 			fsort(dir_flist->sorted + dstart, dir_flist->used - dstart);
 		}
 	}
 
 	if (inc_recurse)
 		flist_done_allocating(flist);
-	else if (f >= 0)
+	else if (f >= 0) {
 		recv_id_list(f, flist);
+		flist_eof = 1;
+		if (DEBUG_GTE(FLIST, 3))
+			rprintf(FINFO, "[%s] flist_eof=1\n", who_am_i());
+	}
 
 	flist_sort_and_clean(flist, relative_paths);
 
 	if (protocol_version < 30) {
 		/* Recv the io_error flag */
-		if (ignore_errors)
-			read_int(f);
-		else
-			io_error |= read_int(f);
+		int err = read_int(f);
+		if (!ignore_errors)
+			io_error |= err;
 	} else if (inc_recurse && flist->ndx_start == 1) {
 		if (!file_total || strcmp(flist->sorted[flist->low]->basename, ".") != 0)
 			flist->parent_ndx = -1;
 	}
 
-	if (verbose > 3)
+	if (DEBUG_GTE(FLIST, 3))
 		output_flist(flist);
 
-	if (verbose > 2)
+	if (DEBUG_GTE(FLIST, 2))
 		rprintf(FINFO, "recv_file_list done\n");
 
 	stats.flist_size += stats.total_read - start_read;
 	stats.num_files += flist->used;
 
 	return flist;
@@ -2455,24 +2582,26 @@
 void recv_additional_file_list(int f)
 {
 	struct file_list *flist;
 	int ndx = read_ndx(f);
 	if (ndx == NDX_FLIST_EOF) {
 		flist_eof = 1;
+		if (DEBUG_GTE(FLIST, 3))
+			rprintf(FINFO, "[%s] flist_eof=1\n", who_am_i());
 		change_local_filter_dir(NULL, 0, 0);
 	} else {
 		ndx = NDX_FLIST_OFFSET - ndx;
 		if (ndx < 0 || ndx >= dir_flist->used) {
 			ndx = NDX_FLIST_OFFSET - ndx;
 			rprintf(FERROR,
 				"[%s] Invalid dir index: %d (%d - %d)\n",
 				who_am_i(), ndx, NDX_FLIST_OFFSET,
 				NDX_FLIST_OFFSET - dir_flist->used + 1);
 			exit_cleanup(RERR_PROTOCOL);
 		}
-		if (verbose > 3) {
+		if (DEBUG_GTE(FLIST, 3)) {
 			rprintf(FINFO, "[%s] receiving flist for dir %d\n",
 				who_am_i(), ndx);
 		}
 		flist = recv_file_list(f);
 		flist->parent_ndx = ndx;
 	}
@@ -2573,20 +2702,22 @@
 
 	if (!(flist = new0(struct file_list)))
 		out_of_memory(msg);
 
 	if (flags & FLIST_TEMP) {
 		if (!(flist->file_pool = pool_create(SMALL_EXTENT, 0,
-						out_of_memory, POOL_INTERN)))
+						     out_of_memory,
+						     POOL_INTERN)))
 			out_of_memory(msg);
 	} else {
 		/* This is a doubly linked list with prev looping back to
 		 * the end of the list, but the last next pointer is NULL. */
 		if (!first_flist) {
 			flist->file_pool = pool_create(NORMAL_EXTENT, 0,
-						out_of_memory, POOL_INTERN);
+						       out_of_memory,
+						       POOL_INTERN);
 			if (!flist->file_pool)
 				out_of_memory(msg);
 
 			flist->ndx_start = flist->flist_num = inc_recurse ? 1 : 0;
 
 			first_flist = cur_flist = flist->prev = flist;
@@ -2710,13 +2841,13 @@
 					keep = j, drop = i;
 				}
 			} else
 				keep = j, drop = i;
 
 			if (!am_sender) {
-				if (verbose > 1) {
+				if (DEBUG_GTE(DUP, 1)) {
 					rprintf(FINFO,
 					    "removing duplicate name %s from file list (%d)\n",
 					    f_name(file, fbuf), drop + flist->ndx_start);
 				}
 				clear_file(flist->sorted[drop]);
 			}
@@ -2851,16 +2982,16 @@
 				slash = "/";
 			name = file->basename;
 			trail = S_ISDIR(file->mode) ? "/" : "";
 		} else
 			root = dir = slash = name = trail = "";
 		rprintf(FINFO,
-			"[%s] i=%d %s %s%s%s%s mode=0%o len=%.0f%s%s flags=%x\n",
+			"[%s] i=%d %s %s%s%s%s mode=0%o len=%s%s%s flags=%x\n",
 			who, i + flist->ndx_start,
 			root, dir, slash, name, trail,
-			(int)file->mode, (double)F_LENGTH(file),
+			(int)file->mode, comma_num(F_LENGTH(file)),
 			uidbuf, gidbuf, file->flags);
 	}
 }
 
 enum fnc_state { s_DIR, s_SLASH, s_BASE, s_TRAILING };
 enum fnc_type { t_PATH, t_ITEM };
@@ -3069,19 +3200,19 @@
 
 	recurse = 0;
 	xfer_dirs = 1;
 	send_directory(senddir_fd, dirlist, dirname, dlen, FLAG_CONTENT_DIR);
 	xfer_dirs = save_xfer_dirs;
 	recurse = save_recurse;
-	if (do_progress)
+	if (INFO_GTE(PROGRESS, 1))
 		flist_count_offset += dirlist->used;
 
 	prune_empty_dirs = 0;
 	dirlist->sorted = dirlist->files;
 	flist_sort_and_clean(dirlist, 0);
 	prune_empty_dirs = save_prune_empty_dirs;
 
-	if (verbose > 3)
+	if (DEBUG_GTE(FLIST, 3))
 		output_flist(dirlist);
 
 	return dirlist;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/generator.c	2011-09-11 04:38:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/generator.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * Routines that are exclusive to the generator process.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -18,23 +18,23 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "inums.h"
+#include "ifuncs.h"
 
-extern int verbose;
 extern int dry_run;
 extern int do_xfers;
 extern int stdout_format_has_i;
 extern int logfile_format_has_i;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
 extern int inc_recurse;
-extern int do_progress;
 extern int relative_paths;
 extern int implied_dirs;
 extern int keep_dirlinks;
 extern int preserve_acls;
 extern int preserve_xattrs;
 extern int preserve_links;
@@ -45,17 +45,19 @@
 extern int preserve_perms;
 extern int preserve_times;
 extern int delete_mode;
 extern int delete_before;
 extern int delete_during;
 extern int delete_after;
+extern int missing_args;
 extern int msgdone_cnt;
 extern int ignore_errors;
 extern int remove_source_files;
 extern int delay_updates;
 extern int update_only;
+extern int human_readable;
 extern int ignore_existing;
 extern int ignore_non_existing;
 extern int inplace;
 extern int append_mode;
 extern int make_backups;
 extern int csum_length;
@@ -64,261 +66,73 @@
 extern OFF_T max_size;
 extern OFF_T min_size;
 extern int io_error;
 extern int flist_eof;
 extern int allowed_lull;
 extern int sock_f_out;
-extern int ignore_timeout;
 extern int protocol_version;
 extern int file_total;
 extern int fuzzy_basis;
 extern int always_checksum;
 extern int checksum_len;
 extern char *partial_dir;
-extern char *basis_dir[MAX_BASIS_DIRS+1];
 extern int compare_dest;
 extern int copy_dest;
 extern int link_dest;
 extern int whole_file;
 extern int list_only;
 extern int read_batch;
+extern int write_batch;
 extern int safe_symlinks;
 extern long block_size; /* "long" because popt can't set an int32. */
 extern int unsort_ndx;
 extern int max_delete;
 extern int force_delete;
 extern int one_file_system;
-extern struct stats stats;
+extern int skipped_deletes;
 extern dev_t filesystem_dev;
 extern mode_t orig_umask;
 extern uid_t our_uid;
-extern char *backup_dir;
-extern char *backup_suffix;
-extern int backup_suffix_len;
+extern char *tmpdir;
+extern char *basis_dir[MAX_BASIS_DIRS+1];
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
-extern struct filter_list_struct daemon_filter_list;
+extern filter_rule_list filter_list, daemon_filter_list;
 
-int ignore_perishable = 0;
-int non_perishable_cnt = 0;
 int maybe_ATTRS_REPORT = 0;
 
 static dev_t dev_zero;
-static int deletion_count = 0; /* used to implement --max-delete */
 static int deldelay_size = 0, deldelay_cnt = 0;
 static char *deldelay_buf = NULL;
 static int deldelay_fd = -1;
 static int loopchk_limit;
 static int dir_tweaking;
 static int symlink_timeset_failed_flags;
 static int need_retouch_dir_times;
 static int need_retouch_dir_perms;
 static const char *solo_file = NULL;
 
-/* For calling delete_item() and delete_dir_contents(). */
-#define DEL_NO_UID_WRITE 	(1<<0) /* file/dir has our uid w/o write perm */
-#define DEL_RECURSE		(1<<1) /* if dir, delete all contents */
-#define DEL_DIR_IS_EMPTY	(1<<2) /* internal delete_FUNCTIONS use only */
-#define DEL_FOR_FILE		(1<<3) /* making room for a replacement file */
-#define DEL_FOR_DIR		(1<<4) /* making room for a replacement dir */
-#define DEL_FOR_SYMLINK 	(1<<5) /* making room for a replacement symlink */
-#define DEL_FOR_DEVICE		(1<<6) /* making room for a replacement device */
-#define DEL_FOR_SPECIAL 	(1<<7) /* making room for a replacement special */
-
-#define DEL_MAKE_ROOM (DEL_FOR_FILE|DEL_FOR_DIR|DEL_FOR_SYMLINK|DEL_FOR_DEVICE|DEL_FOR_SPECIAL)
-
 enum nonregtype {
     TYPE_DIR, TYPE_SPECIAL, TYPE_DEVICE, TYPE_SYMLINK
 };
 
-enum delret {
-    DR_SUCCESS = 0, DR_FAILURE, DR_AT_LIMIT, DR_NOT_EMPTY
-};
-
 /* Forward declarations. */
-static enum delret delete_dir_contents(char *fname, uint16 flags);
 #ifdef SUPPORT_HARD_LINKS
 static void handle_skipped_hlink(struct file_struct *file, int itemizing,
 				 enum logcode code, int f_out);
 #endif
 
-static int is_backup_file(char *fn)
-{
-	int k = strlen(fn) - backup_suffix_len;
-	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
-}
-
-/* Delete a file or directory.  If DEL_RECURSE is set in the flags, this will
- * delete recursively.
- *
- * Note that fbuf must point to a MAXPATHLEN buffer if the mode indicates it's
- * a directory! (The buffer is used for recursion, but returned unchanged.)
- */
-static enum delret delete_item(char *fbuf, uint16 mode, uint16 flags)
-{
-	enum delret ret;
-	char *what;
-	int ok;
-
-	if (verbose > 2) {
-		rprintf(FINFO, "delete_item(%s) mode=%o flags=%d\n",
-			fbuf, (int)mode, (int)flags);
-	}
-
-	if (flags & DEL_NO_UID_WRITE)
-		do_chmod(fbuf, mode | S_IWUSR);
-
-	if (S_ISDIR(mode) && !(flags & DEL_DIR_IS_EMPTY)) {
-		/* This only happens on the first call to delete_item() since
-		 * delete_dir_contents() always calls us w/DEL_DIR_IS_EMPTY. */
-		ignore_perishable = 1;
-		/* If DEL_RECURSE is not set, this just reports emptiness. */
-		ret = delete_dir_contents(fbuf, flags);
-		ignore_perishable = 0;
-		if (ret == DR_NOT_EMPTY || ret == DR_AT_LIMIT)
-			goto check_ret;
-		/* OK: try to delete the directory. */
-	}
-
-	if (!(flags & DEL_MAKE_ROOM) && max_delete >= 0 && ++deletion_count > max_delete)
-		return DR_AT_LIMIT;
-
-	if (S_ISDIR(mode)) {
-		what = "rmdir";
-		ok = do_rmdir(fbuf) == 0;
-	} else if (make_backups > 0 && (backup_dir || !is_backup_file(fbuf))) {
-		what = "make_backup";
-		ok = make_backup(fbuf);
-	} else {
-		what = "unlink";
-		ok = robust_unlink(fbuf) == 0;
-	}
-
-	if (ok) {
-		if (!(flags & DEL_MAKE_ROOM))
-			log_delete(fbuf, mode);
-		ret = DR_SUCCESS;
-	} else {
-		if (S_ISDIR(mode) && errno == ENOTEMPTY) {
-			rprintf(FINFO, "cannot delete non-empty directory: %s\n",
-				fbuf);
-			ret = DR_NOT_EMPTY;
-		} else if (errno != ENOENT) {
-			rsyserr(FERROR, errno, "delete_file: %s(%s) failed",
-				what, fbuf);
-			ret = DR_FAILURE;
-		} else {
-			deletion_count--;
-			ret = DR_SUCCESS;
-		}
-	}
-
-  check_ret:
-	if (ret != DR_SUCCESS && flags & DEL_MAKE_ROOM) {
-		const char *desc;
-		switch (flags & DEL_MAKE_ROOM) {
-		case DEL_FOR_FILE: desc = "regular file"; break;
-		case DEL_FOR_DIR: desc = "directory"; break;
-		case DEL_FOR_SYMLINK: desc = "symlink"; break;
-		case DEL_FOR_DEVICE: desc = "device file"; break;
-		case DEL_FOR_SPECIAL: desc = "special file"; break;
-		default: exit_cleanup(RERR_UNSUPPORTED); /* IMPOSSIBLE */
-		}
-		rprintf(FERROR_XFER, "could not make way for new %s: %s\n",
-			desc, fbuf);
-	}
-	return ret;
-}
-
-/* The directory is about to be deleted: if DEL_RECURSE is given, delete all
- * its contents, otherwise just checks for content.  Returns DR_SUCCESS or
- * DR_NOT_EMPTY.  Note that fname must point to a MAXPATHLEN buffer!  (The
- * buffer is used for recursion, but returned unchanged.)
- */
-static enum delret delete_dir_contents(char *fname, uint16 flags)
-{
-	struct file_list *dirlist;
-	enum delret ret;
-	unsigned remainder;
-	void *save_filters;
-	int j, dlen;
-	char *p;
-
-	if (verbose > 3) {
-		rprintf(FINFO, "delete_dir_contents(%s) flags=%d\n",
-			fname, flags);
-	}
-
-	dlen = strlen(fname);
-	save_filters = push_local_filters(fname, dlen);
-
-	non_perishable_cnt = 0;
-	dirlist = get_dirlist(fname, dlen, 0);
-	ret = non_perishable_cnt ? DR_NOT_EMPTY : DR_SUCCESS;
-
-	if (!dirlist->used)
-		goto done;
-
-	if (!(flags & DEL_RECURSE)) {
-		ret = DR_NOT_EMPTY;
-		goto done;
-	}
-
-	p = fname + dlen;
-	if (dlen != 1 || *fname != '/')
-		*p++ = '/';
-	remainder = MAXPATHLEN - (p - fname);
-
-	/* We do our own recursion, so make delete_item() non-recursive. */
-	flags = (flags & ~(DEL_RECURSE|DEL_MAKE_ROOM|DEL_NO_UID_WRITE))
-	      | DEL_DIR_IS_EMPTY;
-
-	for (j = dirlist->used; j--; ) {
-		struct file_struct *fp = dirlist->files[j];
-
-		if (fp->flags & FLAG_MOUNT_DIR && S_ISDIR(fp->mode)) {
-			if (verbose > 1) {
-				rprintf(FINFO,
-				    "mount point, %s, pins parent directory\n",
-				    f_name(fp, NULL));
-			}
-			ret = DR_NOT_EMPTY;
-			continue;
-		}
-
-		strlcpy(p, fp->basename, remainder);
-		if (!(fp->mode & S_IWUSR) && !am_root && fp->flags & FLAG_OWNED_BY_US)
-			do_chmod(fname, fp->mode | S_IWUSR);
-		/* Save stack by recursing to ourself directly. */
-		if (S_ISDIR(fp->mode)) {
-			if (delete_dir_contents(fname, flags | DEL_RECURSE) != DR_SUCCESS)
-				ret = DR_NOT_EMPTY;
-		}
-		if (delete_item(fname, fp->mode, flags) != DR_SUCCESS)
-			ret = DR_NOT_EMPTY;
-	}
-
-	fname[dlen] = '\0';
-
-  done:
-	flist_free(dirlist);
-	pop_local_filters(save_filters);
-
-	if (ret == DR_NOT_EMPTY) {
-		rprintf(FINFO, "cannot delete non-empty directory: %s\n",
-			fname);
-	}
-	return ret;
-}
+#define EARLY_DELAY_DONE_MSG() (!delay_updates)
+#define EARLY_DELETE_DONE_MSG() (!(delete_during == 2 || delete_after))
 
 static int start_delete_delay_temp(void)
 {
 	char fnametmp[MAXPATHLEN];
 	int save_dry_run = dry_run;
 
 	dry_run = 0;
-	if (!get_tmpname(fnametmp, "deldelay")
+	if (!get_tmpname(fnametmp, "deldelay", False)
 	 || (deldelay_fd = do_mkstemp(fnametmp, 0600)) < 0) {
 		rprintf(FINFO, "NOTE: Unable to create delete-delay temp file%s.\n",
 			inc_recurse ? "" : " -- switching to --delete-after");
 		delete_during = 0;
 		delete_after = !inc_recurse;
 		dry_run = save_dry_run;
@@ -466,19 +280,19 @@
 
 	if (!fbuf) {
 		change_local_filter_dir(NULL, 0, 0);
 		return;
 	}
 
-	if (verbose > 2)
+	if (DEBUG_GTE(DEL, 2))
 		rprintf(FINFO, "delete_in_dir(%s)\n", fbuf);
 
 	if (allowed_lull)
-		maybe_send_keepalive();
+		maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
 
-	if (io_error && !ignore_errors) {
+	if (io_error & IOERR_GENERAL && !ignore_errors) {
 		if (already_warned)
 			return;
 		rprintf(FINFO,
 			"IO error encountered -- skipping file deletion\n");
 		already_warned = 1;
 		return;
@@ -500,13 +314,13 @@
 	 * from the filesystem. */
 	for (i = dirlist->used; i--; ) {
 		struct file_struct *fp = dirlist->files[i];
 		if (!F_IS_ACTIVE(fp))
 			continue;
 		if (fp->flags & FLAG_MOUNT_DIR && S_ISDIR(fp->mode)) {
-			if (verbose > 1)
+			if (INFO_GTE(MOUNT, 1))
 				rprintf(FINFO, "cannot delete mount point: %s\n",
 					f_name(fp, NULL));
 			continue;
 		}
 		/* Here we want to match regardless of file type.  Replacement
 		 * of a file with one of another type is handled separately by
@@ -546,24 +360,24 @@
 
 		if (!(file->flags & FLAG_CONTENT_DIR)) {
 			change_local_filter_dir(fbuf, strlen(fbuf), F_DEPTH(file));
 			continue;
 		}
 
-		if (verbose > 1 && file->flags & FLAG_TOP_DIR)
+		if (DEBUG_GTE(DEL, 1) && file->flags & FLAG_TOP_DIR)
 			rprintf(FINFO, "deleting in %s\n", fbuf);
 
 		if (link_stat(fbuf, &st, keep_dirlinks) < 0
 		 || !S_ISDIR(st.st_mode))
 			continue;
 
 		delete_in_dir(fbuf, file, &st.st_dev);
 	}
 	delete_in_dir(NULL, NULL, &dev_zero);
 
-	if (do_progress && !am_server)
+	if (INFO_GTE(FLIST, 2) && !am_server)
 		rprintf(FINFO, "                    \r");
 }
 
 static inline int time_differs(struct file_struct *file, stat_x *sxp)
 {
 	return cmp_time(sxp->st.st_mtime, file->modtime);
@@ -720,32 +534,34 @@
 			iflags |= ITEM_REPORT_XATTR;
 #endif
 		iflags |= ITEM_IS_NEW;
 	}
 
 	iflags &= 0xffff;
-	if ((iflags & (SIGNIFICANT_ITEM_FLAGS|ITEM_REPORT_XATTR) || verbose > 1
+	if ((iflags & (SIGNIFICANT_ITEM_FLAGS|ITEM_REPORT_XATTR) || INFO_GTE(NAME, 2)
 	  || stdout_format_has_i > 1 || (xname && *xname)) && !read_batch) {
 		if (protocol_version >= 29) {
 			if (ndx >= 0)
 				write_ndx(sock_f_out, ndx);
 			write_shortint(sock_f_out, iflags);
 			if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
 				write_byte(sock_f_out, fnamecmp_type);
 			if (iflags & ITEM_XNAME_FOLLOWS)
 				write_vstring(sock_f_out, xname, strlen(xname));
 #ifdef SUPPORT_XATTRS
 			if (preserve_xattrs && do_xfers
 			 && iflags & (ITEM_REPORT_XATTR|ITEM_TRANSFER)) {
-				send_xattr_request(NULL, file,
-					iflags & ITEM_REPORT_XATTR ? sock_f_out : -1);
+				int fd = iflags & ITEM_REPORT_XATTR
+				      && (protocol_version < 31 || !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))
+				       ? sock_f_out : -1;
+				send_xattr_request(NULL, file, fd);
 			}
 #endif
 		} else if (ndx >= 0) {
 			enum logcode code = logfile_format_has_i ? FINFO : FCLIENT;
-			log_item(code, file, &stats, iflags, xname);
+			log_item(code, file, iflags, xname);
 		}
 	}
 }
 
 
 /* Perform our quick-check heuristic for determining if a file is unchanged. */
@@ -845,17 +661,17 @@
 	sum->remainder	= (int32)(len % blength);
 	sum->count	= (int32)(l = (len / blength) + (sum->remainder != 0));
 
 	if ((int64)sum->count != l)
 		sum->count = -1;
 
-	if (sum->count && verbose > 2) {
+	if (sum->count && DEBUG_GTE(DELTASUM, 2)) {
 		rprintf(FINFO,
-			"count=%.0f rem=%ld blength=%ld s2length=%d flength=%.0f\n",
-			(double)sum->count, (long)sum->remainder, (long)sum->blength,
-			sum->s2length, (double)sum->flength);
+			"count=%s rem=%ld blength=%ld s2length=%d flength=%s\n",
+			big_num(sum->count), (long)sum->remainder, (long)sum->blength,
+			sum->s2length, big_num(sum->flength));
 	}
 }
 
 
 /*
  * Generate and send a stream of signatures/checksums that describe a buffer
@@ -897,16 +713,16 @@
 				continue;
 		}
 
 		sum1 = get_checksum1(map, n1);
 		get_checksum2(map, n1, sum2);
 
-		if (verbose > 3) {
+		if (DEBUG_GTE(DELTASUM, 3)) {
 			rprintf(FINFO,
-				"chunk[%.0f] offset=%.0f len=%ld sum1=%08lx\n",
-				(double)i, (double)offset - n1, (long)n1,
+				"chunk[%s] offset=%s len=%ld sum1=%08lx\n",
+				big_num(i), big_num(offset - n1), (long)n1,
 				(unsigned long)sum1);
 		}
 		write_int(f_out, sum1);
 		write_buf(f_out, sum2, sum.s2length);
 	}
 
@@ -915,62 +731,81 @@
 
 	return 0;
 }
 
 
 /* Try to find a filename in the same dir as "fname" with a similar name. */
-static int find_fuzzy(struct file_struct *file, struct file_list *dirlist)
+static struct file_struct *find_fuzzy(struct file_struct *file, struct file_list *dirlist_array[], uchar *fnamecmp_type_ptr)
 {
 	int fname_len, fname_suf_len;
 	const char *fname_suf, *fname = file->basename;
 	uint32 lowest_dist = 25 << 16; /* ignore a distance greater than 25 */
-	int j, lowest_j = -1;
+	int i, j;
+	struct file_struct *lowest_fp = NULL;
 
 	fname_len = strlen(fname);
 	fname_suf = find_filename_suffix(fname, fname_len, &fname_suf_len);
 
-	for (j = 0; j < dirlist->used; j++) {
-		struct file_struct *fp = dirlist->files[j];
-		const char *suf, *name;
-		int len, suf_len;
-		uint32 dist;
+	/* Try to find an exact size+mtime match first. */
+	for (i = 0; i < fuzzy_basis; i++) {
+		struct file_list *dirlist = dirlist_array[i];
 
-		if (!S_ISREG(fp->mode) || !F_LENGTH(fp)
-		 || fp->flags & FLAG_FILE_SENT)
+		if (!dirlist)
 			continue;
 
-		name = fp->basename;
+		for (j = 0; j < dirlist->used; j++) {
+			struct file_struct *fp = dirlist->files[j];
 
-		if (F_LENGTH(fp) == F_LENGTH(file)
-		    && cmp_time(fp->modtime, file->modtime) == 0) {
-			if (verbose > 4) {
-				rprintf(FINFO,
-					"fuzzy size/modtime match for %s\n",
-					name);
+			if (!S_ISREG(fp->mode) || !F_LENGTH(fp) || fp->flags & FLAG_FILE_SENT)
+				continue;
+
+			if (F_LENGTH(fp) == F_LENGTH(file) && cmp_time(fp->modtime, file->modtime) == 0) {
+				if (DEBUG_GTE(FUZZY, 2))
+					rprintf(FINFO, "fuzzy size/modtime match for %s\n", f_name(fp, NULL));
+				*fnamecmp_type_ptr = FNAMECMP_FUZZY + i;
+				return fp;
 			}
-			return j;
+
 		}
+	}
 
-		len = strlen(name);
-		suf = find_filename_suffix(name, len, &suf_len);
+	for (i = 0; i < fuzzy_basis; i++) {
+		struct file_list *dirlist = dirlist_array[i];
 
-		dist = fuzzy_distance(name, len, fname, fname_len);
-		/* Add some extra weight to how well the suffixes match. */
-		dist += fuzzy_distance(suf, suf_len, fname_suf, fname_suf_len)
-		      * 10;
-		if (verbose > 4) {
-			rprintf(FINFO, "fuzzy distance for %s = %d.%05d\n",
-				name, (int)(dist>>16), (int)(dist&0xFFFF));
-		}
-		if (dist <= lowest_dist) {
-			lowest_dist = dist;
-			lowest_j = j;
+		if (!dirlist)
+			continue;
+
+		for (j = 0; j < dirlist->used; j++) {
+			struct file_struct *fp = dirlist->files[j];
+			const char *suf, *name;
+			int len, suf_len;
+			uint32 dist;
+
+			if (!S_ISREG(fp->mode) || !F_LENGTH(fp) || fp->flags & FLAG_FILE_SENT)
+				continue;
+
+			name = fp->basename;
+			len = strlen(name);
+			suf = find_filename_suffix(name, len, &suf_len);
+
+			dist = fuzzy_distance(name, len, fname, fname_len);
+			/* Add some extra weight to how well the suffixes match. */
+			dist += fuzzy_distance(suf, suf_len, fname_suf, fname_suf_len) * 10;
+			if (DEBUG_GTE(FUZZY, 2)) {
+				rprintf(FINFO, "fuzzy distance for %s = %d.%05d\n",
+					f_name(fp, NULL), (int)(dist>>16), (int)(dist&0xFFFF));
+			}
+			if (dist <= lowest_dist) {
+				lowest_dist = dist;
+				lowest_fp = fp;
+				*fnamecmp_type_ptr = FNAMECMP_FUZZY + i;
+			}
 		}
 	}
 
-	return lowest_j;
+	return lowest_fp;
 }
 
 /* Copy a file found in our --copy-dest handling. */
 static int copy_altdest_file(const char *src, const char *dest, struct file_struct *file)
 {
 	char buf[MAXPATHLEN];
@@ -986,14 +821,14 @@
 		fd_w = open_tmpfile(buf, dest, file);
 		if (fd_w < 0)
 			return -1;
 		copy_to = buf;
 	}
 	cleanup_set(copy_to, NULL, NULL, -1, -1);
-	if (copy_file(src, copy_to, fd_w, file->mode, 0) < 0) {
-		if (verbose) {
+	if (copy_file(src, copy_to, fd_w, file->mode) < 0) {
+		if (INFO_GTE(COPY, 1)) {
 			rsyserr(FINFO, errno, "copy_file %s => %s",
 				full_fname(src), copy_to);
 		}
 		/* Try to clean up. */
 		unlink(copy_to);
 		cleanup_disable();
@@ -1006,17 +841,21 @@
 	cleanup_disable();
 	return ok ? 0 : -1;
 }
 
 /* This is only called for regular files.  We return -2 if we've finished
  * handling the file, -1 if no dest-linking occurred, or a non-negative
- * value if we found an alternate basis file. */
+ * value if we found an alternate basis file.  If we're called with the
+ * find_exact_for_existing flag, the destination file already exists, so
+ * we only try to find an exact alt-dest match.  In this case, the returns
+ * are only -2 & -1 (both as above). */
 static int try_dests_reg(struct file_struct *file, char *fname, int ndx,
-			 char *cmpbuf, stat_x *sxp, int itemizing,
-			 enum logcode code)
+			 char *cmpbuf, stat_x *sxp, int find_exact_for_existing,
+			 int itemizing, enum logcode code)
 {
+	STRUCT_STAT real_st = sxp->st;
 	int best_match = -1;
 	int match_level = 0;
 	int j = 0;
 
 	do {
 		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
@@ -1031,14 +870,16 @@
 			if (!unchanged_file(cmpbuf, file, &sxp->st))
 				continue;
 			best_match = j;
 			match_level = 2;
 			/* FALL THROUGH */
 		case 2:
-			if (!unchanged_attrs(cmpbuf, file, sxp))
+			if (!unchanged_attrs(cmpbuf, file, sxp)) {
+				free_stat_x(sxp);
 				continue;
+			}
 			best_match = j;
 			match_level = 3;
 			break;
 		}
 		break;
 	} while (basis_dir[++j] != NULL);
@@ -1051,43 +892,61 @@
 		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
 		if (link_stat(cmpbuf, &sxp->st, 0) < 0)
 			return -1;
 	}
 
 	if (match_level == 3 && !copy_dest) {
+		if (find_exact_for_existing) {
+			if (link_dest && real_st.st_dev == sxp->st.st_dev && real_st.st_ino == sxp->st.st_ino)
+				return -1;
+			if (do_unlink(fname) < 0 && errno != ENOENT) {
+				sxp->st = real_st;
+				return -1;
+			}
+		}
 #ifdef SUPPORT_HARD_LINKS
 		if (link_dest) {
 			if (!hard_link_one(file, fname, cmpbuf, 1))
 				goto try_a_copy;
 			if (preserve_hard_links && F_IS_HLINKED(file))
 				finish_hard_link(file, fname, ndx, &sxp->st, itemizing, code, j);
-			if (!maybe_ATTRS_REPORT && (verbose > 1 || stdout_format_has_i > 1)) {
+			if (!maybe_ATTRS_REPORT && (INFO_GTE(NAME, 2) || stdout_format_has_i > 1)) {
 				itemize(cmpbuf, file, ndx, 1, sxp,
 					ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,
 					0, "");
 			}
 		} else
 #endif
-		if (itemizing)
-			itemize(cmpbuf, file, ndx, 0, sxp, 0, 0, NULL);
-		if (verbose > 1 && maybe_ATTRS_REPORT)
+		{
+			if (itemizing)
+				itemize(cmpbuf, file, ndx, 0, sxp, 0, 0, NULL);
+		}
+		if (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT)
 			rprintf(FCLIENT, "%s is uptodate\n", fname);
 		return -2;
 	}
 
+	if (find_exact_for_existing) {
+		sxp->st = real_st;
+		return -1;
+	}
+
 	if (match_level >= 2) {
 #ifdef SUPPORT_HARD_LINKS
 	  try_a_copy: /* Copy the file locally. */
 #endif
-		if (!dry_run && copy_altdest_file(cmpbuf, fname, file) < 0)
+		if (!dry_run && copy_altdest_file(cmpbuf, fname, file) < 0) {
+			if (find_exact_for_existing) /* Can get here via hard-link failure */
+				sxp->st = real_st;
 			return -1;
+		}
 		if (itemizing)
 			itemize(cmpbuf, file, ndx, 0, sxp, ITEM_LOCAL_CHANGE, 0, NULL);
 		if (maybe_ATTRS_REPORT
-		 && ((!itemizing && verbose && match_level == 2)
-		  || (verbose > 1 && match_level == 3))) {
+		 && ((!itemizing && INFO_GTE(NAME, 1) && match_level == 2)
+		  || (INFO_GTE(NAME, 2) && match_level == 3))) {
 			code = match_level == 3 ? FCLIENT : FINFO;
 			rprintf(code, "%s%s\n", fname,
 				match_level == 3 ? " is uptodate" : "");
 		}
 #ifdef SUPPORT_HARD_LINKS
 		if (preserve_hard_links && F_IS_HLINKED(file))
@@ -1103,18 +962,21 @@
  * handling the file, or -1 if no dest-linking occurred, or a non-negative
  * value if we found an alternate basis file. */
 static int try_dests_non(struct file_struct *file, char *fname, int ndx,
 			 char *cmpbuf, stat_x *sxp, int itemizing,
 			 enum logcode code)
 {
-	char lnk[MAXPATHLEN];
 	int best_match = -1;
 	int match_level = 0;
 	enum nonregtype type;
 	uint32 *devp;
-	int len, j = 0;
+#ifdef SUPPORT_LINKS
+	char lnk[MAXPATHLEN];
+	int len;
+#endif
+	int j = 0;
 
 #ifndef SUPPORT_LINKS
 	if (S_ISLNK(file->mode))
 		return -1;
 #endif
 	if (S_ISDIR(file->mode)) {
@@ -1148,17 +1010,19 @@
 				continue;
 			break;
 		case TYPE_DEVICE:
 			if (!IS_DEVICE(sxp->st.st_mode))
 				continue;
 			break;
-#ifdef SUPPORT_LINKS
 		case TYPE_SYMLINK:
+#ifdef SUPPORT_LINKS
 			if (!S_ISLNK(sxp->st.st_mode))
 				continue;
 			break;
+#else
+			return -1;
 #endif
 		}
 		if (match_level < 1) {
 			match_level = 1;
 			best_match = j;
 		}
@@ -1168,20 +1032,22 @@
 			break;
 		case TYPE_DEVICE:
 			devp = F_RDEV_P(file);
 			if (sxp->st.st_rdev != MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp)))
 				continue;
 			break;
-#ifdef SUPPORT_LINKS
 		case TYPE_SYMLINK:
-			if ((len = readlink(cmpbuf, lnk, MAXPATHLEN-1)) <= 0)
+#ifdef SUPPORT_LINKS
+			if ((len = do_readlink(cmpbuf, lnk, MAXPATHLEN-1)) <= 0)
 				continue;
 			lnk[len] = '\0';
 			if (strcmp(lnk, F_SYMLINK(file)) != 0)
 				continue;
 			break;
+#else
+			return -1;
 #endif
 		}
 		if (match_level < 2) {
 			match_level = 2;
 			best_match = j;
 		}
@@ -1221,32 +1087,33 @@
 			if (preserve_hard_links && F_IS_HLINKED(file))
 				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
 		} else
 #endif
 			match_level = 2;
 		if (itemizing && stdout_format_has_i
-		 && (verbose > 1 || stdout_format_has_i > 1)) {
+		 && (INFO_GTE(NAME, 2) || stdout_format_has_i > 1)) {
 			int chg = compare_dest && type != TYPE_DIR ? 0
 			    : ITEM_LOCAL_CHANGE + (match_level == 3 ? ITEM_XNAME_FOLLOWS : 0);
 			char *lp = match_level == 3 ? "" : NULL;
 			itemize(cmpbuf, file, ndx, 0, sxp, chg + ITEM_MATCHED, 0, lp);
 		}
-		if (verbose > 1 && maybe_ATTRS_REPORT) {
+		if (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT) {
 			rprintf(FCLIENT, "%s%s is uptodate\n",
 				fname, type == TYPE_DIR ? "/" : "");
 		}
 		return -2;
 	}
 
 	return j;
 }
 
 static void list_file_entry(struct file_struct *f)
 {
 	char permbuf[PERMSTRING_SIZE];
-	double len;
+	int64 len;
+	int colwidth = human_readable ? 14 : 11;
 
 	if (!F_IS_ACTIVE(f)) {
 		/* this can happen if duplicate names were removed */
 		return;
 	}
 
@@ -1254,21 +1121,26 @@
 	len = F_LENGTH(f);
 
 	/* TODO: indicate '+' if the entry has an ACL. */
 
 #ifdef SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(f->mode)) {
-		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
-			permbuf, len, timestring(f->modtime),
-			f_name(f, NULL), F_SYMLINK(f));
+		rprintf(FINFO, "%s %*s %s %s -> %s\n",
+			permbuf, colwidth, human_num(len),
+			timestring(f->modtime), f_name(f, NULL),
+			F_SYMLINK(f));
 	} else
 #endif
-	{
-		rprintf(FINFO, "%s %11.0f %s %s\n",
-			permbuf, len, timestring(f->modtime),
+	if (missing_args == 2 && f->mode == 0) {
+		rprintf(FINFO, "%-*s %s\n",
+			colwidth + 31, "*missing",
 			f_name(f, NULL));
+	} else {
+		rprintf(FINFO, "%s %*s %s %s\n",
+			permbuf, colwidth, human_num(len),
+			timestring(f->modtime), f_name(f, NULL));
 	}
 }
 
 static int phase = 0;
 static int dflt_perms;
 
@@ -1297,13 +1169,13 @@
 	static const char *parent_dirname = "";
 	/* Missing dir not created due to --dry-run; will still be scanned. */
 	static struct file_struct *dry_missing_dir = NULL;
 	/* Missing dir whose contents are skipped altogether due to
 	 * --ignore-non-existing, daemon exclude, or mkdir failure. */
 	static struct file_struct *skip_dir = NULL;
-	static struct file_list *fuzzy_dirlist = NULL;
+	static struct file_list *fuzzy_dirlist[MAX_BASIS_DIRS+1];
 	static int need_fuzzy_dirlist = 0;
 	struct file_struct *fuzzy_file = NULL;
 	int fd = -1, f_copy = -1;
 	stat_x sx, real_sx;
 	STRUCT_STAT partial_st;
 	struct file_struct *back_file = NULL;
@@ -1313,13 +1185,13 @@
 	uchar fnamecmp_type;
 	int del_opts = delete_mode || force_delete ? DEL_RECURSE : 0;
 	int is_dir = !S_ISDIR(file->mode) ? 0
 		   : inc_recurse && ndx != cur_flist->ndx_start - 1 ? -1
 		   : 1;
 
-	if (verbose > 2)
+	if (DEBUG_GTE(GENR, 1))
 		rprintf(FINFO, "recv_generator(%s,%d)\n", fname, ndx);
 
 	if (list_only) {
 		if (is_dir < 0
 		 || (is_dir && !implied_dirs && file->flags & FLAG_IMPLIED_DIR))
 			return;
@@ -1337,18 +1209,13 @@
 #endif
 			return;
 		}
 		skip_dir = NULL;
 	}
 
-#ifdef SUPPORT_ACLS
-	sx.acc_acl = sx.def_acl = NULL;
-#endif
-#ifdef SUPPORT_XATTRS
-	sx.xattr = NULL;
-#endif
+	init_stat_x(&sx);
 	if (daemon_filter_list.head && (*fname != '.' || fname[1])) {
 		if (check_filter(&daemon_filter_list, FLOG, fname, is_dir) < 0) {
 			if (is_dir < 0)
 				return;
 #ifdef SUPPORT_HARD_LINKS
 			if (F_IS_HLINKED(file))
@@ -1361,82 +1228,106 @@
 				goto skipping_dir_contents;
 			return;
 		}
 	}
 
 	if (dry_run > 1 || (dry_missing_dir && is_below(file, dry_missing_dir))) {
+		int i;
 	  parent_is_dry_missing:
-		if (fuzzy_dirlist) {
-			flist_free(fuzzy_dirlist);
-			fuzzy_dirlist = NULL;
+		for (i = 0; i < fuzzy_basis; i++) {
+			if (fuzzy_dirlist[i]) {
+				flist_free(fuzzy_dirlist[i]);
+				fuzzy_dirlist[i] = NULL;
+			}
 		}
 		parent_dirname = "";
 		statret = -1;
 		stat_errno = ENOENT;
 	} else {
 		const char *dn = file->dirname ? file->dirname : ".";
 		dry_missing_dir = NULL;
 		if (parent_dirname != dn && strcmp(parent_dirname, dn) != 0) {
 			if (relative_paths && !implied_dirs
 			 && do_stat(dn, &sx.st) < 0) {
 				if (dry_run)
 					goto parent_is_dry_missing;
-				if (create_directory_path(fname) < 0) {
+				if (make_path(fname, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0) {
 					rsyserr(FERROR_XFER, errno,
 						"recv_generator: mkdir %s failed",
 						full_fname(dn));
 				}
 			}
-			if (fuzzy_dirlist) {
-				flist_free(fuzzy_dirlist);
-				fuzzy_dirlist = NULL;
-			}
-			if (fuzzy_basis)
+			if (fuzzy_basis) {
+				int i;
+				for (i = 0; i < fuzzy_basis; i++) {
+					if (fuzzy_dirlist[i]) {
+						flist_free(fuzzy_dirlist[i]);
+						fuzzy_dirlist[i] = NULL;
+					}
+				}
 				need_fuzzy_dirlist = 1;
+			}
 #ifdef SUPPORT_ACLS
 			if (!preserve_perms)
 				dflt_perms = default_perms_for_dir(dn);
 #endif
 		}
 		parent_dirname = dn;
 
 		if (need_fuzzy_dirlist && S_ISREG(file->mode)) {
+			int i;
 			strlcpy(fnamecmpbuf, dn, sizeof fnamecmpbuf);
-			fuzzy_dirlist = get_dirlist(fnamecmpbuf, -1, GDL_IGNORE_FILTER_RULES);
+			for (i = 0; i < fuzzy_basis; i++) {
+				if (i && pathjoin(fnamecmpbuf, MAXPATHLEN, basis_dir[i-1], dn) >= MAXPATHLEN)
+					continue;
+				fuzzy_dirlist[i] = get_dirlist(fnamecmpbuf, -1, GDL_IGNORE_FILTER_RULES);
+				if (fuzzy_dirlist[i] && fuzzy_dirlist[i]->used == 0) {
+					flist_free(fuzzy_dirlist[i]);
+					fuzzy_dirlist[i] = NULL;
+				}
+			}
 			need_fuzzy_dirlist = 0;
 		}
 
 		statret = link_stat(fname, &sx.st, keep_dirlinks && is_dir);
 		stat_errno = errno;
 	}
 
+	if (missing_args == 2 && file->mode == 0) {
+		if (filter_list.head && check_filter(&filter_list, FINFO, fname, is_dir) < 0)
+			return;
+		if (statret == 0)
+			delete_item(fname, sx.st.st_mode, del_opts);
+		return;
+	}
+
 	if (ignore_non_existing > 0 && statret == -1 && stat_errno == ENOENT) {
 		if (is_dir) {
 			if (is_dir < 0)
 				return;
 			skip_dir = file;
 			file->flags |= FLAG_MISSING_DIR;
 		}
 #ifdef SUPPORT_HARD_LINKS
 		else if (F_IS_HLINKED(file))
 			handle_skipped_hlink(file, itemizing, code, f_out);
 #endif
-		if (verbose > 1) {
+		if (INFO_GTE(SKIP, 1)) {
 			rprintf(FINFO, "not creating new %s \"%s\"\n",
 				is_dir ? "directory" : "file", fname);
 		}
 		return;
 	}
 
 	if (statret == 0 && !(sx.st.st_mode & S_IWUSR)
 	 && !am_root && sx.st.st_uid == our_uid)
 		del_opts |= DEL_NO_UID_WRITE;
 
 	if (ignore_existing > 0 && statret == 0
 	 && (!is_dir || !S_ISDIR(sx.st.st_mode))) {
-		if (verbose > 1 && is_dir >= 0)
+		if (INFO_GTE(SKIP, 1) && is_dir >= 0)
 			rprintf(FINFO, "%s exists\n", fname);
 #ifdef SUPPORT_HARD_LINKS
 		if (F_IS_HLINKED(file))
 			handle_skipped_hlink(file, itemizing, code, f_out);
 #endif
 		goto cleanup;
@@ -1480,14 +1371,15 @@
 		}
 		if (dry_run && statret != 0) {
 			if (!dry_missing_dir)
 				dry_missing_dir = file;
 			file->flags |= FLAG_MISSING_DIR;
 		}
+		init_stat_x(&real_sx);
+		real_sx.st = sx.st;
 		real_ret = statret;
-		real_sx = sx;
 		if (file->flags & FLAG_DIR_CREATED)
 			statret = -1;
 		if (!preserve_perms) { /* See comment in non-dir code below. */
 			file->mode = dest_mode(file->mode, sx.st.st_mode,
 					       dflt_perms, statret == 0);
 		}
@@ -1506,13 +1398,13 @@
 		if (itemizing && f_out != -1) {
 			itemize(fnamecmp, file, ndx, statret, &sx,
 				statret ? ITEM_LOCAL_CHANGE : 0, 0, NULL);
 		}
 		if (real_ret != 0 && do_mkdir(fname,file->mode|added_perms) < 0 && errno != EEXIST) {
 			if (!relative_paths || errno != ENOENT
-			 || create_directory_path(fname) < 0
+			 || make_path(fname, MKP_DROP_NAME | MKP_SKIP_SLASH) < 0
 			 || (do_mkdir(fname, file->mode|added_perms) < 0 && errno != EEXIST)) {
 				rsyserr(FERROR_XFER, errno,
 					"recv_generator: mkdir %s failed",
 					full_fname(fname));
 			  skipping_dir_contents:
 				rprintf(FERROR,
@@ -1525,13 +1417,13 @@
 
 #ifdef SUPPORT_XATTRS
 		if (preserve_xattrs && statret == 1)
 			copy_xattrs(fnamecmpbuf, fname);
 #endif
 		if (set_file_attrs(fname, file, real_ret ? NULL : &real_sx, NULL, 0)
-		    && verbose && code != FNONE && f_out != -1)
+		    && INFO_GTE(NAME, 1) && code != FNONE && f_out != -1)
 			rprintf(code, "%s/\n", fname);
 
 		/* We need to ensure that the dirs in the transfer have both
 		 * readable and writable permissions during the time we are
 		 * putting files within them.  This is then restored to the
 		 * former permissions after the transfer is done. */
@@ -1581,13 +1473,13 @@
 #endif
 
 	if (preserve_links && S_ISLNK(file->mode)) {
 #ifdef SUPPORT_LINKS
 		const char *sl = F_SYMLINK(file);
 		if (safe_symlinks && unsafe_symlink(sl, fname)) {
-			if (verbose) {
+			if (INFO_GTE(NAME, 1)) {
 				if (solo_file) {
 					/* fname contains the destination path, but we
 					 * want to report the source path. */
 					fname = f_name(file, NULL);
 				}
 				rprintf(FINFO,
@@ -1597,32 +1489,27 @@
 			return;
 		}
 		if (statret == 0) {
 			char lnk[MAXPATHLEN];
 			int len;
 
-			if (!S_ISLNK(sx.st.st_mode))
-				statret = -1;
-			else if ((len = readlink(fname, lnk, MAXPATHLEN-1)) > 0
-			      && strncmp(lnk, sl, len) == 0 && sl[len] == '\0') {
+			if (S_ISLNK(sx.st.st_mode)
+			 && (len = do_readlink(fname, lnk, MAXPATHLEN-1)) > 0
+			 && strncmp(lnk, sl, len) == 0 && sl[len] == '\0') {
 				/* The link is pointing to the right place. */
 				set_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT);
 				if (itemizing)
 					itemize(fname, file, ndx, 0, &sx, 0, 0, NULL);
 #if defined SUPPORT_HARD_LINKS && defined CAN_HARDLINK_SYMLINK
 				if (preserve_hard_links && F_IS_HLINKED(file))
 					finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
 #endif
 				if (remove_source_files == 1)
 					goto return_with_success;
 				goto cleanup;
 			}
-			/* Not the right symlink (or not a symlink), so
-			 * delete it. */
-			if (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_SYMLINK) != 0)
-				goto cleanup;
 		} else if (basis_dir[0] != NULL) {
 			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx,
 					      itemizing, code);
 			if (j == -2) {
 #ifndef CAN_HARDLINK_SYMLINK
 				if (link_dest) {
@@ -1633,28 +1520,21 @@
 					goto cleanup;
 				itemizing = 0;
 				code = FNONE;
 			} else if (j >= 0)
 				statret = 1;
 		}
-#ifdef SUPPORT_HARD_LINKS
-		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
-			cur_flist->in_progress++;
-			goto cleanup;
-		}
-#endif
-		if (do_symlink(sl, fname) != 0) {
-			rsyserr(FERROR_XFER, errno, "symlink %s -> \"%s\" failed",
-				full_fname(fname), sl);
-		} else {
+		if (atomic_create(file, fname, sl, MAKEDEV(0, 0), &sx, statret == 0 ? DEL_FOR_SYMLINK : 0)) {
 			set_file_attrs(fname, file, NULL, NULL, 0);
 			if (itemizing) {
+				if (statret == 0 && !S_ISLNK(sx.st.st_mode))
+					statret = -1;
 				itemize(fname, file, ndx, statret, &sx,
 					ITEM_LOCAL_CHANGE|ITEM_REPORT_CHANGE, 0, NULL);
 			}
-			if (code != FNONE && verbose)
+			if (code != FNONE && INFO_GTE(NAME, 1))
 				rprintf(code, "%s -> %s\n", fname, sl);
 #ifdef SUPPORT_HARD_LINKS
 			if (preserve_hard_links && F_IS_HLINKED(file))
 				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
 #endif
 			/* This does not check remove_source_files == 1
@@ -1667,19 +1547,19 @@
 		goto cleanup;
 	}
 
 	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
 	 || (preserve_specials && IS_SPECIAL(file->mode))) {
 		dev_t rdev;
+		int del_for_flag = 0;
 		if (IS_DEVICE(file->mode)) {
 			uint32 *devp = F_RDEV_P(file);
 			rdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
 		} else
 			rdev = 0;
 		if (statret == 0) {
-			int del_for_flag;
 			if (IS_DEVICE(file->mode)) {
 				if (!IS_DEVICE(sx.st.st_mode))
 					statret = -1;
 				del_for_flag = DEL_FOR_DEVICE;
 			} else {
 				if (!IS_SPECIAL(sx.st.st_mode))
@@ -1698,14 +1578,12 @@
 					finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
 #endif
 				if (remove_source_files == 1)
 					goto return_with_success;
 				goto cleanup;
 			}
-			if (delete_item(fname, sx.st.st_mode, del_opts | del_for_flag) != 0)
-				goto cleanup;
 		} else if (basis_dir[0] != NULL) {
 			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx,
 					      itemizing, code);
 			if (j == -2) {
 #ifndef CAN_HARDLINK_SPECIAL
 				if (link_dest) {
@@ -1716,33 +1594,24 @@
 					goto cleanup;
 				itemizing = 0;
 				code = FNONE;
 			} else if (j >= 0)
 				statret = 1;
 		}
-#ifdef SUPPORT_HARD_LINKS
-		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
-			cur_flist->in_progress++;
-			goto cleanup;
-		}
-#endif
-		if (verbose > 2) {
+		if (DEBUG_GTE(GENR, 1)) {
 			rprintf(FINFO, "mknod(%s, 0%o, [%ld,%ld])\n",
 				fname, (int)file->mode,
 				(long)major(rdev), (long)minor(rdev));
 		}
-		if (do_mknod(fname, file->mode, rdev) < 0) {
-			rsyserr(FERROR_XFER, errno, "mknod %s failed",
-				full_fname(fname));
-		} else {
+		if (atomic_create(file, fname, NULL, rdev, &sx, del_for_flag)) {
 			set_file_attrs(fname, file, NULL, NULL, 0);
 			if (itemizing) {
 				itemize(fname, file, ndx, statret, &sx,
 					ITEM_LOCAL_CHANGE|ITEM_REPORT_CHANGE, 0, NULL);
 			}
-			if (code != FNONE && verbose)
+			if (code != FNONE && INFO_GTE(NAME, 1))
 				rprintf(code, "%s\n", fname);
 #ifdef SUPPORT_HARD_LINKS
 			if (preserve_hard_links && F_IS_HLINKED(file))
 				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
 #endif
 			if (remove_source_files == 1)
@@ -1755,32 +1624,32 @@
 		if (solo_file)
 			fname = f_name(file, NULL);
 		rprintf(FINFO, "skipping non-regular file \"%s\"\n", fname);
 		goto cleanup;
 	}
 
-	if (max_size > 0 && F_LENGTH(file) > max_size) {
-		if (verbose > 1) {
+	if (max_size >= 0 && F_LENGTH(file) > max_size) {
+		if (INFO_GTE(SKIP, 1)) {
 			if (solo_file)
 				fname = f_name(file, NULL);
 			rprintf(FINFO, "%s is over max-size\n", fname);
 		}
 		goto cleanup;
 	}
-	if (min_size > 0 && F_LENGTH(file) < min_size) {
-		if (verbose > 1) {
+	if (min_size >= 0 && F_LENGTH(file) < min_size) {
+		if (INFO_GTE(SKIP, 1)) {
 			if (solo_file)
 				fname = f_name(file, NULL);
 			rprintf(FINFO, "%s is under min-size\n", fname);
 		}
 		goto cleanup;
 	}
 
 	if (update_only > 0 && statret == 0
 	    && cmp_time(sx.st.st_mtime, file->modtime) > 0) {
-		if (verbose > 1)
+		if (INFO_GTE(SKIP, 1))
 			rprintf(FINFO, "%s is newer\n", fname);
 #ifdef SUPPORT_HARD_LINKS
 		if (F_IS_HLINKED(file))
 			handle_skipped_hlink(file, itemizing, code, f_out);
 #endif
 		goto cleanup;
@@ -1792,51 +1661,51 @@
 		if (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_FILE) != 0)
 			goto cleanup;
 		statret = -1;
 		stat_errno = ENOENT;
 	}
 
-	if (statret != 0 && basis_dir[0] != NULL) {
+	if (basis_dir[0] != NULL && (statret != 0 || !copy_dest)) {
 		int j = try_dests_reg(file, fname, ndx, fnamecmpbuf, &sx,
-				      itemizing, code);
+				      statret == 0, itemizing, code);
 		if (j == -2) {
 			if (remove_source_files == 1)
 				goto return_with_success;
 			goto cleanup;
 		}
 		if (j >= 0) {
 			fnamecmp = fnamecmpbuf;
 			fnamecmp_type = j;
 			statret = 0;
 		}
 	}
 
+	init_stat_x(&real_sx);
+	real_sx.st = sx.st; /* Don't copy xattr/acl pointers, as they would free wrong. */
 	real_ret = statret;
-	real_sx = sx;
 
 	if (partial_dir && (partialptr = partial_dir_fname(fname)) != NULL
 	    && link_stat(partialptr, &partial_st, 0) == 0
 	    && S_ISREG(partial_st.st_mode)) {
 		if (statret != 0)
 			goto prepare_to_open;
 	} else
 		partialptr = NULL;
 
-	if (statret != 0 && fuzzy_dirlist) {
-		int j = find_fuzzy(file, fuzzy_dirlist);
-		if (j >= 0) {
-			fuzzy_file = fuzzy_dirlist->files[j];
+	if (statret != 0 && fuzzy_basis) {
+		/* Sets fnamecmp_type to FNAMECMP_FUZZY or above. */
+		fuzzy_file = find_fuzzy(file, fuzzy_dirlist, &fnamecmp_type);
+		if (fuzzy_file) {
 			f_name(fuzzy_file, fnamecmpbuf);
-			if (verbose > 2) {
+			if (DEBUG_GTE(FUZZY, 1)) {
 				rprintf(FINFO, "fuzzy basis selected for %s: %s\n",
 					fname, fnamecmpbuf);
 			}
 			sx.st.st_size = F_LENGTH(fuzzy_file);
 			statret = 0;
 			fnamecmp = fnamecmpbuf;
-			fnamecmp_type = FNAMECMP_FUZZY;
 		}
 	}
 
 	if (statret != 0) {
 #ifdef SUPPORT_HARD_LINKS
 		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
@@ -1897,25 +1766,25 @@
 	if (read_batch || whole_file) {
 		if (inplace && make_backups > 0 && fnamecmp_type == FNAMECMP_FNAME) {
 			if (!(backupptr = get_backup_name(fname)))
 				goto cleanup;
 			if (!(back_file = make_file(fname, NULL, NULL, 0, NO_FILTERS)))
 				goto pretend_missing;
-			if (copy_file(fname, backupptr, -1, back_file->mode, 1) < 0) {
+			if (copy_file(fname, backupptr, -1, back_file->mode) < 0) {
 				unmake_file(back_file);
 				back_file = NULL;
 				goto cleanup;
 			}
 		}
 		goto notify_others;
 	}
 
-	if (fuzzy_dirlist) {
-		int j = flist_find(fuzzy_dirlist, file);
+	if (fuzzy_dirlist[0]) {
+		int j = flist_find(fuzzy_dirlist[0], file);
 		if (j >= 0) /* don't use changing file as future fuzzy basis */
-			fuzzy_dirlist->files[j]->flags |= FLAG_FILE_SENT;
+			fuzzy_dirlist[0]->files[j]->flags |= FLAG_FILE_SENT;
 	}
 
 	/* open the file */
 	if ((fd = do_open(fnamecmp, O_RDONLY, 0)) < 0) {
 		rsyserr(FERROR, errno, "failed to open %s, continuing",
 			full_fname(fnamecmp));
@@ -1946,66 +1815,50 @@
 			unmake_file(back_file);
 			back_file = NULL;
 			close(fd);
 			goto cleanup;
 		}
 		if ((f_copy = do_open(backupptr, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0600)) < 0) {
-			int save_errno = errno ? errno : EINVAL; /* 0 paranoia */
-			if (errno == ENOENT && make_bak_dir(backupptr) == 0) {
-				if ((f_copy = do_open(backupptr, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0600)) < 0)
-					save_errno = errno ? errno : save_errno;
-				else
-					save_errno = 0;
-			}
-			if (save_errno) {
-				rsyserr(FERROR_XFER, save_errno, "open %s", full_fname(backupptr));
-				unmake_file(back_file);
-				back_file = NULL;
-				close(fd);
-				goto cleanup;
-			}
+			rsyserr(FERROR_XFER, errno, "open %s", full_fname(backupptr));
+			unmake_file(back_file);
+			back_file = NULL;
+			close(fd);
+			goto cleanup;
 		}
 		fnamecmp_type = FNAMECMP_BACKUP;
 	}
 
-	if (verbose > 3) {
-		rprintf(FINFO, "gen mapped %s of size %.0f\n",
-			fnamecmp, (double)sx.st.st_size);
+	if (DEBUG_GTE(DELTASUM, 3)) {
+		rprintf(FINFO, "gen mapped %s of size %s\n",
+			fnamecmp, big_num(sx.st.st_size));
 	}
 
-	if (verbose > 2)
+	if (DEBUG_GTE(DELTASUM, 2))
 		rprintf(FINFO, "generating and sending sums for %d\n", ndx);
 
   notify_others:
 	if (remove_source_files && !delay_updates && !phase && !dry_run)
 		increment_active_files(ndx, itemizing, code);
-	if (inc_recurse && !dry_run)
+	if (inc_recurse && (!dry_run || write_batch < 0))
 		cur_flist->in_progress++;
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && F_IS_HLINKED(file))
 		file->flags |= FLAG_FILE_SENT;
 #endif
 	write_ndx(f_out, ndx);
 	if (itemizing) {
 		int iflags = ITEM_TRANSFER;
 		if (always_checksum > 0)
 			iflags |= ITEM_REPORT_CHANGE;
 		if (fnamecmp_type != FNAMECMP_FNAME)
 			iflags |= ITEM_BASIS_TYPE_FOLLOWS;
-		if (fnamecmp_type == FNAMECMP_FUZZY)
+		if (fnamecmp_type >= FNAMECMP_FUZZY)
 			iflags |= ITEM_XNAME_FOLLOWS;
 		itemize(fnamecmp, file, -1, real_ret, &real_sx, iflags, fnamecmp_type,
 			fuzzy_file ? fuzzy_file->basename : NULL);
-#ifdef SUPPORT_ACLS
-		if (preserve_acls)
-			free_acl(&real_sx);
-#endif
-#ifdef SUPPORT_XATTRS
-		if (preserve_xattrs)
-			free_xattr(&real_sx);
-#endif
+		free_stat_x(&real_sx);
 	}
 
 	if (!do_xfers) {
 #ifdef SUPPORT_HARD_LINKS
 		if (preserve_hard_links && F_IS_HLINKED(file))
 			finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
@@ -2040,28 +1893,88 @@
 			copy_xattrs(fname, backupptr);
 			preserve_xattrs = 0;
 		}
 #endif
 		set_file_attrs(backupptr, back_file, NULL, NULL, 0);
 		preserve_xattrs = save_preserve_xattrs;
-		if (verbose > 1) {
+		if (INFO_GTE(BACKUP, 1)) {
 			rprintf(FINFO, "backed up %s to %s\n",
 				fname, backupptr);
 		}
 		unmake_file(back_file);
 	}
 
-#ifdef SUPPORT_ACLS
-	if (preserve_acls)
-		free_acl(&sx);
+	free_stat_x(&sx);
+}
+
+/* If we are replacing an existing hard link, symlink, device, or special file,
+ * create a temp-name item and rename it into place.  Only a symlink or hard
+ * link puts a non-NULL value into the lnk arg.  Only a device puts a non-0
+ * value into the rdev arg.  Specify 0 for the del_for_flag if there is not a
+ * file to replace.  This returns 1 on success and 0 on failure. */
+int atomic_create(struct file_struct *file, char *fname, const char *lnk,
+		  dev_t rdev, stat_x *sxp, int del_for_flag)
+{
+	char tmpname[MAXPATHLEN];
+	const char *create_name;
+	int skip_atomic, dir_in_the_way = del_for_flag && S_ISDIR(sxp->st.st_mode);
+
+	if (!del_for_flag || dir_in_the_way || tmpdir || !get_tmpname(tmpname, fname, True))
+		skip_atomic = 1;
+	else
+		skip_atomic = 0;
+
+	if (del_for_flag) {
+		if (make_backups > 0 && !dir_in_the_way) {
+			if (!make_backup(fname, skip_atomic))
+				return 0;
+		} else if (skip_atomic) {
+			int del_opts = delete_mode || force_delete ? DEL_RECURSE : 0;
+			if (delete_item(fname, sxp->st.st_mode, del_opts | del_for_flag) != 0)
+				return 0;
+		}
+	}
+
+	create_name = skip_atomic ? fname : tmpname;
+
+	if (lnk) {
+#ifdef SUPPORT_LINKS
+		if (S_ISLNK(file->mode)
+#ifdef SUPPORT_HARD_LINKS /* The first symlink in a hard-linked cluster is always created. */
+		 && (!F_IS_HLINKED(file) || file->flags & FLAG_HLINK_FIRST)
+#endif
+		 ) {
+			if (do_symlink(lnk, create_name) < 0) {
+				rsyserr(FERROR_XFER, errno, "symlink %s -> \"%s\" failed",
+					full_fname(create_name), lnk);
+				return 0;
+			}
+		} else
 #endif
-#ifdef SUPPORT_XATTRS
-	if (preserve_xattrs)
-		free_xattr(&sx);
+#ifdef SUPPORT_HARD_LINKS
+		if (!hard_link_one(file, create_name, lnk, 0))
+			return 0;
 #endif
-	return;
+	} else {
+		if (do_mknod(create_name, file->mode, rdev) < 0) {
+			rsyserr(FERROR_XFER, errno, "mknod %s failed",
+				full_fname(create_name));
+			return 0;
+		}
+	}
+
+	if (!skip_atomic) {
+		if (do_rename(tmpname, fname) < 0) {
+			rsyserr(FERROR_XFER, errno, "rename %s -> \"%s\" failed",
+				full_fname(tmpname), full_fname(fname));
+			do_unlink(tmpname);
+			return 0;
+		}
+	}
+
+	return 1;
 }
 
 #ifdef SUPPORT_HARD_LINKS
 static void handle_skipped_hlink(struct file_struct *file, int itemizing,
 				 enum logcode code, int f_out)
 {
@@ -2101,13 +2014,13 @@
 	 * transfer and/or re-set any tweaked modified-time values. */
 	for (i = start; i <= end; i++, counter++) {
 		file = flist->files[i];
 		if (!S_ISDIR(file->mode)
 		 || (!implied_dirs && file->flags & FLAG_IMPLIED_DIR))
 			continue;
-		if (verbose > 3) {
+		if (DEBUG_GTE(TIME, 2)) {
 			fname = f_name(file, NULL);
 			rprintf(FINFO, "touch_up_dirs: %s (%d)\n",
 				NS(fname), i);
 		}
 		/* Be sure not to retouch permissions with --fake-super. */
 		fix_dir_perms = !am_root && !(file->mode & S_IWUSR);
@@ -2118,17 +2031,17 @@
 		if (fix_dir_perms)
 			do_chmod(fname, file->mode);
 		if (need_retouch_dir_times) {
 			STRUCT_STAT st;
 			if (link_stat(fname, &st, 0) == 0
 			 && cmp_time(st.st_mtime, file->modtime) != 0)
-				set_modtime(fname, file->modtime, file->mode);
+				set_modtime(fname, file->modtime, F_MOD_NSEC(file), file->mode);
 		}
 		if (counter >= loopchk_limit) {
 			if (allowed_lull)
-				maybe_send_keepalive();
+				maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
 			else
 				maybe_flush_socket(0);
 			counter = 0;
 		}
 	}
 }
@@ -2156,15 +2069,17 @@
 			flist->in_progress--;
 			continue;
 		}
 #endif
 
 		if (check_redo && (ndx = get_redo_num()) != -1) {
+			OFF_T save_max_size = max_size;
+			OFF_T save_min_size = min_size;
 			csum_length = SUM_LENGTH;
-			max_size = -max_size;
-			min_size = -min_size;
+			max_size = -1;
+			min_size = -1;
 			ignore_existing = -ignore_existing;
 			ignore_non_existing = -ignore_non_existing;
 			update_only = -update_only;
 			always_checksum = -always_checksum;
 			size_only = -size_only;
 			append_mode = -append_mode;
@@ -2182,14 +2097,14 @@
 			recv_generator(fbuf, file, ndx, itemizing, code, sock_f_out);
 			cur_flist->to_redo--;
 
 			cur_flist = flist;
 
 			csum_length = SHORT_SUM_LENGTH;
-			max_size = -max_size;
-			min_size = -min_size;
+			max_size = save_max_size;
+			min_size = save_min_size;
 			ignore_existing = -ignore_existing;
 			ignore_non_existing = -ignore_non_existing;
 			update_only = -update_only;
 			always_checksum = -always_checksum;
 			size_only = -size_only;
 			append_mode = -append_mode;
@@ -2203,14 +2118,18 @@
 
 		/* We only get here if inc_recurse is enabled. */
 		if (first_flist->in_progress || first_flist->to_redo)
 			break;
 
 		write_ndx(sock_f_out, NDX_DONE);
-		if (!read_batch)
-			maybe_flush_socket(1);
+		if (!read_batch && !flist_eof) {
+			int old_total = 0;
+			for (flist = first_flist; flist != cur_flist; flist = flist->next)
+				old_total += flist->used;
+			maybe_flush_socket(!flist_eof && file_total - old_total < MIN_FILECNT_LOOKAHEAD/2);
+		}
 
 		if (delete_during == 2 || !dir_tweaking) {
 			/* Skip directory touch-up. */
 		} else if (first_flist->parent_ndx >= 0)
 			touch_up_dirs(dir_flist, first_flist->parent_ndx);
 
@@ -2221,13 +2140,14 @@
 void generate_files(int f_out, const char *local_name)
 {
 	int i, ndx, next_loopchk = 0;
 	char fbuf[MAXPATHLEN];
 	int itemizing;
 	enum logcode code;
-	int save_do_progress = do_progress;
+	int save_info_flist = info_levels[INFO_FLIST];
+	int save_info_progress = info_levels[INFO_PROGRESS];
 
 	if (protocol_version >= 29) {
 		itemizing = 1;
 		maybe_ATTRS_REPORT = stdout_format_has_i ? 0 : ATTRS_REPORT;
 		code = logfile_format_has_i ? FNONE : FLOG;
 	} else if (am_daemon) {
@@ -2248,46 +2168,40 @@
 	need_retouch_dir_times = preserve_times & PRESERVE_DIR_TIMES;
 	loopchk_limit = allowed_lull ? allowed_lull * 5 : 200;
 	symlink_timeset_failed_flags = ITEM_REPORT_TIME
 	    | (protocol_version >= 30 || !am_server ? ITEM_REPORT_TIMEFAIL : 0);
 	implied_dirs_are_missing = relative_paths && !implied_dirs && protocol_version < 30;
 
-	if (verbose > 2)
-		rprintf(FINFO, "generator starting pid=%ld\n", (long)getpid());
+	if (DEBUG_GTE(GENR, 1))
+		rprintf(FINFO, "generator starting pid=%d\n", (int)getpid());
 
 	if (delete_before && !solo_file && cur_flist->used > 0)
 		do_delete_pass();
 	if (delete_during == 2) {
 		deldelay_size = BIGPATHBUFLEN * 4;
 		deldelay_buf = new_array(char, deldelay_size);
 		if (!deldelay_buf)
 			out_of_memory("delete-delay");
 	}
-	do_progress = 0;
+	info_levels[INFO_FLIST] = info_levels[INFO_PROGRESS] = 0;
 
 	if (append_mode > 0 || whole_file < 0)
 		whole_file = 0;
-	if (verbose >= 2) {
+	if (DEBUG_GTE(FLIST, 1)) {
 		rprintf(FINFO, "delta-transmission %s\n",
 			whole_file
 			? "disabled for local transfer or --whole-file"
 			: "enabled");
 	}
 
-	/* Since we often fill up the outgoing socket and then just sit around
-	 * waiting for the other 2 processes to do their thing, we don't want
-	 * to exit on a timeout.  If the data stops flowing, the receiver will
-	 * notice that and let us know via the message pipe (or its closing). */
-	ignore_timeout = 1;
-
 	dflt_perms = (ACCESSPERMS & ~orig_umask);
 
 	do {
 #ifdef SUPPORT_HARD_LINKS
 		if (preserve_hard_links && inc_recurse) {
-			while (!flist_eof && file_total < FILECNT_LOOKAHEAD/2)
+			while (!flist_eof && file_total < MIN_FILECNT_LOOKAHEAD/2)
 				wait_for_receiver();
 		}
 #endif
 
 		if (inc_recurse && cur_flist->parent_ndx >= 0) {
 			struct file_struct *fp = dir_flist->files[cur_flist->parent_ndx];
@@ -2329,13 +2243,13 @@
 			recv_generator(fbuf, file, ndx, itemizing, code, f_out);
 
 			check_for_finished_files(itemizing, code, 0);
 
 			if (i + cur_flist->ndx_start >= next_loopchk) {
 				if (allowed_lull)
-					maybe_send_keepalive();
+					maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
 				else
 					maybe_flush_socket(0);
 				next_loopchk += loopchk_limit;
 			}
 		}
 
@@ -2352,65 +2266,89 @@
 		}
 	} while ((cur_flist = cur_flist->next) != NULL);
 
 	if (delete_during)
 		delete_in_dir(NULL, NULL, &dev_zero);
 	phase++;
-	if (verbose > 2)
+	if (DEBUG_GTE(GENR, 1))
 		rprintf(FINFO, "generate_files phase=%d\n", phase);
 
 	while (1) {
 		check_for_finished_files(itemizing, code, 1);
 		if (msgdone_cnt)
 			break;
 		wait_for_receiver();
 	}
 
 	phase++;
-	if (verbose > 2)
+	if (DEBUG_GTE(GENR, 1))
 		rprintf(FINFO, "generate_files phase=%d\n", phase);
 
 	write_ndx(f_out, NDX_DONE);
 
 	/* Reduce round-trip lag-time for a useless delay-updates phase. */
-	if (protocol_version >= 29 && !delay_updates)
+	if (protocol_version >= 29 && EARLY_DELAY_DONE_MSG())
 		write_ndx(f_out, NDX_DONE);
 
+	if (protocol_version >= 31 && EARLY_DELETE_DONE_MSG()) {
+		if ((INFO_GTE(STATS, 2) && (delete_mode || force_delete)) || read_batch)
+			write_del_stats(f_out);
+		if (EARLY_DELAY_DONE_MSG()) /* Can't send this before delay */
+			write_ndx(f_out, NDX_DONE);
+	}
+
 	/* Read MSG_DONE for the redo phase (and any prior messages). */
 	while (1) {
 		check_for_finished_files(itemizing, code, 0);
 		if (msgdone_cnt > 1)
 			break;
 		wait_for_receiver();
 	}
 
 	if (protocol_version >= 29) {
 		phase++;
-		if (verbose > 2)
+		if (DEBUG_GTE(GENR, 1))
 			rprintf(FINFO, "generate_files phase=%d\n", phase);
-		if (delay_updates)
+		if (!EARLY_DELAY_DONE_MSG()) {
 			write_ndx(f_out, NDX_DONE);
+			if (protocol_version >= 31 && EARLY_DELETE_DONE_MSG())
+				write_ndx(f_out, NDX_DONE);
+		}
 		/* Read MSG_DONE for delay-updates phase & prior messages. */
 		while (msgdone_cnt == 2)
 			wait_for_receiver();
 	}
 
-	do_progress = save_do_progress;
+	info_levels[INFO_FLIST] = save_info_flist;
+	info_levels[INFO_PROGRESS] = save_info_progress;
+
 	if (delete_during == 2)
 		do_delayed_deletions(fbuf);
 	if (delete_after && !solo_file && file_total > 0)
 		do_delete_pass();
 
-	if ((need_retouch_dir_perms || need_retouch_dir_times)
-	 && dir_tweaking && (!inc_recurse || delete_during == 2))
-		touch_up_dirs(dir_flist, -1);
-
-	if (max_delete >= 0 && deletion_count > max_delete) {
+	if (max_delete >= 0 && skipped_deletes) {
 		rprintf(FWARNING,
 			"Deletions stopped due to --max-delete limit (%d skipped)\n",
-			deletion_count - max_delete);
+			skipped_deletes);
 		io_error |= IOERR_DEL_LIMIT;
 	}
 
-	if (verbose > 2)
+	if (protocol_version >= 31) {
+		if (!EARLY_DELETE_DONE_MSG()) {
+			if (INFO_GTE(STATS, 2) || read_batch)
+				write_del_stats(f_out);
+			write_ndx(f_out, NDX_DONE);
+		}
+
+		/* Read MSG_DONE for late-delete phase & prior messages. */
+		while (msgdone_cnt == 3)
+			wait_for_receiver();
+	}
+
+	if ((need_retouch_dir_perms || need_retouch_dir_times)
+	 && dir_tweaking && (!inc_recurse || delete_during == 2))
+		touch_up_dirs(dir_flist, -1);
+
+	if (DEBUG_GTE(GENR, 1))
 		rprintf(FINFO, "generate_files finished\n");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/getgroups.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/getgroups.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/getgroups.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/getgroups.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Print out the gids of all groups for the current user.  This is like
  * `id -G` on Linux, but it's too hard to find a portable equivalent.
  *
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003-2008 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 3 as
  * published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/.gitignore /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/.gitignore
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/.gitignore	2011-03-27 01:01:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/.gitignore	2013-06-16 07:40:10.000000000 +0800
@@ -20,17 +20,21 @@
 /confdefs.h
 /conftest*
 /dox
 /getgroups
 /gmon.out
 /rsync
+/rsync-ssl
+/stunnel-rsync
+/stunnel-rsyncd.conf
 /shconfig
 /testdir
 /tests-dont-exist
 /testtmp
 /tls
+/testrun
 /trimslash
 /t_unsafe
 /wildtest
 /getfsdev
 /rounding.h
 /doc/rsync.pdf
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/hashtable.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/hashtable.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/hashtable.c	2010-06-27 02:32:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/hashtable.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,10 +1,10 @@
 /*
  * Routines to provide a memory-efficient hashtable.
  *
- * Copyright (C) 2007-2009 Wayne Davison
+ * Copyright (C) 2007-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -20,19 +20,19 @@
 #include "rsync.h"
 
 #define HASH_LOAD_LIMIT(size) ((size)*3/4)
 
 struct hashtable *hashtable_create(int size, int key64)
 {
+	int req = size;
 	struct hashtable *tbl;
 	int node_size = key64 ? sizeof (struct ht_int64_node)
 			      : sizeof (struct ht_int32_node);
 
 	/* Pick a power of 2 that can hold the requested size. */
 	if (size & (size-1) || size < 16) {
-		int req = size;
 		size = 16;
 		while (size < req)
 			size *= 2;
 	}
 
 	if (!(tbl = new(struct hashtable))
@@ -40,17 +40,31 @@
 		out_of_memory("hashtable_create");
 	tbl->size = size;
 	tbl->entries = 0;
 	tbl->node_size = node_size;
 	tbl->key64 = key64 ? 1 : 0;
 
+	if (DEBUG_GTE(HASH, 1)) {
+		char buf[32];
+		if (req != size)
+			snprintf(buf, sizeof buf, "req: %d, ", req);
+		else
+			*buf = '\0';
+		rprintf(FINFO, "[%s] created hashtable %lx (%ssize: %d, keys: %d-bit)\n",
+			who_am_i(), (long)tbl, buf, size, key64 ? 64 : 32);
+	}
+
 	return tbl;
 }
 
 void hashtable_destroy(struct hashtable *tbl)
 {
+	if (DEBUG_GTE(HASH, 1)) {
+		rprintf(FINFO, "[%s] destroyed hashtable %lx (size: %d, keys: %d-bit)\n",
+			who_am_i(), (long)tbl, tbl->size, tbl->key64 ? 64 : 32);
+	}
 	free(tbl->nodes);
 	free(tbl);
 }
 
 /* This returns the node for the indicated key, either newly created or
  * already existing.  Returns NULL if not allocating and not found. */
@@ -72,12 +86,17 @@
 
 		if (!(tbl->nodes = new_array0(char, size * tbl->node_size)))
 			out_of_memory("hashtable_node");
 		tbl->size = size;
 		tbl->entries = 0;
 
+		if (DEBUG_GTE(HASH, 1)) {
+			rprintf(FINFO, "[%s] growing hashtable %lx (size: %d, keys: %d-bit)\n",
+				who_am_i(), (long)tbl, size, key64 ? 64 : 32);
+		}
+
 		for (i = size / 2; i-- > 0; ) {
 			struct ht_int32_node *move_node = HT_NODE(tbl, old_nodes, i);
 			int64 move_key = HT_KEY(move_node, key64);
 			if (move_key == 0)
 				continue;
 			node = hashtable_find(tbl, move_key, 1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/hlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/hlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/hlink.c	2010-07-01 00:17:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/hlink.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * Routines to support hard-linking.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2004-2009 Wayne Davison
+ * Copyright (C) 2004-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -18,23 +18,23 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "inums.h"
+#include "ifuncs.h"
 
-extern int verbose;
 extern int dry_run;
 extern int list_only;
 extern int am_sender;
 extern int inc_recurse;
 extern int do_xfers;
 extern int link_dest;
 extern int preserve_acls;
 extern int preserve_xattrs;
-extern int make_backups;
 extern int protocol_version;
 extern int remove_source_files;
 extern int stdout_format_has_i;
 extern int maybe_ATTRS_REPORT;
 extern int unsort_ndx;
 extern char *basis_dir[MAX_BASIS_DIRS+1];
@@ -68,14 +68,20 @@
 	struct hashtable *tbl;
 
 	/* Note that some OSes have a dev == 0, so increment to avoid storing a 0. */
 	if (!dev_node || dev_node->key != dev+1) {
 		/* We keep a separate hash table of inodes for every device. */
 		dev_node = hashtable_find(dev_tbl, dev+1, 1);
-		if (!(tbl = dev_node->data))
+		if (!(tbl = dev_node->data)) {
 			tbl = dev_node->data = hashtable_create(512, 1);
+			if (DEBUG_GTE(HLINK, 3)) {
+				rprintf(FINFO,
+				    "[%s] created hashtable for dev %s\n",
+				    who_am_i(), big_num(dev));
+			}
+		}
 	} else
 		tbl = dev_node->data;
 
 	return hashtable_find(tbl, ino, 1);
 }
 
@@ -203,49 +209,42 @@
 	}
 	if (protocol_version < 30)
 		idev_destroy();
 }
 
 static int maybe_hard_link(struct file_struct *file, int ndx,
-			   const char *fname, int statret, stat_x *sxp,
+			   char *fname, int statret, stat_x *sxp,
 			   const char *oldname, STRUCT_STAT *old_stp,
 			   const char *realname, int itemizing, enum logcode code)
 {
 	if (statret == 0) {
 		if (sxp->st.st_dev == old_stp->st_dev
 		 && sxp->st.st_ino == old_stp->st_ino) {
 			if (itemizing) {
 				itemize(fname, file, ndx, statret, sxp,
 					ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,
 					0, "");
 			}
-			if (verbose > 1 && maybe_ATTRS_REPORT)
+			if (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT)
 				rprintf(FCLIENT, "%s is uptodate\n", fname);
 			file->flags |= FLAG_HLINK_DONE;
 			return 0;
 		}
-		if (make_backups > 0) {
-			if (!make_backup(fname))
-				return -1;
-		} else if (robust_unlink(fname)) {
-			rsyserr(FERROR_XFER, errno, "unlink %s failed",
-				full_fname(fname));
-			return -1;
-		}
 	}
 
-	if (hard_link_one(file, fname, oldname, 0)) {
+	if (atomic_create(file, fname, oldname, MAKEDEV(0, 0), sxp, statret == 0 ? DEL_FOR_FILE : 0)) {
 		if (itemizing) {
 			itemize(fname, file, ndx, statret, sxp,
 				ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS, 0,
 				realname);
 		}
-		if (code != FNONE && verbose)
+		if (code != FNONE && INFO_GTE(NAME, 1))
 			rprintf(code, "%s => %s\n", fname, realname);
 		return 0;
 	}
+
 	return -1;
 }
 
 /* Figure out if a prior entry is still there or if we just have a
  * cached name for it. */
 static char *check_prior(struct file_struct *file, int gnum,
@@ -285,13 +284,13 @@
 	*flist_p = NULL;
 	return NULL;
 }
 
 /* Only called if FLAG_HLINKED is set and FLAG_HLINK_FIRST is not.  Returns:
  * 0 = process the file, 1 = skip the file, -1 = error occurred. */
-int hard_link_check(struct file_struct *file, int ndx, const char *fname,
+int hard_link_check(struct file_struct *file, int ndx, char *fname,
 		    int statret, stat_x *sxp, int itemizing,
 		    enum logcode code)
 {
 	STRUCT_STAT prev_st;
 	char namebuf[MAXPATHLEN], altbuf[MAXPATHLEN];
 	char *realname, *prev_name;
@@ -304,12 +303,16 @@
 	if (!prev_name) {
 		struct file_struct *prev_file;
 
 		if (!flist) {
 			/* The previous file was skipped, so this one is
 			 * treated as if it were the first in its group. */
+			if (DEBUG_GTE(HLINK, 2)) {
+				rprintf(FINFO, "hlink for %d (%s,%d): virtual first\n",
+					ndx, f_name(file, NULL), gnum);
+			}
 			return 0;
 		}
 
 		prev_file = flist->files[prev_ndx - flist->ndx_start];
 
 		/* Is the previous link not complete yet? */
@@ -320,32 +323,44 @@
 				 * be updated when the transfer completes, and
 				 * mark ourself as waiting for the transfer. */
 				F_HL_PREV(file) = F_HL_PREV(prev_file);
 				F_HL_PREV(prev_file) = ndx;
 				file->flags |= FLAG_FILE_SENT;
 				cur_flist->in_progress++;
+				if (DEBUG_GTE(HLINK, 2)) {
+					rprintf(FINFO, "hlink for %d (%s,%d): waiting for %d\n",
+						ndx, f_name(file, NULL), gnum, F_HL_PREV(file));
+				}
 				return 1;
 			}
+			if (DEBUG_GTE(HLINK, 2)) {
+				rprintf(FINFO, "hlink for %d (%s,%d): looking for a leader\n",
+					ndx, f_name(file, NULL), gnum);
+			}
 			return 0;
 		}
 
 		/* There is a finished file to link with! */
 		if (!(prev_file->flags & FLAG_HLINK_FIRST)) {
 			/* The previous previous is FIRST when prev is not. */
 			prev_name = realname = check_prior(prev_file, gnum, &prev_ndx, &flist);
-			assert(prev_name != NULL || flist != NULL);
 			/* Update our previous pointer to point to the FIRST. */
 			F_HL_PREV(file) = prev_ndx;
 		}
 
 		if (!prev_name) {
 			int alt_dest;
 
+			assert(flist != NULL);
 			prev_file = flist->files[prev_ndx - flist->ndx_start];
 			/* F_HL_PREV() is alt_dest value when DONE && FIRST. */
 			alt_dest = F_HL_PREV(prev_file);
+			if (DEBUG_GTE(HLINK, 2)) {
+				rprintf(FINFO, "hlink for %d (%s,%d): found flist match (alt %d)\n",
+					ndx, f_name(file, NULL), gnum, alt_dest);
+			}
 
 			if (alt_dest >= 0 && dry_run) {
 				pathjoin(namebuf, MAXPATHLEN, basis_dir[alt_dest],
 					 f_name(prev_file, NULL));
 				prev_name = namebuf;
 				realname = f_name(prev_file, altbuf);
@@ -353,12 +368,17 @@
 				prev_name = f_name(prev_file, namebuf);
 				realname = prev_name;
 			}
 		}
 	}
 
+	if (DEBUG_GTE(HLINK, 2)) {
+		rprintf(FINFO, "hlink for %d (%s,%d): leader is %d (%s)\n",
+			ndx, f_name(file, NULL), gnum, prev_ndx, prev_name);
+	}
+
 	if (link_stat(prev_name, &prev_st, 0) < 0) {
 		if (!dry_run || errno != ENOENT) {
 			rsyserr(FERROR_XFER, errno, "stat %s failed", full_fname(prev_name));
 			return -1;
 		}
 		/* A new hard-link will get a new dev & inode, so approximate
@@ -368,32 +388,27 @@
 
 	if (statret < 0 && basis_dir[0] != NULL) {
 		/* If we match an alt-dest item, we don't output this as a change. */
 		char cmpbuf[MAXPATHLEN];
 		stat_x alt_sx;
 		int j = 0;
-#ifdef SUPPORT_ACLS
-		alt_sx.acc_acl = alt_sx.def_acl = NULL;
-#endif
-#ifdef SUPPORT_XATTRS
-		alt_sx.xattr = NULL;
-#endif
+		init_stat_x(&alt_sx);
 		do {
 			pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
 			if (link_stat(cmpbuf, &alt_sx.st, 0) < 0)
 				continue;
 			if (link_dest) {
 				if (prev_st.st_dev != alt_sx.st.st_dev
 				 || prev_st.st_ino != alt_sx.st.st_ino)
 					continue;
 				statret = 1;
 				if (stdout_format_has_i == 0
-				 || (verbose < 2 && stdout_format_has_i < 2)) {
+				 || (!INFO_GTE(NAME, 2) && stdout_format_has_i < 2)) {
 					itemizing = 0;
 					code = FNONE;
-					if (verbose > 1 && maybe_ATTRS_REPORT)
+					if (INFO_GTE(NAME, 2) && maybe_ATTRS_REPORT)
 						rprintf(FCLIENT, "%s is uptodate\n", fname);
 				}
 				break;
 			}
 			if (!unchanged_file(cmpbuf, file, &alt_sx.st))
 				continue;
@@ -423,22 +438,14 @@
 				else {
 					sxp->xattr = alt_sx.xattr;
 					alt_sx.xattr = NULL;
 				}
 			}
 #endif
-		} else {
-#ifdef SUPPORT_ACLS
-			if (preserve_acls)
-				free_acl(&alt_sx);
-#endif
-#ifdef SUPPORT_XATTRS
-			if (preserve_xattrs)
-				free_xattr(&alt_sx);
-#endif
-		}
+		} else
+			free_stat_x(&alt_sx);
 	}
 
 	if (maybe_hard_link(file, ndx, fname, statret, sxp, prev_name, &prev_st,
 			    realname, itemizing, code) < 0)
 		return -1;
 
@@ -451,13 +458,13 @@
 int hard_link_one(struct file_struct *file, const char *fname,
 		  const char *oldname, int terse)
 {
 	if (do_link(oldname, fname) < 0) {
 		enum logcode code;
 		if (terse) {
-			if (!verbose)
+			if (!INFO_GTE(NAME, 1))
 				return 0;
 			code = FINFO;
 		} else
 			code = FERROR_XFER;
 		rsyserr(code, errno, "link %s => %s failed",
 			full_fname(fname), oldname);
@@ -478,13 +485,13 @@
 	char prev_name[MAXPATHLEN], alt_name[MAXPATHLEN];
 	const char *our_name;
 	struct file_list *flist;
 	int prev_statret, ndx, prev_ndx = F_HL_PREV(file);
 
 	if (stp == NULL && prev_ndx >= 0) {
-		if (link_stat(fname, &st, 0) < 0) {
+		if (link_stat(fname, &st, 0) < 0 && !dry_run) {
 			rsyserr(FERROR_XFER, errno, "stat %s failed",
 				full_fname(fname));
 			return;
 		}
 		stp = &st;
 	}
@@ -496,38 +503,26 @@
 		pathjoin(alt_name, MAXPATHLEN, basis_dir[alt_dest],
 			 f_name(file, NULL));
 		our_name = alt_name;
 	} else
 		our_name = fname;
 
-#ifdef SUPPORT_ACLS
-	prev_sx.acc_acl = prev_sx.def_acl = NULL;
-#endif
-#ifdef SUPPORT_XATTRS
-	prev_sx.xattr = NULL;
-#endif
+	init_stat_x(&prev_sx);
 
 	while ((ndx = prev_ndx) >= 0) {
 		int val;
 		flist = flist_for_ndx(ndx, "finish_hard_link");
 		file = flist->files[ndx - flist->ndx_start];
 		file->flags = (file->flags & ~FLAG_HLINK_FIRST) | FLAG_HLINK_DONE;
 		prev_ndx = F_HL_PREV(file);
 		F_HL_PREV(file) = fin_ndx;
 		prev_statret = link_stat(f_name(file, prev_name), &prev_sx.st, 0);
 		val = maybe_hard_link(file, ndx, prev_name, prev_statret, &prev_sx,
 				      our_name, stp, fname, itemizing, code);
 		flist->in_progress--;
-#ifdef SUPPORT_ACLS
-		if (preserve_acls)
-			free_acl(&prev_sx);
-#endif
-#ifdef SUPPORT_XATTRS
-		if (preserve_xattrs)
-			free_xattr(&prev_sx);
-#endif
+		free_stat_x(&prev_sx);
 		if (val < 0)
 			continue;
 		if (remove_source_files == 1 && do_xfers)
 			send_msg_int(MSG_SUCCESS, ndx);
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/ifuncs.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/ifuncs.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/ifuncs.h	2008-03-21 22:26:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/ifuncs.h	2013-05-20 06:01:29.000000000 +0800
@@ -1,9 +1,9 @@
 /* Inline functions for rsync.
  *
- * Copyright (C) 2007-2008 Wayne Davison
+ * Copyright (C) 2007-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -32,12 +32,20 @@
 	if (!bf)
 		out_of_memory("realloc_xbuf");
 	xb->buf = bf;
 	xb->size = sz;
 }
 
+static inline void
+free_xbuf(xbuf *xb)
+{
+	if (xb->buf)
+		free(xb->buf);
+	memset(xb, 0, sizeof (xbuf));
+}
+
 static inline int
 to_wire_mode(mode_t mode)
 {
 #ifdef SUPPORT_LINKS
 #if _S_IFLNK != 0120000
 	if (S_ISLNK(mode))
@@ -64,47 +72,35 @@
 	return (di->d_name - 2);
 #else
 	return di->d_name;
 #endif
 }
 
-static inline int
-isDigit(const char *ptr)
-{
-	return isdigit(*(unsigned char *)ptr);
-}
-
-static inline int
-isPrint(const char *ptr)
-{
-	return isprint(*(unsigned char *)ptr);
-}
-
-static inline int
-isSpace(const char *ptr)
-{
-	return isspace(*(unsigned char *)ptr);
-}
-
-static inline int
-isLower(const char *ptr)
-{
-	return islower(*(unsigned char *)ptr);
-}
-
-static inline int
-isUpper(const char *ptr)
-{
-	return isupper(*(unsigned char *)ptr);
-}
-
-static inline int
-toLower(const char *ptr)
+static inline void
+init_stat_x(stat_x *sx_p)
 {
-	return tolower(*(unsigned char *)ptr);
+#ifdef SUPPORT_ACLS
+	sx_p->acc_acl = sx_p->def_acl = NULL;
+#endif
+#ifdef SUPPORT_XATTRS
+	sx_p->xattr = NULL;
+#endif
 }
 
-static inline int
-toUpper(const char *ptr)
+static inline void
+free_stat_x(stat_x *sx_p)
 {
-	return toupper(*(unsigned char *)ptr);
+#ifdef SUPPORT_ACLS
+    {
+	extern int preserve_acls;
+	if (preserve_acls)
+		free_acl(sx_p);
+    }
+#endif
+#ifdef SUPPORT_XATTRS
+    {
+	extern int preserve_xattrs;
+	if (preserve_xattrs)
+		free_xattr(sx_p);
+    }
+#endif
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0: inums.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/io.c	2011-09-23 14:33:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/io.c	2013-05-29 03:59:47.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * Socket and pipe I/O utilities used in rsync.
  *
  * Copyright (C) 1996-2001 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -26,146 +26,1024 @@
  * For historical reasons this is off during the start of the
  * connection, but it's switched on quite early using
  * io_start_multiplex_out() and io_start_multiplex_in(). */
 
 #include "rsync.h"
 #include "ifuncs.h"
+#include "inums.h"
 
 /** If no timeout is specified then use a 60 second select timeout */
 #define SELECT_TIMEOUT 60
 
 extern int bwlimit;
 extern size_t bwlimit_writemax;
 extern int io_timeout;
 extern int am_server;
-extern int am_daemon;
 extern int am_sender;
+extern int am_receiver;
 extern int am_generator;
+extern int msgs2stderr;
 extern int inc_recurse;
 extern int io_error;
 extern int eol_nulls;
 extern int flist_eof;
+extern int file_total;
+extern int file_old_total;
 extern int list_only;
 extern int read_batch;
 extern int compat_flags;
 extern int protect_args;
 extern int checksum_seed;
 extern int protocol_version;
 extern int remove_source_files;
 extern int preserve_hard_links;
+extern BOOL extra_flist_sending_enabled;
+extern BOOL flush_ok_after_signal;
 extern struct stats stats;
 extern struct file_list *cur_flist;
 #ifdef ICONV_OPTION
 extern int filesfrom_convert;
 extern iconv_t ic_send, ic_recv;
 #endif
 
 int csum_length = SHORT_SUM_LENGTH; /* initial value */
 int allowed_lull = 0;
-int ignore_timeout = 0;
 int batch_fd = -1;
 int msgdone_cnt = 0;
+int forward_flist_data = 0;
+BOOL flist_receiving_enabled = False;
 
 /* Ignore an EOF error if non-zero. See whine_about_eof(). */
 int kluge_around_eof = 0;
+int got_kill_signal = -1; /* is set to 0 only after multiplexed I/O starts */
 
-int msg_fd_in = -1;
-int msg_fd_out = -1;
 int sock_f_in = -1;
 int sock_f_out = -1;
 
-static int iobuf_f_in = -1;
-static char *iobuf_in;
-static size_t iobuf_in_siz;
-static size_t iobuf_in_ndx;
-static size_t iobuf_in_remaining;
-
-static int iobuf_f_out = -1;
-static char *iobuf_out;
-static int iobuf_out_cnt;
+int64 total_data_read = 0;
+int64 total_data_written = 0;
 
-int flist_forward_from = -1;
+static struct {
+	xbuf in, out, msg;
+	int in_fd;
+	int out_fd; /* Both "out" and "msg" go to this fd. */
+	int in_multiplexed;
+	unsigned out_empty_len;
+	size_t raw_data_header_pos;      /* in the out xbuf */
+	size_t raw_flushing_ends_before; /* in the out xbuf */
+	size_t raw_input_ends_before;    /* in the in xbuf */
+} iobuf = { .in_fd = -1, .out_fd = -1 };
 
-static int io_multiplexing_out;
-static int io_multiplexing_in;
 static time_t last_io_in;
 static time_t last_io_out;
-static int no_flush;
 
 static int write_batch_monitor_in = -1;
 static int write_batch_monitor_out = -1;
 
-static int io_filesfrom_f_in = -1;
-static int io_filesfrom_f_out = -1;
-static xbuf ff_buf = EMPTY_XBUF;
-static char ff_lastchar;
+static int ff_forward_fd = -1;
+static int ff_reenable_multiplex = -1;
+static char ff_lastchar = '\0';
+static xbuf ff_xb = EMPTY_XBUF;
 #ifdef ICONV_OPTION
 static xbuf iconv_buf = EMPTY_XBUF;
 #endif
-static int defer_forwarding_messages = 0, keep_defer_forwarding = 0;
 static int select_timeout = SELECT_TIMEOUT;
 static int active_filecnt = 0;
 static OFF_T active_bytecnt = 0;
 static int first_message = 1;
 
 static char int_byte_extra[64] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* (00 - 3F)/4 */
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* (40 - 7F)/4 */
 	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* (80 - BF)/4 */
 	2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, /* (C0 - FF)/4 */
 };
 
+/* Our I/O buffers are sized with no bits on in the lowest byte of the "size"
+ * (indeed, our rounding of sizes in 1024-byte units assures more than this).
+ * This allows the code that is storing bytes near the physical end of a
+ * circular buffer to temporarily reduce the buffer's size (in order to make
+ * some storing idioms easier), while also making it simple to restore the
+ * buffer's actual size when the buffer's "pos" wraps around to the start (we
+ * just round the buffer's size up again). */
+
+#define IOBUF_WAS_REDUCED(siz) ((siz) & 0xFF)
+#define IOBUF_RESTORE_SIZE(siz) (((siz) | 0xFF) + 1)
+
+#define IN_MULTIPLEXED (iobuf.in_multiplexed != 0)
+#define IN_MULTIPLEXED_AND_READY (iobuf.in_multiplexed > 0)
+#define OUT_MULTIPLEXED (iobuf.out_empty_len != 0)
+
+#define PIO_NEED_INPUT (1<<0) /* The *_NEED_* flags are mutually exclusive. */
+#define PIO_NEED_OUTROOM (1<<1)
+#define PIO_NEED_MSGROOM (1<<2)
+
+#define PIO_CONSUME_INPUT (1<<4) /* Must becombined with PIO_NEED_INPUT. */
+
+#define PIO_INPUT_AND_CONSUME (PIO_NEED_INPUT | PIO_CONSUME_INPUT)
+#define PIO_NEED_FLAGS (PIO_NEED_INPUT | PIO_NEED_OUTROOM | PIO_NEED_MSGROOM)
+
 #define REMOTE_OPTION_ERROR "rsync: on remote machine: -"
 #define REMOTE_OPTION_ERROR2 ": unknown option"
 
+#define FILESFROM_BUFLEN 2048
+
 enum festatus { FES_SUCCESS, FES_REDO, FES_NO_SEND };
 
-static void check_timeout(void)
+static flist_ndx_list redo_list, hlink_list;
+
+static void read_a_msg(void);
+static void drain_multiplex_messages(void);
+static void sleep_for_bwlimit(int bytes_written);
+
+static void check_timeout(BOOL allow_keepalive)
+{
+	time_t t, chk;
+
+	/* On the receiving side, the generator is now the one that decides
+	 * when a timeout has occurred.  When it is sifting through a lot of
+	 * files looking for work, it will be sending keep-alive messages to
+	 * the sender, and even though the receiver won't be sending/receiving
+	 * anything (not even keep-alive messages), the successful writes to
+	 * the sender will keep things going.  If the receiver is actively
+	 * receiving data, it will ensure that the generator knows that it is
+	 * not idle by sending the generator keep-alive messages (since the
+	 * generator might be blocked trying to send checksums, it needs to
+	 * know that the receiver is active).  Thus, as long as one or the
+	 * other is successfully doing work, the generator will not timeout. */
+	if (!io_timeout)
+		return;
+
+	t = time(NULL);
+
+	if (allow_keepalive) {
+		/* This may put data into iobuf.msg w/o flushing. */
+		maybe_send_keepalive(t, 0);
+	}
+
+	if (!last_io_in)
+		last_io_in = t;
+
+	if (am_receiver)
+		return;
+
+	chk = MAX(last_io_out, last_io_in);
+	if (t - chk >= io_timeout) {
+		if (am_server)
+			msgs2stderr = 1;
+		rprintf(FERROR, "[%s] io timeout after %d seconds -- exiting\n",
+			who_am_i(), (int)(t-chk));
+		exit_cleanup(RERR_TIMEOUT);
+	}
+}
+
+/* It's almost always an error to get an EOF when we're trying to read from the
+ * network, because the protocol is (for the most part) self-terminating.
+ *
+ * There is one case for the receiver when it is at the end of the transfer
+ * (hanging around reading any keep-alive packets that might come its way): if
+ * the sender dies before the generator's kill-signal comes through, we can end
+ * up here needing to loop until the kill-signal arrives.  In this situation,
+ * kluge_around_eof will be < 0.
+ *
+ * There is another case for older protocol versions (< 24) where the module
+ * listing was not terminated, so we must ignore an EOF error in that case and
+ * exit.  In this situation, kluge_around_eof will be > 0. */
+static NORETURN void whine_about_eof(BOOL allow_kluge)
+{
+	if (kluge_around_eof && allow_kluge) {
+		int i;
+		if (kluge_around_eof > 0)
+			exit_cleanup(0);
+		/* If we're still here after 10 seconds, exit with an error. */
+		for (i = 10*1000/20; i--; )
+			msleep(20);
+	}
+
+	rprintf(FERROR, RSYNC_NAME ": connection unexpectedly closed "
+		"(%s bytes received so far) [%s]\n",
+		big_num(stats.total_read), who_am_i());
+
+	exit_cleanup(RERR_STREAMIO);
+}
+
+/* Do a safe read, handling any needed looping and error handling.
+ * Returns the count of the bytes read, which will only be different
+ * from "len" if we encountered an EOF.  This routine is not used on
+ * the socket except very early in the transfer. */
+static size_t safe_read(int fd, char *buf, size_t len)
+{
+	size_t got;
+	int n;
+
+	assert(fd != iobuf.in_fd);
+
+	n = read(fd, buf, len);
+	if ((size_t)n == len || n == 0) {
+		if (DEBUG_GTE(IO, 2))
+			rprintf(FINFO, "[%s] safe_read(%d)=%ld\n", who_am_i(), fd, (long)n);
+		return n;
+	}
+	if (n < 0) {
+		if (errno != EINTR && errno != EWOULDBLOCK && errno != EAGAIN) {
+		  read_failed:
+			rsyserr(FERROR, errno, "safe_read failed to read %ld bytes [%s]",
+				(long)len, who_am_i());
+			exit_cleanup(RERR_STREAMIO);
+		}
+		got = 0;
+	} else
+		got = n;
+
+	while (1) {
+		struct timeval tv;
+		fd_set r_fds, e_fds;
+		int cnt;
+
+		FD_ZERO(&r_fds);
+		FD_SET(fd, &r_fds);
+		FD_ZERO(&e_fds);
+		FD_SET(fd, &e_fds);
+		tv.tv_sec = select_timeout;
+		tv.tv_usec = 0;
+
+		cnt = select(fd+1, &r_fds, NULL, &e_fds, &tv);
+		if (cnt <= 0) {
+			if (cnt < 0 && errno == EBADF) {
+				rsyserr(FERROR, errno, "safe_read select failed [%s]",
+					who_am_i());
+				exit_cleanup(RERR_FILEIO);
+			}
+			if (io_timeout)
+				maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
+			continue;
+		}
+
+		/*if (FD_ISSET(fd, &e_fds))
+			rprintf(FINFO, "select exception on fd %d\n", fd); */
+
+		if (FD_ISSET(fd, &r_fds)) {
+			n = read(fd, buf + got, len - got);
+			if (DEBUG_GTE(IO, 2))
+				rprintf(FINFO, "[%s] safe_read(%d)=%ld\n", who_am_i(), fd, (long)n);
+			if (n == 0)
+				break;
+			if (n < 0) {
+				if (errno == EINTR)
+					continue;
+				goto read_failed;
+			}
+			if ((got += (size_t)n) == len)
+				break;
+		}
+	}
+
+	return got;
+}
+
+static const char *what_fd_is(int fd)
+{
+	static char buf[20];
+
+	if (fd == sock_f_out)
+		return "socket";
+	else if (fd == iobuf.out_fd)
+		return "message fd";
+	else if (fd == batch_fd)
+		return "batch file";
+	else {
+		snprintf(buf, sizeof buf, "fd %d", fd);
+		return buf;
+	}
+}
+
+/* Do a safe write, handling any needed looping and error handling.
+ * Returns only if everything was successfully written.  This routine
+ * is not used on the socket except very early in the transfer. */
+static void safe_write(int fd, const char *buf, size_t len)
+{
+	int n;
+
+	assert(fd != iobuf.out_fd);
+
+	n = write(fd, buf, len);
+	if ((size_t)n == len)
+		return;
+	if (n < 0) {
+		if (errno != EINTR && errno != EWOULDBLOCK && errno != EAGAIN) {
+		  write_failed:
+			rsyserr(FERROR, errno,
+				"safe_write failed to write %ld bytes to %s [%s]",
+				(long)len, what_fd_is(fd), who_am_i());
+			exit_cleanup(RERR_STREAMIO);
+		}
+	} else {
+		buf += n;
+		len -= n;
+	}
+
+	while (len) {
+		struct timeval tv;
+		fd_set w_fds;
+		int cnt;
+
+		FD_ZERO(&w_fds);
+		FD_SET(fd, &w_fds);
+		tv.tv_sec = select_timeout;
+		tv.tv_usec = 0;
+
+		cnt = select(fd + 1, NULL, &w_fds, NULL, &tv);
+		if (cnt <= 0) {
+			if (cnt < 0 && errno == EBADF) {
+				rsyserr(FERROR, errno, "safe_write select failed on %s [%s]",
+					what_fd_is(fd), who_am_i());
+				exit_cleanup(RERR_FILEIO);
+			}
+			if (io_timeout)
+				maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
+			continue;
+		}
+
+		if (FD_ISSET(fd, &w_fds)) {
+			n = write(fd, buf, len);
+			if (n < 0) {
+				if (errno == EINTR)
+					continue;
+				goto write_failed;
+			}
+			buf += n;
+			len -= n;
+		}
+	}
+}
+
+/* This is only called when files-from data is known to be available.  We read
+ * a chunk of data and put it into the output buffer. */
+static void forward_filesfrom_data(void)
+{
+	int len;
+
+	len = read(ff_forward_fd, ff_xb.buf + ff_xb.len, ff_xb.size - ff_xb.len);
+	if (len <= 0) {
+		if (len == 0 || errno != EINTR) {
+			/* Send end-of-file marker */
+			ff_forward_fd = -1;
+			write_buf(iobuf.out_fd, "\0\0", ff_lastchar ? 2 : 1);
+			free_xbuf(&ff_xb);
+			if (ff_reenable_multiplex >= 0)
+				io_start_multiplex_out(ff_reenable_multiplex);
+		}
+		return;
+	}
+
+	if (DEBUG_GTE(IO, 2))
+		rprintf(FINFO, "[%s] files-from read=%ld\n", who_am_i(), (long)len);
+
+#ifdef ICONV_OPTION
+	len += ff_xb.len;
+#endif
+
+	if (!eol_nulls) {
+		char *s = ff_xb.buf + len;
+		/* Transform CR and/or LF into '\0' */
+		while (s-- > ff_xb.buf) {
+			if (*s == '\n' || *s == '\r')
+				*s = '\0';
+		}
+	}
+
+	if (ff_lastchar)
+		ff_xb.pos = 0;
+	else {
+		char *s = ff_xb.buf;
+		/* Last buf ended with a '\0', so don't let this buf start with one. */
+		while (len && *s == '\0')
+			s++, len--;
+		ff_xb.pos = s - ff_xb.buf;
+	}
+
+#ifdef ICONV_OPTION
+	if (filesfrom_convert && len) {
+		char *sob = ff_xb.buf + ff_xb.pos, *s = sob;
+		char *eob = sob + len;
+		int flags = ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_CIRCULAR_OUT;
+		if (ff_lastchar == '\0')
+			flags |= ICB_INIT;
+		/* Convert/send each null-terminated string separately, skipping empties. */
+		while (s != eob) {
+			if (*s++ == '\0') {
+				ff_xb.len = s - sob - 1;
+				if (iconvbufs(ic_send, &ff_xb, &iobuf.out, flags) < 0)
+					exit_cleanup(RERR_PROTOCOL); /* impossible? */
+				write_buf(iobuf.out_fd, s-1, 1); /* Send the '\0'. */
+				while (s != eob && *s == '\0')
+					s++;
+				sob = s;
+				ff_xb.pos = sob - ff_xb.buf;
+				flags |= ICB_INIT;
+			}
+		}
+
+		if ((ff_xb.len = s - sob) == 0)
+			ff_lastchar = '\0';
+		else {
+			/* Handle a partial string specially, saving any incomplete chars. */
+			flags &= ~ICB_INCLUDE_INCOMPLETE;
+			if (iconvbufs(ic_send, &ff_xb, &iobuf.out, flags) < 0) {
+				if (errno == E2BIG)
+					exit_cleanup(RERR_PROTOCOL); /* impossible? */
+				if (ff_xb.pos)
+					memmove(ff_xb.buf, ff_xb.buf + ff_xb.pos, ff_xb.len);
+			}
+			ff_lastchar = 'x'; /* Anything non-zero. */
+		}
+	} else
+#endif
+
+	if (len) {
+		char *f = ff_xb.buf + ff_xb.pos;
+		char *t = ff_xb.buf;
+		char *eob = f + len;
+		/* Eliminate any multi-'\0' runs. */
+		while (f != eob) {
+			if (!(*t++ = *f++)) {
+				while (f != eob && *f == '\0')
+					f++;
+			}
+		}
+		ff_lastchar = f[-1];
+		if ((len = t - ff_xb.buf) != 0) {
+			/* This will not circle back to perform_io() because we only get
+			 * called when there is plenty of room in the output buffer. */
+			write_buf(iobuf.out_fd, ff_xb.buf, len);
+		}
+	}
+}
+
+void reduce_iobuf_size(xbuf *out, size_t new_size)
+{
+	if (new_size < out->size) {
+		/* Avoid weird buffer interactions by only outputting this to stderr. */
+		if (msgs2stderr && DEBUG_GTE(IO, 4)) {
+			const char *name = out == &iobuf.out ? "iobuf.out"
+					 : out == &iobuf.msg ? "iobuf.msg"
+					 : NULL;
+			if (name) {
+				rprintf(FINFO, "[%s] reduced size of %s (-%d)\n",
+					who_am_i(), name, (int)(out->size - new_size));
+			}
+		}
+		out->size = new_size;
+	}
+}
+
+void restore_iobuf_size(xbuf *out)
+{
+	if (IOBUF_WAS_REDUCED(out->size)) {
+		size_t new_size = IOBUF_RESTORE_SIZE(out->size);
+		/* Avoid weird buffer interactions by only outputting this to stderr. */
+		if (msgs2stderr && DEBUG_GTE(IO, 4)) {
+			const char *name = out == &iobuf.out ? "iobuf.out"
+					 : out == &iobuf.msg ? "iobuf.msg"
+					 : NULL;
+			if (name) {
+				rprintf(FINFO, "[%s] restored size of %s (+%d)\n",
+					who_am_i(), name, (int)(new_size - out->size));
+			}
+		}
+		out->size = new_size;
+	}
+}
+
+static void handle_kill_signal(BOOL flush_ok)
+{
+	got_kill_signal = -1;
+	flush_ok_after_signal = flush_ok;
+	exit_cleanup(RERR_SIGNAL);
+}
+
+/* Perform buffered input and/or output until specified conditions are met.
+ * When given a "needed" read or write request, this returns without doing any
+ * I/O if the needed input bytes or write space is already available.  Once I/O
+ * is needed, this will try to do whatever reading and/or writing is currently
+ * possible, up to the maximum buffer allowances, no matter if this is a read
+ * or write request.  However, the I/O stops as soon as the required input
+ * bytes or output space is available.  If this is not a read request, the
+ * routine may also do some advantageous reading of messages from a multiplexed
+ * input source (which ensures that we don't jam up with everyone in their
+ * "need to write" code and nobody reading the accumulated data that would make
+ * writing possible).
+ *
+ * The iobuf.in, .out and .msg buffers are all circular.  Callers need to be
+ * aware that some data copies will need to be split when the bytes wrap around
+ * from the end to the start.  In order to help make writing into the output
+ * buffers easier for some operations (such as the use of SIVAL() into the
+ * buffer) a buffer may be temporarily shortened by a small amount, but the
+ * original size will be automatically restored when the .pos wraps to the
+ * start.  See also the 3 raw_* iobuf vars that are used in the handling of
+ * MSG_DATA bytes as they are read-from/written-into the buffers.
+ *
+ * When writing, we flush data in the following priority order:
+ *
+ * 1. Finish writing any in-progress MSG_DATA sequence from iobuf.out.
+ *
+ * 2. Write out all the messages from the message buf (if iobuf.msg is active).
+ *    Yes, this means that a PIO_NEED_OUTROOM call will completely flush any
+ *    messages before getting to the iobuf.out flushing (except for rule 1).
+ *
+ * 3. Write out the raw data from iobuf.out, possibly filling in the multiplexed
+ *    MSG_DATA header that was pre-allocated (when output is multiplexed).
+ *
+ * TODO:  items for possible future work:
+ *
+ *    - Make this routine able to read the generator-to-receiver batch flow?
+ *
+ * Unlike the old routines that this replaces, it is OK to read ahead as far as
+ * we can because the read_a_msg() routine now reads its bytes out of the input
+ * buffer.  In the old days, only raw data was in the input buffer, and any
+ * unused raw data in the buf would prevent the reading of socket data. */
+static char *perform_io(size_t needed, int flags)
+{
+	fd_set r_fds, e_fds, w_fds;
+	struct timeval tv;
+	int cnt, max_fd;
+	size_t empty_buf_len = 0;
+	xbuf *out;
+	char *data;
+
+	if (iobuf.in.len == 0 && iobuf.in.pos != 0) {
+		if (iobuf.raw_input_ends_before)
+			iobuf.raw_input_ends_before -= iobuf.in.pos;
+		iobuf.in.pos = 0;
+	}
+
+	switch (flags & PIO_NEED_FLAGS) {
+	case PIO_NEED_INPUT:
+		/* We never resize the circular input buffer. */
+		if (iobuf.in.size < needed) {
+			rprintf(FERROR, "need to read %ld bytes, iobuf.in.buf is only %ld bytes.\n",
+				(long)needed, (long)iobuf.in.size);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+
+		if (msgs2stderr && DEBUG_GTE(IO, 3)) {
+			rprintf(FINFO, "[%s] perform_io(%ld, %sinput)\n",
+				who_am_i(), (long)needed, flags & PIO_CONSUME_INPUT ? "consume&" : "");
+		}
+		break;
+
+	case PIO_NEED_OUTROOM:
+		/* We never resize the circular output buffer. */
+		if (iobuf.out.size - iobuf.out_empty_len < needed) {
+			fprintf(stderr, "need to write %ld bytes, iobuf.out.buf is only %ld bytes.\n",
+				(long)needed, (long)(iobuf.out.size - iobuf.out_empty_len));
+			exit_cleanup(RERR_PROTOCOL);
+		}
+
+		if (msgs2stderr && DEBUG_GTE(IO, 3)) {
+			rprintf(FINFO, "[%s] perform_io(%ld, outroom) needs to flush %ld\n",
+				who_am_i(), (long)needed,
+				iobuf.out.len + needed > iobuf.out.size
+				? (long)(iobuf.out.len + needed - iobuf.out.size) : 0L);
+		}
+		break;
+
+	case PIO_NEED_MSGROOM:
+		/* We never resize the circular message buffer. */
+		if (iobuf.msg.size < needed) {
+			fprintf(stderr, "need to write %ld bytes, iobuf.msg.buf is only %ld bytes.\n",
+				(long)needed, (long)iobuf.msg.size);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+
+		if (msgs2stderr && DEBUG_GTE(IO, 3)) {
+			rprintf(FINFO, "[%s] perform_io(%ld, msgroom) needs to flush %ld\n",
+				who_am_i(), (long)needed,
+				iobuf.msg.len + needed > iobuf.msg.size
+				? (long)(iobuf.msg.len + needed - iobuf.msg.size) : 0L);
+		}
+		break;
+
+	case 0:
+		if (msgs2stderr && DEBUG_GTE(IO, 3))
+			rprintf(FINFO, "[%s] perform_io(%ld, %d)\n", who_am_i(), (long)needed, flags);
+		break;
+
+	default:
+		exit_cleanup(RERR_UNSUPPORTED);
+	}
+
+	while (1) {
+		switch (flags & PIO_NEED_FLAGS) {
+		case PIO_NEED_INPUT:
+			if (iobuf.in.len >= needed)
+				goto double_break;
+			break;
+		case PIO_NEED_OUTROOM:
+			/* Note that iobuf.out_empty_len doesn't factor into this check
+			 * because iobuf.out.len already holds any needed header len. */
+			if (iobuf.out.len + needed <= iobuf.out.size)
+				goto double_break;
+			break;
+		case PIO_NEED_MSGROOM:
+			if (iobuf.msg.len + needed <= iobuf.msg.size)
+				goto double_break;
+			break;
+		}
+
+		max_fd = -1;
+
+		FD_ZERO(&r_fds);
+		FD_ZERO(&e_fds);
+		if (iobuf.in_fd >= 0 && iobuf.in.size - iobuf.in.len) {
+			if (!read_batch || batch_fd >= 0) {
+				FD_SET(iobuf.in_fd, &r_fds);
+				FD_SET(iobuf.in_fd, &e_fds);
+			}
+			if (iobuf.in_fd > max_fd)
+				max_fd = iobuf.in_fd;
+		}
+
+		/* Only do more filesfrom processing if there is enough room in the out buffer. */
+		if (ff_forward_fd >= 0 && iobuf.out.size - iobuf.out.len > FILESFROM_BUFLEN*2) {
+			FD_SET(ff_forward_fd, &r_fds);
+			if (ff_forward_fd > max_fd)
+				max_fd = ff_forward_fd;
+		}
+
+		FD_ZERO(&w_fds);
+		if (iobuf.out_fd >= 0) {
+			if (iobuf.raw_flushing_ends_before
+			 || (!iobuf.msg.len && iobuf.out.len > iobuf.out_empty_len && !(flags & PIO_NEED_MSGROOM))) {
+				if (OUT_MULTIPLEXED && !iobuf.raw_flushing_ends_before) {
+					/* The iobuf.raw_flushing_ends_before value can point off the end
+					 * of the iobuf.out buffer for a while, for easier subtracting. */
+					iobuf.raw_flushing_ends_before = iobuf.out.pos + iobuf.out.len;
+
+					SIVAL(iobuf.out.buf + iobuf.raw_data_header_pos, 0,
+					      ((MPLEX_BASE + (int)MSG_DATA)<<24) + iobuf.out.len - 4);
+
+					if (msgs2stderr && DEBUG_GTE(IO, 1)) {
+						rprintf(FINFO, "[%s] send_msg(%d, %ld)\n",
+							who_am_i(), (int)MSG_DATA, (long)iobuf.out.len - 4);
+					}
+
+					/* reserve room for the next MSG_DATA header */
+					iobuf.raw_data_header_pos = iobuf.raw_flushing_ends_before;
+					if (iobuf.raw_data_header_pos >= iobuf.out.size)
+						iobuf.raw_data_header_pos -= iobuf.out.size;
+					else if (iobuf.raw_data_header_pos + 4 > iobuf.out.size) {
+						/* The 4-byte header won't fit at the end of the buffer,
+						 * so we'll temporarily reduce the output buffer's size
+						 * and put the header at the start of the buffer. */
+						reduce_iobuf_size(&iobuf.out, iobuf.raw_data_header_pos);
+						iobuf.raw_data_header_pos = 0;
+					}
+					/* Yes, it is possible for this to make len > size for a while. */
+					iobuf.out.len += 4;
+				}
+
+				empty_buf_len = iobuf.out_empty_len;
+				out = &iobuf.out;
+			} else if (iobuf.msg.len) {
+				empty_buf_len = 0;
+				out = &iobuf.msg;
+			} else
+				out = NULL;
+			if (out) {
+				FD_SET(iobuf.out_fd, &w_fds);
+				if (iobuf.out_fd > max_fd)
+					max_fd = iobuf.out_fd;
+			}
+		} else
+			out = NULL;
+
+		if (max_fd < 0) {
+			switch (flags & PIO_NEED_FLAGS) {
+			case PIO_NEED_INPUT:
+				iobuf.in.len = 0;
+				if (kluge_around_eof == 2)
+					exit_cleanup(0);
+				if (iobuf.in_fd == -2)
+					whine_about_eof(True);
+				rprintf(FERROR, "error in perform_io: no fd for input.\n");
+				exit_cleanup(RERR_PROTOCOL);
+			case PIO_NEED_OUTROOM:
+			case PIO_NEED_MSGROOM:
+				msgs2stderr = 1;
+				drain_multiplex_messages();
+				if (iobuf.out_fd == -2)
+					whine_about_eof(True);
+				rprintf(FERROR, "error in perform_io: no fd for output.\n");
+				exit_cleanup(RERR_PROTOCOL);
+			default:
+				/* No stated needs, so I guess this is OK. */
+				break;
+			}
+			break;
+		}
+
+		if (got_kill_signal > 0)
+			handle_kill_signal(True);
+
+		if (extra_flist_sending_enabled) {
+			if (file_total - file_old_total < MAX_FILECNT_LOOKAHEAD && IN_MULTIPLEXED_AND_READY)
+				tv.tv_sec = 0;
+			else {
+				extra_flist_sending_enabled = False;
+				tv.tv_sec = select_timeout;
+			}
+		} else
+			tv.tv_sec = select_timeout;
+		tv.tv_usec = 0;
+
+		cnt = select(max_fd + 1, &r_fds, &w_fds, &e_fds, &tv);
+
+		if (cnt <= 0) {
+			if (cnt < 0 && errno == EBADF) {
+				msgs2stderr = 1;
+				exit_cleanup(RERR_SOCKETIO);
+			}
+			if (extra_flist_sending_enabled) {
+				extra_flist_sending_enabled = False;
+				send_extra_file_list(sock_f_out, -1);
+				extra_flist_sending_enabled = !flist_eof;
+			} else
+				check_timeout((flags & PIO_NEED_INPUT) != 0);
+			FD_ZERO(&r_fds); /* Just in case... */
+			FD_ZERO(&w_fds);
+		}
+
+		if (iobuf.in_fd >= 0 && FD_ISSET(iobuf.in_fd, &r_fds)) {
+			size_t len, pos = iobuf.in.pos + iobuf.in.len;
+			int n;
+			if (pos >= iobuf.in.size) {
+				pos -= iobuf.in.size;
+				len = iobuf.in.size - iobuf.in.len;
+			} else
+				len = iobuf.in.size - pos;
+			if ((n = read(iobuf.in_fd, iobuf.in.buf + pos, len)) <= 0) {
+				if (n == 0) {
+					/* Signal that input has become invalid. */
+					if (!read_batch || batch_fd < 0 || am_generator)
+						iobuf.in_fd = -2;
+					batch_fd = -1;
+					continue;
+				}
+				if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)
+					n = 0;
+				else {
+					/* Don't write errors on a dead socket. */
+					if (iobuf.in_fd == sock_f_in) {
+						if (am_sender)
+							msgs2stderr = 1;
+						rsyserr(FERROR_SOCKET, errno, "read error");
+					} else
+						rsyserr(FERROR, errno, "read error");
+					exit_cleanup(RERR_SOCKETIO);
+				}
+			}
+			if (msgs2stderr && DEBUG_GTE(IO, 2))
+				rprintf(FINFO, "[%s] recv=%ld\n", who_am_i(), (long)n);
+
+			if (io_timeout) {
+				last_io_in = time(NULL);
+				if (flags & PIO_NEED_INPUT)
+					maybe_send_keepalive(last_io_in, 0);
+			}
+			stats.total_read += n;
+
+			iobuf.in.len += n;
+		}
+
+		if (out && FD_ISSET(iobuf.out_fd, &w_fds)) {
+			size_t len = iobuf.raw_flushing_ends_before ? iobuf.raw_flushing_ends_before - out->pos : out->len;
+			int n;
+
+			if (bwlimit_writemax && len > bwlimit_writemax)
+				len = bwlimit_writemax;
+
+			if (out->pos + len > out->size)
+				len = out->size - out->pos;
+			if ((n = write(iobuf.out_fd, out->buf + out->pos, len)) <= 0) {
+				if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)
+					n = 0;
+				else {
+					/* Don't write errors on a dead socket. */
+					msgs2stderr = 1;
+					iobuf.out_fd = -2;
+					iobuf.out.len = iobuf.msg.len = iobuf.raw_flushing_ends_before = 0;
+					rsyserr(FERROR_SOCKET, errno, "[%s] write error", who_am_i());
+					drain_multiplex_messages();
+					exit_cleanup(RERR_SOCKETIO);
+				}
+			}
+			if (msgs2stderr && DEBUG_GTE(IO, 2)) {
+				rprintf(FINFO, "[%s] %s sent=%ld\n",
+					who_am_i(), out == &iobuf.out ? "out" : "msg", (long)n);
+			}
+
+			if (io_timeout)
+				last_io_out = time(NULL);
+			stats.total_written += n;
+
+			if (bwlimit_writemax)
+				sleep_for_bwlimit(n);
+
+			if ((out->pos += n) == out->size) {
+				if (iobuf.raw_flushing_ends_before)
+					iobuf.raw_flushing_ends_before -= out->size;
+				out->pos = 0;
+				restore_iobuf_size(out);
+			} else if (out->pos == iobuf.raw_flushing_ends_before)
+				iobuf.raw_flushing_ends_before = 0;
+			if ((out->len -= n) == empty_buf_len) {
+				out->pos = 0;
+				restore_iobuf_size(out);
+				if (empty_buf_len)
+					iobuf.raw_data_header_pos = 0;
+			}
+		}
+
+		if (got_kill_signal > 0)
+			handle_kill_signal(True);
+
+		/* We need to help prevent deadlock by doing what reading
+		 * we can whenever we are here trying to write. */
+		if (IN_MULTIPLEXED_AND_READY && !(flags & PIO_NEED_INPUT)) {
+			while (!iobuf.raw_input_ends_before && iobuf.in.len > 512)
+				read_a_msg();
+			if (flist_receiving_enabled && iobuf.in.len > 512)
+				wait_for_receiver(); /* generator only */
+		}
+
+		if (ff_forward_fd >= 0 && FD_ISSET(ff_forward_fd, &r_fds)) {
+			/* This can potentially flush all output and enable
+			 * multiplexed output, so keep this last in the loop
+			 * and be sure to not cache anything that would break
+			 * such a change. */
+			forward_filesfrom_data();
+		}
+	}
+  double_break:
+
+	if (got_kill_signal > 0)
+		handle_kill_signal(True);
+
+	data = iobuf.in.buf + iobuf.in.pos;
+
+	if (flags & PIO_CONSUME_INPUT) {
+		iobuf.in.len -= needed;
+		iobuf.in.pos += needed;
+		if (iobuf.in.pos == iobuf.raw_input_ends_before)
+			iobuf.raw_input_ends_before = 0;
+		if (iobuf.in.pos >= iobuf.in.size) {
+			iobuf.in.pos -= iobuf.in.size;
+			if (iobuf.raw_input_ends_before)
+				iobuf.raw_input_ends_before -= iobuf.in.size;
+		}
+	}
+
+	return data;
+}
+
+static void raw_read_buf(char *buf, size_t len)
+{
+	size_t pos = iobuf.in.pos;
+	char *data = perform_io(len, PIO_INPUT_AND_CONSUME);
+	if (iobuf.in.pos <= pos && len) {
+		size_t siz = len - iobuf.in.pos;
+		memcpy(buf, data, siz);
+		memcpy(buf + siz, iobuf.in.buf, iobuf.in.pos);
+	} else
+		memcpy(buf, data, len);
+}
+
+static int32 raw_read_int(void)
+{
+	char *data, buf[4];
+	if (iobuf.in.size - iobuf.in.pos >= 4)
+		data = perform_io(4, PIO_INPUT_AND_CONSUME);
+	else
+		raw_read_buf(data = buf, 4);
+	return IVAL(data, 0);
+}
+
+void noop_io_until_death(void)
+{
+	char buf[1024];
+
+	if (!iobuf.in.buf || !iobuf.out.buf || iobuf.in_fd < 0 || iobuf.out_fd < 0 || kluge_around_eof)
+		return;
+
+	kluge_around_eof = 2;
+	/* Setting an I/O timeout ensures that if something inexplicably weird
+	 * happens, we won't hang around forever. */
+	if (!io_timeout)
+		set_io_timeout(60);
+
+	while (1)
+		read_buf(iobuf.in_fd, buf, sizeof buf);
+}
+
+/* Buffer a message for the multiplexed output stream.  Is not used for (normal) MSG_DATA. */
+int send_msg(enum msgcode code, const char *buf, size_t len, int convert)
 {
-	time_t t, chk;
+	char *hdr;
+	size_t needed, pos;
+	BOOL want_debug = DEBUG_GTE(IO, 1) && convert >= 0 && (msgs2stderr || code != MSG_INFO);
 
-	if (!io_timeout || ignore_timeout)
-		return;
+	if (!OUT_MULTIPLEXED)
+		return 0;
 
-	t = time(NULL);
+	if (want_debug)
+		rprintf(FINFO, "[%s] send_msg(%d, %ld)\n", who_am_i(), (int)code, (long)len);
 
-	if (!last_io_in)
-		last_io_in = t;
+	/* When checking for enough free space for this message, we need to
+	 * make sure that there is space for the 4-byte header, plus we'll
+	 * assume that we may waste up to 3 bytes (if the header doesn't fit
+	 * at the physical end of the buffer). */
+#ifdef ICONV_OPTION
+	if (convert > 0 && ic_send == (iconv_t)-1)
+		convert = 0;
+	if (convert > 0) {
+		/* Ensuring double-size room leaves space for maximal conversion expansion. */
+		needed = len*2 + 4 + 3;
+	} else
+#endif
+		needed = len + 4 + 3;
+	if (iobuf.msg.len + needed > iobuf.msg.size)
+		perform_io(needed, PIO_NEED_MSGROOM);
+
+	pos = iobuf.msg.pos + iobuf.msg.len; /* Must be set after any flushing. */
+	if (pos >= iobuf.msg.size)
+		pos -= iobuf.msg.size;
+	else if (pos + 4 > iobuf.msg.size) {
+		/* The 4-byte header won't fit at the end of the buffer,
+		 * so we'll temporarily reduce the message buffer's size
+		 * and put the header at the start of the buffer. */
+		reduce_iobuf_size(&iobuf.msg, pos);
+		pos = 0;
+	}
+	hdr = iobuf.msg.buf + pos;
 
-	chk = MAX(last_io_out, last_io_in);
-	if (t - chk >= io_timeout) {
-		if (am_server || am_daemon)
-			exit_cleanup(RERR_TIMEOUT);
-		rprintf(FERROR, "[%s] io timeout after %d seconds -- exiting\n",
-			who_am_i(), (int)(t-chk));
-		exit_cleanup(RERR_TIMEOUT);
+	iobuf.msg.len += 4; /* Allocate room for the coming header bytes. */
+
+#ifdef ICONV_OPTION
+	if (convert > 0) {
+		xbuf inbuf;
+
+		INIT_XBUF(inbuf, (char*)buf, len, (size_t)-1);
+
+		len = iobuf.msg.len;
+		iconvbufs(ic_send, &inbuf, &iobuf.msg,
+			  ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_CIRCULAR_OUT | ICB_INIT);
+		if (inbuf.len > 0) {
+			rprintf(FERROR, "overflowed iobuf.msg buffer in send_msg");
+			exit_cleanup(RERR_UNSUPPORTED);
+		}
+		len = iobuf.msg.len - len;
+	} else
+#endif
+	{
+		size_t siz;
+
+		if ((pos += 4) == iobuf.msg.size)
+			pos = 0;
+
+		/* Handle a split copy if we wrap around the end of the circular buffer. */
+		if (pos >= iobuf.msg.pos && (siz = iobuf.msg.size - pos) < len) {
+			memcpy(iobuf.msg.buf + pos, buf, siz);
+			memcpy(iobuf.msg.buf, buf + siz, len - siz);
+		} else
+			memcpy(iobuf.msg.buf + pos, buf, len);
+
+		iobuf.msg.len += len;
 	}
-}
 
-static void readfd(int fd, char *buffer, size_t N);
-static void writefd(int fd, const char *buf, size_t len);
-static void writefd_unbuffered(int fd, const char *buf, size_t len);
-static void mplex_write(int fd, enum msgcode code, const char *buf, size_t len, int convert);
+	SIVAL(hdr, 0, ((MPLEX_BASE + (int)code)<<24) + len);
 
-static flist_ndx_list redo_list, hlink_list;
+	if (want_debug && convert > 0)
+		rprintf(FINFO, "[%s] converted msg len=%ld\n", who_am_i(), (long)len);
 
-struct msg_list_item {
-	struct msg_list_item *next;
-	char convert;
-	char buf[1];
-};
+	return 1;
+}
 
-struct msg_list {
-	struct msg_list_item *head, *tail;
-};
+void send_msg_int(enum msgcode code, int num)
+{
+	char numbuf[4];
+
+	if (DEBUG_GTE(IO, 1))
+		rprintf(FINFO, "[%s] send_msg_int(%d, %d)\n", who_am_i(), (int)code, num);
 
-static struct msg_list msg_queue;
+	SIVAL(numbuf, 0, num);
+	send_msg(code, numbuf, 4, -1);
+}
 
-static void got_flist_entry_status(enum festatus status, const char *buf)
+static void got_flist_entry_status(enum festatus status, int ndx)
 {
-	int ndx = IVAL(buf, 0);
 	struct file_list *flist = flist_for_ndx(ndx, "got_flist_entry_status");
 
 	if (remove_source_files) {
 		active_filecnt--;
 		active_bytecnt -= F_LENGTH(flist->files[ndx - flist->ndx_start]);
 	}
@@ -173,23 +1051,24 @@
 	if (inc_recurse)
 		flist->in_progress--;
 
 	switch (status) {
 	case FES_SUCCESS:
 		if (remove_source_files)
-			send_msg(MSG_SUCCESS, buf, 4, 0);
+			send_msg_int(MSG_SUCCESS, ndx);
 		/* FALL THROUGH */
 	case FES_NO_SEND:
 #ifdef SUPPORT_HARD_LINKS
 		if (preserve_hard_links) {
 			struct file_struct *file = flist->files[ndx - flist->ndx_start];
 			if (F_IS_HLINKED(file)) {
 				if (status == FES_NO_SEND)
 					flist_ndx_push(&hlink_list, -2); /* indicates a failure follows */
 				flist_ndx_push(&hlink_list, ndx);
-				flist->in_progress++;
+				if (inc_recurse)
+					flist->in_progress++;
 			}
 		}
 #endif
 		break;
 	case FES_REDO:
 		if (read_batch) {
@@ -223,77 +1102,12 @@
 		select_timeout = allowed_lull;
 
 	if (read_batch)
 		allowed_lull = 0;
 }
 
-/* Setup the fd used to receive MSG_* messages.  Only needed during the
- * early stages of being a local sender (up through the sending of the
- * file list) or when we're the generator (to fetch the messages from
- * the receiver). */
-void set_msg_fd_in(int fd)
-{
-	msg_fd_in = fd;
-}
-
-/* Setup the fd used to send our MSG_* messages.  Only needed when
- * we're the receiver (to send our messages to the generator). */
-void set_msg_fd_out(int fd)
-{
-	msg_fd_out = fd;
-	set_nonblocking(msg_fd_out);
-}
-
-/* Add a message to the pending MSG_* list. */
-static void msg_list_add(struct msg_list *lst, int code, const char *buf, int len, int convert)
-{
-	struct msg_list_item *m;
-	int sz = len + 4 + sizeof m[0] - 1;
-
-	if (!(m = (struct msg_list_item *)new_array(char, sz)))
-		out_of_memory("msg_list_add");
-	m->next = NULL;
-	m->convert = convert;
-	SIVAL(m->buf, 0, ((code+MPLEX_BASE)<<24) | len);
-	memcpy(m->buf + 4, buf, len);
-	if (lst->tail)
-		lst->tail->next = m;
-	else
-		lst->head = m;
-	lst->tail = m;
-}
-
-static inline int flush_a_msg(int fd)
-{
-	struct msg_list_item *m = msg_queue.head;
-	int len = IVAL(m->buf, 0) & 0xFFFFFF;
-	int tag = *((uchar*)m->buf+3) - MPLEX_BASE;
-
-	if (!(msg_queue.head = m->next))
-		msg_queue.tail = NULL;
-
-	defer_forwarding_messages++;
-	mplex_write(fd, tag, m->buf + 4, len, m->convert);
-	defer_forwarding_messages--;
-
-	free(m);
-
-	return len;
-}
-
-static void msg_flush(void)
-{
-	if (am_generator) {
-		while (msg_queue.head && io_multiplexing_out)
-			stats.total_written += flush_a_msg(sock_f_out) + 4;
-	} else {
-		while (msg_queue.head)
-			(void)flush_a_msg(msg_fd_out);
-	}
-}
-
 static void check_for_d_option_error(const char *msg)
 {
 	static char rsync263_opts[] = "BCDHIKLPRSTWabceghlnopqrtuvxz";
 	char *colon;
 	int saw_d = 0;
 
@@ -318,138 +1132,12 @@
 	if (saw_d) {
 		rprintf(FWARNING,
 		    "*** Try using \"--old-d\" if remote rsync is <= 2.6.3 ***\n");
 	}
 }
 
-/* Read a message from the MSG_* fd and handle it.  This is called either
- * during the early stages of being a local sender (up through the sending
- * of the file list) or when we're the generator (to fetch the messages
- * from the receiver). */
-static void read_msg_fd(void)
-{
-	char buf[2048];
-	size_t n;
-	struct file_list *flist;
-	int fd = msg_fd_in;
-	int tag, len;
-
-	/* Temporarily disable msg_fd_in.  This is needed to avoid looping back
-	 * to this routine from writefd_unbuffered(). */
-	no_flush++;
-	msg_fd_in = -1;
-	defer_forwarding_messages++;
-
-	readfd(fd, buf, 4);
-	tag = IVAL(buf, 0);
-
-	len = tag & 0xFFFFFF;
-	tag = (tag >> 24) - MPLEX_BASE;
-
-	switch (tag) {
-	case MSG_DONE:
-		if (len < 0 || len > 1 || !am_generator) {
-		  invalid_msg:
-			rprintf(FERROR, "invalid message %d:%d [%s%s]\n",
-				tag, len, who_am_i(),
-				inc_recurse ? "/inc" : "");
-			exit_cleanup(RERR_STREAMIO);
-		}
-		if (len) {
-			readfd(fd, buf, len);
-			stats.total_read = read_varlong(fd, 3);
-		}
-		msgdone_cnt++;
-		break;
-	case MSG_REDO:
-		if (len != 4 || !am_generator)
-			goto invalid_msg;
-		readfd(fd, buf, 4);
-		got_flist_entry_status(FES_REDO, buf);
-		break;
-	case MSG_FLIST:
-		if (len != 4 || !am_generator || !inc_recurse)
-			goto invalid_msg;
-		readfd(fd, buf, 4);
-		/* Read extra file list from receiver. */
-		assert(iobuf_in != NULL);
-		assert(iobuf_f_in == fd);
-		if (verbose > 3) {
-			rprintf(FINFO, "[%s] receiving flist for dir %d\n",
-				who_am_i(), IVAL(buf,0));
-		}
-		flist = recv_file_list(fd);
-		flist->parent_ndx = IVAL(buf,0);
-#ifdef SUPPORT_HARD_LINKS
-		if (preserve_hard_links)
-			match_hard_links(flist);
-#endif
-		break;
-	case MSG_FLIST_EOF:
-		if (len != 0 || !am_generator || !inc_recurse)
-			goto invalid_msg;
-		flist_eof = 1;
-		break;
-	case MSG_IO_ERROR:
-		if (len != 4)
-			goto invalid_msg;
-		readfd(fd, buf, len);
-		io_error |= IVAL(buf, 0);
-		break;
-	case MSG_DELETED:
-		if (len >= (int)sizeof buf || !am_generator)
-			goto invalid_msg;
-		readfd(fd, buf, len);
-		send_msg(MSG_DELETED, buf, len, 1);
-		break;
-	case MSG_SUCCESS:
-		if (len != 4 || !am_generator)
-			goto invalid_msg;
-		readfd(fd, buf, 4);
-		got_flist_entry_status(FES_SUCCESS, buf);
-		break;
-	case MSG_NO_SEND:
-		if (len != 4 || !am_generator)
-			goto invalid_msg;
-		readfd(fd, buf, 4);
-		got_flist_entry_status(FES_NO_SEND, buf);
-		break;
-	case MSG_ERROR_SOCKET:
-	case MSG_ERROR_UTF8:
-	case MSG_CLIENT:
-		if (!am_generator)
-			goto invalid_msg;
-		if (tag == MSG_ERROR_SOCKET)
-			io_end_multiplex_out();
-		/* FALL THROUGH */
-	case MSG_INFO:
-	case MSG_ERROR:
-	case MSG_ERROR_XFER:
-	case MSG_WARNING:
-	case MSG_LOG:
-		while (len) {
-			n = len;
-			if (n >= sizeof buf)
-				n = sizeof buf - 1;
-			readfd(fd, buf, n);
-			rwrite((enum logcode)tag, buf, n, !am_generator);
-			len -= n;
-		}
-		break;
-	default:
-		rprintf(FERROR, "unknown message %d:%d [%s]\n",
-			tag, len, who_am_i());
-		exit_cleanup(RERR_STREAMIO);
-	}
-
-	no_flush--;
-	msg_fd_in = fd;
-	if (!--defer_forwarding_messages && !no_flush)
-		msg_flush();
-}
-
 /* This is used by the generator to limit how many file transfers can
  * be active at once when --remove-source-files is specified.  Without
  * this, sender-side deletions were mostly happening at the end. */
 void increment_active_files(int ndx, int itemizing, enum logcode code)
 {
 	while (1) {
@@ -457,332 +1145,54 @@
 		int limit = active_bytecnt >= 128*1024 ? 10 : 50;
 		if (active_filecnt < limit)
 			break;
 		check_for_finished_files(itemizing, code, 0);
 		if (active_filecnt < limit)
 			break;
-		if (iobuf_out_cnt)
-			io_flush(NORMAL_FLUSH);
-		else
-			read_msg_fd();
+		wait_for_receiver();
 	}
 
 	active_filecnt++;
 	active_bytecnt += F_LENGTH(cur_flist->files[ndx - cur_flist->ndx_start]);
 }
 
-/* Write an message to a multiplexed stream. If this fails, rsync exits. */
-static void mplex_write(int fd, enum msgcode code, const char *buf, size_t len, int convert)
-{
-	char buffer[BIGPATHBUFLEN]; /* Oversized for use by iconv code. */
-	size_t n = len;
-
-#ifdef ICONV_OPTION
-	/* We need to convert buf before doing anything else so that we
-	 * can include the (converted) byte length in the message header. */
-	if (convert && ic_send != (iconv_t)-1) {
-		xbuf outbuf, inbuf;
-
-		INIT_XBUF(outbuf, buffer + 4, 0, sizeof buffer - 4);
-		INIT_XBUF(inbuf, (char*)buf, len, -1);
-
-		iconvbufs(ic_send, &inbuf, &outbuf,
-			  ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE);
-		if (inbuf.len > 0) {
-			rprintf(FERROR, "overflowed conversion buffer in mplex_write");
-			exit_cleanup(RERR_UNSUPPORTED);
-		}
-
-		n = len = outbuf.len;
-	} else
-#endif
-	if (n > 1024 - 4) /* BIGPATHBUFLEN can handle 1024 bytes */
-		n = 0;    /* We'd rather do 2 writes than too much memcpy(). */
-	else
-		memcpy(buffer + 4, buf, n);
-
-	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
-
-	keep_defer_forwarding++; /* defer_forwarding_messages++ on return */
-	writefd_unbuffered(fd, buffer, n+4);
-	keep_defer_forwarding--;
-
-	if (len > n)
-		writefd_unbuffered(fd, buf+n, len-n);
-
-	if (!--defer_forwarding_messages && !no_flush)
-		msg_flush();
-}
-
-int send_msg(enum msgcode code, const char *buf, int len, int convert)
-{
-	if (msg_fd_out < 0) {
-		if (!defer_forwarding_messages)
-			return io_multiplex_write(code, buf, len, convert);
-		if (!io_multiplexing_out)
-			return 0;
-		msg_list_add(&msg_queue, code, buf, len, convert);
-		return 1;
-	}
-	if (flist_forward_from >= 0)
-		msg_list_add(&msg_queue, code, buf, len, convert);
-	else
-		mplex_write(msg_fd_out, code, buf, len, convert);
-	return 1;
-}
-
-void send_msg_int(enum msgcode code, int num)
-{
-	char numbuf[4];
-	SIVAL(numbuf, 0, num);
-	send_msg(code, numbuf, 4, 0);
-}
-
-void wait_for_receiver(void)
-{
-	if (io_flush(NORMAL_FLUSH))
-		return;
-	read_msg_fd();
-}
-
 int get_redo_num(void)
 {
 	return flist_ndx_pop(&redo_list);
 }
 
 int get_hlink_num(void)
 {
 	return flist_ndx_pop(&hlink_list);
 }
 
-/**
- * When we're the receiver and we have a local --files-from list of names
+/* When we're the receiver and we have a local --files-from list of names
  * that needs to be sent over the socket to the sender, we have to do two
  * things at the same time: send the sender a list of what files we're
  * processing and read the incoming file+info list from the sender.  We do
- * this by augmenting the read_timeout() function to copy this data.  It
- * uses ff_buf to read a block of data from f_in (when it is ready, since
- * it might be a pipe) and then blast it out f_out (when it is ready to
- * receive more data).
- */
-void io_set_filesfrom_fds(int f_in, int f_out)
-{
-	io_filesfrom_f_in = f_in;
-	io_filesfrom_f_out = f_out;
-	alloc_xbuf(&ff_buf, 2048);
-#ifdef ICONV_OPTION
-	if (protect_args)
-		alloc_xbuf(&iconv_buf, 1024);
-#endif
-}
-
-/* It's almost always an error to get an EOF when we're trying to read from the
- * network, because the protocol is (for the most part) self-terminating.
- *
- * There is one case for the receiver when it is at the end of the transfer
- * (hanging around reading any keep-alive packets that might come its way): if
- * the sender dies before the generator's kill-signal comes through, we can end
- * up here needing to loop until the kill-signal arrives.  In this situation,
- * kluge_around_eof will be < 0.
- *
- * There is another case for older protocol versions (< 24) where the module
- * listing was not terminated, so we must ignore an EOF error in that case and
- * exit.  In this situation, kluge_around_eof will be > 0. */
-static void whine_about_eof(int fd)
-{
-	if (kluge_around_eof && fd == sock_f_in) {
-		int i;
-		if (kluge_around_eof > 0)
-			exit_cleanup(0);
-		/* If we're still here after 10 seconds, exit with an error. */
-		for (i = 10*1000/20; i--; )
-			msleep(20);
-	}
-
-	rprintf(FERROR, RSYNC_NAME ": connection unexpectedly closed "
-		"(%.0f bytes received so far) [%s]\n",
-		(double)stats.total_read, who_am_i());
-
-	exit_cleanup(RERR_STREAMIO);
-}
-
-/**
- * Read from a socket with I/O timeout. return the number of bytes
- * read. If no bytes can be read then exit, never return a number <= 0.
- *
- * TODO: If the remote shell connection fails, then current versions
- * actually report an "unexpected EOF" error here.  Since it's a
- * fairly common mistake to try to use rsh when ssh is required, we
- * should trap that: if we fail to read any data at all, we should
- * give a better explanation.  We can tell whether the connection has
- * started by looking e.g. at whether the remote version is known yet.
- */
-static int read_timeout(int fd, char *buf, size_t len)
-{
-	int n, cnt = 0;
-
-	io_flush(FULL_FLUSH);
-
-	while (cnt == 0) {
-		/* until we manage to read *something* */
-		fd_set r_fds, w_fds;
-		struct timeval tv;
-		int maxfd = fd;
-		int count;
-
-		FD_ZERO(&r_fds);
-		FD_ZERO(&w_fds);
-		FD_SET(fd, &r_fds);
-		if (io_filesfrom_f_out >= 0) {
-			int new_fd;
-			if (ff_buf.len == 0) {
-				if (io_filesfrom_f_in >= 0) {
-					FD_SET(io_filesfrom_f_in, &r_fds);
-					new_fd = io_filesfrom_f_in;
-				} else {
-					io_filesfrom_f_out = -1;
-					new_fd = -1;
-				}
-			} else {
-				FD_SET(io_filesfrom_f_out, &w_fds);
-				new_fd = io_filesfrom_f_out;
-			}
-			if (new_fd > maxfd)
-				maxfd = new_fd;
-		}
-
-		tv.tv_sec = select_timeout;
-		tv.tv_usec = 0;
-
-		errno = 0;
-
-		count = select(maxfd + 1, &r_fds, &w_fds, NULL, &tv);
-
-		if (count <= 0) {
-			if (errno == EBADF) {
-				defer_forwarding_messages = 0;
-				exit_cleanup(RERR_SOCKETIO);
-			}
-			check_timeout();
-			continue;
-		}
-
-		if (io_filesfrom_f_out >= 0) {
-			if (ff_buf.len) {
-				if (FD_ISSET(io_filesfrom_f_out, &w_fds)) {
-					int l = write(io_filesfrom_f_out,
-						      ff_buf.buf + ff_buf.pos,
-						      ff_buf.len);
-					if (l > 0) {
-						if (!(ff_buf.len -= l))
-							ff_buf.pos = 0;
-						else
-							ff_buf.pos += l;
-					} else if (errno != EINTR) {
-						/* XXX should we complain? */
-						io_filesfrom_f_out = -1;
-					}
-				}
-			} else if (io_filesfrom_f_in >= 0) {
-				if (FD_ISSET(io_filesfrom_f_in, &r_fds)) {
-#ifdef ICONV_OPTION
-					xbuf *ibuf = filesfrom_convert ? &iconv_buf : &ff_buf;
-#else
-					xbuf *ibuf = &ff_buf;
-#endif
-					int l = read(io_filesfrom_f_in, ibuf->buf, ibuf->size);
-					if (l <= 0) {
-						if (l == 0 || errno != EINTR) {
-							/* Send end-of-file marker */
-							memcpy(ff_buf.buf, "\0\0", 2);
-							ff_buf.len = ff_lastchar? 2 : 1;
-							ff_buf.pos = 0;
-							io_filesfrom_f_in = -1;
-						}
-					} else {
-#ifdef ICONV_OPTION
-						if (filesfrom_convert) {
-							iconv_buf.pos = 0;
-							iconv_buf.len = l;
-							iconvbufs(ic_send, &iconv_buf, &ff_buf,
-							    ICB_EXPAND_OUT|ICB_INCLUDE_BAD|ICB_INCLUDE_INCOMPLETE);
-							l = ff_buf.len;
-						}
-#endif
-						if (!eol_nulls) {
-							char *s = ff_buf.buf + l;
-							/* Transform CR and/or LF into '\0' */
-							while (s-- > ff_buf.buf) {
-								if (*s == '\n' || *s == '\r')
-									*s = '\0';
-							}
-						}
-						if (!ff_lastchar) {
-							/* Last buf ended with a '\0', so don't
-							 * let this buf start with one. */
-							while (l && ff_buf.buf[ff_buf.pos] == '\0')
-								ff_buf.pos++, l--;
-						}
-						if (!l)
-							ff_buf.pos = 0;
-						else {
-							char *f = ff_buf.buf + ff_buf.pos;
-							char *t = f;
-							char *eob = f + l;
-							/* Eliminate any multi-'\0' runs. */
-							while (f != eob) {
-								if (!(*t++ = *f++)) {
-									while (f != eob && !*f)
-										f++, l--;
-								}
-							}
-							ff_lastchar = f[-1];
-						}
-						ff_buf.len = l;
-					}
-				}
-			}
-		}
-
-		if (!FD_ISSET(fd, &r_fds))
-			continue;
-
-		n = read(fd, buf, len);
-
-		if (n <= 0) {
-			if (n == 0)
-				whine_about_eof(fd); /* Doesn't return. */
-			if (errno == EINTR || errno == EWOULDBLOCK
-			    || errno == EAGAIN)
-				continue;
-
-			/* Don't write errors on a dead socket. */
-			if (fd == sock_f_in) {
-				io_end_multiplex_out();
-				rsyserr(FERROR_SOCKET, errno, "read error");
-			} else
-				rsyserr(FERROR, errno, "read error");
-			exit_cleanup(RERR_STREAMIO);
-		}
-
-		buf += n;
-		len -= n;
-		cnt += n;
-
-		if (fd == sock_f_in && io_timeout)
-			last_io_in = time(NULL);
+ * this by making recv_file_list() call forward_filesfrom_data(), which
+ * will ensure that we forward data to the sender until we get some data
+ * for recv_file_list() to use. */
+void start_filesfrom_forwarding(int fd)
+{
+	if (protocol_version < 31 && OUT_MULTIPLEXED) {
+		/* Older protocols send the files-from data w/o packaging
+		 * it in multiplexed I/O packets, so temporarily switch
+		 * to buffered I/O to match this behavior. */
+		iobuf.msg.pos = iobuf.msg.len = 0; /* Be extra sure no messages go out. */
+		ff_reenable_multiplex = io_end_multiplex_out(MPLX_TO_BUFFERED);
 	}
+	ff_forward_fd = fd;
 
-	return cnt;
+	alloc_xbuf(&ff_xb, FILESFROM_BUFLEN);
 }
 
 /* Read a line into the "buf" buffer. */
 int read_line(int fd, char *buf, size_t bufsiz, int flags)
 {
 	char ch, *s, *eob;
-	int cnt;
 
 #ifdef ICONV_OPTION
 	if (flags & RL_CONVERT && iconv_buf.size < bufsiz)
 		realloc_xbuf(&iconv_buf, bufsiz + 1024);
 #endif
 
@@ -791,30 +1201,16 @@
 	s = flags & RL_CONVERT ? iconv_buf.buf : buf;
 #else
 	s = buf;
 #endif
 	eob = s + bufsiz - 1;
 	while (1) {
-		cnt = read(fd, &ch, 1);
-		if (cnt < 0 && (errno == EWOULDBLOCK
-		  || errno == EINTR || errno == EAGAIN)) {
-			struct timeval tv;
-			fd_set r_fds, e_fds;
-			FD_ZERO(&r_fds);
-			FD_SET(fd, &r_fds);
-			FD_ZERO(&e_fds);
-			FD_SET(fd, &e_fds);
-			tv.tv_sec = select_timeout;
-			tv.tv_usec = 0;
-			if (!select(fd+1, &r_fds, NULL, &e_fds, &tv))
-				check_timeout();
-			/*if (FD_ISSET(fd, &e_fds))
-				rprintf(FINFO, "select exception on fd %d\n", fd); */
-			continue;
-		}
-		if (cnt != 1)
+		/* We avoid read_byte() for files because files can return an EOF. */
+		if (fd == iobuf.in_fd)
+			ch = read_byte(fd);
+		else if (safe_read(fd, &ch, 1) == 0)
 			break;
 		if (flags & RL_EOL_NULLS ? ch == '\0' : (ch == '\r' || ch == '\n')) {
 			/* Skip empty lines if dumping comments. */
 			if (flags & RL_DUMP_COMMENTS && s == buf)
 				continue;
 			break;
@@ -831,53 +1227,60 @@
 	if (flags & RL_CONVERT) {
 		xbuf outbuf;
 		INIT_XBUF(outbuf, buf, 0, bufsiz);
 		iconv_buf.pos = 0;
 		iconv_buf.len = s - iconv_buf.buf;
 		iconvbufs(ic_recv, &iconv_buf, &outbuf,
-			  ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE);
+			  ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_INIT);
 		outbuf.buf[outbuf.len] = '\0';
 		return outbuf.len;
 	}
 #endif
 
 	return s - buf;
 }
 
 void read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,
 	       char ***argv_p, int *argc_p, char **request_p)
 {
 	int maxargs = MAX_ARGS;
-	int dot_pos = 0;
-	int argc = 0;
+	int dot_pos = 0, argc = 0, request_len = 0;
 	char **argv, *p;
 	int rl_flags = (rl_nulls ? RL_EOL_NULLS : 0);
 
 #ifdef ICONV_OPTION
 	rl_flags |= (protect_args && ic_recv != (iconv_t)-1 ? RL_CONVERT : 0);
 #endif
 
 	if (!(argv = new_array(char *, maxargs)))
 		out_of_memory("read_args");
 	if (mod_name && !protect_args)
 		argv[argc++] = "rsyncd";
 
+	if (request_p)
+		*request_p = NULL;
+
 	while (1) {
 		if (read_line(f_in, buf, bufsiz, rl_flags) == 0)
 			break;
 
 		if (argc == maxargs-1) {
 			maxargs += MAX_ARGS;
 			if (!(argv = realloc_array(argv, char *, maxargs)))
 				out_of_memory("read_args");
 		}
 
 		if (dot_pos) {
-			if (request_p) {
-				*request_p = strdup(buf);
-				request_p = NULL;
+			if (request_p && request_len < 1024) {
+				int len = strlen(buf);
+				if (request_len)
+					request_p[0][request_len++] = ' ';
+				if (!(*request_p = realloc_array(*request_p, char, request_len + len + 1)))
+					out_of_memory("read_args");
+				memcpy(*request_p + request_len, buf, len + 1);
+				request_len += len;
 			}
 			if (mod_name)
 				glob_expand_module(mod_name, buf, &argv, &argc, &maxargs);
 			else
 				glob_expand(buf, &argv, &argc, &maxargs);
 		} else {
@@ -893,328 +1296,458 @@
 	glob_expand(NULL, NULL, NULL, NULL);
 
 	*argc_p = argc;
 	*argv_p = argv;
 }
 
-int io_start_buffering_out(int f_out)
+BOOL io_start_buffering_out(int f_out)
 {
-	if (iobuf_out) {
-		assert(f_out == iobuf_f_out);
-		return 0;
+	if (msgs2stderr && DEBUG_GTE(IO, 2))
+		rprintf(FINFO, "[%s] io_start_buffering_out(%d)\n", who_am_i(), f_out);
+
+	if (iobuf.out.buf) {
+		if (iobuf.out_fd == -1)
+			iobuf.out_fd = f_out;
+		else
+			assert(f_out == iobuf.out_fd);
+		return False;
 	}
-	if (!(iobuf_out = new_array(char, IO_BUFFER_SIZE)))
-		out_of_memory("io_start_buffering_out");
-	iobuf_out_cnt = 0;
-	iobuf_f_out = f_out;
-	return 1;
+
+	alloc_xbuf(&iobuf.out, ROUND_UP_1024(IO_BUFFER_SIZE * 2));
+	iobuf.out_fd = f_out;
+
+	return True;
+}
+
+BOOL io_start_buffering_in(int f_in)
+{
+	if (msgs2stderr && DEBUG_GTE(IO, 2))
+		rprintf(FINFO, "[%s] io_start_buffering_in(%d)\n", who_am_i(), f_in);
+
+	if (iobuf.in.buf) {
+		if (iobuf.in_fd == -1)
+			iobuf.in_fd = f_in;
+		else
+			assert(f_in == iobuf.in_fd);
+		return False;
+	}
+
+	alloc_xbuf(&iobuf.in, ROUND_UP_1024(IO_BUFFER_SIZE));
+	iobuf.in_fd = f_in;
+
+	return True;
 }
 
-int io_start_buffering_in(int f_in)
+void io_end_buffering_in(BOOL free_buffers)
 {
-	if (iobuf_in) {
-		assert(f_in == iobuf_f_in);
-		return 0;
+	if (msgs2stderr && DEBUG_GTE(IO, 2)) {
+		rprintf(FINFO, "[%s] io_end_buffering_in(IOBUF_%s_BUFS)\n",
+			who_am_i(), free_buffers ? "FREE" : "KEEP");
 	}
-	iobuf_in_siz = 2 * IO_BUFFER_SIZE;
-	if (!(iobuf_in = new_array(char, iobuf_in_siz)))
-		out_of_memory("io_start_buffering_in");
-	iobuf_f_in = f_in;
-	return 1;
-}
 
-void io_end_buffering_in(void)
-{
-	if (!iobuf_in)
-		return;
-	free(iobuf_in);
-	iobuf_in = NULL;
-	iobuf_in_ndx = 0;
-	iobuf_in_remaining = 0;
-	iobuf_f_in = -1;
+	if (free_buffers)
+		free_xbuf(&iobuf.in);
+	else
+		iobuf.in.pos = iobuf.in.len = 0;
+
+	iobuf.in_fd = -1;
 }
 
-void io_end_buffering_out(void)
+void io_end_buffering_out(BOOL free_buffers)
 {
-	if (!iobuf_out)
-		return;
+	if (msgs2stderr && DEBUG_GTE(IO, 2)) {
+		rprintf(FINFO, "[%s] io_end_buffering_out(IOBUF_%s_BUFS)\n",
+			who_am_i(), free_buffers ? "FREE" : "KEEP");
+	}
+
 	io_flush(FULL_FLUSH);
-	free(iobuf_out);
-	iobuf_out = NULL;
-	iobuf_f_out = -1;
+
+	if (free_buffers) {
+		free_xbuf(&iobuf.out);
+		free_xbuf(&iobuf.msg);
+	}
+
+	iobuf.out_fd = -1;
 }
 
 void maybe_flush_socket(int important)
 {
-	if (iobuf_out && iobuf_out_cnt
+	if (flist_eof && iobuf.out.buf && iobuf.out.len > iobuf.out_empty_len
 	 && (important || time(NULL) - last_io_out >= 5))
 		io_flush(NORMAL_FLUSH);
 }
 
-void maybe_send_keepalive(void)
-{
-	if (time(NULL) - last_io_out >= allowed_lull) {
-		if (!iobuf_out || !iobuf_out_cnt) {
-			if (protocol_version < 29)
-				send_msg(MSG_DATA, "", 0, 0);
-			else if (protocol_version >= 30)
-				send_msg(MSG_NOOP, "", 0, 0);
-			else {
-				write_int(sock_f_out, cur_flist->used);
-				write_shortint(sock_f_out, ITEM_IS_NEW);
-			}
-		}
-		if (iobuf_out)
+/* Older rsync versions used to send either a MSG_NOOP (protocol 30) or a
+ * raw-data-based keep-alive (protocol 29), both of which implied forwarding of
+ * the message through the sender.  Since the new timeout method does not need
+ * any forwarding, we just send an empty MSG_DATA message, which works with all
+ * rsync versions.  This avoids any message forwarding, and leaves the raw-data
+ * stream alone (since we can never be quite sure if that stream is in the
+ * right state for a keep-alive message). */
+void maybe_send_keepalive(time_t now, int flags)
+{
+	if (flags & MSK_ACTIVE_RECEIVER)
+		last_io_in = now; /* Fudge things when we're working hard on the files. */
+
+	if (now - last_io_out >= allowed_lull) {
+		/* The receiver is special:  it only sends keep-alive messages if it is
+		 * actively receiving data.  Otherwise, it lets the generator timeout. */
+		if (am_receiver && now - last_io_in >= io_timeout)
+			return;
+
+		if (!iobuf.msg.len && iobuf.out.len == iobuf.out_empty_len)
+			send_msg(MSG_DATA, "", 0, 0);
+		if (!(flags & MSK_ALLOW_FLUSH)) {
+			/* Let the caller worry about writing out the data. */
+		} else if (iobuf.msg.len)
+			perform_io(iobuf.msg.size - iobuf.msg.len + 1, PIO_NEED_MSGROOM);
+		else if (iobuf.out.len > iobuf.out_empty_len)
 			io_flush(NORMAL_FLUSH);
 	}
 }
 
-void start_flist_forward(int f_in)
+void start_flist_forward(int ndx)
 {
-	assert(iobuf_out != NULL);
-	assert(iobuf_f_out == msg_fd_out);
-	flist_forward_from = f_in;
-	defer_forwarding_messages++;
+	write_int(iobuf.out_fd, ndx);
+	forward_flist_data = 1;
 }
 
 void stop_flist_forward(void)
 {
-	flist_forward_from = -1;
-	defer_forwarding_messages--;
-	io_flush(FULL_FLUSH);
-}
-
-/**
- * Continue trying to read len bytes - don't return until len has been
- * read.
- **/
-static void read_loop(int fd, char *buf, size_t len)
-{
-	while (len) {
-		int n = read_timeout(fd, buf, len);
-
-		buf += n;
-		len -= n;
-	}
+	forward_flist_data = 0;
 }
 
-/**
- * Read from the file descriptor handling multiplexing - return number
- * of bytes read.
- *
- * Never returns <= 0.
- */
-static int readfd_unbuffered(int fd, char *buf, size_t len)
+/* Read a message from a multiplexed source. */
+static void read_a_msg(void)
 {
+	char data[BIGPATHBUFLEN];
+	int tag, val;
 	size_t msg_bytes;
-	int tag, cnt = 0;
-	char line[BIGPATHBUFLEN];
 
-	if (!iobuf_in || fd != iobuf_f_in)
-		return read_timeout(fd, buf, len);
+	/* This ensures that perform_io() does not try to do any message reading
+	 * until we've read all of the data for this message.  We should also
+	 * try to avoid calling things that will cause data to be written via
+	 * perform_io() prior to this being reset to 1. */
+	iobuf.in_multiplexed = -1;
 
-	if (!io_multiplexing_in && iobuf_in_remaining == 0) {
-		iobuf_in_remaining = read_timeout(fd, iobuf_in, iobuf_in_siz);
-		iobuf_in_ndx = 0;
-	}
-
-	while (cnt == 0) {
-		if (iobuf_in_remaining) {
-			len = MIN(len, iobuf_in_remaining);
-			memcpy(buf, iobuf_in + iobuf_in_ndx, len);
-			iobuf_in_ndx += len;
-			iobuf_in_remaining -= len;
-			cnt = len;
-			break;
-		}
+	tag = raw_read_int();
 
-		read_loop(fd, line, 4);
-		tag = IVAL(line, 0);
+	msg_bytes = tag & 0xFFFFFF;
+	tag = (tag >> 24) - MPLEX_BASE;
 
-		msg_bytes = tag & 0xFFFFFF;
-		tag = (tag >> 24) - MPLEX_BASE;
+	if (DEBUG_GTE(IO, 1) && msgs2stderr)
+		rprintf(FINFO, "[%s] got msg=%d, len=%ld\n", who_am_i(), (int)tag, (long)msg_bytes);
 
-		switch (tag) {
-		case MSG_DATA:
-			if (msg_bytes > iobuf_in_siz) {
-				if (!(iobuf_in = realloc_array(iobuf_in, char,
-							       msg_bytes)))
-					out_of_memory("readfd_unbuffered");
-				iobuf_in_siz = msg_bytes;
-			}
-			read_loop(fd, iobuf_in, msg_bytes);
-			iobuf_in_remaining = msg_bytes;
-			iobuf_in_ndx = 0;
-			break;
-		case MSG_NOOP:
-			if (msg_bytes != 0)
-				goto invalid_msg;
-			if (am_sender)
-				maybe_send_keepalive();
-			break;
-		case MSG_IO_ERROR:
-			if (msg_bytes != 4)
-				goto invalid_msg;
-			read_loop(fd, line, msg_bytes);
-			send_msg_int(MSG_IO_ERROR, IVAL(line, 0));
-			io_error |= IVAL(line, 0);
+	switch (tag) {
+	case MSG_DATA:
+		assert(iobuf.raw_input_ends_before == 0);
+		/* Though this does not yet read the data, we do mark where in
+		 * the buffer the msg data will end once it is read.  It is
+		 * possible that this points off the end of the buffer, in
+		 * which case the gradual reading of the input stream will
+		 * cause this value to wrap around and eventually become real. */
+		if (msg_bytes)
+			iobuf.raw_input_ends_before = iobuf.in.pos + msg_bytes;
+		iobuf.in_multiplexed = 1;
+		break;
+	case MSG_STATS:
+		if (msg_bytes != sizeof stats.total_read || !am_generator)
+			goto invalid_msg;
+		raw_read_buf((char*)&stats.total_read, sizeof stats.total_read);
+		iobuf.in_multiplexed = 1;
+		break;
+	case MSG_REDO:
+		if (msg_bytes != 4 || !am_generator)
+			goto invalid_msg;
+		val = raw_read_int();
+		iobuf.in_multiplexed = 1;
+		got_flist_entry_status(FES_REDO, val);
+		break;
+	case MSG_IO_ERROR:
+		if (msg_bytes != 4)
+			goto invalid_msg;
+		val = raw_read_int();
+		iobuf.in_multiplexed = 1;
+		io_error |= val;
+		if (am_receiver)
+			send_msg_int(MSG_IO_ERROR, val);
+		break;
+	case MSG_IO_TIMEOUT:
+		if (msg_bytes != 4 || am_server || am_generator)
+			goto invalid_msg;
+		val = raw_read_int();
+		iobuf.in_multiplexed = 1;
+		if (!io_timeout || io_timeout > val) {
+			if (INFO_GTE(MISC, 2))
+				rprintf(FINFO, "Setting --timeout=%d to match server\n", val);
+			set_io_timeout(val);
+		}
+		break;
+	case MSG_NOOP:
+		/* Support protocol-30 keep-alive method. */
+		if (msg_bytes != 0)
+			goto invalid_msg;
+		iobuf.in_multiplexed = 1;
+		if (am_sender)
+			maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
+		break;
+	case MSG_DELETED:
+		if (msg_bytes >= sizeof data)
+			goto overflow;
+		if (am_generator) {
+			raw_read_buf(data, msg_bytes);
+			iobuf.in_multiplexed = 1;
+			send_msg(MSG_DELETED, data, msg_bytes, 1);
 			break;
-		case MSG_DELETED:
-			if (msg_bytes >= sizeof line)
-				goto overflow;
+		}
 #ifdef ICONV_OPTION
-			if (ic_recv != (iconv_t)-1) {
-				xbuf outbuf, inbuf;
-				char ibuf[512];
-				int add_null = 0;
-
-				INIT_CONST_XBUF(outbuf, line);
-				INIT_XBUF(inbuf, ibuf, 0, -1);
-
-				while (msg_bytes) {
-					inbuf.len = msg_bytes > sizeof ibuf
-						  ? sizeof ibuf : msg_bytes;
-					read_loop(fd, inbuf.buf, inbuf.len);
-					if (!(msg_bytes -= inbuf.len)
-					 && !ibuf[inbuf.len-1])
-						inbuf.len--, add_null = 1;
-					if (iconvbufs(ic_send, &inbuf, &outbuf,
-					    ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE) < 0)
-						goto overflow;
-				}
-				if (add_null) {
-					if (outbuf.len == outbuf.size)
+		if (ic_recv != (iconv_t)-1) {
+			xbuf outbuf, inbuf;
+			char ibuf[512];
+			int add_null = 0;
+			int flags = ICB_INCLUDE_BAD | ICB_INIT;
+
+			INIT_CONST_XBUF(outbuf, data);
+			INIT_XBUF(inbuf, ibuf, 0, (size_t)-1);
+
+			while (msg_bytes) {
+				size_t len = msg_bytes > sizeof ibuf - inbuf.len ? sizeof ibuf - inbuf.len : msg_bytes;
+				raw_read_buf(ibuf + inbuf.len, len);
+				inbuf.pos = 0;
+				inbuf.len += len;
+				if (!(msg_bytes -= len) && !ibuf[inbuf.len-1])
+					inbuf.len--, add_null = 1;
+				if (iconvbufs(ic_send, &inbuf, &outbuf, flags) < 0) {
+					if (errno == E2BIG)
 						goto overflow;
-					outbuf.buf[outbuf.len++] = '\0';
+					/* Buffer ended with an incomplete char, so move the
+					 * bytes to the start of the buffer and continue. */
+					memmove(ibuf, ibuf + inbuf.pos, inbuf.len);
 				}
-				msg_bytes = outbuf.len;
-			} else
-#endif
-				read_loop(fd, line, msg_bytes);
-			/* A directory name was sent with the trailing null */
-			if (msg_bytes > 0 && !line[msg_bytes-1])
-				log_delete(line, S_IFDIR);
-			else {
-				line[msg_bytes] = '\0';
-				log_delete(line, S_IFREG);
+				flags &= ~ICB_INIT;
 			}
-			break;
-		case MSG_SUCCESS:
-			if (msg_bytes != 4) {
-			  invalid_msg:
-				rprintf(FERROR, "invalid multi-message %d:%ld [%s]\n",
-					tag, (long)msg_bytes, who_am_i());
-				exit_cleanup(RERR_STREAMIO);
+			if (add_null) {
+				if (outbuf.len == outbuf.size)
+					goto overflow;
+				outbuf.buf[outbuf.len++] = '\0';
 			}
-			read_loop(fd, line, msg_bytes);
-			successful_send(IVAL(line, 0));
-			break;
-		case MSG_NO_SEND:
-			if (msg_bytes != 4)
-				goto invalid_msg;
-			read_loop(fd, line, msg_bytes);
-			send_msg_int(MSG_NO_SEND, IVAL(line, 0));
-			break;
-		case MSG_INFO:
-		case MSG_ERROR:
-		case MSG_ERROR_XFER:
-		case MSG_WARNING:
-			if (msg_bytes >= sizeof line) {
-			    overflow:
-				rprintf(FERROR,
-					"multiplexing overflow %d:%ld [%s]\n",
-					tag, (long)msg_bytes, who_am_i());
-				exit_cleanup(RERR_STREAMIO);
+			msg_bytes = outbuf.len;
+		} else
+#endif
+			raw_read_buf(data, msg_bytes);
+		iobuf.in_multiplexed = 1;
+		/* A directory name was sent with the trailing null */
+		if (msg_bytes > 0 && !data[msg_bytes-1])
+			log_delete(data, S_IFDIR);
+		else {
+			data[msg_bytes] = '\0';
+			log_delete(data, S_IFREG);
+		}
+		break;
+	case MSG_SUCCESS:
+		if (msg_bytes != 4) {
+		  invalid_msg:
+			rprintf(FERROR, "invalid multi-message %d:%lu [%s%s]\n",
+				tag, (unsigned long)msg_bytes, who_am_i(),
+				inc_recurse ? "/inc" : "");
+			exit_cleanup(RERR_STREAMIO);
+		}
+		val = raw_read_int();
+		iobuf.in_multiplexed = 1;
+		if (am_generator)
+			got_flist_entry_status(FES_SUCCESS, val);
+		else
+			successful_send(val);
+		break;
+	case MSG_NO_SEND:
+		if (msg_bytes != 4)
+			goto invalid_msg;
+		val = raw_read_int();
+		iobuf.in_multiplexed = 1;
+		if (am_generator)
+			got_flist_entry_status(FES_NO_SEND, val);
+		else
+			send_msg_int(MSG_NO_SEND, val);
+		break;
+	case MSG_ERROR_SOCKET:
+	case MSG_ERROR_UTF8:
+	case MSG_CLIENT:
+	case MSG_LOG:
+		if (!am_generator)
+			goto invalid_msg;
+		if (tag == MSG_ERROR_SOCKET)
+			msgs2stderr = 1;
+		/* FALL THROUGH */
+	case MSG_INFO:
+	case MSG_ERROR:
+	case MSG_ERROR_XFER:
+	case MSG_WARNING:
+		if (msg_bytes >= sizeof data) {
+		    overflow:
+			rprintf(FERROR,
+				"multiplexing overflow %d:%lu [%s%s]\n",
+				tag, (unsigned long)msg_bytes, who_am_i(),
+				inc_recurse ? "/inc" : "");
+			exit_cleanup(RERR_STREAMIO);
+		}
+		raw_read_buf(data, msg_bytes);
+		/* We don't set in_multiplexed value back to 1 before writing this message
+		 * because the write might loop back and read yet another message, over and
+		 * over again, while waiting for room to put the message in the msg buffer. */
+		rwrite((enum logcode)tag, data, msg_bytes, !am_generator);
+		iobuf.in_multiplexed = 1;
+		if (first_message) {
+			if (list_only && !am_sender && tag == 1 && msg_bytes < sizeof data) {
+				data[msg_bytes] = '\0';
+				check_for_d_option_error(data);
+			}
+			first_message = 0;
+		}
+		break;
+	case MSG_ERROR_EXIT:
+		if (msg_bytes == 4)
+			val = raw_read_int();
+		else if (msg_bytes == 0)
+			val = 0;
+		else
+			goto invalid_msg;
+		iobuf.in_multiplexed = 1;
+		if (DEBUG_GTE(EXIT, 3))
+			rprintf(FINFO, "[%s] got MSG_ERROR_EXIT with %ld bytes\n", who_am_i(), (long)msg_bytes);
+		if (msg_bytes == 0) {
+			if (!am_sender && !am_generator) {
+				if (DEBUG_GTE(EXIT, 3)) {
+					rprintf(FINFO, "[%s] sending MSG_ERROR_EXIT (len 0)\n",
+						who_am_i());
+				}
+				send_msg(MSG_ERROR_EXIT, "", 0, 0);
+				io_flush(FULL_FLUSH);
 			}
-			read_loop(fd, line, msg_bytes);
-			rwrite((enum logcode)tag, line, msg_bytes, 1);
-			if (first_message) {
-				if (list_only && !am_sender && tag == 1) {
-					line[msg_bytes] = '\0';
-					check_for_d_option_error(line);
+		} else if (protocol_version >= 31) {
+			if (am_generator || am_receiver) {
+				if (DEBUG_GTE(EXIT, 3)) {
+					rprintf(FINFO, "[%s] sending MSG_ERROR_EXIT with exit_code %d\n",
+						who_am_i(), val);
 				}
-				first_message = 0;
+				send_msg_int(MSG_ERROR_EXIT, val);
+			} else {
+				if (DEBUG_GTE(EXIT, 3)) {
+					rprintf(FINFO, "[%s] sending MSG_ERROR_EXIT (len 0)\n",
+						who_am_i());
+				}
+				send_msg(MSG_ERROR_EXIT, "", 0, 0);
 			}
-			break;
-		default:
-			rprintf(FERROR, "unexpected tag %d [%s]\n",
-				tag, who_am_i());
-			exit_cleanup(RERR_STREAMIO);
 		}
+		/* Send a negative linenum so that we don't end up
+		 * with a duplicate exit message. */
+		_exit_cleanup(val, __FILE__, 0 - __LINE__);
+	default:
+		rprintf(FERROR, "unexpected tag %d [%s%s]\n",
+			tag, who_am_i(), inc_recurse ? "/inc" : "");
+		exit_cleanup(RERR_STREAMIO);
 	}
 
-	if (iobuf_in_remaining == 0)
-		io_flush(NORMAL_FLUSH);
-
-	return cnt;
+	assert(iobuf.in_multiplexed > 0);
 }
 
-/* Do a buffered read from fd.  Don't return until all N bytes have
- * been read.  If all N can't be read then exit with an error. */
-static void readfd(int fd, char *buffer, size_t N)
+static void drain_multiplex_messages(void)
 {
-	int  cnt;
-	size_t total = 0;
-
-	while (total < N) {
-		cnt = readfd_unbuffered(fd, buffer + total, N-total);
-		total += cnt;
-	}
-
-	if (fd == write_batch_monitor_in) {
-		if ((size_t)write(batch_fd, buffer, total) != total)
-			exit_cleanup(RERR_FILEIO);
+	while (IN_MULTIPLEXED_AND_READY && iobuf.in.len) {
+		if (iobuf.raw_input_ends_before) {
+			size_t raw_len = iobuf.raw_input_ends_before - iobuf.in.pos;
+			iobuf.raw_input_ends_before = 0;
+			if (raw_len >= iobuf.in.len) {
+				iobuf.in.len = 0;
+				break;
+			}
+			iobuf.in.len -= raw_len;
+			if ((iobuf.in.pos += raw_len) >= iobuf.in.size)
+				iobuf.in.pos -= iobuf.in.size;
+		}
+		read_a_msg();
 	}
+}
 
-	if (fd == flist_forward_from)
-		writefd(iobuf_f_out, buffer, total);
+void wait_for_receiver(void)
+{
+	if (!iobuf.raw_input_ends_before)
+		read_a_msg();
 
-	if (fd == sock_f_in)
-		stats.total_read += total;
+	if (iobuf.raw_input_ends_before) {
+		int ndx = read_int(iobuf.in_fd);
+		if (ndx < 0) {
+			switch (ndx) {
+			case NDX_FLIST_EOF:
+				flist_eof = 1;
+				if (DEBUG_GTE(FLIST, 3))
+					rprintf(FINFO, "[%s] flist_eof=1\n", who_am_i());
+				break;
+			case NDX_DONE:
+				msgdone_cnt++;
+				break;
+			default:
+				exit_cleanup(RERR_STREAMIO);
+			}
+		} else {
+			struct file_list *flist;
+			flist_receiving_enabled = False;
+			if (DEBUG_GTE(FLIST, 2)) {
+				rprintf(FINFO, "[%s] receiving flist for dir %d\n",
+					who_am_i(), ndx);
+			}
+			flist = recv_file_list(iobuf.in_fd);
+			flist->parent_ndx = ndx;
+#ifdef SUPPORT_HARD_LINKS
+			if (preserve_hard_links)
+				match_hard_links(flist);
+#endif
+			flist_receiving_enabled = True;
+		}
+	}
 }
 
 unsigned short read_shortint(int f)
 {
 	char b[2];
-	readfd(f, b, 2);
+	read_buf(f, b, 2);
 	return (UVAL(b, 1) << 8) + UVAL(b, 0);
 }
 
 int32 read_int(int f)
 {
 	char b[4];
 	int32 num;
 
-	readfd(f, b, 4);
+	read_buf(f, b, 4);
 	num = IVAL(b, 0);
 #if SIZEOF_INT32 > 4
 	if (num & (int32)0x80000000)
 		num |= ~(int32)0xffffffff;
 #endif
 	return num;
 }
 
 int32 read_varint(int f)
 {
 	union {
-	    char b[5];
-	    int32 x;
+		char b[5];
+		int32 x;
 	} u;
 	uchar ch;
 	int extra;
 
 	u.x = 0;
-	readfd(f, (char*)&ch, 1);
+	ch = read_byte(f);
 	extra = int_byte_extra[ch / 4];
 	if (extra) {
 		uchar bit = ((uchar)1<<(8-extra));
 		if (extra >= (int)sizeof u.b) {
 			rprintf(FERROR, "Overflow in read_varint()\n");
 			exit_cleanup(RERR_STREAMIO);
 		}
-		readfd(f, u.b, extra);
+		read_buf(f, u.b, extra);
 		u.b[extra] = ch & (bit-1);
 	} else
 		u.b[0] = ch;
 #if CAREFUL_ALIGNMENT
 	u.x = IVAL(u.b,0);
 #endif
@@ -1225,33 +1758,33 @@
 	return u.x;
 }
 
 int64 read_varlong(int f, uchar min_bytes)
 {
 	union {
-	    char b[9];
-	    int64 x;
+		char b[9];
+		int64 x;
 	} u;
 	char b2[8];
 	int extra;
 
 #if SIZEOF_INT64 < 8
 	memset(u.b, 0, 8);
 #else
 	u.x = 0;
 #endif
-	readfd(f, b2, min_bytes);
+	read_buf(f, b2, min_bytes);
 	memcpy(u.b, b2+1, min_bytes-1);
 	extra = int_byte_extra[CVAL(b2, 0) / 4];
 	if (extra) {
 		uchar bit = ((uchar)1<<(8-extra));
 		if (min_bytes + extra > (int)sizeof u.b) {
 			rprintf(FERROR, "Overflow in read_varlong()\n");
 			exit_cleanup(RERR_STREAMIO);
 		}
-		readfd(f, u.b + min_bytes - 1, extra);
+		read_buf(f, u.b + min_bytes - 1, extra);
 		u.b[min_bytes + extra - 1] = CVAL(b2, 0) & (bit-1);
 #if SIZEOF_INT64 < 8
 		if (min_bytes + extra > 5 || u.b[4] || CVAL(u.b,3) & 0x80) {
 			rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
 			exit_cleanup(RERR_UNSUPPORTED);
 		}
@@ -1277,32 +1810,70 @@
 		return num;
 
 #if SIZEOF_INT64 < 8
 	rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
 	exit_cleanup(RERR_UNSUPPORTED);
 #else
-	readfd(f, b, 8);
+	read_buf(f, b, 8);
 	return IVAL(b,0) | (((int64)IVAL(b,4))<<32);
 #endif
 }
 
 void read_buf(int f, char *buf, size_t len)
 {
-	readfd(f,buf,len);
+	if (f != iobuf.in_fd) {
+		if (safe_read(f, buf, len) != len)
+			whine_about_eof(False); /* Doesn't return. */
+		goto batch_copy;
+	}
+
+	if (!IN_MULTIPLEXED) {
+		raw_read_buf(buf, len);
+		total_data_read += len;
+		if (forward_flist_data)
+			write_buf(iobuf.out_fd, buf, len);
+	  batch_copy:
+		if (f == write_batch_monitor_in)
+			safe_write(batch_fd, buf, len);
+		return;
+	}
+
+	while (1) {
+		size_t siz;
+
+		while (!iobuf.raw_input_ends_before)
+			read_a_msg();
+
+		siz = MIN(len, iobuf.raw_input_ends_before - iobuf.in.pos);
+		if (siz >= iobuf.in.size)
+			siz = iobuf.in.size;
+		raw_read_buf(buf, siz);
+		total_data_read += siz;
+
+		if (forward_flist_data)
+			write_buf(iobuf.out_fd, buf, siz);
+
+		if (f == write_batch_monitor_in)
+			safe_write(batch_fd, buf, siz);
+
+		if ((len -= siz) == 0)
+			break;
+		buf += siz;
+	}
 }
 
 void read_sbuf(int f, char *buf, size_t len)
 {
-	readfd(f, buf, len);
+	read_buf(f, buf, len);
 	buf[len] = '\0';
 }
 
 uchar read_byte(int f)
 {
 	uchar c;
-	readfd(f, (char *)&c, 1);
+	read_buf(f, (char*)&c, 1);
 	return c;
 }
 
 int read_vstring(int f, char *buf, int bufsize)
 {
 	int len = read_byte(f);
@@ -1314,13 +1885,13 @@
 		rprintf(FERROR, "over-long vstring received (%d > %d)\n",
 			len, bufsize - 1);
 		return -1;
 	}
 
 	if (len)
-		readfd(f, buf, len);
+		read_buf(f, buf, len);
 	buf[len] = '\0';
 	return len;
 }
 
 /* Populate a sum_struct with values from the socket.  This is
  * called by both the sender and the receiver. */
@@ -1367,40 +1938,35 @@
 	write_int(f, sum->blength);
 	if (protocol_version >= 27)
 		write_int(f, sum->s2length);
 	write_int(f, sum->remainder);
 }
 
-/**
- * Sleep after writing to limit I/O bandwidth usage.
+/* Sleep after writing to limit I/O bandwidth usage.
  *
  * @todo Rather than sleeping after each write, it might be better to
  * use some kind of averaging.  The current algorithm seems to always
  * use a bit less bandwidth than specified, because it doesn't make up
  * for slow periods.  But arguably this is a feature.  In addition, we
  * ought to take the time used to write the data into account.
  *
  * During some phases of big transfers (file FOO is uptodate) this is
  * called with a small bytes_written every time.  As the kernel has to
  * round small waits up to guarantee that we actually wait at least the
  * requested number of microseconds, this can become grossly inaccurate.
  * We therefore keep track of the bytes we've written over time and only
- * sleep when the accumulated delay is at least 1 tenth of a second.
- **/
+ * sleep when the accumulated delay is at least 1 tenth of a second. */
 static void sleep_for_bwlimit(int bytes_written)
 {
 	static struct timeval prior_tv;
 	static long total_written = 0;
 	struct timeval tv, start_tv;
 	long elapsed_usec, sleep_usec;
 
 #define ONE_SEC	1000000L /* # of microseconds in a second */
 
-	if (!bwlimit_writemax)
-		return;
-
 	total_written += bytes_written;
 
 	gettimeofday(&start_tv, NULL);
 	if (prior_tv.tv_sec) {
 		elapsed_usec = (start_tv.tv_sec - prior_tv.tv_sec) * ONE_SEC
 			     + (start_tv.tv_usec - prior_tv.tv_usec);
@@ -1422,200 +1988,37 @@
 	gettimeofday(&prior_tv, NULL);
 	elapsed_usec = (prior_tv.tv_sec - start_tv.tv_sec) * ONE_SEC
 		     + (prior_tv.tv_usec - start_tv.tv_usec);
 	total_written = (sleep_usec - elapsed_usec) * bwlimit / (ONE_SEC/1024);
 }
 
-static const char *what_fd_is(int fd)
-{
-	static char buf[20];
-
-	if (fd == sock_f_out)
-		return "socket";
-	else if (fd == msg_fd_out)
-		return "message fd";
-	else if (fd == batch_fd)
-		return "batch file";
-	else {
-		snprintf(buf, sizeof buf, "fd %d", fd);
-		return buf;
-	}
-}
-
-/* Write len bytes to the file descriptor fd, looping as necessary to get
- * the job done and also (in certain circumstances) reading any data on
- * msg_fd_in to avoid deadlock.
- *
- * This function underlies the multiplexing system.  The body of the
- * application never calls this function directly. */
-static void writefd_unbuffered(int fd, const char *buf, size_t len)
-{
-	size_t n, total = 0;
-	fd_set w_fds, r_fds, e_fds;
-	int maxfd, count, cnt, using_r_fds;
-	int defer_inc = 0;
-	struct timeval tv;
-
-	if (no_flush++)
-		defer_forwarding_messages++, defer_inc++;
-
-	while (total < len) {
-		FD_ZERO(&w_fds);
-		FD_SET(fd, &w_fds);
-		FD_ZERO(&e_fds);
-		FD_SET(fd, &e_fds);
-		maxfd = fd;
-
-		if (msg_fd_in >= 0) {
-			FD_ZERO(&r_fds);
-			FD_SET(msg_fd_in, &r_fds);
-			if (msg_fd_in > maxfd)
-				maxfd = msg_fd_in;
-			using_r_fds = 1;
-		} else
-			using_r_fds = 0;
-
-		tv.tv_sec = select_timeout;
-		tv.tv_usec = 0;
-
-		errno = 0;
-		count = select(maxfd + 1, using_r_fds ? &r_fds : NULL,
-			       &w_fds, &e_fds, &tv);
-
-		if (count <= 0) {
-			if (count < 0 && errno == EBADF)
-				exit_cleanup(RERR_SOCKETIO);
-			check_timeout();
-			continue;
-		}
-
-		/*if (FD_ISSET(fd, &e_fds))
-			rprintf(FINFO, "select exception on fd %d\n", fd); */
-
-		if (using_r_fds && FD_ISSET(msg_fd_in, &r_fds))
-			read_msg_fd();
-
-		if (!FD_ISSET(fd, &w_fds))
-			continue;
-
-		n = len - total;
-		if (bwlimit_writemax && n > bwlimit_writemax)
-			n = bwlimit_writemax;
-		cnt = write(fd, buf + total, n);
-
-		if (cnt <= 0) {
-			if (cnt < 0) {
-				if (errno == EINTR)
-					continue;
-				if (errno == EWOULDBLOCK || errno == EAGAIN) {
-					msleep(1);
-					continue;
-				}
-			}
-
-			/* Don't try to write errors back across the stream. */
-			if (fd == sock_f_out)
-				io_end_multiplex_out();
-			/* Don't try to write errors down a failing msg pipe. */
-			if (am_server && fd == msg_fd_out)
-				exit_cleanup(RERR_STREAMIO);
-			rsyserr(FERROR, errno,
-				"writefd_unbuffered failed to write %ld bytes to %s [%s]",
-				(long)len, what_fd_is(fd), who_am_i());
-			/* If the other side is sending us error messages, try
-			 * to grab any messages they sent before they died. */
-			while (!am_server && fd == sock_f_out && io_multiplexing_in) {
-				char buf[1024];
-				set_io_timeout(30);
-				ignore_timeout = 0;
-				readfd_unbuffered(sock_f_in, buf, sizeof buf);
-			}
-			exit_cleanup(RERR_STREAMIO);
-		}
-
-		total += cnt;
-		defer_forwarding_messages++, defer_inc++;
-
-		if (fd == sock_f_out) {
-			if (io_timeout || am_generator)
-				last_io_out = time(NULL);
-			sleep_for_bwlimit(cnt);
-		}
-	}
-
-	no_flush--;
-	if (keep_defer_forwarding)
-		defer_inc--;
-	if (!(defer_forwarding_messages -= defer_inc) && !no_flush)
-		msg_flush();
-}
-
-int io_flush(int flush_it_all)
-{
-	int flushed_something = 0;
-
-	if (no_flush)
-		return 0;
-
-	if (iobuf_out_cnt) {
-		if (io_multiplexing_out)
-			mplex_write(sock_f_out, MSG_DATA, iobuf_out, iobuf_out_cnt, 0);
-		else
-			writefd_unbuffered(iobuf_f_out, iobuf_out, iobuf_out_cnt);
-		iobuf_out_cnt = 0;
-		flushed_something = 1;
-	}
-
-	if (flush_it_all && !defer_forwarding_messages && msg_queue.head) {
-		msg_flush();
-		flushed_something = 1;
-	}
-
-	return flushed_something;
-}
-
-static void writefd(int fd, const char *buf, size_t len)
+void io_flush(int flush_it_all)
 {
-	if (fd == sock_f_out)
-		stats.total_written += len;
-
-	if (fd == write_batch_monitor_out)
-		writefd_unbuffered(batch_fd, buf, len);
-
-	if (!iobuf_out || fd != iobuf_f_out) {
-		writefd_unbuffered(fd, buf, len);
-		return;
-	}
-
-	while (len) {
-		int n = MIN((int)len, IO_BUFFER_SIZE - iobuf_out_cnt);
-		if (n > 0) {
-			memcpy(iobuf_out+iobuf_out_cnt, buf, n);
-			buf += n;
-			len -= n;
-			iobuf_out_cnt += n;
-		}
-
-		if (iobuf_out_cnt == IO_BUFFER_SIZE)
-			io_flush(NORMAL_FLUSH);
+	if (iobuf.out.len > iobuf.out_empty_len) {
+		if (flush_it_all) /* FULL_FLUSH: flush everything in the output buffers */
+			perform_io(iobuf.out.size - iobuf.out_empty_len, PIO_NEED_OUTROOM);
+		else /* NORMAL_FLUSH: flush at least 1 byte */
+			perform_io(iobuf.out.size - iobuf.out.len + 1, PIO_NEED_OUTROOM);
 	}
+	if (iobuf.msg.len)
+		perform_io(iobuf.msg.size, PIO_NEED_MSGROOM);
 }
 
 void write_shortint(int f, unsigned short x)
 {
 	char b[2];
 	b[0] = (char)x;
 	b[1] = (char)(x >> 8);
-	writefd(f, b, 2);
+	write_buf(f, b, 2);
 }
 
 void write_int(int f, int32 x)
 {
 	char b[4];
 	SIVAL(b, 0, x);
-	writefd(f, b, 4);
+	write_buf(f, b, 4);
 }
 
 void write_varint(int f, int32 x)
 {
 	char b[5];
 	uchar bit;
@@ -1631,13 +2034,13 @@
 		*b = ~(bit-1);
 	} else if (cnt > 1)
 		*b = b[cnt] | ~(bit*2-1);
 	else
 		*b = b[cnt];
 
-	writefd(f, b, cnt);
+	write_buf(f, b, cnt);
 }
 
 void write_varlong(int f, int64 x, uchar min_bytes)
 {
 	char b[9];
 	uchar bit;
@@ -1663,53 +2066,79 @@
 		*b = ~(bit-1);
 	} else if (cnt > min_bytes)
 		*b = b[cnt] | ~(bit*2-1);
 	else
 		*b = b[cnt];
 
-	writefd(f, b, cnt);
+	write_buf(f, b, cnt);
 }
 
 /*
  * Note: int64 may actually be a 32-bit type if ./configure couldn't find any
  * 64-bit types on this platform.
  */
 void write_longint(int f, int64 x)
 {
 	char b[12], * const s = b+4;
 
 	SIVAL(s, 0, x);
 	if (x <= 0x7FFFFFFF && x >= 0) {
-		writefd(f, s, 4);
+		write_buf(f, s, 4);
 		return;
 	}
 
 #if SIZEOF_INT64 < 8
 	rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
 	exit_cleanup(RERR_UNSUPPORTED);
 #else
 	memset(b, 0xFF, 4);
 	SIVAL(s, 4, x >> 32);
-	writefd(f, b, 12);
+	write_buf(f, b, 12);
 #endif
 }
 
 void write_buf(int f, const char *buf, size_t len)
 {
-	writefd(f,buf,len);
+	size_t pos, siz;
+
+	if (f != iobuf.out_fd) {
+		safe_write(f, buf, len);
+		goto batch_copy;
+	}
+
+	if (iobuf.out.len + len > iobuf.out.size)
+		perform_io(len, PIO_NEED_OUTROOM);
+
+	pos = iobuf.out.pos + iobuf.out.len; /* Must be set after any flushing. */
+	if (pos >= iobuf.out.size)
+		pos -= iobuf.out.size;
+
+	/* Handle a split copy if we wrap around the end of the circular buffer. */
+	if (pos >= iobuf.out.pos && (siz = iobuf.out.size - pos) < len) {
+		memcpy(iobuf.out.buf + pos, buf, siz);
+		memcpy(iobuf.out.buf, buf + siz, len - siz);
+	} else
+		memcpy(iobuf.out.buf + pos, buf, len);
+
+	iobuf.out.len += len;
+	total_data_written += len;
+
+  batch_copy:
+	if (f == write_batch_monitor_out)
+		safe_write(batch_fd, buf, len);
 }
 
-/** Write a string to the connection */
+/* Write a string to the connection */
 void write_sbuf(int f, const char *buf)
 {
-	writefd(f, buf, strlen(buf));
+	write_buf(f, buf, strlen(buf));
 }
 
 void write_byte(int f, uchar c)
 {
-	writefd(f, (char *)&c, 1);
+	write_buf(f, (char *)&c, 1);
 }
 
 void write_vstring(int f, const char *str, int len)
 {
 	uchar lenbuf[3], *lb = lenbuf;
 
@@ -1721,15 +2150,15 @@
 			exit_cleanup(RERR_PROTOCOL);
 		}
 		*lb++ = len / 0x100 + 0x80;
 	}
 	*lb = len;
 
-	writefd(f, (char*)lenbuf, lb - lenbuf + 1);
+	write_buf(f, (char*)lenbuf, lb - lenbuf + 1);
 	if (len)
-		writefd(f, str, len);
+		write_buf(f, str, len);
 }
 
 /* Send a file-list index using a byte-reduction method. */
 void write_ndx(int f, int32 ndx)
 {
 	static int32 prev_positive = -1, prev_negative = 1;
@@ -1745,13 +2174,13 @@
 	 * negative nums as a positive after sending a leading 0xFF. */
 	if (ndx >= 0) {
 		diff = ndx - prev_positive;
 		prev_positive = ndx;
 	} else if (ndx == NDX_DONE) {
 		*b = 0;
-		writefd(f, b, 1);
+		write_buf(f, b, 1);
 		return;
 	} else {
 		b[cnt++] = (char)0xFF;
 		ndx = -ndx;
 		diff = ndx - prev_negative;
 		prev_negative = ndx;
@@ -1770,39 +2199,39 @@
 		b[cnt++] = (char)(ndx >> 16);
 	} else {
 		b[cnt++] = (char)0xFE;
 		b[cnt++] = (char)(diff >> 8);
 		b[cnt++] = (char)diff;
 	}
-	writefd(f, b, cnt);
+	write_buf(f, b, cnt);
 }
 
 /* Receive a file-list index using a byte-reduction method. */
 int32 read_ndx(int f)
 {
 	static int32 prev_positive = -1, prev_negative = 1;
 	int32 *prev_ptr, num;
 	char b[4];
 
 	if (protocol_version < 30)
 		return read_int(f);
 
-	readfd(f, b, 1);
+	read_buf(f, b, 1);
 	if (CVAL(b, 0) == 0xFF) {
-		readfd(f, b, 1);
+		read_buf(f, b, 1);
 		prev_ptr = &prev_negative;
 	} else if (CVAL(b, 0) == 0)
 		return NDX_DONE;
 	else
 		prev_ptr = &prev_positive;
 	if (CVAL(b, 0) == 0xFE) {
-		readfd(f, b, 2);
+		read_buf(f, b, 2);
 		if (CVAL(b, 0) & 0x80) {
 			b[3] = CVAL(b, 0) & ~0x80;
 			b[0] = b[1];
-			readfd(f, b+1, 2);
+			read_buf(f, b+1, 2);
 			num = IVAL(b, 0);
 		} else
 			num = (UVAL(b,0)<<8) + UVAL(b,1) + *prev_ptr;
 	} else
 		num = UVAL(b, 0) + *prev_ptr;
 	*prev_ptr = num;
@@ -1811,23 +2240,27 @@
 	return num;
 }
 
 /* Read a line of up to bufsiz-1 characters into buf.  Strips
  * the (required) trailing newline and all carriage returns.
  * Returns 1 for success; 0 for I/O error or truncation. */
-int read_line_old(int f, char *buf, size_t bufsiz)
+int read_line_old(int fd, char *buf, size_t bufsiz, int eof_ok)
 {
+	assert(fd != iobuf.in_fd);
 	bufsiz--; /* leave room for the null */
 	while (bufsiz > 0) {
-		buf[0] = 0;
-		read_buf(f, buf, 1);
-		if (buf[0] == 0)
+		if (safe_read(fd, buf, 1) == 0) {
+			if (eof_ok)
+				break;
 			return 0;
-		if (buf[0] == '\n')
+		}
+		if (*buf == '\0')
+			return 0;
+		if (*buf == '\n')
 			break;
-		if (buf[0] != '\r') {
+		if (*buf != '\r') {
 			buf++;
 			bufsiz--;
 		}
 	}
 	*buf = '\0';
 	return bufsiz > 0;
@@ -1841,60 +2274,88 @@
 
 	va_start(ap, format);
 	len = vsnprintf(buf, sizeof buf, format, ap);
 	va_end(ap);
 
 	if (len < 0)
-		exit_cleanup(RERR_STREAMIO);
+		exit_cleanup(RERR_PROTOCOL);
 
 	if (len > (int)sizeof buf) {
 		rprintf(FERROR, "io_printf() was too long for the buffer.\n");
-		exit_cleanup(RERR_STREAMIO);
+		exit_cleanup(RERR_PROTOCOL);
 	}
 
 	write_sbuf(fd, buf);
 }
 
-/** Setup for multiplexing a MSG_* stream with the data stream. */
-void io_start_multiplex_out(void)
+/* Setup for multiplexing a MSG_* stream with the data stream. */
+void io_start_multiplex_out(int fd)
 {
-	io_flush(NORMAL_FLUSH);
-	io_start_buffering_out(sock_f_out);
-	io_multiplexing_out = 1;
-}
+	io_flush(FULL_FLUSH);
 
-/** Setup for multiplexing a MSG_* stream with the data stream. */
-void io_start_multiplex_in(void)
-{
-	io_flush(NORMAL_FLUSH);
-	io_start_buffering_in(sock_f_in);
-	io_multiplexing_in = 1;
+	if (msgs2stderr && DEBUG_GTE(IO, 2))
+		rprintf(FINFO, "[%s] io_start_multiplex_out(%d)\n", who_am_i(), fd);
+
+	if (!iobuf.msg.buf)
+		alloc_xbuf(&iobuf.msg, ROUND_UP_1024(IO_BUFFER_SIZE));
+
+	iobuf.out_empty_len = 4; /* See also OUT_MULTIPLEXED */
+	io_start_buffering_out(fd);
+	got_kill_signal = 0;
+
+	iobuf.raw_data_header_pos = iobuf.out.pos + iobuf.out.len;
+	iobuf.out.len += 4;
 }
 
-/** Write an message to the multiplexed data stream. */
-int io_multiplex_write(enum msgcode code, const char *buf, size_t len, int convert)
+/* Setup for multiplexing a MSG_* stream with the data stream. */
+void io_start_multiplex_in(int fd)
 {
-	if (!io_multiplexing_out)
-		return 0;
-	io_flush(NORMAL_FLUSH);
-	stats.total_written += (len+4);
-	mplex_write(sock_f_out, code, buf, len, convert);
-	return 1;
+	if (msgs2stderr && DEBUG_GTE(IO, 2))
+		rprintf(FINFO, "[%s] io_start_multiplex_in(%d)\n", who_am_i(), fd);
+
+	iobuf.in_multiplexed = 1; /* See also IN_MULTIPLEXED */
+	io_start_buffering_in(fd);
 }
 
-void io_end_multiplex_in(void)
+int io_end_multiplex_in(int mode)
 {
-	io_multiplexing_in = 0;
-	io_end_buffering_in();
+	int ret = iobuf.in_multiplexed ? iobuf.in_fd : -1;
+
+	if (msgs2stderr && DEBUG_GTE(IO, 2))
+		rprintf(FINFO, "[%s] io_end_multiplex_in(mode=%d)\n", who_am_i(), mode);
+
+	iobuf.in_multiplexed = 0;
+	if (mode == MPLX_SWITCHING)
+		iobuf.raw_input_ends_before = 0;
+	else
+		assert(iobuf.raw_input_ends_before == 0);
+	if (mode != MPLX_TO_BUFFERED)
+		io_end_buffering_in(mode);
+
+	return ret;
 }
 
-/** Stop output multiplexing. */
-void io_end_multiplex_out(void)
+int io_end_multiplex_out(int mode)
 {
-	io_multiplexing_out = 0;
-	io_end_buffering_out();
+	int ret = iobuf.out_empty_len ? iobuf.out_fd : -1;
+
+	if (msgs2stderr && DEBUG_GTE(IO, 2))
+		rprintf(FINFO, "[%s] io_end_multiplex_out(mode=%d)\n", who_am_i(), mode);
+
+	if (mode != MPLX_TO_BUFFERED)
+		io_end_buffering_out(mode);
+	else
+		io_flush(FULL_FLUSH);
+
+	iobuf.out.len = 0;
+	iobuf.out_empty_len = 0;
+	if (got_kill_signal > 0) /* Just in case... */
+		handle_kill_signal(False);
+	got_kill_signal = -1;
+
+	return ret;
 }
 
 void start_write_batch(int fd)
 {
 	/* Some communication has already taken place, but we don't
 	 * enable batch writing until here so that we can write a
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/io.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/io.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/io.h	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/io.h	2013-01-20 03:05:53.000000000 +0800
@@ -1,8 +1,8 @@
 /*
- * Copyright (C) 2007-2008 Wayne Davison
+ * Copyright (C) 2007-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0: itypes.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/compat.c	2007-07-10 21:55:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/compat.c	2013-06-12 04:28:45.000000000 +0800
@@ -17,12 +17,15 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "itypes.h"
+
+static char number_separator;
 
 #ifndef HAVE_STRDUP
  char *strdup(char *s)
 {
 	int len = strlen(s) + 1;
 	char *ret = (char *)malloc(len);
@@ -148,6 +151,125 @@
 #ifdef HAVE_GETTIMEOFDAY_TZ
 	return gettimeofday(tv, NULL);
 #else
 	return gettimeofday(tv);
 #endif
 }
+
+#define HUMANIFY(mult) \
+	do { \
+		if (num >= mult || num <= -mult) { \
+			double dnum = (double)num / mult; \
+			char units; \
+			if (num < 0) \
+				dnum = -dnum; \
+			if (dnum < mult) \
+				units = 'K'; \
+			else if ((dnum /= mult) < mult) \
+				units = 'M'; \
+			else if ((dnum /= mult) < mult) \
+				units = 'G'; \
+			else { \
+				dnum /= mult; \
+				units = 'T'; \
+			} \
+			if (num < 0) \
+				dnum = -dnum; \
+			snprintf(bufs[n], sizeof bufs[0], "%.2f%c", dnum, units); \
+			return bufs[n]; \
+		} \
+	} while (0)
+
+/* Return the int64 number as a string.  If the human_flag arg is non-zero,
+ * we may output the number in K, M, G, or T units.  If we don't add a unit
+ * suffix, we will append the fract string, if it is non-NULL.  We can
+ * return up to 4 buffers at a time. */
+char *do_big_num(int64 num, int human_flag, const char *fract)
+{
+	static char bufs[4][128]; /* more than enough room */
+	static unsigned int n;
+	char *s;
+	int len, negated;
+
+	if (human_flag && !number_separator) {
+		char buf[32];
+		snprintf(buf, sizeof buf, "%f", 3.14);
+		if (strchr(buf, '.') != NULL)
+			number_separator = ',';
+		else
+			number_separator = '.';
+	}
+
+	n = (n + 1) % (sizeof bufs / sizeof bufs[0]);
+
+	if (human_flag > 1) {
+		if (human_flag == 2)
+			HUMANIFY(1000);
+		else
+			HUMANIFY(1024);
+	}
+
+	s = bufs[n] + sizeof bufs[0] - 1;
+	if (fract) {
+		len = strlen(fract);
+		s -= len;
+		strlcpy(s, fract, len + 1);
+	} else
+		*s = '\0';
+
+	len = 0;
+
+	if (!num)
+		*--s = '0';
+	if (num < 0) {
+		/* A maximum-size negated number can't fit as a positive,
+		 * so do one digit in negated form to start us off. */
+		*--s = (char)(-(num % 10)) + '0';
+		num = -(num / 10);
+		len++;
+		negated = 1;
+	} else
+		negated = 0;
+
+	while (num) {
+		if (human_flag) {
+			if (len == 3) {
+				*--s = number_separator;
+				len = 1;
+			} else
+				len++;
+		}
+		*--s = (char)(num % 10) + '0';
+		num /= 10;
+	}
+
+	if (negated)
+		*--s = '-';
+
+	return s;
+}
+
+/* Return the double number as a string.  If the human_flag option is > 1,
+ * we may output the number in K, M, G, or T units.  The buffer we use for
+ * our result is either a single static buffer defined here, or a buffer
+ * we get from do_big_num(). */
+char *do_big_dnum(double dnum, int human_flag, int decimal_digits)
+{
+	static char tmp_buf[128];
+#if SIZEOF_INT64 >= 8
+	char *fract;
+
+	snprintf(tmp_buf, sizeof tmp_buf, "%.*f", decimal_digits, dnum);
+
+	if (!human_flag || (dnum < 1000.0 && dnum > -1000.0))
+		return tmp_buf;
+
+	for (fract = tmp_buf+1; isDigit(fract); fract++) {}
+
+	return do_big_num((int64)dnum, human_flag, fract);
+#else
+	/* A big number might lose digits converting to a too-short int64,
+	 * so let's just return the raw double conversion. */
+	snprintf(tmp_buf, sizeof tmp_buf, "%.*f", decimal_digits, dnum);
+	return tmp_buf;
+#endif
+}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib: getpass.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/pool_alloc.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/pool_alloc.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/pool_alloc.3	2007-05-29 12:19:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/pool_alloc.3	2008-07-20 00:20:56.000000000 +0800
@@ -92,31 +92,45 @@
 Specifying
 .B 0
 for
 .I quantum
 will produce a quantum that should meet maximal alignment
 on most platforms.
-If
-.B POOL_QALIGN
+Unless
+.B POOL_NO_QALIGN
 is set in the
 .IR flags ,
 allocations will be aligned to addresses that are a
 multiple of
 .IR quantum .
+A
+.B NULL
+may be specified for the
+.I bomb
+function pointer if it is not needed.  (See the
+.B pool_alloc()
+function for how it is used.)
 If
 .B POOL_CLEAR
 is set in the
 .IR flags ,
 all allocations from the pool will be initialized to zeros.
-You may specify a
-.B NULL
-for the
-.I bomb
-function pointer if you don't wish to use it.  (See the
-.B pool_alloc()
-function for how it is used.)
+If either
+.B POOL_PREPEND
+or
+.B POOL_INTERN
+is specified in the
+.IR flags ,
+each extent's data structure will be allocated at the start of the
+.IR size -length
+buffer (rather than as a separate, non-pool allocation), with the
+former extending the
+.I size
+to hold the structure, and the latter subtracting the structure's
+length from the indicated
+.IR size .
 .P
 .B pool_destroy()
 destroys an allocation
 .I pool
 and frees all its associated memory.
 .P
@@ -128,14 +142,14 @@
 If
 .I size
 is
 .BR 0 ,
 .I quantum
 bytes will be allocated.
-If the pool has been created with
-.BR POOL_QALIGN ,
+If the pool has been created without
+.BR POOL_NO_QALIGN ,
 every chunk of memory that is returned will be suitably aligned.
 You can use this with the default
 .I quantum
 size to ensure that all memory can store a variable of any type.
 If the requested memory cannot be allocated, the
 .I bomb()
@@ -166,13 +180,13 @@
 If enough free calls are made to indicate that an extent has no
 remaining allocated objects (as computed by the total freed size for
 an extent), its memory will be completely freed back to the system.
 If
 .I addr
 is
-.BR 0 ,
+.BR NULL ,
 no memory will be freed, but subsequent allocations will come
 from a new extent.
 .P
 .B pool_free_old()
 takes a boundary
 .I addr
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/pool_alloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/pool_alloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/pool_alloc.c	2008-11-10 10:55:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/pool_alloc.c	2008-11-10 10:56:21.000000000 +0800
@@ -1,86 +1,116 @@
 #include "rsync.h"
 
 #define POOL_DEF_EXTENT	(32 * 1024)
 
+#define POOL_QALIGN_P2		(1<<16)		/* power-of-2 qalign	*/
+
 struct alloc_pool
 {
 	size_t			size;		/* extent size		*/
 	size_t			quantum;	/* allocation quantum	*/
 	struct pool_extent	*extents;	/* top extent is "live" */
 	void			(*bomb)();	/* function to call if
 						 * malloc fails		*/
 	int			flags;
 
 	/* statistical data */
 	unsigned long		e_created;	/* extents created	*/
-	unsigned long		e_freed;	/* extents detroyed	*/
+	unsigned long		e_freed;	/* extents destroyed	*/
 	int64			n_allocated;	/* calls to alloc	*/
 	int64			n_freed;	/* calls to free	*/
 	int64			b_allocated;	/* cum. bytes allocated	*/
 	int64			b_freed;	/* cum. bytes freed	*/
 };
 
 struct pool_extent
 {
+	struct pool_extent	*next;
 	void			*start;		/* starting address	*/
 	size_t			free;		/* free bytecount	*/
-	size_t			bound;		/* bytes bound by padding,
-						 * overhead and freed	*/
-	struct pool_extent	*next;
+	size_t			bound;		/* trapped free bytes	*/
 };
 
 struct align_test {
-	void *foo;
-	int64 bar;
+	uchar foo;
+	union {
+	    int64 i;
+	    void *p;
+	} bar;
 };
 
 #define MINALIGN	offsetof(struct align_test, bar)
 
 /* Temporarily cast a void* var into a char* var when adding an offset (to
  * keep some compilers from complaining about the pointer arithmetic). */
 #define PTR_ADD(b,o)	( (void*) ((char*)(b) + (o)) )
 
 alloc_pool_t
 pool_create(size_t size, size_t quantum, void (*bomb)(const char *), int flags)
 {
-	struct alloc_pool	*pool;
+	struct alloc_pool *pool;
+
+	if (!(pool = new0(struct alloc_pool)))
+		return NULL;
+
+	if ((MINALIGN & (MINALIGN - 1)) != 0) {
+		if (bomb)
+			(*bomb)("Compiler error: MINALIGN is not a power of 2\n");
+		return NULL;
+	}
+
+	if (!size)
+		size = POOL_DEF_EXTENT;
+	if (!quantum)
+		quantum = MINALIGN;
 
-	if (!(pool = new(struct alloc_pool)))
-		return pool;
-	memset(pool, 0, sizeof (struct alloc_pool));
-
-	pool->size = size	/* round extent size to min alignment reqs */
-	    ? (size + MINALIGN - 1) & ~(MINALIGN - 1)
-	    : POOL_DEF_EXTENT;
 	if (flags & POOL_INTERN) {
-		pool->size -= sizeof (struct pool_extent);
-		flags |= POOL_APPEND;
+		if (size <= sizeof (struct pool_extent))
+			size = quantum;
+		else
+			size -= sizeof (struct pool_extent);
+		flags |= POOL_PREPEND;
+	}
+
+	if (quantum <= 1)
+		flags = (flags | POOL_NO_QALIGN) & ~POOL_QALIGN_P2;
+	else if (!(flags & POOL_NO_QALIGN)) {
+		if (size % quantum)
+			size += quantum - size % quantum;
+		/* If quantum is a power of 2, we'll avoid using modulus. */
+		if (!(quantum & (quantum - 1)))
+			flags |= POOL_QALIGN_P2;
 	}
-	pool->quantum = quantum ? quantum : MINALIGN;
+
+	pool->size = size;
+	pool->quantum = quantum;
 	pool->bomb = bomb;
 	pool->flags = flags;
 
 	return pool;
 }
 
 void
 pool_destroy(alloc_pool_t p)
 {
 	struct alloc_pool *pool = (struct alloc_pool *) p;
-	struct pool_extent	*cur, *next;
+	struct pool_extent *cur, *next;
 
 	if (!pool)
 		return;
 
 	for (cur = pool->extents; cur; cur = next) {
 		next = cur->next;
-		free(cur->start);
-		if (!(pool->flags & POOL_APPEND))
+		if (pool->flags & POOL_PREPEND)
+			free(PTR_ADD(cur->start, -sizeof (struct pool_extent)));
+		else {
+			free(cur->start);
 			free(cur);
+		}
 	}
+
 	free(pool);
 }
 
 void *
 pool_alloc(alloc_pool_t p, size_t len, const char *bomb_msg)
 {
@@ -87,51 +117,46 @@
 	struct alloc_pool *pool = (struct alloc_pool *) p;
 	if (!pool)
 		return NULL;
 
 	if (!len)
 		len = pool->quantum;
-	else if (pool->quantum > 1 && len % pool->quantum)
-		len += pool->quantum - len % pool->quantum;
+	else if (pool->flags & POOL_QALIGN_P2) {
+		if (len & (pool->quantum - 1))
+			len += pool->quantum - (len & (pool->quantum - 1));
+	} else if (!(pool->flags & POOL_NO_QALIGN)) {
+		if (len % pool->quantum)
+			len += pool->quantum - len % pool->quantum;
+	}
 
 	if (len > pool->size)
 		goto bomb_out;
 
 	if (!pool->extents || len > pool->extents->free) {
-		void	*start;
-		size_t	free;
-		size_t	bound;
-		size_t	skew;
-		size_t	asize;
+		void *start;
+		size_t asize;
 		struct pool_extent *ext;
 
-		free = pool->size;
-		bound = 0;
-
 		asize = pool->size;
-		if (pool->flags & POOL_APPEND)
+		if (pool->flags & POOL_PREPEND)
 			asize += sizeof (struct pool_extent);
 
 		if (!(start = new_array(char, asize)))
 			goto bomb_out;
 
 		if (pool->flags & POOL_CLEAR)
-			memset(start, 0, free);
+			memset(start, 0, asize);
 
-		if (pool->flags & POOL_APPEND)
-			ext = PTR_ADD(start, free);
-		else if (!(ext = new(struct pool_extent)))
+		if (pool->flags & POOL_PREPEND) {
+			ext = start;
+			start = PTR_ADD(start, sizeof (struct pool_extent));
+		} else if (!(ext = new(struct pool_extent)))
 			goto bomb_out;
-		if (pool->flags & POOL_QALIGN && pool->quantum > 1
-		    && (skew = (size_t)PTR_ADD(start, free) % pool->quantum)) {
-			bound  += skew;
-			free -= skew;
-		}
 		ext->start = start;
-		ext->free = free;
-		ext->bound = bound;
+		ext->free = pool->size;
+		ext->bound = 0;
 		ext->next = pool->extents;
 		pool->extents = ext;
 
 		pool->e_created++;
 	}
 
@@ -157,16 +182,30 @@
 	struct alloc_pool *pool = (struct alloc_pool *)p;
 	struct pool_extent *cur, *prev;
 
 	if (!pool)
 		return;
 
+	if (!addr) {
+		/* A NULL addr starts a fresh extent for new allocations. */
+		if ((cur = pool->extents) != NULL && cur->free != pool->size) {
+			cur->bound += cur->free;
+			cur->free = 0;
+		}
+		return;
+	}
+
 	if (!len)
 		len = pool->quantum;
-	else if (pool->quantum > 1 && len % pool->quantum)
-		len += pool->quantum - len % pool->quantum;
+	else if (pool->flags & POOL_QALIGN_P2) {
+		if (len & (pool->quantum - 1))
+			len += pool->quantum - (len & (pool->quantum - 1));
+	} else if (!(pool->flags & POOL_NO_QALIGN)) {
+		if (len % pool->quantum)
+			len += pool->quantum - len % pool->quantum;
+	}
 
 	pool->n_freed++;
 	pool->b_freed += len;
 
 	for (prev = NULL, cur = pool->extents; cur; prev = cur, cur = cur->next) {
 		if (addr >= cur->start
@@ -176,39 +215,35 @@
 	if (!cur)
 		return;
 
 	if (!prev) {
 		/* The "live" extent is kept ready for more allocations. */
 		if (cur->free + cur->bound + len >= pool->size) {
-			size_t skew;
-
 			if (pool->flags & POOL_CLEAR) {
 				memset(PTR_ADD(cur->start, cur->free), 0,
 				       pool->size - cur->free);
 			}
 			cur->free = pool->size;
 			cur->bound = 0;
-			if (pool->flags & POOL_QALIGN && pool->quantum > 1
-			    && (skew = (size_t)PTR_ADD(cur->start, cur->free) % pool->quantum)) {
-				cur->bound += skew;
-				cur->free -= skew;
-			}
 		} else if (addr == PTR_ADD(cur->start, cur->free)) {
 			if (pool->flags & POOL_CLEAR)
 				memset(addr, 0, len);
 			cur->free += len;
 		} else
 			cur->bound += len;
 	} else {
 		cur->bound += len;
 
 		if (cur->free + cur->bound >= pool->size) {
 			prev->next = cur->next;
-			free(cur->start);
-			if (!(pool->flags & POOL_APPEND))
+			if (pool->flags & POOL_PREPEND)
+				free(PTR_ADD(cur->start, -sizeof (struct pool_extent)));
+			else {
+				free(cur->start);
 				free(cur);
+			}
 			pool->e_freed++;
 		} else if (prev != pool->extents) {
 			/* Move the extent to be the first non-live extent. */
 			prev->next = cur->next;
 			cur->next = pool->extents->next;
 			pool->extents->next = cur;
@@ -239,37 +274,33 @@
 
 	if (addr == PTR_ADD(cur->start, cur->free)) {
 		if (prev) {
 			prev->next = NULL;
 			next = cur;
 		} else {
-			size_t skew;
-
 			/* The most recent live extent can just be reset. */
 			if (pool->flags & POOL_CLEAR)
 				memset(addr, 0, pool->size - cur->free);
 			cur->free = pool->size;
 			cur->bound = 0;
-			if (pool->flags & POOL_QALIGN && pool->quantum > 1
-			    && (skew = (size_t)PTR_ADD(cur->start, cur->free) % pool->quantum)) {
-				cur->bound += skew;
-				cur->free -= skew;
-			}
 			next = cur->next;
 			cur->next = NULL;
 		}
 	} else {
 		next = cur->next;
 		cur->next = NULL;
 	}
 
 	while ((cur = next) != NULL) {
 		next = cur->next;
-		free(cur->start);
-		if (!(pool->flags & POOL_APPEND))
+		if (pool->flags & POOL_PREPEND)
+			free(PTR_ADD(cur->start, -sizeof (struct pool_extent)));
+		else {
+			free(cur->start);
 			free(cur);
+		}
 		pool->e_freed++;
 	}
 }
 
 /* If the current extent doesn't have "len" free space in it, mark it as full
  * so that the next alloc will start a new extent.  If len is (size_t)-1, this
@@ -310,13 +341,13 @@
 	} while (0)
 
 int
 pool_stats(alloc_pool_t p, int fd, int summarize)
 {
 	struct alloc_pool *pool = (struct alloc_pool *) p;
-	struct pool_extent	*cur;
+	struct pool_extent *cur;
 	char buf[BUFSIZ];
 	int ret = 0;
 
 	if (!pool)
 		return ret;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/pool_alloc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/pool_alloc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/pool_alloc.h	2007-05-29 12:19:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/pool_alloc.h	2008-07-20 00:20:56.000000000 +0800
@@ -1,12 +1,12 @@
 #include <stddef.h>
 
 #define POOL_CLEAR	(1<<0)		/* zero fill allocations	*/
-#define POOL_QALIGN	(1<<1)		/* align data to quanta		*/
+#define POOL_NO_QALIGN	(1<<1)		/* don't align data to quanta	*/
 #define POOL_INTERN	(1<<2)		/* Allocate extent structures	*/
-#define POOL_APPEND	(1<<3)		/*   or appended to extent data	*/
+#define POOL_PREPEND	(1<<3)		/*   or prepend to extent data	*/
 
 typedef void *alloc_pool_t;
 
 alloc_pool_t pool_create(size_t size, size_t quantum, void (*bomb)(const char *), int flags);
 void pool_destroy(alloc_pool_t pool);
 void *pool_alloc(alloc_pool_t pool, size_t size, const char *bomb_msg);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/snprintf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/snprintf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/snprintf.c	2005-10-12 04:21:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/snprintf.c	2011-08-01 14:31:24.000000000 +0800
@@ -34,13 +34,13 @@
  *    probably requires libm on most operating systems.  Don't yet
  *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
  *    was pretty badly broken, it just wasn't being exercised in ways
  *    which showed it, so that's been fixed.  Also, formated the code
  *    to mutt conventions, and removed dead code left over from the
  *    original.  Also, there is now a builtin-test, just compile with:
- *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
+ *           gcc -I.. -DTEST_SNPRINTF -o snprintf snprintf.c -lm
  *    and run snprintf for results.
  * 
  *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
  *    The PGP code was using unsigned hexadecimal formats. 
  *    Unfortunately, unsigned formats simply didn't work.
  *
@@ -86,19 +86,27 @@
  *
  * Martin Pool (mbp@samba.org) May 2003
  *    Put in a prototype for dummy_snprintf() to quiet compiler warnings.
  *
  *    Move #endif to make sure VA_COPY, LDOUBLE, etc are defined even
  *    if the C library has some snprintf functions already.
+ *
+ * Darren Tucker (dtucker@zip.com.au) 2005
+ *    Fix bug allowing read overruns of the source string with "%.*s"
+ *    Usually harmless unless the read runs outside the process' allocation
+ *    (eg if your malloc does guard pages) in which case it will segfault.
+ *    From OpenSSH.  Also added test for same.
+ *
+ * Simo Sorce (idra@samba.org) Jan 2006
+ * 
+ *    Add support for position independent parameters 
+ *    fix fmtstr now it conforms to sprintf wrt min.max
+ *
  **************************************************************/
 
-#ifndef NO_CONFIG_H
 #include "config.h"
-#else
-#define NULL 0
-#endif 
 
 #ifdef TEST_SNPRINTF /* need math library headers for testing */
 
 /* In test mode, we pretend that this system doesn't have any snprintf
  * functions, regardless of what config.h says. */
 #  undef HAVE_SNPRINTF
@@ -130,19 +138,26 @@
 #include <stdio.h>
  /* make the compiler happy with an empty file */
  void dummy_snprintf(void);
  void dummy_snprintf(void) {} 
 #endif /* HAVE_SNPRINTF, etc */
 
+#ifdef STDC_HEADERS
+#include <stddef.h>
+#endif
+
 #ifdef HAVE_LONG_DOUBLE
 #define LDOUBLE long double
 #else
 #define LDOUBLE double
 #endif
 
-#if SIZEOF_LONG_LONG
+#if !defined HAVE_LONG_LONG && SIZEOF_LONG_LONG
+#define HAVE_LONG_LONG 1
+#endif
+#ifdef HAVE_LONG_LONG
 #define LLONG long long
 #else
 #define LLONG long
 #endif
 
 #ifndef VA_COPY
@@ -152,12 +167,16 @@
 #ifdef HAVE___VA_COPY
 #define VA_COPY(dest, src) __va_copy(dest, src)
 #else
 #define VA_COPY(dest, src) (dest) = (src)
 #endif
 #endif
+#endif
+
+/* yes this really must be a ||. Don't muck with this (tridge) */
+#if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
 
 /*
  * dopr(): poor man's version of doprintf
  */
 
 /* format read states */
@@ -177,104 +196,205 @@
 #define DP_F_NUM   	(1 << 3)
 #define DP_F_ZERO  	(1 << 4)
 #define DP_F_UP    	(1 << 5)
 #define DP_F_UNSIGNED 	(1 << 6)
 
 /* Conversion Flags */
-#define DP_C_SHORT   1
-#define DP_C_LONG    2
-#define DP_C_LDOUBLE 3
-#define DP_C_LLONG   4
+#define DP_C_CHAR    1
+#define DP_C_SHORT   2
+#define DP_C_LONG    3
+#define DP_C_LDOUBLE 4
+#define DP_C_LLONG   5
+#define DP_C_SIZET   6
+
+/* Chunk types */
+#define CNK_FMT_STR 0
+#define CNK_INT     1
+#define CNK_OCTAL   2
+#define CNK_UINT    3
+#define CNK_HEX     4
+#define CNK_FLOAT   5
+#define CNK_CHAR    6
+#define CNK_STRING  7
+#define CNK_PTR     8
+#define CNK_NUM     9
+#define CNK_PRCNT   10
 
 #define char_to_int(p) ((p)- '0')
 #ifndef MAX
 #define MAX(p,q) (((p) >= (q)) ? (p) : (q))
 #endif
 
-/* yes this really must be a ||. Don't muck with this (tridge) */
-#if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
+struct pr_chunk {
+	int type; /* chunk type */
+	int num; /* parameter number */
+	int min; 
+	int max;
+	int flags;
+	int cflags;
+	int start;
+	int len;
+	LLONG value;
+	LDOUBLE fvalue;
+	char *strvalue;
+	void *pnum;
+	struct pr_chunk *min_star;
+	struct pr_chunk *max_star;
+	struct pr_chunk *next;
+};
+
+struct pr_chunk_x {
+	struct pr_chunk **chunks;
+	int num;
+};
 
-static size_t dopr(char *buffer, size_t maxlen, const char *format, 
+static int dopr(char *buffer, size_t maxlen, const char *format, 
 		   va_list args_in);
 static void fmtstr(char *buffer, size_t *currlen, size_t maxlen,
 		    char *value, int flags, int min, int max);
 static void fmtint(char *buffer, size_t *currlen, size_t maxlen,
-		    long value, int base, int min, int max, int flags);
+		    LLONG value, int base, int min, int max, int flags);
 static void fmtfp(char *buffer, size_t *currlen, size_t maxlen,
 		   LDOUBLE fvalue, int min, int max, int flags);
 static void dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c);
+static struct pr_chunk *new_chunk(void);
+static int add_cnk_list_entry(struct pr_chunk_x **list,
+				int max_num, struct pr_chunk *chunk);
 
-static size_t dopr(char *buffer, size_t maxlen, const char *format, va_list args_in)
+static int dopr(char *buffer, size_t maxlen, const char *format, va_list args_in)
 {
 	char ch;
-	LLONG value;
-	LDOUBLE fvalue;
-	char *strvalue;
-	int min;
-	int max;
 	int state;
-	int flags;
-	int cflags;
+	int pflag;
+	int pnum;
+	int pfirst;
 	size_t currlen;
 	va_list args;
+	const char *base;
+	struct pr_chunk *chunks = NULL;
+	struct pr_chunk *cnk = NULL;
+	struct pr_chunk_x *clist = NULL;
+	int max_pos;
+	int ret = -1;
 
 	VA_COPY(args, args_in);
-	
+
 	state = DP_S_DEFAULT;
-	currlen = flags = cflags = min = 0;
-	max = -1;
+	pfirst = 1;
+	pflag = 0;
+	pnum = 0;
+
+	max_pos = 0;
+	base = format;
 	ch = *format++;
 	
+	/* retrieve the string structure as chunks */
 	while (state != DP_S_DONE) {
 		if (ch == '\0') 
 			state = DP_S_DONE;
 
 		switch(state) {
 		case DP_S_DEFAULT:
-			if (ch == '%') 
+			
+			if (cnk) {
+				cnk->next = new_chunk();
+				cnk = cnk->next;
+			} else {
+				cnk = new_chunk();
+			}
+			if (!cnk) goto done;
+			if (!chunks) chunks = cnk;
+			
+			if (ch == '%') {
 				state = DP_S_FLAGS;
-			else 
-				dopr_outch (buffer, &currlen, maxlen, ch);
-			ch = *format++;
+				ch = *format++;
+			} else {
+				cnk->type = CNK_FMT_STR;
+				cnk->start = format - base -1;
+				while ((ch != '\0') && (ch != '%')) ch = *format++;
+				cnk->len = format - base - cnk->start -1;
+			}
 			break;
 		case DP_S_FLAGS:
 			switch (ch) {
 			case '-':
-				flags |= DP_F_MINUS;
+				cnk->flags |= DP_F_MINUS;
 				ch = *format++;
 				break;
 			case '+':
-				flags |= DP_F_PLUS;
+				cnk->flags |= DP_F_PLUS;
 				ch = *format++;
 				break;
 			case ' ':
-				flags |= DP_F_SPACE;
+				cnk->flags |= DP_F_SPACE;
 				ch = *format++;
 				break;
 			case '#':
-				flags |= DP_F_NUM;
+				cnk->flags |= DP_F_NUM;
 				ch = *format++;
 				break;
 			case '0':
-				flags |= DP_F_ZERO;
+				cnk->flags |= DP_F_ZERO;
+				ch = *format++;
+				break;
+			case 'I':
+				/* internationalization not supported yet */
 				ch = *format++;
 				break;
 			default:
 				state = DP_S_MIN;
 				break;
 			}
 			break;
 		case DP_S_MIN:
 			if (isdigit((unsigned char)ch)) {
-				min = 10*min + char_to_int (ch);
+				cnk->min = 10 * cnk->min + char_to_int (ch);
+				ch = *format++;
+			} else if (ch == '$') {
+				if (!pfirst && !pflag) {
+					/* parameters must be all positioned or none */
+					goto done;
+				}
+				if (pfirst) {
+					pfirst = 0;
+					pflag = 1;
+				}
+				if (cnk->min == 0) /* what ?? */
+					goto done;
+				cnk->num = cnk->min;
+				cnk->min = 0;
 				ch = *format++;
 			} else if (ch == '*') {
-				min = va_arg (args, int);
+				if (pfirst) pfirst = 0;
+				cnk->min_star = new_chunk();
+				if (!cnk->min_star) /* out of memory :-( */
+					goto done;
+				cnk->min_star->type = CNK_INT;
+				if (pflag) {
+					int num;
+					ch = *format++;
+					if (!isdigit((unsigned char)ch)) {
+						/* parameters must be all positioned or none */
+						goto done;
+					}
+					for (num = 0; isdigit((unsigned char)ch); ch = *format++) {
+						num = 10 * num + char_to_int(ch);
+					}
+					cnk->min_star->num = num;
+					if (ch != '$') /* what ?? */
+						goto done;
+				} else {
+					cnk->min_star->num = ++pnum;
+				}
+				max_pos = add_cnk_list_entry(&clist, max_pos, cnk->min_star);
+				if (max_pos == 0) /* out of memory :-( */
+					goto done;
 				ch = *format++;
 				state = DP_S_DOT;
 			} else {
+				if (pfirst) pfirst = 0;
 				state = DP_S_DOT;
 			}
 			break;
 		case DP_S_DOT:
 			if (ch == '.') {
 				state = DP_S_MAX;
@@ -282,191 +402,387 @@
 			} else { 
 				state = DP_S_MOD;
 			}
 			break;
 		case DP_S_MAX:
 			if (isdigit((unsigned char)ch)) {
-				if (max < 0)
-					max = 0;
-				max = 10*max + char_to_int (ch);
+				if (cnk->max < 0)
+					cnk->max = 0;
+				cnk->max = 10 * cnk->max + char_to_int (ch);
+				ch = *format++;
+			} else if (ch == '$') {
+				if (!pfirst && !pflag) {
+					/* parameters must be all positioned or none */
+					goto done;
+				}
+				if (cnk->max <= 0) /* what ?? */
+					goto done;
+				cnk->num = cnk->max;
+				cnk->max = -1;
 				ch = *format++;
 			} else if (ch == '*') {
-				max = va_arg (args, int);
+				cnk->max_star = new_chunk();
+				if (!cnk->max_star) /* out of memory :-( */
+					goto done;
+				cnk->max_star->type = CNK_INT;
+				if (pflag) {
+					int num;
+					ch = *format++;
+					if (!isdigit((unsigned char)ch)) {
+						/* parameters must be all positioned or none */
+						goto done;
+					}
+					for (num = 0; isdigit((unsigned char)ch); ch = *format++) {
+						num = 10 * num + char_to_int(ch);
+					}
+					cnk->max_star->num = num;
+					if (ch != '$') /* what ?? */
+						goto done;
+				} else {
+					cnk->max_star->num = ++pnum;
+				}
+				max_pos = add_cnk_list_entry(&clist, max_pos, cnk->max_star);
+				if (max_pos == 0) /* out of memory :-( */
+					goto done;
+
 				ch = *format++;
 				state = DP_S_MOD;
 			} else {
 				state = DP_S_MOD;
 			}
 			break;
 		case DP_S_MOD:
 			switch (ch) {
 			case 'h':
-				cflags = DP_C_SHORT;
+				cnk->cflags = DP_C_SHORT;
 				ch = *format++;
+				if (ch == 'h') {
+					cnk->cflags = DP_C_CHAR;
+					ch = *format++;
+				}
 				break;
 			case 'l':
-				cflags = DP_C_LONG;
+				cnk->cflags = DP_C_LONG;
 				ch = *format++;
 				if (ch == 'l') {	/* It's a long long */
-					cflags = DP_C_LLONG;
+					cnk->cflags = DP_C_LLONG;
 					ch = *format++;
 				}
 				break;
 			case 'L':
-				cflags = DP_C_LDOUBLE;
+				cnk->cflags = DP_C_LDOUBLE;
+				ch = *format++;
+				break;
+			case 'z':
+				cnk->cflags = DP_C_SIZET;
 				ch = *format++;
 				break;
 			default:
 				break;
 			}
 			state = DP_S_CONV;
 			break;
 		case DP_S_CONV:
+			if (cnk->num == 0) cnk->num = ++pnum;
+			max_pos = add_cnk_list_entry(&clist, max_pos, cnk);
+			if (max_pos == 0) /* out of memory :-( */
+				goto done;
+			
 			switch (ch) {
 			case 'd':
 			case 'i':
-				if (cflags == DP_C_SHORT) 
-					value = va_arg (args, int);
-				else if (cflags == DP_C_LONG)
-					value = va_arg (args, long int);
-				else if (cflags == DP_C_LLONG)
-					value = va_arg (args, LLONG);
-				else
-					value = va_arg (args, int);
-				fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
+				cnk->type = CNK_INT;
 				break;
 			case 'o':
-				flags |= DP_F_UNSIGNED;
-				if (cflags == DP_C_SHORT)
-					value = va_arg (args, unsigned int);
-				else if (cflags == DP_C_LONG)
-					value = (long)va_arg (args, unsigned long int);
-				else if (cflags == DP_C_LLONG)
-					value = (long)va_arg (args, unsigned LLONG);
-				else
-					value = (long)va_arg (args, unsigned int);
-				fmtint (buffer, &currlen, maxlen, value, 8, min, max, flags);
+				cnk->type = CNK_OCTAL;
+				cnk->flags |= DP_F_UNSIGNED;
 				break;
 			case 'u':
-				flags |= DP_F_UNSIGNED;
-				if (cflags == DP_C_SHORT)
-					value = va_arg (args, unsigned int);
-				else if (cflags == DP_C_LONG)
-					value = (long)va_arg (args, unsigned long int);
-				else if (cflags == DP_C_LLONG)
-					value = (LLONG)va_arg (args, unsigned LLONG);
-				else
-					value = (long)va_arg (args, unsigned int);
-				fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
+				cnk->type = CNK_UINT;
+				cnk->flags |= DP_F_UNSIGNED;
 				break;
 			case 'X':
-				flags |= DP_F_UP;
+				cnk->flags |= DP_F_UP;
 			case 'x':
-				flags |= DP_F_UNSIGNED;
-				if (cflags == DP_C_SHORT)
-					value = va_arg (args, unsigned int);
-				else if (cflags == DP_C_LONG)
-					value = (long)va_arg (args, unsigned long int);
-				else if (cflags == DP_C_LLONG)
-					value = (LLONG)va_arg (args, unsigned LLONG);
-				else
-					value = (long)va_arg (args, unsigned int);
-				fmtint (buffer, &currlen, maxlen, value, 16, min, max, flags);
-				break;
-			case 'f':
-				if (cflags == DP_C_LDOUBLE)
-					fvalue = va_arg (args, LDOUBLE);
-				else
-					fvalue = va_arg (args, double);
-				/* um, floating point? */
-				fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
+				cnk->type = CNK_HEX;
+				cnk->flags |= DP_F_UNSIGNED;
 				break;
+			case 'A':
+				/* hex float not supported yet */
 			case 'E':
-				flags |= DP_F_UP;
-			case 'e':
-				if (cflags == DP_C_LDOUBLE)
-					fvalue = va_arg (args, LDOUBLE);
-				else
-					fvalue = va_arg (args, double);
-				fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
-				break;
 			case 'G':
-				flags |= DP_F_UP;
+			case 'F':
+				cnk->flags |= DP_F_UP;
+			case 'a':
+				/* hex float not supported yet */
+			case 'e':
+			case 'f':
 			case 'g':
-				if (cflags == DP_C_LDOUBLE)
-					fvalue = va_arg (args, LDOUBLE);
-				else
-					fvalue = va_arg (args, double);
-				fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
+				cnk->type = CNK_FLOAT;
 				break;
 			case 'c':
-				dopr_outch (buffer, &currlen, maxlen, va_arg (args, int));
+				cnk->type = CNK_CHAR;
 				break;
 			case 's':
-				strvalue = va_arg (args, char *);
-				if (!strvalue) strvalue = "(NULL)";
-				if (max == -1) {
-					max = strlen(strvalue);
-				}
-				if (min > 0 && max >= 0 && min > max) max = min;
-				fmtstr (buffer, &currlen, maxlen, strvalue, flags, min, max);
+				cnk->type = CNK_STRING;
 				break;
 			case 'p':
-				strvalue = va_arg (args, void *);
-				fmtint (buffer, &currlen, maxlen, (long) strvalue, 16, min, max, flags);
+				cnk->type = CNK_PTR;
+				cnk->flags |= DP_F_UNSIGNED;
 				break;
 			case 'n':
-				if (cflags == DP_C_SHORT) {
-					short int *num;
-					num = va_arg (args, short int *);
-					*num = currlen;
-				} else if (cflags == DP_C_LONG) {
-					long int *num;
-					num = va_arg (args, long int *);
-					*num = (long int)currlen;
-				} else if (cflags == DP_C_LLONG) {
-					LLONG *num;
-					num = va_arg (args, LLONG *);
-					*num = (LLONG)currlen;
-				} else {
-					int *num;
-					num = va_arg (args, int *);
-					*num = currlen;
-				}
+				cnk->type = CNK_NUM;
 				break;
 			case '%':
-				dopr_outch (buffer, &currlen, maxlen, ch);
-				break;
-			case 'w':
-				/* not supported yet, treat as next char */
-				ch = *format++;
+				cnk->type = CNK_PRCNT;
 				break;
 			default:
-				/* Unknown, skip */
-				break;
+				/* Unknown, bail out*/
+				goto done;
 			}
 			ch = *format++;
 			state = DP_S_DEFAULT;
-			flags = cflags = min = 0;
-			max = -1;
 			break;
 		case DP_S_DONE:
 			break;
 		default:
 			/* hmm? */
 			break; /* some picky compilers need this */
 		}
 	}
+
+	/* retrieve the format arguments */
+	for (pnum = 0; pnum < max_pos; pnum++) {
+		int i;
+
+		if (clist[pnum].num == 0) {
+			/* ignoring a parameter should not be permitted
+			 * all parameters must be matched at least once
+			 * BUT seem some system ignore this rule ...
+			 * at least my glibc based system does --SSS
+			 */
+#ifdef DEBUG_SNPRINTF
+			printf("parameter at position %d not used\n", pnum+1);
+#endif
+			/* eat the parameter */
+			va_arg (args, int);
+			continue;
+		}
+		for (i = 1; i < clist[pnum].num; i++) {
+			if (clist[pnum].chunks[0]->type != clist[pnum].chunks[i]->type) {
+				/* nooo noo no!
+				 * all the references to a parameter
+				 * must be of the same type
+				 */
+				goto done;
+			}
+		}
+		cnk = clist[pnum].chunks[0];
+		switch (cnk->type) {
+		case CNK_INT:
+			if (cnk->cflags == DP_C_SHORT) 
+				cnk->value = va_arg (args, int);
+			else if (cnk->cflags == DP_C_LONG)
+				cnk->value = va_arg (args, long int);
+			else if (cnk->cflags == DP_C_LLONG)
+				cnk->value = va_arg (args, LLONG);
+			else if (cnk->cflags == DP_C_SIZET)
+				cnk->value = va_arg (args, ssize_t);
+			else
+				cnk->value = va_arg (args, int);
+
+			for (i = 1; i < clist[pnum].num; i++) {
+				clist[pnum].chunks[i]->value = cnk->value;
+			}
+			break;
+
+		case CNK_OCTAL:
+		case CNK_UINT:
+		case CNK_HEX:
+			if (cnk->cflags == DP_C_SHORT)
+				cnk->value = va_arg (args, unsigned int);
+			else if (cnk->cflags == DP_C_LONG)
+				cnk->value = (unsigned long int)va_arg (args, unsigned long int);
+			else if (cnk->cflags == DP_C_LLONG)
+				cnk->value = (LLONG)va_arg (args, unsigned LLONG);
+			else if (cnk->cflags == DP_C_SIZET)
+				cnk->value = (size_t)va_arg (args, size_t);
+			else
+				cnk->value = (unsigned int)va_arg (args, unsigned int);
+
+			for (i = 1; i < clist[pnum].num; i++) {
+				clist[pnum].chunks[i]->value = cnk->value;
+			}
+			break;
+
+		case CNK_FLOAT:
+			if (cnk->cflags == DP_C_LDOUBLE)
+				cnk->fvalue = va_arg (args, LDOUBLE);
+			else
+				cnk->fvalue = va_arg (args, double);
+
+			for (i = 1; i < clist[pnum].num; i++) {
+				clist[pnum].chunks[i]->fvalue = cnk->fvalue;
+			}
+			break;
+
+		case CNK_CHAR:
+			cnk->value = va_arg (args, int);
+
+			for (i = 1; i < clist[pnum].num; i++) {
+				clist[pnum].chunks[i]->value = cnk->value;
+			}
+			break;
+
+		case CNK_STRING:
+			cnk->strvalue = va_arg (args, char *);
+			if (!cnk->strvalue) cnk->strvalue = "(NULL)";
+
+			for (i = 1; i < clist[pnum].num; i++) {
+				clist[pnum].chunks[i]->strvalue = cnk->strvalue;
+			}
+			break;
+
+		case CNK_PTR:
+			cnk->strvalue = va_arg (args, void *);
+			for (i = 1; i < clist[pnum].num; i++) {
+				clist[pnum].chunks[i]->strvalue = cnk->strvalue;
+			}
+			break;
+
+		case CNK_NUM:
+			if (cnk->cflags == DP_C_CHAR)
+				cnk->pnum = va_arg (args, char *);
+			else if (cnk->cflags == DP_C_SHORT)
+				cnk->pnum = va_arg (args, short int *);
+			else if (cnk->cflags == DP_C_LONG)
+				cnk->pnum = va_arg (args, long int *);
+			else if (cnk->cflags == DP_C_LLONG)
+				cnk->pnum = va_arg (args, LLONG *);
+			else if (cnk->cflags == DP_C_SIZET)
+				cnk->pnum = va_arg (args, ssize_t *);
+			else
+				cnk->pnum = va_arg (args, int *);
+
+			for (i = 1; i < clist[pnum].num; i++) {
+				clist[pnum].chunks[i]->pnum = cnk->pnum;
+			}
+			break;
+
+		case CNK_PRCNT:
+			break;
+
+		default:
+			/* what ?? */
+			goto done;
+		}
+	}
+	/* print out the actual string from chunks */
+	currlen = 0;
+	cnk = chunks;
+	while (cnk) {
+		int len, min, max;
+
+		if (cnk->min_star) min = cnk->min_star->value;
+		else min = cnk->min;
+		if (cnk->max_star) max = cnk->max_star->value;
+		else max = cnk->max;
+
+		switch (cnk->type) {
+
+		case CNK_FMT_STR:
+			if (maxlen != 0 && maxlen > currlen) {
+				if (maxlen > (currlen + cnk->len)) len = cnk->len;
+				else len = maxlen - currlen;
+
+				memcpy(&(buffer[currlen]), &(base[cnk->start]), len);
+			}
+			currlen += cnk->len;
+				
+			break;
+
+		case CNK_INT:
+		case CNK_UINT:
+			fmtint (buffer, &currlen, maxlen, cnk->value, 10, min, max, cnk->flags);
+			break;
+
+		case CNK_OCTAL:
+			fmtint (buffer, &currlen, maxlen, cnk->value, 8, min, max, cnk->flags);
+			break;
+
+		case CNK_HEX:
+			fmtint (buffer, &currlen, maxlen, cnk->value, 16, min, max, cnk->flags);
+			break;
+
+		case CNK_FLOAT:
+			fmtfp (buffer, &currlen, maxlen, cnk->fvalue, min, max, cnk->flags);
+			break;
+
+		case CNK_CHAR:
+			dopr_outch (buffer, &currlen, maxlen, cnk->value);
+			break;
+
+		case CNK_STRING:
+			if (max == -1) {
+				max = strlen(cnk->strvalue);
+			}
+			fmtstr (buffer, &currlen, maxlen, cnk->strvalue, cnk->flags, min, max);
+			break;
+
+		case CNK_PTR:
+			fmtint (buffer, &currlen, maxlen, (long)(cnk->strvalue), 16, min, max, cnk->flags);
+			break;
+
+		case CNK_NUM:
+			if (cnk->cflags == DP_C_CHAR)
+				*((char *)(cnk->pnum)) = (char)currlen;
+			else if (cnk->cflags == DP_C_SHORT)
+				*((short int *)(cnk->pnum)) = (short int)currlen;
+			else if (cnk->cflags == DP_C_LONG)
+				*((long int *)(cnk->pnum)) = (long int)currlen;
+			else if (cnk->cflags == DP_C_LLONG)
+				*((LLONG *)(cnk->pnum)) = (LLONG)currlen;
+			else if (cnk->cflags == DP_C_SIZET)
+				*((ssize_t *)(cnk->pnum)) = (ssize_t)currlen;
+			else
+				*((int *)(cnk->pnum)) = (int)currlen;
+			break;
+
+		case CNK_PRCNT:
+			dopr_outch (buffer, &currlen, maxlen, '%');
+			break;
+
+		default:
+			/* what ?? */
+			goto done;
+		}
+		cnk = cnk->next;
+	}
 	if (maxlen != 0) {
 		if (currlen < maxlen - 1) 
 			buffer[currlen] = '\0';
 		else if (maxlen > 0) 
 			buffer[maxlen - 1] = '\0';
 	}
-	
-	return currlen;
+	ret = currlen;
+
+done:
+	va_end(args);
+
+	while (chunks) {
+		cnk = chunks->next;
+		free(chunks);
+		chunks = cnk;
+	}
+	if (clist) {
+		for (pnum = 0; pnum < max_pos; pnum++) {
+			if (clist[pnum].chunks) free(clist[pnum].chunks);
+		}
+		free(clist);
+	}
+	return ret;
 }
 
 static void fmtstr(char *buffer, size_t *currlen, size_t maxlen,
 		    char *value, int flags, int min, int max)
 {
 	int padlen, strln;     /* amount to pad */
@@ -476,42 +792,40 @@
 	printf("fmtstr min=%d max=%d s=[%s]\n", min, max, value);
 #endif
 	if (value == 0) {
 		value = "<NULL>";
 	}
 
-	for (strln = 0; value[strln]; ++strln); /* strlen */
+	for (strln = 0; strln < max && value[strln]; ++strln); /* strlen */
 	padlen = min - strln;
 	if (padlen < 0) 
 		padlen = 0;
 	if (flags & DP_F_MINUS) 
 		padlen = -padlen; /* Left Justify */
 	
-	while ((padlen > 0) && (cnt < max)) {
+	while (padlen > 0) {
 		dopr_outch (buffer, currlen, maxlen, ' ');
 		--padlen;
-		++cnt;
 	}
 	while (*value && (cnt < max)) {
 		dopr_outch (buffer, currlen, maxlen, *value++);
 		++cnt;
 	}
-	while ((padlen < 0) && (cnt < max)) {
+	while (padlen < 0) {
 		dopr_outch (buffer, currlen, maxlen, ' ');
 		++padlen;
-		++cnt;
 	}
 }
 
 /* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
 
 static void fmtint(char *buffer, size_t *currlen, size_t maxlen,
-		    long value, int base, int min, int max, int flags)
+		    LLONG value, int base, int min, int max, int flags)
 {
 	int signvalue = 0;
-	unsigned long uvalue;
+	unsigned LLONG uvalue;
 	char convert[20];
 	int place = 0;
 	int spadlen = 0; /* amount to space pad */
 	int zpadlen = 0; /* amount to zero pad */
 	int caps = 0;
 	
@@ -623,38 +937,40 @@
 
 /* a replacement for modf that doesn't need the math library. Should
    be portable, but slow */
 static double my_modf(double x0, double *iptr)
 {
 	int i;
-	long l;
+	LLONG l=0;
 	double x = x0;
 	double f = 1.0;
 
 	for (i=0;i<100;i++) {
 		l = (long)x;
-		if (l <= (x+1) && l >= (x-1)) {
-			if (i != 0) {
-				double i2;
-				double ret;
-
-				ret = my_modf(x0-l*f, &i2);
-				(*iptr) = l*f + i2;
-				return ret;
-			} 
-
-			(*iptr) = l;
-			return x - (*iptr);
-		}
+		if (l <= (x+1) && l >= (x-1)) break;
 		x *= 0.1;
 		f *= 10.0;
 	}
 
-	/* yikes! the number is beyond what we can handle. What do we do? */
-	(*iptr) = 0;
-	return 0;
+	if (i == 100) {
+		/* yikes! the number is beyond what we can handle. What do we do? */
+		(*iptr) = 0;
+		return 0;
+	}
+
+	if (i != 0) {
+		double i2;
+		double ret;
+
+		ret = my_modf(x0-l*f, &i2);
+		(*iptr) = l*f + i2;
+		return ret;
+	} 
+
+	(*iptr) = l;
+	return x - (*iptr);
 }
 
 
 static void fmtfp (char *buffer, size_t *currlen, size_t maxlen,
 		   LDOUBLE fvalue, int min, int max, int flags)
 {
@@ -698,17 +1014,17 @@
 
 #if 0
 	 if (max == 0) ufvalue += 0.5; /* if max = 0 we must round */
 #endif
 
 	/* 
-	 * Sorry, we only support 16 digits past the decimal because of our 
+	 * Sorry, we only support 9 digits past the decimal because of our 
 	 * conversion method
 	 */
-	if (max > 16)
-		max = 16;
+	if (max > 9)
+		max = 9;
 
 	/* We "cheat" by converting the fractional part to integer by
 	 * multiplying by a factor of 10
 	 */
 
 	temp = ufvalue;
@@ -812,12 +1128,91 @@
 	if (*currlen < maxlen) {
 		buffer[(*currlen)] = c;
 	}
 	(*currlen)++;
 }
 
+static struct pr_chunk *new_chunk(void) {
+	struct pr_chunk *new_c = (struct pr_chunk *)malloc(sizeof(struct pr_chunk));
+
+	if (!new_c)
+		return NULL;
+
+	new_c->type = 0;
+	new_c->num = 0;
+	new_c->min = 0;
+	new_c->min_star = NULL;
+	new_c->max = -1;
+	new_c->max_star = NULL;
+	new_c->flags = 0;
+	new_c->cflags = 0;
+	new_c->start = 0;
+	new_c->len = 0;
+	new_c->value = 0;
+	new_c->fvalue = 0;
+	new_c->strvalue = NULL;
+	new_c->pnum = NULL;
+	new_c->next = NULL;
+
+	return new_c;
+}
+
+static int add_cnk_list_entry(struct pr_chunk_x **list,
+				int max_num, struct pr_chunk *chunk) {
+	struct pr_chunk_x *l;
+	struct pr_chunk **c;
+	int max;
+	int cnum;
+	int i, pos;
+
+	if (chunk->num > max_num) {
+		max = chunk->num;
+	
+		if (*list == NULL) {
+			l = (struct pr_chunk_x *)malloc(sizeof(struct pr_chunk_x) * max);
+			pos = 0;
+		} else {
+			l = (struct pr_chunk_x *)realloc(*list, sizeof(struct pr_chunk_x) * max);
+			pos = max_num;
+		}
+		if (l == NULL) {
+			for (i = 0; i < max; i++) {
+				if ((*list)[i].chunks) free((*list)[i].chunks);
+			}
+			return 0;
+		}
+		for (i = pos; i < max; i++) {
+			l[i].chunks = NULL;
+			l[i].num = 0;
+		}
+	} else {
+		l = *list;
+		max = max_num;
+	}
+
+	i = chunk->num - 1;
+	cnum = l[i].num + 1;
+	if (l[i].chunks == NULL) {
+		c = (struct pr_chunk **)malloc(sizeof(struct pr_chunk *) * cnum); 
+	} else {
+		c = (struct pr_chunk **)realloc(l[i].chunks, sizeof(struct pr_chunk *) * cnum);
+	}
+	if (c == NULL) {
+		for (i = 0; i < max; i++) {
+			if (l[i].chunks) free(l[i].chunks);
+		}
+		return 0;
+	}
+	c[l[i].num] = chunk;
+	l[i].chunks = c;
+	l[i].num = cnum;
+
+	*list = l;
+	return max;
+}
+
  int rsync_vsnprintf (char *str, size_t count, const char *fmt, va_list args)
 {
 	return dopr(str, count, fmt, args);
 }
 #define vsnprintf rsync_vsnprintf
 #endif
@@ -839,31 +1234,29 @@
 	va_end(ap);
 	return ret;
 }
 #define snprintf rsync_snprintf
 #endif
 
-#endif 
-
 #ifndef HAVE_VASPRINTF
  int vasprintf(char **ptr, const char *format, va_list ap)
 {
 	int ret;
 	va_list ap2;
 
 	VA_COPY(ap2, ap);
-	
 	ret = vsnprintf(NULL, 0, format, ap2);
-	if (ret <= 0) return ret;
+	va_end(ap2);
+	if (ret < 0) return ret;
 
 	(*ptr) = (char *)malloc(ret+1);
 	if (!*ptr) return -1;
 
 	VA_COPY(ap2, ap);
-
 	ret = vsnprintf(*ptr, ret+1, format, ap2);
+	va_end(ap2);
 
 	return ret;
 }
 #endif
 
 
@@ -882,17 +1275,19 @@
 }
 #endif
 
 #ifdef TEST_SNPRINTF
 
  int sprintf(char *str,const char *fmt,...);
+ int printf(const char *fmt,...);
 
  int main (void)
 {
 	char buf1[1024];
 	char buf2[1024];
+	char *buf3;
 	char *fp_fmt[] = {
 		"%1.1f",
 		"%-1.5f",
 		"%1.5f",
 		"%123.9f",
 		"%10.5f",
@@ -902,13 +1297,14 @@
 		"%01.3f",
 		"%4f",
 		"%3.1f",
 		"%3.2f",
 		"%.0f",
 		"%f",
-		"-16.16f",
+		"%-8.8f",
+		"%-9.9f",
 		NULL
 	};
 	double fp_nums[] = { 6442452944.1234, -1.5, 134.21, 91340.2, 341.1234, 203.9, 0.96, 0.996, 
 			     0.9996, 1.996, 4.136, 5.030201, 0.00205,
 			     /* END LIST */ 0};
 	char *int_fmt[] = {
@@ -921,87 +1317,182 @@
 		"%+22.33d",
 		"%01.3d",
 		"%4d",
 		"%d",
 		NULL
 	};
-	long int_nums[] = { -1, 134, 91340, 341, 0203, 0};
+	long int_nums[] = { -1, 134, 91340, 341, 0203, 1234567890, 0};
 	char *str_fmt[] = {
-		"10.5s",
-		"5.10s",
-		"10.1s",
-		"0.10s",
-		"10.0s",
-		"1.10s",
+		"%10.5s",
+		"%-10.5s",
+		"%5.10s",
+		"%-5.10s",
+		"%10.1s",
+		"%0.10s",
+		"%10.0s",
+		"%1.10s",
 		"%s",
 		"%.1s",
 		"%.10s",
 		"%10s",
 		NULL
 	};
 	char *str_vals[] = {"hello", "a", "", "a longer string", NULL};
+#ifdef HAVE_LONG_LONG
+	char *ll_fmt[] = {
+		"%llu",
+		NULL
+	};
+	LLONG ll_nums[] = { 134, 91340, 341, 0203, 1234567890, 128006186140000000LL, 0};
+#endif
 	int x, y;
 	int fail = 0;
 	int num = 0;
+	int l1, l2;
+	char *ss_fmt[] = {
+		"%zd",
+		"%zu",
+		NULL
+	};
+	size_t ss_nums[] = {134, 91340, 123456789, 0203, 1234567890, 0};
 
 	printf ("Testing snprintf format codes against system sprintf...\n");
 
 	for (x = 0; fp_fmt[x] ; x++) {
 		for (y = 0; fp_nums[y] != 0 ; y++) {
-			int l1 = snprintf(NULL, 0, fp_fmt[x], fp_nums[y]);
-			int l2 = snprintf(buf1, sizeof(buf1), fp_fmt[x], fp_nums[y]);
-			sprintf (buf2, fp_fmt[x], fp_nums[y]);
-			if (strcmp (buf1, buf2)) {
-				printf("snprintf doesn't match Format: %s\n\tsnprintf = [%s]\n\t sprintf = [%s]\n", 
-				       fp_fmt[x], buf1, buf2);
-				fail++;
-			}
-			if (l1 != l2) {
-				printf("snprintf l1 != l2 (%d %d) %s\n", l1, l2, fp_fmt[x]);
+			buf1[0] = buf2[0] = '\0';
+			l1 = snprintf(buf1, sizeof(buf1), fp_fmt[x], fp_nums[y]);
+			l2 = sprintf (buf2, fp_fmt[x], fp_nums[y]);
+			buf1[1023] = buf2[1023] = '\0';
+			if (strcmp (buf1, buf2) || (l1 != l2)) {
+				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n", 
+				       fp_fmt[x], l1, buf1, l2, buf2);
 				fail++;
 			}
 			num++;
 		}
 	}
 
 	for (x = 0; int_fmt[x] ; x++) {
 		for (y = 0; int_nums[y] != 0 ; y++) {
-			int l1 = snprintf(NULL, 0, int_fmt[x], int_nums[y]);
-			int l2 = snprintf(buf1, sizeof(buf1), int_fmt[x], int_nums[y]);
-			sprintf (buf2, int_fmt[x], int_nums[y]);
-			if (strcmp (buf1, buf2)) {
-				printf("snprintf doesn't match Format: %s\n\tsnprintf = [%s]\n\t sprintf = [%s]\n", 
-				       int_fmt[x], buf1, buf2);
-				fail++;
-			}
-			if (l1 != l2) {
-				printf("snprintf l1 != l2 (%d %d) %s\n", l1, l2, int_fmt[x]);
+			buf1[0] = buf2[0] = '\0';
+			l1 = snprintf(buf1, sizeof(buf1), int_fmt[x], int_nums[y]);
+			l2 = sprintf (buf2, int_fmt[x], int_nums[y]);
+			buf1[1023] = buf2[1023] = '\0';
+			if (strcmp (buf1, buf2) || (l1 != l2)) {
+				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n", 
+				       int_fmt[x], l1, buf1, l2, buf2);
 				fail++;
 			}
 			num++;
 		}
 	}
 
 	for (x = 0; str_fmt[x] ; x++) {
 		for (y = 0; str_vals[y] != 0 ; y++) {
-			int l1 = snprintf(NULL, 0, str_fmt[x], str_vals[y]);
-			int l2 = snprintf(buf1, sizeof(buf1), str_fmt[x], str_vals[y]);
-			sprintf (buf2, str_fmt[x], str_vals[y]);
-			if (strcmp (buf1, buf2)) {
-				printf("snprintf doesn't match Format: %s\n\tsnprintf = [%s]\n\t sprintf = [%s]\n", 
-				       str_fmt[x], buf1, buf2);
+			buf1[0] = buf2[0] = '\0';
+			l1 = snprintf(buf1, sizeof(buf1), str_fmt[x], str_vals[y]);
+			l2 = sprintf (buf2, str_fmt[x], str_vals[y]);
+			buf1[1023] = buf2[1023] = '\0';
+			if (strcmp (buf1, buf2) || (l1 != l2)) {
+				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n", 
+				       str_fmt[x], l1, buf1, l2, buf2);
 				fail++;
 			}
-			if (l1 != l2) {
-				printf("snprintf l1 != l2 (%d %d) %s\n", l1, l2, str_fmt[x]);
+			num++;
+		}
+	}
+
+#ifdef HAVE_LONG_LONG
+	for (x = 0; ll_fmt[x] ; x++) {
+		for (y = 0; ll_nums[y] != 0 ; y++) {
+			buf1[0] = buf2[0] = '\0';
+			l1 = snprintf(buf1, sizeof(buf1), ll_fmt[x], ll_nums[y]);
+			l2 = sprintf (buf2, ll_fmt[x], ll_nums[y]);
+			buf1[1023] = buf2[1023] = '\0';
+			if (strcmp (buf1, buf2) || (l1 != l2)) {
+				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n", 
+				       ll_fmt[x], l1, buf1, l2, buf2);
 				fail++;
 			}
 			num++;
 		}
 	}
+#endif
+
+#define BUFSZ 2048
+
+	buf1[0] = buf2[0] = '\0';
+	if ((buf3 = malloc(BUFSZ)) == NULL) {
+		fail++;
+	} else {
+		num++;
+		memset(buf3, 'a', BUFSZ);
+		snprintf(buf1, sizeof(buf1), "%.*s", 1, buf3);
+		buf1[1023] = '\0';
+		if (strcmp(buf1, "a") != 0) {
+			printf("length limit buf1 '%s' expected 'a'\n", buf1);
+			fail++;
+		}
+        }
 
+	buf1[0] = buf2[0] = '\0';
+	l1 = snprintf(buf1, sizeof(buf1), "%4$*1$d %2$s %3$*1$.*1$f", 3, "pos test", 12.3456, 9);
+	l2 = sprintf(buf2, "%4$*1$d %2$s %3$*1$.*1$f", 3, "pos test", 12.3456, 9);
+	buf1[1023] = buf2[1023] = '\0';
+	if (strcmp(buf1, buf2) || (l1 != l2)) {
+		printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
+				"%4$*1$d %2$s %3$*1$.*1$f", l1, buf1, l2, buf2);
+		fail++;
+	}
+
+	buf1[0] = buf2[0] = '\0';
+	l1 = snprintf(buf1, sizeof(buf1), "%4$*4$d %2$s %3$*4$.*4$f", 3, "pos test", 12.3456, 9);
+	l2 = sprintf(buf2, "%4$*4$d %2$s %3$*4$.*4$f", 3, "pos test", 12.3456, 9);
+	buf1[1023] = buf2[1023] = '\0';
+	if (strcmp(buf1, buf2)) {
+		printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
+				"%4$*1$d %2$s %3$*1$.*1$f", l1, buf1, l2, buf2);
+		fail++;
+	}
+
+	for (x = 0; ss_fmt[x] ; x++) {
+		for (y = 0; ss_nums[y] != 0 ; y++) {
+			buf1[0] = buf2[0] = '\0';
+			l1 = snprintf(buf1, sizeof(buf1), ss_fmt[x], ss_nums[y]);
+			l2 = sprintf (buf2, ss_fmt[x], ss_nums[y]);
+			buf1[1023] = buf2[1023] = '\0';
+			if (strcmp (buf1, buf2) || (l1 != l2)) {
+				printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n", 
+				       ss_fmt[x], l1, buf1, l2, buf2);
+				fail++;
+			}
+			num++;
+		}
+	}
+#if 0
+	buf1[0] = buf2[0] = '\0';
+	l1 = snprintf(buf1, sizeof(buf1), "%lld", (LLONG)1234567890);
+	l2 = sprintf(buf2, "%lld", (LLONG)1234567890);
+	buf1[1023] = buf2[1023] = '\0';
+	if (strcmp(buf1, buf2)) {
+		printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
+				"%lld", l1, buf1, l2, buf2);
+		fail++;
+	}
+
+	buf1[0] = buf2[0] = '\0';
+	l1 = snprintf(buf1, sizeof(buf1), "%Lf", (LDOUBLE)890.1234567890123);
+	l2 = sprintf(buf2, "%Lf", (LDOUBLE)890.1234567890123);
+	buf1[1023] = buf2[1023] = '\0';
+	if (strcmp(buf1, buf2)) {
+		printf("snprintf doesn't match Format: %s\n\tsnprintf(%d) = [%s]\n\t sprintf(%d) = [%s]\n",
+				"%Lf", l1, buf1, l2, buf2);
+		fail++;
+	}
+#endif
 	printf ("%d tests failed out of %d.\n", fail, num);
 
 	printf("seeing how many digits we support\n");
 	{
 		double v0 = 0.12345678901234567890123456789012345678901;
 		for (x=0; x<100; x++) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/sysxattrs.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/sysxattrs.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/lib/sysxattrs.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/lib/sysxattrs.c	2009-09-04 06:25:55.000000000 +0800
@@ -123,12 +123,156 @@
 		list[off+keylen] = '\0';
 	}
 
 	return len;
 }
 
+#elif HAVE_SOLARIS_XATTRS
+
+static ssize_t read_xattr(int attrfd, void *buf, size_t buflen)
+{
+	STRUCT_STAT sb;
+	ssize_t ret;
+
+	if (fstat(attrfd, &sb) < 0)
+		ret = -1;
+	else if (sb.st_size > SSIZE_MAX) {
+		errno = ERANGE;
+		ret = -1;
+	} else if (buflen == 0)
+		ret = sb.st_size;
+	else if (sb.st_size > buflen) {
+		errno = ERANGE;
+		ret = -1;
+	} else {
+		size_t bufpos;
+		for (bufpos = 0; bufpos < sb.st_size; ) {
+			ssize_t cnt = read(attrfd, buf + bufpos, sb.st_size - bufpos);
+			if (cnt <= 0) {
+				if (cnt < 0 && errno == EINTR)
+					continue;
+				bufpos = -1;
+				break;
+			}
+			bufpos += cnt;
+		}
+		ret = bufpos;
+	}
+
+	close(attrfd);
+
+	return ret;
+}
+
+ssize_t sys_lgetxattr(const char *path, const char *name, void *value, size_t size)
+{
+	int attrfd;
+
+	if ((attrfd = attropen(path, name, O_RDONLY)) < 0) {
+		errno = ENOATTR;
+		return -1;
+	}
+
+	return read_xattr(attrfd, value, size);
+}
+
+ssize_t sys_fgetxattr(int filedes, const char *name, void *value, size_t size)
+{
+	int attrfd;
+
+	if ((attrfd = openat(filedes, name, O_RDONLY|O_XATTR, 0)) < 0) {
+		errno = ENOATTR;
+		return -1;
+	}
+
+	return read_xattr(attrfd, value, size);
+}
+
+int sys_lsetxattr(const char *path, const char *name, const void *value, size_t size)
+{
+	int attrfd;
+	size_t bufpos;
+	mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
+
+	if ((attrfd = attropen(path, name, O_CREAT|O_TRUNC|O_WRONLY, mode)) < 0)
+		return -1;
+
+	for (bufpos = 0; bufpos < size; ) {
+		ssize_t cnt = write(attrfd, value+bufpos, size);
+		if (cnt <= 0) {
+			if (cnt < 0 && errno == EINTR)
+				continue;
+			bufpos = -1;
+			break;
+		}
+		bufpos += cnt;
+	}
+
+	close(attrfd);
+
+	return bufpos > 0 ? 0 : -1;
+}
+
+int sys_lremovexattr(const char *path, const char *name)
+{
+	int attrdirfd;
+	int ret;
+
+	if ((attrdirfd = attropen(path, ".", O_RDONLY)) < 0)
+		return -1;
+
+	ret = unlinkat(attrdirfd, name, 0);
+
+	close(attrdirfd);
+
+	return ret;
+}
+
+ssize_t sys_llistxattr(const char *path, char *list, size_t size)
+{
+	int attrdirfd;
+	DIR *dirp;
+	struct dirent *dp;
+	ssize_t ret = 0;
+
+	if ((attrdirfd = attropen(path, ".", O_RDONLY)) < 0) {
+		errno = ENOTSUP;
+		return -1;
+	}
+
+	if ((dirp = fdopendir(attrdirfd)) == NULL) {
+		close(attrdirfd);
+		return -1;
+	}
+
+	while ((dp = readdir(dirp))) {
+		int len = strlen(dp->d_name);
+
+		if (dp->d_name[0] == '.' && (len == 1 || (len == 2 && dp->d_name[1] == '.')))
+			continue;
+		if (len == 11 && dp->d_name[0] == 'S' && strncmp(dp->d_name, "SUNWattr_r", 10) == 0
+		 && (dp->d_name[10] == 'o' || dp->d_name[10] == 'w'))
+			continue;
+
+		if ((ret += len+1) > size) {
+			if (size == 0)
+				continue;
+			ret = -1;
+			errno = ERANGE;
+			break;
+		}
+		memcpy(list, dp->d_name, len+1);
+		list += len+1;
+	}
+
+	closedir(dirp);
+	close(attrdirfd);
+
+	return ret;
+}
+
 #else
 
 #error You need to create xattr compatibility functions.
 
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/loadparm.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/loadparm.c	2013-01-20 03:05:53.000000000 +0800
@@ -14,76 +14,68 @@
  */
 
 /* This is based on loadparm.c from Samba, written by Andrew Tridgell
  * and Karl Auer.  Some of the changes are:
  *
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison <wayned@samba.org>
+ * Copyright (C) 2003-2013 Wayne Davison <wayned@samba.org>
  */
 
 /* Load parameters.
  *
  *  This module provides suitable callback functions for the params
- *  module. It builds the internal table of service details which is
+ *  module. It builds the internal table of section details which is
  *  then used by the rest of the server.
  *
  * To add a parameter:
  *
- * 1) add it to the global or service structure definition
+ * 1) add it to the global_vars or local_vars structure definition
  * 2) add it to the parm_table
  * 3) add it to the list of available functions (eg: using FN_GLOBAL_STRING())
- * 4) If it's a global then initialise it in init_globals. If a local
- *    (ie. service) parameter then initialise it in the sDefault structure
- *
+ * 4) initialise it in the Defaults static stucture
  *
  * Notes:
- *   The configuration file is processed sequentially for speed. It is NOT
- *   accessed randomly as happens in 'real' Windows. For this reason, there
- *   is a fair bit of sequence-dependent code here - ie., code which assumes
- *   that certain things happen before others. In particular, the code which
- *   happens at the boundary between sections is delicately poised, so be
- *   careful!
- *
+ *   The configuration file is processed sequentially for speed. For this
+ *   reason, there is a fair bit of sequence-dependent code here - ie., code
+ *   which assumes that certain things happen before others. In particular, the
+ *   code which happens at the boundary between sections is delicately poised,
+ *   so be careful!
  */
 
-/* TODO: Parameter to set debug level on server. */
-
 #include "rsync.h"
-#include "ifuncs.h"
-#define PTR_DIFF(p1,p2) ((ptrdiff_t)(((char *)(p1)) - (char *)(p2)))
-#define strequal(a,b) (strcasecmp(a,b)==0)
+#include "itypes.h"
+
+extern item_list dparam_list;
+
+#define strequal(a, b) (strcasecmp(a, b)==0)
 #define BOOLSTR(b) ((b) ? "Yes" : "No")
-typedef char pstring[1024];
-#define pstrcpy(a,b) strlcpy(a,b,sizeof(pstring))
 
 #ifndef LOG_DAEMON
 #define LOG_DAEMON 0
 #endif
 
 #define DEFAULT_DONT_COMPRESS "*.gz *.zip *.z *.rpm *.deb *.iso *.bz2" \
-	" *.t[gb]z *.7z *.mp[34] *.mov *.avi *.ogg *.jpg *.jpeg"
+	" *.t[gb]z *.7z *.mp[34] *.mov *.avi *.ogg *.jpg *.jpeg *.png" \
+	" *.lzo *.rzip *.lzma *.rar *.ace *.gpg *.xz *.txz *.lz *.tlz"
 
 /* the following are used by loadparm for option lists */
-typedef enum
-{
-	P_BOOL,P_BOOLREV,P_CHAR,P_INTEGER,P_OCTAL,
-	P_PATH,P_STRING,P_GSTRING,P_ENUM,P_SEP
+typedef enum {
+	P_BOOL, P_BOOLREV, P_CHAR, P_INTEGER,
+	P_OCTAL, P_PATH, P_STRING, P_ENUM
 } parm_type;
 
-typedef enum
-{
-	P_LOCAL,P_GLOBAL,P_SEPARATOR,P_NONE
+typedef enum {
+	P_LOCAL, P_GLOBAL, P_NONE
 } parm_class;
 
 struct enum_list {
 	int value;
 	char *name;
 };
 
-struct parm_struct
-{
+struct parm_struct {
 	char *label;
 	parm_type type;
 	parm_class class;
 	void *ptr;
 	struct enum_list *enum_list;
 	unsigned flags;
@@ -91,39 +83,32 @@
 
 #ifndef GLOBAL_NAME
 #define GLOBAL_NAME "global"
 #endif
 
 /* some helpful bits */
-#define pSERVICE(i) ServicePtrs[i]
-#define iSERVICE(i) (*pSERVICE(i))
-#define LP_SNUM_OK(iService) (((iService) >= 0) && ((iService) < iNumServices))
+#define iSECTION(i) ((local_vars*)section_list.items)[i]
+#define LP_SNUM_OK(i) ((i) >= 0 && (i) < (int)section_list.count)
+#define SECTION_PTR(s, p) (((char*)(s)) + (ptrdiff_t)(((char*)(p))-(char*)&Vars.l))
 
-/*
- * This structure describes global (ie., server-wide) parameters.
- */
-typedef struct
-{
+/* This structure describes global (ie., server-wide) parameters. */
+typedef struct {
 	char *bind_address;
 	char *motd_file;
 	char *pid_file;
 	char *socket_options;
 
+	int listen_backlog;
 	int rsync_port;
-} global;
+} global_vars;
 
-static global Globals;
-
-
-/*
- * This structure describes a single service.  Their order must match the
+/* This structure describes a single section.  Their order must match the
  * initializers below, which you can accomplish by keeping each sub-section
  * sorted.  (e.g. in vim, just visually select each subsection and use !sort.)
- */
-typedef struct
-{
+ * NOTE: the char* variables MUST all remain at the start of the stuct! */
+typedef struct {
 	char *auth_users;
 	char *charset;
 	char *comment;
 	char *dont_compress;
 	char *exclude;
 	char *exclude_from;
@@ -143,46 +128,71 @@
 	char *postxfer_exec;
 	char *prexfer_exec;
 	char *refuse_options;
 	char *secrets_file;
 	char *temp_dir;
 	char *uid;
+/* NOTE: update this macro if the last char* variable changes! */
+#define LOCAL_STRING_COUNT() (offsetof(local_vars, uid) / sizeof (char*) + 1)
 
 	int max_connections;
 	int max_verbosity;
 	int syslog_facility;
 	int timeout;
 
 	BOOL fake_super;
+	BOOL forward_lookup;
 	BOOL ignore_errors;
 	BOOL ignore_nonreadable;
 	BOOL list;
 	BOOL munge_symlinks;
 	BOOL numeric_ids;
 	BOOL read_only;
+	BOOL reverse_lookup;
 	BOOL strict_modes;
 	BOOL transfer_logging;
 	BOOL use_chroot;
 	BOOL write_only;
-} service;
+} local_vars;
 
+/* This structure describes the global variables (g) as well as the globally
+ * specified values of the local variables (l), which are used when modules
+ * don't specify their own values. */
+typedef struct {
+	global_vars g;
+	local_vars l;
+} all_vars;
 
-/* This is a default service used to prime a services structure.  In order
- * to make these easy to keep sorted in the same way as the variables
+/* The application defaults for all the variables.  "Defaults" is
+ * used to re-initialize "Vars" before each config-file read.
+ *
+ * In order to keep these sorted in the same way as the structure
  * above, use the variable name in the leading comment, including a
  * trailing ';' (to avoid a sorting problem with trailing digits). */
-static service sDefault =
-{
+static const all_vars Defaults = {
+ /* ==== global_vars ==== */
+ {
+ /* bind_address; */		NULL,
+ /* motd_file; */		NULL,
+ /* pid_file; */		NULL,
+ /* socket_options; */		NULL,
+
+ /* listen_backlog; */		5,
+ /* rsync_port; */		0,
+ },
+
+ /* ==== local_vars ==== */
+ {
  /* auth_users; */		NULL,
  /* charset; */ 		NULL,
  /* comment; */ 		NULL,
  /* dont_compress; */		DEFAULT_DONT_COMPRESS,
  /* exclude; */			NULL,
  /* exclude_from; */		NULL,
  /* filter; */			NULL,
- /* gid; */			NOBODY_GROUP,
+ /* gid; */			NULL,
  /* hosts_allow; */		NULL,
  /* hosts_deny; */		NULL,
  /* include; */			NULL,
  /* include_from; */		NULL,
  /* incoming_chmod; */		NULL,
  /* lock_file; */		DEFAULT_LOCK_FILE,
@@ -193,41 +203,48 @@
  /* path; */			NULL,
  /* postxfer_exec; */		NULL,
  /* prexfer_exec; */		NULL,
  /* refuse_options; */		NULL,
  /* secrets_file; */		NULL,
  /* temp_dir; */ 		NULL,
- /* uid; */			NOBODY_USER,
+ /* uid; */			NULL,
 
  /* max_connections; */		0,
  /* max_verbosity; */		1,
  /* syslog_facility; */		LOG_DAEMON,
  /* timeout; */			0,
 
  /* fake_super; */		False,
+ /* forward_lookup; */		True,
  /* ignore_errors; */		False,
  /* ignore_nonreadable; */	False,
  /* list; */			True,
  /* munge_symlinks; */		(BOOL)-1,
  /* numeric_ids; */		(BOOL)-1,
  /* read_only; */		True,
+ /* reverse_lookup; */		True,
  /* strict_modes; */		True,
  /* transfer_logging; */	False,
  /* use_chroot; */		True,
  /* write_only; */		False,
+ }
 };
 
+/* The currently configured values for all the variables. */
+static all_vars Vars;
 
+/* Stack of "Vars" values used by the &include directive. */
+static item_list Vars_stack = EMPTY_ITEM_LIST;
 
-/* local variables */
-static service **ServicePtrs = NULL;
-static int iNumServices = 0;
-static int iServiceIndex = 0;
+/* The array of section values that holds all the defined modules. */
+static item_list section_list = EMPTY_ITEM_LIST;
+
+static int iSectionIndex = -1;
 static BOOL bInGlobalSection = True;
 
-#define NUMPARAMETERS (sizeof(parm_table) / sizeof(struct parm_struct))
+#define NUMPARAMETERS (sizeof (parm_table) / sizeof (struct parm_struct))
 
 static struct enum_list enum_facilities[] = {
 #ifdef LOG_AUTH
 	{ LOG_AUTH, "auth" },
 #endif
 #ifdef LOG_AUTHPRIV
@@ -287,116 +304,155 @@
 #ifdef LOG_LOCAL6
 	{ LOG_LOCAL6, "local6" },
 #endif
 #ifdef LOG_LOCAL7
 	{ LOG_LOCAL7, "local7" },
 #endif
-	{ -1, NULL }};
-
+	{ -1, NULL }
+};
 
-/* note that we do not initialise the defaults union - it is not allowed in ANSI C */
 static struct parm_struct parm_table[] =
 {
- {"address",           P_STRING, P_GLOBAL,&Globals.bind_address,       NULL,0},
- {"motd file",         P_STRING, P_GLOBAL,&Globals.motd_file,          NULL,0},
- {"pid file",          P_STRING, P_GLOBAL,&Globals.pid_file,           NULL,0},
- {"port",              P_INTEGER,P_GLOBAL,&Globals.rsync_port,         NULL,0},
- {"socket options",    P_STRING, P_GLOBAL,&Globals.socket_options,     NULL,0},
-
- {"auth users",        P_STRING, P_LOCAL, &sDefault.auth_users,        NULL,0},
- {"charset",           P_STRING, P_LOCAL, &sDefault.charset,           NULL,0},
- {"comment",           P_STRING, P_LOCAL, &sDefault.comment,           NULL,0},
- {"dont compress",     P_STRING, P_LOCAL, &sDefault.dont_compress,     NULL,0},
- {"exclude from",      P_STRING, P_LOCAL, &sDefault.exclude_from,      NULL,0},
- {"exclude",           P_STRING, P_LOCAL, &sDefault.exclude,           NULL,0},
- {"fake super",        P_BOOL,   P_LOCAL, &sDefault.fake_super,        NULL,0},
- {"filter",            P_STRING, P_LOCAL, &sDefault.filter,            NULL,0},
- {"gid",               P_STRING, P_LOCAL, &sDefault.gid,               NULL,0},
- {"hosts allow",       P_STRING, P_LOCAL, &sDefault.hosts_allow,       NULL,0},
- {"hosts deny",        P_STRING, P_LOCAL, &sDefault.hosts_deny,        NULL,0},
- {"ignore errors",     P_BOOL,   P_LOCAL, &sDefault.ignore_errors,     NULL,0},
- {"ignore nonreadable",P_BOOL,   P_LOCAL, &sDefault.ignore_nonreadable,NULL,0},
- {"include from",      P_STRING, P_LOCAL, &sDefault.include_from,      NULL,0},
- {"include",           P_STRING, P_LOCAL, &sDefault.include,           NULL,0},
- {"incoming chmod",    P_STRING, P_LOCAL, &sDefault.incoming_chmod,    NULL,0},
- {"list",              P_BOOL,   P_LOCAL, &sDefault.list,              NULL,0},
- {"lock file",         P_STRING, P_LOCAL, &sDefault.lock_file,         NULL,0},
- {"log file",          P_STRING, P_LOCAL, &sDefault.log_file,          NULL,0},
- {"log format",        P_STRING, P_LOCAL, &sDefault.log_format,        NULL,0},
- {"max connections",   P_INTEGER,P_LOCAL, &sDefault.max_connections,   NULL,0},
- {"max verbosity",     P_INTEGER,P_LOCAL, &sDefault.max_verbosity,     NULL,0},
- {"munge symlinks",    P_BOOL,   P_LOCAL, &sDefault.munge_symlinks,    NULL,0},
- {"name",              P_STRING, P_LOCAL, &sDefault.name,              NULL,0},
- {"numeric ids",       P_BOOL,   P_LOCAL, &sDefault.numeric_ids,       NULL,0},
- {"outgoing chmod",    P_STRING, P_LOCAL, &sDefault.outgoing_chmod,    NULL,0},
- {"path",              P_PATH,   P_LOCAL, &sDefault.path,              NULL,0},
+ {"address",           P_STRING, P_GLOBAL,&Vars.g.bind_address,        NULL,0},
+ {"listen backlog",    P_INTEGER,P_GLOBAL,&Vars.g.listen_backlog,      NULL,0},
+ {"motd file",         P_STRING, P_GLOBAL,&Vars.g.motd_file,           NULL,0},
+ {"pid file",          P_STRING, P_GLOBAL,&Vars.g.pid_file,            NULL,0},
+ {"port",              P_INTEGER,P_GLOBAL,&Vars.g.rsync_port,          NULL,0},
+ {"socket options",    P_STRING, P_GLOBAL,&Vars.g.socket_options,      NULL,0},
+
+ {"auth users",        P_STRING, P_LOCAL, &Vars.l.auth_users,          NULL,0},
+ {"charset",           P_STRING, P_LOCAL, &Vars.l.charset,             NULL,0},
+ {"comment",           P_STRING, P_LOCAL, &Vars.l.comment,             NULL,0},
+ {"dont compress",     P_STRING, P_LOCAL, &Vars.l.dont_compress,       NULL,0},
+ {"exclude from",      P_STRING, P_LOCAL, &Vars.l.exclude_from,        NULL,0},
+ {"exclude",           P_STRING, P_LOCAL, &Vars.l.exclude,             NULL,0},
+ {"fake super",        P_BOOL,   P_LOCAL, &Vars.l.fake_super,          NULL,0},
+ {"filter",            P_STRING, P_LOCAL, &Vars.l.filter,              NULL,0},
+ {"forward lookup",    P_BOOL,   P_LOCAL, &Vars.l.forward_lookup,      NULL,0},
+ {"gid",               P_STRING, P_LOCAL, &Vars.l.gid,                 NULL,0},
+ {"hosts allow",       P_STRING, P_LOCAL, &Vars.l.hosts_allow,         NULL,0},
+ {"hosts deny",        P_STRING, P_LOCAL, &Vars.l.hosts_deny,          NULL,0},
+ {"ignore errors",     P_BOOL,   P_LOCAL, &Vars.l.ignore_errors,       NULL,0},
+ {"ignore nonreadable",P_BOOL,   P_LOCAL, &Vars.l.ignore_nonreadable,  NULL,0},
+ {"include from",      P_STRING, P_LOCAL, &Vars.l.include_from,        NULL,0},
+ {"include",           P_STRING, P_LOCAL, &Vars.l.include,             NULL,0},
+ {"incoming chmod",    P_STRING, P_LOCAL, &Vars.l.incoming_chmod,      NULL,0},
+ {"list",              P_BOOL,   P_LOCAL, &Vars.l.list,                NULL,0},
+ {"lock file",         P_STRING, P_LOCAL, &Vars.l.lock_file,           NULL,0},
+ {"log file",          P_STRING, P_LOCAL, &Vars.l.log_file,            NULL,0},
+ {"log format",        P_STRING, P_LOCAL, &Vars.l.log_format,          NULL,0},
+ {"max connections",   P_INTEGER,P_LOCAL, &Vars.l.max_connections,     NULL,0},
+ {"max verbosity",     P_INTEGER,P_LOCAL, &Vars.l.max_verbosity,       NULL,0},
+ {"munge symlinks",    P_BOOL,   P_LOCAL, &Vars.l.munge_symlinks,      NULL,0},
+ {"name",              P_STRING, P_LOCAL, &Vars.l.name,                NULL,0},
+ {"numeric ids",       P_BOOL,   P_LOCAL, &Vars.l.numeric_ids,         NULL,0},
+ {"outgoing chmod",    P_STRING, P_LOCAL, &Vars.l.outgoing_chmod,      NULL,0},
+ {"path",              P_PATH,   P_LOCAL, &Vars.l.path,                NULL,0},
 #ifdef HAVE_PUTENV
- {"post-xfer exec",    P_STRING, P_LOCAL, &sDefault.postxfer_exec,     NULL,0},
- {"pre-xfer exec",     P_STRING, P_LOCAL, &sDefault.prexfer_exec,      NULL,0},
+ {"post-xfer exec",    P_STRING, P_LOCAL, &Vars.l.postxfer_exec,       NULL,0},
+ {"pre-xfer exec",     P_STRING, P_LOCAL, &Vars.l.prexfer_exec,        NULL,0},
 #endif
- {"read only",         P_BOOL,   P_LOCAL, &sDefault.read_only,         NULL,0},
- {"refuse options",    P_STRING, P_LOCAL, &sDefault.refuse_options,    NULL,0},
- {"secrets file",      P_STRING, P_LOCAL, &sDefault.secrets_file,      NULL,0},
- {"strict modes",      P_BOOL,   P_LOCAL, &sDefault.strict_modes,      NULL,0},
- {"syslog facility",   P_ENUM,   P_LOCAL, &sDefault.syslog_facility,enum_facilities,0},
- {"temp dir",          P_PATH,   P_LOCAL, &sDefault.temp_dir,          NULL,0},
- {"timeout",           P_INTEGER,P_LOCAL, &sDefault.timeout,           NULL,0},
- {"transfer logging",  P_BOOL,   P_LOCAL, &sDefault.transfer_logging,  NULL,0},
- {"uid",               P_STRING, P_LOCAL, &sDefault.uid,               NULL,0},
- {"use chroot",        P_BOOL,   P_LOCAL, &sDefault.use_chroot,        NULL,0},
- {"write only",        P_BOOL,   P_LOCAL, &sDefault.write_only,        NULL,0},
+ {"read only",         P_BOOL,   P_LOCAL, &Vars.l.read_only,           NULL,0},
+ {"refuse options",    P_STRING, P_LOCAL, &Vars.l.refuse_options,      NULL,0},
+ {"reverse lookup",    P_BOOL,   P_LOCAL, &Vars.l.reverse_lookup,      NULL,0},
+ {"secrets file",      P_STRING, P_LOCAL, &Vars.l.secrets_file,        NULL,0},
+ {"strict modes",      P_BOOL,   P_LOCAL, &Vars.l.strict_modes,        NULL,0},
+ {"syslog facility",   P_ENUM,   P_LOCAL, &Vars.l.syslog_facility,     enum_facilities,0},
+ {"temp dir",          P_PATH,   P_LOCAL, &Vars.l.temp_dir,            NULL,0},
+ {"timeout",           P_INTEGER,P_LOCAL, &Vars.l.timeout,             NULL,0},
+ {"transfer logging",  P_BOOL,   P_LOCAL, &Vars.l.transfer_logging,    NULL,0},
+ {"uid",               P_STRING, P_LOCAL, &Vars.l.uid,                 NULL,0},
+ {"use chroot",        P_BOOL,   P_LOCAL, &Vars.l.use_chroot,          NULL,0},
+ {"write only",        P_BOOL,   P_LOCAL, &Vars.l.write_only,          NULL,0},
  {NULL,                P_BOOL,   P_NONE,  NULL,                        NULL,0}
 };
 
-
-/***************************************************************************
-* Initialise the global parameter structure.
-***************************************************************************/
-static void init_globals(void)
-{
-	memset(&Globals, 0, sizeof Globals);
-}
-
-/***************************************************************************
-* Initialise the sDefault parameter structure.
-***************************************************************************/
-static void init_locals(void)
+/* Initialise the Default all_vars structure. */
+static void reset_all_vars(void)
 {
+	memcpy(&Vars, &Defaults, sizeof Vars);
 }
 
+/* Expand %VAR% references.  Any unknown vars or unrecognized
+ * syntax leaves the raw chars unchanged. */
+static char *expand_vars(char *str)
+{
+	char *buf, *t, *f;
+	int bufsize;
+
+	if (strchr(str, '%') == NULL)
+		return str;
+
+	bufsize = strlen(str) + 2048;
+	if ((buf = new_array(char, bufsize+1)) == NULL) /* +1 for trailing '\0' */
+		out_of_memory("expand_vars");
+
+	for (t = buf, f = str; bufsize && *f; ) {
+		if (*f == '%' && *++f != '%') {
+			char *percent = strchr(f, '%');
+			if (percent) {
+				char *val;
+				*percent = '\0';
+				val = getenv(f);
+				*percent = '%';
+				if (val) {
+					int len = strlcpy(t, val, bufsize+1);
+					if (len > bufsize)
+						break;
+					bufsize -= len;
+					t += len;
+					f = percent + 1;
+					continue;
+				}
+			}
+			f--;
+		}
+		*t++ = *f++;
+		bufsize--;
+	}
+	*t = '\0';
 
-/*
-   In this section all the functions that are used to access the
-   parameters from the rest of the program are defined
-*/
+	if (*f) {
+		rprintf(FLOG, "Overflowed buf in expand_vars() trying to expand: %s\n", str);
+		exit_cleanup(RERR_MALLOC);
+	}
 
-#define FN_GLOBAL_STRING(fn_name,ptr) \
- char *fn_name(void) {return(*(char **)(ptr) ? *(char **)(ptr) : "");}
-#define FN_GLOBAL_BOOL(fn_name,ptr) \
- BOOL fn_name(void) {return(*(BOOL *)(ptr));}
-#define FN_GLOBAL_CHAR(fn_name,ptr) \
- char fn_name(void) {return(*(char *)(ptr));}
-#define FN_GLOBAL_INTEGER(fn_name,ptr) \
- int fn_name(void) {return(*(int *)(ptr));}
+	if (bufsize && (buf = realloc(buf, t - buf + 1)) == NULL)
+		out_of_memory("expand_vars");
 
-#define FN_LOCAL_STRING(fn_name,val) \
- char *fn_name(int i) {return((LP_SNUM_OK(i)&&pSERVICE(i)->val)?pSERVICE(i)->val : (sDefault.val?sDefault.val:""));}
-#define FN_LOCAL_BOOL(fn_name,val) \
- BOOL fn_name(int i) {return(LP_SNUM_OK(i)? pSERVICE(i)->val : sDefault.val);}
-#define FN_LOCAL_CHAR(fn_name,val) \
- char fn_name(int i) {return(LP_SNUM_OK(i)? pSERVICE(i)->val : sDefault.val);}
-#define FN_LOCAL_INTEGER(fn_name,val) \
- int fn_name(int i) {return(LP_SNUM_OK(i)? pSERVICE(i)->val : sDefault.val);}
+	return buf;
+}
 
+/* In this section all the functions that are used to access the
+ * parameters from the rest of the program are defined. */
 
-FN_GLOBAL_STRING(lp_bind_address, &Globals.bind_address)
-FN_GLOBAL_STRING(lp_motd_file, &Globals.motd_file)
-FN_GLOBAL_STRING(lp_pid_file, &Globals.pid_file)
-FN_GLOBAL_STRING(lp_socket_options, &Globals.socket_options)
+#define FN_GLOBAL_STRING(fn_name, ptr) \
+ char *fn_name(void) {return expand_vars(*(char **)(ptr) ? *(char **)(ptr) : "");}
+#define FN_GLOBAL_BOOL(fn_name, ptr) \
+ BOOL fn_name(void) {return *(BOOL *)(ptr);}
+#define FN_GLOBAL_CHAR(fn_name, ptr) \
+ char fn_name(void) {return *(char *)(ptr);}
+#define FN_GLOBAL_INTEGER(fn_name, ptr) \
+ int fn_name(void) {return *(int *)(ptr);}
+
+#define FN_LOCAL_STRING(fn_name, val) \
+ char *fn_name(int i) {return expand_vars(LP_SNUM_OK(i) && iSECTION(i).val ? iSECTION(i).val : Vars.l.val ? Vars.l.val : "");}
+#define FN_LOCAL_BOOL(fn_name, val) \
+ BOOL fn_name(int i) {return LP_SNUM_OK(i)? iSECTION(i).val : Vars.l.val;}
+#define FN_LOCAL_CHAR(fn_name, val) \
+ char fn_name(int i) {return LP_SNUM_OK(i)? iSECTION(i).val : Vars.l.val;}
+#define FN_LOCAL_INTEGER(fn_name, val) \
+ int fn_name(int i) {return LP_SNUM_OK(i)? iSECTION(i).val : Vars.l.val;}
+
+FN_GLOBAL_STRING(lp_bind_address, &Vars.g.bind_address)
+FN_GLOBAL_STRING(lp_motd_file, &Vars.g.motd_file)
+FN_GLOBAL_STRING(lp_pid_file, &Vars.g.pid_file)
+FN_GLOBAL_STRING(lp_socket_options, &Vars.g.socket_options)
 
-FN_GLOBAL_INTEGER(lp_rsync_port, &Globals.rsync_port)
+FN_GLOBAL_INTEGER(lp_listen_backlog, &Vars.g.listen_backlog)
+FN_GLOBAL_INTEGER(lp_rsync_port, &Vars.g.rsync_port)
 
 FN_LOCAL_STRING(lp_auth_users, auth_users)
 FN_LOCAL_STRING(lp_charset, charset)
 FN_LOCAL_STRING(lp_comment, comment)
 FN_LOCAL_STRING(lp_dont_compress, dont_compress)
 FN_LOCAL_STRING(lp_exclude, exclude)
@@ -424,447 +480,367 @@
 FN_LOCAL_INTEGER(lp_max_connections, max_connections)
 FN_LOCAL_INTEGER(lp_max_verbosity, max_verbosity)
 FN_LOCAL_INTEGER(lp_syslog_facility, syslog_facility)
 FN_LOCAL_INTEGER(lp_timeout, timeout)
 
 FN_LOCAL_BOOL(lp_fake_super, fake_super)
+FN_LOCAL_BOOL(lp_forward_lookup, forward_lookup)
 FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
 FN_LOCAL_BOOL(lp_ignore_nonreadable, ignore_nonreadable)
 FN_LOCAL_BOOL(lp_list, list)
 FN_LOCAL_BOOL(lp_munge_symlinks, munge_symlinks)
 FN_LOCAL_BOOL(lp_numeric_ids, numeric_ids)
 FN_LOCAL_BOOL(lp_read_only, read_only)
+FN_LOCAL_BOOL(lp_reverse_lookup, reverse_lookup)
 FN_LOCAL_BOOL(lp_strict_modes, strict_modes)
 FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
 FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
 FN_LOCAL_BOOL(lp_write_only, write_only)
 
-/* local prototypes */
-static int    strwicmp(char *psz1, char *psz2);
-static int    map_parameter(char *parmname);
-static BOOL   set_boolean(BOOL *pb, char *parmvalue);
-static int    getservicebyname(char *name, service *pserviceDest);
-static void   copy_service(service *pserviceDest, service *pserviceSource);
-static BOOL   do_parameter(char *parmname, char *parmvalue);
-static BOOL   do_section(char *sectionname);
-
-
-/***************************************************************************
-* initialise a service to the defaults
-***************************************************************************/
-static void init_service(service *pservice)
-{
-	memset((char *)pservice,0,sizeof(service));
-	copy_service(pservice,&sDefault);
-}
-
-
-/**
- * Assign a copy of @p v to @p *s.  Handles NULL strings.  @p *v must
- * be initialized when this is called, either to NULL or a malloc'd
- * string.
- *
- * @fixme There is a small leak here in that sometimes the existing
- * value will be dynamically allocated, and the old copy is lost.
- * However, we can't always deallocate the old value, because in the
- * case of sDefault, it points to a static string.  It would be nice
- * to have either all-strdup'd values, or to never need to free
- * memory.
- **/
-static void string_set(char **s, const char *v)
+/* Assign a copy of v to *s.  Handles NULL strings.  We don't worry
+ * about overwriting a malloc'd string because the long-running
+ * (port-listening) daemon only loads the config file once, and the
+ * per-job (forked or xinitd-ran) daemon only re-reads the file at
+ * the start, so any lost memory is inconsequential. */
+static inline void string_set(char **s, const char *v)
 {
-	if (!v) {
+	if (!v)
 		*s = NULL;
-		return;
-	}
-	*s = strdup(v);
-	if (!*s)
-		exit_cleanup(RERR_MALLOC);
+	else if (!(*s = strdup(v)))
+		out_of_memory("string_set");
 }
 
+/* Copy the local_vars, strdup'ing any strings.  NOTE:  this depends on
+ * the structure starting with a contiguous list of the char* variables,
+ * and having an accurate count in the LOCAL_STRING_COUNT() macro. */
+static void copy_section(local_vars *psectionDest, local_vars *psectionSource)
+{
+	int count = LOCAL_STRING_COUNT();
+	char **strings = (char**)psectionDest;
+
+	memcpy(psectionDest, psectionSource, sizeof psectionDest[0]);
+	while (count--) {
+		if (strings[count] && !(strings[count] = strdup(strings[count])))
+			out_of_memory("copy_section");
+	}
+}
 
-/***************************************************************************
-* add a new service to the services array initialising it with the given
-* service
-***************************************************************************/
-static int add_a_service(service *pservice, char *name)
+/* Initialise a section to the defaults. */
+static void init_section(local_vars *psection)
 {
-  int i;
-  service tservice;
-  int num_to_alloc = iNumServices+1;
+	memset(psection, 0, sizeof (local_vars));
+	copy_section(psection, &Vars.l);
+}
 
-  tservice = *pservice;
+/* Do a case-insensitive, whitespace-ignoring string compare. */
+static int strwicmp(char *psz1, char *psz2)
+{
+	/* if BOTH strings are NULL, return TRUE, if ONE is NULL return */
+	/* appropriate value. */
+	if (psz1 == psz2)
+		return 0;
+
+	if (psz1 == NULL)
+		return -1;
+
+	if (psz2 == NULL)
+		return 1;
+
+	/* sync the strings on first non-whitespace */
+	while (1) {
+		while (isSpace(psz1))
+			psz1++;
+		while (isSpace(psz2))
+			psz2++;
+		if (toUpper(psz1) != toUpper(psz2) || *psz1 == '\0' || *psz2 == '\0')
+			break;
+		psz1++;
+		psz2++;
+	}
+	return *psz1 - *psz2;
+}
 
-  /* it might already exist */
-  if (name)
-    {
-      i = getservicebyname(name,NULL);
-      if (i >= 0)
-	return(i);
-    }
+/* Find a section by name. Otherwise works like get_section. */
+static int getsectionbyname(char *name)
+{
+	int i;
 
-  i = iNumServices;
+	for (i = section_list.count - 1; i >= 0; i--) {
+		if (strwicmp(iSECTION(i).name, name) == 0)
+			break;
+	}
 
-  ServicePtrs = realloc_array(ServicePtrs, service *, num_to_alloc);
+	return i;
+}
 
-  if (ServicePtrs)
-	  pSERVICE(iNumServices) = new(service);
+/* Add a new section to the sections array w/the default values. */
+static int add_a_section(char *name)
+{
+	int i;
+	local_vars *s;
 
-  if (!ServicePtrs || !pSERVICE(iNumServices))
-	  return(-1);
+	/* it might already exist */
+	if (name) {
+		i = getsectionbyname(name);
+		if (i >= 0)
+			return i;
+	}
 
-  iNumServices++;
+	i = section_list.count;
+	s = EXPAND_ITEM_LIST(&section_list, local_vars, 2);
 
-  init_service(pSERVICE(i));
-  copy_service(pSERVICE(i),&tservice);
-  if (name)
-    string_set(&iSERVICE(i).name,name);
+	init_section(s);
+	if (name)
+		string_set(&s->name, name);
 
-  return(i);
+	return i;
 }
 
-/***************************************************************************
-* Do a case-insensitive, whitespace-ignoring string compare.
-***************************************************************************/
-static int strwicmp(char *psz1, char *psz2)
-{
-   /* if BOTH strings are NULL, return TRUE, if ONE is NULL return */
-   /* appropriate value. */
-   if (psz1 == psz2)
-      return (0);
-   else
-      if (psz1 == NULL)
-         return (-1);
-      else
-          if (psz2 == NULL)
-              return (1);
-
-   /* sync the strings on first non-whitespace */
-   while (1)
-   {
-      while (isSpace(psz1))
-         psz1++;
-      while (isSpace(psz2))
-         psz2++;
-      if (toUpper(psz1) != toUpper(psz2) || *psz1 == '\0' || *psz2 == '\0')
-         break;
-      psz1++;
-      psz2++;
-   }
-   return (*psz1 - *psz2);
-}
-
-/***************************************************************************
-* Map a parameter's string representation to something we can use.
-* Returns False if the parameter string is not recognised, else TRUE.
-***************************************************************************/
+/* Map a parameter's string representation to something we can use.
+ * Returns False if the parameter string is not recognised, else TRUE. */
 static int map_parameter(char *parmname)
 {
-   int iIndex;
+	int iIndex;
 
-   if (*parmname == '-')
-     return(-1);
+	if (*parmname == '-')
+		return -1;
 
-   for (iIndex = 0; parm_table[iIndex].label; iIndex++)
-      if (strwicmp(parm_table[iIndex].label, parmname) == 0)
-         return(iIndex);
+	for (iIndex = 0; parm_table[iIndex].label; iIndex++) {
+		if (strwicmp(parm_table[iIndex].label, parmname) == 0)
+			return iIndex;
+	}
 
-   rprintf(FLOG, "Unknown Parameter encountered: \"%s\"\n", parmname);
-   return(-1);
+	rprintf(FLOG, "Unknown Parameter encountered: \"%s\"\n", parmname);
+	return -1;
 }
 
-
-/***************************************************************************
-* Set a boolean variable from the text value stored in the passed string.
-* Returns True in success, False if the passed string does not correctly
-* represent a boolean.
-***************************************************************************/
+/* Set a boolean variable from the text value stored in the passed string.
+ * Returns True in success, False if the passed string does not correctly
+ * represent a boolean. */
 static BOOL set_boolean(BOOL *pb, char *parmvalue)
 {
-   BOOL bRetval;
+	if (strwicmp(parmvalue, "yes") == 0
+	 || strwicmp(parmvalue, "true") == 0
+	 || strwicmp(parmvalue, "1") == 0)
+		*pb = True;
+	else if (strwicmp(parmvalue, "no") == 0
+	      || strwicmp(parmvalue, "False") == 0
+	      || strwicmp(parmvalue, "0") == 0)
+		*pb = False;
+	else {
+		rprintf(FLOG, "Badly formed boolean in configuration file: \"%s\".\n", parmvalue);
+		return False;
+	}
+	return True;
+}
 
-   bRetval = True;
-   if (strwicmp(parmvalue, "yes") == 0 ||
-       strwicmp(parmvalue, "true") == 0 ||
-       strwicmp(parmvalue, "1") == 0)
-      *pb = True;
-   else
-      if (strwicmp(parmvalue, "no") == 0 ||
-          strwicmp(parmvalue, "False") == 0 ||
-          strwicmp(parmvalue, "0") == 0)
-         *pb = False;
-      else
-      {
-         rprintf(FLOG, "Badly formed boolean in configuration file: \"%s\".\n",
-               parmvalue);
-         bRetval = False;
-      }
-   return (bRetval);
-}
-
-/***************************************************************************
-* Find a service by name. Otherwise works like get_service.
-***************************************************************************/
-static int getservicebyname(char *name, service *pserviceDest)
-{
-   int iService;
-
-   for (iService = iNumServices - 1; iService >= 0; iService--)
-      if (strwicmp(iSERVICE(iService).name, name) == 0)
-      {
-         if (pserviceDest != NULL)
-	   copy_service(pserviceDest, pSERVICE(iService));
-         break;
-      }
-
-   return (iService);
-}
-
-
-
-/***************************************************************************
-* Copy a service structure to another
-***************************************************************************/
-static void copy_service(service *pserviceDest,
-                         service *pserviceSource)
-{
-  int i;
-
-  for (i=0;parm_table[i].label;i++)
-    if (parm_table[i].ptr && parm_table[i].class == P_LOCAL) {
-	void *def_ptr = parm_table[i].ptr;
-	void *src_ptr =
-	  ((char *)pserviceSource) + PTR_DIFF(def_ptr,&sDefault);
-	void *dest_ptr =
-	  ((char *)pserviceDest) + PTR_DIFF(def_ptr,&sDefault);
-
-	switch (parm_table[i].type)
-	  {
-	  case P_BOOL:
-	  case P_BOOLREV:
-	    *(BOOL *)dest_ptr = *(BOOL *)src_ptr;
-	    break;
-
-	  case P_INTEGER:
-	  case P_ENUM:
-	  case P_OCTAL:
-	    *(int *)dest_ptr = *(int *)src_ptr;
-	    break;
-
-	  case P_CHAR:
-	    *(char *)dest_ptr = *(char *)src_ptr;
-	    break;
-
-	  case P_PATH:
-	  case P_STRING:
-	    string_set(dest_ptr,*(char **)src_ptr);
-	    break;
-
-	  default:
-	    break;
-	  }
-      }
-}
-
-
-/***************************************************************************
-* Process a parameter for a particular service number. If snum < 0
-* then assume we are in the globals
-***************************************************************************/
-static BOOL lp_do_parameter(int snum, char *parmname, char *parmvalue)
-{
-   int parmnum, i;
-   void *parm_ptr=NULL; /* where we are going to store the result */
-   void *def_ptr=NULL;
-   char *cp;
-
-   parmnum = map_parameter(parmname);
-
-   if (parmnum < 0)
-     {
-       rprintf(FLOG, "IGNORING unknown parameter \"%s\"\n", parmname);
-       return(True);
-     }
-
-   def_ptr = parm_table[parmnum].ptr;
-
-   /* we might point at a service, the default service or a global */
-   if (snum < 0) {
-     parm_ptr = def_ptr;
-   } else {
-       if (parm_table[parmnum].class == P_GLOBAL) {
-	   rprintf(FLOG, "Global parameter %s found in service section!\n",parmname);
-	   return(True);
-	 }
-       parm_ptr = ((char *)pSERVICE(snum)) + PTR_DIFF(def_ptr,&sDefault);
-   }
-
-   /* now switch on the type of variable it is */
-   switch (parm_table[parmnum].type)
-     {
-     case P_BOOL:
-       set_boolean(parm_ptr,parmvalue);
-       break;
-
-     case P_BOOLREV:
-       set_boolean(parm_ptr,parmvalue);
-       *(BOOL *)parm_ptr = ! *(BOOL *)parm_ptr;
-       break;
-
-     case P_INTEGER:
-       *(int *)parm_ptr = atoi(parmvalue);
-       break;
-
-     case P_CHAR:
-       *(char *)parm_ptr = *parmvalue;
-       break;
-
-     case P_OCTAL:
-       sscanf(parmvalue,"%o",(int *)parm_ptr);
-       break;
-
-     case P_PATH:
-       string_set(parm_ptr,parmvalue);
-       if ((cp = *(char**)parm_ptr) != NULL) {
-	   int len = strlen(cp);
-	   while (len > 1 && cp[len-1] == '/') len--;
-	   cp[len] = '\0';
-       }
-       break;
-
-     case P_STRING:
-       string_set(parm_ptr,parmvalue);
-       break;
-
-     case P_GSTRING:
-       strlcpy((char *)parm_ptr,parmvalue,sizeof(pstring));
-       break;
-
-     case P_ENUM:
-	     for (i=0;parm_table[parmnum].enum_list[i].name;i++) {
-		     if (strequal(parmvalue, parm_table[parmnum].enum_list[i].name)) {
-			     *(int *)parm_ptr = parm_table[parmnum].enum_list[i].value;
-			     break;
-		     }
-	     }
-	     if (!parm_table[parmnum].enum_list[i].name) {
-		     if (atoi(parmvalue) > 0)
-			     *(int *)parm_ptr = atoi(parmvalue);
-	     }
-	     break;
-     case P_SEP:
-	     break;
-     }
-
-   return(True);
-}
-
-/***************************************************************************
-* Process a parameter.
-***************************************************************************/
+/* Process a parameter. */
 static BOOL do_parameter(char *parmname, char *parmvalue)
 {
-   return lp_do_parameter(bInGlobalSection?-2:iServiceIndex, parmname, parmvalue);
+	int parmnum, i;
+	void *parm_ptr; /* where we are going to store the result */
+	void *def_ptr;
+	char *cp;
+
+	parmnum = map_parameter(parmname);
+
+	if (parmnum < 0) {
+		rprintf(FLOG, "IGNORING unknown parameter \"%s\"\n", parmname);
+		return True;
+	}
+
+	def_ptr = parm_table[parmnum].ptr;
+
+	if (bInGlobalSection)
+		parm_ptr = def_ptr;
+	else {
+		if (parm_table[parmnum].class == P_GLOBAL) {
+			rprintf(FLOG, "Global parameter %s found in module section!\n", parmname);
+			return True;
+		}
+		parm_ptr = SECTION_PTR(&iSECTION(iSectionIndex), def_ptr);
+	}
+
+	/* now switch on the type of variable it is */
+	switch (parm_table[parmnum].type) {
+	case P_PATH:
+	case P_STRING:
+		/* delay expansion of vars */
+		break;
+	default:
+		/* expand any %VARS% now */
+		parmvalue = expand_vars(parmvalue);
+		break;
+	}
+
+	switch (parm_table[parmnum].type) {
+	case P_BOOL:
+		set_boolean(parm_ptr, parmvalue);
+		break;
+
+	case P_BOOLREV:
+		set_boolean(parm_ptr, parmvalue);
+		*(BOOL *)parm_ptr = ! *(BOOL *)parm_ptr;
+		break;
+
+	case P_INTEGER:
+		*(int *)parm_ptr = atoi(parmvalue);
+		break;
+
+	case P_CHAR:
+		*(char *)parm_ptr = *parmvalue;
+		break;
+
+	case P_OCTAL:
+		sscanf(parmvalue, "%o", (int *)parm_ptr);
+		break;
+
+	case P_PATH:
+		string_set(parm_ptr, parmvalue);
+		if ((cp = *(char**)parm_ptr) != NULL) {
+			int len = strlen(cp);
+			while (len > 1 && cp[len-1] == '/') len--;
+			cp[len] = '\0';
+		}
+		break;
+
+	case P_STRING:
+		string_set(parm_ptr, parmvalue);
+		break;
+
+	case P_ENUM:
+		for (i=0; parm_table[parmnum].enum_list[i].name; i++) {
+			if (strequal(parmvalue, parm_table[parmnum].enum_list[i].name)) {
+				*(int *)parm_ptr = parm_table[parmnum].enum_list[i].value;
+				break;
+			}
+		}
+		if (!parm_table[parmnum].enum_list[i].name) {
+			if (atoi(parmvalue) > 0)
+				*(int *)parm_ptr = atoi(parmvalue);
+		}
+		break;
+	}
+
+	return True;
 }
 
-/***************************************************************************
-* Process a new section (service). At this stage all sections are services.
-* Later we'll have special sections that permit server parameters to be set.
-* Returns True on success, False on failure.
-***************************************************************************/
+/* Process a new section (rsync module).
+ * Returns True on success, False on failure. */
 static BOOL do_section(char *sectionname)
 {
-   BOOL bRetval;
-   BOOL isglobal = (strwicmp(sectionname, GLOBAL_NAME) == 0);
-   bRetval = False;
-
-   /* if we were in a global section then do the local inits */
-   if (bInGlobalSection && !isglobal)
-     init_locals();
+	BOOL isglobal;
 
-   /* if we've just struck a global section, note the fact. */
-   bInGlobalSection = isglobal;
+	if (*sectionname == ']') { /* A special push/pop/reset directive from params.c */
+		bInGlobalSection = 1;
+		if (strcmp(sectionname+1, "push") == 0) {
+			all_vars *vp = EXPAND_ITEM_LIST(&Vars_stack, all_vars, 2);
+			memcpy(vp, &Vars, sizeof Vars);
+		} else if (strcmp(sectionname+1, "pop") == 0
+		 || strcmp(sectionname+1, "reset") == 0) {
+			all_vars *vp = ((all_vars*)Vars_stack.items) + Vars_stack.count - 1;
+			if (!Vars_stack.count)
+				return False;
+			memcpy(&Vars, vp, sizeof Vars);
+			if (sectionname[1] == 'p')
+				Vars_stack.count--;
+		} else
+			return False;
+		return True;
+	}
 
-   /* check for multiple global sections */
-   if (bInGlobalSection)
-   {
-     return(True);
-   }
+	isglobal = strwicmp(sectionname, GLOBAL_NAME) == 0;
 
-   if (strchr(sectionname, '/') != NULL) {
-     rprintf(FLOG, "Warning: invalid section name in configuration file: %s\n", sectionname);
-     return False;
-   }
+	/* At the end of the global section, add any --dparam items. */
+	if (bInGlobalSection && !isglobal) {
+		if (!section_list.count)
+			set_dparams(0);
+	}
 
-   /* if we have a current service, tidy it up before moving on */
-   bRetval = True;
+	/* if we've just struck a global section, note the fact. */
+	bInGlobalSection = isglobal;
 
-   if (iServiceIndex >= 0)
-     bRetval = True;
+	/* check for multiple global sections */
+	if (bInGlobalSection)
+		return True;
+
+#if 0
+	/* If we have a current section, tidy it up before moving on. */
+	if (iSectionIndex >= 0) {
+		/* Add any tidy work as needed ... */
+		if (problem)
+			return False;
+	}
+#endif
 
-   /* if all is still well, move to the next record in the services array */
-   if (bRetval)
-     {
-       /* We put this here to avoid an odd message order if messages are */
-       /* issued by the post-processing of a previous section. */
+	if (strchr(sectionname, '/') != NULL) {
+		rprintf(FLOG, "Warning: invalid section name in configuration file: %s\n", sectionname);
+		return False;
+	}
 
-       if ((iServiceIndex=add_a_service(&sDefault,sectionname)) < 0)
-	 {
-	   rprintf(FLOG, "Failed to add a new service\n");
-	   return(False);
-	 }
-     }
+	if ((iSectionIndex = add_a_section(sectionname)) < 0) {
+		rprintf(FLOG, "Failed to add a new module\n");
+		bInGlobalSection = True;
+		return False;
+	}
 
-   return (bRetval);
+	return True;
 }
 
-
-/***************************************************************************
-* Load the services array from the services file. Return True on success,
-* False on failure.
-***************************************************************************/
-BOOL lp_load(char *pszFname, int globals_only)
+/* Load the modules from the config file. Return True on success,
+ * False on failure. */
+int lp_load(char *pszFname, int globals_only)
 {
-	pstring n2;
-	BOOL bRetval;
-
-	bRetval = False;
-
 	bInGlobalSection = True;
 
-	init_globals();
-
-	pstrcpy(n2, pszFname);
+	reset_all_vars();
 
-	/* We get sections first, so have to start 'behind' to make up */
-	iServiceIndex = -1;
-	bRetval = pm_process(n2, globals_only?NULL:do_section, do_parameter);
+	/* We get sections first, so have to start 'behind' to make up. */
+	iSectionIndex = -1;
+	return pm_process(pszFname, globals_only ? NULL : do_section, do_parameter);
+}
+
+BOOL set_dparams(int syntax_check_only)
+{
+	char *equal, *val, **params = dparam_list.items;
+	unsigned j;
+
+	for (j = 0; j < dparam_list.count; j++) {
+		equal = strchr(params[j], '='); /* options.c verified this */
+		*equal = '\0';
+		if (syntax_check_only) {
+			if (map_parameter(params[j]) < 0) {
+				rprintf(FERROR, "Unknown parameter \"%s\"\n", params[j]);
+				*equal = '=';
+				return False;
+			}
+		} else {
+			for (val = equal+1; isSpace(val); val++) {}
+			do_parameter(params[j], val);
+		}
+		*equal = '=';
+	}
 
-	return (bRetval);
+	return True;
 }
 
-
-/***************************************************************************
-* return the max number of services
-***************************************************************************/
-int lp_numservices(void)
+/* Return the max number of modules (sections). */
+int lp_num_modules(void)
 {
-  return(iNumServices);
+	return section_list.count;
 }
 
-/***************************************************************************
-* Return the number of the service with the given name, or -1 if it doesn't
-* exist. Note that this is a DIFFERENT ANIMAL from the internal function
-* getservicebyname()! This works ONLY if all services have been loaded, and
-* does not copy the found service.
-***************************************************************************/
+/* Return the number of the module with the given name, or -1 if it doesn't
+ * exist. Note that this is a DIFFERENT ANIMAL from the internal function
+ * getsectionbyname()! This works ONLY if all sections have been loaded,
+ * and does not copy the found section. */
 int lp_number(char *name)
 {
-   int iService;
+	int i;
 
-   for (iService = iNumServices - 1; iService >= 0; iService--)
-      if (strcmp(lp_name(iService), name) == 0)
-         break;
+	for (i = section_list.count - 1; i >= 0; i--) {
+		if (strcmp(lp_name(i), name) == 0)
+			break;
+	}
 
-   return (iService);
+	return i;
 }
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/log.c	2011-01-30 11:25:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/log.c	2013-06-12 04:36:44.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Logging and utility functions.
  *
  * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2000-2001 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,33 +17,36 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
-#include "ifuncs.h"
+#include "itypes.h"
+#include "inums.h"
 
-extern int verbose;
 extern int dry_run;
 extern int am_daemon;
 extern int am_server;
 extern int am_sender;
 extern int am_generator;
 extern int local_server;
 extern int quiet;
 extern int module_id;
-extern int msg_fd_out;
+extern int checksum_len;
 extern int allow_8bit_chars;
 extern int protocol_version;
+extern int always_checksum;
 extern int preserve_times;
-extern int progress_is_active;
+extern int msgs2stderr;
 extern int stdout_format_has_i;
 extern int stdout_format_has_o_or_i;
 extern int logfile_format_has_i;
 extern int logfile_format_has_o_or_i;
 extern int receiver_symlink_times;
+extern int64 total_data_written;
+extern int64 total_data_read;
 extern mode_t orig_umask;
 extern char *auth_user;
 extern char *stdout_format;
 extern char *logfile_format;
 extern char *logfile_name;
 #ifdef ICONV_CONST
@@ -52,19 +55,26 @@
 #ifdef ICONV_OPTION
 extern iconv_t ic_recv;
 #endif
 extern char curr_dir[MAXPATHLEN];
 extern char *full_module_path;
 extern unsigned int module_dirlen;
+extern char sender_file_sum[MAX_DIGEST_LEN];
+extern const char undetermined_hostname[];
 
 static int log_initialised;
 static int logfile_was_closed;
 static FILE *logfile_fp;
 struct stats stats;
 
 int got_xfer_error = 0;
+int output_needs_newline = 0;
+int send_msgs_to_gen = 0;
+
+static int64 initial_data_written;
+static int64 initial_data_read;
 
 struct {
         int code;
         char const *name;
 } const rerr_names[] = {
 	{ RERR_SYNTAX     , "syntax or usage error" },
@@ -82,19 +92,19 @@
 	{ RERR_SIGNAL1    , "received SIGUSR1" },
 	{ RERR_SIGNAL     , "received SIGINT, SIGTERM, or SIGHUP" },
 	{ RERR_WAITCHILD  , "waitpid() failed" },
 	{ RERR_MALLOC     , "error allocating core memory buffers" },
 	{ RERR_PARTIAL    , "some files/attrs were not transferred (see previous errors)" },
 	{ RERR_VANISHED   , "some files vanished before they could be transferred" },
+	{ RERR_DEL_LIMIT  , "the --max-delete limit stopped deletions" },
 	{ RERR_TIMEOUT    , "timeout in data send/receive" },
 	{ RERR_CONTIMEOUT , "timeout waiting for daemon connection" },
 	{ RERR_CMD_FAILED , "remote shell failed" },
 	{ RERR_CMD_KILLED , "remote shell killed" },
 	{ RERR_CMD_RUN    , "remote command could not be run" },
 	{ RERR_CMD_NOTFOUND,"remote command not found" },
-	{ RERR_DEL_LIMIT  , "the --max-delete limit stopped deletions" },
 	{ 0, NULL }
 };
 
 /*
  * Map from rsync error code to name, or return NULL.
  */
@@ -110,14 +120,13 @@
 
 static void logit(int priority, const char *buf)
 {
 	if (logfile_was_closed)
 		logfile_reopen();
 	if (logfile_fp) {
-		fprintf(logfile_fp, "%s [%d] %s",
-			timestring(time(NULL)), (int)getpid(), buf);
+		fprintf(logfile_fp, "%s [%d] %s", timestring(time(NULL)), (int)getpid(), buf);
 		fflush(logfile_fp);
 	} else {
 		syslog(priority, "%s", buf);
 	}
 }
 
@@ -238,25 +247,34 @@
 /* this is the underlying (unformatted) rsync debugging function. Call
  * it with FINFO, FERROR_*, FWARNING, FLOG, or FCLIENT.  Note: recursion
  * can happen with certain fatal conditions. */
 void rwrite(enum logcode code, const char *buf, int len, int is_utf8)
 {
 	int trailing_CR_or_NL;
-	FILE *f = NULL;
+	FILE *f = msgs2stderr ? stderr : stdout;
 #ifdef ICONV_OPTION
 	iconv_t ic = is_utf8 && ic_recv != (iconv_t)-1 ? ic_recv : ic_chck;
 #else
 #ifdef ICONV_CONST
 	iconv_t ic = ic_chck;
 #endif
 #endif
 
 	if (len < 0)
 		exit_cleanup(RERR_MESSAGEIO);
 
-	if (am_server && msg_fd_out >= 0) {
+	if (msgs2stderr) {
+		if (!am_daemon) {
+			if (code == FLOG)
+				return;
+			goto output_msg;
+		}
+		if (code == FCLIENT)
+			return;
+		code = FLOG;
+	} else if (send_msgs_to_gen) {
 		assert(!is_utf8);
 		/* Pass the message to our sibling in native charset. */
 		send_msg((enum msgcode)code, buf, len, 0);
 		return;
 	}
 
@@ -303,48 +321,60 @@
 		if (send_msg(msg, buf, len, !is_utf8))
 			return;
 		if (am_daemon) {
 			/* TODO: can we send the error to the user somehow? */
 			return;
 		}
+		f = stderr;
 	}
 
+output_msg:
 	switch (code) {
 	case FERROR_XFER:
 		got_xfer_error = 1;
 		/* FALL THROUGH */
 	case FERROR:
+	case FERROR_UTF8:
+	case FERROR_SOCKET:
 	case FWARNING:
 		f = stderr;
 		break;
+	case FLOG:
 	case FINFO:
-		f = am_server ? stderr : stdout;
+	case FCLIENT:
 		break;
 	default:
+		fprintf(stderr, "Unknown logcode in rwrite(): %d [%s]\n", (int)code, who_am_i());
 		exit_cleanup(RERR_MESSAGEIO);
 	}
 
-	if (progress_is_active && !am_server) {
+	if (output_needs_newline) {
 		fputc('\n', f);
-		progress_is_active = 0;
+		output_needs_newline = 0;
 	}
 
 	trailing_CR_or_NL = len && (buf[len-1] == '\n' || buf[len-1] == '\r')
 			  ? buf[--len] : 0;
 
+	if (len && buf[0] == '\r') {
+		fputc('\r', f);
+		buf++;
+		len--;
+	}
+
 #ifdef ICONV_CONST
 	if (ic != (iconv_t)-1) {
 		xbuf outbuf, inbuf;
 		char convbuf[1024];
 		int ierrno;
 
 		INIT_CONST_XBUF(outbuf, convbuf);
-		INIT_XBUF(inbuf, (char*)buf, len, -1);
+		INIT_XBUF(inbuf, (char*)buf, len, (size_t)-1);
 
 		while (inbuf.len) {
-			iconvbufs(ic, &inbuf, &outbuf, 0);
+			iconvbufs(ic, &inbuf, &outbuf, inbuf.pos ? 0 : ICB_INIT);
 			ierrno = errno;
 			if (outbuf.len) {
 				filtered_fwrite(f, convbuf, outbuf.len, 0);
 				outbuf.len = 0;
 			}
 			if (!ierrno || ierrno == E2BIG)
@@ -433,29 +463,34 @@
 
 	rwrite(code, buf, len, 0);
 }
 
 void rflush(enum logcode code)
 {
-	FILE *f = NULL;
+	FILE *f;
 
 	if (am_daemon || code == FLOG)
 		return;
 
-	if (code == FINFO && !am_server)
+	if (!am_server && (code == FINFO || code == FCLIENT))
 		f = stdout;
 	else
 		f = stderr;
 
 	fflush(f);
 }
 
+void remember_initial_stats(void)
+{
+	initial_data_read = total_data_read;
+	initial_data_written = total_data_written;
+}
+
 /* A generic logging routine for send/recv, with parameter substitiution. */
 static void log_formatted(enum logcode code, const char *format, const char *op,
-			  struct file_struct *file, const char *fname,
-			  struct stats *initial_stats, int iflags,
+			  struct file_struct *file, const char *fname, int iflags,
 			  const char *hlink)
 {
 	char buf[MAXPATHLEN+1024], buf2[MAXPATHLEN], fmt[32];
 	char *p, *s, *c;
 	const char *n;
 	size_t len, total;
@@ -472,36 +507,51 @@
 		exit_cleanup(RERR_MESSAGEIO);
 	}
 	buf[total++] = '\n';
 	buf[total] = '\0';
 
 	for (p = buf; (p = strchr(p, '%')) != NULL; ) {
+		int humanize = 0;
 		s = p++;
 		c = fmt + 1;
+		while (*p == '\'') {
+			humanize++;
+			p++;
+		}
 		if (*p == '-')
 			*c++ = *p++;
 		while (isDigit(p) && c - fmt < (int)(sizeof fmt) - 8)
 			*c++ = *p++;
+		while (*p == '\'') {
+			humanize++;
+			p++;
+		}
 		if (!*p)
 			break;
 		*c = '\0';
 		n = NULL;
 
+		/* Note for %h and %a: it doesn't matter what fd we pass to
+		 * client_{name,addr} because rsync_module will already have
+		 * forced the answer to be cached (assuming, of course, for %h
+		 * that lp_reverse_lookup(module_id) is true). */
 		switch (*p) {
 		case 'h':
-			if (am_daemon)
-				n = client_name(0);
+			if (am_daemon) {
+				n = lp_reverse_lookup(module_id)
+				  ? client_name(0) : undetermined_hostname;
+			}
 			break;
 		case 'a':
 			if (am_daemon)
 				n = client_addr(0);
 			break;
 		case 'l':
-			strlcat(fmt, ".0f", sizeof fmt);
+			strlcat(fmt, "s", sizeof fmt);
 			snprintf(buf2, sizeof buf2, fmt,
-				 (double)F_LENGTH(file));
+				 do_big_num(F_LENGTH(file), humanize, NULL));
 			n = buf2;
 			break;
 		case 'U':
 			strlcat(fmt, "u", sizeof fmt);
 			snprintf(buf2, sizeof buf2, fmt,
 				 uid_ndx ? F_OWNER(file) : 0);
@@ -515,15 +565,14 @@
 				snprintf(buf2, sizeof buf2, fmt,
 					 F_GROUP(file));
 				n = buf2;
 			}
 			break;
 		case 'p':
-			strlcat(fmt, "ld", sizeof fmt);
-			snprintf(buf2, sizeof buf2, fmt,
-				 (long)getpid());
+			strlcat(fmt, "d", sizeof fmt);
+			snprintf(buf2, sizeof buf2, fmt, (int)getpid());
 			n = buf2;
 			break;
 		case 'M':
 			n = c = timestring(file->modtime);
 			while ((c = strchr(c, ' ')) != NULL)
 				*c = '-';
@@ -604,34 +653,47 @@
 			n = full_module_path;
 			break;
 		case 'u':
 			n = auth_user;
 			break;
 		case 'b':
-			if (am_sender) {
-				b = stats.total_written -
-					initial_stats->total_written;
-			} else {
-				b = stats.total_read -
-					initial_stats->total_read;
-			}
-			strlcat(fmt, ".0f", sizeof fmt);
-			snprintf(buf2, sizeof buf2, fmt, (double)b);
+			if (!(iflags & ITEM_TRANSFER))
+				b = 0;
+			else if (am_sender)
+				b = total_data_written - initial_data_written;
+			else
+				b = total_data_read - initial_data_read;
+			strlcat(fmt, "s", sizeof fmt);
+			snprintf(buf2, sizeof buf2, fmt,
+				 do_big_num(b, humanize, NULL));
 			n = buf2;
 			break;
 		case 'c':
-			if (!am_sender) {
-				b = stats.total_written -
-					initial_stats->total_written;
+			if (!(iflags & ITEM_TRANSFER))
+				b = 0;
+			else if (!am_sender)
+				b = total_data_written - initial_data_written;
+			else
+				b = total_data_read - initial_data_read;
+			strlcat(fmt, "s", sizeof fmt);
+			snprintf(buf2, sizeof buf2, fmt,
+				 do_big_num(b, humanize, NULL));
+			n = buf2;
+			break;
+		case 'C':
+			if (protocol_version >= 30
+			 && (iflags & ITEM_TRANSFER
+			  || (always_checksum && S_ISREG(file->mode)))) {
+				const char *sum = iflags & ITEM_TRANSFER
+						? sender_file_sum : F_SUM(file);
+				n = sum_as_hex(sum);
 			} else {
-				b = stats.total_read -
-					initial_stats->total_read;
+				memset(buf2, ' ', checksum_len*2);
+				buf2[checksum_len*2] = '\0';
+				n = buf2;
 			}
-			strlcat(fmt, ".0f", sizeof fmt);
-			snprintf(buf2, sizeof buf2, fmt, (double)b);
-			n = buf2;
 			break;
 		case 'i':
 			if (iflags & ITEM_DELETED) {
 				n = "*deleting  ";
 				break;
 			}
@@ -725,103 +787,99 @@
 	const char *p;
 
 	if (!format)
 		return 0;
 
 	for (p = format; (p = strchr(p, '%')) != NULL; ) {
-		if (*++p == '-')
+		for (p++; *p == '\''; p++) {} /*SHARED ITERATOR*/
+		if (*p == '-')
 			p++;
 		while (isDigit(p))
 			p++;
+		while (*p == '\'') p++;
 		if (!*p)
 			break;
 		if (*p == esc)
 			return 1;
 	}
 	return 0;
 }
 
 /* Log the transfer of a file.  If the code is FCLIENT, the output just goes
  * to stdout.  If it is FLOG, it just goes to the log file.  Otherwise we
  * output to both. */
-void log_item(enum logcode code, struct file_struct *file,
-	      struct stats *initial_stats, int iflags, const char *hlink)
+void log_item(enum logcode code, struct file_struct *file, int iflags, const char *hlink)
 {
 	const char *s_or_r = am_sender ? "send" : "recv";
 
-	if (code != FLOG && stdout_format && !am_server) {
-		log_formatted(FCLIENT, stdout_format, s_or_r,
-			      file, NULL, initial_stats, iflags, hlink);
-	}
-	if (code != FCLIENT && logfile_format && *logfile_format) {
-		log_formatted(FLOG, logfile_format, s_or_r,
-			      file, NULL, initial_stats, iflags, hlink);
-	}
+	if (code != FLOG && stdout_format && !am_server)
+		log_formatted(FCLIENT, stdout_format, s_or_r, file, NULL, iflags, hlink);
+	if (code != FCLIENT && logfile_format && *logfile_format)
+		log_formatted(FLOG, logfile_format, s_or_r, file, NULL, iflags, hlink);
 }
 
 void maybe_log_item(struct file_struct *file, int iflags, int itemizing,
 		    const char *buf)
 {
 	int significant_flags = iflags & SIGNIFICANT_ITEM_FLAGS;
 	int see_item = itemizing && (significant_flags || *buf
-		|| stdout_format_has_i > 1 || (verbose > 1 && stdout_format_has_i));
+		|| stdout_format_has_i > 1 || (INFO_GTE(NAME, 2) && stdout_format_has_i));
 	int local_change = iflags & ITEM_LOCAL_CHANGE && significant_flags;
 	if (am_server) {
 		if (logfile_name && !dry_run && see_item
 		 && (significant_flags || logfile_format_has_i))
-			log_item(FLOG, file, &stats, iflags, buf);
+			log_item(FLOG, file, iflags, buf);
 	} else if (see_item || local_change || *buf
 	    || (S_ISDIR(file->mode) && significant_flags)) {
 		enum logcode code = significant_flags || logfile_format_has_i ? FINFO : FCLIENT;
-		log_item(code, file, &stats, iflags, buf);
+		log_item(code, file, iflags, buf);
 	}
 }
 
 void log_delete(const char *fname, int mode)
 {
 	static struct {
 		union file_extras ex[4]; /* just in case... */
 		struct file_struct file;
-	} x;
+	} x; /* Zero-initialized due to static declaration. */
 	int len = strlen(fname);
 	const char *fmt;
 
 	x.file.mode = mode;
 
-	if (!verbose && !stdout_format)
+	if (!INFO_GTE(DEL, 1) && !stdout_format)
 		;
 	else if (am_server && protocol_version >= 29 && len < MAXPATHLEN) {
 		if (S_ISDIR(mode))
 			len++; /* directories include trailing null */
 		send_msg(MSG_DELETED, fname, len, am_generator);
 	} else {
 		fmt = stdout_format_has_o_or_i ? stdout_format : "deleting %n";
-		log_formatted(FCLIENT, fmt, "del.", &x.file, fname, &stats,
-			      ITEM_DELETED, NULL);
+		log_formatted(FCLIENT, fmt, "del.", &x.file, fname, ITEM_DELETED, NULL);
 	}
 
 	if (!logfile_name || dry_run || !logfile_format)
 		return;
 
 	fmt = logfile_format_has_o_or_i ? logfile_format : "deleting %n";
-	log_formatted(FLOG, fmt, "del.", &x.file, fname, &stats, ITEM_DELETED, NULL);
+	log_formatted(FLOG, fmt, "del.", &x.file, fname, ITEM_DELETED, NULL);
 }
 
 /*
  * Called when the transfer is interrupted for some reason.
  *
  * Code is one of the RERR_* codes from errcode.h, or terminating
  * successfully.
  */
 void log_exit(int code, const char *file, int line)
 {
 	if (code == 0) {
-		rprintf(FLOG,"sent %.0f bytes  received %.0f bytes  total size %.0f\n",
-			(double)stats.total_written,
-			(double)stats.total_read,
-			(double)stats.total_size);
+		rprintf(FLOG,"sent %s bytes  received %s bytes  total size %s\n",
+			comma_num(stats.total_written),
+			comma_num(stats.total_read),
+			comma_num(stats.total_size));
 	} else if (am_server != 2) {
 		const char *name;
 
 		name = rerr_name(code);
 		if (!name)
 			name = "unexplained error";
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/main.c	2011-06-19 03:44:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/main.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * The startup routines, including main(), for rsync.
  *
  * Copyright (C) 1996-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -18,33 +18,36 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
-#include "ifuncs.h"
+#include "inums.h"
 #include "io.h"
 #if defined CONFIG_LOCALE && defined HAVE_LOCALE_H
 #include <locale.h>
 #endif
 
-extern int verbose;
 extern int dry_run;
 extern int list_only;
+extern int io_timeout;
 extern int am_root;
 extern int am_server;
 extern int am_sender;
 extern int am_daemon;
 extern int inc_recurse;
 extern int blocking_io;
+extern int always_checksum;
 extern int remove_source_files;
+extern int output_needs_newline;
 extern int need_messages_from_generator;
 extern int kluge_around_eof;
-extern int do_stats;
 extern int got_xfer_error;
+extern int msgs2stderr;
 extern int module_id;
+extern int read_only;
 extern int copy_links;
 extern int copy_dirlinks;
 extern int copy_unsafe_links;
 extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int protocol_version;
@@ -59,37 +62,50 @@
 extern int module_id;
 extern int rsync_port;
 extern int whole_file;
 extern int read_batch;
 extern int write_batch;
 extern int batch_fd;
+extern int sock_f_in;
+extern int sock_f_out;
 extern int filesfrom_fd;
 extern int connect_timeout;
+extern int send_msgs_to_gen;
 extern dev_t filesystem_dev;
 extern pid_t cleanup_child_pid;
+extern size_t bwlimit_writemax;
 extern unsigned int module_dirlen;
+extern BOOL flist_receiving_enabled;
+extern BOOL shutting_down;
+extern int basis_dir_cnt;
 extern struct stats stats;
+extern char *stdout_format;
+extern char *logfile_format;
 extern char *filesfrom_host;
 extern char *partial_dir;
 extern char *dest_option;
-extern char *basis_dir[MAX_BASIS_DIRS+1];
 extern char *rsync_path;
 extern char *shell_cmd;
 extern char *batch_name;
 extern char *password_file;
+extern char *backup_dir;
 extern char curr_dir[MAXPATHLEN];
+extern char backup_dir_buf[MAXPATHLEN];
+extern char *basis_dir[MAX_BASIS_DIRS+1];
 extern struct file_list *first_flist;
-extern struct filter_list_struct daemon_filter_list;
+extern filter_rule_list daemon_filter_list;
 
 uid_t our_uid;
+gid_t our_gid;
 int am_receiver = 0;  /* Only set to 1 after the receiver/generator fork. */
 int am_generator = 0; /* Only set to 1 after the receiver/generator fork. */
 int local_server = 0;
 int daemon_over_rsh = 0;
 mode_t orig_umask = 0;
 int batch_gen_fd = -1;
+int sender_keeps_checksum = 0;
 
 /* There's probably never more than at most 2 outstanding child processes,
  * but set it higher, just in case. */
 #define MAXCHILDPROCS 7
 
 #ifdef HAVE_SIGACTION
@@ -113,13 +129,13 @@
 
 /* Works like waitpid(), but if we already harvested the child pid in our
  * remember_children(), we succeed instead of returning an error. */
 pid_t wait_process(pid_t pid, int *status_ptr, int flags)
 {
 	pid_t waited_pid;
-	
+
 	do {
 		waited_pid = waitpid(pid, status_ptr, flags);
 	} while (waited_pid == -1 && errno == EINTR);
 
 	if (waited_pid == -1 && errno == ECHILD) {
 		/* Status of requested child no longer available:  check to
@@ -166,12 +182,36 @@
 		else
 			*exit_code_ptr = RERR_WAITCHILD;
 	} else
 		*exit_code_ptr = WEXITSTATUS(status);
 }
 
+void write_del_stats(int f)
+{
+	if (read_batch)
+		write_int(f, NDX_DEL_STATS);
+	else
+		write_ndx(f, NDX_DEL_STATS);
+	write_varint(f, stats.deleted_files - stats.deleted_dirs
+		      - stats.deleted_symlinks - stats.deleted_devices
+		      - stats.deleted_specials);
+	write_varint(f, stats.deleted_dirs);
+	write_varint(f, stats.deleted_symlinks);
+	write_varint(f, stats.deleted_devices);
+	write_varint(f, stats.deleted_specials);
+}
+
+void read_del_stats(int f)
+{
+	stats.deleted_files = read_varint(f);
+	stats.deleted_files += stats.deleted_dirs = read_varint(f);
+	stats.deleted_files += stats.deleted_symlinks = read_varint(f);
+	stats.deleted_files += stats.deleted_devices = read_varint(f);
+	stats.deleted_files += stats.deleted_specials = read_varint(f);
+}
+
 /* This function gets called from all 3 processes.  We want the client side
  * to actually output the text, but the sender is the only process that has
  * all the stats we need.  So, if we're a client sender, we do the report.
  * If we're a server sender, we write the stats on the supplied fd.  If
  * we're the client receiver we read the stats from the supplied fd and do
  * the report.  All processes might also generate a set of debug stats, if
@@ -182,13 +222,13 @@
 	endtime = time(NULL);
 
 	/* Cache two stats because the read/write code can change it. */
 	total_read = stats.total_read;
 	total_written = stats.total_written;
 
-	if (do_stats && verbose > 1) {
+	if (INFO_GTE(STATS, 3)) {
 		/* These come out from every process */
 		show_malloc_stats();
 		show_flist_stats();
 	}
 
 	if (am_generator)
@@ -236,52 +276,78 @@
 			write_varlong30(batch_fd, stats.flist_buildtime, 3);
 			write_varlong30(batch_fd, stats.flist_xfertime, 3);
 		}
 	}
 }
 
+static void output_itemized_counts(const char *prefix, int *counts)
+{
+	static char *labels[] = { "reg", "dir", "link", "dev", "special" };
+	char buf[1024], *pre = " (";
+	int j, len = 0;
+	int total = counts[0];
+	if (total) {
+		counts[0] -= counts[1] + counts[2] + counts[3] + counts[4];
+		for (j = 0; j < 5; j++) {
+			if (counts[j]) {
+				len += snprintf(buf+len, sizeof buf - len - 2,
+					"%s%s: %s",
+					pre, labels[j], comma_num(counts[j]));
+				pre = ", ";
+			}
+		}
+		buf[len++] = ')';
+	}
+	buf[len] = '\0';
+	rprintf(FINFO, "%s: %s%s\n", prefix, comma_num(total), buf);
+}
+
 static void output_summary(void)
 {
-	if (do_stats) {
+	if (INFO_GTE(STATS, 2)) {
 		rprintf(FCLIENT, "\n");
-		rprintf(FINFO,"Number of files: %d\n", stats.num_files);
-		rprintf(FINFO,"Number of files transferred: %d\n",
-			stats.num_transferred_files);
+		output_itemized_counts("Number of files", &stats.num_files);
+		if (protocol_version >= 29)
+			output_itemized_counts("Number of created files", &stats.created_files);
+		if (protocol_version >= 31)
+			output_itemized_counts("Number of deleted files", &stats.deleted_files);
+		rprintf(FINFO,"Number of regular files transferred: %s\n",
+			comma_num(stats.xferred_files));
 		rprintf(FINFO,"Total file size: %s bytes\n",
 			human_num(stats.total_size));
 		rprintf(FINFO,"Total transferred file size: %s bytes\n",
 			human_num(stats.total_transferred_size));
 		rprintf(FINFO,"Literal data: %s bytes\n",
 			human_num(stats.literal_data));
 		rprintf(FINFO,"Matched data: %s bytes\n",
 			human_num(stats.matched_data));
 		rprintf(FINFO,"File list size: %s\n",
 			human_num(stats.flist_size));
 		if (stats.flist_buildtime) {
 			rprintf(FINFO,
-				"File list generation time: %.3f seconds\n",
-				(double)stats.flist_buildtime / 1000);
+				"File list generation time: %s seconds\n",
+				comma_dnum((double)stats.flist_buildtime / 1000, 3));
 			rprintf(FINFO,
-				"File list transfer time: %.3f seconds\n",
-				(double)stats.flist_xfertime / 1000);
+				"File list transfer time: %s seconds\n",
+				comma_dnum((double)stats.flist_xfertime / 1000, 3));
 		}
 		rprintf(FINFO,"Total bytes sent: %s\n",
 			human_num(total_written));
 		rprintf(FINFO,"Total bytes received: %s\n",
 			human_num(total_read));
 	}
 
-	if (verbose || do_stats) {
+	if (INFO_GTE(STATS, 1)) {
 		rprintf(FCLIENT, "\n");
 		rprintf(FINFO,
 			"sent %s bytes  received %s bytes  %s bytes/sec\n",
 			human_num(total_written), human_num(total_read),
 			human_dnum((total_written + total_read)/(0.5 + (endtime - starttime)), 2));
-		rprintf(FINFO, "total size is %s  speedup is %.2f%s\n",
+		rprintf(FINFO, "total size is %s  speedup is %s%s\n",
 			human_num(stats.total_size),
-			(double)stats.total_size / (total_written+total_read),
+			comma_dnum((double)stats.total_size / (total_written+total_read), 2),
 			write_batch < 0 ? " (BATCH ONLY)" : dry_run ? " (DRY RUN)" : "");
 	}
 
 	fflush(stdout);
 	fflush(stderr);
 }
@@ -296,13 +362,13 @@
 	struct mallinfo mi;
 
 	mi = mallinfo();
 
 	rprintf(FCLIENT, "\n");
 	rprintf(FINFO, RSYNC_NAME "[%d] (%s%s%s) heap statistics:\n",
-		getpid(), am_server ? "server " : "",
+		(int)getpid(), am_server ? "server " : "",
 		am_daemon ? "daemon " : "", who_am_i());
 	rprintf(FINFO, "  arena:     %10ld   (bytes from sbrk)\n",
 		(long)mi.arena);
 	rprintf(FINFO, "  ordblks:   %10ld   (chunks not in use)\n",
 		(long)mi.ordblks);
 	rprintf(FINFO, "  smblks:    %10ld\n",
@@ -329,24 +395,24 @@
 
 /* Start the remote shell.   cmd may be NULL to use the default. */
 static pid_t do_cmd(char *cmd, char *machine, char *user, char **remote_argv, int remote_argc,
 		    int *f_in_p, int *f_out_p)
 {
 	int i, argc = 0;
-	char *args[MAX_ARGS];
+	char *args[MAX_ARGS], *need_to_free = NULL;
 	pid_t pid;
 	int dash_l_set = 0;
 
 	if (!read_batch && !local_server) {
 		char *t, *f, in_quote = '\0';
 		char *rsh_env = getenv(RSYNC_RSH_ENV);
 		if (!cmd)
 			cmd = rsh_env;
 		if (!cmd)
 			cmd = RSYNC_RSH;
-		cmd = strdup(cmd); /* MEMORY LEAK */
+		cmd = need_to_free = strdup(cmd);
 		if (!cmd)
 			goto oom;
 
 		for (t = f = cmd; *f; f++) {
 			if (*f == ' ')
 				continue;
@@ -437,13 +503,13 @@
 			remote_argc--;
 		}
 	}
 
 	args[argc] = NULL;
 
-	if (verbose > 3) {
+	if (DEBUG_GTE(CMD, 2)) {
 		for (i = 0; i < argc; i++)
 			rprintf(FCLIENT, "cmd[%d]=%s ", i, args[i]);
 		rprintf(FCLIENT, "\n");
 	}
 
 	if (read_batch) {
@@ -476,12 +542,15 @@
 		setup_iconv();
 #endif
 		if (protect_args && !daemon_over_rsh)
 			send_protected_args(*f_out_p, args);
 	}
 
+	if (need_to_free)
+		free(need_to_free);
+
 	return pid;
 
   oom:
 	out_of_memory("do_cmd");
 	return 0; /* not reached */
 }
@@ -502,13 +571,13 @@
 static char *get_local_name(struct file_list *flist, char *dest_path)
 {
 	STRUCT_STAT st;
 	int statret;
 	char *cp;
 
-	if (verbose > 2) {
+	if (DEBUG_GTE(RECV, 1)) {
 		rprintf(FINFO, "get_local_name count=%d %s\n",
 			file_total, NS(dest_path));
 	}
 
 	if (!dest_path || list_only)
 		return NULL;
@@ -578,23 +647,23 @@
 		if (statret == 0) {
 			rprintf(FERROR,
 			    "ERROR: destination path is not a directory\n");
 			exit_cleanup(RERR_SYNTAX);
 		}
 
-		if (mkdir_defmode(dest_path) != 0) {
+		if (do_mkdir(dest_path, ACCESSPERMS) != 0) {
 			rsyserr(FERROR, errno, "mkdir %s failed",
 				full_fname(dest_path));
 			exit_cleanup(RERR_FILEIO);
 		}
 
 		if (flist->high >= flist->low
 		 && strcmp(flist->files[flist->low]->basename, ".") == 0)
 			flist->files[0]->flags |= FLAG_DIR_CREATED;
 
-		if (verbose)
+		if (INFO_GTE(NAME, 1))
 			rprintf(FINFO, "created directory %s\n", dest_path);
 
 		if (dry_run) {
 			/* Indicate that dest dir doesn't really exist. */
 			dry_run++;
 		}
@@ -634,54 +703,69 @@
  * tweak any dest-relative paths to make them work for a dry-run (the
  * destination dir must be in curr_dir[] when this function is called).
  * We also warn about any arg that is non-existent or not a directory. */
 static void check_alt_basis_dirs(void)
 {
 	STRUCT_STAT st;
-	char **dir_p, *slash = strrchr(curr_dir, '/');
+	char *slash = strrchr(curr_dir, '/');
+	int j;
 
-	for (dir_p = basis_dir; *dir_p; dir_p++) {
-		if (dry_run > 1 && **dir_p != '/') {
-			int len = curr_dir_len + 1 + strlen(*dir_p) + 1;
+	for (j = 0; j < basis_dir_cnt; j++) {
+		char *bdir = basis_dir[j];
+		int bd_len = strlen(bdir);
+		if (bd_len > 1 && bdir[bd_len-1] == '/')
+			bdir[--bd_len] = '\0';
+		if (dry_run > 1 && *bdir != '/') {
+			int len = curr_dir_len + 1 + bd_len + 1;
 			char *new = new_array(char, len);
 			if (!new)
 				out_of_memory("check_alt_basis_dirs");
-			if (slash && strncmp(*dir_p, "../", 3) == 0) {
+			if (slash && strncmp(bdir, "../", 3) == 0) {
 			    /* We want to remove only one leading "../" prefix for
 			     * the directory we couldn't create in dry-run mode:
 			     * this ensures that any other ".." references get
 			     * evaluated the same as they would for a live copy. */
 			    *slash = '\0';
-			    pathjoin(new, len, curr_dir, *dir_p + 3);
+			    pathjoin(new, len, curr_dir, bdir + 3);
 			    *slash = '/';
 			} else
-			    pathjoin(new, len, curr_dir, *dir_p);
-			*dir_p = new;
-		}
-		if (do_stat(*dir_p, &st) < 0) {
-			rprintf(FWARNING, "%s arg does not exist: %s\n",
-				dest_option, *dir_p);
-		} else if (!S_ISDIR(st.st_mode)) {
-			rprintf(FWARNING, "%s arg is not a dir: %s\n",
-				dest_option, *dir_p);
+			    pathjoin(new, len, curr_dir, bdir);
+			basis_dir[j] = bdir = new;
 		}
+		if (do_stat(bdir, &st) < 0)
+			rprintf(FWARNING, "%s arg does not exist: %s\n", dest_option, bdir);
+		else if (!S_ISDIR(st.st_mode))
+			rprintf(FWARNING, "%s arg is not a dir: %s\n", dest_option, bdir);
 	}
 }
 
 /* This is only called by the sender. */
-static void read_final_goodbye(int f_in)
+static void read_final_goodbye(int f_in, int f_out)
 {
 	int i, iflags, xlen;
 	uchar fnamecmp_type;
 	char xname[MAXPATHLEN];
 
+	shutting_down = True;
+
 	if (protocol_version < 29)
 		i = read_int(f_in);
 	else {
-		i = read_ndx_and_attrs(f_in, &iflags, &fnamecmp_type,
-				       xname, &xlen);
+		i = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type, xname, &xlen);
+		if (protocol_version >= 31 && i == NDX_DONE) {
+			if (am_sender)
+				write_ndx(f_out, NDX_DONE);
+			else {
+				if (batch_gen_fd >= 0) {
+					while (read_int(batch_gen_fd) != NDX_DEL_STATS) {}
+					read_del_stats(batch_gen_fd);
+				}
+				write_int(f_out, NDX_DONE);
+			}
+			i = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type, xname, &xlen);
+		}
 	}
 
 	if (i != NDX_DONE) {
 		rprintf(FERROR, "Invalid packet at end of run (%d) [%s]\n",
 			i, who_am_i());
 		exit_cleanup(RERR_PROTOCOL);
@@ -690,23 +774,21 @@
 
 static void do_server_sender(int f_in, int f_out, int argc, char *argv[])
 {
 	struct file_list *flist;
 	char *dir = argv[0];
 
-	if (verbose > 2) {
-		rprintf(FINFO, "server_sender starting pid=%ld\n",
-			(long)getpid());
-	}
+	if (DEBUG_GTE(SEND, 1))
+		rprintf(FINFO, "server_sender starting pid=%d\n", (int)getpid());
 
 	if (am_daemon && lp_write_only(module_id)) {
 		rprintf(FERROR, "ERROR: module is write only\n");
 		exit_cleanup(RERR_SYNTAX);
 		return;
 	}
-	if (am_daemon && lp_read_only(module_id) && remove_source_files) {
+	if (am_daemon && read_only && remove_source_files) {
 		rprintf(FERROR,
 		    "ERROR: --remove-%s-files cannot be used with a read-only module\n",
 		    remove_source_files == 1 ? "source" : "sent");
 		exit_cleanup(RERR_SYNTAX);
 		return;
 	}
@@ -725,22 +807,26 @@
 		argc = 1;
 		argv--;
 		argv[0] = ".";
 	}
 
 	flist = send_file_list(f_out,argc,argv);
-	if (!flist || flist->used == 0)
+	if (!flist || flist->used == 0) {
+		/* Make sure input buffering is off so we can't hang in noop_io_until_death(). */
+		io_end_buffering_in(0);
+		/* TODO:  we should really exit in a more controlled manner. */
 		exit_cleanup(0);
+	}
 
 	io_start_buffering_in(f_in);
 
 	send_files(f_in, f_out);
 	io_flush(FULL_FLUSH);
 	handle_stats(f_out);
 	if (protocol_version >= 24)
-		read_final_goodbye(f_in);
+		read_final_goodbye(f_in, f_out);
 	io_flush(FULL_FLUSH);
 	exit_cleanup(0);
 }
 
 
 static int do_recv(int f_in, int f_out, char *local_name)
@@ -760,53 +846,68 @@
 
 	if (fd_pair(error_pipe) < 0) {
 		rsyserr(FERROR, errno, "pipe failed in do_recv");
 		exit_cleanup(RERR_IPC);
 	}
 
-	io_flush(NORMAL_FLUSH);
+	if (backup_dir) {
+		int ret = make_path(backup_dir_buf, MKP_DROP_NAME); /* drops trailing slash */
+		if (ret < 0)
+			exit_cleanup(RERR_SYNTAX);
+		if (ret)
+			rprintf(FINFO, "Created backup_dir %s\n", backup_dir_buf);
+		else if (INFO_GTE(BACKUP, 1))
+			rprintf(FINFO, "backup_dir is %s\n", backup_dir_buf);
+	}
+
+	io_flush(FULL_FLUSH);
 
 	if ((pid = do_fork()) == -1) {
 		rsyserr(FERROR, errno, "fork failed in do_recv");
 		exit_cleanup(RERR_IPC);
 	}
 
 	if (pid == 0) {
 		am_receiver = 1;
+		send_msgs_to_gen = am_server;
 
 		close(error_pipe[0]);
+
+		/* We can't let two processes write to the socket at one time. */
+		io_end_multiplex_out(MPLX_SWITCHING);
 		if (f_in != f_out)
 			close(f_out);
+		sock_f_out = -1;
+		f_out = error_pipe[1];
 
-		/* we can't let two processes write to the socket at one time */
-		io_end_multiplex_out();
+		bwlimit_writemax = 0; /* receiver doesn't need to do this */
 
-		/* set place to send errors */
-		set_msg_fd_out(error_pipe[1]);
-		io_start_buffering_out(error_pipe[1]);
+		if (read_batch)
+			io_start_buffering_in(f_in);
+		io_start_multiplex_out(f_out);
 
-		recv_files(f_in, local_name);
+		recv_files(f_in, f_out, local_name);
 		io_flush(FULL_FLUSH);
 		handle_stats(f_in);
 
-		send_msg(MSG_DONE, "", 1, 0);
-		write_varlong(error_pipe[1], stats.total_read, 3);
+		if (output_needs_newline) {
+			fputc('\n', stdout);
+			output_needs_newline = 0;
+		}
+
+		write_int(f_out, NDX_DONE);
+		send_msg(MSG_STATS, (char*)&stats.total_read, sizeof stats.total_read, 0);
 		io_flush(FULL_FLUSH);
 
 		/* Handle any keep-alive packets from the post-processing work
 		 * that the generator does. */
 		if (protocol_version >= 29) {
-			int iflags, xlen;
-			uchar fnamecmp_type;
-			char xname[MAXPATHLEN];
-
 			kluge_around_eof = -1;
 
 			/* This should only get stopped via a USR2 signal. */
-			read_ndx_and_attrs(f_in, &iflags, &fnamecmp_type,
-					   xname, &xlen);
+			read_final_goodbye(f_in, f_out);
 
 			rprintf(FERROR, "Invalid packet at end of run [%s]\n",
 				who_am_i());
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
@@ -815,25 +916,26 @@
 		 * a signal won't interrupt a sleep! */
 		while (1)
 			msleep(20);
 	}
 
 	am_generator = 1;
+	flist_receiving_enabled = True;
 
-	io_end_multiplex_in();
+	io_end_multiplex_in(MPLX_SWITCHING);
 	if (write_batch && !am_server)
 		stop_write_batch();
 
 	close(error_pipe[1]);
 	if (f_in != f_out)
 		close(f_in);
+	sock_f_in = -1;
+	f_in = error_pipe[0];
 
 	io_start_buffering_out(f_out);
-
-	set_msg_fd_in(error_pipe[0]);
-	io_start_buffering_in(error_pipe[0]);
+	io_start_multiplex_in(f_in);
 
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && inc_recurse) {
 		struct file_list *flist;
 		for (flist = first_flist; flist; flist = flist->next)
 			match_hard_links(flist);
@@ -841,43 +943,43 @@
 #endif
 
 	generate_files(f_out, local_name);
 
 	handle_stats(-1);
 	io_flush(FULL_FLUSH);
+	shutting_down = True;
 	if (protocol_version >= 24) {
 		/* send a final goodbye message */
 		write_ndx(f_out, NDX_DONE);
 	}
 	io_flush(FULL_FLUSH);
 
-	set_msg_fd_in(-1);
 	kill(pid, SIGUSR2);
 	wait_process_with_flush(pid, &exit_code);
 	return exit_code;
 }
 
 static void do_server_recv(int f_in, int f_out, int argc, char *argv[])
 {
 	int exit_code;
 	struct file_list *flist;
 	char *local_name = NULL;
-	int save_verbose = verbose;
+	int negated_levels;
 
-	if (filesfrom_fd >= 0) {
+	if (filesfrom_fd >= 0 && !msgs2stderr && protocol_version < 31) {
 		/* We can't mix messages with files-from data on the socket,
-		 * so temporarily turn off verbose messages. */
-		verbose = 0;
-	}
+		 * so temporarily turn off info/debug messages. */
+		negate_output_levels();
+		negated_levels = 1;
+	} else
+		negated_levels = 0;
 
-	if (verbose > 2) {
-		rprintf(FINFO, "server_recv(%d) starting pid=%ld\n",
-			argc, (long)getpid());
-	}
+	if (DEBUG_GTE(RECV, 1))
+		rprintf(FINFO, "server_recv(%d) starting pid=%d\n", argc, (int)getpid());
 
-	if (am_daemon && lp_read_only(module_id)) {
+	if (am_daemon && read_only) {
 		rprintf(FERROR,"ERROR: module is read only\n");
 		exit_cleanup(RERR_SYNTAX);
 		return;
 	}
 
 	if (argc > 0) {
@@ -889,35 +991,37 @@
 				full_fname(dir));
 			exit_cleanup(RERR_FILESELECT);
 		}
 	}
 
 	if (protocol_version >= 30)
-		io_start_multiplex_in();
+		io_start_multiplex_in(f_in);
 	else
 		io_start_buffering_in(f_in);
 	recv_filter_list(f_in);
 
 	if (filesfrom_fd >= 0) {
 		/* We need to send the files-from names to the sender at the
 		 * same time that we receive the file-list from them, so we
 		 * need the IO routines to automatically write out the names
 		 * onto our f_out socket as we read the file-list.  This
 		 * avoids both deadlock and extra delays/buffers. */
-		io_set_filesfrom_fds(filesfrom_fd, f_out);
+		start_filesfrom_forwarding(filesfrom_fd);
 		filesfrom_fd = -1;
 	}
 
 	flist = recv_file_list(f_in);
 	if (!flist) {
 		rprintf(FERROR,"server_recv: recv_file_list error\n");
 		exit_cleanup(RERR_FILESELECT);
 	}
 	if (inc_recurse && file_total == 1)
 		recv_additional_file_list(f_in);
-	verbose = save_verbose;
+
+	if (negated_levels)
+		negate_output_levels();
 
 	if (argc > 0)
 		local_name = get_local_name(flist,argv[0]);
 
 	/* Now that we know what our destination directory turned out to be,
 	 * we can sanitize the --link-/copy-/compare-dest args correctly. */
@@ -929,13 +1033,13 @@
 			partial_dir = sanitize_path(NULL, partial_dir, NULL, curr_dir_depth, SP_DEFAULT);
 	}
 	check_alt_basis_dirs();
 
 	if (daemon_filter_list.head) {
 		char **dir_p;
-		struct filter_list_struct *elp = &daemon_filter_list;
+		filter_rule_list *elp = &daemon_filter_list;
 
 		for (dir_p = basis_dir; *dir_p; dir_p++) {
 			char *dir = *dir_p;
 			if (*dir == '/')
 				dir += module_dirlen;
 			if (check_filter(elp, FLOG, dir, 1) < 0)
@@ -968,30 +1072,31 @@
 	set_nonblocking(f_out);
 
 	io_set_sock_fds(f_in, f_out);
 	setup_protocol(f_out, f_in);
 
 	if (protocol_version >= 23)
-		io_start_multiplex_out();
+		io_start_multiplex_out(f_out);
+	if (am_daemon && io_timeout && protocol_version >= 31)
+		send_msg_int(MSG_IO_TIMEOUT, io_timeout);
 
 	if (am_sender) {
 		keep_dirlinks = 0; /* Must be disabled on the sender. */
 		if (need_messages_from_generator)
-			io_start_multiplex_in();
+			io_start_multiplex_in(f_in);
+		else
+			io_start_buffering_in(f_in);
 		recv_filter_list(f_in);
 		do_server_sender(f_in, f_out, argc, argv);
 	} else
 		do_server_recv(f_in, f_out, argc, argv);
 	exit_cleanup(0);
 }
 
-
-/*
- * This is called once the connection has been negotiated.  It is used
- * for rsyncd, remote-shell, and local connections.
- */
+/* This is called once the connection has been negotiated.  It is used
+ * for rsyncd, remote-shell, and local connections. */
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[])
 {
 	struct file_list *flist = NULL;
 	int exit_code = 0, exit_code2 = 0;
 	char *local_name = NULL;
 
@@ -1013,59 +1118,69 @@
 	 * this until after the above protocol setup so that we know for sure
 	 * that ssh is done twiddling its file descriptors.  */
 	set_blocking(STDERR_FILENO);
 
 	if (am_sender) {
 		keep_dirlinks = 0; /* Must be disabled on the sender. */
+
+		if (always_checksum
+		 && (log_format_has(stdout_format, 'C')
+		  || log_format_has(logfile_format, 'C')))
+			sender_keeps_checksum = 1;
+
 		if (protocol_version >= 30)
-			io_start_multiplex_out();
+			io_start_multiplex_out(f_out);
 		else
 			io_start_buffering_out(f_out);
-		if (!filesfrom_host)
-			set_msg_fd_in(f_in);
+		if (protocol_version >= 31 || (!filesfrom_host && protocol_version >= 23))
+			io_start_multiplex_in(f_in);
+		else
+			io_start_buffering_in(f_in);
 		send_filter_list(f_out);
 		if (filesfrom_host)
 			filesfrom_fd = f_in;
 
 		if (write_batch && !am_server)
 			start_write_batch(f_out);
 		flist = send_file_list(f_out, argc, argv);
-		if (verbose > 3)
+		if (DEBUG_GTE(FLIST, 3))
 			rprintf(FINFO,"file list sent\n");
 
-		if (protocol_version >= 23)
-			io_start_multiplex_in();
+		if (protocol_version < 31 && filesfrom_host && protocol_version >= 23)
+			io_start_multiplex_in(f_in);
 
 		io_flush(NORMAL_FLUSH);
 		send_files(f_in, f_out);
 		io_flush(FULL_FLUSH);
 		handle_stats(-1);
 		if (protocol_version >= 24)
-			read_final_goodbye(f_in);
+			read_final_goodbye(f_in, f_out);
 		if (pid != -1) {
-			if (verbose > 3)
+			if (DEBUG_GTE(EXIT, 2))
 				rprintf(FINFO,"client_run waiting on %d\n", (int) pid);
 			io_flush(FULL_FLUSH);
 			wait_process_with_flush(pid, &exit_code);
 		}
 		output_summary();
 		io_flush(FULL_FLUSH);
 		exit_cleanup(exit_code);
 	}
 
 	if (!read_batch) {
 		if (protocol_version >= 23)
-			io_start_multiplex_in();
+			io_start_multiplex_in(f_in);
 		if (need_messages_from_generator)
-			io_start_multiplex_out();
+			io_start_multiplex_out(f_out);
+		else
+			io_start_buffering_out(f_out);
 	}
 
 	send_filter_list(read_batch ? -1 : f_out);
 
 	if (filesfrom_fd >= 0) {
-		io_set_filesfrom_fds(filesfrom_fd, f_out);
+		start_filesfrom_forwarding(filesfrom_fd);
 		filesfrom_fd = -1;
 	}
 
 	if (write_batch && !am_server)
 		start_write_batch(f_in);
 	flist = recv_file_list(f_in);
@@ -1081,13 +1196,13 @@
 	} else {
 		handle_stats(-1);
 		output_summary();
 	}
 
 	if (pid != -1) {
-		if (verbose > 3)
+		if (DEBUG_GTE(RECV, 1))
 			rprintf(FINFO,"client_run2 waiting on %d\n", (int) pid);
 		io_flush(FULL_FLUSH);
 		wait_process_with_flush(pid, &exit_code);
 	}
 
 	return MAX(exit_code, exit_code2);
@@ -1106,20 +1221,18 @@
 	}
 
 	return 0;
 }
 
 
-/**
- * Start a client for either type of remote connection.  Work out
+/* Start a client for either type of remote connection.  Work out
  * whether the arguments request a remote shell or rsyncd connection,
  * and call the appropriate connection function, then run_client.
  *
  * Calls either start_socket_client (for sockets) or do_cmd and
- * client_run (for ssh).
- **/
+ * client_run (for ssh). */
 static int start_client(int argc, char *argv[])
 {
 	char *p, *shell_machine = NULL, *shell_user = NULL;
 	char **remote_argv;
 	int remote_argc;
 	int f_in, f_out;
@@ -1200,12 +1313,15 @@
 			exit_cleanup(RERR_SYNTAX);
 		}
 		remote_argv = argv += argc - 1;
 		remote_argc = argc = 1;
 	}
 
+	if (!rsync_port && remote_argc && !**remote_argv) /* Turn an empty arg into a dot dir. */
+		*remote_argv = ".";
+
 	if (am_sender) {
 		char *dummy_host;
 		int dummy_port = rsync_port;
 		int i;
 		/* For local source, extra source args must not have hostspec. */
 		for (i = 1; i < argc; i++) {
@@ -1235,12 +1351,14 @@
 				if (!rsync_port || !dummy_port)
 					rprintf(FERROR, "All source args must use the same hostspec format.\n");
 				else
 					rprintf(FERROR, "All source args must use the same port number.\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
+			if (!rsync_port && !*arg) /* Turn an empty arg into a dot dir. */
+				arg = ".";
 			remote_argv[i] = arg;
 		}
 	}
 
 	if (daemon_over_rsh < 0)
 		return start_socket_client(shell_machine, remote_argc, remote_argv, argc, argv);
@@ -1263,16 +1381,16 @@
 			*p = 0;
 			shell_user = shell_machine;
 			shell_machine = p+1;
 		}
 	}
 
-	if (verbose > 3) {
+	if (DEBUG_GTE(CMD, 2)) {
 		rprintf(FINFO,"cmd=%s machine=%s user=%s path=%s\n",
 			NS(shell_cmd), NS(shell_machine), NS(shell_user),
-			remote_argv ? NS(remote_argv[0]) : "");
+			NS(remote_argv[0]));
 	}
 
 	pid = do_cmd(shell_cmd, shell_machine, shell_user, remote_argv, remote_argc,
 		     &f_in, &f_out);
 
 	/* if we're running an rsync server on the remote host over a
@@ -1369,16 +1487,15 @@
  * should just look at the environment variable, but I'm a bit leery
  * of a signal sending us into a busy loop.
  **/
 static RETSIGTYPE rsync_panic_handler(UNUSED(int whatsig))
 {
 	char cmd_buf[300];
-	int ret;
+	int ret, pid_int = getpid();
 
-	snprintf(cmd_buf, sizeof cmd_buf, get_panic_action(),
-		 getpid(), getpid());
+	snprintf(cmd_buf, sizeof cmd_buf, get_panic_action(), pid_int, pid_int);
 
 	/* Unless we failed to execute gdb, we allow the process to
 	 * continue.  I'm not sure if that's right. */
 	ret = system(cmd_buf);
 	if (ret)
 		_exit(ret);
@@ -1408,24 +1525,26 @@
 	SIGACTMASK(SIGABRT, rsync_panic_handler);
 	SIGACTMASK(SIGBUS, rsync_panic_handler);
 #endif
 
 	starttime = time(NULL);
 	our_uid = MY_UID();
+	our_gid = MY_GID();
 	am_root = our_uid == 0;
 
 	memset(&stats, 0, sizeof(stats));
 
 	if (argc < 2) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
-	/* we set a 0 umask so that correct file permissions can be
-	 * carried across */
-	orig_umask = umask(0);
+	/* Get the umask for use in permission calculations.  We no longer set
+	 * it to zero; that is ugly and pointless now that all the callers that
+	 * relied on it have been reeducated to work with default ACLs. */
+	umask(orig_umask = umask(0));
 
 #if defined CONFIG_LOCALE && defined HAVE_SETLOCALE
 	setlocale(LC_CTYPE, "");
 #endif
 
 	if (!parse_arguments(&argc, (const char ***) &argv)) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/Makefile.in	2011-03-27 01:01:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/Makefile.in	2013-06-16 07:40:10.000000000 +0800
@@ -1,12 +1,13 @@
 # Makefile for rsync. This is processed by configure to produce the final
 # Makefile
 
 prefix=@prefix@
 datarootdir=@datarootdir@
 exec_prefix=@exec_prefix@
+stunnel4=@STUNNEL4@
 bindir=@bindir@
 mandir=@mandir@
 
 LIBS=@LIBS@
 CC=@CC@
 CFLAGS=@CFLAGS@
@@ -15,63 +16,79 @@
 LDFLAGS=@LDFLAGS@
 
 INSTALLCMD=@INSTALL@
 INSTALLMAN=@INSTALL@
 
 srcdir=@srcdir@
+MKDIR_P=@MKDIR_P@
 VPATH=$(srcdir)
 SHELL=/bin/sh
 
-VERSION=@VERSION@
+VERSION=@RSYNC_VERSION@
 
 .SUFFIXES:
 .SUFFIXES: .c .o
 
 GENFILES=configure.sh config.h.in proto.h proto.h-tstamp rsync.1 rsyncd.conf.5
-HEADERS=byteorder.h config.h errcode.h proto.h rsync.h ifuncs.h lib/pool_alloc.h
+HEADERS=byteorder.h config.h errcode.h proto.h rsync.h ifuncs.h itypes.h inums.h \
+	lib/pool_alloc.h
 LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o lib/md5.o \
 	lib/permstring.o lib/pool_alloc.o lib/sysacls.o lib/sysxattrs.o @LIBOBJS@
-ZLIBOBJ=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
+zlib_OBJS=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
 	zlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o
 OBJS1=flist.o rsync.o generator.o receiver.o cleanup.o sender.o exclude.o \
-	util.o main.o checksum.o match.o syscall.o log.o backup.o
+	util.o util2.o main.o checksum.o match.o syscall.o log.o backup.o delete.o
 OBJS2=options.o io.o compat.o hlink.o token.o uidlist.o socket.o hashtable.o \
 	fileio.o batch.o clientname.o chmod.o acls.o xattrs.o
 OBJS3=progress.o pipe.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 	popt/popthelp.o popt/poptparse.o
-OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
+OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) @BUILD_ZLIB@ @BUILD_POPT@
 
 TLS_OBJ = tls.o syscall.o lib/compat.o lib/snprintf.o lib/permstring.o lib/sysxattrs.o @BUILD_POPT@
 
 # Programs we must have to run the test cases
 CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) getfsdev$(EXEEXT) \
-	trimslash$(EXEEXT) t_unsafe$(EXEEXT) wildtest$(EXEEXT)
+	testrun$(EXEEXT) trimslash$(EXEEXT) t_unsafe$(EXEEXT) wildtest$(EXEEXT)
 
 CHECK_SYMLINKS = testsuite/chown-fake.test testsuite/devices-fake.test testsuite/xattrs-hlink.test
 
 # Objects for CHECK_PROGS to clean
-CHECK_OBJS=tls.o getgroups.o getfsdev.o t_stub.o t_unsafe.o trimslash.o wildtest.o
+CHECK_OBJS=tls.o testrun.o getgroups.o getfsdev.o t_stub.o t_unsafe.o trimslash.o wildtest.o
 
 # note that the -I. is needed to handle config.h when using VPATH
 .c.o:
 @OBJ_SAVE@
 	$(CC) -I. -I$(srcdir) $(CFLAGS) $(CPPFLAGS) -c $< @CC_SHOBJ_FLAG@
 @OBJ_RESTORE@
 
-all: Makefile rsync$(EXEEXT) @MAKE_MAN@
+all: Makefile rsync$(EXEEXT) rsync-ssl stunnel-rsync stunnel-rsyncd.conf @MAKE_MAN@
 
 install: all
-	-mkdir -p ${DESTDIR}${bindir}
+	-${MKDIR_P} ${DESTDIR}${bindir}
 	${INSTALLCMD} ${INSTALL_STRIP} -m 755 rsync$(EXEEXT) ${DESTDIR}${bindir}
-	-mkdir -p ${DESTDIR}${mandir}/man1
-	-mkdir -p ${DESTDIR}${mandir}/man5
+	-${MKDIR_P} ${DESTDIR}${mandir}/man1
+	-${MKDIR_P} ${DESTDIR}${mandir}/man5
 	if test -f rsync.1; then ${INSTALLMAN} -m 644 rsync.1 ${DESTDIR}${mandir}/man1; fi
 	if test -f rsyncd.conf.5; then ${INSTALLMAN} -m 644 rsyncd.conf.5 ${DESTDIR}${mandir}/man5; fi
 
+install-ssl-client: rsync-ssl stunnel-rsync
+	-${MKDIR_P} ${DESTDIR}${bindir}
+	${INSTALLCMD} ${INSTALL_STRIP} -m 755 rsync-ssl ${DESTDIR}${bindir}
+	${INSTALLCMD} ${INSTALL_STRIP} -m 755 stunnel-rsync ${DESTDIR}${bindir}
+
+install-ssl-daemon: stunnel-rsyncd.conf
+	-${MKDIR_P} ${DESTDIR}/etc/stunnel
+	${INSTALLCMD} ${INSTALL_STRIP} -m 644 stunnel-rsyncd.conf ${DESTDIR}/etc/stunnel/rsyncd.conf
+	@if ! ls /etc/rsync-ssl/certs/server.* >/dev/null 2>/dev/null; then \
+	    echo "Note that you'll need to install the certificate used by /etc/stunnel/rsyncd.conf"; \
+	fi
+
+install-all: install install-ssl-client install-ssl-daemon
+
 install-strip:
 	$(MAKE) INSTALL_STRIP='-s' install
 
 rsync$(EXEEXT): $(OBJS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
 
@@ -98,23 +115,26 @@
 	fi
 	@rm -f rounding.out
 
 tls$(EXEEXT): $(TLS_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TLS_OBJ) $(LIBS)
 
+testrun$(EXEEXT): testrun.o
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ testrun.o
+
 getgroups$(EXEEXT): getgroups.o
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getgroups.o $(LIBS)
 
 getfsdev$(EXEEXT): getfsdev.o
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getfsdev.o $(LIBS)
 
 TRIMSLASH_OBJ = trimslash.o syscall.o lib/compat.o lib/snprintf.o
 trimslash$(EXEEXT): $(TRIMSLASH_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
 
-T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o t_stub.o lib/compat.o lib/snprintf.o lib/wildmatch.o
+T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o util2.o t_stub.o lib/compat.o lib/snprintf.o lib/wildmatch.o
 t_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(T_UNSAFE_OBJ) $(LIBS)
 
 gen: conf proto.h man
 
 gensend: gen
@@ -166,23 +186,36 @@
 	    else \
 		echo "Makefile updated -- rerun your make command."; \
 		exit 1; \
 	    fi \
 	fi
 
+rsync-ssl: $(srcdir)/rsync-ssl.in Makefile
+	sed 's;\@bindir\@;$(bindir);g' <$(srcdir)/rsync-ssl.in >rsync-ssl
+	@chmod +x rsync-ssl
+
+stunnel-rsync: $(srcdir)/stunnel-rsync.in Makefile
+	sed 's;\@stunnel4\@;$(stunnel4);g' <$(srcdir)/stunnel-rsync.in >stunnel-rsync
+	@chmod +x stunnel-rsync
+
+stunnel-rsyncd.conf: $(srcdir)/stunnel-rsyncd.conf.in Makefile
+	sed 's;\@bindir\@;$(bindir);g' <$(srcdir)/stunnel-rsyncd.conf.in >stunnel-rsyncd.conf
+
 proto: proto.h-tstamp
 
 proto.h: proto.h-tstamp
 	@if test -f proto.h; then :; else cp -p $(srcdir)/proto.h .; fi
 
 proto.h-tstamp: $(srcdir)/*.c $(srcdir)/lib/compat.c config.h
 	perl $(srcdir)/mkproto.pl $(srcdir)/*.c $(srcdir)/lib/compat.c
 
-man: rsync.1 rsyncd.conf.5
-	@if test -f rsync.1; then :; else cp -p $(srcdir)/rsync.1 .; fi
-	@if test -f rsyncd.conf.5; then :; else cp -p $(srcdir)/rsyncd.conf.5 .; fi
+man: rsync.1 rsyncd.conf.5 man-copy
+
+man-copy:
+	@-if test -f rsync.1; then :; else echo 'Copying srcdir rsync.1'; cp -p $(srcdir)/rsync.1 .; fi
+	@-if test -f rsyncd.conf.5; then :; else echo 'Copying srcdir rsyncd.conf.5'; cp -p $(srcdir)/rsyncd.conf.5 .; fi
 
 rsync.1: rsync.yo
 	yodl2man -o rsync.1 $(srcdir)/rsync.yo
 	-$(srcdir)/tweak_manpage rsync.1
 
 rsyncd.conf.5: rsyncd.conf.yo
@@ -198,12 +231,13 @@
 
 # We try to delete built files from both the source and build
 # directories, just in case somebody previously configured things in
 # the source directory.
 distclean: clean
 	rm -f Makefile config.h config.status
+	rm -f rsync-ssl stunnel-rsync stunnel-rsyncd.conf
 	rm -f lib/dummy popt/dummy zlib/dummy
 	rm -f $(srcdir)/Makefile $(srcdir)/config.h $(srcdir)/config.status
 	rm -f $(srcdir)/lib/dummy $(srcdir)/popt/dummy $(srcdir)/zlib/dummy
 	rm -f config.cache config.log
 	rm -f $(srcdir)/config.cache $(srcdir)/config.log
 	rm -f shconfig $(srcdir)/shconfig
@@ -236,12 +270,15 @@
 check: all $(CHECK_PROGS) $(CHECK_SYMLINKS)
 	rsync_bin=`pwd`/rsync$(EXEEXT) $(srcdir)/runtests.sh
 
 check29: all $(CHECK_PROGS) $(CHECK_SYMLINKS)
 	rsync_bin=`pwd`/rsync$(EXEEXT) $(srcdir)/runtests.sh --protocol=29
 
+check30: all $(CHECK_PROGS) $(CHECK_SYMLINKS)
+	rsync_bin=`pwd`/rsync$(EXEEXT) $(srcdir)/runtests.sh --protocol=30
+
 wildtest.o: wildtest.c lib/wildmatch.c rsync.h config.h
 wildtest$(EXEEXT): wildtest.o lib/compat.o lib/snprintf.o @BUILD_POPT@
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ wildtest.o lib/compat.o lib/snprintf.o @BUILD_POPT@ $(LIBS)
 
 testsuite/chown-fake.test:
 	ln -s chown.test $(srcdir)/testsuite/chown-fake.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/match.c	2011-04-23 02:27:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/match.c	2013-08-04 00:59:38.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Block matching used by the file-transfer code.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,19 +17,20 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "inums.h"
 
-extern int verbose;
-extern int do_progress;
 extern int checksum_seed;
 extern int append_mode;
+extern int checksum_len;
 
 int updating_basis_file;
+char sender_file_sum[MAX_DIGEST_LEN];
 
 static int false_alarms;
 static int hash_hits;
 static int matches;
 static int64 data_transfer;
 
@@ -104,16 +105,16 @@
 static void matched(int f, struct sum_struct *s, struct map_struct *buf,
 		    OFF_T offset, int32 i)
 {
 	int32 n = (int32)(offset - last_match); /* max value: block_size (int32) */
 	int32 j;
 
-	if (verbose > 2 && i >= 0) {
+	if (DEBUG_GTE(DELTASUM, 2) && i >= 0) {
 		rprintf(FINFO,
-			"match at %.0f last_match=%.0f j=%d len=%ld n=%ld\n",
-			(double)offset, (double)last_match, i,
+			"match at %s last_match=%s j=%d len=%ld n=%ld\n",
+			big_num(offset), big_num(last_match), i,
 			(long)s->sums[i].len, (long)n);
 	}
 
 	send_token(f, i, buf, last_match, n, i < 0 ? 0 : s->sums[i].len);
 	data_transfer += n;
 
@@ -129,13 +130,13 @@
 
 	if (i >= 0)
 		last_match = offset + s->sums[i].len;
 	else
 		last_match = offset;
 
-	if (buf && do_progress)
+	if (buf && INFO_GTE(PROGRESS, 1))
 		show_progress(last_match, buf->file_size);
 }
 
 
 static void hash_search(int f,struct sum_struct *s,
 			struct map_struct *buf, OFF_T len)
@@ -148,77 +149,85 @@
 	schar *map;
 
 	/* want_i is used to encourage adjacent matches, allowing the RLL
 	 * coding of the output to work more efficiently. */
 	want_i = 0;
 
-	if (verbose > 2) {
-		rprintf(FINFO, "hash search b=%ld len=%.0f\n",
-			(long)s->blength, (double)len);
+	if (DEBUG_GTE(DELTASUM, 2)) {
+		rprintf(FINFO, "hash search b=%ld len=%s\n",
+			(long)s->blength, big_num(len));
 	}
 
 	k = (int32)MIN(len, (OFF_T)s->blength);
 
 	map = (schar *)map_ptr(buf, 0, k);
 
 	sum = get_checksum1((char *)map, k);
 	s1 = sum & 0xFFFF;
 	s2 = sum >> 16;
-	if (verbose > 3)
+	if (DEBUG_GTE(DELTASUM, 3))
 		rprintf(FINFO, "sum=%.8x k=%ld\n", sum, (long)k);
 
 	offset = aligned_offset = aligned_i = 0;
 
 	end = len + 1 - s->sums[s->count-1].len;
 
-	if (verbose > 3) {
-		rprintf(FINFO, "hash search s->blength=%ld len=%.0f count=%.0f\n",
-			(long)s->blength, (double)len, (double)s->count);
+	if (DEBUG_GTE(DELTASUM, 3)) {
+		rprintf(FINFO, "hash search s->blength=%ld len=%s count=%s\n",
+			(long)s->blength, big_num(len), big_num(s->count));
 	}
 
 	do {
 		int done_csum2 = 0;
-		int32 i;
+		uint32 hash_entry;
+		int32 i, *prev;
 
-		if (verbose > 4) {
-			rprintf(FINFO, "offset=%.0f sum=%04x%04x\n",
-				(double)offset, s2 & 0xFFFF, s1 & 0xFFFF);
+		if (DEBUG_GTE(DELTASUM, 4)) {
+			rprintf(FINFO, "offset=%s sum=%04x%04x\n",
+				big_num(offset), s2 & 0xFFFF, s1 & 0xFFFF);
 		}
 
 		if (tablesize == TRADITIONAL_TABLESIZE) {
-			if ((i = hash_table[SUM2HASH2(s1,s2)]) < 0)
+			hash_entry = SUM2HASH2(s1,s2);
+			if ((i = hash_table[hash_entry]) < 0)
 				goto null_hash;
 			sum = (s1 & 0xffff) | (s2 << 16);
 		} else {
 			sum = (s1 & 0xffff) | (s2 << 16);
-			if ((i = hash_table[BIG_SUM2HASH(sum)]) < 0)
+			hash_entry = BIG_SUM2HASH(sum);
+			if ((i = hash_table[hash_entry]) < 0)
 				goto null_hash;
 		}
+		prev = &hash_table[hash_entry];
 
 		hash_hits++;
 		do {
 			int32 l;
 
+			/* When updating in-place, the chunk's offset must be
+			 * either >= our offset or identical data at that offset.
+			 * Remove any bypassed entries that we can never use. */
+			if (updating_basis_file && s->sums[i].offset < offset
+			    && !(s->sums[i].flags & SUMFLG_SAME_OFFSET)) {
+				*prev = s->sums[i].chain;
+				continue;
+			}
+			prev = &s->sums[i].chain;
+
 			if (sum != s->sums[i].sum1)
 				continue;
 
 			/* also make sure the two blocks are the same length */
 			l = (int32)MIN((OFF_T)s->blength, len-offset);
 			if (l != s->sums[i].len)
 				continue;
 
-			/* in-place: ensure chunk's offset is either >= our
-			 * offset or that the data didn't move. */
-			if (updating_basis_file && s->sums[i].offset < offset
-			    && !(s->sums[i].flags & SUMFLG_SAME_OFFSET))
-				continue;
-
-			if (verbose > 3) {
+			if (DEBUG_GTE(DELTASUM, 3)) {
 				rprintf(FINFO,
-					"potential match at %.0f i=%ld sum=%08x\n",
-					(double)offset, (long)i, sum);
+					"potential match at %s i=%ld sum=%08x\n",
+					big_num(offset), (long)i, sum);
 			}
 
 			if (!done_csum2) {
 				map = (schar *)map_ptr(buf,offset,l);
 				get_checksum2((char *)map,l,sum2);
 				done_csum2 = 1;
@@ -235,20 +244,43 @@
 			if (updating_basis_file) {
 				/* All the generator's chunks start at blength boundaries. */
 				while (aligned_offset < offset) {
 					aligned_offset += s->blength;
 					aligned_i++;
 				}
-				if (offset == aligned_offset && aligned_i < s->count) {
+				if ((offset == aligned_offset
+				  || (sum == 0 && l == s->blength && aligned_offset + l <= len))
+				 && aligned_i < s->count) {
 					if (i != aligned_i) {
 						if (sum != s->sums[aligned_i].sum1
 						 || l != s->sums[aligned_i].len
 						 || memcmp(sum2, s->sums[aligned_i].sum2, s->s2length) != 0)
 							goto check_want_i;
 						i = aligned_i;
 					}
+					if (offset != aligned_offset) {
+						/* We've matched some zeros in a spot that is also zeros
+						 * further along in the basis file, if we find zeros ahead
+						 * in the sender's file, we'll output enough literal data
+						 * to re-align with the basis file, and get back to seeking
+						 * instead of writing. */
+						backup = (int32)(aligned_offset - last_match);
+						if (backup < 0)
+							backup = 0;
+						map = (schar *)map_ptr(buf, aligned_offset - backup, l + backup)
+						    + backup;
+						sum = get_checksum1((char *)map, l);
+						if (sum != s->sums[i].sum1)
+							goto check_want_i;
+						get_checksum2((char *)map, l, sum2);
+						if (memcmp(sum2, s->sums[i].sum2, s->s2length) != 0)
+							goto check_want_i;
+						/* OK, we have a re-alignment match.  Bump the offset
+						 * forward to the new match point. */
+						offset = aligned_offset;
+					}
 					/* This identical chunk is in the same spot in the old and new file. */
 					s->sums[i].flags |= SUMFLG_SAME_OFFSET;
 					want_i = i;
 				}
 			}
 
@@ -325,85 +357,92 @@
  * 0</tt>, then there are actually no checksums for this file.
  *
  * @param len Length of the file to send.
  **/
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len)
 {
-	char file_sum[MAX_DIGEST_LEN];
-	int sum_len;
-
 	last_match = 0;
 	false_alarms = 0;
 	hash_hits = 0;
 	matches = 0;
 	data_transfer = 0;
 
 	sum_init(checksum_seed);
 
 	if (append_mode > 0) {
 		if (append_mode == 2) {
 			OFF_T j = 0;
 			for (j = CHUNK_SIZE; j < s->flength; j += CHUNK_SIZE) {
-				if (buf && do_progress)
+				if (buf && INFO_GTE(PROGRESS, 1))
 					show_progress(last_match, buf->file_size);
 				sum_update(map_ptr(buf, last_match, CHUNK_SIZE),
 					   CHUNK_SIZE);
 				last_match = j;
 			}
 			if (last_match < s->flength) {
 				int32 n = (int32)(s->flength - last_match);
-				if (buf && do_progress)
+				if (buf && INFO_GTE(PROGRESS, 1))
 					show_progress(last_match, buf->file_size);
 				sum_update(map_ptr(buf, last_match, n), n);
 			}
 		}
 		last_match = s->flength;
 		s->count = 0;
 	}
 
 	if (len > 0 && s->count > 0) {
 		build_hash_table(s);
 
-		if (verbose > 2)
+		if (DEBUG_GTE(DELTASUM, 2))
 			rprintf(FINFO,"built hash table\n");
 
 		hash_search(f, s, buf, len);
 
-		if (verbose > 2)
+		if (DEBUG_GTE(DELTASUM, 2))
 			rprintf(FINFO,"done hash search\n");
 	} else {
 		OFF_T j;
 		/* by doing this in pieces we avoid too many seeks */
 		for (j = last_match + CHUNK_SIZE; j < len; j += CHUNK_SIZE)
 			matched(f, s, buf, j, -2);
 		matched(f, s, buf, len, -1);
 	}
 
-	sum_len = sum_end(file_sum);
-	/* If we had a read error, send a bad checksum. */
-	if (buf && buf->status != 0)
-		file_sum[0]++;
+	if (sum_end(sender_file_sum) != checksum_len)
+		overflow_exit("checksum_len"); /* Impossible... */
 
-	if (verbose > 2)
+	/* If we had a read error, send a bad checksum.  We use all bits
+	 * off as long as the checksum doesn't happen to be that, in
+	 * which case we turn the last 0 bit into a 1. */
+	if (buf && buf->status != 0) {
+		int i;
+		for (i = 0; i < checksum_len && sender_file_sum[i] == 0; i++) {}
+		memset(sender_file_sum, 0, checksum_len);
+		if (i == checksum_len)
+			sender_file_sum[i-1]++;
+	}
+
+	if (DEBUG_GTE(DELTASUM, 2))
 		rprintf(FINFO,"sending file_sum\n");
-	write_buf(f, file_sum, sum_len);
+	write_buf(f, sender_file_sum, checksum_len);
 
-	if (verbose > 2)
+	if (DEBUG_GTE(DELTASUM, 2)) {
 		rprintf(FINFO, "false_alarms=%d hash_hits=%d matches=%d\n",
 			false_alarms, hash_hits, matches);
+	}
 
 	total_hash_hits += hash_hits;
 	total_false_alarms += false_alarms;
 	total_matches += matches;
 	stats.literal_data += data_transfer;
 }
 
 void match_report(void)
 {
-	if (verbose <= 1)
+	if (!DEBUG_GTE(DELTASUM, 1))
 		return;
 
 	rprintf(FINFO,
-		"total: matches=%d  hash_hits=%d  false_alarms=%d data=%.0f\n",
+		"total: matches=%d  hash_hits=%d  false_alarms=%d data=%s\n",
 		total_matches, total_hash_hits, total_false_alarms,
-		(double)stats.literal_data);
+		big_num(stats.literal_data));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/NEWS	2011-09-24 00:13:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/NEWS	2013-09-29 04:55:54.000000000 +0800
@@ -1,56 +1,243 @@
-NEWS for rsync 3.0.9 (23 Sep 2011)
-Protocol: 30 (unchanged)
-Changes since 3.0.8:
+NEWS for rsync 3.1.0 (28 Sep 2013)
+Protocol: 31 (changed)
+Changes since 3.0.9:
+
+  OUTPUT CHANGES:
+
+    - Output numbers in 3-digit groups by default (e.g. 1,234,567).  See the
+      --human-readable option for a way to turn it off.  See also the daemon's
+      "log format" parameter and related command-line options (including
+      --out-format) for a modifier that can be used to request digit-grouping
+      or human-readable output in log escapes. (Note that log output is
+      unchanged by default.)
+
+    - The --list-only option is now affected by the --human-readable setting.
+      It will display digit groupings by default, and unit suffixes if higher
+      levels of readability are requested.  Also, the column width for the size
+      output has increased from 11 to 14 characters when human readability is
+      enabled.  Use --no-h to get the old-style output and column size.
+
+    - The output of the --progress option has changed:  the string "xfer" was
+      shortened to "xfr", and the string "to-check" was shortened to "to-chk",
+      both designed to make room for the (by default) wider display of file
+      size numbers without making the total line-length longer.  Also, when
+      incremental recursion is enabled, the string "ir-chk" will be used
+      instead of "to-chk" up until the incremental-recursion scan is done,
+      letting you know that the value to check and the total value will still
+      be increasing as new files are found.
+
+    - Enhanced the --stats output: 1) to mention how many files were created
+      (protocol >= 28), 2) to mention how many files were deleted (a new line
+      for protocol 31, but only output when --delete is in effect), and 3) to
+      follow the file-count, created-count, and deleted-count with a subcount
+      list that shows the counts by type.  The wording of the transferred count
+      has also changed so that it is clearer that it is only a count of regular
+      files.
 
   BUG FIXES:
 
-    - Fix a crash bug in checksum scanning when --inplace is used.
+    - Fixed a bug in the iconv code when EINVAL or EILSEQ is returned with a
+      full output buffer.
 
-    - Fix a hang if a hard-linked file cannot be opened by the sender (e.g.
-      if it has no read permission).
+    - Fixed some rare bugs in --iconv processing that might cause a multibyte
+      character to get translated incorrectly.
 
-    - Fix preservation of a symlink's system xattrs (e.g. selinux) on Linux.
+    - Fixed a bogus "vanished file" error if some files were specified with
+      "./" prefixes and others were not.
 
-    - Fix a memory leak in the xattr code.
+    - Fixed a bug in --sparse where an extra gap could get inserted after a
+      partial write.
 
-    - Fixed a bug with --delete-excluded when a filter merge file has a rule
-      that specifies a receiver-only side restriction.
+    - Changed the way --progress overwrites its prior output in order to make
+      it nearly impossible for the progress to get overwritten by an error.
 
-    - Fix a bug with the modifying of unwritable directories.
+    - Improved the propagation of abnormal-exit error messages.  This should
+      help the client side to receive errors from the server when it is exiting
+      abnormally, and should also avoid dying with an "connection unexpectedly
+      closed" exit when the closed connection is really expected.
 
-    - Fix --fake-super's interaction with --link-dest same-file comparisons.
+    - The sender now checks each file it plans to remove to ensure that it
+      hasn't changed from the first stat's info.  This helps to avoid losing
+      file data when the user is not using the option in a safe manner.
 
-    - Fix the updating of the curr_dir buffer to avoid a duplicate slash.
+    - Fixed a data-duplication bug in the compress option that made compression
+      less efficient.  This improves protocol 31 onward, while behaving in a
+      compatible (buggy) manner with older rsync protocols.
 
-    - Fix the directory permissions on an implied dot-dir when using --relative
-      (e.g. /outside/path/././send/path).
+    - When creating a temp-file, rsync is now a bit smarter about it dot-char
+      choices, which can fix a problem on OS X with names that start with "..".
 
-    - Fixed some too-long sleeping instances when using --bwlimit.
+    - Rsync now sets a cleanup flag for --inplace and --append transfers that
+      will flush the write buffer if the transfer aborts.  This ensures that
+      more received data gets written out to the disk on an aborted transfer
+      (which is quite helpful on a slow, flaky connection).
 
-    - Fixed when symlink ownership difference-checking gets compiled into
-      unchanged_attrs().
+    - The reads that map_ptr() now does are aligned on 1K boundaries.  This
+      helps some filesystems and/or files that don't like unaligned reads.
 
-    - Improved the socket-error reporting when multiple protocols fail.
+    - Fix an issue in the msleep() function if time jumps backwards.
 
-    - Fixed a case where a socket error could reference just-freed memory.
+    - Fix daemon-server module-name splitting bug where an arg would get split
+      even if --protect-args was used.
 
-    - Failing to use a password file that was specified on the command-line is
-      now a fatal error.
+  ENHANCEMENTS:
 
-    - Fix the non-root updating of directories that don't have the read and/or
-      execute permission.
+    - Added the --remote-option=OPT (-M OPT) command-line option that is useful
+      for things like sending a remote --log-file=FILE or --fake-super option.
 
-    - Make daemon-excluded file errors more error-like.
+    - Added the --info=FLAGS and --debug=FLAGS options to allow finer-grained
+      control over what is output.  Added an extra type of --progress output
+      using --info=progress2.
 
-    - Fix a compilation issue on older C compilers (due to a misplaced var
-      declaration).
+    - The --msgs2stderr option can help with debugging rsync by allowing the
+      debug messages to get output to stderr rather than travel via the socket
+      protocol.
 
-    - Make configure avoid finding socketpair on cygwin.
+    - Added the --delete-missing-args and --ignore-missing-args options to
+      either delete or ignore user-specified files on the receiver that are
+      missing on the sender (normally the absence of user-specified files
+      generates an error).
 
-    - Avoid trying to reference SO_BROADCAST if the OS doesn't support it.
+    - Added a "T" (terabyte) category to the --human-readable size suffixes.
 
-    - Fix some issues with the post-processing of the man pages.
+    - Added the --usermap/--groupmap/--chown options for manipulating file
+      ownership during the copy.
 
-    - Fixed the user home-dir handling in the support/lsh script.
+    - Added the "%C" escape to the log-output handling, which will output the
+      MD5 checksum of any transferred file, or all files if --checksum was
+      specified (when protocol 30 or above is in effect).
 
-    - Some minor manpage improvements.
+    - Added the "reverse lookup" parameter to the rsync daemon config file to
+      allow reverse-DNS lookups to be disabled.
+
+    - Added a forward-DNS lookup for the daemon's hosts allow/deny config.  Can
+      be disabled via "forward lookup" parameter (defaults to enabled).
+
+    - Added a way for more than one group to be specified in the daemon's
+      config file, including a way to specify that you want all of the
+      specified user's groups without having to name them.  Also changed the
+      daemon to complain about an inability to set explicitly-specified uid/gid
+      values, even when not run by a super-user.
+
+    - The daemon now tries to send the user the error messages from the
+      pre-xfer exec script when it fails.
+
+    - Improved the use of alt-dest options into an existing hierarchy of files:
+      If a match is found in an alt-dir, it takes precedence over an existing
+      file.  (We'll need to wait for a future version before attribute-changes
+      on otherwise unchanged files are safe when using an existing hierarchy.)
+
+    - Added per-user authorization options and group-authorization support to
+      the daemon's "auth users" parameter.
+
+    - Added a way to reference environment variables in a daemon's config file
+      (using %VAR% references).
+
+    - When replacing a non-dir with a symlink/hard-link/device/special-file,
+      the update should now be done in an atomic manner.
+
+    - Avoid re-sending xattr info for hard-linked files w/the same xattrs
+      (protocol 31).
+
+    - The backup code was improved to use better logic maintaining the backup
+      directory hierarchy.  Also, when a file is being backed up, rsync tries
+      to hard-link it into place so that the upcoming replacement of the
+      destination file will be atomic (for the normal, non-inplace logic).
+
+    - Added the ability to synchronize nano-second modified times.
+
+    - Added a few more default suffixes for the "dont compress" settings.
+
+    - Added the checking of the RSYNC_PROTECT_ARGS environment variable to allow
+      the default for the --protect-args command-line option to be overridden.
+
+    - Added the --preallocate command-line option.
+
+    - Allow --password-file=- to read the password from stdin (filename "-").
+
+    - Rsync now comes packaged with an rsync-ssl helper script that can be
+      used to contact a remote rsync daemon using a piped-stunnel command.
+      It also includes an stunnel config file to run the server side to
+      support ssl daemon connections.  See the packaging/lsb/rsync.spec
+      file for one way to package the resulting files.  (Suggestions for
+      how to make this even easier to install & use are welcomed.)
+
+    - Improved the speed of some --inplace updates when there are lots of
+      identical checksum blocks that end up being unusable.
+
+    - Added the --outbuf=N|L|B option for choosing the output buffering.
+
+    - Repeating the --fuzzy option now causes the code to look for fuzzy
+      matches inside alt-dest directories too.
+
+    - The --chmod option now supports numeric modes, e.g. --chmod=644,D755
+
+    - Added some Solaris xattr code.
+
+    - Made an rsync daemon (the listening process) exit with a 0 status when
+      it was signaled to die.  This helps launchd.
+
+    - Improved the RSYNC_* environment variables for the pre-xfer exec script:
+      when a daemon is sent multiple request args, they are now joined into a
+      single return value (separated by spaces) so that the RSYNC_REQUEST
+      environment variable is accurate for any "pre-xfer exec".  The values in
+      RSYNC_ARG# vars are no longer truncated at the "." arg (prior to the
+      request dirs/files), so that all the requested values are also listed
+      (separately) in RSYNC_ARG# variables.
+
+  EXTRAS:
+
+    - Added an "instant-rsyncd" script to the support directory, which makes
+      it easy to configure a simple rsync daemon in the current directory.
+
+    - Added the "mapfrom" and "mapto" scripts to the support directory, which
+      makes it easier to do user/group mapping in a local transfer based on
+      passwd/group files from another machine.
+
+    - There's a new, improved version of the lsh script in the support dir:
+      it's written in perl and supports -u without resorting to using sudo
+      (when run as root).  The old shell version is now named lsh.sh.
+
+    - There is a helper script named rsync-slash-strip in the support directory
+      for anyone that wants to change the way rsync handles args with trailing
+      slashes.  (e.g. arg/ would get stripped to arg while arg/. would turn into
+      arg/).
+
+  INTERNAL:
+
+    - The I/O code was rewritten to be simpler and do bigger buffered reads
+      over the socket.  The I/O between the receiver and the generator was
+      changed to be standard multiplexed-I/O (like that over the socket).
+
+    - The sender tries to use any dead time while the generator is looking for
+      files to transfer in order to do sender-side directory scanning in a more
+      parallel manner.
+
+    - A daemon can now inform a client about a daemon-configured timeout value
+      so that the client can assist in the keep-alive activity (protocol 31).
+
+    - The filter code received some refactoring to make it more extendible, to
+      read better, and do better sanity checking.
+
+    - Really big numbers are now output using our own big-num routine rather
+      than casting them to a double and using a %.0f conversion.
+
+    - The pool_alloc library has received some minor improvements in alignment
+      handling.
+
+    - Added init_stat_x() function to avoid duplication of acl/xattr init code.
+
+    - The included zlib was upgraded from 1.2.3 to 1.2.8.
+
+    - Rsync can now be compiled to use an unmodified zlib library instead of
+      the tweaked one that is included with rsync.  This will eventually
+      become the default, at which point we'll start the countdown to removing
+      the included zlib.  Until then, feel free to configure using:
+
+	./configure --with-included-zlib=no
+
+  DEVELOPER RELATED:
+
+    - Added more conditional debug output.
+
+    - Fixed some build issues for android and minix.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/OLDNEWS	2011-09-24 00:13:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/OLDNEWS	2013-09-29 04:55:54.000000000 +0800
@@ -1,6 +1,63 @@
+NEWS for rsync 3.0.9 (23 Sep 2011)
+Protocol: 30 (unchanged)
+Changes since 3.0.8:
+
+  BUG FIXES:
+
+    - Fix a crash bug in checksum scanning when --inplace is used.
+
+    - Fix a hang if a hard-linked file cannot be opened by the sender (e.g.
+      if it has no read permission).
+
+    - Fix preservation of a symlink's system xattrs (e.g. selinux) on Linux.
+
+    - Fix a memory leak in the xattr code.
+
+    - Fixed a bug with --delete-excluded when a filter merge file has a rule
+      that specifies a receiver-only side restriction.
+
+    - Fix a bug with the modifying of unwritable directories.
+
+    - Fix --fake-super's interaction with --link-dest same-file comparisons.
+
+    - Fix the updating of the curr_dir buffer to avoid a duplicate slash.
+
+    - Fix the directory permissions on an implied dot-dir when using --relative
+      (e.g. /outside/path/././send/path).
+
+    - Fixed some too-long sleeping instances when using --bwlimit.
+
+    - Fixed when symlink ownership difference-checking gets compiled into
+      unchanged_attrs().
+
+    - Improved the socket-error reporting when multiple protocols fail.
+
+    - Fixed a case where a socket error could reference just-freed memory.
+
+    - Failing to use a password file that was specified on the command-line is
+      now a fatal error.
+
+    - Fix the non-root updating of directories that don't have the read and/or
+      execute permission.
+
+    - Make daemon-excluded file errors more error-like.
+
+    - Fix a compilation issue on older C compilers (due to a misplaced var
+      declaration).
+
+    - Make configure avoid finding socketpair on cygwin.
+
+    - Avoid trying to reference SO_BROADCAST if the OS doesn't support it.
+
+    - Fix some issues with the post-processing of the man pages.
+
+    - Fixed the user home-dir handling in the support/lsh script.
+
+    - Some minor manpage improvements.
+
 NEWS for rsync 3.0.8 (26 Mar 2011)
 Protocol: 30 (unchanged)
 Changes since 3.0.7:
 
   BUG FIXES:
 
@@ -3228,16 +3284,16 @@
 
   TESTING:
 
     * The existing test.sh script by Phil Hands has been merged into a
       test framework that works from both "make check" and the Samba
       build farm.
-
 
 Partial Protocol History
 	RELEASE DATE	VER.	DATE OF COMMIT*	PROTOCOL
+	28 Sep 2013	3.1.0	31 Aug 2008	31
 	23 Sep 2011	3.0.9			30
 	26 Mar 2011	3.0.8			30
 	31 Dec 2009	3.0.7			30
 	08 May 2009	3.0.6			30
 	28 Dec 2008	3.0.5			30
 	06 Sep 2008	3.0.4			30
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/options.c	2011-09-14 06:41:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/options.c	2013-06-12 04:28:45.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Command-line (and received via daemon-socket) option parsing.
  *
  * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2000, 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2002-2011 Wayne Davison
+ * Copyright (C) 2002-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,23 +17,23 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
-#include "ifuncs.h"
+#include "itypes.h"
 #include <popt.h>
-#include "zlib/zlib.h"
+#include <zlib.h>
 
 extern int module_id;
 extern int local_server;
 extern int sanitize_paths;
 extern int daemon_over_rsh;
 extern unsigned int module_dirlen;
-extern struct filter_list_struct filter_list;
-extern struct filter_list_struct daemon_filter_list;
+extern filter_rule_list filter_list;
+extern filter_rule_list daemon_filter_list;
 
 int make_backups = 0;
 
 /**
  * If 1, send the whole file as literal data rather than trying to
  * create an incremental diff.
@@ -70,61 +70,64 @@
 int delete_after = 0;
 int delete_excluded = 0;
 int remove_source_files = 0;
 int one_file_system = 0;
 int protocol_version = PROTOCOL_VERSION;
 int sparse_files = 0;
+int preallocate_files = 0;
 int do_compression = 0;
 int def_compress_level = Z_DEFAULT_COMPRESSION;
 int am_root = 0; /* 0 = normal, 1 = root, 2 = --super, -1 = --fake-super */
 int am_server = 0;
 int am_sender = 0;
 int am_starting_up = 1;
 int relative_paths = -1;
 int implied_dirs = 1;
+int missing_args = 0; /* 0 = FERROR_XFER, 1 = ignore, 2 = delete */
 int numeric_ids = 0;
+int msgs2stderr = 0;
 int allow_8bit_chars = 0;
 int force_delete = 0;
 int io_timeout = 0;
 int prune_empty_dirs = 0;
 int use_qsort = 0;
 char *files_from = NULL;
 int filesfrom_fd = -1;
 char *filesfrom_host = NULL;
 int eol_nulls = 0;
-int protect_args = 0;
-int human_readable = 0;
+int protect_args = -1;
+int human_readable = 1;
 int recurse = 0;
 int allow_inc_recurse = 1;
 int xfer_dirs = -1;
 int am_daemon = 0;
-int do_stats = 0;
-int do_progress = 0;
 int connect_timeout = 0;
 int keep_partial = 0;
 int safe_symlinks = 0;
 int copy_unsafe_links = 0;
+int munge_symlinks = 0;
 int size_only = 0;
 int daemon_bwlimit = 0;
 int bwlimit = 0;
 int fuzzy_basis = 0;
 size_t bwlimit_writemax = 0;
 int ignore_existing = 0;
 int ignore_non_existing = 0;
 int need_messages_from_generator = 0;
 int max_delete = INT_MIN;
-OFF_T max_size = 0;
-OFF_T min_size = 0;
+OFF_T max_size = -1;
+OFF_T min_size = -1;
 int ignore_errors = 0;
 int modify_window = 0;
 int blocking_io = -1;
 int checksum_seed = 0;
 int inplace = 0;
 int delay_updates = 0;
 long block_size = 0; /* "long" because popt can't set an int32. */
 char *skip_compress = NULL;
+item_list dparam_list = EMPTY_ITEM_LIST;
 
 /** Network address family. **/
 int default_af_hint
 #ifdef INET6
 	= 0;		/* Any protocol */
 #else
@@ -162,20 +165,25 @@
 char *stdout_format = NULL;
 char *password_file = NULL;
 char *rsync_path = RSYNC_PATH;
 char *backup_dir = NULL;
 char backup_dir_buf[MAXPATHLEN];
 char *sockopts = NULL;
+char *usermap = NULL;
+char *groupmap = NULL;
 int rsync_port = 0;
 int compare_dest = 0;
 int copy_dest = 0;
 int link_dest = 0;
 int basis_dir_cnt = 0;
 char *dest_option = NULL;
 
-int verbose = 0;
+static int remote_option_alloc = 0;
+int remote_option_cnt = 0;
+const char **remote_options = NULL;
+
 int quiet = 0;
 int output_motd = 1;
 int log_before_transfer = 0;
 int stdout_format_has_i = 0;
 int stdout_format_has_o_or_i = 0;
 int logfile_format_has_i = 0;
@@ -190,36 +198,377 @@
 #ifdef ICONV_OPTION
 char *iconv_opt = ICONV_OPTION;
 #endif
 
 struct chmod_mode_struct *chmod_modes = NULL;
 
+static const char *debug_verbosity[] = {
+	/*0*/ NULL,
+	/*1*/ NULL,
+	/*2*/ "BIND,CMD,CONNECT,DEL,DELTASUM,DUP,FILTER,FLIST,ICONV",
+	/*3*/ "ACL,BACKUP,CONNECT2,DELTASUM2,DEL2,EXIT,FILTER2,FLIST2,FUZZY,GENR,OWN,RECV,SEND,TIME",
+	/*4*/ "CMD2,DELTASUM3,DEL3,EXIT2,FLIST3,ICONV2,OWN2,PROTO,TIME2",
+	/*5*/ "CHDIR,DELTASUM4,FLIST4,FUZZY2,HASH,HLINK",
+};
+
+#define MAX_VERBOSITY ((int)(sizeof debug_verbosity / sizeof debug_verbosity[0]) - 1)
+
+static const char *info_verbosity[1+MAX_VERBOSITY] = {
+	/*0*/ NULL,
+	/*1*/ "COPY,DEL,FLIST,MISC,NAME,STATS,SYMSAFE",
+	/*2*/ "BACKUP,MISC2,MOUNT,NAME2,REMOVE,SKIP",
+};
+
+#define MAX_OUT_LEVEL 4 /* The largest N allowed for any flagN word. */
+
+short info_levels[COUNT_INFO], debug_levels[COUNT_DEBUG];
+
+#define DEFAULT_PRIORITY 0 	/* Default/implied/--verbose set values. */
+#define HELP_PRIORITY 1		/* The help output uses this level. */
+#define USER_PRIORITY 2		/* User-specified via --info or --debug */
+#define LIMIT_PRIORITY 3	/* Overriding priority when limiting values. */
+
+#define W_CLI (1<<0)	/* client side */
+#define W_SRV (1<<1)	/* server side */
+#define W_SND (1<<2)	/* sending side */
+#define W_REC (1<<3)	/* receiving side */
+
+struct output_struct {
+	char *name;	/* The name of the info/debug flag. */
+	char *help;	/* The description of the info/debug flag. */
+	uchar namelen;  /* The length of the name string. */
+	uchar flag;	/* The flag's value, for consistency check. */
+	uchar where;	/* Bits indicating where the flag is used. */
+	uchar priority; /* See *_PRIORITY defines. */
+};
+
+#define INFO_WORD(flag, where, help) { #flag, help, sizeof #flag - 1, INFO_##flag, where, 0 }
+
+static struct output_struct info_words[COUNT_INFO+1] = {
+	INFO_WORD(BACKUP, W_REC, "Mention files backed up"),
+	INFO_WORD(COPY, W_REC, "Mention files copied locally on the receiving side"),
+	INFO_WORD(DEL, W_REC, "Mention deletions on the receiving side"),
+	INFO_WORD(FLIST, W_CLI, "Mention file-list receiving/sending (levels 1-2)"),
+	INFO_WORD(MISC, W_SND|W_REC, "Mention miscellaneous information (levels 1-2)"),
+	INFO_WORD(MOUNT, W_SND|W_REC, "Mention mounts that were found or skipped"),
+	INFO_WORD(NAME, W_SND|W_REC, "Mention 1) updated file/dir names, 2) unchanged names"),
+	INFO_WORD(PROGRESS, W_CLI, "Mention 1) per-file progress or 2) total transfer progress"),
+	INFO_WORD(REMOVE, W_SND, "Mention files removed on the sending side"),
+	INFO_WORD(SKIP, W_REC, "Mention files that are skipped due to options used"),
+	INFO_WORD(STATS, W_CLI|W_SRV, "Mention statistics at end of run (levels 1-3)"),
+	INFO_WORD(SYMSAFE, W_SND|W_REC, "Mention symlinks that are unsafe"),
+	{ NULL, "--info", 0, 0, 0, 0 }
+};
+
+#define DEBUG_WORD(flag, where, help) { #flag, help, sizeof #flag - 1, DEBUG_##flag, where, 0 }
+
+static struct output_struct debug_words[COUNT_DEBUG+1] = {
+	DEBUG_WORD(ACL, W_SND|W_REC, "Debug extra ACL info"),
+	DEBUG_WORD(BACKUP, W_REC, "Debug backup actions (levels 1-2)"),
+	DEBUG_WORD(BIND, W_CLI, "Debug socket bind actions"),
+	DEBUG_WORD(CHDIR, W_CLI|W_SRV, "Debug when the current directory changes"),
+	DEBUG_WORD(CONNECT, W_CLI, "Debug connection events (levels 1-2)"),
+	DEBUG_WORD(CMD, W_CLI, "Debug commands+options that are issued (levels 1-2)"),
+	DEBUG_WORD(DEL, W_REC, "Debug delete actions (levels 1-3)"),
+	DEBUG_WORD(DELTASUM, W_SND|W_REC, "Debug delta-transfer checksumming (levels 1-4)"),
+	DEBUG_WORD(DUP, W_REC, "Debug weeding of duplicate names"),
+	DEBUG_WORD(EXIT, W_CLI|W_SRV, "Debug exit events (levels 1-3)"),
+	DEBUG_WORD(FILTER, W_SND|W_REC, "Debug filter actions (levels 1-2)"),
+	DEBUG_WORD(FLIST, W_SND|W_REC, "Debug file-list operations (levels 1-4)"),
+	DEBUG_WORD(FUZZY, W_REC, "Debug fuzzy scoring (levels 1-2)"),
+	DEBUG_WORD(GENR, W_REC, "Debug generator functions"),
+	DEBUG_WORD(HASH, W_SND|W_REC, "Debug hashtable code"),
+	DEBUG_WORD(HLINK, W_SND|W_REC, "Debug hard-link actions (levels 1-3)"),
+	DEBUG_WORD(ICONV, W_CLI|W_SRV, "Debug iconv character conversions (levels 1-2)"),
+	DEBUG_WORD(IO, W_CLI|W_SRV, "Debug I/O routines (levels 1-4)"),
+	DEBUG_WORD(OWN, W_REC, "Debug ownership changes in users & groups (levels 1-2)"),
+	DEBUG_WORD(PROTO, W_CLI|W_SRV, "Debug protocol information"),
+	DEBUG_WORD(RECV, W_REC, "Debug receiver functions"),
+	DEBUG_WORD(SEND, W_SND, "Debug sender functions"),
+	DEBUG_WORD(TIME, W_REC, "Debug setting of modified times (levels 1-2)"),
+	{ NULL, "--debug", 0, 0, 0, 0 }
+};
+
+static int verbose = 0;
+static int do_stats = 0;
+static int do_progress = 0;
 static int daemon_opt;   /* sets am_daemon after option error-reporting */
 static int omit_dir_times = 0;
+static int omit_link_times = 0;
 static int F_option_cnt = 0;
 static int modify_window_set;
 static int itemize_changes = 0;
 static int refused_delete, refused_archive_part, refused_compress;
 static int refused_partial, refused_progress, refused_delete_before;
 static int refused_delete_during;
 static int refused_inplace, refused_no_iconv;
-static char *max_size_arg, *min_size_arg;
+static BOOL usermap_via_chown, groupmap_via_chown;
+#ifdef HAVE_SETVBUF
+static char *outbuf_mode;
+#endif
+static char *bwlimit_arg, *max_size_arg, *min_size_arg;
 static char tmp_partialdir[] = ".~tmp~";
 
 /** Local address to bind.  As a character string because it's
  * interpreted by the IPv6 layer: should be a numeric IP4 or IP6
  * address, or a hostname. **/
 char *bind_address;
 
+static void output_item_help(struct output_struct *words);
+
+/* This constructs a string that represents all the options set for either
+ * the --info or --debug setting, skipping any implied options (by -v, etc.).
+ * This is used both when conveying the user's options to the server, and
+ * when the help output wants to tell the user what options are implied. */
+static char *make_output_option(struct output_struct *words, short *levels, uchar where)
+{
+	char *str = words == info_words ? "--info=" : "--debug=";
+	int j, counts[MAX_OUT_LEVEL+1], pos, skipped = 0, len = 0, max = 0, lev = 0;
+	int word_count = words == info_words ? COUNT_INFO : COUNT_DEBUG;
+	char *buf;
+
+	memset(counts, 0, sizeof counts);
+
+	for (j = 0; words[j].name; j++) {
+		if (words[j].flag != j) {
+			rprintf(FERROR, "rsync: internal error on %s%s: %d != %d\n",
+				words == info_words ? "INFO_" : "DEBUG_",
+				words[j].name, words[j].flag, j);
+			exit_cleanup(RERR_UNSUPPORTED);
+		}
+		if (!(words[j].where & where))
+			continue;
+		if (words[j].priority == DEFAULT_PRIORITY) {
+			/* Implied items don't need to be mentioned. */
+			skipped++;
+			continue;
+		}
+		len += len ? 1 : strlen(str);
+		len += strlen(words[j].name);
+		len += levels[j] == 1 ? 0 : 1;
+
+		if (words[j].priority == HELP_PRIORITY)
+			continue; /* no abbreviating for help */
+
+		assert(levels[j] <= MAX_OUT_LEVEL);
+		if (++counts[levels[j]] > max) {
+			/* Determine which level has the most items. */
+			lev = levels[j];
+			max = counts[lev];
+		}
+	}
+
+	/* Sanity check the COUNT_* define against the length of the table. */
+	if (j != word_count) {
+		rprintf(FERROR, "rsync: internal error: %s is wrong! (%d != %d)\n",
+			words == info_words ? "COUNT_INFO" : "COUNT_DEBUG",
+			j, word_count);
+		exit_cleanup(RERR_UNSUPPORTED);
+	}
+
+	if (!len)
+		return NULL;
+
+	len++;
+	if (!(buf = new_array(char, len)))
+		out_of_memory("make_output_option");
+	pos = 0;
+
+	if (skipped || max < 5)
+		lev = -1;
+	else {
+		if (lev == 0)
+			pos += snprintf(buf, len, "%sNONE", str);
+		else if (lev == 1)
+			pos += snprintf(buf, len, "%sALL", str);
+		else
+			pos += snprintf(buf, len, "%sALL%d", str, lev);
+	}
+
+	for (j = 0; words[j].name && pos < len; j++) {
+		if (words[j].priority == DEFAULT_PRIORITY || levels[j] == lev || !(words[j].where & where))
+			continue;
+		if (pos)
+			buf[pos++] = ',';
+		else
+			pos += strlcpy(buf+pos, str, len-pos);
+		if (pos < len)
+			pos += strlcpy(buf+pos, words[j].name, len-pos);
+		/* Level 1 is implied by the name alone. */
+		if (levels[j] != 1 && pos < len)
+			buf[pos++] = '0' + levels[j];
+	}
+
+	buf[pos] = '\0';
+
+	return buf;
+}
+
+static void parse_output_words(struct output_struct *words, short *levels,
+			       const char *str, uchar priority)
+{
+	const char *s;
+	int j, len, lev;
+
+	if (!str)
+		return;
+
+	while (*str) {
+		if ((s = strchr(str, ',')) != NULL)
+			len = s++ - str;
+		else
+			len = strlen(str);
+		while (len && isDigit(str+len-1))
+			len--;
+		lev = isDigit(str+len) ? atoi(str+len) : 1;
+		if (lev > MAX_OUT_LEVEL)
+			lev = MAX_OUT_LEVEL;
+		if (len == 4 && strncasecmp(str, "help", 4) == 0) {
+			output_item_help(words);
+			exit_cleanup(0);
+		}
+		if (len == 4 && strncasecmp(str, "none", 4) == 0)
+			len = lev = 0;
+		else if (len == 3 && strncasecmp(str, "all", 3) == 0)
+			len = 0;
+		for (j = 0; words[j].name; j++) {
+			if (!len
+			 || (len == words[j].namelen && strncasecmp(str, words[j].name, len) == 0)) {
+				if (priority >= words[j].priority) {
+					words[j].priority = priority;
+					levels[j] = lev;
+				}
+				if (len)
+					break;
+			}
+		}
+		if (len && !words[j].name) {
+			rprintf(FERROR, "Unknown %s item: \"%.*s\"\n",
+				words[j].help, len, str);
+			exit_cleanup(RERR_SYNTAX);
+		}
+		if (!s)
+			break;
+		str = s;
+	}
+}
+
+/* Tell the user what all the info or debug flags mean. */
+static void output_item_help(struct output_struct *words)
+{
+	short *levels = words == info_words ? info_levels : debug_levels;
+	const char **verbosity = words == info_words ? info_verbosity : debug_verbosity;
+	char buf[128], *opt, *fmt = "%-10s %s\n";
+	int j;
+
+	reset_output_levels();
+
+	rprintf(FINFO, "Use OPT or OPT1 for level 1 output, OPT2 for level 2, etc.; OPT0 silences.\n");
+	rprintf(FINFO, "\n");
+	for (j = 0; words[j].name; j++)
+		rprintf(FINFO, fmt, words[j].name, words[j].help);
+	rprintf(FINFO, "\n");
+
+	snprintf(buf, sizeof buf, "Set all %s options (e.g. all%d)",
+		 words[j].help, MAX_OUT_LEVEL);
+	rprintf(FINFO, fmt, "ALL", buf);
+
+	snprintf(buf, sizeof buf, "Silence all %s options (same as all0)",
+		 words[j].help);
+	rprintf(FINFO, fmt, "NONE", buf);
+
+	rprintf(FINFO, fmt, "HELP", "Output this help message");
+	rprintf(FINFO, "\n");
+	rprintf(FINFO, "Options added for each increase in verbose level:\n");
+
+	for (j = 1; j <= MAX_VERBOSITY; j++) {
+		parse_output_words(words, levels, verbosity[j], HELP_PRIORITY);
+		opt = make_output_option(words, levels, W_CLI|W_SRV|W_SND|W_REC);
+		if (opt) {
+			rprintf(FINFO, "%d) %s\n", j, strchr(opt, '=')+1);
+			free(opt);
+		}
+		reset_output_levels();
+	}
+}
+
+/* The --verbose option now sets info+debug flags. */
+static void set_output_verbosity(int level, uchar priority)
+{
+	int j;
+
+	if (level > MAX_VERBOSITY)
+		level = MAX_VERBOSITY;
+
+	for (j = 1; j <= level; j++) {
+		parse_output_words(info_words, info_levels, info_verbosity[j], priority);
+		parse_output_words(debug_words, debug_levels, debug_verbosity[j], priority);
+	}
+}
+
+/* Limit the info+debug flag levels given a verbose-option level limit. */
+void limit_output_verbosity(int level)
+{
+	short info_limits[COUNT_INFO], debug_limits[COUNT_DEBUG];
+	int j;
+
+	if (level > MAX_VERBOSITY)
+		return;
+
+	memset(info_limits, 0, sizeof info_limits);
+	memset(debug_limits, 0, sizeof debug_limits);
+
+	/* Compute the level limits in the above arrays. */
+	for (j = 1; j <= level; j++) {
+		parse_output_words(info_words, info_limits, info_verbosity[j], LIMIT_PRIORITY);
+		parse_output_words(debug_words, debug_limits, debug_verbosity[j], LIMIT_PRIORITY);
+	}
+
+	for (j = 0; j < COUNT_INFO; j++) {
+		if (info_levels[j] > info_limits[j])
+			info_levels[j] = info_limits[j];
+	}
+
+	for (j = 0; j < COUNT_DEBUG; j++) {
+		if (debug_levels[j] > debug_limits[j])
+			debug_levels[j] = debug_limits[j];
+	}
+}
+
+void reset_output_levels(void)
+{
+	int j;
+
+	memset(info_levels, 0, sizeof info_levels);
+	memset(debug_levels, 0, sizeof debug_levels);
+
+	for (j = 0; j < COUNT_INFO; j++)
+		info_words[j].priority = DEFAULT_PRIORITY;
+
+	for (j = 0; j < COUNT_DEBUG; j++)
+		debug_words[j].priority = DEFAULT_PRIORITY;
+}
+
+void negate_output_levels(void)
+{
+	int j;
+
+	for (j = 0; j < COUNT_INFO; j++)
+		info_levels[j] *= -1;
+
+	for (j = 0; j < COUNT_DEBUG; j++)
+		debug_levels[j] *= -1;
+}
 
 static void print_rsync_version(enum logcode f)
 {
 	char *subprotocol = "";
 	char const *got_socketpair = "no ";
 	char const *have_inplace = "no ";
 	char const *hardlinks = "no ";
+	char const *prealloc = "no ";
 	char const *symtimes = "no ";
 	char const *acls = "no ";
 	char const *xattrs = "no ";
 	char const *links = "no ";
 	char const *iconv = "no ";
 	char const *ipv6 = "no ";
@@ -235,12 +584,15 @@
 #ifdef HAVE_FTRUNCATE
 	have_inplace = "";
 #endif
 #ifdef SUPPORT_HARD_LINKS
 	hardlinks = "";
 #endif
+#ifdef SUPPORT_PREALLOCATION
+	prealloc = "";
+#endif
 #ifdef SUPPORT_ACLS
 	acls = "";
 #endif
 #ifdef SUPPORT_XATTRS
 	xattrs = "";
 #endif
@@ -256,24 +608,24 @@
 #ifdef CAN_SET_SYMLINK_TIMES
 	symtimes = "";
 #endif
 
 	rprintf(f, "%s  version %s  protocol version %d%s\n",
 		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION, subprotocol);
-	rprintf(f, "Copyright (C) 1996-2011 by Andrew Tridgell, Wayne Davison, and others.\n");
+	rprintf(f, "Copyright (C) 1996-2013 by Andrew Tridgell, Wayne Davison, and others.\n");
 	rprintf(f, "Web site: http://rsync.samba.org/\n");
 	rprintf(f, "Capabilities:\n");
 	rprintf(f, "    %d-bit files, %d-bit inums, %d-bit timestamps, %d-bit long ints,\n",
 		(int)(sizeof (OFF_T) * 8),
 		(int)(sizeof dumstat->st_ino * 8), /* Don't check ino_t! */
 		(int)(sizeof (time_t) * 8),
 		(int)(sizeof (int64) * 8));
 	rprintf(f, "    %ssocketpairs, %shardlinks, %ssymlinks, %sIPv6, batchfiles, %sinplace,\n",
 		got_socketpair, hardlinks, links, ipv6, have_inplace);
-	rprintf(f, "    %sappend, %sACLs, %sxattrs, %siconv, %ssymtimes\n",
-		have_inplace, acls, xattrs, iconv, symtimes);
+	rprintf(f, "    %sappend, %sACLs, %sxattrs, %siconv, %ssymtimes, %sprealloc\n",
+		have_inplace, acls, xattrs, iconv, symtimes, prealloc);
 
 #ifdef MAINTAINER_MODE
 	rprintf(f, "Panic Action: \"%s\"\n", get_panic_action());
 #endif
 
 #if SIZEOF_INT64 < 8
@@ -310,12 +662,15 @@
   rprintf(F,"  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n");
   rprintf(F,"The ':' usages connect via remote shell, while '::' & 'rsync://' usages connect\n");
   rprintf(F,"to an rsync daemon, and require SRC or DEST to start with a module name.\n");
   rprintf(F,"\n");
   rprintf(F,"Options\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
+  rprintf(F,"     --info=FLAGS            fine-grained informational verbosity\n");
+  rprintf(F,"     --debug=FLAGS           fine-grained debug verbosity\n");
+  rprintf(F,"     --msgs2stderr           special output handling for debugging\n");
   rprintf(F," -q, --quiet                 suppress non-error messages\n");
   rprintf(F,"     --no-motd               suppress daemon-mode MOTD (see manpage caveat)\n");
   rprintf(F," -c, --checksum              skip based on checksum, not mod-time & size\n");
   rprintf(F," -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)\n");
   rprintf(F,"     --no-OPTION             turn off an implied OPTION (e.g. --no-D)\n");
   rprintf(F," -r, --recursive             recurse into directories\n");
@@ -330,12 +685,13 @@
   rprintf(F,"     --append-verify         like --append, but with old data in file checksum\n");
   rprintf(F," -d, --dirs                  transfer directories without recursing\n");
   rprintf(F," -l, --links                 copy symlinks as symlinks\n");
   rprintf(F," -L, --copy-links            transform symlink into referent file/dir\n");
   rprintf(F,"     --copy-unsafe-links     only \"unsafe\" symlinks are transformed\n");
   rprintf(F,"     --safe-links            ignore symlinks that point outside the source tree\n");
+  rprintf(F,"     --munge-links           munge symlinks to make them safer (but unusable)\n");
   rprintf(F," -k, --copy-dirlinks         transform symlink to a dir into referent dir\n");
   rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
   rprintf(F," -H, --hard-links            preserve hard links\n");
   rprintf(F," -p, --perms                 preserve permissions\n");
   rprintf(F," -E, --executability         preserve the file's executability\n");
   rprintf(F,"     --chmod=CHMOD           affect file and/or directory permissions\n");
@@ -349,17 +705,23 @@
   rprintf(F," -g, --group                 preserve group\n");
   rprintf(F,"     --devices               preserve device files (super-user only)\n");
   rprintf(F,"     --specials              preserve special files\n");
   rprintf(F," -D                          same as --devices --specials\n");
   rprintf(F," -t, --times                 preserve modification times\n");
   rprintf(F," -O, --omit-dir-times        omit directories from --times\n");
+  rprintf(F," -J, --omit-link-times       omit symlinks from --times\n");
   rprintf(F,"     --super                 receiver attempts super-user activities\n");
 #ifdef SUPPORT_XATTRS
   rprintf(F,"     --fake-super            store/recover privileged attrs using xattrs\n");
 #endif
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
+#ifdef SUPPORT_PREALLOCATION
+  rprintf(F,"     --preallocate           allocate dest files before writing them\n");
+#else
+  rprintf(F,"     --preallocate           pre-allocate dest files on remote receiver\n");
+#endif
   rprintf(F," -n, --dry-run               perform a trial run with no changes made\n");
   rprintf(F," -W, --whole-file            copy files whole (without delta-xfer algorithm)\n");
   rprintf(F," -x, --one-file-system       don't cross filesystem boundaries\n");
   rprintf(F," -B, --block-size=SIZE       force a fixed checksum block-size\n");
   rprintf(F," -e, --rsh=COMMAND           specify the remote shell to use\n");
   rprintf(F,"     --rsync-path=PROGRAM    specify the rsync to run on the remote machine\n");
@@ -370,25 +732,31 @@
   rprintf(F,"     --delete                delete extraneous files from destination dirs\n");
   rprintf(F,"     --delete-before         receiver deletes before transfer, not during\n");
   rprintf(F,"     --delete-during         receiver deletes during the transfer\n");
   rprintf(F,"     --delete-delay          find deletions during, delete after\n");
   rprintf(F,"     --delete-after          receiver deletes after transfer, not during\n");
   rprintf(F,"     --delete-excluded       also delete excluded files from destination dirs\n");
+  rprintf(F,"     --ignore-missing-args   ignore missing source args without error\n");
+  rprintf(F,"     --delete-missing-args   delete missing source args from destination\n");
   rprintf(F,"     --ignore-errors         delete even if there are I/O errors\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --max-delete=NUM        don't delete more than NUM files\n");
   rprintf(F,"     --max-size=SIZE         don't transfer any file larger than SIZE\n");
   rprintf(F,"     --min-size=SIZE         don't transfer any file smaller than SIZE\n");
   rprintf(F,"     --partial               keep partially transferred files\n");
   rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
   rprintf(F,"     --delay-updates         put all updated files into place at transfer's end\n");
   rprintf(F," -m, --prune-empty-dirs      prune empty directory chains from the file-list\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
+  rprintf(F,"     --usermap=STRING        custom username mapping\n");
+  rprintf(F,"     --groupmap=STRING       custom groupname mapping\n");
+  rprintf(F,"     --chown=USER:GROUP      simple username/groupname mapping\n");
   rprintf(F,"     --timeout=SECONDS       set I/O timeout in seconds\n");
   rprintf(F,"     --contimeout=SECONDS    set daemon connection timeout in seconds\n");
   rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
+  rprintf(F," -M, --remote-option=OPTION  send OPTION to the remote side only\n");
   rprintf(F,"     --size-only             skip files that match in size\n");
   rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
   rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
@@ -419,20 +787,24 @@
   rprintf(F," -i, --itemize-changes       output a change-summary for all updates\n");
   rprintf(F,"     --out-format=FORMAT     output updates using the specified FORMAT\n");
   rprintf(F,"     --log-file=FILE         log what we're doing to the specified FILE\n");
   rprintf(F,"     --log-file-format=FMT   log updates using the specified FMT\n");
   rprintf(F,"     --password-file=FILE    read daemon-access password from FILE\n");
   rprintf(F,"     --list-only             list the files instead of copying them\n");
-  rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
+  rprintf(F,"     --bwlimit=RATE          limit socket I/O bandwidth\n");
+#ifdef HAVE_SETVBUF
+  rprintf(F,"     --outbuf=N|L|B          set output buffering to None, Line, or Block\n");
+#endif
   rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
   rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
   rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
   rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
 #ifdef ICONV_OPTION
   rprintf(F,"     --iconv=CONVERT_SPEC    request charset conversion of filenames\n");
 #endif
+  rprintf(F,"     --checksum-seed=NUM     set block/file checksum seed (advanced)\n");
   rprintf(F," -4, --ipv4                  prefer IPv4\n");
   rprintf(F," -6, --ipv6                  prefer IPv6\n");
   rprintf(F,"     --version               print version number\n");
   rprintf(F,"(-h) --help                  show this help (-h is --help only if used alone)\n");
 
   rprintf(F,"\n");
@@ -442,22 +814,26 @@
 }
 
 enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
-      OPT_NO_D, OPT_APPEND, OPT_NO_ICONV,
+      OPT_NO_D, OPT_APPEND, OPT_NO_ICONV, OPT_INFO, OPT_DEBUG,
+      OPT_USERMAP, OPT_GROUPMAP, OPT_CHOWN, OPT_BWLIMIT,
       OPT_SERVER, OPT_REFUSED_BASE = 9000};
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"help",             0,  POPT_ARG_NONE,   0, OPT_HELP, 0, 0 },
   {"version",          0,  POPT_ARG_NONE,   0, OPT_VERSION, 0, 0},
   {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
   {"no-verbose",       0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
   {"no-v",             0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
+  {"info",             0,  POPT_ARG_STRING, 0, OPT_INFO, 0, 0 },
+  {"debug",            0,  POPT_ARG_STRING, 0, OPT_DEBUG, 0, 0 },
+  {"msgs2stderr",      0,  POPT_ARG_NONE,   &msgs2stderr, 0, 0, 0 },
   {"quiet",           'q', POPT_ARG_NONE,   0, 'q', 0, 0 },
   {"motd",             0,  POPT_ARG_VAL,    &output_motd, 1, 0, 0 },
   {"no-motd",          0,  POPT_ARG_VAL,    &output_motd, 0, 0, 0 },
   {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
   {"human-readable",  'h', POPT_ARG_NONE,   0, 'h', 0, 0},
   {"no-human-readable",0,  POPT_ARG_VAL,    &human_readable, 0, 0, 0},
@@ -489,12 +865,15 @@
   {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
   {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
   {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 1, 0, 0 },
   {"no-omit-dir-times",0,  POPT_ARG_VAL,    &omit_dir_times, 0, 0, 0 },
   {"no-O",             0,  POPT_ARG_VAL,    &omit_dir_times, 0, 0, 0 },
+  {"omit-link-times", 'J', POPT_ARG_VAL,    &omit_link_times, 1, 0, 0 },
+  {"no-omit-link-times",0, POPT_ARG_VAL,    &omit_link_times, 0, 0, 0 },
+  {"no-J",             0,  POPT_ARG_VAL,    &omit_link_times, 0, 0, 0 },
   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
   {"super",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },
   {"no-super",         0,  POPT_ARG_VAL,    &am_root, 0, 0, 0 },
   {"fake-super",       0,  POPT_ARG_VAL,    &am_root, -1, 0, 0 },
   {"owner",           'o', POPT_ARG_VAL,    &preserve_uid, 1, 0, 0 },
   {"no-owner",         0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },
@@ -511,12 +890,14 @@
   {"links",           'l', POPT_ARG_VAL,    &preserve_links, 1, 0, 0 },
   {"no-links",         0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
   {"no-l",             0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
   {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
   {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
   {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
+  {"munge-links",      0,  POPT_ARG_VAL,    &munge_symlinks, 1, 0, 0 },
+  {"no-munge-links",   0,  POPT_ARG_VAL,    &munge_symlinks, 0, 0, 0 },
   {"copy-dirlinks",   'k', POPT_ARG_NONE,   &copy_dirlinks, 0, 0, 0 },
   {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
   {"hard-links",      'H', POPT_ARG_NONE,   0, 'H', 0, 0 },
   {"no-hard-links",    0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },
   {"no-H",             0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },
   {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
@@ -538,24 +919,27 @@
   {"ignore-existing",  0,  POPT_ARG_NONE,   &ignore_existing, 0, 0, 0 },
   {"max-size",         0,  POPT_ARG_STRING, &max_size_arg, OPT_MAX_SIZE, 0, 0 },
   {"min-size",         0,  POPT_ARG_STRING, &min_size_arg, OPT_MIN_SIZE, 0, 0 },
   {"sparse",          'S', POPT_ARG_VAL,    &sparse_files, 1, 0, 0 },
   {"no-sparse",        0,  POPT_ARG_VAL,    &sparse_files, 0, 0, 0 },
   {"no-S",             0,  POPT_ARG_VAL,    &sparse_files, 0, 0, 0 },
+  {"preallocate",      0,  POPT_ARG_NONE,   &preallocate_files, 0, 0, 0},
   {"inplace",          0,  POPT_ARG_VAL,    &inplace, 1, 0, 0 },
   {"no-inplace",       0,  POPT_ARG_VAL,    &inplace, 0, 0, 0 },
   {"append",           0,  POPT_ARG_NONE,   0, OPT_APPEND, 0, 0 },
   {"append-verify",    0,  POPT_ARG_VAL,    &append_mode, 2, 0, 0 },
   {"no-append",        0,  POPT_ARG_VAL,    &append_mode, 0, 0, 0 },
   {"del",              0,  POPT_ARG_NONE,   &delete_during, 0, 0, 0 },
   {"delete",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },
   {"delete-before",    0,  POPT_ARG_NONE,   &delete_before, 0, 0, 0 },
   {"delete-during",    0,  POPT_ARG_VAL,    &delete_during, 1, 0, 0 },
   {"delete-delay",     0,  POPT_ARG_VAL,    &delete_during, 2, 0, 0 },
   {"delete-after",     0,  POPT_ARG_NONE,   &delete_after, 0, 0, 0 },
   {"delete-excluded",  0,  POPT_ARG_NONE,   &delete_excluded, 0, 0, 0 },
+  {"delete-missing-args",0,POPT_BIT_SET,    &missing_args, 2, 0, 0 },
+  {"ignore-missing-args",0,POPT_BIT_SET,    &missing_args, 1, 0, 0 },
   {"remove-sent-files",0,  POPT_ARG_VAL,    &remove_source_files, 2, 0, 0 }, /* deprecated */
   {"remove-source-files",0,POPT_ARG_VAL,    &remove_source_files, 1, 0, 0 },
   {"force",            0,  POPT_ARG_VAL,    &force_delete, 1, 0, 0 },
   {"no-force",         0,  POPT_ARG_VAL,    &force_delete, 0, 0, 0 },
   {"ignore-errors",    0,  POPT_ARG_VAL,    &ignore_errors, 1, 0, 0 },
   {"no-ignore-errors", 0,  POPT_ARG_VAL,    &ignore_errors, 0, 0, 0 },
@@ -574,13 +958,13 @@
   {"no-checksum",      0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
   {"no-c",             0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
-  {"fuzzy",           'y', POPT_ARG_VAL,    &fuzzy_basis, 1, 0, 0 },
+  {"fuzzy",           'y', POPT_ARG_NONE,   0, 'y', 0, 0 },
   {"no-fuzzy",         0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
   {"no-y",             0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
   {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
   {"no-compress",      0,  POPT_ARG_VAL,    &do_compression, 0, 0, 0 },
   {"no-z",             0,  POPT_ARG_VAL,    &do_compression, 0, 0, 0 },
   {"skip-compress",    0,  POPT_ARG_STRING, &skip_compress, 0, 0, 0 },
@@ -600,13 +984,13 @@
   {"log-file-format",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },
   {"out-format",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 },
   {"log-format",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 }, /* DEPRECATED */
   {"itemize-changes", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },
   {"no-itemize-changes",0, POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },
   {"no-i",             0,  POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },
-  {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
+  {"bwlimit",          0,  POPT_ARG_STRING, &bwlimit_arg, OPT_BWLIMIT, 0, 0 },
   {"no-bwlimit",       0,  POPT_ARG_VAL,    &bwlimit, 0, 0, 0 },
   {"backup",          'b', POPT_ARG_VAL,    &make_backups, 1, 0, 0 },
   {"no-backup",        0,  POPT_ARG_VAL,    &make_backups, 0, 0, 0 },
   {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
   {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
@@ -618,12 +1002,15 @@
   {"no-from0",         0,  POPT_ARG_VAL,    &eol_nulls, 0, 0, 0},
   {"protect-args",    's', POPT_ARG_VAL,    &protect_args, 1, 0, 0},
   {"no-protect-args",  0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},
   {"no-s",             0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},
   {"numeric-ids",      0,  POPT_ARG_VAL,    &numeric_ids, 1, 0, 0 },
   {"no-numeric-ids",   0,  POPT_ARG_VAL,    &numeric_ids, 0, 0, 0 },
+  {"usermap",          0,  POPT_ARG_STRING, 0, OPT_USERMAP, 0, 0 },
+  {"groupmap",         0,  POPT_ARG_STRING, 0, OPT_GROUPMAP, 0, 0 },
+  {"chown",            0,  POPT_ARG_STRING, 0, OPT_CHOWN, 0, 0 },
   {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
   {"no-timeout",       0,  POPT_ARG_VAL,    &io_timeout, 0, 0, 0 },
   {"contimeout",       0,  POPT_ARG_INT,    &connect_timeout, 0, 0, 0 },
   {"no-contimeout",    0,  POPT_ARG_VAL,    &connect_timeout, 0, 0, 0 },
   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
   {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
@@ -641,33 +1028,39 @@
   {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
   {"sockopts",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },
   {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
   {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
+#ifdef HAVE_SETVBUF
+  {"outbuf",           0,  POPT_ARG_STRING, &outbuf_mode, 0, 0, 0 },
+#endif
+  {"remote-option",   'M', POPT_ARG_STRING, 0, 'M', 0, 0 },
   {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
   {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
   {"server",           0,  POPT_ARG_NONE,   0, OPT_SERVER, 0, 0 },
   {"sender",           0,  POPT_ARG_NONE,   0, OPT_SENDER, 0, 0 },
   /* All the following options switch us into daemon-mode option-parsing. */
   {"config",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
   {"daemon",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
+  {"dparam",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
   {"detach",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
   {"no-detach",        0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
   {0,0,0,0, 0, 0, 0}
 };
 
 static void daemon_usage(enum logcode F)
 {
   print_rsync_version(F);
 
   rprintf(F,"\n");
   rprintf(F,"Usage: rsync --daemon [OPTION]...\n");
   rprintf(F,"     --address=ADDRESS       bind to the specified address\n");
-  rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
+  rprintf(F,"     --bwlimit=RATE          limit socket I/O bandwidth\n");
   rprintf(F,"     --config=FILE           specify alternate rsyncd.conf file\n");
+  rprintf(F," -M, --dparam=OVERRIDE       override global daemon config parameter\n");
   rprintf(F,"     --no-detach             do not detach from the parent\n");
   rprintf(F,"     --port=PORT             listen on alternate port number\n");
   rprintf(F,"     --log-file=FILE         override the \"log file\" setting\n");
   rprintf(F,"     --log-file-format=FMT   override the \"log format\" setting\n");
   rprintf(F,"     --sockopts=OPTIONS      specify custom TCP options\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
@@ -683,12 +1076,13 @@
 static struct poptOption long_daemon_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
   {"bwlimit",          0,  POPT_ARG_INT,    &daemon_bwlimit, 0, 0, 0 },
   {"config",           0,  POPT_ARG_STRING, &config_file, 0, 0, 0 },
   {"daemon",           0,  POPT_ARG_NONE,   &daemon_opt, 0, 0, 0 },
+  {"dparam",          'M', POPT_ARG_STRING, 0, 'M', 0, 0 },
   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
   {"detach",           0,  POPT_ARG_VAL,    &no_detach, 0, 0, 0 },
   {"no-detach",        0,  POPT_ARG_VAL,    &no_detach, 1, 0, 0 },
   {"log-file",         0,  POPT_ARG_STRING, &logfile_name, 0, 0, 0 },
   {"log-file-format",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },
@@ -849,13 +1243,13 @@
 		size *= mult;
 	size *= atof(*size_arg);
 	if ((*arg == '+' || *arg == '-') && arg[1] == '1')
 		size += atoi(arg), make_compatible = 1, arg += 2;
 	if (*arg)
 		return -1;
-	if (size > 0 && make_compatible) {
+	if (size > 0 && make_compatible && def_suf == 'b') {
 		/* We convert this manually because we may need %lld precision,
 		 * and that's not a portable sprintf() escape. */
 		char buf[128], *s = buf + sizeof buf - 1;
 		OFF_T num = size;
 		*s = '\0';
 		while (num) {
@@ -907,13 +1301,13 @@
 		if (!*lp_charset(module_id))
 			set_refuse_options("iconv");
 #endif
 	}
 
 #ifdef ICONV_OPTION
-	if (!am_daemon && !protect_args && (arg = getenv("RSYNC_ICONV")) != NULL && *arg)
+	if (!am_daemon && protect_args <= 0 && (arg = getenv("RSYNC_ICONV")) != NULL && *arg)
 		iconv_opt = strdup(arg);
 #endif
 
 	/* TODO: Call poptReadDefaultConfig; handle errors. */
 
 	/* The context leaks in case of an error, but if there's a
@@ -962,21 +1356,35 @@
 					sizeof err_buf);
 				return 0;
 			}
 #ifdef ICONV_OPTION
 			iconv_opt = NULL;
 #endif
+			protect_args = 0;
 			poptFreeContext(pc);
 			pc = poptGetContext(RSYNC_NAME, argc, argv,
 					    long_daemon_options, 0);
 			while ((opt = poptGetNextOpt(pc)) != -1) {
+				char **cpp;
 				switch (opt) {
 				case 'h':
 					daemon_usage(FINFO);
 					exit_cleanup(0);
 
+				case 'M':
+					arg = poptGetOptArg(pc);
+					if (!strchr(arg, '=')) {
+						rprintf(FERROR,
+						    "--dparam value is missing an '=': %s\n",
+						    arg);
+						goto daemon_error;
+					}
+					cpp = EXPAND_ITEM_LIST(&dparam_list, char *, 4);
+					*cpp = strdup(arg);
+					break;
+
 				case 'v':
 					verbose++;
 					break;
 
 				default:
 					rprintf(FERROR,
@@ -984,12 +1392,15 @@
 					    poptBadOption(pc, POPT_BADOPTION_NOALIAS),
 					    poptStrerror(opt));
 					goto daemon_error;
 				}
 			}
 
+			if (dparam_list.count && !set_dparams(1))
+				exit_cleanup(RERR_SYNTAX);
+
 			if (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {
 				snprintf(err_buf, sizeof err_buf,
 					 "the --temp-dir path is WAY too long.\n");
 				return 0;
 			}
 
@@ -1013,46 +1424,49 @@
 			 * we need to remember that we're using a
 			 * non-default setting. */
 			modify_window_set = 1;
 			break;
 
 		case OPT_FILTER:
-			parse_rule(&filter_list, poptGetOptArg(pc), 0, 0);
+			parse_filter_str(&filter_list, poptGetOptArg(pc),
+					rule_template(0), 0);
 			break;
 
 		case OPT_EXCLUDE:
-			parse_rule(&filter_list, poptGetOptArg(pc),
-				   0, XFLG_OLD_PREFIXES);
+			parse_filter_str(&filter_list, poptGetOptArg(pc),
+					rule_template(0), XFLG_OLD_PREFIXES);
 			break;
 
 		case OPT_INCLUDE:
-			parse_rule(&filter_list, poptGetOptArg(pc),
-				   MATCHFLG_INCLUDE, XFLG_OLD_PREFIXES);
+			parse_filter_str(&filter_list, poptGetOptArg(pc),
+					rule_template(FILTRULE_INCLUDE), XFLG_OLD_PREFIXES);
 			break;
 
 		case OPT_EXCLUDE_FROM:
 		case OPT_INCLUDE_FROM:
 			arg = poptGetOptArg(pc);
 			if (sanitize_paths)
 				arg = sanitize_path(NULL, arg, NULL, 0, SP_DEFAULT);
 			if (daemon_filter_list.head) {
 				int rej;
-				char *dir, *cp = strdup(arg);
+				char *cp = strdup(arg);
 				if (!cp)
 					out_of_memory("parse_arguments");
 				if (!*cp)
-					goto options_rejected;
-				dir = cp + (*cp == '/' ? module_dirlen : 0);
-				clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
-				rej = check_filter(&daemon_filter_list, FLOG, dir, 0) < 0;
+					rej = 1;
+				else {
+					char *dir = cp + (*cp == '/' ? module_dirlen : 0);
+					clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
+					rej = check_filter(&daemon_filter_list, FLOG, dir, 0) < 0;
+				}
 				free(cp);
 				if (rej)
 					goto options_rejected;
 			}
 			parse_filter_file(&filter_list, arg,
-				opt == OPT_INCLUDE_FROM ? MATCHFLG_INCLUDE : 0,
+				rule_template(opt == OPT_INCLUDE_FROM ? FILTRULE_INCLUDE : 0),
 				XFLG_FATAL_ERRORS | XFLG_OLD_PREFIXES);
 			break;
 
 		case 'a':
 			if (refused_archive_part) {
 				create_refuse_error(refused_archive_part);
@@ -1092,27 +1506,31 @@
 			break;
 
 		case 'v':
 			verbose++;
 			break;
 
+		case 'y':
+			fuzzy_basis++;
+			break;
+
 		case 'q':
 			quiet++;
 			break;
 
 		case 'x':
 			one_file_system++;
 			break;
 
 		case 'F':
 			switch (++F_option_cnt) {
 			case 1:
-				parse_rule(&filter_list,": /.rsync-filter",0,0);
+				parse_filter_str(&filter_list,": /.rsync-filter",rule_template(0),0);
 				break;
 			case 2:
-				parse_rule(&filter_list,"- .rsync-filter",0,0);
+				parse_filter_str(&filter_list,"- .rsync-filter",rule_template(0),0);
 				break;
 			}
 			break;
 
 		case 'P':
 			if (refused_partial || refused_progress) {
@@ -1136,12 +1554,32 @@
 			if (do_compression && refused_compress) {
 				create_refuse_error(refused_compress);
 				return 0;
 			}
 			break;
 
+		case 'M':
+			arg = poptGetOptArg(pc);
+			if (*arg != '-') {
+				snprintf(err_buf, sizeof err_buf,
+					"Remote option must start with a dash: %s\n", arg);
+				return 0;
+			}
+			if (remote_option_cnt+2 >= remote_option_alloc) {
+				remote_option_alloc += 16;
+				remote_options = realloc_array(remote_options,
+							const char *, remote_option_alloc);
+				if (!remote_options)
+					out_of_memory("parse_arguments");
+				if (!remote_option_cnt)
+					remote_options[0] = "ARG0";
+			}
+			remote_options[++remote_option_cnt] = arg;
+			remote_options[remote_option_cnt+1] = NULL;
+			break;
+
 		case OPT_WRITE_BATCH:
 			/* batch_name is already set */
 			write_batch = 1;
 			break;
 
 		case OPT_ONLY_WRITE_BATCH:
@@ -1158,29 +1596,46 @@
 #ifdef ICONV_OPTION
 			iconv_opt = NULL;
 #endif
 			break;
 
 		case OPT_MAX_SIZE:
-			if ((max_size = parse_size_arg(&max_size_arg, 'b')) <= 0) {
+			if ((max_size = parse_size_arg(&max_size_arg, 'b')) < 0) {
 				snprintf(err_buf, sizeof err_buf,
 					"--max-size value is invalid: %s\n",
 					max_size_arg);
 				return 0;
 			}
 			break;
 
 		case OPT_MIN_SIZE:
-			if ((min_size = parse_size_arg(&min_size_arg, 'b')) <= 0) {
+			if ((min_size = parse_size_arg(&min_size_arg, 'b')) < 0) {
 				snprintf(err_buf, sizeof err_buf,
 					"--min-size value is invalid: %s\n",
 					min_size_arg);
 				return 0;
 			}
 			break;
 
+		case OPT_BWLIMIT:
+			{
+				OFF_T limit = parse_size_arg(&bwlimit_arg, 'K');
+				if (limit < 0) {
+					snprintf(err_buf, sizeof err_buf,
+						"--bwlimit value is invalid: %s\n", bwlimit_arg);
+					return 0;
+				}
+				bwlimit = (limit + 512) / 1024;
+				if (limit && !bwlimit) {
+					snprintf(err_buf, sizeof err_buf,
+						"--bwlimit value is too small: %s\n", bwlimit_arg);
+					return 0;
+				}
+			}
+			break;
+
 		case OPT_APPEND:
 			if (am_server)
 				append_mode++;
 			else
 				append_mode = 1;
 			break;
@@ -1224,12 +1679,92 @@
 				    "Invalid argument passed to --chmod (%s)\n",
 				    arg);
 				return 0;
 			}
 			break;
 
+		case OPT_INFO:
+			arg = poptGetOptArg(pc);
+			parse_output_words(info_words, info_levels, arg, USER_PRIORITY);
+			break;
+
+		case OPT_DEBUG:
+			arg = poptGetOptArg(pc);
+			parse_output_words(debug_words, debug_levels, arg, USER_PRIORITY);
+			break;
+
+		case OPT_USERMAP:
+			if (usermap) {
+				if (usermap_via_chown) {
+					snprintf(err_buf, sizeof err_buf,
+					    "--usermap conflicts with prior --chown.\n");
+					return 0;
+				}
+				snprintf(err_buf, sizeof err_buf,
+				    "You can only specify --usermap once.\n");
+				return 0;
+			}
+			usermap = (char *)poptGetOptArg(pc);
+			usermap_via_chown = False;
+			break;
+
+		case OPT_GROUPMAP:
+			if (groupmap) {
+				if (groupmap_via_chown) {
+					snprintf(err_buf, sizeof err_buf,
+					    "--groupmap conflicts with prior --chown.\n");
+					return 0;
+				}
+				snprintf(err_buf, sizeof err_buf,
+				    "You can only specify --groupmap once.\n");
+				return 0;
+			}
+			groupmap = (char *)poptGetOptArg(pc);
+			groupmap_via_chown = False;
+			break;
+
+		case OPT_CHOWN: {
+			const char *chown = poptGetOptArg(pc);
+			int len;
+			if ((arg = strchr(chown, ':')) != NULL)
+				len = arg++ - chown;
+			else
+				len = strlen(chown);
+			if (len) {
+				if (usermap) {
+					if (!usermap_via_chown) {
+						snprintf(err_buf, sizeof err_buf,
+						    "--chown conflicts with prior --usermap.\n");
+						return 0;
+					}
+					snprintf(err_buf, sizeof err_buf,
+					    "You can only specify a user-affecting --chown once.\n");
+					return 0;
+				}
+				if (asprintf(&usermap, "*:%.*s", len, chown) < 0)
+					out_of_memory("parse_arguments");
+				usermap_via_chown = True;
+			}
+			if (arg && *arg) {
+				if (groupmap) {
+					if (!groupmap_via_chown) {
+						snprintf(err_buf, sizeof err_buf,
+						    "--chown conflicts with prior --groupmap.\n");
+						return 0;
+					}
+					snprintf(err_buf, sizeof err_buf,
+					    "You can only specify a group-affecting --chown once.\n");
+					return 0;
+				}
+				if (asprintf(&groupmap, "*:%s", arg) < 0)
+					out_of_memory("parse_arguments");
+				groupmap_via_chown = True;
+			}
+			break;
+		}
+
 		case OPT_HELP:
 			usage(FINFO);
 			exit_cleanup(0);
 
 		case 'A':
 #ifdef SUPPORT_ACLS
@@ -1271,18 +1806,72 @@
 				 poptBadOption(pc, POPT_BADOPTION_NOALIAS),
 				 poptStrerror(opt));
 			return 0;
 		}
 	}
 
-	if (human_readable && argc == 2 && !am_server) {
+	if (protect_args < 0) {
+		if (am_server)
+			protect_args = 0;
+		else if ((arg = getenv("RSYNC_PROTECT_ARGS")) != NULL && *arg)
+			protect_args = atoi(arg) ? 1 : 0;
+		else {
+#ifdef RSYNC_USE_PROTECTED_ARGS
+			protect_args = 1;
+#else
+			protect_args = 0;
+#endif
+		}
+	}
+
+	if (human_readable > 1 && argc == 2 && !am_server) {
 		/* Allow the old meaning of 'h' (--help) on its own. */
 		usage(FINFO);
 		exit_cleanup(0);
 	}
 
+#ifdef HAVE_SETVBUF
+	if (outbuf_mode && !am_server) {
+		int mode = *(uchar *)outbuf_mode;
+		if (islower(mode))
+			mode = toupper(mode);
+		fflush(stdout); /* Just in case... */
+		switch (mode) {
+		case 'N': /* None */
+		case 'U': /* Unbuffered */
+			mode = _IONBF;
+			break;
+		case 'L': /* Line */
+			mode = _IOLBF;
+			break;
+		case 'B': /* Block */
+		case 'F': /* Full */
+			mode = _IOFBF;
+			break;
+		default:
+			snprintf(err_buf, sizeof err_buf,
+				"Invalid --outbuf setting -- specify N, L, or B.\n");
+			return 0;
+		}
+		setvbuf(stdout, (char *)NULL, mode, 0);
+	}
+
+	if (msgs2stderr) {
+		/* Make stderr line buffered for better sharing of the stream. */
+		fflush(stderr); /* Just in case... */
+		setvbuf(stderr, (char *)NULL, _IOLBF, 0);
+	}
+#endif
+
+	set_output_verbosity(verbose, DEFAULT_PRIORITY);
+
+	if (do_stats) {
+		parse_output_words(info_words, info_levels,
+			verbose > 1 ? "stats3" : "stats2", DEFAULT_PRIORITY);
+	}
+
 #ifdef ICONV_OPTION
 	if (iconv_opt && protect_args != 2) {
 		if (!am_server && strcmp(iconv_opt, "-") == 0)
 			iconv_opt = NULL;
 		else
 			need_unsorted_flist = 1;
@@ -1290,12 +1879,15 @@
 	if (refused_no_iconv && !iconv_opt) {
 		create_refuse_error(refused_no_iconv);
 		return 0;
 	}
 #endif
 
+	if (fuzzy_basis > 1)
+		fuzzy_basis = basis_dir_cnt + 1;
+
 	if (protect_args == 1 && am_server)
 		return 1;
 
 	*argv_p = argv = poptGetArgs(pc);
 	*argc_p = argc = count_args(argv);
 
@@ -1328,12 +1920,18 @@
 		snprintf(err_buf, sizeof err_buf,
 			 "--fake-super requires an rsync with extended attributes enabled\n");
 		return 0;
 	}
 #endif
 
+	if (block_size > MAX_BLOCK_SIZE) {
+		snprintf(err_buf, sizeof err_buf,
+			 "--block-size=%lu is too large (max: %u)\n", block_size, MAX_BLOCK_SIZE);
+		return 0;
+	}
+
 	if (write_batch && read_batch) {
 		snprintf(err_buf, sizeof err_buf,
 			"--write-batch and --read-batch can not be used together\n");
 		return 0;
 	}
 	if (write_batch > 0 || read_batch) {
@@ -1393,13 +1991,13 @@
 	}
 
 	if (argc < 2 && !read_batch && !am_server)
 		list_only |= 1;
 
 	if (xfer_dirs >= 4) {
-		parse_rule(&filter_list, "- /*/*", 0, 0);
+		parse_filter_str(&filter_list, "- /*/*", rule_template(0), 0);
 		recurse = xfer_dirs = 1;
 	} else if (recurse)
 		xfer_dirs = 1;
 	else if (xfer_dirs < 0)
 		xfer_dirs = list_only ? 1 : 0;
 
@@ -1431,13 +2029,15 @@
 	if (!xfer_dirs && delete_mode) {
 		snprintf(err_buf, sizeof err_buf,
 			"--delete does not work without --recursive (-r) or --dirs (-d).\n");
 		return 0;
 	}
 
-	if (delete_mode && refused_delete) {
+	if (missing_args == 3) /* simplify if both options were specified */
+		missing_args = 2;
+	if (refused_delete && (delete_mode || missing_args == 2)) {
 		create_refuse_error(refused_delete);
 		return 0;
 	}
 
 	if (remove_source_files) {
 		/* We only want to infer this refusal of --remove-source-files
@@ -1447,23 +2047,34 @@
 			create_refuse_error(refused_delete);
 			return 0;
 		}
 		need_messages_from_generator = 1;
 	}
 
+	if (munge_symlinks && !am_daemon) {
+		STRUCT_STAT st;
+		char prefix[SYMLINK_PREFIX_LEN]; /* NOT +1 ! */
+		strlcpy(prefix, SYMLINK_PREFIX, sizeof prefix); /* trim the trailing slash */
+		if (do_stat(prefix, &st) == 0 && S_ISDIR(st.st_mode)) {
+			rprintf(FERROR, "Symlink munging is unsafe when a %s directory exists.\n",
+				prefix);
+			exit_cleanup(RERR_UNSUPPORTED);
+		}
+	}
+
 	if (sanitize_paths) {
 		int i;
 		for (i = argc; i-- > 0; )
 			argv[i] = sanitize_path(NULL, argv[i], "", 0, SP_KEEP_DOT_DIRS);
 		if (tmpdir)
 			tmpdir = sanitize_path(NULL, tmpdir, NULL, 0, SP_DEFAULT);
 		if (backup_dir)
 			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0, SP_DEFAULT);
 	}
 	if (daemon_filter_list.head && !am_sender) {
-		struct filter_list_struct *elp = &daemon_filter_list;
+		filter_rule_list *elp = &daemon_filter_list;
 		if (tmpdir) {
 			char *dir;
 			if (!*tmpdir)
 				goto options_rejected;
 			dir = tmpdir + (*tmpdir == '/' ? module_dirlen : 0);
 			clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
@@ -1488,42 +2099,54 @@
 		snprintf(err_buf, sizeof err_buf,
 			"--suffix cannot contain slashes: %s\n",
 			backup_suffix);
 		return 0;
 	}
 	if (backup_dir) {
-		size_t len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
+		size_t len;
+		while (*backup_dir == '.' && backup_dir[1] == '/')
+			backup_dir += 2;
+		if (*backup_dir == '.' && backup_dir[1] == '\0')
+			backup_dir++;
+		len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
 		if (len > sizeof backup_dir_buf - 128) {
 			snprintf(err_buf, sizeof err_buf,
 				"the --backup-dir path is WAY too long.\n");
 			return 0;
 		}
 		backup_dir_len = (int)len;
-		if (backup_dir_buf[backup_dir_len - 1] != '/') {
+		if (!backup_dir_len) {
+			backup_dir_len = -1;
+			backup_dir = NULL;
+		} else if (backup_dir_buf[backup_dir_len - 1] != '/') {
 			backup_dir_buf[backup_dir_len++] = '/';
 			backup_dir_buf[backup_dir_len] = '\0';
 		}
 		backup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;
-		if (verbose > 1 && !am_sender)
-			rprintf(FINFO, "backup_dir is %s\n", backup_dir_buf);
+	}
+	if (backup_dir) {
+		/* No need for a suffix or a protect rule. */
 	} else if (!backup_suffix_len && (!am_server || !am_sender)) {
 		snprintf(err_buf, sizeof err_buf,
-			"--suffix cannot be a null string without --backup-dir\n");
+			"--suffix cannot be empty %s\n", backup_dir_len < 0
+			? "when --backup-dir is the same as the dest dir"
+			: "without a --backup-dir");
 		return 0;
 	} else if (make_backups && delete_mode && !delete_excluded && !am_server) {
 		snprintf(backup_dir_buf, sizeof backup_dir_buf,
 			"P *%s", backup_suffix);
-		parse_rule(&filter_list, backup_dir_buf, 0, 0);
+		parse_filter_str(&filter_list, backup_dir_buf, rule_template(0), 0);
 	}
 
 	if (preserve_times) {
 		preserve_times = PRESERVE_FILE_TIMES;
 		if (!omit_dir_times)
 			preserve_times |= PRESERVE_DIR_TIMES;
 #ifdef CAN_SET_SYMLINK_TIMES
-		preserve_times |= PRESERVE_LINK_TIMES;
+		if (!omit_link_times)
+			preserve_times |= PRESERVE_LINK_TIMES;
 #endif
 	}
 
 	if (make_backups && !backup_dir) {
 		omit_dir_times = 0; /* Implied, so avoid -O to sender. */
 		preserve_times &= ~PRESERVE_DIR_TIMES;
@@ -1532,29 +2155,33 @@
 	if (stdout_format) {
 		if (am_server && log_format_has(stdout_format, 'I'))
 			stdout_format_has_i = 2;
 		else if (log_format_has(stdout_format, 'i'))
 			stdout_format_has_i = itemize_changes | 1;
 		if (!log_format_has(stdout_format, 'b')
-		 && !log_format_has(stdout_format, 'c'))
+		 && !log_format_has(stdout_format, 'c')
+		 && !log_format_has(stdout_format, 'C'))
 			log_before_transfer = !am_server;
 	} else if (itemize_changes) {
 		stdout_format = "%i %n%L";
 		stdout_format_has_i = itemize_changes;
 		log_before_transfer = !am_server;
 	}
 
-	if (do_progress && !verbose && !log_before_transfer && !am_server)
-		verbose = 1;
+	if (do_progress && !am_server) {
+		if (!log_before_transfer && INFO_EQ(NAME, 0))
+			parse_output_words(info_words, info_levels, "name", DEFAULT_PRIORITY);
+		parse_output_words(info_words, info_levels, "flist2,progress", DEFAULT_PRIORITY);
+	}
 
 	if (dry_run)
 		do_xfers = 0;
 
 	set_io_timeout(io_timeout);
 
-	if (verbose && !stdout_format) {
+	if (INFO_GTE(NAME, 1) && !stdout_format) {
 		stdout_format = "%n%L";
 		log_before_transfer = !am_server;
 	}
 	if (stdout_format_has_i || log_format_has(stdout_format, 'o'))
 		stdout_format_has_o_or_i = 1;
 
@@ -1645,13 +2272,13 @@
 		}
 	}
 
 	if (files_from) {
 		char *h, *p;
 		int q;
-		if (argc > 2 || (!am_daemon && argc == 1)) {
+		if (argc > 2 || (!am_daemon && !am_server && argc == 1)) {
 			usage(FERROR);
 			exit_cleanup(RERR_SYNTAX);
 		}
 		if (strcmp(files_from, "-") == 0) {
 			filesfrom_fd = 0;
 			if (am_server)
@@ -1711,12 +2338,13 @@
  * locally.
  **/
 void server_options(char **args, int *argc_p)
 {
 	static char argstr[64];
 	int ac = *argc_p;
+	uchar where;
 	char *arg;
 	int i, x;
 
 	/* This should always remain first on the server's command-line. */
 	args[ac++] = "--server";
 
@@ -1755,12 +2383,19 @@
 		if (keep_dirlinks)
 			argstr[x++] = 'K';
 		if (prune_empty_dirs)
 			argstr[x++] = 'm';
 		if (omit_dir_times)
 			argstr[x++] = 'O';
+		if (omit_link_times)
+			argstr[x++] = 'J';
+		if (fuzzy_basis) {
+			argstr[x++] = 'y';
+			if (fuzzy_basis > 1)
+				argstr[x++] = 'y';
+		}
 	} else {
 		if (copy_links)
 			argstr[x++] = 'L';
 		if (copy_dirlinks)
 			argstr[x++] = 'k';
 	}
@@ -1839,13 +2474,12 @@
 #ifdef CAN_SET_SYMLINK_TIMES
 		argstr[x++] = 'L';
 #endif
 #ifdef ICONV_OPTION
 		argstr[x++] = 's';
 #endif
-		argstr[x++] = 'f';
 	}
 
 	if (x >= (int)sizeof argstr) { /* Not possible... */
 		rprintf(FERROR, "argstr overflow in server_options().\n");
 		exit_cleanup(RERR_MALLOC);
 	}
@@ -1941,17 +2575,17 @@
 		if (max_delete > 0) {
 			if (asprintf(&arg, "--max-delete=%d", max_delete) < 0)
 				goto oom;
 			args[ac++] = arg;
 		} else if (max_delete == 0)
 			args[ac++] = "--max-delete=-1";
-		if (min_size) {
+		if (min_size >= 0) {
 			args[ac++] = "--min-size";
 			args[ac++] = min_size_arg;
 		}
-		if (max_size) {
+		if (max_size >= 0) {
 			args[ac++] = "--max-size";
 			args[ac++] = max_size_arg;
 		}
 		if (delete_before)
 			args[ac++] = "--delete-before";
 		else if (delete_during == 2)
@@ -1969,20 +2603,29 @@
 		if (write_batch < 0)
 			args[ac++] = "--only-write-batch=X";
 		if (am_root > 1)
 			args[ac++] = "--super";
 		if (size_only)
 			args[ac++] = "--size-only";
+		if (do_stats)
+			args[ac++] = "--stats";
 	} else {
 		if (skip_compress) {
 			if (asprintf(&arg, "--skip-compress=%s", skip_compress) < 0)
 				goto oom;
 			args[ac++] = arg;
 		}
 	}
 
+	/* --delete-missing-args needs the cooperation of both sides, but
+	 * the sender can handle --ignore-missing-args by itself. */
+	if (missing_args == 2)
+		args[ac++] = "--delete-missing-args";
+	else if (missing_args == 1 && !am_sender)
+		args[ac++] = "--ignore-missing-args";
+
 	if (modify_window_set) {
 		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
@@ -2015,12 +2658,24 @@
 		args[ac++] = "--numeric-ids";
 
 	if (use_qsort)
 		args[ac++] = "--use-qsort";
 
 	if (am_sender) {
+		if (usermap) {
+			if (asprintf(&arg, "--usermap=%s", usermap) < 0)
+				goto oom;
+			args[ac++] = arg;
+		}
+
+		if (groupmap) {
+			if (asprintf(&arg, "--groupmap=%s", groupmap) < 0)
+				goto oom;
+			args[ac++] = arg;
+		}
+
 		if (ignore_existing)
 			args[ac++] = "--ignore-existing";
 
 		/* Backward compatibility: send --existing, not --ignore-non-existing. */
 		if (ignore_non_existing)
 			args[ac++] = "--existing";
@@ -2039,12 +2694,22 @@
 				args[ac++] = dest_option;
 				args[ac++] = basis_dir[i];
 			}
 		}
 	}
 
+	/* What flags do we need to send to the other side? */
+	where = (am_server ? W_CLI : W_SRV) | (am_sender ? W_REC : W_SND);
+	arg = make_output_option(info_words, info_levels, where);
+	if (arg)
+		args[ac++] = arg;
+
+	arg = make_output_option(debug_words, debug_levels, where);
+	if (arg)
+		args[ac++] = arg;
+
 	if (append_mode) {
 		if (append_mode > 1)
 			args[ac++] = "--append";
 		args[ac++] = "--append";
 	} else if (inplace)
 		args[ac++] = "--inplace";
@@ -2063,25 +2728,35 @@
 			args[ac++] = "--no-relative";
 	}
 	/* It's OK that this checks the upper-bound of the protocol_version. */
 	if (relative_paths && !implied_dirs && (!am_sender || protocol_version >= 30))
 		args[ac++] = "--no-implied-dirs";
 
-	if (fuzzy_basis && am_sender)
-		args[ac++] = "--fuzzy";
-
 	if (remove_source_files == 1)
 		args[ac++] = "--remove-source-files";
 	else if (remove_source_files)
 		args[ac++] = "--remove-sent-files";
 
+	if (preallocate_files && am_sender)
+		args[ac++] = "--preallocate";
+
 	if (ac > MAX_SERVER_ARGS) { /* Not possible... */
 		rprintf(FERROR, "argc overflow in server_options().\n");
 		exit_cleanup(RERR_MALLOC);
 	}
 
+	if (remote_option_cnt) {
+		int j;
+		if (ac + remote_option_cnt > MAX_SERVER_ARGS) {
+			rprintf(FERROR, "too many remote options specified.\n");
+			exit_cleanup(RERR_SYNTAX);
+		}
+		for (j = 1; j <= remote_option_cnt; j++)
+			args[ac++] = (char*)remote_options[j];
+	}
+
 	*argc_p = ac;
 	return;
 
     oom:
 	out_of_memory("server_options");
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging: branch-from-patch
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/packaging/git-status.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging/git-status.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/packaging/git-status.pl	2010-07-01 00:17:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging/git-status.pl	2011-03-20 07:29:47.000000000 +0800
@@ -3,31 +3,34 @@
 
 sub check_git_state
 {
     my($master_branch, $fatal_unless_clean, $check_patches_dir) = @_;
 
     my($cur_branch) = check_git_status($fatal_unless_clean);
-    if ($cur_branch ne $master_branch) {
+    (my $branch = $cur_branch) =~ s{^patch/([^/]+)/[^/]+$}{$1}; # change patch/BRANCH/PATCH_NAME into BRANCH
+    if ($branch ne $master_branch) {
 	print "The checkout is not on the $master_branch branch.\n";
 	exit 1 if $master_branch ne 'master';
-	print "Do you want me to continue with --branch=$cur_branch? [n] ";
+	print "Do you want me to continue with --branch=$branch? [n] ";
 	$_ = <STDIN>;
 	exit 1 unless /^y/i;
-	$_[0] = $master_branch = $cur_branch; # Updates caller's $master_branch too.
+	$_[0] = $master_branch = $branch; # Updates caller's $master_branch too.
     }
 
     if ($check_patches_dir && -d 'patches/.git') {
-	($cur_branch) = check_git_status($fatal_unless_clean, 'patches');
-	if ($cur_branch ne $master_branch) {
-	    print "The *patches* checkout is on branch $cur_branch, not branch $master_branch.\n";
+	($branch) = check_git_status($fatal_unless_clean, 'patches');
+	if ($branch ne $master_branch) {
+	    print "The *patches* checkout is on branch $branch, not branch $master_branch.\n";
 	    print "Do you want to change it to branch $master_branch? [n] ";
 	    $_ = <STDIN>;
 	    exit 1 unless /^y/i;
 	    system "cd patches && git checkout '$master_branch'";
 	}
     }
+
+    return $cur_branch;
 }
 
 sub check_git_status
 {
     my($fatal_unless_clean, $subdir) = @_;
     $subdir = '.' unless defined $subdir;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/packaging/lsb/rsync.spec	2011-09-24 00:13:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging/lsb/rsync.spec	2013-09-29 04:55:54.000000000 +0800
@@ -1,38 +1,56 @@
 Summary: A fast, versatile, remote (and local) file-copying tool
 Name: rsync
-Version: 3.0.9
+Version: 3.1.0
 %define fullversion %{version}
 Release: 1
 %define srcdir src
 Group: Applications/Internet
 Source0: http://rsync.samba.org/ftp/rsync/%{srcdir}/rsync-%{fullversion}.tar.gz
 #Source1: http://rsync.samba.org/ftp/rsync/%{srcdir}/rsync-patches-%{fullversion}.tar.gz
 URL: http://rsync.samba.org/
 
 Prefix: %{_prefix}
 BuildRoot: /var/tmp/%{name}-root
 License: GPL
 
+%package ssl-client
+Summary: Provides rsync-ssl
+Requires: stunnel >= 4
+
+%package ssl-daemon
+Summary: An stunnel config file to support ssl rsync daemon connections.
+Requires: stunnel >= 4
+
 %description
 Rsync is a fast and extraordinarily versatile file copying tool.  It can
 copy locally, to/from another host over any remote shell, or to/from a
 remote rsync daemon.  It offers a large number of options that control
 every aspect of its behavior and permit very flexible specification of the
 set of files to be copied.  It is famous for its delta-transfer algorithm,
 which reduces the amount of data sent over the network by sending only the
 differences between the source files and the existing files in the
 destination.  Rsync is widely used for backups and mirroring and as an
 improved copy command for everyday use.
 
+%description ssl-client
+Provides the rsync-ssl script that makes use of stunnel 4 to open an ssl
+connection to an rsync daemon (on port 874).  This setup does NOT require
+any local stunnel daemon to be running to connect to the remote ssl rsyncd.
+
+%description ssl-daemon
+Provides a config file for stunnel that will (if you start your stunnel
+service) cause stunnel to listen for ssl rsync-daemon connections and run
+"rsync --daemon" to handle them.
+
 %prep
 # Choose one -- setup source only, or setup source + rsync-patches:
 %setup -q -n rsync-%{fullversion}
 #%setup -q -b1 -n rsync-%{fullversion}
 
-# If you you used "%setup -q -b1", choose the patches you wish to apply:
+# If you you used "%setup -q -b1 ...", choose the patches you wish to apply:
 #patch -p1 <patches/acls.diff
 #patch -p1 <patches/xattrs.diff
 #patch -p1 <patches/remote-option.diff
 #patch -p1 <patches/db.diff
 
 # Avoid extra perl dependencies for scripts going into doc dir.
@@ -43,32 +61,37 @@
 %configure
 
 make
 
 %install
 rm -rf $RPM_BUILD_ROOT
+make install install-ssl-client install-ssl-daemon DESTDIR=$RPM_BUILD_ROOT
 
-%makeinstall
-
-mkdir -p $RPM_BUILD_ROOT/etc/xinetd.d
+mkdir -p $RPM_BUILD_ROOT/etc/xinetd.d $RPM_BUILD_ROOT/etc/rsync-ssl/certs
 install -m 644 packaging/lsb/rsync.xinetd $RPM_BUILD_ROOT/etc/xinetd.d/rsync
 
-#install -p -m 755 support/rsyncdb $RPM_BUILD_ROOT/usr/bin/rsyncdb
-
 %clean
 rm -rf $RPM_BUILD_ROOT
 
 %files
 %defattr(-,root,root)
 %doc COPYING NEWS OLDNEWS README support/ tech_report.tex
 %config(noreplace) /etc/xinetd.d/rsync
-%{_prefix}/bin/rsync*
+%{_prefix}/bin/rsync
 %{_mandir}/man1/rsync.1*
 %{_mandir}/man5/rsyncd.conf.5*
 
+%files ssl-client
+%{_prefix}/bin/rsync-ssl
+%{_prefix}/bin/stunnel-rsync
+
+%files ssl-daemon
+%config(noreplace) /etc/stunnel/rsyncd.conf
+%dir /etc/rsync-ssl/certs
+
 %changelog
-* Fri Sep 23 2011 Wayne Davison <wayned@samba.org>
-Released 3.0.9.
+* Sat Sep 28 2013 Wayne Davison <wayned@samba.org>
+Released 3.1.0.
 
 * Fri Mar 21 2008 Wayne Davison <wayned@samba.org>
 Added installation of /etc/xinetd.d/rsync file and some commented-out
 lines that demonstrate how to use the rsync-patches tar file.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/packaging/patch-update /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging/patch-update
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/packaging/patch-update	2010-07-01 00:17:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging/patch-update	2011-03-20 07:29:47.000000000 +0800
@@ -29,13 +29,13 @@
 }
 
 die "No '$patches_dir' directory was found.\n" unless -d $patches_dir;
 die "No '.git' directory present in the current dir.\n" unless -d '.git';
 
 require 'packaging/git-status.pl';
-check_git_state($master_branch, !$skip_branch_check, 1);
+my $starting_branch = check_git_state($master_branch, !$skip_branch_check, 1);
 
 my $master_commit;
 open PIPE, '-|', "git log -1 --no-color $master_branch" or die $!;
 while (<PIPE>) {
     if (/^commit (\S+)/) {
 	$master_commit = $1;
@@ -121,13 +121,13 @@
 
 if ($incl_generated_files) {
     system "rm -rf $tmp_dir";
 }
 
 sleep 1 while $last_touch >= time;
-system "git checkout $master_branch" and exit 1;
+system "git checkout $starting_branch" and exit 1;
 
 exit;
 
 
 sub update_patch
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/packaging/release-rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging/release-rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/packaging/release-rsync	2010-07-01 00:17:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/packaging/release-rsync	2013-09-17 00:16:30.000000000 +0800
@@ -275,13 +275,13 @@
 
 print "Updating files in \"patches\" dir ...\n";
 system "packaging/patch-update --branch=$master_branch";
 
 if ($ans =~ /^y/i) {
     print "\nVisiting all \"patch/$master_branch/*\" branches ...\n";
-    system "packaging/patch-update --branch=$master_branch --shell";
+    system "packaging/patch-update --branch=$master_branch --skip-check --shell";
 }
 
 if (-d 'patches/.git') {
     system "cd patches && git commit -a -m 'The patches for $version.'" and exit 1;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/params.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/params.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/params.c	2007-11-23 01:51:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/params.c	2011-03-12 08:13:33.000000000 +0800
@@ -72,12 +72,13 @@
  *
  * -------------------------------------------------------------------------- **
  */
 
 #include "rsync.h"
 #include "ifuncs.h"
+#include "itypes.h"
 
 /* -------------------------------------------------------------------------- **
  * Constants...
  */
 
 #define BUFR_INC 1024
@@ -90,12 +91,14 @@
  *                but it was the nicest kludge I could think of (for now).
  *  bSize       - The size of the global buffer <bufr>.
  */
 
 static char *bufr  = NULL;
 static int   bSize = 0;
+static BOOL  (*the_sfunc)(char *);
+static BOOL  (*the_pfunc)(char *, char *);
 
 /* -------------------------------------------------------------------------- **
  * Functions...
  */
 
 static int EatWhitespace( FILE *InFile )
@@ -220,26 +223,26 @@
     switch( c )
       {
       case ']':                       /* Found the closing bracket.         */
         bufr[end] = '\0';
         if( 0 == end )                  /* Don't allow an empty name.       */
           {
-          rprintf(FLOG, "%s Empty section name in configuration file.\n", func );
+          rprintf(FLOG, "%s Empty section name in config file.\n", func );
           return( False );
           }
         if( !sfunc( bufr ) )            /* Got a valid name.  Deal with it. */
           return( False );
         (void)EatComment( InFile );     /* Finish off the line.             */
         return( True );
 
       case '\n':                      /* Got newline before closing ']'.    */
         i = Continuation( bufr, i );    /* Check for line continuation.     */
         if( i < 0 )
           {
           bufr[end] = '\0';
-          rprintf(FLOG, "%s Badly formed line in configuration file: %s\n",
+          rprintf(FLOG, "%s Badly formed line in config file: %s\n",
                    func, bufr );
           return( False );
           }
         end = ( (i > 0) && (' ' == bufr[i - 1]) ) ? (i - 1) : (i);
         c = getc( InFile );             /* Continue with next line.         */
         break;
@@ -258,13 +261,13 @@
           c = getc( InFile );
           }
       }
     }
 
   /* We arrive here if we've met the EOF before the closing bracket. */
-  rprintf(FLOG, "%s Unexpected EOF in the configuration file: %s\n", func, bufr );
+  rprintf(FLOG, "%s Unexpected EOF in the config file: %s\n", func, bufr );
   return( False );
   } /* Section */
 
 static BOOL Parameter( FILE *InFile, BOOL (*pfunc)(char *, char *), int c )
   /* ------------------------------------------------------------------------ **
    * Scan a parameter name and value, and pass these two fields to pfunc().
@@ -312,27 +315,26 @@
 
     switch( c )
       {
       case '=':                 /* Equal sign marks end of param name. */
         if( 0 == end )              /* Don't allow an empty name.      */
           {
-          rprintf(FLOG, "%s Invalid parameter name in config. file.\n", func );
+          rprintf(FLOG, "%s Invalid parameter name in config file.\n", func );
           return( False );
           }
         bufr[end++] = '\0';         /* Mark end of string & advance.   */
-        i       = end;              /* New string starts here.         */
-        vstart  = end;              /* New string is parameter value.  */
-        bufr[i] = '\0';             /* New string is nul, for now.     */
+        i = vstart = end;           /* New string starts here.         */
+        c = EatWhitespace(InFile);
         break;
 
       case '\n':                /* Find continuation char, else error. */
         i = Continuation( bufr, i );
         if( i < 0 )
           {
           bufr[end] = '\0';
-          rprintf(FLOG, "%s Ignoring badly formed line in configuration file: %s\n",
+          rprintf(FLOG, "%s Ignoring badly formed line in config file: %s\n",
                    func, bufr );
           return( True );
           }
         end = ( (i > 0) && (' ' == bufr[i - 1]) ) ? (i - 1) : (i);
         c = getc( InFile );       /* Read past eoln.                   */
         break;
@@ -340,12 +342,25 @@
       case '\0':                /* Shouldn't have EOF within param name. */
       case EOF:
         bufr[i] = '\0';
         rprintf(FLOG, "%s Unexpected end-of-file at: %s\n", func, bufr );
         return( True );
 
+      case ' ':
+      case '\t':
+        /* A directive divides at the first space or tab. */
+        if (*bufr == '&') {
+          bufr[end++] = '\0';
+          i = vstart = end;
+          c = EatWhitespace(InFile);
+          if (c == '=')
+            c = EatWhitespace(InFile);
+          break;
+        }
+        /* FALL THROUGH */
+
       default:
         if( isspace( c ) )     /* One ' ' per whitespace region.       */
           {
           bufr[end] = ' ';
           i = end + 1;
           c = EatWhitespace( InFile );
@@ -357,13 +372,12 @@
           c = getc( InFile );
           }
       }
     }
 
   /* Now parse the value. */
-  c = EatWhitespace( InFile );  /* Again, trim leading whitespace. */
   while( (EOF !=c) && (c > 0) )
     {
 
     if( i > (bSize - 2) )       /* Make sure there's enough room. */
       {
       bSize += BUFR_INC;
@@ -403,34 +417,116 @@
     }
   bufr[end] = '\0';          /* End of value. */
 
   return( pfunc( bufr, &bufr[vstart] ) );   /* Pass name & value to pfunc().  */
   } /* Parameter */
 
-static BOOL Parse( FILE *InFile,
+static int name_cmp(const void *n1, const void *n2)
+{
+    return strcmp(*(char * const *)n1, *(char * const *)n2);
+}
+
+static int include_config(char *include, int manage_globals)
+{
+    STRUCT_STAT sb;
+    char *match = manage_globals ? "*.conf" : "*.inc";
+    int ret;
+
+    if (do_stat(include, &sb) < 0) {
+	rsyserr(FLOG, errno, "unable to stat config file \"%s\"", include);
+	return 0;
+    }
+
+    if (S_ISREG(sb.st_mode)) {
+	if (manage_globals && the_sfunc)
+	    the_sfunc("]push");
+	ret = pm_process(include, the_sfunc, the_pfunc);
+	if (manage_globals && the_sfunc)
+	    the_sfunc("]pop");
+    } else if (S_ISDIR(sb.st_mode)) {
+	char buf[MAXPATHLEN], **bpp;
+	item_list conf_list;
+	struct dirent *di;
+	size_t j;
+	DIR *d;
+
+	if (!(d = opendir(include))) {
+	    rsyserr(FLOG, errno, "unable to open config dir \"%s\"", include);
+	    return 0;
+	}
+
+	memset(&conf_list, 0, sizeof conf_list);
+
+	while ((di = readdir(d)) != NULL) {
+	    char *dname = d_name(di);
+	    if (!wildmatch(match, dname))
+		continue;
+	    bpp = EXPAND_ITEM_LIST(&conf_list, char *, 32);
+	    pathjoin(buf, sizeof buf, include, dname);
+	    *bpp = strdup(buf);
+	}
+	closedir(d);
+
+	if (!(bpp = conf_list.items))
+	    return 1;
+
+	if (conf_list.count > 1)
+	    qsort(bpp, conf_list.count, sizeof (char *), name_cmp);
+
+	for (j = 0, ret = 1; j < conf_list.count; j++) {
+	    if (manage_globals && the_sfunc)
+		the_sfunc(j == 0 ? "]push" : "]reset");
+	    if ((ret = pm_process(bpp[j], the_sfunc, the_pfunc)) != 1)
+		break;
+	}
+
+	if (manage_globals && the_sfunc)
+	    the_sfunc("]pop");
+
+	for (j = 0; j < conf_list.count; j++)
+	    free(bpp[j]);
+	free(bpp);
+    } else
+	ret = 0;
+
+    return ret;
+}
+
+static int parse_directives(char *name, char *val)
+{
+    if (strcasecmp(name, "&include") == 0)
+        return include_config(val, 1);
+    if (strcasecmp(name, "&merge") == 0)
+        return include_config(val, 0);
+    rprintf(FLOG, "Unknown directive: %s.\n", name);
+    return 0;
+}
+
+static int Parse( FILE *InFile,
                    BOOL (*sfunc)(char *),
                    BOOL (*pfunc)(char *, char *) )
   /* ------------------------------------------------------------------------ **
    * Scan & parse the input.
    *
    *  Input:  InFile  - Input source.
    *          sfunc   - Function to be called when a section name is scanned.
    *                    See Section().
    *          pfunc   - Function to be called when a parameter is scanned.
    *                    See Parameter().
    *
-   *  Output: True if the file was successfully scanned, else False.
+   *  Output: 1 if the file was successfully scanned, 2 if the file was
+   *  scanned until a section header with no section function, else 0.
    *
    *  Notes:  The input can be viewed in terms of 'lines'.  There are four
    *          types of lines:
    *            Blank      - May contain whitespace, otherwise empty.
    *            Comment    - First non-whitespace character is a ';' or '#'.
    *                         The remainder of the line is ignored.
    *            Section    - First non-whitespace character is a '['.
    *            Parameter  - The default case.
-   * 
+   *
    * ------------------------------------------------------------------------ **
    */
   {
   int    c;
 
   c = EatWhitespace( InFile );
@@ -445,35 +541,45 @@
       case ';':                         /* Comment line. */
       case '#':
         c = EatComment( InFile );
         break;
 
       case '[':                         /* Section Header. */
-	      if (!sfunc) return True;
-	      if( !Section( InFile, sfunc ) )
-		      return( False );
-	      c = EatWhitespace( InFile );
-	      break;
+        if (!sfunc)
+          return 2;
+        if( !Section( InFile, sfunc ) )
+          return 0;
+        c = EatWhitespace( InFile );
+        break;
 
       case '\\':                        /* Bogus backslash. */
         c = EatWhitespace( InFile );
         break;
 
+      case '&':                         /* Handle directives */
+        the_sfunc = sfunc;
+        the_pfunc = pfunc;
+        c = Parameter( InFile, parse_directives, c );
+        if (c != 1)
+          return c;
+        c = EatWhitespace( InFile );
+        break;
+
       default:                          /* Parameter line. */
         if( !Parameter( InFile, pfunc, c ) )
-          return( False );
+          return 0;
         c = EatWhitespace( InFile );
         break;
       }
     }
-  return( True );
+  return 1;
   } /* Parse */
 
 static FILE *OpenConfFile( char *FileName )
   /* ------------------------------------------------------------------------ **
-   * Open a configuration file.
+   * Open a config file.
    *
    *  Input:  FileName  - The pathname of the config file to be opened.
    *
    *  Output: A pointer of type (FILE *) to the opened file, or NULL if the
    *          file could not be opened.
    *
@@ -482,39 +588,40 @@
   {
   FILE *OpenedFile;
   char *func = "params.c:OpenConfFile() -";
 
   if( NULL == FileName || 0 == *FileName )
     {
-    rprintf(FLOG, "%s No configuration filename specified.\n", func);
+    rprintf(FLOG, "%s No config filename specified.\n", func);
     return( NULL );
     }
 
   OpenedFile = fopen( FileName, "r" );
   if( NULL == OpenedFile )
     {
-    rsyserr(FLOG, errno, "unable to open configuration file \"%s\"",
+    rsyserr(FLOG, errno, "unable to open config file \"%s\"",
 	    FileName);
     }
 
   return( OpenedFile );
   } /* OpenConfFile */
 
-BOOL pm_process( char *FileName,
+int pm_process( char *FileName,
                  BOOL (*sfunc)(char *),
                  BOOL (*pfunc)(char *, char *) )
   /* ------------------------------------------------------------------------ **
    * Process the named parameter file.
    *
    *  Input:  FileName  - The pathname of the parameter file to be opened.
    *          sfunc     - A pointer to a function that will be called when
    *                      a section name is discovered.
    *          pfunc     - A pointer to a function that will be called when
    *                      a parameter name and value are discovered.
    *
-   *  Output: TRUE if the file was successfully parsed, else FALSE.
+   *  Output: 1 if the file was successfully parsed, 2 if parsing ended at a
+   *  section header w/o a section function, else 0.
    *
    * ------------------------------------------------------------------------ **
    */
   {
   int   result;
   FILE *InFile;
@@ -546,14 +653,14 @@
 
   fclose(InFile);
 
   if( !result )                               /* Generic failure. */
     {
     rprintf(FLOG, "%s Failed.  Error returned from params.c:parse().\n", func);
-    return( False );
+    return 0;
     }
 
-  return( True );                             /* Generic success. */
+  return result;
   } /* pm_process */
 
 /* -------------------------------------------------------------------------- */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/pipe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/pipe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/pipe.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/pipe.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * Routines used to setup various kinds of inter-process pipes.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2004-2009 Wayne Davison
+ * Copyright (C) 2004-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -23,14 +23,16 @@
 #include "rsync.h"
 
 extern int am_sender;
 extern int am_server;
 extern int blocking_io;
 extern int filesfrom_fd;
-extern mode_t orig_umask;
+extern int munge_symlinks;
 extern char *logfile_name;
+extern int remote_option_cnt;
+extern const char **remote_options;
 extern struct chmod_mode_struct *chmod_modes;
 
 /**
  * Create a child connected to us via its stdin/stdout.
  *
  * This is derived from CVS code
@@ -46,13 +48,13 @@
 pid_t piped_child(char **command, int *f_in, int *f_out)
 {
 	pid_t pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
 
-	if (verbose >= 2)
+	if (DEBUG_GTE(CMD, 1))
 		print_child_argv("opening connection using:", command);
 
 	if (fd_pair(to_child_pipe) < 0 || fd_pair(from_child_pipe) < 0) {
 		rsyserr(FERROR, errno, "pipe");
 		exit_cleanup(RERR_IPC);
 	}
@@ -72,13 +74,12 @@
 			exit_cleanup(RERR_IPC);
 		}
 		if (to_child_pipe[0] != STDIN_FILENO)
 			close(to_child_pipe[0]);
 		if (from_child_pipe[1] != STDOUT_FILENO)
 			close(from_child_pipe[1]);
-		umask(orig_umask);
 		set_blocking(STDIN_FILENO);
 		if (blocking_io > 0)
 			set_blocking(STDOUT_FILENO);
 		execvp(command[0], command);
 		rsyserr(FERROR, errno, "Failed to exec %s", command[0]);
 		exit_cleanup(RERR_IPC);
@@ -128,20 +129,30 @@
 	}
 
 	if (pid == 0) {
 		am_sender = 0;
 		am_server = 1;
 		filesfrom_fd = -1;
+		munge_symlinks = 0; /* Each side needs its own option. */
 		chmod_modes = NULL; /* Let the sending side handle this. */
 
 		/* Let the client side handle this. */
 		if (logfile_name) {
 			logfile_name = NULL;
 			logfile_close();
 		}
 
+		if (remote_option_cnt) {
+			int rc = remote_option_cnt + 1;
+			const char **rv = remote_options;
+			if (!parse_arguments(&rc, &rv)) {
+				option_error();
+				exit_cleanup(RERR_SYNTAX);
+			}
+		}
+
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
 			rsyserr(FERROR, errno, "Failed to dup/close");
 			exit_cleanup(RERR_IPC);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/progress.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/progress.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * Routines to output progress information during a file transfer.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -18,15 +18,18 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "inums.h"
 
 extern int am_server;
+extern int flist_eof;
 extern int need_unsorted_flist;
+extern int output_needs_newline;
 extern struct stats stats;
 extern struct file_list *cur_flist;
 
 #define PROGRESS_HISTORY_SECS 5
 
 #ifdef GETPGRP_VOID
@@ -37,14 +40,12 @@
 
 struct progress_history {
 	struct timeval time;
 	OFF_T ofs;
 };
 
-int progress_is_active = 0;
-
 static struct progress_history ph_start;
 static struct progress_history ph_list[PROGRESS_HISTORY_SECS];
 static int newest_hpos, oldest_hpos;
 static int current_file_index;
 
 static unsigned long msdiff(struct timeval *t1, struct timeval *t2)
@@ -63,25 +64,41 @@
  **/
 static void rprint_progress(OFF_T ofs, OFF_T size, struct timeval *now,
 			    int is_last)
 {
 	char rembuf[64], eol[128];
 	const char *units;
-	int pct = ofs == size ? 100 : (int) (100.0 * ofs / size);
 	unsigned long diff;
 	double rate, remain;
+	int pct;
 
 	if (is_last) {
+		int len = snprintf(eol, sizeof eol,
+			" (xfr#%d, %s-chk=%d/%d)\n",
+			stats.xferred_files, flist_eof ? "to" : "ir",
+			stats.num_files - current_file_index - 1,
+			stats.num_files);
+		if (INFO_GTE(PROGRESS, 2)) {
+			static int last_len = 0;
+			/* Drop \n and pad with spaces if line got shorter. */
+			if (last_len < --len)
+				last_len = len;
+			eol[last_len] = '\0';
+			while (last_len > len)
+				eol[--last_len] = ' ';
+			is_last = 0;
+		}
 		/* Compute stats based on the starting info. */
 		if (!ph_start.time.tv_sec
 		    || !(diff = msdiff(&ph_start.time, now)))
 			diff = 1;
 		rate = (double) (ofs - ph_start.ofs) * 1000.0 / diff / 1024.0;
 		/* Switch to total time taken for our last update. */
 		remain = (double) diff / 1000.0;
 	} else {
+		strlcpy(eol, "  ", sizeof eol);
 		/* Compute stats based on recent progress. */
 		if (!(diff = msdiff(&ph_list[oldest_hpos].time, now)))
 			diff = 1;
 		rate = (double) (ofs - ph_list[oldest_hpos].ofs) * 1000.0
 		     / diff / 1024.0;
 		remain = rate ? (double) (size - ofs) / rate / 1000.0 : 0.0;
@@ -103,43 +120,46 @@
 		snprintf(rembuf, sizeof rembuf, "%4d:%02d:%02d",
 			 (int) (remain / 3600.0),
 			 (int) (remain / 60.0) % 60,
 			 (int) remain % 60);
 	}
 
-	if (is_last) {
-		snprintf(eol, sizeof eol, " (xfer#%d, to-check=%d/%d)\n",
-			stats.num_transferred_files,
-			stats.num_files - current_file_index - 1,
-			stats.num_files);
-	} else
-		strlcpy(eol, "\r", sizeof eol);
-	progress_is_active = 0;
-	rprintf(FCLIENT, "%12s %3d%% %7.2f%s %s%s",
+	output_needs_newline = 0;
+	pct = ofs == size ? 100 : (int) (100.0 * ofs / size);
+	rprintf(FCLIENT, "\r%15s %3d%% %7.2f%s %s%s",
 		human_num(ofs), pct, rate, units, rembuf, eol);
-	if (!is_last)
-		progress_is_active = 1;
+	if (!is_last) {
+		output_needs_newline = 1;
+		rflush(FCLIENT);
+	}
 }
 
 void set_current_file_index(struct file_struct *file, int ndx)
 {
-	if (need_unsorted_flist)
+	if (!file)
+		current_file_index = cur_flist->used + cur_flist->ndx_start - 1;
+	else if (need_unsorted_flist)
 		current_file_index = flist_find(cur_flist, file) + cur_flist->ndx_start;
 	else
 		current_file_index = ndx;
 	current_file_index -= cur_flist->flist_num;
 }
 
 void end_progress(OFF_T size)
 {
 	if (!am_server) {
 		struct timeval now;
 		gettimeofday(&now, NULL);
-		rprint_progress(size, size, &now, True);
+		if (INFO_GTE(PROGRESS, 2)) {
+			rprint_progress(stats.total_transferred_size,
+					stats.total_size, &now, True);
+		} else {
+			rprint_progress(size, size, &now, True);
+			memset(&ph_start, 0, sizeof ph_start);
+		}
 	}
-	memset(&ph_start, 0, sizeof ph_start);
 }
 
 void show_progress(OFF_T ofs, OFF_T size)
 {
 	struct timeval now;
 #if defined HAVE_GETPGRP && defined HAVE_TCGETPGRP
@@ -189,8 +209,12 @@
 #if defined HAVE_GETPGRP && defined HAVE_TCGETPGRP
 	tc_pgrp = tcgetpgrp(STDOUT_FILENO);
 	if (tc_pgrp != pgrp && tc_pgrp != -1)
 		return;
 #endif
 
-	rprint_progress(ofs, size, &now, False);
+	if (INFO_GTE(PROGRESS, 2)) {
+		rprint_progress(stats.total_transferred_size,
+				stats.total_size, &now, False);
+	} else
+		rprint_progress(ofs, size, &now, False);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/proto.h	2011-09-24 00:44:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/proto.h	2013-09-29 11:01:28.000000000 +0800
@@ -1,9 +1,9 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
-int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
+int allow_access(const char *addr, const char **host_ptr, int i);
 void free_acl(stat_x *sxp);
 int get_acl(const char *fname, stat_x *sxp);
 void send_acl(int f, stat_x *sxp);
 void receive_acl(int f, struct file_struct *file);
 void cache_tmp_acl(struct file_struct *file, stat_x *sxp);
 void uncache_tmp_acls(void);
@@ -12,14 +12,13 @@
 int default_perms_for_dir(const char *dir);
 void base64_encode(const char *buf, int len, char *out, int pad);
 char *auth_server(int f_in, int f_out, int module, const char *host,
 		  const char *addr, const char *leader);
 void auth_client(int fd, const char *user, const char *challenge);
 char *get_backup_name(const char *fname);
-int make_bak_dir(const char *fullpath);
-int make_backup(const char *fname);
+int make_backup(const char *fname, BOOL prefer_rename);
 void write_stream_flags(int fd);
 void read_stream_flags(int fd);
 void check_batch_flags(void);
 void write_batch_shell_file(int argc, char *argv[], int file_arg_cnt);
 uint32 get_checksum1(char *buf1, int32 len);
 void get_checksum2(char *buf, int32 len, char *sum);
@@ -56,31 +55,32 @@
 int start_inband_exchange(int f_in, int f_out, const char *user, int argc, char *argv[]);
 int start_daemon(int f_in, int f_out);
 int daemon_main(void);
 void set_allow_inc_recurse(void);
 void setup_protocol(int f_out,int f_in);
 int claim_connection(char *fname, int max_connections);
+enum delret delete_item(char *fbuf, uint16 mode, uint16 flags);
+uint16 get_del_for_flag(uint16 mode);
 void set_filter_dir(const char *dir, unsigned int dirlen);
 void *push_local_filters(const char *dir, unsigned int dirlen);
 void pop_local_filters(void *mem);
 void change_local_filter_dir(const char *dname, int dlen, int dir_depth);
-int check_filter(struct filter_list_struct *listp, enum logcode code,
+int check_filter(filter_rule_list *listp, enum logcode code,
 		 const char *name, int name_is_dir);
-void parse_rule(struct filter_list_struct *listp, const char *pattern,
-		uint32 mflags, int xflags);
-void parse_filter_file(struct filter_list_struct *listp, const char *fname,
-		       uint32 mflags, int xflags);
-char *get_rule_prefix(int match_flags, const char *pat, int for_xfer,
+const filter_rule *rule_template(uint32 rflags);
+void parse_filter_str(filter_rule_list *listp, const char *rulestr,
+		     const filter_rule *template, int xflags);
+void parse_filter_file(filter_rule_list *listp, const char *fname, const filter_rule *template, int xflags);
+char *get_rule_prefix(filter_rule *rule, const char *pat, int for_xfer,
 		      unsigned int *plen_ptr);
 void send_filter_list(int f_out);
 void recv_filter_list(int f_in);
 int sparse_end(int f, OFF_T size);
 int flush_write_file(int f);
 int write_file(int f, char *buf, int len);
-struct map_struct *map_file(int fd, OFF_T len, int32 read_size,
-			    int32 blk_size);
+struct map_struct *map_file(int fd, OFF_T len, int32 read_size, int32 blk_size);
 char *map_ptr(struct map_struct *map, OFF_T offset, int32 len);
 int unmap_file(struct map_struct *map);
 void init_flist(void);
 void show_flist_stats(void);
 int link_stat(const char *path, STRUCT_STAT *stp, int follow_dirlinks);
 int change_pathname(struct file_struct *file, const char *dir, int dirlen);
@@ -103,88 +103,91 @@
 struct file_list *get_dirlist(char *dirname, int dlen, int flags);
 int unchanged_attrs(const char *fname, struct file_struct *file, stat_x *sxp);
 void itemize(const char *fnamecmp, struct file_struct *file, int ndx, int statret,
 	     stat_x *sxp, int32 iflags, uchar fnamecmp_type,
 	     const char *xname);
 int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st);
+int atomic_create(struct file_struct *file, char *fname, const char *lnk,
+		  dev_t rdev, stat_x *sxp, int del_for_flag);
 void check_for_finished_files(int itemizing, enum logcode code, int check_redo);
 void generate_files(int f_out, const char *local_name);
 struct hashtable *hashtable_create(int size, int key64);
 void hashtable_destroy(struct hashtable *tbl);
 void *hashtable_find(struct hashtable *tbl, int64 key, int allocate_if_missing);
 void init_hard_links(void);
 struct ht_int64_node *idev_find(int64 dev, int64 ino);
 void idev_destroy(void);
 void match_hard_links(struct file_list *flist);
-int hard_link_check(struct file_struct *file, int ndx, const char *fname,
+int hard_link_check(struct file_struct *file, int ndx, char *fname,
 		    int statret, stat_x *sxp, int itemizing,
 		    enum logcode code);
 int hard_link_one(struct file_struct *file, const char *fname,
 		  const char *oldname, int terse);
 void finish_hard_link(struct file_struct *file, const char *fname, int fin_ndx,
 		      STRUCT_STAT *stp, int itemizing, enum logcode code,
 		      int alt_dest);
 int skip_hard_link(struct file_struct *file, struct file_list **flist_p);
+void reduce_iobuf_size(xbuf *out, size_t new_size);
+void restore_iobuf_size(xbuf *out);
+void noop_io_until_death(void);
+int send_msg(enum msgcode code, const char *buf, size_t len, int convert);
+void send_msg_int(enum msgcode code, int num);
 void io_set_sock_fds(int f_in, int f_out);
 void set_io_timeout(int secs);
-void set_msg_fd_in(int fd);
-void set_msg_fd_out(int fd);
 void increment_active_files(int ndx, int itemizing, enum logcode code);
-int send_msg(enum msgcode code, const char *buf, int len, int convert);
-void send_msg_int(enum msgcode code, int num);
-void wait_for_receiver(void);
 int get_redo_num(void);
 int get_hlink_num(void);
-void io_set_filesfrom_fds(int f_in, int f_out);
+void start_filesfrom_forwarding(int fd);
 int read_line(int fd, char *buf, size_t bufsiz, int flags);
 void read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,
 	       char ***argv_p, int *argc_p, char **request_p);
-int io_start_buffering_out(int f_out);
-int io_start_buffering_in(int f_in);
-void io_end_buffering_in(void);
-void io_end_buffering_out(void);
+BOOL io_start_buffering_out(int f_out);
+BOOL io_start_buffering_in(int f_in);
+void io_end_buffering_in(BOOL free_buffers);
+void io_end_buffering_out(BOOL free_buffers);
 void maybe_flush_socket(int important);
-void maybe_send_keepalive(void);
-void start_flist_forward(int f_in);
+void maybe_send_keepalive(time_t now, int flags);
+void start_flist_forward(int ndx);
 void stop_flist_forward(void);
+void wait_for_receiver(void);
 unsigned short read_shortint(int f);
 int32 read_int(int f);
 int32 read_varint(int f);
 int64 read_varlong(int f, uchar min_bytes);
 int64 read_longint(int f);
 void read_buf(int f, char *buf, size_t len);
 void read_sbuf(int f, char *buf, size_t len);
 uchar read_byte(int f);
 int read_vstring(int f, char *buf, int bufsize);
 void read_sum_head(int f, struct sum_struct *sum);
 void write_sum_head(int f, struct sum_struct *sum);
-int io_flush(int flush_it_all);
+void io_flush(int flush_it_all);
 void write_shortint(int f, unsigned short x);
 void write_int(int f, int32 x);
 void write_varint(int f, int32 x);
 void write_varlong(int f, int64 x, uchar min_bytes);
 void write_longint(int f, int64 x);
 void write_buf(int f, const char *buf, size_t len);
 void write_sbuf(int f, const char *buf);
 void write_byte(int f, uchar c);
 void write_vstring(int f, const char *str, int len);
 void write_ndx(int f, int32 ndx);
 int32 read_ndx(int f);
-int read_line_old(int f, char *buf, size_t bufsiz);
+int read_line_old(int fd, char *buf, size_t bufsiz, int eof_ok);
 void io_printf(int fd, const char *format, ...);
-void io_start_multiplex_out(void);
-void io_start_multiplex_in(void);
-int io_multiplex_write(enum msgcode code, const char *buf, size_t len, int convert);
-void io_end_multiplex_in(void);
-void io_end_multiplex_out(void);
+void io_start_multiplex_out(int fd);
+void io_start_multiplex_in(int fd);
+int io_end_multiplex_in(int mode);
+int io_end_multiplex_out(int mode);
 void start_write_batch(int fd);
 void stop_write_batch(void);
 char *lp_bind_address(void);
 char *lp_motd_file(void);
 char *lp_pid_file(void);
 char *lp_socket_options(void);
+int lp_listen_backlog(void);
 int lp_rsync_port(void);
 char *lp_auth_users(int module_id);
 char *lp_charset(int module_id);
 char *lp_comment(int module_id);
 char *lp_dont_compress(int module_id);
 char *lp_exclude(int module_id);
@@ -210,76 +213,84 @@
 char *lp_uid(int module_id);
 int lp_max_connections(int module_id);
 int lp_max_verbosity(int module_id);
 int lp_syslog_facility(int module_id);
 int lp_timeout(int module_id);
 BOOL lp_fake_super(int module_id);
+BOOL lp_forward_lookup(int module_id);
 BOOL lp_ignore_errors(int module_id);
 BOOL lp_ignore_nonreadable(int module_id);
 BOOL lp_list(int module_id);
 BOOL lp_munge_symlinks(int module_id);
 BOOL lp_numeric_ids(int module_id);
 BOOL lp_read_only(int module_id);
+BOOL lp_reverse_lookup(int module_id);
 BOOL lp_strict_modes(int module_id);
 BOOL lp_transfer_logging(int module_id);
 BOOL lp_use_chroot(int module_id);
 BOOL lp_write_only(int module_id);
-BOOL lp_load(char *pszFname, int globals_only);
-int lp_numservices(void);
+int lp_load(char *pszFname, int globals_only);
+BOOL set_dparams(int syntax_check_only);
+int lp_num_modules(void);
 int lp_number(char *name);
 void log_init(int restart);
 void logfile_close(void);
 void logfile_reopen(void);
 void rwrite(enum logcode code, const char *buf, int len, int is_utf8);
 void rprintf(enum logcode code, const char *format, ...);
 void rsyserr(enum logcode code, int errcode, const char *format, ...);
 void rflush(enum logcode code);
+void remember_initial_stats(void);
 int log_format_has(const char *format, char esc);
-void log_item(enum logcode code, struct file_struct *file,
-	      struct stats *initial_stats, int iflags, const char *hlink);
+void log_item(enum logcode code, struct file_struct *file, int iflags, const char *hlink);
 void maybe_log_item(struct file_struct *file, int iflags, int itemizing,
 		    const char *buf);
 void log_delete(const char *fname, int mode);
 void log_exit(int code, const char *file, int line);
 pid_t wait_process(pid_t pid, int *status_ptr, int flags);
+void write_del_stats(int f);
+void read_del_stats(int f);
 int child_main(int argc, char *argv[]);
 void start_server(int f_in, int f_out, int argc, char *argv[]);
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[]);
 RETSIGTYPE remember_children(UNUSED(int val));
 const char *get_panic_action(void);
 int main(int argc,char *argv[]);
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len);
 void match_report(void);
+void limit_output_verbosity(int level);
+void reset_output_levels(void);
+void negate_output_levels(void);
 void usage(enum logcode F);
 void option_error(void);
 int parse_arguments(int *argc_p, const char ***argv_p);
 void server_options(char **args, int *argc_p);
 char *check_for_hostspec(char *s, char **host_ptr, int *port_ptr);
-BOOL pm_process( char *FileName,
+int pm_process( char *FileName,
                  BOOL (*sfunc)(char *),
                  BOOL (*pfunc)(char *, char *) );
 pid_t piped_child(char **command, int *f_in, int *f_out);
 pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
 		  int (*child_main)(int, char*[]));
 void set_current_file_index(struct file_struct *file, int ndx);
 void end_progress(OFF_T size);
 void show_progress(OFF_T ofs, OFF_T size);
-int get_tmpname(char *fnametmp, const char *fname);
+int get_tmpname(char *fnametmp, const char *fname, BOOL make_unique);
 int open_tmpfile(char *fnametmp, const char *fname, struct file_struct *file);
-int recv_files(int f_in, char *local_name);
+int recv_files(int f_in, int f_out, char *local_name);
 void setup_iconv(void);
 int iconvbufs(iconv_t ic, xbuf *in, xbuf *out, int flags);
 void send_protected_args(int fd, char *args[]);
-int read_ndx_and_attrs(int f_in, int *iflag_ptr, uchar *type_ptr,
+int read_ndx_and_attrs(int f_in, int f_out, int *iflag_ptr, uchar *type_ptr,
 		       char *buf, int *len_ptr);
 void free_sums(struct sum_struct *s);
 mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms,
 		 int exists);
 int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
 		   const char *fnamecmp, int flags);
-RETSIGTYPE sig_int(UNUSED(int val));
+RETSIGTYPE sig_int(int sig_num);
 int finish_transfer(const char *fname, const char *fnametmp,
 		    const char *fnamecmp, const char *partialptr,
 		    struct file_struct *file, int ok_to_set_time,
 		    int overwriting_basis);
 struct file_list *flist_for_ndx(int ndx, const char *fatal_error_loc);
 const char *who_am_i(void);
@@ -292,13 +303,14 @@
 int open_socket_out_wrapped(char *host, int port, const char *bind_addr,
 			    int af_hint);
 int is_a_socket(int fd);
 void start_accept_loop(int port, int (*fn)(int, int));
 void set_socket_options(int fd, char *options);
 int do_unlink(const char *fname);
-int do_symlink(const char *fname1, const char *fname2);
+int do_symlink(const char *lnk, const char *fname);
+ssize_t do_readlink(const char *path, char *buf, size_t bufsiz);
 int do_link(const char *fname1, const char *fname2);
 int do_lchown(const char *path, uid_t owner, gid_t group);
 int do_mknod(const char *pathname, mode_t mode, dev_t dev);
 int do_rmdir(const char *pathname);
 int do_open(const char *pathname, int flags, mode_t mode);
 int do_chmod(const char *path, mode_t mode);
@@ -312,44 +324,46 @@
 int do_fstat(int fd, STRUCT_STAT *st);
 OFF_T do_lseek(int fd, OFF_T offset, int whence);
 int do_utimensat(const char *fname, time_t modtime, uint32 mod_nsec);
 int do_lutimes(const char *fname, time_t modtime, uint32 mod_nsec);
 int do_utimes(const char *fname, time_t modtime, uint32 mod_nsec);
 int do_utime(const char *fname, time_t modtime, UNUSED(uint32 mod_nsec));
+int do_fallocate(int fd, OFF_T offset, OFF_T length);
+int do_open_nofollow(const char *pathname, int flags);
 void set_compression(const char *fname);
 void send_token(int f, int32 token, struct map_struct *buf, OFF_T offset,
 		int32 n, int32 toklen);
 int32 recv_token(int f, char **data);
 void see_token(char *data, int32 toklen);
+char *uid_to_user(uid_t uid);
+char *gid_to_group(gid_t gid);
+int user_to_uid(const char *name, uid_t *uid_p, BOOL num_ok);
+int group_to_gid(const char *name, gid_t *gid_p, BOOL num_ok);
 uid_t match_uid(uid_t uid);
 gid_t match_gid(gid_t gid, uint16 *flags_ptr);
 const char *add_uid(uid_t uid);
 const char *add_gid(gid_t gid);
 void send_id_list(int f);
 uid_t recv_user_name(int f, uid_t uid);
 gid_t recv_group_name(int f, gid_t gid, uint16 *flags_ptr);
 void recv_id_list(int f, struct file_list *flist);
+void parse_name_map(char *map, BOOL usernames);
+const char *getallgroups(uid_t uid, gid_t *gid_list, int *size_ptr);
 void set_nonblocking(int fd);
 void set_blocking(int fd);
 int fd_pair(int fd[2]);
 void print_child_argv(const char *prefix, char **cmd);
-NORETURN void out_of_memory(const char *str);
-NORETURN void overflow_exit(const char *str);
-int set_modtime(const char *fname, time_t modtime, mode_t mode);
-int mkdir_defmode(char *fname);
-int create_directory_path(char *fname);
+int set_modtime(const char *fname, time_t modtime, uint32 mod_nsec, mode_t mode);
+int make_path(char *fname, int flags);
 int full_write(int desc, const char *ptr, size_t len);
-int copy_file(const char *source, const char *dest, int ofd,
-	      mode_t mode, int create_bak_dir);
+int copy_file(const char *source, const char *dest, int ofd, mode_t mode);
 int robust_unlink(const char *fname);
 int robust_rename(const char *from, const char *to, const char *partialptr,
 		  int mode);
 pid_t do_fork(void);
 void kill_all(int sig);
-int name_to_uid(const char *name, uid_t *uid_p);
-int name_to_gid(const char *name, gid_t *gid_p);
 int lock_range(int fd, int offset, int len);
 int glob_expand(const char *arg, char ***argv_p, int *argc_p, int *maxargs_p);
 void glob_expand_module(char *base1, char *arg, char ***argv_p, int *argc_p, int *maxargs_p);
 void strlower(char *s);
 size_t pathjoin(char *dest, size_t destsize, const char *p1, const char *p2);
 size_t stringjoin(char *dest, size_t destsize, ...);
@@ -360,31 +374,32 @@
 int change_dir(const char *dir, int set_path_only);
 char *normalize_path(char *path, BOOL force_newbuf, unsigned int *len_ptr);
 char *full_fname(const char *fn);
 char *partial_dir_fname(const char *fname);
 int handle_partial_dir(const char *fname, int create);
 int unsafe_symlink(const char *dest, const char *src);
-char *human_num(int64 num);
-char *human_dnum(double dnum, int decimal_digits);
 char *timestring(time_t t);
-int msleep(int t);
 int cmp_time(time_t file1, time_t file2);
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6);
-void *_new_array(unsigned long num, unsigned int size, int use_calloc);
-void *_realloc_array(void *ptr, unsigned int size, size_t num);
 const char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr);
-uint32 fuzzy_distance(const char *s1, int len1, const char *s2, int len2);
+uint32 fuzzy_distance(const char *s1, unsigned len1, const char *s2, unsigned len2);
 struct bitbag *bitbag_create(int max_ndx);
 void bitbag_set_bit(struct bitbag *bb, int ndx);
 void bitbag_clear_bit(struct bitbag *bb, int ndx);
 int bitbag_check_bit(struct bitbag *bb, int ndx);
 int bitbag_next_bit(struct bitbag *bb, int after);
 void flist_ndx_push(flist_ndx_list *lp, int ndx);
 int flist_ndx_pop(flist_ndx_list *lp);
 void *expand_item_list(item_list *lp, size_t item_size,
 		       const char *desc, int incr);
+int msleep(int t);
+void *_new_array(unsigned long num, unsigned int size, int use_calloc);
+void *_realloc_array(void *ptr, unsigned int size, size_t num);
+const char *sum_as_hex(const char *sum);
+NORETURN void out_of_memory(const char *str);
+NORETURN void overflow_exit(const char *str);
 void free_xattr(stat_x *sxp);
 int get_xattr(const char *fname, stat_x *sxp);
 int copy_xattrs(const char *source, const char *dest);
 int send_xattr(int f, stat_x *sxp);
 int xattr_diff(struct file_struct *file, stat_x *sxp, int find_all);
 void send_xattr_request(const char *fname, struct file_struct *file, int f_out);
@@ -400,6 +415,8 @@
 int get_stat_xattr(const char *fname, int fd, STRUCT_STAT *fst, STRUCT_STAT *xst);
 int set_stat_xattr(const char *fname, struct file_struct *file, mode_t new_mode);
 int x_stat(const char *fname, STRUCT_STAT *fst, STRUCT_STAT *xst);
 int x_lstat(const char *fname, STRUCT_STAT *fst, STRUCT_STAT *xst);
 int x_fstat(int fd, STRUCT_STAT *fst, STRUCT_STAT *xst);
 int sys_gettimeofday(struct timeval *tv);
+char *do_big_num(int64 num, int human_flag, const char *fract);
+char *do_big_dnum(double dnum, int human_flag, int decimal_digits);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/receiver.c	2011-03-27 01:01:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/receiver.c	2013-09-29 01:40:27.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Routines only used by the receiving process.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,19 +17,18 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "inums.h"
 
-extern int verbose;
 extern int dry_run;
 extern int do_xfers;
 extern int am_root;
 extern int am_server;
-extern int do_progress;
 extern int inc_recurse;
 extern int log_before_transfer;
 extern int stdout_format_has_i;
 extern int logfile_format_has_i;
 extern int csum_length;
 extern int read_batch;
@@ -43,32 +42,38 @@
 extern int basis_dir_cnt;
 extern int make_backups;
 extern int cleanup_got_literal;
 extern int remove_source_files;
 extern int append_mode;
 extern int sparse_files;
+extern int preallocate_files;
 extern int keep_partial;
+extern int checksum_len;
 extern int checksum_seed;
 extern int inplace;
+extern int allowed_lull;
 extern int delay_updates;
 extern mode_t orig_umask;
 extern struct stats stats;
 extern char *tmpdir;
 extern char *partial_dir;
 extern char *basis_dir[MAX_BASIS_DIRS+1];
+extern char sender_file_sum[MAX_DIGEST_LEN];
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
-extern struct filter_list_struct daemon_filter_list;
+extern filter_rule_list daemon_filter_list;
 
 static struct bitbag *delayed_bits = NULL;
 static int phase = 0, redoing = 0;
 static flist_ndx_list batch_redo_list;
 /* We're either updating the basis file or an identical copy: */
 static int updating_basis_or_equiv;
 
 #define TMPNAME_SUFFIX ".XXXXXX"
 #define TMPNAME_SUFFIX_LEN ((int)sizeof TMPNAME_SUFFIX - 1)
+#define MAX_UNIQUE_NUMBER 999999
+#define MAX_UNIQUE_LOOP 100
 
 /* get_tmpname() - create a tmp filename for a given filename
  *
  * If a tmpdir is defined, use that as the directory to put it in.  Otherwise,
  * the tmp filename is in the same directory as the given name.  Note that
  * there may be no directory at all in the given name!
@@ -76,18 +81,23 @@
  * The tmp filename is basically the given filename with a dot prepended, and
  * .XXXXXX appended (for mkstemp() to put its unique gunk in).  We take care
  * to not exceed either the MAXPATHLEN or NAME_MAX, especially the last, as
  * the basename basically becomes 8 characters longer.  In such a case, the
  * original name is shortened sufficiently to make it all fit.
  *
+ * If the make_unique arg is True, the XXXXXX string is replaced with a unique
+ * string that doesn't exist at the time of the check.  This is intended to be
+ * used for creating hard links, symlinks, devices, and special files, since
+ * normal files should be handled by mkstemp() for safety.
+ *
  * Of course, the only reason the file is based on the original name is to
  * make it easier to figure out what purpose a temp file is serving when a
  * transfer is in progress. */
-int get_tmpname(char *fnametmp, const char *fname)
+int get_tmpname(char *fnametmp, const char *fname, BOOL make_unique)
 {
-	int maxname, added, length = 0;
+	int maxname, length = 0;
 	const char *f;
 	char *suf;
 
 	if (tmpdir) {
 		/* Note: this can't overflow, so the return value is safe */
 		length = strlcpy(fnametmp, tmpdir, MAXPATHLEN - 2);
@@ -100,39 +110,71 @@
 			length = f - fname;
 			/* copy up to and including the slash */
 			strlcpy(fnametmp, fname, length + 1);
 		}
 	} else
 		f = fname;
+	if (*f == '.') /* avoid an extra leading dot for OS X's sake */
+		f++;
 	fnametmp[length++] = '.';
 
 	/* The maxname value is bufsize, and includes space for the '\0'.
 	 * NAME_MAX needs an extra -1 for the name's leading dot. */
 	maxname = MIN(MAXPATHLEN - length - TMPNAME_SUFFIX_LEN,
 		      NAME_MAX - 1 - TMPNAME_SUFFIX_LEN);
 
-	if (maxname < 1) {
+	if (maxname < 0) {
 		rprintf(FERROR_XFER, "temporary filename too long: %s\n", fname);
 		fnametmp[0] = '\0';
 		return 0;
 	}
 
-	added = strlcpy(fnametmp + length, f, maxname);
-	if (added >= maxname)
-		added = maxname - 1;
-	suf = fnametmp + length + added;
-
-	/* Trim any dangling high-bit chars if the first-trimmed char (if any) is
-	 * also a high-bit char, just in case we cut into a multi-byte sequence.
-	 * We are guaranteed to stop because of the leading '.' we added. */
-	if ((int)f[added] & 0x80) {
-		while ((int)suf[-1] & 0x80)
+	if (maxname) {
+		int added = strlcpy(fnametmp + length, f, maxname);
+		if (added >= maxname)
+			added = maxname - 1;
+		suf = fnametmp + length + added;
+
+		/* Trim any dangling high-bit chars if the first-trimmed char (if any) is
+		 * also a high-bit char, just in case we cut into a multi-byte sequence.
+		 * We are guaranteed to stop because of the leading '.' we added. */
+		if ((int)f[added] & 0x80) {
+			while ((int)suf[-1] & 0x80)
+				suf--;
+		}
+		/* trim one trailing dot before our suffix's dot */
+		if (suf[-1] == '.')
 			suf--;
-	}
+	} else
+		suf = fnametmp + length - 1; /* overwrite the leading dot with suffix's dot */
 
-	memcpy(suf, TMPNAME_SUFFIX, TMPNAME_SUFFIX_LEN+1);
+	if (make_unique) {
+		static unsigned counter_limit;
+		unsigned counter;
+
+		if (!counter_limit) {
+			counter_limit = (unsigned)getpid() + MAX_UNIQUE_LOOP;
+			if (counter_limit > MAX_UNIQUE_NUMBER || counter_limit < MAX_UNIQUE_LOOP)
+				counter_limit = MAX_UNIQUE_LOOP;
+		}
+		counter = counter_limit - MAX_UNIQUE_LOOP;
+
+		/* This doesn't have to be very good because we don't need
+		 * to worry about someone trying to guess the values:  all
+		 * a conflict will do is cause a device, special file, hard
+		 * link, or symlink to fail to be created.  Also: avoid
+		 * using mktemp() due to gcc's annoying warning. */
+		while (1) {
+			snprintf(suf, TMPNAME_SUFFIX_LEN+1, ".%d", counter);
+			if (access(fnametmp, 0) < 0)
+				break;
+			if (++counter >= counter_limit)
+				return 0;
+		}
+	} else
+		memcpy(suf, TMPNAME_SUFFIX, TMPNAME_SUFFIX_LEN+1);
 
 	return 1;
 }
 
 /* Opens a temporary file for writing.
  * Success: Writes name into fnametmp, returns fd.
@@ -140,13 +182,13 @@
  * Calling cleanup_set() is the caller's job. */
 int open_tmpfile(char *fnametmp, const char *fname, struct file_struct *file)
 {
 	int fd;
 	mode_t added_perms;
 
-	if (!get_tmpname(fnametmp, fname))
+	if (!get_tmpname(fnametmp, fname, False))
 		return -1;
 
 	if (am_root < 0) {
 		/* For --fake-super, the file must be useable by the copying
 		 * user, just like it would be for root. */
 		added_perms = S_IRUSR|S_IWUSR;
@@ -163,15 +205,15 @@
 
 #if 0
 	/* In most cases parent directories will already exist because their
 	 * information should have been previously transferred, but that may
 	 * not be the case with -R */
 	if (fd == -1 && relative_paths && errno == ENOENT
-	    && create_directory_path(fnametmp) == 0) {
+	 && make_path(fnametmp, MKP_SKIP_SLASH | MKP_DROP_NAME) == 0) {
 		/* Get back to name with XXXXXX in it. */
-		get_tmpname(fnametmp, fname);
+		get_tmpname(fnametmp, fname, False);
 		fd = do_mkstemp(fnametmp, (file->mode|added_perms) & INITACCESSPERMS);
 	}
 #endif
 
 	if (fd == -1) {
 		rsyserr(FERROR_XFER, errno, "mkstemp %s failed",
@@ -183,72 +225,90 @@
 }
 
 static int receive_data(int f_in, char *fname_r, int fd_r, OFF_T size_r,
 			const char *fname, int fd, OFF_T total_size)
 {
 	static char file_sum1[MAX_DIGEST_LEN];
-	static char file_sum2[MAX_DIGEST_LEN];
 	struct map_struct *mapbuf;
 	struct sum_struct sum;
-	int32 len, sum_len;
+	int32 len;
 	OFF_T offset = 0;
 	OFF_T offset2;
 	char *data;
 	int32 i;
 	char *map = NULL;
+#ifdef SUPPORT_PREALLOCATION
+#ifdef PREALLOCATE_NEEDS_TRUNCATE
+	OFF_T preallocated_len = 0;
+#endif
+
+	if (preallocate_files && fd != -1 && total_size > 0 && (!inplace || total_size > size_r)) {
+		/* Try to preallocate enough space for file's eventual length.  Can
+		 * reduce fragmentation on filesystems like ext4, xfs, and NTFS. */
+		if (do_fallocate(fd, 0, total_size) == 0) {
+#ifdef PREALLOCATE_NEEDS_TRUNCATE
+			preallocated_len = total_size;
+#endif
+		} else
+			rsyserr(FWARNING, errno, "do_fallocate %s", full_fname(fname));
+	}
+#endif
 
 	read_sum_head(f_in, &sum);
 
 	if (fd_r >= 0 && size_r > 0) {
 		int32 read_size = MAX(sum.blength * 2, 16*1024);
 		mapbuf = map_file(fd_r, size_r, read_size, sum.blength);
-		if (verbose > 2) {
-			rprintf(FINFO, "recv mapped %s of size %.0f\n",
-				fname_r, (double)size_r);
+		if (DEBUG_GTE(DELTASUM, 2)) {
+			rprintf(FINFO, "recv mapped %s of size %s\n",
+				fname_r, big_num(size_r));
 		}
 	} else
 		mapbuf = NULL;
 
 	sum_init(checksum_seed);
 
 	if (append_mode > 0) {
 		OFF_T j;
 		sum.flength = (OFF_T)sum.count * sum.blength;
 		if (sum.remainder)
 			sum.flength -= sum.blength - sum.remainder;
-		if (append_mode == 2) {
+		if (append_mode == 2 && mapbuf) {
 			for (j = CHUNK_SIZE; j < sum.flength; j += CHUNK_SIZE) {
-				if (do_progress)
+				if (INFO_GTE(PROGRESS, 1))
 					show_progress(offset, total_size);
 				sum_update(map_ptr(mapbuf, offset, CHUNK_SIZE),
 					   CHUNK_SIZE);
 				offset = j;
 			}
 			if (offset < sum.flength) {
 				int32 len = (int32)(sum.flength - offset);
-				if (do_progress)
+				if (INFO_GTE(PROGRESS, 1))
 					show_progress(offset, total_size);
 				sum_update(map_ptr(mapbuf, offset, len), len);
 			}
 		}
 		offset = sum.flength;
 		if (fd != -1 && (j = do_lseek(fd, offset, SEEK_SET)) != offset) {
-			rsyserr(FERROR_XFER, errno, "lseek of %s returned %.0f, not %.0f",
-				full_fname(fname), (double)j, (double)offset);
+			rsyserr(FERROR_XFER, errno, "lseek of %s returned %s, not %s",
+				full_fname(fname), big_num(j), big_num(offset));
 			exit_cleanup(RERR_FILEIO);
 		}
 	}
 
 	while ((i = recv_token(f_in, &data)) != 0) {
-		if (do_progress)
+		if (INFO_GTE(PROGRESS, 1))
 			show_progress(offset, total_size);
 
+		if (allowed_lull)
+			maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH | MSK_ACTIVE_RECEIVER);
+
 		if (i > 0) {
-			if (verbose > 3) {
-				rprintf(FINFO,"data recv %d at %.0f\n",
-					i,(double)offset);
+			if (DEBUG_GTE(DELTASUM, 3)) {
+				rprintf(FINFO,"data recv %d at %s\n",
+					i, big_num(offset));
 			}
 
 			stats.literal_data += i;
 			cleanup_got_literal = 1;
 
 			sum_update(data, i);
@@ -264,16 +324,16 @@
 		len = sum.blength;
 		if (i == (int)sum.count-1 && sum.remainder != 0)
 			len = sum.remainder;
 
 		stats.matched_data += len;
 
-		if (verbose > 3) {
+		if (DEBUG_GTE(DELTASUM, 3)) {
 			rprintf(FINFO,
-				"chunk[%d] of size %ld at %.0f offset=%.0f%s\n",
-				i, (long)len, (double)offset2, (double)offset,
+				"chunk[%d] of size %ld at %s offset=%s%s\n",
+				i, (long)len, big_num(offset2), big_num(offset),
 				updating_basis_or_equiv && offset == offset2 ? " (seek)" : "");
 		}
 
 		if (mapbuf) {
 			map = map_ptr(mapbuf,offset2,len);
 
@@ -286,15 +346,15 @@
 				OFF_T pos;
 				if (flush_write_file(fd) < 0)
 					goto report_write_error;
 				offset += len;
 				if ((pos = do_lseek(fd, len, SEEK_CUR)) != offset) {
 					rsyserr(FERROR_XFER, errno,
-						"lseek of %s returned %.0f, not %.0f",
+						"lseek of %s returned %s, not %s",
 						full_fname(fname),
-						(double)pos, (double)offset);
+						big_num(pos), big_num(offset));
 					exit_cleanup(RERR_FILEIO);
 				}
 				continue;
 			}
 		}
 		if (fd != -1 && map && write_file(fd, map, len) != (int)len)
@@ -303,37 +363,45 @@
 	}
 
 	if (flush_write_file(fd) < 0)
 		goto report_write_error;
 
 #ifdef HAVE_FTRUNCATE
-	if (inplace && fd != -1 && do_ftruncate(fd, offset) < 0) {
+	/* inplace: New data could be shorter than old data.
+	 * preallocate_files: total_size could have been an overestimate.
+	 *     Cut off any extra preallocated zeros from dest file. */
+	if ((inplace
+#ifdef PREALLOCATE_NEEDS_TRUNCATE
+	  || preallocated_len > offset
+#endif
+	  ) && fd != -1 && do_ftruncate(fd, offset) < 0) {
 		rsyserr(FERROR_XFER, errno, "ftruncate failed on %s",
 			full_fname(fname));
 	}
 #endif
 
-	if (do_progress)
+	if (INFO_GTE(PROGRESS, 1))
 		end_progress(total_size);
 
 	if (fd != -1 && offset > 0 && sparse_end(fd, offset) != 0) {
 	    report_write_error:
 		rsyserr(FERROR_XFER, errno, "write failed on %s",
 			full_fname(fname));
 		exit_cleanup(RERR_FILEIO);
 	}
 
-	sum_len = sum_end(file_sum1);
+	if (sum_end(file_sum1) != checksum_len)
+		overflow_exit("checksum_len"); /* Impossible... */
 
 	if (mapbuf)
 		unmap_file(mapbuf);
 
-	read_buf(f_in, file_sum2, sum_len);
-	if (verbose > 2)
+	read_buf(f_in, sender_file_sum, checksum_len);
+	if (DEBUG_GTE(DELTASUM, 2))
 		rprintf(FINFO,"got file_sum\n");
-	if (fd != -1 && memcmp(file_sum1, file_sum2, sum_len) != 0)
+	if (fd != -1 && memcmp(file_sum1, sender_file_sum, checksum_len) != 0)
 		return 0;
 	return 1;
 }
 
 
 static void discard_receive_data(int f_in, OFF_T length)
@@ -347,15 +415,15 @@
 	int ndx;
 
 	for (ndx = -1; (ndx = bitbag_next_bit(delayed_bits, ndx)) >= 0; ) {
 		struct file_struct *file = cur_flist->files[ndx];
 		fname = local_name ? local_name : f_name(file, NULL);
 		if ((partialptr = partial_dir_fname(fname)) != NULL) {
-			if (make_backups > 0 && !make_backup(fname))
+			if (make_backups > 0 && !make_backup(fname, False))
 				continue;
-			if (verbose > 2) {
+			if (DEBUG_GTE(RECV, 1)) {
 				rprintf(FINFO, "renaming %s to %s\n",
 					partialptr, fname);
 			}
 			/* We don't use robust_rename() here because the
 			 * partial-dir must be on the same drive. */
 			if (do_rename(partialptr, fname) < 0) {
@@ -400,22 +468,24 @@
 		return 1;
 	}
 
 	return 0;
 }
 
-static int gen_wants_ndx(int desired_ndx)
+static int gen_wants_ndx(int desired_ndx, int flist_num)
 {
 	static int next_ndx = -1;
 	static int done_cnt = 0;
 	static BOOL got_eof = False;
-	int flist_num = first_flist->flist_num;
 
 	if (got_eof)
 		return 0;
 
+	/* TODO: integrate gen-reading I/O into perform_io() so this is not needed? */
+	io_flush(FULL_FLUSH);
+
 	while (next_ndx < desired_ndx) {
 		if (inc_recurse && flist_num <= done_cnt)
 			return 0;
 		if (next_ndx >= 0)
 			no_batched_update(next_ndx, False);
 		if ((next_ndx = read_int(batch_gen_fd)) < 0) {
@@ -437,86 +507,109 @@
 }
 
 /**
  * main routine for receiver process.
  *
  * Receiver process runs on the same host as the generator process. */
-int recv_files(int f_in, char *local_name)
+int recv_files(int f_in, int f_out, char *local_name)
 {
 	int fd1,fd2;
 	STRUCT_STAT st;
 	int iflags, xlen;
 	char *fname, fbuf[MAXPATHLEN];
 	char xname[MAXPATHLEN];
 	char fnametmp[MAXPATHLEN];
 	char *fnamecmp, *partialptr;
 	char fnamecmpbuf[MAXPATHLEN];
 	uchar fnamecmp_type;
 	struct file_struct *file;
-	struct stats initial_stats;
 	int itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;
 	enum logcode log_code = log_before_transfer ? FLOG : FINFO;
 	int max_phase = protocol_version >= 29 ? 2 : 1;
 	int dflt_perms = (ACCESSPERMS & ~orig_umask);
 #ifdef SUPPORT_ACLS
 	const char *parent_dirname = "";
 #endif
 	int ndx, recv_ok;
 
-	if (verbose > 2)
+	if (DEBUG_GTE(RECV, 1))
 		rprintf(FINFO, "recv_files(%d) starting\n", cur_flist->used);
 
 	if (delay_updates)
 		delayed_bits = bitbag_create(cur_flist->used + 1);
 
 	while (1) {
 		cleanup_disable();
 
 		/* This call also sets cur_flist. */
-		ndx = read_ndx_and_attrs(f_in, &iflags, &fnamecmp_type,
+		ndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,
 					 xname, &xlen);
 		if (ndx == NDX_DONE) {
+			if (!am_server && INFO_GTE(PROGRESS, 2) && cur_flist) {
+				set_current_file_index(NULL, 0);
+				end_progress(0);
+			}
 			if (inc_recurse && first_flist) {
-				if (read_batch)
-					gen_wants_ndx(first_flist->used + first_flist->ndx_start);
+				if (read_batch) {
+					ndx = first_flist->used + first_flist->ndx_start;
+					gen_wants_ndx(ndx, first_flist->flist_num);
+				}
 				flist_free(first_flist);
 				if (first_flist)
 					continue;
-			} else if (read_batch && first_flist)
-				gen_wants_ndx(first_flist->used);
+			} else if (read_batch && first_flist) {
+				ndx = first_flist->used;
+				gen_wants_ndx(ndx, first_flist->flist_num);
+			}
 			if (++phase > max_phase)
 				break;
-			if (verbose > 2)
+			if (DEBUG_GTE(RECV, 1))
 				rprintf(FINFO, "recv_files phase=%d\n", phase);
 			if (phase == 2 && delay_updates)
 				handle_delayed_updates(local_name);
-			send_msg(MSG_DONE, "", 0, 0);
+			write_int(f_out, NDX_DONE);
 			continue;
 		}
 
 		if (ndx - cur_flist->ndx_start >= 0)
 			file = cur_flist->files[ndx - cur_flist->ndx_start];
 		else
 			file = dir_flist->files[cur_flist->parent_ndx];
 		fname = local_name ? local_name : f_name(file, fbuf);
 
-		if (verbose > 2)
+		if (DEBUG_GTE(RECV, 1))
 			rprintf(FINFO, "recv_files(%s)\n", fname);
 
 #ifdef SUPPORT_XATTRS
-		if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers)
+		if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers
+		 && (protocol_version < 31 || !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))
 			recv_xattr_request(file, f_in);
 #endif
 
 		if (!(iflags & ITEM_TRANSFER)) {
 			maybe_log_item(file, iflags, itemizing, xname);
 #ifdef SUPPORT_XATTRS
 			if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers
 			 && !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))
 				set_file_attrs(fname, file, NULL, fname, 0);
 #endif
+			if (iflags & ITEM_IS_NEW) {
+				stats.created_files++;
+				if (S_ISREG(file->mode)) {
+					/* Nothing further to count. */
+				} else if (S_ISDIR(file->mode))
+					stats.created_dirs++;
+#ifdef SUPPORT_LINKS
+				else if (S_ISLNK(file->mode))
+					stats.created_symlinks++;
+#endif
+				else if (IS_DEVICE(file->mode))
+					stats.created_devices++;
+				else
+					stats.created_specials++;
+			}
 			continue;
 		}
 		if (phase == 2) {
 			rprintf(FERROR,
 				"got transfer request in phase 2 [%s]\n",
 				who_am_i());
@@ -540,17 +633,19 @@
 				if (append_mode)
 					sparse_files = -sparse_files;
 				append_mode = -append_mode;
 				csum_length = SHORT_SUM_LENGTH;
 				redoing = 0;
 			}
+			if (iflags & ITEM_IS_NEW)
+				stats.created_files++;
 		}
 
-		if (!am_server && do_progress)
+		if (!am_server && INFO_GTE(PROGRESS, 1))
 			set_current_file_index(file, ndx);
-		stats.num_transferred_files++;
+		stats.xferred_files++;
 		stats.total_transferred_size += F_LENGTH(file);
 
 		cleanup_got_literal = 0;
 
 		if (daemon_filter_list.head
 		    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {
@@ -558,34 +653,39 @@
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		if (read_batch) {
 			int wanted = redoing
 				   ? we_want_redo(ndx)
-				   : gen_wants_ndx(ndx);
+				   : gen_wants_ndx(ndx, cur_flist->flist_num);
 			if (!wanted) {
 				rprintf(FINFO,
 					"(Skipping batched update for%s \"%s\")\n",
 					redoing ? " resend of" : "",
 					fname);
 				discard_receive_data(f_in, F_LENGTH(file));
 				file->flags |= FLAG_FILE_SENT;
 				continue;
 			}
 		}
 
+		if (!log_before_transfer)
+			remember_initial_stats();
+
 		if (!do_xfers) { /* log the transfer */
-			log_item(FCLIENT, file, &stats, iflags, NULL);
+			log_item(FCLIENT, file, iflags, NULL);
 			if (read_batch)
 				discard_receive_data(f_in, F_LENGTH(file));
 			continue;
 		}
 		if (write_batch < 0) {
-			log_item(FCLIENT, file, &stats, iflags, NULL);
+			log_item(FCLIENT, file, iflags, NULL);
 			if (!am_server)
 				discard_receive_data(f_in, F_LENGTH(file));
+			if (inc_recurse)
+				send_msg_int(MSG_SUCCESS, ndx);
 			continue;
 		}
 
 		partialptr = partial_dir ? partial_dir_fname(fname) : fname;
 
 		if (protocol_version >= 29) {
@@ -598,27 +698,32 @@
 				break;
 			case FNAMECMP_BACKUP:
 				fnamecmp = get_backup_name(fname);
 				break;
 			case FNAMECMP_FUZZY:
 				if (file->dirname) {
-					pathjoin(fnamecmpbuf, MAXPATHLEN,
-						 file->dirname, xname);
+					pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, file->dirname, xname);
 					fnamecmp = fnamecmpbuf;
 				} else
 					fnamecmp = xname;
 				break;
 			default:
-				if (fnamecmp_type >= basis_dir_cnt) {
+				if (fnamecmp_type > FNAMECMP_FUZZY && fnamecmp_type-FNAMECMP_FUZZY <= basis_dir_cnt) {
+					fnamecmp_type -= FNAMECMP_FUZZY + 1;
+					if (file->dirname) {
+						stringjoin(fnamecmpbuf, sizeof fnamecmpbuf,
+							   basis_dir[fnamecmp_type], "/", file->dirname, "/", xname, NULL);
+					} else
+						pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], xname);
+				} else if (fnamecmp_type >= basis_dir_cnt) {
 					rprintf(FERROR,
 						"invalid basis_dir index: %d.\n",
 						fnamecmp_type);
 					exit_cleanup(RERR_PROTOCOL);
-				}
-				pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
-					 basis_dir[fnamecmp_type], fname);
+				} else
+					pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], fname);
 				fnamecmp = fnamecmpbuf;
 				break;
 			}
 			if (!fnamecmp || (daemon_filter_list.head
 			  && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {
 				fnamecmp = fname;
@@ -635,14 +740,12 @@
 			} else if (partial_dir && partialptr)
 				fnamecmp = partialptr;
 			else
 				fnamecmp = fname;
 		}
 
-		initial_stats = stats;
-
 		/* open the file */
 		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 
 		if (fd1 == -1 && protocol_version < 29) {
 			if (fnamecmp != fname) {
 				fnamecmp = fname;
@@ -713,13 +816,14 @@
 		/* We now check to see if we are writing the file "inplace" */
 		if (inplace)  {
 			fd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);
 			if (fd2 == -1) {
 				rsyserr(FERROR_XFER, errno, "open %s failed",
 					full_fname(fname));
-			}
+			} else if (updating_basis_or_equiv)
+				cleanup_set(NULL, NULL, file, fd1, fd2);
 		} else {
 			fd2 = open_tmpfile(fnametmp, fname, file);
 			if (fd2 != -1)
 				cleanup_set(fnametmp, partialptr, file, fd1, fd2);
 		}
 
@@ -731,21 +835,21 @@
 				send_msg_int(MSG_NO_SEND, ndx);
 			continue;
 		}
 
 		/* log the transfer */
 		if (log_before_transfer)
-			log_item(FCLIENT, file, &initial_stats, iflags, NULL);
-		else if (!am_server && verbose && do_progress)
+			log_item(FCLIENT, file, iflags, NULL);
+		else if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))
 			rprintf(FINFO, "%s\n", fname);
 
 		/* recv file data */
 		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
 				       fname, fd2, F_LENGTH(file));
 
-		log_item(log_code, file, &initial_stats, iflags, NULL);
+		log_item(log_code, file, iflags, NULL);
 
 		if (fd1 != -1)
 			close(fd1);
 		if (close(fd2) < 0) {
 			rsyserr(FERROR, errno, "close failed on %s",
 				full_fname(fnametmp));
@@ -793,13 +897,13 @@
 			if (remove_source_files || inc_recurse
 			 || (preserve_hard_links && F_IS_HLINKED(file)))
 				send_msg_int(MSG_SUCCESS, ndx);
 			break;
 		case 0: {
 			enum logcode msgtype = redoing ? FERROR_XFER : FWARNING;
-			if (msgtype == FERROR_XFER || verbose) {
+			if (msgtype == FERROR_XFER || INFO_GTE(NAME, 1)) {
 				char *errstr, *redostr, *keptstr;
 				if (!(keep_partial && partialptr) && !inplace)
 					keptstr = "discarded";
 				else if (partial_dir)
 					keptstr = "put into partial-dir";
 				else
@@ -835,11 +939,11 @@
 	if (make_backups < 0)
 		make_backups = -make_backups;
 
 	if (phase == 2 && delay_updates) /* for protocol_version < 29 */
 		handle_delayed_updates(local_name);
 
-	if (verbose > 2)
+	if (DEBUG_GTE(RECV, 1))
 		rprintf(FINFO,"recv_files finished\n");
 
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rounding.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rounding.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rounding.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rounding.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,10 +1,10 @@
 /*
  * A pre-compilation helper program to aid in the creation of rounding.h.
  *
- * Copyright (C) 2007-2009 Wayne Davison
+ * Copyright (C) 2007-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsync.1	2011-09-24 00:42:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsync.1	2013-09-29 11:01:03.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsync" "1" "23 Sep 2011" "" ""
+.TH "rsync" "1" "28 Sep 2013" "" ""
 .SH "NAME"
 rsync \- a fast, versatile, remote (and local) file\-copying tool
 .SH "SYNOPSIS"
 
 .PP 
 .nf 
@@ -404,12 +404,15 @@
 .PP 
 Here is a short summary of the options available in rsync. Please refer
 to the detailed description below for a complete description.  
 .nf 
 
  \-v, \-\-verbose               increase verbosity
+     \-\-info=FLAGS            fine\-grained informational verbosity
+     \-\-debug=FLAGS           fine\-grained debug verbosity
+     \-\-msgs2stderr           special output handling for debugging
  \-q, \-\-quiet                 suppress non\-error messages
      \-\-no\-motd               suppress daemon\-mode MOTD (see caveat)
  \-c, \-\-checksum              skip based on checksum, not mod\-time & size
  \-a, \-\-archive               archive mode; equals \-rlptgoD (no \-H,\-A,\-X)
      \-\-no\-OPTION             turn off an implied OPTION (e.g. \-\-no\-D)
  \-r, \-\-recursive             recurse into directories
@@ -424,12 +427,13 @@
      \-\-append\-verify         \-\-append w/old data in file checksum
  \-d, \-\-dirs                  transfer directories without recursing
  \-l, \-\-links                 copy symlinks as symlinks
  \-L, \-\-copy\-links            transform symlink into referent file/dir
      \-\-copy\-unsafe\-links     only \(dq\&unsafe\(dq\& symlinks are transformed
      \-\-safe\-links            ignore symlinks that point outside the tree
+     \-\-munge\-links           munge symlinks to make them safer
  \-k, \-\-copy\-dirlinks         transform symlink to dir into referent dir
  \-K, \-\-keep\-dirlinks         treat symlinked dir on receiver as dir
  \-H, \-\-hard\-links            preserve hard links
  \-p, \-\-perms                 preserve permissions
  \-E, \-\-executability         preserve executability
      \-\-chmod=CHMOD           affect file and/or directory permissions
@@ -439,15 +443,17 @@
  \-g, \-\-group                 preserve group
      \-\-devices               preserve device files (super\-user only)
      \-\-specials              preserve special files
  \-D                          same as \-\-devices \-\-specials
  \-t, \-\-times                 preserve modification times
  \-O, \-\-omit\-dir\-times        omit directories from \-\-times
+ \-J, \-\-omit\-link\-times       omit symlinks from \-\-times
      \-\-super                 receiver attempts super\-user activities
      \-\-fake\-super            store/recover privileged attrs using xattrs
  \-S, \-\-sparse                handle sparse files efficiently
+     \-\-preallocate           allocate dest files before writing
  \-n, \-\-dry\-run               perform a trial run with no changes made
  \-W, \-\-whole\-file            copy files whole (w/o delta\-xfer algorithm)
  \-x, \-\-one\-file\-system       don'\&t cross filesystem boundaries
  \-B, \-\-block\-size=SIZE       force a fixed checksum block\-size
  \-e, \-\-rsh=COMMAND           specify the remote shell to use
      \-\-rsync\-path=PROGRAM    specify the rsync to run on remote machine
@@ -458,22 +464,27 @@
      \-\-delete                delete extraneous files from dest dirs
      \-\-delete\-before         receiver deletes before xfer, not during
      \-\-delete\-during         receiver deletes during the transfer
      \-\-delete\-delay          find deletions during, delete after
      \-\-delete\-after          receiver deletes after transfer, not during
      \-\-delete\-excluded       also delete excluded files from dest dirs
+     \-\-ignore\-missing\-args   ignore missing source args without error
+     \-\-delete\-missing\-args   delete missing source args from destination
      \-\-ignore\-errors         delete even if there are I/O errors
      \-\-force                 force deletion of dirs even if not empty
      \-\-max\-delete=NUM        don'\&t delete more than NUM files
      \-\-max\-size=SIZE         don'\&t transfer any file larger than SIZE
      \-\-min\-size=SIZE         don'\&t transfer any file smaller than SIZE
      \-\-partial               keep partially transferred files
      \-\-partial\-dir=DIR       put a partially transferred file into DIR
      \-\-delay\-updates         put all updated files into place at end
  \-m, \-\-prune\-empty\-dirs      prune empty directory chains from file\-list
      \-\-numeric\-ids           don'\&t map uid/gid values by user/group name
+     \-\-usermap=STRING        custom username mapping
+     \-\-groupmap=STRING       custom groupname mapping
+     \-\-chown=USER:GROUP      simple username/groupname mapping
      \-\-timeout=SECONDS       set I/O timeout in seconds
      \-\-contimeout=SECONDS    set daemon connection timeout in seconds
  \-I, \-\-ignore\-times          don'\&t skip files that match size and time
      \-\-size\-only             skip files that match in size
      \-\-modify\-window=NUM     compare mod\-times with reduced accuracy
  \-T, \-\-temp\-dir=DIR          create temporary files in directory DIR
@@ -496,24 +507,26 @@
  \-0, \-\-from0                 all *from/filter files are delimited by 0s
  \-s, \-\-protect\-args          no space\-splitting; wildcard chars only
      \-\-address=ADDRESS       bind address for outgoing socket to daemon
      \-\-port=PORT             specify double\-colon alternate port number
      \-\-sockopts=OPTIONS      specify custom TCP options
      \-\-blocking\-io           use blocking I/O for the remote shell
+     \-\-outbuf=N|L|B          set out buffering to None, Line, or Block
      \-\-stats                 give some file\-transfer stats
  \-8, \-\-8\-bit\-output          leave high\-bit chars unescaped in output
  \-h, \-\-human\-readable        output numbers in a human\-readable format
      \-\-progress              show progress during transfer
  \-P                          same as \-\-partial \-\-progress
  \-i, \-\-itemize\-changes       output a change\-summary for all updates
+ \-M, \-\-remote\-option=OPTION  send OPTION to the remote side only
      \-\-out\-format=FORMAT     output updates using the specified FORMAT
      \-\-log\-file=FILE         log what we'\&re doing to the specified FILE
      \-\-log\-file\-format=FMT   log updates using the specified FMT
      \-\-password\-file=FILE    read daemon\-access password from FILE
      \-\-list\-only             list the files instead of copying them
-     \-\-bwlimit=KBPS          limit I/O bandwidth; KBytes per second
+     \-\-bwlimit=RATE          limit socket I/O bandwidth
      \-\-write\-batch=FILE      write a batched update to FILE
      \-\-only\-write\-batch=FILE like \-\-write\-batch but w/o updating dest
      \-\-read\-batch=FILE       read a batched update from FILE
      \-\-protocol=NUM          force an older protocol version to be used
      \-\-iconv=CONVERT_SPEC    request charset conversion of filenames
      \-\-checksum\-seed=NUM     set block/file checksum seed (advanced)
@@ -527,14 +540,15 @@
 Rsync can also be run as a daemon, in which case the following options are
 accepted: 
 .nf 
 
      \-\-daemon                run as an rsync daemon
      \-\-address=ADDRESS       bind to the specified address
-     \-\-bwlimit=KBPS          limit I/O bandwidth; KBytes per second
+     \-\-bwlimit=RATE          limit socket I/O bandwidth
      \-\-config=FILE           specify alternate rsyncd.conf file
+ \-M, \-\-dparam=OVERRIDE       override global daemon config parameter
      \-\-no\-detach             do not detach from the parent
      \-\-port=PORT             listen on alternate port number
      \-\-log\-file=FILE         override the \(dq\&log file\(dq\& setting
      \-\-log\-file\-format=FMT   override the \(dq\&log format\(dq\& setting
      \-\-sockopts=OPTIONS      specify custom TCP options
  \-v, \-\-verbose               increase verbosity
@@ -574,20 +588,80 @@
 single \fB\-v\fP will give you information about what files are being
 transferred and a brief summary at the end. Two \fB\-v\fP options will give you
 information on what files are being skipped and slightly more
 information at the end. More than two \fB\-v\fP options should only be used if
 you are debugging rsync.
 .IP 
-Note that the names of the transferred files that are output are done using
-a default \fB\-\-out\-format\fP of \(dq\&%n%L\(dq\&, which tells you just the name of the
-file and, if the item is a link, where it points.  At the single \fB\-v\fP
-level of verbosity, this does not mention when a file gets its attributes
-changed.  If you ask for an itemized list of changed attributes (either
-\fB\-\-itemize\-changes\fP or adding \(dq\&%i\(dq\& to the \fB\-\-out\-format\fP setting), the
-output (on the client) increases to mention all items that are changed in
-any way.  See the \fB\-\-out\-format\fP option for more details.
+In a modern rsync, the \fB\-v\fP option is equivalent to the setting of groups
+of \fB\-\-info\fP and \fB\-\-debug\fP options.  You can choose to use these newer
+options in addition to, or in place of using \fB\-\-verbose\fP, as any
+fine\-grained settings override the implied settings of \fB\-v\fP.  Both
+\fB\-\-info\fP and \fB\-\-debug\fP have a way to ask for help that tells you
+exactly what flags are set for each increase in verbosity.
+.IP 
+.IP "\fB\-\-info=FLAGS\fP"
+This option lets you have fine\-grained control over the
+information
+output you want to see.  An individual flag name may be followed by a level
+number, with 0 meaning to silence that output, 1 being the default output
+level, and higher numbers increasing the output of that flag (for those
+that support higher levels).  Use
+\fB\-\-info=help\fP
+to see all the available flag names, what they output, and what flag names
+are added for each increase in the verbose level.  Some examples:
+.IP 
+.nf 
+    rsync \-a \-\-info=progress2 src/ dest/
+    rsync \-avv \-\-info=stats2,misc1,flist0 src/ dest/ 
+.fi 
+
+.IP 
+Note that \fB\-\-info=name\fP\(cq\&s output is affected by the \fB\-\-out\-format\fP and
+\fB\-\-itemize\-changes\fP (\fB\-i\fP) options.  See those options for more
+information on what is output and when.
+.IP 
+This option was added to 3.1.0, so an older rsync on the server side might
+reject your attempts at fine\-grained control (if one or more flags needed
+to be send to the server and the server was too old to understand them).
+.IP 
+.IP "\fB\-\-debug=FLAGS\fP"
+This option lets you have fine\-grained control over the debug
+output you want to see.  An individual flag name may be followed by a level
+number, with 0 meaning to silence that output, 1 being the default output
+level, and higher numbers increasing the output of that flag (for those
+that support higher levels).  Use
+\fB\-\-debug=help\fP
+to see all the available flag names, what they output, and what flag names
+are added for each increase in the verbose level.  Some examples:
+.IP 
+.nf 
+    rsync \-avvv \-\-debug=none src/ dest/
+    rsync \-avA \-\-del \-\-debug=del2,acl src/ dest/ 
+.fi 
+
+.IP 
+Note that some debug messages will only be output when \fB\-\-msgs2stderr\fP is
+specified, especially those pertaining to I/O and buffer debugging.
+.IP 
+This option was added to 3.1.0, so an older rsync on the server side might
+reject your attempts at fine\-grained control (if one or more flags needed
+to be send to the server and the server was too old to understand them).
+.IP 
+.IP "\fB\-\-msgs2stderr\fP"
+This option changes rsync to send all its output
+directly to stderr rather than to send messages to the client side via the
+protocol (which normally outputs info messages via stdout).  This is mainly
+intended for debugging in order to avoid changing the data sent via the
+protocol, since the extra protocol data can change what is being tested.
+Keep in mind that a daemon connection does not have a stderr channel to send
+messages back to the client side, so if you are doing any daemon\-transfer
+debugging using this option, you should start up a daemon using \fB\-\-no\-detach\fP
+so that you can see the stderr output on the daemon side.
+.IP 
+This option has the side\-effect of making stderr output get line\-buffered so
+that the merging of the output of 3 programs happens in a more readable manner.
 .IP 
 .IP "\fB\-q, \-\-quiet\fP"
 This option decreases the amount of information you
 are given during the transfer, notably suppressing information messages
 from the remote server. This option is useful when invoking rsync from
 cron.
@@ -963,12 +1037,32 @@
 .IP "\fB\-\-safe\-links\fP"
 This tells rsync to ignore any symbolic links
 which point outside the copied tree. All absolute symlinks are
 also ignored. Using this option in conjunction with \fB\-\-relative\fP may
 give unexpected results.
 .IP 
+.IP "\fB\-\-munge\-links\fP"
+This option tells rsync to (1) modify all symlinks on
+the receiving side in a way that makes them unusable but recoverable (see
+below), or (2) to unmunge symlinks on the sending side that had been stored in
+a munged state.  This is useful if you don\(cq\&t quite trust the source of the data
+to not try to slip in a symlink to a unexpected place.
+.IP 
+The way rsync disables the use of symlinks is to prefix each one with the
+string \(dq\&/rsyncd\-munged/\(dq\&.  This prevents the links from being used as long as
+that directory does not exist.  When this option is enabled, rsync will refuse
+to run if that path is a directory or a symlink to a directory.
+.IP 
+The option only affects the client side of the transfer, so if you need it to
+affect the server, specify it via \fB\-\-remote\-option\fP.  (Note that in a local
+transfer, the client side is the sender.)
+.IP 
+This option has no affect on a daemon, since the daemon configures whether it
+wants munged symlinks via its \(dq\&munge symlinks\(dq\& parameter.  See also the
+\(dq\&munge\-symlinks\(dq\& perl script in the support directory of the source code.
+.IP 
 .IP "\fB\-k, \-\-copy\-dirlinks\fP"
 This option causes the sending side to treat
 a symlink to a directory as though it were a real directory.  This is
 useful if you don\(cq\&t want symlinks to non\-directories to be affected, as
 they would be using \fB\-\-copy\-links\fP.
 .IP 
@@ -1179,12 +1273,19 @@
 .IP 
 .RS 
 \-\-chmod=Dg+s,ug+w,Fo\-w,+X
 .RE
 
 .IP 
+Using octal mode numbers is also allowed:
+.IP 
+.RS 
+\-\-chmod=D2775,F664
+.RE
+
+.IP 
 It is also legal to specify multiple \fB\-\-chmod\fP options, as each
 additional option is just appended to the list of changes to make.
 .IP 
 See the \fB\-\-perms\fP and \fB\-\-executability\fP options for how the resulting
 permission value can be applied to the files in the transfer.
 .IP 
@@ -1238,12 +1339,16 @@
 .IP "\fB\-O, \-\-omit\-dir\-times\fP"
 This tells rsync to omit directories when
 it is preserving modification times (see \fB\-\-times\fP).  If NFS is sharing
 the directories on the receiving side, it is a good idea to use \fB\-O\fP.
 This option is inferred if you use \fB\-\-backup\fP without \fB\-\-backup\-dir\fP.
 .IP 
+.IP "\fB\-J, \-\-omit\-link\-times\fP"
+This tells rsync to omit symlinks when
+it is preserving modification times (see \fB\-\-times\fP).
+.IP 
 .IP "\fB\-\-super\fP"
 This tells the receiving side to attempt super\-user
 activities even if the receiving rsync wasn\(cq\&t run by the super\-user.  These
 activities include: preserving users via the \fB\-\-owner\fP option, preserving
 all groups (not just the current user\(cq\&s groups) via the \fB\-\-groups\fP
 option, and copying devices via the \fB\-\-devices\fP option.  This is useful
@@ -1266,35 +1371,47 @@
 extended attributes (if \fB\-\-xattrs\fP was specified).
 .IP 
 This is a good way to backup data without using a super\-user, and to store
 ACLs from incompatible systems.
 .IP 
 The \fB\-\-fake\-super\fP option only affects the side where the option is used.
-To affect the remote side of a remote\-shell connection, specify an rsync
-path:
+To affect the remote side of a remote\-shell connection, use the
+\fB\-\-remote\-option\fP (\fB\-M\fP) option:
 .IP 
 .RS 
-\f(CW  rsync \-av \-\-rsync\-path=\(dq\&rsync \-\-fake\-super\(dq\& /src/ host:/dest/\fP
+\f(CW  rsync \-av \-M\-\-fake\-super /src/ host:/dest/\fP
 .RE
 
 .IP 
-Since there is only one \(dq\&side\(dq\& in a local copy, this option affects both
-the sending and receiving of files.  You\(cq\&ll need to specify a copy using
-\(dq\&localhost\(dq\& if you need to avoid this, possibly using the \(dq\&lsh\(dq\& shell
-script (from the support directory) as a substitute for an actual remote
-shell (see \fB\-\-rsh\fP).
+For a local copy, this option affects both the source and the destination.
+If you wish a local copy to enable this option just for the destination
+files, specify \fB\-M\-\-fake\-super\fP.  If you wish a local copy to enable
+this option just for the source files, combine \fB\-\-fake\-super\fP with
+\fB\-M\-\-super\fP.
 .IP 
 This option is overridden by both \fB\-\-super\fP and \fB\-\-no\-super\fP.
 .IP 
 See also the \(dq\&fake super\(dq\& setting in the daemon\(cq\&s rsyncd.conf file.
 .IP 
 .IP "\fB\-S, \-\-sparse\fP"
 Try to handle sparse files efficiently so they take
 up less space on the destination.  Conflicts with \fB\-\-inplace\fP because it\(cq\&s
 not possible to overwrite data in a sparse fashion.
 .IP 
+.IP "\fB\-\-preallocate\fP"
+This tells the receiver to allocate each destination
+file to its eventual size before writing data to the file.  Rsync will only use
+the real filesystem\-level preallocation support provided by Linux\(cq\&s
+\fBfallocate\fP(2) system call or Cygwin\(cq\&s \fBposix_fallocate\fP(3), not the slow
+glibc implementation that writes a zero byte into each block.
+.IP 
+Without this option, larger files may not be entirely contiguous on the
+filesystem, but with this option rsync will probably copy more slowly.  If the
+destination is not an extent\-supporting filesystem (such as ext4, xfs, NTFS,
+etc.), this option may have no positive effect at all.
+.IP 
 .IP "\fB\-n, \-\-dry\-run\fP"
 This makes rsync perform a trial run that doesn\(cq\&t
 make any changes (and produces mostly the same output as a real run).  It
 is most commonly used in combination with the \fB\-v, \-\-verbose\fP and/or
 \fB\-i, \-\-itemize\-changes\fP options to see what an rsync command is going
 to do before one actually runs it.
@@ -1376,12 +1493,15 @@
 a file that is not yet fully written.  If you can\(cq\&t first write the files into
 a different directory, you should use a naming idiom that lets rsync avoid
 transferring files that are not yet finished (e.g. name the file \(dq\&foo.new\(dq\& when
 it is written, rename it to \(dq\&foo\(dq\& when it is done, and then use the option
 \fB\-\-exclude='\&*.new'\&\fP for the rsync transfer).
 .IP 
+Starting with 3.1.0, rsync will skip the sender\-side removal (and output an
+error) if the file\(cq\&s size or modify time has not stayed unchanged.
+.IP 
 .IP "\fB\-\-delete\fP"
 This tells rsync to delete extraneous files from the
 receiving side (ones that aren\(cq\&t on the sending side), but only for the
 directories that are being synchronized.  You must have asked rsync to
 send the whole directory (e.g. \(dq\&dir\(dq\& or \(dq\&dir/\(dq\&) without using a wildcard
 for the directory\(cq\&s contents (e.g. \(dq\&dir/*\(dq\&) since the wildcard is expanded
@@ -1465,12 +1585,31 @@
 delete any files on the receiving side that are excluded (see \fB\-\-exclude\fP).
 See the FILTER RULES section for a way to make individual exclusions behave
 this way on the receiver, and for a way to protect files from
 \fB\-\-delete\-excluded\fP.
 See \fB\-\-delete\fP (which is implied) for more details on file\-deletion.
 .IP 
+.IP "\fB\-\-ignore\-missing\-args\fP"
+When rsync is first processing the explicitly
+requested source files (e.g. command\-line arguments or \fB\-\-files\-from\fP
+entries), it is normally an error if the file cannot be found.  This option
+suppresses that error, and does not try to transfer the file.  This does not
+affect subsequent vanished\-file errors if a file was initially found to be
+present and later is no longer there.
+.IP 
+.IP "\fB\-\-delete\-missing\-args\fP"
+This option takes the behavior of (the implied)
+\fB\-\-ignore\-missing\-args\fP option a step farther:  each missing arg will become
+a deletion request of the corresponding destination file on the receiving side
+(should it exist).  If the destination file is a non\-empty directory, it will
+only be successfully deleted if \-\-force or \-\-delete are in effect.  Other than
+that, this option is independent of any other type of delete processing.
+.IP 
+The missing source files are represented by special file\-list entries which
+display as a \(dq\&*missing\(dq\& entry in the \fB\-\-list\-only\fP output.
+.IP 
 .IP "\fB\-\-ignore\-errors\fP"
 Tells \fB\-\-delete\fP to go ahead and delete files
 even when there are I/O errors.
 .IP 
 .IP "\fB\-\-force\fP"
 This option tells rsync to delete a non\-empty directory
@@ -1480,21 +1619,23 @@
 Note for older rsync versions: \fB\-\-force\fP used to still be required when
 using \fB\-\-delete\-after\fP, and it used to be non\-functional unless the
 \fB\-\-recursive\fP option was also enabled.
 .IP 
 .IP "\fB\-\-max\-delete=NUM\fP"
 This tells rsync not to delete more than NUM
-files or directories.  If that limit is exceeded, a warning is output
-and rsync exits with an error code of 25 (new for 3.0.0).
+files or directories.  If that limit is exceeded, all further deletions are
+skipped through the end of the transfer.  At the end, rsync outputs a warning
+(including a count of the skipped deletions) and exits with an error code
+of 25 (unless some more important error condition also occurred).
 .IP 
-Also new for version 3.0.0, you may specify \fB\-\-max\-delete=0\fP to be warned
+Beginning with version 3.0.0, you may specify \fB\-\-max\-delete=0\fP to be warned
 about any extraneous files in the destination without removing any of them.
 Older clients interpreted this as \(dq\&unlimited\(dq\&, so if you don\(cq\&t know what
 version the client is, you can use the less obvious \fB\-\-max\-delete=\-1\fP as
 a backward\-compatible way to specify that no deletions be allowed (though
-older versions didn\(cq\&t warn when the limit was exceeded).
+really old versions didn\(cq\&t warn when the limit was exceeded).
 .IP 
 .IP "\fB\-\-max\-size=SIZE\fP"
 This tells rsync to avoid transferring any
 file that is larger than the specified SIZE. The SIZE value can be
 suffixed with a string to indicate a size multiplier, and
 may be a fractional value (e.g. \(dq\&\fB\-\-max\-size=1.5m\fP\(dq\&).
@@ -1511,18 +1652,22 @@
 Finally, if the suffix ends in either \(dq\&+1\(dq\& or \(dq\&\-1\(dq\&, the value will
 be offset by one byte in the indicated direction.
 .IP 
 Examples: \-\-max\-size=1.5mb\-1 is 1499999 bytes, and \-\-max\-size=2g+1 is
 2147483649 bytes.
 .IP 
+Note that rsync versions prior to 3.1.0 did not allow \fB\-\-max\-size=0\fP.
+.IP 
 .IP "\fB\-\-min\-size=SIZE\fP"
 This tells rsync to avoid transferring any
 file that is smaller than the specified SIZE, which can help in not
 transferring small, junk files.
 See the \fB\-\-max\-size\fP option for a description of SIZE and other information.
 .IP 
+Note that rsync versions prior to 3.1.0 did not allow \fB\-\-min\-size=0\fP.
+.IP 
 .IP "\fB\-B, \-\-block\-size=BLOCKSIZE\fP"
 This forces the block size used in
 rsync\(cq\&s delta\-transfer algorithm to a fixed value.  It is normally selected based on
 the size of each file being updated.  See the technical report for details.
 .IP 
 .IP "\fB\-e, \-\-rsh=COMMAND\fP"
@@ -1577,12 +1722,49 @@
 .IP 
 .RS 
 \f(CW    rsync \-avR \-\-rsync\-path=\(dq\&cd /a/b && rsync\(dq\& host:c/d /e/\fP
 .RE
 
 .IP 
+.IP "\fB\-M, \-\-remote\-option=OPTION\fP"
+This option is used for more advanced
+situations where you want certain effects to be limited to one side of the
+transfer only.  For instance, if you want to pass \fB\-\-log\-file=FILE\fP and
+\fB\-\-fake\-super\fP to the remote system, specify it like this:
+.IP 
+.RS 
+\f(CW    rsync \-av \-M \-\-log\-file=foo \-M\-\-fake\-super src/ dest/\fP
+.RE
+
+.IP 
+If you want to have an option affect only the local side of a transfer when
+it normally affects both sides, send its negation to the remote side.  Like
+this:
+.IP 
+.RS 
+\f(CW    rsync \-av \-x \-M\-\-no\-x src/ dest/\fP
+.RE
+
+.IP 
+Be cautious using this, as it is possible to toggle an option that will cause
+rsync to have a different idea about what data to expect next over the socket,
+and that will make it fail in a cryptic fashion.
+.IP 
+Note that it is best to use a separate \fB\-\-remote\-option\fP for each option you
+want to pass.  This makes your useage compatible with the \fB\-\-protect\-args\fP
+option.  If that option is off, any spaces in your remote options will be split
+by the remote shell unless you take steps to protect them.
+.IP 
+When performing a local transfer, the \(dq\&local\(dq\& side is the sender and the
+\(dq\&remote\(dq\& side is the receiver.
+.IP 
+Note some versions of the popt option\-parsing library have a bug in them that
+prevents you from using an adjacent arg with an equal in it next to a short
+option letter (e.g. \f(CW\-M\-\-log\-file=/tmp/foo\fP.  If this bug affects your
+version of popt, you can use the version of popt that is included with rsync.
+.IP 
 .IP "\fB\-C, \-\-cvs\-exclude\fP"
 This is a useful shorthand for excluding a
 broad range of files that you often don\(cq\&t want to transfer between
 systems. It uses a similar algorithm to CVS to determine if
 a file should be ignored.
 .IP 
@@ -1773,12 +1955,26 @@
 .IP 
 If you use this option with \fB\-\-iconv\fP, the args related to the remote
 side will also be translated
 from the local to the remote character\-set.  The translation happens before
 wild\-cards are expanded.  See also the \fB\-\-files\-from\fP option.
 .IP 
+You may also control this option via the RSYNC_PROTECT_ARGS environment
+variable.  If this variable has a non\-zero value, this option will be enabled
+by default, otherwise it will be disabled by default.  Either state is
+overridden by a manually specified positive or negative version of this option
+(note that \fB\-\-no\-s\fP and \fB\-\-no\-protect\-args\fP are the negative versions).
+Since this option was first introduced in 3.0.0, you\(cq\&ll need to make sure it\(cq\&s
+disabled if you ever need to interact with a remote rsync that is older than
+that.
+.IP 
+Rsync can also be configured (at build time) to have this option enabled by
+default (with is overridden by both the environment and the command\-line).
+This option will eventually become a new default setting at some
+as\-yet\-undetermined point in the future.
+.IP 
 .IP "\fB\-T, \-\-temp\-dir=DIR\fP"
 This option instructs rsync to use DIR as a
 scratch directory when creating temporary copies of the files transferred
 on the receiving side.  The default behavior is to create each temporary
 file in the same directory as the associated destination file.
 .IP 
@@ -1813,36 +2009,46 @@
 This option tells rsync that it should look for a
 basis file for any destination file that is missing.  The current algorithm
 looks in the same directory as the destination file for either a file that
 has an identical size and modified\-time, or a similarly\-named file.  If
 found, rsync uses the fuzzy basis file to try to speed up the transfer.
 .IP 
+If the option is repeated, the fuzzy scan will also be done in any matching
+alternate destination directories that are specified via \fB\-\-compare\-dest\fP,
+\fB\-\-copy\-dest\fP, or \fB\-\-link\-dest\fP.
+.IP 
 Note that the use of the \fB\-\-delete\fP option might get rid of any potential
 fuzzy\-match files, so either use \fB\-\-delete\-after\fP or specify some
 filename exclusions if you need to prevent this.
 .IP 
 .IP "\fB\-\-compare\-dest=DIR\fP"
 This option instructs rsync to use \fIDIR\fP on
 the destination machine as an additional hierarchy to compare destination
 files against doing transfers (if the files are missing in the destination
 directory).  If a file is found in \fIDIR\fP that is identical to the
 sender\(cq\&s file, the file will NOT be transferred to the destination
 directory.  This is useful for creating a sparse backup of just files that
 have changed from an earlier backup.
+This option is typically used to copy into an empty (or newly created)
+directory.
 .IP 
 Beginning in version 2.6.4, multiple \fB\-\-compare\-dest\fP directories may be
 provided, which will cause rsync to search the list in the order specified
 for an exact match.
 If a match is found that differs only in attributes, a local copy is made
 and the attributes updated.
 If a match is not found, a basis file from one of the \fIDIR\fPs will be
 selected to try to speed up the transfer.
 .IP 
 If \fIDIR\fP is a relative path, it is relative to the destination directory.
 See also \fB\-\-copy\-dest\fP and \fB\-\-link\-dest\fP.
 .IP 
+NOTE: beginning with version 3.1.0, rsync will remove a file from a non\-empty
+destination hierarchy if an exact match is found in one of the compare\-dest
+hierarchies (making the end result more closely match a fresh copy).
+.IP 
 .IP "\fB\-\-copy\-dest=DIR\fP"
 This option behaves like \fB\-\-compare\-dest\fP, but
 rsync will also copy unchanged files found in \fIDIR\fP to the destination
 directory using a local copy.
 This is useful for doing transfers to a new destination while leaving
 existing files intact, and then doing a flash\-cutover when all files have
@@ -1879,16 +2085,17 @@
 If a match is found that differs only in attributes, a local copy is made
 and the attributes updated.
 If a match is not found, a basis file from one of the \fIDIR\fPs will be
 selected to try to speed up the transfer.
 .IP 
 This option works best when copying into an empty destination hierarchy, as
-rsync treats existing files as definitive (so it never looks in the link\-dest
-dirs when a destination file already exists), and as malleable (so it might
-change the attributes of a destination file, which affects all the hard\-linked
-versions).
+existing files may get their attributes tweaked, and that can affect alternate
+destination files via hard\-links.  Also, itemizing of changes can get a bit
+muddled.  Note that prior to version 3.1.0, an alternate\-directory exact match
+would never be found (nor linked into the destination) when a destination file
+already exists.
 .IP 
 Note that if you combine this option with \fB\-\-ignore\-times\fP, rsync will not
 link any files together because it only links identical files together as a
 substitute for transferring the file, never as an additional check after the
 file is updated.
 .IP 
@@ -1940,26 +2147,37 @@
 
 .IP 
 The default list of suffixes that will not be compressed is this (in this
 version of rsync):
 .IP 
 \fB7z\fP
+\fBace\fP
 \fBavi\fP
 \fBbz2\fP
 \fBdeb\fP
+\fBgpg\fP
 \fBgz\fP
 \fBiso\fP
 \fBjpeg\fP
 \fBjpg\fP
+\fBlz\fP
+\fBlzma\fP
+\fBlzo\fP
 \fBmov\fP
 \fBmp3\fP
 \fBmp4\fP
 \fBogg\fP
+\fBpng\fP
+\fBrar\fP
 \fBrpm\fP
+\fBrzip\fP
 \fBtbz\fP
 \fBtgz\fP
+\fBtlz\fP
+\fBtxz\fP
+\fBxz\fP
 \fBz\fP
 \fBzip\fP
 .IP 
 This list will be replaced by your \fB\-\-skip\-compress\fP list in all but one
 situation: a copy from a daemon rsync will add your skipped suffixes to
 its list of non\-compressing files (and its list may be configured to a
@@ -1979,12 +2197,71 @@
 on the destination system, then the numeric ID
 from the source system is used instead.  See also the comments on the
 \(dq\&use chroot\(dq\& setting in the rsyncd.conf manpage for information on how
 the chroot setting affects rsync\(cq\&s ability to look up the names of the
 users and groups and what you can do about it.
 .IP 
+.IP "\fB\-\-usermap=STRING, \-\-groupmap=STRING\fP"
+These options allow you to
+specify users and groups that should be mapped to other values by the
+receiving side.  The \fBSTRING\fP is one or more \fBFROM\fP:\fBTO\fP pairs of
+values separated by commas.  Any matching \fBFROM\fP value from the sender is
+replaced with a \fBTO\fP value from the receiver.  You may specify usernames
+or user IDs for the \fBFROM\fP and \fBTO\fP values, and the \fBFROM\fP value may
+also be a wild\-card string, which will be matched against the sender\(cq\&s
+names (wild\-cards do NOT match against ID numbers, though see below for
+why a \(cq\&*\(cq\& matches everything).  You may instead specify a range of ID
+numbers via an inclusive range: LOW\-HIGH.  For example:
+.IP 
+.nf 
+  \-\-usermap=0\-99:nobody,wayne:admin,*:normal \-\-groupmap=usr:1,1:usr
+.fi 
+
+.IP 
+The first match in the list is the one that is used.  You should specify
+all your user mappings using a single \fB\-\-usermap\fP option, and/or all
+your group mappings using a single \fB\-\-groupmap\fP option.
+.IP 
+Note that the sender\(cq\&s name for the 0 user and group are not transmitted
+to the receiver, so you should either match these values using a 0, or use
+the names in effect on the receiving side (typically \(dq\&root\(dq\&).  All other
+\fBFROM\fP names match those in use on the sending side.  All \fBTO\fP names
+match those in use on the receiving side.
+.IP 
+Any IDs that do not have a name on the sending side are treated as having an
+empty name for the purpose of matching.  This allows them to be matched via
+a \(dq\&*\(dq\& or using an empty name.  For instance:
+.IP 
+.nf 
+  \-\-usermap=:nobody \-\-groupmap=*:nobody
+.fi 
+
+.IP 
+When the \fB\-\-numeric\-ids\fP option is used, the sender does not send any
+names, so all the IDs are treated as having an empty name.  This means that
+you will need to specify numeric \fBFROM\fP values if you want to map these
+nameless IDs to different values.
+.IP 
+For the \fB\-\-usermap\fP option to have any effect, the \fB\-o\fP (\fB\-\-owner\fP)
+option must be used (or implied), and the receiver will need to be running
+as a super\-user (see also the \fB\-\-fake\-super\fP option).  For the \fB\-\-groupmap\fP
+option to have any effect, the \fB\-g\fP (\fB\-\-groups\fP) option must be used
+(or implied), and the receiver will need to have permissions to set that
+group.
+.IP 
+.IP "\fB\-\-chown=USER:GROUP\fP"
+This option forces all files to be owned by USER
+with group GROUP.  This is a simpler interface than using \fB\-\-usermap\fP and
+\fB\-\-groupmap\fP directly, but it is implemented using those options internally,
+so you cannot mix them.  If either the USER or GROUP is empty, no mapping for
+the omitted user/group will occur.  If GROUP is empty, the trailing colon may
+be omitted, but if USER is empty, a leading colon must be supplied.
+.IP 
+If you specify \(dq\&\-\-chown=foo:bar, this is exactly the same as specifying
+\(dq\&\-\-usermap=*:foo \-\-groupmap=*:bar\(dq\&, only easier.
+.IP 
 .IP "\fB\-\-timeout=TIMEOUT\fP"
 This option allows you to set a maximum I/O
 timeout in seconds. If no data is transferred for the specified time
 then rsync will exit. The default is 0, which means no timeout.
 .IP 
 .IP "\fB\-\-contimeout\fP"
@@ -2021,12 +2298,20 @@
 This tells rsync to use blocking I/O when launching
 a remote shell transport.  If the remote shell is either rsh or remsh,
 rsync defaults to using
 blocking I/O, otherwise it defaults to using non\-blocking I/O.  (Note that
 ssh prefers non\-blocking I/O.)
 .IP 
+.IP "\fB\-\-outbuf=MODE\fP"
+This sets the output buffering mode.  The mode can be
+None (aka Unbuffered), Line, or Block (aka Full).  You may specify as little
+as a single letter for the mode, and use upper or lower case.
+.IP 
+The main use of this option is to change Full buffering to Line buffering
+when rsync\(cq\&s output is going to a file or pipe.
+.IP 
 .IP "\fB\-i, \-\-itemize\-changes\fP"
 Requests a simple itemized list of the
 changes that are being made to each file, including attribute changes.
 This is exactly the same as specifying \fB\-\-out\-format='\&%i %n%L'\&\fP.
 If you repeat the option, unchanged files will also be output, but only
 if the receiving rsync is at least version 2.6.7 (you can use \fB\-vv\fP
@@ -2119,19 +2404,19 @@
 .IP 
 .IP "\fB\-\-out\-format=FORMAT\fP"
 This allows you to specify exactly what the
 rsync client outputs to the user on a per\-update basis.  The format is a
 text string containing embedded single\-character escape sequences prefixed
 with a percent (%) character.   A default format of \(dq\&%n%L\(dq\& is assumed if
-\fB\-v\fP is specified (which reports the name
+either \fB\-\-info=name\fP or \fB\-v\fP is specified (this tells you just the name
 of the file and, if the item is a link, where it points).  For a full list
 of the possible escape characters, see the \(dq\&log format\(dq\& setting in the
 rsyncd.conf manpage.
 .IP 
-Specifying the \fB\-\-out\-format\fP option
-will mention each file, dir, etc. that gets updated in a significant
+Specifying the \fB\-\-out\-format\fP option implies the \fB\-\-info=name\fP option,
+which will mention each file, dir, etc. that gets updated in a significant
 way (a transferred file, a recreated symlink/device, or a touched
 directory).  In addition, if the itemize\-changes escape (%i) is included in
 the string (e.g. if the \fB\-\-itemize\-changes\fP option was used), the logging
 of names increases to mention any item that is changed in any way (as long
 as the receiving side is at least 2.6.4).  See the \fB\-\-itemize\-changes\fP
 option for a description of the output of \(dq\&%i\(dq\&.
@@ -2152,13 +2437,13 @@
 option if you wish to override this.
 .IP 
 Here\(cq\&s a example command that requests the remote side to log what is
 happening:
 .IP 
 .nf 
-  rsync \-av \-\-rsync\-path=\(dq\&rsync \-\-log\-file=/tmp/rlog\(dq\& src/ dest/
+  rsync \-av \-\-remote\-option=\-\-log\-file=/tmp/rlog src/ dest/
 .fi 
 
 .IP 
 This is very useful if you need to debug why a connection is closing
 unexpectedly.
 .IP 
@@ -2173,23 +2458,40 @@
 The default FORMAT used if \fB\-\-log\-file\fP is specified and this option is not
 is \(cq\&%i %n%L\(cq\&.
 .IP 
 .IP "\fB\-\-stats\fP"
 This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective rsync\(cq\&s delta\-transfer
-algorithm is for your data.
+algorithm is for your data.  This option is equivalent to \fB\-\-info=stats2\fP
+if combined with 0 or 1 \fB\-v\fP options, or \fB\-\-info=stats3\fP if combined
+with 2 or more \fB\-v\fP options.
 .IP 
 The current statistics are as follows: 
 .RS 
 .IP o 
 \fBNumber of files\fP is the count of all \(dq\&files\(dq\& (in the generic
-sense), which includes directories, symlinks, etc.
-.IP o 
-\fBNumber of files transferred\fP is the count of normal files that
-were updated via rsync\(cq\&s delta\-transfer algorithm, which does not include created
-dirs, symlinks, etc.
+sense), which includes directories, symlinks, etc.  The total count will
+be followed by a list of counts by filetype (if the total is non\-zero).
+For example: \(dq\&(reg: 5, dir: 3, link: 2, dev: 1, special: 1)\(dq\& lists the
+totals for regular files, directories, symlinks, devices, and special
+files.  If any of value is 0, it is completely omitted from the list.
+.IP o 
+\fBNumber of created files\fP is the count of how many \(dq\&files\(dq\& (generic
+sense) were created (as opposed to updated).  The total count will be
+followed by a list of counts by filetype (if the total is non\-zero).
+.IP o 
+\fBNumber of deleted files\fP is the count of how many \(dq\&files\(dq\& (generic
+sense) were created (as opposed to updated).  The total count will be
+followed by a list of counts by filetype (if the total is non\-zero).
+Note that this line is only output if deletions are in effect, and only
+if protocol 31 is being used (the default for rsync 3.1.x).
+.IP o 
+\fBNumber of regular files transferred\fP is the count of normal files
+that were updated via rsync\(cq\&s delta\-transfer algorithm, which does not
+include dirs, symlinks, etc.  Note that rsync 3.1.0 added the word
+\(dq\&regular\(dq\& into this heading.
 .IP o 
 \fBTotal file size\fP is the total sum of all file sizes in the transfer.
 This does not count any size for directories or special files, but does
 include the size of symlinks.
 .IP o 
 \fBTotal transferred file size\fP is the total sum of all files sizes
@@ -2234,16 +2536,31 @@
 and a hash (#), followed by exactly 3 octal digits.  For example, a newline
 would output as \(dq\&\e#012\(dq\&.  A literal backslash that is in a filename is not
 escaped unless it is followed by a hash and 3 digits (0\-9).
 .IP 
 .IP "\fB\-h, \-\-human\-readable\fP"
 Output numbers in a more human\-readable format.
-This makes big numbers output using larger units, with a K, M, or G suffix.  If
-this option was specified once, these units are K (1000), M (1000*1000), and
-G (1000*1000*1000); if the option is repeated, the units are powers of 1024
-instead of 1000.
+There are 3 possible levels:  (1) output numbers with a separator between each
+set of 3 digits (either a comma or a period, depending on if the decimal point
+is represented by a period or a comma); (2) output numbers in units of 1000
+(with a character suffix for larger units \-\- see below); (3) output numbers in
+units of 1024.
+.IP 
+The default is human\-readable level 1.  Each \fB\-h\fP option increases the level
+by one.  You can take the level down to 0 (to output numbers as pure digits) by
+specifing the \fB\-\-no\-human\-readable\fP (\fB\-\-no\-h\fP) option.
+.IP 
+The unit letters that are appended in levels 2 and 3 are: K (kilo), M (mega),
+G (giga), or T (tera).  For example, a 1234567\-byte file would output as 1.23M
+in level\-2 (assuming that a period is your local decimal point).
+.IP 
+Backward compatibility note:  versions of rsync prior to 3.1.0 do not support
+human\-readable level 1, and they default to level 0.  Thus, specifying one or
+two \fB\-h\fP options will behave in a comparable manner in old and new versions
+as long as you didn\(cq\&t specify a \fB\-\-no\-h\fP option prior to one or more \fB\-h\fP
+options.  See the \fB\-\-list\-only\fP option for one difference.
 .IP 
 .IP "\fB\-\-partial\fP"
 By default, rsync will delete any partially
 transferred file if the transfer is interrupted. In some circumstances
 it is more desirable to keep partially transferred files. Using the
 \fB\-\-partial\fP option tells rsync to keep the partial file which should
@@ -2377,13 +2694,15 @@
 in place of the hide\-filter (if that is more natural to you).
 .IP 
 .IP "\fB\-\-progress\fP"
 This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
-Implies \fB\-\-verbose\fP if it wasn\(cq\&t already specified.
+With a modern rsync this is the same as specifying
+\fB\-\-info=flist2,name,progress\fP, but any user\-supplied settings for those
+info flags takes precedence (e.g. \(dq\&\-\-info=flist0 \-\-progress\(dq\&).
 .IP 
 While rsync is transferring a regular file, it updates a progress line that
 looks like this:
 .IP 
 .nf 
       782448  63%  110.64kB/s    0:00:04
@@ -2403,33 +2722,51 @@
 was finishing the matched part of the file.
 .IP 
 When the file transfer finishes, rsync replaces the progress line with a
 summary line that looks like this:
 .IP 
 .nf 
-     1238099 100%  146.38kB/s    0:00:08  (xfer#5, to\-check=169/396)
+      1,238,099 100%  146.38kB/s    0:00:08  (xfr#5, to\-chk=169/396)
 .fi 
 
 .IP 
-In this example, the file was 1238099 bytes long in total, the average rate
+In this example, the file was 1,238,099 bytes long in total, the average rate
 of transfer for the whole file was 146.38 kilobytes per second over the 8
 seconds that it took to complete, it was the 5th transfer of a regular file
 during the current rsync session, and there are 169 more files for the
 receiver to check (to see if they are up\-to\-date or not) remaining out of
 the 396 total files in the file\-list.
 .IP 
+In an incremental recursion scan, rsync won\(cq\&t know the total number of files
+in the file\-list until it reaches the ends of the scan, but since it starts to
+transfer files during the scan, it will display a line with the text \(dq\&ir\-chk\(dq\&
+(for incremental recursion check) instead of \(dq\&to\-chk\(dq\& until the point that it
+knows the full size of the list, at which point it will switch to using
+\(dq\&to\-chk\(dq\&.  Thus, seeing \(dq\&ir\-chk\(dq\& lets you know that the total count of files
+in the file list is still going to increase (and each time it does, the count
+of files left to check  will increase by the number of the files added to the
+list).
+.IP 
 .IP "\fB\-P\fP"
 The \fB\-P\fP option is equivalent to \fB\-\-partial\fP \fB\-\-progress\fP.  Its
 purpose is to make it much easier to specify these two options for a long
 transfer that may be interrupted.
 .IP 
-.IP "\fB\-\-password\-file\fP"
-This option allows you to provide a password in a
-file for accessing an rsync daemon.  The file must not be world readable.
-It should contain just the password as the first line of the file (all
-other lines are ignored).
+There is also a \fB\-\-info=progress2\fP option that outputs statistics based
+on the whole transfer, rather than individual files.  Use this flag without
+outputting a filename (e.g. avoid \fB\-v\fP or specify \fB\-\-info=name0\fP if you
+want to see how the transfer is doing without scrolling the screen with a
+lot of names.  (You don\(cq\&t need to specify the \fB\-\-progress\fP option in
+order to use \fB\-\-info=progress2\fP.)
+.IP 
+.IP "\fB\-\-password\-file=FILE\fP"
+This option allows you to provide a password for
+accessing an rsync daemon via a file or via standard input if \fBFILE\fP is
+\fB\-\fP.  The file should contain just the password on the first line (all other
+lines are ignored).  Rsync will exit with an error if \fBFILE\fP is world
+readable or if a root\-run rsync command finds a non\-root\-owned file.
 .IP 
 This option does not supply a password to a remote shell transport such as
 ssh; to learn how to do that, consult the remote shell\(cq\&s documentation.
 When accessing an rsync daemon using a remote shell as the transport, this
 option only comes into effect after the remote shell finishes its
 authentication (i.e. if you have also specified a password in the daemon\(cq\&s
@@ -2448,28 +2785,50 @@
 .IP 
 .nf 
     rsync \-av \-\-list\-only foo* dest/
 .fi 
 
 .IP 
+Starting with rsync 3.1.0, the sizes output by \fB\-\-list\-only\fP are affected
+by the \fB\-\-human\-readable\fP option.  By default they will contain digit
+separators, but higher levels of readability will output the sizes with
+unit suffixes.  Note also that the column width for the size output has
+increased from 11 to 14 characters for all human\-readable levels.  Use
+\fB\-\-no\-h\fP if you want just digits in the sizes, and the old column width
+of 11 characters.
+.IP 
 Compatibility note:  when requesting a remote listing of files from an rsync
 that is version 2.6.3 or older, you may encounter an error if you ask for a
 non\-recursive listing.  This is because a file listing implies the \fB\-\-dirs\fP
 option w/o \fB\-\-recursive\fP, and older rsyncs don\(cq\&t have that option.  To
 avoid this problem, either specify the \fB\-\-no\-dirs\fP option (if you don\(cq\&t
 need to expand a directory\(cq\&s content), or turn on recursion and exclude
 the content of subdirectories: \fB\-r \-\-exclude='\&/*/*'\&\fP.
 .IP 
-.IP "\fB\-\-bwlimit=KBPS\fP"
-This option allows you to specify a maximum
-transfer rate in kilobytes per second. This option is most effective when
-using rsync with large files (several megabytes and up). Due to the nature
-of rsync transfers, blocks of data are sent, then if rsync determines the
-transfer was too fast, it will wait before sending the next data block. The
-result is an average transfer rate equaling the specified limit. A value
-of zero specifies no limit.
+.IP "\fB\-\-bwlimit=RATE\fP"
+This option allows you to specify the maximum transfer
+rate for the data sent over the socket, specified in units per second.  The
+RATE value can be suffixed with a string to indicate a size multiplier, and may
+be a fractional value (e.g.  \(dq\&\fB\-\-bwlimit=1.5m\fP\(dq\&).  If no suffix is specified,
+the value will be assumed to be in units of 1024 bytes (as if \(dq\&K\(dq\& or \(dq\&KiB\(dq\& had
+been appended).  See the \fB\-\-max\-size\fP option for a description of all the
+available suffixes. A value of zero specifies no limit.
+.IP 
+For backward\-compatibility reasons, the rate limit will be rounded to the
+nearest KiB unit, so no rate smaller than 1024 bytes per second is possible.
+.IP 
+Rsync writes data over the socket in blocks, and this option both limits the
+size of the blocks that rsync writes, and tries to keep the average transfer
+rate at the requested limit.  Some \(dq\&burstiness\(dq\& may be seen where rsync writes
+out a block of data and then sleeps to bring the average rate into compliance.
+.IP 
+Due to the internal buffering of data, the \fB\-\-progress\fP option may not be an
+accurate reflection on how fast the data is being sent.  This is because some
+files can show up as being rapidly sent when the data is quickly buffered,
+while other can show up as very slow when the flushing of the output buffer
+occurs.  This may be fixed in a future version.
 .IP 
 .IP "\fB\-\-write\-batch=FILE\fP"
 Record a file that can later be applied to
 another identical destination with \fB\-\-read\-batch\fP. See the \(dq\&BATCH MODE\(dq\&
 section for details, and also the \fB\-\-only\-write\-batch\fP option.
 .IP 
@@ -2545,26 +2904,25 @@
 .IP 
 If rsync was complied without support for IPv6, the \fB\-\-ipv6\fP option
 will have no effect.  The \fB\-\-version\fP output will tell you if this
 is the case.
 .IP 
 .IP "\fB\-\-checksum\-seed=NUM\fP"
-Set the checksum seed to the integer
-NUM.  This 4 byte checksum seed is included in each block and file
-checksum calculation.  By default the checksum seed is generated
-by the server and defaults to the current 
+Set the checksum seed to the integer NUM.  This 4
+byte checksum seed is included in each block and MD4 file checksum calculation
+(the more modern MD5 file checksums don\(cq\&t use a seed).  By default the checksum
+seed is generated by the server and defaults to the current 
 \f(CWtime()\fP
-\&.  This option
-is used to set a specific checksum seed, which is useful for
-applications that want repeatable block and file checksums, or
-in the case where the user wants a more random checksum seed.
-Setting NUM to 0 causes rsync to use the default of 
+\&.  This
+option is used to set a specific checksum seed, which is useful for
+applications that want repeatable block checksums, or in the case where the
+user wants a more random checksum seed.  Setting NUM to 0 causes rsync to use
+the default of 
 \f(CWtime()\fP
 for checksum seed.
-
-.PP 
+.IP 
 .SH "DAEMON OPTIONS"
 
 .PP 
 The options allowed when starting an rsync daemon are as follows:
 .PP 
 .IP "\fB\-\-daemon\fP"
@@ -2583,26 +2941,37 @@
 By default rsync will bind to the wildcard address when
 run as a daemon with the \fB\-\-daemon\fP option.  The \fB\-\-address\fP option
 allows you to specify a specific IP address (or hostname) to bind to.  This
 makes virtual hosting possible in conjunction with the \fB\-\-config\fP option.
 See also the \(dq\&address\(dq\& global option in the rsyncd.conf manpage.
 .IP 
-.IP "\fB\-\-bwlimit=KBPS\fP"
-This option allows you to specify a maximum
-transfer rate in kilobytes per second for the data the daemon sends.
-The client can still specify a smaller \fB\-\-bwlimit\fP value, but their
-requested value will be rounded down if they try to exceed it.  See the
-client version of this option (above) for some extra details.
+.IP "\fB\-\-bwlimit=RATE\fP"
+This option allows you to specify the maximum transfer
+rate for the data the daemon sends over the socket.  The client can still
+specify a smaller \fB\-\-bwlimit\fP value, but no larger value will be allowed.
+See the client version of this option (above) for some extra details.
 .IP 
 .IP "\fB\-\-config=FILE\fP"
 This specifies an alternate config file than
 the default.  This is only relevant when \fB\-\-daemon\fP is specified.
 The default is /etc/rsyncd.conf unless the daemon is running over
 a remote shell program and the remote user is not the super\-user; in that case
 the default is rsyncd.conf in the current directory (typically $HOME).
 .IP 
+.IP "\fB\-M, \-\-dparam=OVERRIDE\fP"
+This option can be used to set a daemon\-config
+parameter when starting up rsync in daemon mode.  It is equivalent to adding
+the parameter at the end of the global settings prior to the first module\(cq\&s
+definition.  The parameter names can be specified without spaces, if you so
+desire.  For instance:
+.IP 
+.nf 
+    rsync \-\-daemon \-M pidfile=/path/rsync.pid 
+.fi 
+
+.IP 
 .IP "\fB\-\-no\-detach\fP"
 When running as a daemon, this option instructs
 rsync to not detach itself and become a background process.  This
 option is required when running as a service on Cygwin, and may also
 be useful when rsync is supervised by a program such as
 \fBdaemontools\fP or AIX\(cq\&s \fBSystem Resource Controller\fP.
@@ -3475,12 +3844,16 @@
 The CVSIGNORE environment variable supplements any
 ignore patterns in .cvsignore files. See the \fB\-\-cvs\-exclude\fP option for
 more details.
 .IP "\fBRSYNC_ICONV\fP"
 Specify a default \fB\-\-iconv\fP setting using this
 environment variable. (First supported in 3.0.0.)
+.IP "\fBRSYNC_PROTECT_ARGS\fP"
+Specify a non\-zero numeric value if you want the
+\fB\-\-protect\-args\fP option to be enabled by default, or a zero value to make
+sure that it is disabled by default. (First supported in 3.1.0.)
 .IP "\fBRSYNC_RSH\fP"
 The RSYNC_RSH environment variable allows you to
 override the default shell used as the transport for rsync.  Command line
 options are permitted after the command name, just as in the \fB\-e\fP option.
 .IP "\fBRSYNC_PROXY\fP"
 The RSYNC_PROXY environment variable allows you to
@@ -3528,13 +3901,13 @@
 Please report bugs! See the web site at
 http://rsync.samba.org/
 .PP 
 .SH "VERSION"
 
 .PP 
-This man page is current for version 3.0.9 of rsync.
+This man page is current for version 3.1.0 of rsync.
 .PP 
 .SH "INTERNAL OPTIONS"
 
 .PP 
 The options \fB\-\-server\fP and \fB\-\-sender\fP are used internally by rsync,
 and should never be typed by a user under normal circumstances.  Some
@@ -3544,13 +3917,13 @@
 named rrsync (for restricted rsync) that can be used with a restricted
 ssh login.
 .PP 
 .SH "CREDITS"
 
 .PP 
-rsync is distributed under the GNU public license.  See the file
+rsync is distributed under the GNU General Public License.  See the file
 COPYING for details.
 .PP 
 A WEB site is available at
 http://rsync.samba.org/.  The site
 includes an FAQ\-O\-Matic which may cover questions unanswered by this
 manual page.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsync.c	2011-02-23 02:48:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsync.c	2013-05-27 07:22:56.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Routines common to more than one of the rsync processes.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -24,30 +24,32 @@
 #if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
 #include <libcharset.h>
 #elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
 #include <langinfo.h>
 #endif
 
-extern int verbose;
 extern int dry_run;
 extern int preserve_acls;
 extern int preserve_xattrs;
 extern int preserve_perms;
 extern int preserve_executability;
 extern int preserve_times;
 extern int am_root;
 extern int am_server;
+extern int am_daemon;
 extern int am_sender;
 extern int am_receiver;
 extern int am_generator;
 extern int am_starting_up;
 extern int allow_8bit_chars;
 extern int protocol_version;
+extern int got_kill_signal;
 extern int inc_recurse;
 extern int inplace;
 extern int flist_eof;
+extern int file_old_total;
 extern int keep_dirlinks;
 extern int make_backups;
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
 extern struct chmod_mode_struct *daemon_chmod_modes;
 #ifdef ICONV_OPTION
 extern char *iconv_opt;
@@ -79,25 +81,26 @@
 # endif
 
 	if (!am_server && !allow_8bit_chars) {
 		/* It's OK if this fails... */
 		ic_chck = iconv_open(defset, defset);
 
-		if (verbose > 3) {
+		if (DEBUG_GTE(ICONV, 2)) {
 			if (ic_chck == (iconv_t)-1) {
 				rprintf(FINFO,
-					"note: iconv_open(\"%s\", \"%s\") failed (%d)"
-					" -- using isprint() instead of iconv().\n",
+					"msg checking via isprint()"
+					" (iconv_open(\"%s\", \"%s\") errno: %d)\n",
 					defset, defset, errno);
 			} else {
 				rprintf(FINFO,
-					"note: iconv_open(\"%s\", \"%s\") succeeded.\n",
-					defset, defset);
+					"msg checking charset: %s\n",
+					defset);
 			}
 		}
-	}
+	} else
+		ic_chck = (iconv_t)-1;
 
 # ifdef ICONV_OPTION
 	if (!iconv_opt)
 		return;
 
 	if ((cp = strchr(iconv_opt, ',')) != NULL) {
@@ -121,86 +124,148 @@
 	if ((ic_recv = iconv_open(charset, UTF8_CHARSET)) == (iconv_t)-1) {
 		rprintf(FERROR, "iconv_open(\"%s\", \"%s\") failed\n",
 			charset, UTF8_CHARSET);
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
 
-	if (verbose > 1) {
-		rprintf(FINFO, "%s charset: %s\n",
-			am_server ? "server" : "client",
-			*charset ? charset : "[LOCALE]");
+	if (DEBUG_GTE(ICONV, 1)) {
+		rprintf(FINFO, "[%s] charset: %s\n",
+			who_am_i(), *charset ? charset : "[LOCALE]");
 	}
 # endif
 }
 
-/* This function converts the characters in the "in" xbuf into characters
- * in the "out" xbuf.  The "len" of the "in" xbuf is used starting from its
- * "pos".  The "size" of the "out" xbuf restricts how many characters can be
- * stored, starting at its "pos+len" position.  Note that the last byte of
- * the buffer is never used, which reserves space for a terminating '\0'.
+/* This function converts the chars in the "in" xbuf into characters in the
+ * "out" xbuf.  The ".len" chars of the "in" xbuf is used starting from its
+ * ".pos".  The ".size" of the "out" xbuf restricts how many characters can
+ * be stored, starting at its ".pos+.len" position.  Note that the last byte
+ * of the "out" xbuf is not used, which reserves space for a trailing '\0'
+ * (though it is up to the caller to store a trailing '\0', as needed).
+ *
  * We return a 0 on success or a -1 on error.  An error also sets errno to
  * E2BIG, EILSEQ, or EINVAL (see below); otherwise errno will be set to 0.
- * The "in" xbuf is altered to update "pos" and "len".  The "out" xbuf has
- * data appended, and its "len" incremented.   If ICB_EXPAND_OUT is set in
- * "flags", the "out" xbuf will also be allocated if empty, and expanded if
- * too small (so E2BIG will not be returned).  If ICB_INCLUDE_BAD is set in
- * "flags", any badly-encoded chars are included verbatim in the "out" xbuf,
- * so EILSEQ will not be returned.  Likewise for ICB_INCLUDE_INCOMPLETE with
- * respect to an incomplete multi-byte char at the end, which ensures that
- * EINVAL is not returned.  Anytime "in.pos" is 0 we will reset the iconv()
- * state prior to processing the characters. */
+ * The "in" xbuf is altered to update ".pos" and ".len".  The "out" xbuf has
+ * data appended, and its ".len" incremented (see below for a ".size" note).
+ *
+ * If ICB_CIRCULAR_OUT is set in "flags", the chars going into the "out" xbuf
+ * can wrap around to the start, and the xbuf may have its ".size" reduced
+ * (presumably by 1 byte) if the iconv code doesn't have space to store a
+ * multi-byte character at the physical end of the ".buf" (though no reducing
+ * happens if ".pos" is <= 1, since there is no room to wrap around).
+ *
+ * If ICB_EXPAND_OUT is set in "flags", the "out" xbuf will be allocated if
+ * empty, and (as long as ICB_CIRCULAR_OUT is not set) expanded if too small.
+ * This prevents the return of E2BIG (except for a circular xbuf).
+ *
+ * If ICB_INCLUDE_BAD is set in "flags", any badly-encoded chars are included
+ * verbatim in the "out" xbuf, so EILSEQ will not be returned.
+ *
+ * If ICB_INCLUDE_INCOMPLETE is set in "flags", any incomplete multi-byte
+ * chars are included, which ensures that EINVAL is not returned.
+ *
+ * If ICB_INIT is set, the iconv() conversion state is initialized prior to
+ * processing the characters. */
 int iconvbufs(iconv_t ic, xbuf *in, xbuf *out, int flags)
 {
 	ICONV_CONST char *ibuf;
-	size_t icnt, ocnt;
+	size_t icnt, ocnt, opos;
 	char *obuf;
 
-	if (!out->size && flags & ICB_EXPAND_OUT)
-		alloc_xbuf(out, 1024);
+	if (!out->size && flags & ICB_EXPAND_OUT) {
+		size_t siz = ROUND_UP_1024(in->len * 2);
+		alloc_xbuf(out, siz);
+	} else if (out->len+1 >= out->size) {
+		/* There is no room to even start storing data. */
+		if (!(flags & ICB_EXPAND_OUT) || flags & ICB_CIRCULAR_OUT) {
+			errno = E2BIG;
+			return -1;
+		}
+		realloc_xbuf(out, out->size + ROUND_UP_1024(in->len * 2));
+	}
 
-	if (!in->pos)
+	if (flags & ICB_INIT)
 		iconv(ic, NULL, 0, NULL, 0);
 
 	ibuf = in->buf + in->pos;
 	icnt = in->len;
 
-	obuf = out->buf + (out->pos + out->len);
-	ocnt = out->size - (out->pos + out->len) - 1;
+	opos = out->pos + out->len;
+	if (flags & ICB_CIRCULAR_OUT) {
+		if (opos >= out->size) {
+			opos -= out->size;
+			/* We know that out->pos is not 0 due to the "no room" check
+			 * above, so this can't go "negative". */
+			ocnt = out->pos - opos - 1;
+		} else {
+			/* Allow the use of all bytes to the physical end of the buffer
+			 * unless pos is 0, in which case we reserve our trailing '\0'. */
+			ocnt = out->size - opos - (out->pos ? 0 : 1);
+		}
+	} else
+		ocnt = out->size - opos - 1;
+	obuf = out->buf + opos;
 
 	while (icnt) {
 		while (iconv(ic, &ibuf, &icnt, &obuf, &ocnt) == (size_t)-1) {
 			if (errno == EINTR)
 				continue;
 			if (errno == EINVAL) {
 				if (!(flags & ICB_INCLUDE_INCOMPLETE))
 					goto finish;
+				if (!ocnt)
+					goto e2big;
 			} else if (errno == EILSEQ) {
 				if (!(flags & ICB_INCLUDE_BAD))
 					goto finish;
-			} else {
-				size_t opos = obuf - out->buf;
-				if (!(flags & ICB_EXPAND_OUT)) {
+				if (!ocnt)
+					goto e2big;
+			} else if (errno == E2BIG) {
+				size_t siz;
+			  e2big:
+				opos = obuf - out->buf;
+				if (flags & ICB_CIRCULAR_OUT && out->pos > 1 && opos > out->pos) {
+					/* We are in a divided circular buffer at the physical
+					 * end with room to wrap to the start.  If iconv() refused
+					 * to use one or more trailing bytes in the buffer, we
+					 * set the size to ignore the unused bytes. */
+					if (opos < out->size)
+						reduce_iobuf_size(out, opos);
+					obuf = out->buf;
+					ocnt = out->pos - 1;
+					continue;
+				}
+				if (!(flags & ICB_EXPAND_OUT) || flags & ICB_CIRCULAR_OUT) {
 					errno = E2BIG;
 					goto finish;
 				}
-				realloc_xbuf(out, out->size + 1024);
+				siz = ROUND_UP_1024(in->len * 2);
+				realloc_xbuf(out, out->size + siz);
 				obuf = out->buf + opos;
-				ocnt += 1024;
+				ocnt += siz;
 				continue;
+			} else {
+				rsyserr(FERROR, errno, "unexpected error from iconv()");
+				exit_cleanup(RERR_UNSUPPORTED);
 			}
 			*obuf++ = *ibuf++;
 			ocnt--, icnt--;
+			if (!icnt)
+				break;
 		}
 	}
 
 	errno = 0;
 
   finish:
+	opos = obuf - out->buf;
+	if (flags & ICB_CIRCULAR_OUT && opos < out->pos)
+		opos += out->size;
+	out->len = opos - out->pos;
+
 	in->len = icnt;
 	in->pos = ibuf - in->buf;
-	out->len = obuf - out->buf - out->pos;
 
 	return errno ? -1 : 0;
 }
 #endif
 
 void send_protected_args(int fd, char *args[])
@@ -213,22 +278,22 @@
 	if (convert)
 		alloc_xbuf(&outbuf, 1024);
 #endif
 
 	for (i = 0; args[i]; i++) {} /* find first NULL */
 	args[i] = "rsync"; /* set a new arg0 */
-	if (verbose > 1)
+	if (DEBUG_GTE(CMD, 1))
 		print_child_argv("protected args:", args + i + 1);
 	do {
 		if (!args[i][0])
 			write_buf(fd, ".", 2);
 #ifdef ICONV_OPTION
 		else if (convert) {
 			INIT_XBUF_STRLEN(inbuf, args[i]);
 			iconvbufs(ic_send, &inbuf, &outbuf,
-				  ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE);
+				  ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_INIT);
 			outbuf.buf[outbuf.len] = '\0';
 			write_buf(fd, outbuf.buf, outbuf.len + 1);
 			outbuf.len = 0;
 		}
 #endif
 		else
@@ -239,28 +304,34 @@
 #ifdef ICONV_OPTION
 	if (convert)
 		free(outbuf.buf);
 #endif
 }
 
-int read_ndx_and_attrs(int f_in, int *iflag_ptr, uchar *type_ptr,
+int read_ndx_and_attrs(int f_in, int f_out, int *iflag_ptr, uchar *type_ptr,
 		       char *buf, int *len_ptr)
 {
 	int len, iflags = 0;
 	struct file_list *flist;
 	uchar fnamecmp_type = FNAMECMP_FNAME;
-	int ndx, save_verbose = verbose;
+	int ndx;
 
   read_loop:
 	while (1) {
 		ndx = read_ndx(f_in);
 
 		if (ndx >= 0)
 			break;
 		if (ndx == NDX_DONE)
 			return ndx;
+		if (ndx == NDX_DEL_STATS) {
+			read_del_stats(f_in);
+			if (am_sender && am_server)
+				write_del_stats(f_out);
+			continue;
+		}
 		if (!inc_recurse || am_sender) {
 			int last;
 			if (first_flist)
 				last = first_flist->prev->ndx_start + first_flist->prev->used - 1;
 			else
 				last = -1;
@@ -268,13 +339,15 @@
 				"Invalid file index: %d (%d - %d) [%s]\n",
 				ndx, NDX_DONE, last, who_am_i());
 			exit_cleanup(RERR_PROTOCOL);
 		}
 		if (ndx == NDX_FLIST_EOF) {
 			flist_eof = 1;
-			send_msg(MSG_FLIST_EOF, "", 0, 0);
+			if (DEBUG_GTE(FLIST, 3))
+				rprintf(FINFO, "[%s] flist_eof=1\n", who_am_i());
+			write_int(f_out, NDX_FLIST_EOF);
 			continue;
 		}
 		ndx = NDX_FLIST_OFFSET - ndx;
 		if (ndx < 0 || ndx >= dir_flist->used) {
 			ndx = NDX_FLIST_OFFSET - ndx;
 			rprintf(FERROR,
@@ -282,37 +355,42 @@
 				ndx, NDX_FLIST_OFFSET,
 				NDX_FLIST_OFFSET - dir_flist->used + 1,
 				who_am_i());
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
-		/* Send everything read from f_in to msg_fd_out. */
-		if (verbose > 3) {
+		if (DEBUG_GTE(FLIST, 2)) {
 			rprintf(FINFO, "[%s] receiving flist for dir %d\n",
 				who_am_i(), ndx);
 		}
-		verbose = 0;
-		send_msg_int(MSG_FLIST, ndx);
-		start_flist_forward(f_in);
+		/* Send all the data we read for this flist to the generator. */
+		start_flist_forward(ndx);
 		flist = recv_file_list(f_in);
 		flist->parent_ndx = ndx;
 		stop_flist_forward();
-		verbose = save_verbose;
 	}
 
 	iflags = protocol_version >= 29 ? read_shortint(f_in)
 		   : ITEM_TRANSFER | ITEM_MISSING_DATA;
 
 	/* Support the protocol-29 keep-alive style. */
 	if (protocol_version < 30 && ndx == cur_flist->used && iflags == ITEM_IS_NEW) {
 		if (am_sender)
-			maybe_send_keepalive();
+			maybe_send_keepalive(time(NULL), MSK_ALLOW_FLUSH);
 		goto read_loop;
 	}
 
-	cur_flist = flist_for_ndx(ndx, "read_ndx_and_attrs");
+	flist = flist_for_ndx(ndx, "read_ndx_and_attrs");
+	if (flist != cur_flist) {
+		cur_flist = flist;
+		if (am_sender) {
+			file_old_total = cur_flist->used;
+			for (flist = first_flist; flist != cur_flist; flist = flist->next)
+				file_old_total += flist->used;
+		}
+	}
 
 	if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
 		fnamecmp_type = read_byte(f_in);
 	*type_ptr = fnamecmp_type;
 
 	if (iflags & ITEM_XNAME_FOLLOWS) {
@@ -388,18 +466,13 @@
 			return 1;
 		if (link_stat(fname, &sx2.st, 0) < 0) {
 			rsyserr(FERROR_XFER, errno, "stat %s failed",
 				full_fname(fname));
 			return 0;
 		}
-#ifdef SUPPORT_ACLS
-		sx2.acc_acl = sx2.def_acl = NULL;
-#endif
-#ifdef SUPPORT_XATTRS
-		sx2.xattr = NULL;
-#endif
+		init_stat_x(&sx2);
 		sxp = &sx2;
 		inherit = !preserve_perms;
 	} else
 		inherit = !preserve_perms && file->flags & FLAG_DIR_CREATED;
 
 	if (inherit && S_ISDIR(new_mode) && sxp->st.st_mode & S_ISGID) {
@@ -426,13 +499,13 @@
 	if (!preserve_times
 	 || (!(preserve_times & PRESERVE_DIR_TIMES) && S_ISDIR(sxp->st.st_mode))
 	 || (!(preserve_times & PRESERVE_LINK_TIMES) && S_ISLNK(sxp->st.st_mode)))
 		flags |= ATTRS_SKIP_MTIME;
 	if (!(flags & ATTRS_SKIP_MTIME)
 	    && cmp_time(sxp->st.st_mtime, file->modtime) != 0) {
-		int ret = set_modtime(fname, file->modtime, sxp->st.st_mode);
+		int ret = set_modtime(fname, file->modtime, F_MOD_NSEC(file), sxp->st.st_mode);
 		if (ret < 0) {
 			rsyserr(FERROR_XFER, errno, "failed to set times on %s",
 				full_fname(fname));
 			goto cleanup;
 		}
 		if (ret == 0) /* ret == 1 if symlink could not be set */
@@ -447,13 +520,13 @@
 #ifndef CAN_CHOWN_SYMLINK
 	if (S_ISLNK(sxp->st.st_mode)) {
 		;
 	} else
 #endif
 	if (change_uid || change_gid) {
-		if (verbose > 2) {
+		if (DEBUG_GTE(OWN, 1)) {
 			if (change_uid) {
 				rprintf(FINFO,
 					"set uid of %s from %u to %u\n",
 					fname, (unsigned)sxp->st.st_uid, F_OWNER(file));
 			}
 			if (change_gid) {
@@ -512,43 +585,53 @@
 		}
 		if (ret == 0) /* ret == 1 if symlink could not be set */
 			updated = 1;
 	}
 #endif
 
-	if (verbose > 1 && flags & ATTRS_REPORT) {
+	if (INFO_GTE(NAME, 2) && flags & ATTRS_REPORT) {
 		if (updated)
 			rprintf(FCLIENT, "%s\n", fname);
 		else
 			rprintf(FCLIENT, "%s is uptodate\n", fname);
 	}
   cleanup:
-	if (sxp == &sx2) {
-#ifdef SUPPORT_ACLS
-		if (preserve_acls)
-			free_acl(&sx2);
-#endif
-#ifdef SUPPORT_XATTRS
-		if (preserve_xattrs)
-			free_xattr(&sx2);
-#endif
-	}
+	if (sxp == &sx2)
+		free_stat_x(&sx2);
 	return updated;
 }
 
-RETSIGTYPE sig_int(UNUSED(int val))
+/* This is only called for SIGINT, SIGHUP, and SIGTERM. */
+RETSIGTYPE sig_int(int sig_num)
 {
 	/* KLUGE: if the user hits Ctrl-C while ssh is prompting
 	 * for a password, then our cleanup's sending of a SIGUSR1
 	 * signal to all our children may kill ssh before it has a
 	 * chance to restore the tty settings (i.e. turn echo back
 	 * on).  By sleeping for a short time, ssh gets a bigger
 	 * chance to do the right thing.  If child processes are
 	 * not ssh waiting for a password, then this tiny delay
 	 * shouldn't hurt anything. */
 	msleep(400);
+
+	/* If we're an rsync daemon listener (not a daemon server),
+	 * we'll exit with status 0 if we received SIGTERM. */
+	if (am_daemon && !am_server && sig_num == SIGTERM)
+		exit_cleanup(0);
+
+	/* If the signal arrived on the server side (or for the receiver
+	 * process on the client), we want to try to do a controlled shutdown
+	 * that lets the client side (generator process) know what happened.
+	 * To do this, we set a flag and let the normal process handle the
+	 * shutdown.  We only attempt this if multiplexed IO is in effect and
+	 * we didn't already set the flag. */
+	if (!got_kill_signal && (am_server || am_receiver)) {
+		got_kill_signal = sig_num;
+		return;
+	}
+
 	exit_cleanup(RERR_SIGNAL);
 }
 
 /* Finish off a file transfer: renaming the file and setting the file's
  * attributes (e.g. permissions, ownership, etc.).  If the robust_rename()
  * call is forced to copy the temp file and partialptr is both non-NULL and
@@ -560,41 +643,40 @@
 		    int overwriting_basis)
 {
 	int ret;
 	const char *temp_copy_name = partialptr && *partialptr != '/' ? partialptr : NULL;
 
 	if (inplace) {
-		if (verbose > 2)
+		if (DEBUG_GTE(RECV, 1))
 			rprintf(FINFO, "finishing %s\n", fname);
 		fnametmp = fname;
 		goto do_set_file_attrs;
 	}
 
 	if (make_backups > 0 && overwriting_basis) {
-		if (!make_backup(fname))
+		int ok = make_backup(fname, False);
+		if (!ok)
 			return 1;
-		if (fnamecmp == fname)
+		if (ok == 1 && fnamecmp == fname)
 			fnamecmp = get_backup_name(fname);
 	}
 
 	/* Change permissions before putting the file into place. */
 	set_file_attrs(fnametmp, file, NULL, fnamecmp,
 		       ok_to_set_time ? 0 : ATTRS_SKIP_MTIME);
 
 	/* move tmp file over real file */
-	if (verbose > 2)
+	if (DEBUG_GTE(RECV, 1))
 		rprintf(FINFO, "renaming %s to %s\n", fnametmp, fname);
-	ret = robust_rename(fnametmp, fname, temp_copy_name,
-			    file->mode & INITACCESSPERMS);
+	ret = robust_rename(fnametmp, fname, temp_copy_name, file->mode);
 	if (ret < 0) {
 		rsyserr(FERROR_XFER, errno, "%s %s -> \"%s\"",
 			ret == -2 ? "copy" : "rename",
 			full_fname(fnametmp), fname);
 		if (!partialptr || (ret == -2 && temp_copy_name)
-		 || robust_rename(fnametmp, partialptr, NULL,
-				  file->mode & INITACCESSPERMS) < 0)
+		 || robust_rename(fnametmp, partialptr, NULL, file->mode) < 0)
 			do_unlink(fnametmp);
 		return 0;
 	}
 	if (ret == 0) {
 		/* The file was moved into place (not copied), so it's done. */
 		return 1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsyncd.conf.5	2011-09-24 00:35:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsyncd.conf.5	2013-09-29 10:57:23.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsyncd.conf" "5" "23 Sep 2011" "" ""
+.TH "rsyncd.conf" "5" "28 Sep 2013" "" ""
 .SH "NAME"
 rsyncd.conf \- configuration file for rsync in daemon mode
 .SH "SYNOPSIS"
 
 .PP 
 rsyncd.conf
@@ -28,14 +28,15 @@
 Only the first equals sign in a parameter is significant. Whitespace before
 or after the first equals sign is discarded. Leading, trailing and internal
 whitespace in module and parameter names is irrelevant. Leading and
 trailing whitespace in a parameter value is discarded. Internal whitespace
 within a parameter value is retained verbatim.
 .PP 
-Any line beginning with a hash (#) is ignored, as are lines containing
-only whitespace.
+Any line \fBbeginning\fP with a hash (#) is ignored, as are lines containing
+only whitespace. (If a hash occurs after anything other than leading
+whitespace, it is considered a part of the line\(cq\&s content.)
 .PP 
 Any line ending in a \e is \(dq\&continued\(dq\& on the next line in the
 customary UNIX fashion.
 .PP 
 The values following the equals sign in parameters are all either a string
 (no quotes needed) or a boolean, which may be given as yes/no, 0/1 or
@@ -86,22 +87,38 @@
 global parameters.
 .PP 
 You may also include any module parameters in the global part of the
 config file in which case the supplied value will override the
 default for that parameter.
 .PP 
+You may use references to environment variables in the values of parameters.
+String parameters will have %VAR% references expanded as late as possible (when
+the string is used in the program), allowing for the use of variables that
+rsync sets at connection time, such as RSYNC_USER_NAME.  Non\-string parameters
+(such as true/false settings) are expanded when read from the config file.  If
+a variable does not exist in the environment, or if a sequence of characters is
+not a valid reference (such as an un\-paired percent sign), the raw characters
+are passed through unchanged.  This helps with backward compatibility and
+safety (e.g. expanding a non\-existent %VAR% to an empty string in a path could
+result in a very unsafe path).  The safest way to insert a literal % into a
+value is to use %%.
+.PP 
 .IP "\fBmotd file\fP"
 This parameter allows you to specify a
 \(dq\&message of the day\(dq\& to display to clients on each connect. This
 usually contains site information and any legal notices. The default
 is no motd file.
+This can be overridden by the \fB\-\-dparam=motdfile=FILE\fP
+command\-line option when starting the daemon.
 .IP 
 .IP "\fBpid file\fP"
 This parameter tells the rsync daemon to write
 its process ID to that file.  If the file already exists, the rsync
 daemon will abort rather than overwrite the file.
+This can be overridden by the \fB\-\-dparam=pidfile=FILE\fP
+command\-line option when starting the daemon.
 .IP 
 .IP "\fBport\fP"
 You can override the default port the daemon will listen on
 by specifying this value (defaults to 873).  This is ignored if the daemon
 is being run by inetd, and is superseded by the \fB\-\-port\fP command\-line option.
 .IP 
@@ -118,34 +135,51 @@
 \f(CWsetsockopt()\fP
 system call for
 details on some of the options you may be able to set. By default no
 special socket options are set.  These settings can also be specified
 via the \fB\-\-sockopts\fP command\-line option.
 .IP 
+.IP "\fBlisten backlog\fP"
+You can override the default backlog value when the
+daemon listens for connections.  It defaults to 5.
+.IP 
 .SH "MODULE PARAMETERS"
 
 .PP 
 After the global parameters you should define a number of modules, each
 module exports a directory tree as a symbolic name. Modules are
 exported by specifying a module name in square brackets [module]
 followed by the parameters for that module.
 The module name cannot contain a slash or a closing square bracket.  If the
 name contains whitespace, each internal sequence of whitespace will be
 changed into a single space, while leading or trailing whitespace will be
 discarded.
 .PP 
+As with GLOBAL PARAMETERS, you may use references to environment variables in
+the values of parameters.  See the GLOBAL PARAMETERS section for more details.
+.PP 
 .IP "\fBcomment\fP"
 This parameter specifies a description string
 that is displayed next to the module name when clients obtain a list
 of available modules. The default is no comment.
 .IP 
 .IP "\fBpath\fP"
 This parameter specifies the directory in the daemon\(cq\&s
 filesystem to make available in this module.  You must specify this parameter
 for each module in \f(CWrsyncd.conf\fP.
 .IP 
+You may base the path\(cq\&s value off of an environment variable by surrounding
+the variable name with percent signs.  You can even reference a variable
+that is set by rsync when the user connects.
+For example, this would use the authorizing user\(cq\&s name in the path:
+.IP 
+.nf 
+    path = /home/%RSYNC_USER_NAME% 
+.fi 
+
+.IP 
 It is fine if the path includes internal spaces \-\- they will be retained
 verbatim (which means that you shouldn\(cq\&t try to escape them).  If your final
 directory has a trailing space (and this is somehow not something you wish to
 fix), append a trailing slash to the path to avoid losing the trailing
 whitespace.
 .IP 
@@ -220,14 +254,15 @@
 taken steps to ensure that the module has the necessary resources it needs
 to translate names, and that it is not possible for a user to change those
 resources.
 .IP 
 .IP "\fBmunge symlinks\fP"
 This parameter tells rsync to modify
-all incoming symlinks in a way that makes them unusable but recoverable
-(see below).  This should help protect your files from user trickery when
+all symlinks in the same way as the (non\-daemon\-affecting)
+\fB\-\-munge\-links\fP command\-line option (using a method described below).
+This should help protect your files from user trickery when
 your daemon module is writable.  The default is disabled when \(dq\&use chroot\(dq\&
 is on and the inside\-chroot path is \(dq\&/\(dq\&, otherwise it is enabled.
 .IP 
 If you disable this parameter on a daemon that is not read\-only, there
 are tricks that a user can play with uploaded symlinks to access
 daemon\-excluded items (if your module has any), and, if \(dq\&use chroot\(dq\&
@@ -296,12 +331,18 @@
 or config\-file error messages.
 .IP 
 If the daemon fails to open the specified file, it will fall back to
 using syslog and output an error about the failure.  (Note that the
 failure to open the specified log file used to be a fatal error.)
 .IP 
+This setting can be overridden by using the \fB\-\-log\-file=FILE\fP or
+\fB\-\-dparam=logfile=FILE\fP command\-line options.  The former overrides
+all the log\-file parameters of the daemon and all module settings.
+The latter sets the daemon\(cq\&s log file and the default for all the
+modules, which still allows modules to override the default setting.
+.IP 
 .IP "\fBsyslog facility\fP"
 This parameter allows you to
 specify the syslog facility name to use when logging messages from the
 rsync daemon. You may use any standard syslog facility name which is
 defined on your system. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
@@ -327,37 +368,59 @@
 This parameter determines whether clients
 will be able to upload files or not. If \(dq\&read only\(dq\& is true then any
 attempted uploads will fail. If \(dq\&read only\(dq\& is false then uploads will
 be possible if file permissions on the daemon side allow them. The default
 is for all modules to be read only.
 .IP 
+Note that \(dq\&auth users\(dq\& can override this setting on a per\-user basis.
+.IP 
 .IP "\fBwrite only\fP"
 This parameter determines whether clients
 will be able to download files or not. If \(dq\&write only\(dq\& is true then any
 attempted downloads will fail. If \(dq\&write only\(dq\& is false then downloads
 will be possible if file permissions on the daemon side allow them.  The
 default is for this parameter to be disabled.
 .IP 
 .IP "\fBlist\fP"
-This parameter determines if this module should be
-listed when the client asks for a listing of available modules. By
-setting this to false you can create hidden modules. The default is
-for modules to be listable.
+This parameter determines whether this module is
+listed when the client asks for a listing of available modules.  In addition,
+if this is false, the daemon will pretend the module does not exist
+when a client denied by \(dq\&hosts allow\(dq\& or \(dq\&hosts deny\(dq\& attempts to access it.
+Realize that if \(dq\&reverse lookup\(dq\& is disabled globally but enabled for the
+module, the resulting reverse lookup to a potentially client\-controlled DNS
+server may still reveal to the client that it hit an existing module.
+The default is for modules to be listable.
 .IP 
 .IP "\fBuid\fP"
 This parameter specifies the user name or user ID that
 file transfers to and from that module should take place as when the daemon
 was run as root. In combination with the \(dq\&gid\(dq\& parameter this determines what
-file permissions are available. The default is uid \-2, which is normally
-the user \(dq\&nobody\(dq\&.
+file permissions are available. The default when run by a super\-user is to
+switch to the system\(cq\&s \(dq\&nobody\(dq\& user.  The default for a non\-super\-user is to
+not try to change the user.  See also the \(dq\&gid\(dq\& parameter.
+.IP 
+The RSYNC_USER_NAME environment variable may be used to request that rsync run
+as the authorizing user.  For example, if you want a rsync to run as the same
+user that was received for the rsync authentication, this setup is useful:
+.IP 
+.nf 
+    uid = %RSYNC_USER_NAME%
+    gid = * 
+.fi 
+
 .IP 
 .IP "\fBgid\fP"
-This parameter specifies the group name or group ID that
-file transfers to and from that module should take place as when the daemon
-was run as root. This complements the \(dq\&uid\(dq\& parameter. The default is gid \-2,
-which is normally the group \(dq\&nobody\(dq\&.
+This parameter specifies one or more group names/IDs that will be
+used when accessing the module.  The first one will be the default group, and
+any extra ones be set as supplemental groups.  You may also specify a \(dq\&*\(dq\& as
+the first gid in the list, which will be replaced by all the normal groups for
+the transfer\(cq\&s user (see \(dq\&uid\(dq\&).  The default when run by a super\-user is to
+switch to your OS\(cq\&s \(dq\&nobody\(dq\& (or perhaps \(dq\&nogroup\(dq\&) group with no other
+supplementary groups.  The default for a non\-super\-user is to not change any
+group attributes (and indeed, your OS may not allow a non\-super\-user to try to
+change their group settings).
 .IP 
 .IP "\fBfake super\fP"
 Setting \(dq\&fake super = yes\(dq\& for a module causes the
 daemon side to behave as if the \fB\-\-fake\-super\fP command\-line option had
 been specified.  This allows the full attributes of a file to be stored
 without having to have the daemon actually running as root.
@@ -435,42 +498,88 @@
 disable group write permissions on the server while having it appear to
 be on to the clients.
 See the description of the \fB\-\-chmod\fP rsync option and the \fBchmod\fP(1)
 manpage for information on the format of this string.
 .IP 
 .IP "\fBauth users\fP"
-This parameter specifies a comma and
-space\-separated list of usernames that will be allowed to connect to
+This parameter specifies a comma and/or space\-separated
+list of authorization rules.  In its simplest form, you list the usernames
+that will be allowed to connect to
 this module. The usernames do not need to exist on the local
-system. The usernames may also contain shell wildcard characters. If
+system. The rules may contain shell wildcard characters that will be matched
+against the username provided by the client for authentication. If
 \(dq\&auth users\(dq\& is set then the client will be challenged to supply a
 username and password to connect to the module. A challenge response
 authentication protocol is used for this exchange. The plain text
 usernames and passwords are stored in the file specified by the
 \(dq\&secrets file\(dq\& parameter. The default is for all users to be able to
 connect without a password (this is called \(dq\&anonymous rsync\(dq\&).
 .IP 
+In addition to username matching, you can specify groupname matching via a \(cq\&@\(cq\&
+prefix.  When using groupname matching, the authenticating username must be a
+real user on the system, or it will be assumed to be a member of no groups.
+For example, specifying \(dq\&@rsync\(dq\& will match the authenticating user if the
+named user is a member of the rsync group.
+.IP 
+Finally, options may be specified after a colon (:).  The options allow you to
+\(dq\&deny\(dq\& a user or a group, set the access to \(dq\&ro\(dq\& (read\-only), or set the access
+to \(dq\&rw\(dq\& (read/write).  Setting an auth\-rule\-specific ro/rw setting overrides
+the module\(cq\&s \(dq\&read only\(dq\& setting.
+.IP 
+Be sure to put the rules in the order you want them to be matched, because the
+checking stops at the first matching user or group, and that is the only auth
+that is checked.  For example:
+.IP 
+.nf 
+  auth users = joe:deny @guest:deny admin:rw @rsync:ro susan joe sam 
+.fi 
+
+.IP 
+In the above rule, user joe will be denied access no matter what.  Any user
+that is in the group \(dq\&guest\(dq\& is also denied access.  The user \(dq\&admin\(dq\& gets
+access in read/write mode, but only if the admin user is not in group \(dq\&guest\(dq\&
+(because the admin user\-matching rule would never be reached if the user is in
+group \(dq\&guest\(dq\&).  Any other user who is in group \(dq\&rsync\(dq\& will get read\-only
+access.  Finally, users susan, joe, and sam get the ro/rw setting of the
+module, but only if the user didn\(cq\&t match an earlier group\-matching rule.
+.IP 
+See the description of the secrets file for how you can have per\-user passwords
+as well as per\-group passwords.  It also explains how a user can authenticate
+using their user password or (when applicable) a group password, depending on
+what rule is being authenticated.
+.IP 
 See also the section entitled \(dq\&USING RSYNC\-DAEMON FEATURES VIA A REMOTE
 SHELL CONNECTION\(dq\& in \fBrsync\fP(1) for information on how handle an
 rsyncd.conf\-level username that differs from the remote\-shell\-level
 username when using a remote shell to connect to an rsync daemon.
 .IP 
 .IP "\fBsecrets file\fP"
-This parameter specifies the name of
-a file that contains the username:password pairs used for
-authenticating this module. This file is only consulted if the \(dq\&auth
-users\(dq\& parameter is specified. The file is line based and contains
-username:password pairs separated by a single colon. Any line starting
-with a hash (#) is considered a comment and is skipped. The passwords
-can contain any characters but be warned that many operating systems
-limit the length of passwords that can be typed at the client end, so
-you may find that passwords longer than 8 characters don\(cq\&t work.
+This parameter specifies the name of a file that contains
+the username:password and/or @groupname:password pairs used for authenticating
+this module. This file is only consulted if the \(dq\&auth users\(dq\& parameter is
+specified.  The file is line\-based and contains one name:password pair per
+line.  Any line has a hash (#) as the very first character on the line is
+considered a comment and is skipped.  The passwords can contain any characters
+but be warned that many operating systems limit the length of passwords that
+can be typed at the client end, so you may find that passwords longer than 8
+characters don\(cq\&t work.
+.IP 
+The use of group\-specific lines are only relevant when the module is being
+authorized using a matching \(dq\&@groupname\(dq\& rule.  When that happens, the user
+can be authorized via either their \(dq\&username:password\(dq\& line or the
+\(dq\&@groupname:password\(dq\& line for the group that triggered the authentication.
+.IP 
+It is up to you what kind of password entries you want to include, either
+users, groups, or both.  The use of group rules in \(dq\&auth users\(dq\& does not
+require that you specify a group password if you do not want to use shared
+passwords.
 .IP 
 There is no default for the \(dq\&secrets file\(dq\& parameter, you must choose a name
 (such as \f(CW/etc/rsyncd.secrets\fP).  The file must normally not be readable
-by \(dq\&other\(dq\&; see \(dq\&strict modes\(dq\&.
+by \(dq\&other\(dq\&; see \(dq\&strict modes\(dq\&.  If the file is not found or is rejected, no
+logins for a \(dq\&user auth\(dq\& module will be possible.
 .IP 
 .IP "\fBstrict modes\fP"
 This parameter determines whether or not
 the permissions on the secrets file will be checked.  If \(dq\&strict modes\(dq\& is
 true, then the secrets file must not be readable by any user ID other
 than the one that the rsync daemon is running under.  If \(dq\&strict modes\(dq\& is
@@ -497,19 +606,21 @@
 .IP o 
 an address/mask in the form ipaddr/maskaddr where ipaddr is the
 IP address and maskaddr is the netmask in dotted decimal notation for IPv4,
 or similar for IPv6, e.g. ffff:ffff:ffff:ffff:: instead of /64. All IP
 addresses which match the masked IP address will be allowed in.
 .IP o 
-a hostname. The hostname as determined by a reverse lookup will
-be matched (case insensitive) against the pattern. Only an exact
-match is allowed in.
-.IP o 
-a hostname pattern using wildcards. These are matched using the
-same rules as normal unix filename matching. If the pattern matches
-then the client is allowed in.
+a hostname pattern using wildcards. If the hostname of the connecting IP
+(as determined by a reverse lookup) matches the wildcarded name (using the
+same rules as normal unix filename matching), the client is allowed in.  This
+only works if \(dq\&reverse lookup\(dq\& is enabled (the default).
+.IP o 
+a hostname. A plain hostname is matched against the reverse DNS of the
+connecting IP (if \(dq\&reverse lookup\(dq\& is enabled), and/or the IP of the given
+hostname is matched against the connecting IP (if \(dq\&forward lookup\(dq\& is
+enabled, as it is by default).  Any match will be allowed in.
 .RE
 
 .IP 
 Note IPv6 link\-local addresses can have a scope in the address specification:
 .IP 
 .RS 
@@ -537,12 +648,31 @@
 list of patterns that are matched against a connecting clients
 hostname and IP address. If the pattern matches then the connection is
 rejected. See the \(dq\&hosts allow\(dq\& parameter for more information.
 .IP 
 The default is no \(dq\&hosts deny\(dq\& parameter, which means all hosts can connect.
 .IP 
+.IP "\fBreverse lookup\fP"
+Controls whether the daemon performs a reverse lookup
+on the client\(cq\&s IP address to determine its hostname, which is used for
+\(dq\&hosts allow\(dq\&/\(dq\&hosts deny\(dq\& checks and the \(dq\&%h\(dq\& log escape.  This is enabled by
+default, but you may wish to disable it to save time if you know the lookup will
+not return a useful result, in which case the daemon will use the name
+\(dq\&UNDETERMINED\(dq\& instead.
+.IP 
+If this parameter is enabled globally (even by default), rsync performs the
+lookup as soon as a client connects, so disabling it for a module will not
+avoid the lookup.  Thus, you probably want to disable it globally and then
+enable it for modules that need the information.
+.IP 
+.IP "\fBforward lookup\fP"
+Controls whether the daemon performs a forward lookup
+on any hostname specified in an hosts allow/deny setting.  By default this is
+enabled, allowing the use of an explicit hostname that would not be returned
+by reverse DNS of the connecting IP.
+.IP 
 .IP "\fBignore errors\fP"
 This parameter tells rsyncd to
 ignore I/O errors on the daemon when deciding whether to run the delete
 phase of the transfer. Normally rsync skips the \fB\-\-delete\fP step if any
 I/O errors have occurred in order to prevent disastrous deletion due
 to a temporary resource shortage or other I/O error. In some cases this
@@ -567,36 +697,43 @@
 This parameter allows you to specify the
 format used for logging file transfers when transfer logging is enabled.
 The format is a text string containing embedded single\-character escape
 sequences prefixed with a percent (%) character.  An optional numeric
 field width may also be specified between the percent and the escape
 letter (e.g. \(dq\&\fB%\-50n %8l %07p\fP\(dq\&).
+In addition, one or more apostrophes may be specified prior to a numerical
+escape to indicate that the numerical value should be made more human\-readable.
+The 3 supported levels are the same as for the \fB\-\-human\-readable\fP
+command\-line option, though the default is for human\-readability to be off.
+Each added apostrophe increases the level (e.g. \(dq\&\fB%'\&'\&l %'\&b %f\fP\(dq\&).
 .IP 
 The default log format is \(dq\&%o %h [%a] %m (%u) %f %l\(dq\&, and a \(dq\&%t [%p] \(dq\&
 is always prefixed when using the \(dq\&log file\(dq\& parameter.
 (A perl script that will summarize this default log format is included
 in the rsync source code distribution in the \(dq\&support\(dq\& subdirectory:
 rsyncstats.)
 .IP 
 The single\-character escapes that are understood are as follows:
 .IP 
 .RS 
 .IP o 
-%a the remote IP address
+%a the remote IP address (only available for a daemon)
 .IP o 
 %b the number of bytes actually transferred
 .IP o 
 %B the permission bits of the file (e.g. rwxrwxrwt)
 .IP o 
 %c the total size of the block checksums received for the basis file (only when sending)
 .IP o 
+%C the full\-file MD5 checksum if \fB\-\-checksum\fP is enabled or a file was transferred (only for protocol 30 or above).
+.IP o 
 %f the filename (long form on sender; no trailing \(dq\&/\(dq\&)
 .IP o 
 %G the gid of the file (decimal) or \(dq\&DEFAULT\(dq\&
 .IP o 
-%h the remote host name
+%h the remote host name (only available for a daemon)
 .IP o 
 %i an itemized list of what is being updated
 .IP o 
 %l the length of the file in bytes
 .IP o 
 %L the string \(dq\& \-> SYMLINK\(dq\&, \(dq\& => HARDLINK\(dq\&, or \(dq\&\(dq\& (where \fBSYMLINK\fP or \fBHARDLINK\fP is a filename)
@@ -681,13 +818,18 @@
 for the \(dq\&dont compress\(dq\& parameter changes the default when the daemon is
 the sender.
 .IP 
 .IP "\fBpre\-xfer exec\fP, \fBpost\-xfer exec\fP"
 You may specify a command to be run
 before and/or after the transfer.  If the \fBpre\-xfer exec\fP command fails, the
-transfer is aborted before it begins.
+transfer is aborted before it begins.  Any output from the script on stdout (up
+to several KB) will be displayed to the user when aborting, but is NOT
+displayed if the script returns success.  Any output from the script on stderr
+goes to the daemon\(cq\&s stderr, which is typically discarded (though see
+\-\-no\-detatch option for a way to see the stderr output, which can assist with
+debugging).
 .IP 
 The following environment variables will be set, though some are
 specific to the pre\-xfer or the post\-xfer environment:
 .IP 
 .RS 
 .IP o 
@@ -701,18 +843,21 @@
 .IP o 
 \fBRSYNC_USER_NAME\fP: The accessing user\(cq\&s name (empty if no user).
 .IP o 
 \fBRSYNC_PID\fP: A unique number for this transfer.
 .IP o 
 \fBRSYNC_REQUEST\fP: (pre\-xfer only) The module/path info specified
-by the user (note that the user can specify multiple source files,
-so the request can be something like \(dq\&mod/path1 mod/path2\(dq\&, etc.).
+by the user.  Note that the user can specify multiple source files,
+so the request can be something like \(dq\&mod/path1 mod/path2\(dq\&, etc.
 .IP o 
 \fBRSYNC_ARG#\fP: (pre\-xfer only) The pre\-request arguments are set
-in these numbered values. RSYNC_ARG0 is always \(dq\&rsyncd\(dq\&, and the last
-value contains a single period.
+in these numbered values. RSYNC_ARG0 is always \(dq\&rsyncd\(dq\&, followed by
+the options that were used in RSYNC_ARG1, and so on.  There will be a
+value of \(dq\&.\(dq\& indicating that the options are done and the path args
+are beginning \-\- these contain similar information to RSYNC_REQUEST,
+but with values separated and the module name stripped off.
 .IP o 
 \fBRSYNC_EXIT_STATUS\fP: (post\-xfer only) the server side\(cq\&s exit value.
 This will be 0 for a successful run, a positive value for an error that the
 server generated, or a \-1 if rsync failed to exit properly.  Note that an
 error that occurs on the client side does not currently get sent to the
 server side, so this is not the final exit status for the whole transfer.
@@ -724,12 +869,78 @@
 
 .IP 
 Even though the commands can be associated with a particular module, they
 are run using the permissions of the user that started the daemon (not the
 module\(cq\&s uid/gid setting) without any chroot restrictions.
 .IP 
+.SH "CONFIG DIRECTIVES"
+
+.PP 
+There are currently two config directives available that allow a config file to
+incorporate the contents of other files:  \fB&include\fP and \fB&merge\fP.  Both
+allow a reference to either a file or a directory.  They differ in how
+segregated the file\(cq\&s contents are considered to be.
+.PP 
+The \fB&include\fP directive treats each file as more distinct, with each one
+inheriting the defaults of the parent file, starting the parameter parsing
+as globals/defaults, and leaving the defaults unchanged for the parsing of
+the rest of the parent file.
+.PP 
+The \fB&merge\fP directive, on the other hand, treats the file\(cq\&s contents as
+if it were simply inserted in place of the directive, and thus it can set
+parameters in a module started in another file, can affect the defaults for
+other files, etc.
+.PP 
+When an \fB&include\fP or \fB&merge\fP directive refers to a directory, it will read
+in all the \fB*.conf\fP or \fB*.inc\fP files (respectively) that are contained inside
+that directory (without any
+recursive scanning), with the files sorted into alpha order.  So, if you have a
+directory named \(dq\&rsyncd.d\(dq\& with the files \(dq\&foo.conf\(dq\&, \(dq\&bar.conf\(dq\&, and
+\(dq\&baz.conf\(dq\& inside it, this directive:
+.PP 
+.nf 
+    &include /path/rsyncd.d 
+.fi 
+
+.PP 
+would be the same as this set of directives:
+.PP 
+.nf 
+    &include /path/rsyncd.d/bar.conf
+    &include /path/rsyncd.d/baz.conf
+    &include /path/rsyncd.d/foo.conf 
+.fi 
+
+.PP 
+except that it adjusts as files are added and removed from the directory.
+.PP 
+The advantage of the \fB&include\fP directive is that you can define one or more
+modules in a separate file without worrying about unintended side\-effects
+between the self\-contained module files.
+.PP 
+The advantage of the \fB&merge\fP directive is that you can load config snippets
+that can be included into multiple module definitions, and you can also set
+global values that will affect connections (such as \fBmotd file\fP), or globals
+that will affect other include files.
+.PP 
+For example, this is a useful /etc/rsyncd.conf file:
+.PP 
+.nf 
+    port = 873
+    log file = /var/log/rsync.log
+    pid file = /var/lock/rsync.lock
+
+    &merge /etc/rsyncd.d
+    &include /etc/rsyncd.d 
+.fi 
+
+.PP 
+This would merge any /etc/rsyncd.d/*.inc files (for global values that should
+stay in effect), and then include any /etc/rsyncd.d/*.conf files (defining
+modules without any global\-value cross\-talk).
+.PP 
 .SH "AUTHENTICATION STRENGTH"
 
 .PP 
 The authentication protocol used in rsync is a 128 bit MD4 based
 challenge response system. This is fairly weak protection, though (with
 at least one brute\-force hash\-finding algorithm publicly available), so
@@ -825,18 +1036,18 @@
 Please report bugs! The rsync bug tracking system is online at
 http://rsync.samba.org/
 .PP 
 .SH "VERSION"
 
 .PP 
-This man page is current for version 3.0.9 of rsync.
+This man page is current for version 3.1.0 of rsync.
 .PP 
 .SH "CREDITS"
 
 .PP 
-rsync is distributed under the GNU public license.  See the file
+rsync is distributed under the GNU General Public License.  See the file
 COPYING for details.
 .PP 
 The primary ftp site for rsync is
 ftp://rsync.samba.org/pub/rsync.
 .PP 
 A WEB site is available at
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsyncd.conf.yo	2011-09-24 00:13:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsyncd.conf.yo	2013-09-29 04:55:54.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(23 Sep 2011)()()
+manpage(rsyncd.conf)(5)(28 Sep 2013)()()
 manpagename(rsyncd.conf)(configuration file for rsync in daemon mode)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -25,14 +25,15 @@
 Only the first equals sign in a parameter is significant. Whitespace before
 or after the first equals sign is discarded. Leading, trailing and internal
 whitespace in module and parameter names is irrelevant. Leading and
 trailing whitespace in a parameter value is discarded. Internal whitespace
 within a parameter value is retained verbatim.
 
-Any line beginning with a hash (#) is ignored, as are lines containing
-only whitespace.
+Any line bf(beginning) with a hash (#) is ignored, as are lines containing
+only whitespace. (If a hash occurs after anything other than leading
+whitespace, it is considered a part of the line's content.)
 
 Any line ending in a \ is "continued" on the next line in the
 customary UNIX fashion.
 
 The values following the equals sign in parameters are all either a string
 (no quotes needed) or a boolean, which may be given as yes/no, 0/1 or
@@ -75,21 +76,37 @@
 global parameters.
 
 You may also include any module parameters in the global part of the
 config file in which case the supplied value will override the
 default for that parameter.
 
+You may use references to environment variables in the values of parameters.
+String parameters will have %VAR% references expanded as late as possible (when
+the string is used in the program), allowing for the use of variables that
+rsync sets at connection time, such as RSYNC_USER_NAME.  Non-string parameters
+(such as true/false settings) are expanded when read from the config file.  If
+a variable does not exist in the environment, or if a sequence of characters is
+not a valid reference (such as an un-paired percent sign), the raw characters
+are passed through unchanged.  This helps with backward compatibility and
+safety (e.g. expanding a non-existent %VAR% to an empty string in a path could
+result in a very unsafe path).  The safest way to insert a literal % into a
+value is to use %%.
+
 startdit()
 dit(bf(motd file)) This parameter allows you to specify a
 "message of the day" to display to clients on each connect. This
 usually contains site information and any legal notices. The default
 is no motd file.
+This can be overridden by the bf(--dparam=motdfile=FILE)
+command-line option when starting the daemon.
 
 dit(bf(pid file)) This parameter tells the rsync daemon to write
 its process ID to that file.  If the file already exists, the rsync
 daemon will abort rather than overwrite the file.
+This can be overridden by the bf(--dparam=pidfile=FILE)
+command-line option when starting the daemon.
 
 dit(bf(port)) You can override the default port the daemon will listen on
 by specifying this value (defaults to 873).  This is ignored if the daemon
 is being run by inetd, and is superseded by the bf(--port) command-line option.
 
 dit(bf(address)) You can override the default IP address the daemon
@@ -101,12 +118,15 @@
 sorts of socket options which may make transfers faster (or
 slower!). Read the man page for the code(setsockopt()) system call for
 details on some of the options you may be able to set. By default no
 special socket options are set.  These settings can also be specified
 via the bf(--sockopts) command-line option.
 
+dit(bf(listen backlog)) You can override the default backlog value when the
+daemon listens for connections.  It defaults to 5.
+
 enddit()
 
 manpagesection(MODULE PARAMETERS)
 
 After the global parameters you should define a number of modules, each
 module exports a directory tree as a symbolic name. Modules are
@@ -114,22 +134,32 @@
 followed by the parameters for that module.
 The module name cannot contain a slash or a closing square bracket.  If the
 name contains whitespace, each internal sequence of whitespace will be
 changed into a single space, while leading or trailing whitespace will be
 discarded.
 
+As with GLOBAL PARAMETERS, you may use references to environment variables in
+the values of parameters.  See the GLOBAL PARAMETERS section for more details.
+
 startdit()
 
 dit(bf(comment)) This parameter specifies a description string
 that is displayed next to the module name when clients obtain a list
 of available modules. The default is no comment.
 
 dit(bf(path)) This parameter specifies the directory in the daemon's
 filesystem to make available in this module.  You must specify this parameter
 for each module in tt(rsyncd.conf).
 
+You may base the path's value off of an environment variable by surrounding
+the variable name with percent signs.  You can even reference a variable
+that is set by rsync when the user connects.
+For example, this would use the authorizing user's name in the path:
+
+verb(    path = /home/%RSYNC_USER_NAME% )
+
 It is fine if the path includes internal spaces -- they will be retained
 verbatim (which means that you shouldn't try to escape them).  If your final
 directory has a trailing space (and this is somehow not something you wish to
 fix), append a trailing slash to the path to avoid losing the trailing
 whitespace.
 
@@ -194,14 +224,15 @@
 A chroot-enabled module should not have this parameter enabled unless you've
 taken steps to ensure that the module has the necessary resources it needs
 to translate names, and that it is not possible for a user to change those
 resources.
 
 dit(bf(munge symlinks)) This parameter tells rsync to modify
-all incoming symlinks in a way that makes them unusable but recoverable
-(see below).  This should help protect your files from user trickery when
+all symlinks in the same way as the (non-daemon-affecting)
+bf(--munge-links) command-line option (using a method described below).
+This should help protect your files from user trickery when
 your daemon module is writable.  The default is disabled when "use chroot"
 is on and the inside-chroot path is "/", otherwise it is enabled.
 
 If you disable this parameter on a daemon that is not read-only, there
 are tricks that a user can play with uploaded symlinks to access
 daemon-excluded items (if your module has any), and, if "use chroot"
@@ -263,12 +294,18 @@
 or config-file error messages.
 
 If the daemon fails to open the specified file, it will fall back to
 using syslog and output an error about the failure.  (Note that the
 failure to open the specified log file used to be a fatal error.)
 
+This setting can be overridden by using the bf(--log-file=FILE) or
+bf(--dparam=logfile=FILE) command-line options.  The former overrides
+all the log-file parameters of the daemon and all module settings.
+The latter sets the daemon's log file and the default for all the
+modules, which still allows modules to override the default setting.
+
 dit(bf(syslog facility)) This parameter allows you to
 specify the syslog facility name to use when logging messages from the
 rsync daemon. You may use any standard syslog facility name which is
 defined on your system. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
 local1, local2, local3, local4, local5, local6 and local7. The default
@@ -290,33 +327,52 @@
 dit(bf(read only)) This parameter determines whether clients
 will be able to upload files or not. If "read only" is true then any
 attempted uploads will fail. If "read only" is false then uploads will
 be possible if file permissions on the daemon side allow them. The default
 is for all modules to be read only.
 
+Note that "auth users" can override this setting on a per-user basis.
+
 dit(bf(write only)) This parameter determines whether clients
 will be able to download files or not. If "write only" is true then any
 attempted downloads will fail. If "write only" is false then downloads
 will be possible if file permissions on the daemon side allow them.  The
 default is for this parameter to be disabled.
 
-dit(bf(list)) This parameter determines if this module should be
-listed when the client asks for a listing of available modules. By
-setting this to false you can create hidden modules. The default is
-for modules to be listable.
+dit(bf(list)) This parameter determines whether this module is
+listed when the client asks for a listing of available modules.  In addition,
+if this is false, the daemon will pretend the module does not exist
+when a client denied by "hosts allow" or "hosts deny" attempts to access it.
+Realize that if "reverse lookup" is disabled globally but enabled for the
+module, the resulting reverse lookup to a potentially client-controlled DNS
+server may still reveal to the client that it hit an existing module.
+The default is for modules to be listable.
 
 dit(bf(uid)) This parameter specifies the user name or user ID that
 file transfers to and from that module should take place as when the daemon
 was run as root. In combination with the "gid" parameter this determines what
-file permissions are available. The default is uid -2, which is normally
-the user "nobody".
-
-dit(bf(gid)) This parameter specifies the group name or group ID that
-file transfers to and from that module should take place as when the daemon
-was run as root. This complements the "uid" parameter. The default is gid -2,
-which is normally the group "nobody".
+file permissions are available. The default when run by a super-user is to
+switch to the system's "nobody" user.  The default for a non-super-user is to
+not try to change the user.  See also the "gid" parameter.
+
+The RSYNC_USER_NAME environment variable may be used to request that rsync run
+as the authorizing user.  For example, if you want a rsync to run as the same
+user that was received for the rsync authentication, this setup is useful:
+
+verb(    uid = %RSYNC_USER_NAME%
+    gid = * )
+
+dit(bf(gid)) This parameter specifies one or more group names/IDs that will be
+used when accessing the module.  The first one will be the default group, and
+any extra ones be set as supplemental groups.  You may also specify a "*" as
+the first gid in the list, which will be replaced by all the normal groups for
+the transfer's user (see "uid").  The default when run by a super-user is to
+switch to your OS's "nobody" (or perhaps "nogroup") group with no other
+supplementary groups.  The default for a non-super-user is to not change any
+group attributes (and indeed, your OS may not allow a non-super-user to try to
+change their group settings).
 
 dit(bf(fake super)) Setting "fake super = yes" for a module causes the
 daemon side to behave as if the bf(--fake-super) command-line option had
 been specified.  This allows the full attributes of a file to be stored
 without having to have the daemon actually running as root.
 
@@ -385,41 +441,84 @@
 than those stored in the filesystem itself.  For instance, you could
 disable group write permissions on the server while having it appear to
 be on to the clients.
 See the description of the bf(--chmod) rsync option and the bf(chmod)(1)
 manpage for information on the format of this string.
 
-dit(bf(auth users)) This parameter specifies a comma and
-space-separated list of usernames that will be allowed to connect to
+dit(bf(auth users)) This parameter specifies a comma and/or space-separated
+list of authorization rules.  In its simplest form, you list the usernames
+that will be allowed to connect to
 this module. The usernames do not need to exist on the local
-system. The usernames may also contain shell wildcard characters. If
+system. The rules may contain shell wildcard characters that will be matched
+against the username provided by the client for authentication. If
 "auth users" is set then the client will be challenged to supply a
 username and password to connect to the module. A challenge response
 authentication protocol is used for this exchange. The plain text
 usernames and passwords are stored in the file specified by the
 "secrets file" parameter. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync").
 
+In addition to username matching, you can specify groupname matching via a '@'
+prefix.  When using groupname matching, the authenticating username must be a
+real user on the system, or it will be assumed to be a member of no groups.
+For example, specifying "@rsync" will match the authenticating user if the
+named user is a member of the rsync group.
+
+Finally, options may be specified after a colon (:).  The options allow you to
+"deny" a user or a group, set the access to "ro" (read-only), or set the access
+to "rw" (read/write).  Setting an auth-rule-specific ro/rw setting overrides
+the module's "read only" setting.
+
+Be sure to put the rules in the order you want them to be matched, because the
+checking stops at the first matching user or group, and that is the only auth
+that is checked.  For example:
+
+verb(  auth users = joe:deny @guest:deny admin:rw @rsync:ro susan joe sam )
+
+In the above rule, user joe will be denied access no matter what.  Any user
+that is in the group "guest" is also denied access.  The user "admin" gets
+access in read/write mode, but only if the admin user is not in group "guest"
+(because the admin user-matching rule would never be reached if the user is in
+group "guest").  Any other user who is in group "rsync" will get read-only
+access.  Finally, users susan, joe, and sam get the ro/rw setting of the
+module, but only if the user didn't match an earlier group-matching rule.
+
+See the description of the secrets file for how you can have per-user passwords
+as well as per-group passwords.  It also explains how a user can authenticate
+using their user password or (when applicable) a group password, depending on
+what rule is being authenticated.
+
 See also the section entitled "USING RSYNC-DAEMON FEATURES VIA A REMOTE
 SHELL CONNECTION" in bf(rsync)(1) for information on how handle an
 rsyncd.conf-level username that differs from the remote-shell-level
 username when using a remote shell to connect to an rsync daemon.
 
-dit(bf(secrets file)) This parameter specifies the name of
-a file that contains the username:password pairs used for
-authenticating this module. This file is only consulted if the "auth
-users" parameter is specified. The file is line based and contains
-username:password pairs separated by a single colon. Any line starting
-with a hash (#) is considered a comment and is skipped. The passwords
-can contain any characters but be warned that many operating systems
-limit the length of passwords that can be typed at the client end, so
-you may find that passwords longer than 8 characters don't work.
+dit(bf(secrets file)) This parameter specifies the name of a file that contains
+the username:password and/or @groupname:password pairs used for authenticating
+this module. This file is only consulted if the "auth users" parameter is
+specified.  The file is line-based and contains one name:password pair per
+line.  Any line has a hash (#) as the very first character on the line is
+considered a comment and is skipped.  The passwords can contain any characters
+but be warned that many operating systems limit the length of passwords that
+can be typed at the client end, so you may find that passwords longer than 8
+characters don't work.
+
+The use of group-specific lines are only relevant when the module is being
+authorized using a matching "@groupname" rule.  When that happens, the user
+can be authorized via either their "username:password" line or the
+"@groupname:password" line for the group that triggered the authentication.
+
+It is up to you what kind of password entries you want to include, either
+users, groups, or both.  The use of group rules in "auth users" does not
+require that you specify a group password if you do not want to use shared
+passwords.
 
 There is no default for the "secrets file" parameter, you must choose a name
 (such as tt(/etc/rsyncd.secrets)).  The file must normally not be readable
-by "other"; see "strict modes".
+by "other"; see "strict modes".  If the file is not found or is rejected, no
+logins for a "user auth" module will be possible.
 
 dit(bf(strict modes)) This parameter determines whether or not
 the permissions on the secrets file will be checked.  If "strict modes" is
 true, then the secrets file must not be readable by any user ID other
 than the one that the rsync daemon is running under.  If "strict modes" is
 false, the check is not performed.  The default is true.  This parameter
@@ -440,18 +539,20 @@
   and n is the number of one bits in the netmask.  All IP addresses which
   match the masked IP address will be allowed in.
   it() an address/mask in the form ipaddr/maskaddr where ipaddr is the
   IP address and maskaddr is the netmask in dotted decimal notation for IPv4,
   or similar for IPv6, e.g. ffff:ffff:ffff:ffff:: instead of /64. All IP
   addresses which match the masked IP address will be allowed in.
-  it() a hostname. The hostname as determined by a reverse lookup will
-  be matched (case insensitive) against the pattern. Only an exact
-  match is allowed in.
-  it() a hostname pattern using wildcards. These are matched using the
-  same rules as normal unix filename matching. If the pattern matches
-  then the client is allowed in.
+  it() a hostname pattern using wildcards. If the hostname of the connecting IP
+  (as determined by a reverse lookup) matches the wildcarded name (using the
+  same rules as normal unix filename matching), the client is allowed in.  This
+  only works if "reverse lookup" is enabled (the default).
+  it() a hostname. A plain hostname is matched against the reverse DNS of the
+  connecting IP (if "reverse lookup" is enabled), and/or the IP of the given
+  hostname is matched against the connecting IP (if "forward lookup" is
+  enabled, as it is by default).  Any match will be allowed in.
 ))
 
 Note IPv6 link-local addresses can have a scope in the address specification:
 
 quote(
 tt(    fe80::1%link1)nl()
@@ -473,12 +574,29 @@
 list of patterns that are matched against a connecting clients
 hostname and IP address. If the pattern matches then the connection is
 rejected. See the "hosts allow" parameter for more information.
 
 The default is no "hosts deny" parameter, which means all hosts can connect.
 
+dit(bf(reverse lookup)) Controls whether the daemon performs a reverse lookup
+on the client's IP address to determine its hostname, which is used for
+"hosts allow"/"hosts deny" checks and the "%h" log escape.  This is enabled by
+default, but you may wish to disable it to save time if you know the lookup will
+not return a useful result, in which case the daemon will use the name
+"UNDETERMINED" instead.
+
+If this parameter is enabled globally (even by default), rsync performs the
+lookup as soon as a client connects, so disabling it for a module will not
+avoid the lookup.  Thus, you probably want to disable it globally and then
+enable it for modules that need the information.
+
+dit(bf(forward lookup)) Controls whether the daemon performs a forward lookup
+on any hostname specified in an hosts allow/deny setting.  By default this is
+enabled, allowing the use of an explicit hostname that would not be returned
+by reverse DNS of the connecting IP.
+
 dit(bf(ignore errors)) This parameter tells rsyncd to
 ignore I/O errors on the daemon when deciding whether to run the delete
 phase of the transfer. Normally rsync skips the bf(--delete) step if any
 I/O errors have occurred in order to prevent disastrous deletion due
 to a temporary resource shortage or other I/O error. In some cases this
 test is counter productive so you can use this parameter to turn off this
@@ -499,29 +617,35 @@
 dit(bf(log format)) This parameter allows you to specify the
 format used for logging file transfers when transfer logging is enabled.
 The format is a text string containing embedded single-character escape
 sequences prefixed with a percent (%) character.  An optional numeric
 field width may also be specified between the percent and the escape
 letter (e.g. "bf(%-50n %8l %07p)").
+In addition, one or more apostrophes may be specified prior to a numerical
+escape to indicate that the numerical value should be made more human-readable.
+The 3 supported levels are the same as for the bf(--human-readable)
+command-line option, though the default is for human-readability to be off.
+Each added apostrophe increases the level (e.g. "bf(%''l %'b %f)").
 
 The default log format is "%o %h [%a] %m (%u) %f %l", and a "%t [%p] "
 is always prefixed when using the "log file" parameter.
 (A perl script that will summarize this default log format is included
 in the rsync source code distribution in the "support" subdirectory:
 rsyncstats.)
 
 The single-character escapes that are understood are as follows:
 
 quote(itemization(
-  it() %a the remote IP address
+  it() %a the remote IP address (only available for a daemon)
   it() %b the number of bytes actually transferred
   it() %B the permission bits of the file (e.g. rwxrwxrwt)
   it() %c the total size of the block checksums received for the basis file (only when sending)
+  it() %C the full-file MD5 checksum if bf(--checksum) is enabled or a file was transferred (only for protocol 30 or above).
   it() %f the filename (long form on sender; no trailing "/")
   it() %G the gid of the file (decimal) or "DEFAULT"
-  it() %h the remote host name
+  it() %h the remote host name (only available for a daemon)
   it() %i an itemized list of what is being updated
   it() %l the length of the file in bytes
   it() %L the string " -> SYMLINK", " => HARDLINK", or "" (where bf(SYMLINK) or bf(HARDLINK) is a filename)
   it() %m the module name
   it() %M the last-modified time of the file
   it() %n the filename (short form; trailing "/" on dir)
@@ -586,30 +710,38 @@
 of file suffixes that are not compressed by default.  Specifying a value
 for the "dont compress" parameter changes the default when the daemon is
 the sender.
 
 dit(bf(pre-xfer exec), bf(post-xfer exec)) You may specify a command to be run
 before and/or after the transfer.  If the bf(pre-xfer exec) command fails, the
-transfer is aborted before it begins.
+transfer is aborted before it begins.  Any output from the script on stdout (up
+to several KB) will be displayed to the user when aborting, but is NOT
+displayed if the script returns success.  Any output from the script on stderr
+goes to the daemon's stderr, which is typically discarded (though see
+--no-detatch option for a way to see the stderr output, which can assist with
+debugging).
 
 The following environment variables will be set, though some are
 specific to the pre-xfer or the post-xfer environment:
 
 quote(itemization(
   it() bf(RSYNC_MODULE_NAME): The name of the module being accessed.
   it() bf(RSYNC_MODULE_PATH): The path configured for the module.
   it() bf(RSYNC_HOST_ADDR): The accessing host's IP address.
   it() bf(RSYNC_HOST_NAME): The accessing host's name.
   it() bf(RSYNC_USER_NAME): The accessing user's name (empty if no user).
   it() bf(RSYNC_PID): A unique number for this transfer.
   it() bf(RSYNC_REQUEST): (pre-xfer only) The module/path info specified
-  by the user (note that the user can specify multiple source files,
-  so the request can be something like "mod/path1 mod/path2", etc.).
+  by the user.  Note that the user can specify multiple source files,
+  so the request can be something like "mod/path1 mod/path2", etc.
   it() bf(RSYNC_ARG#): (pre-xfer only) The pre-request arguments are set
-  in these numbered values. RSYNC_ARG0 is always "rsyncd", and the last
-  value contains a single period.
+  in these numbered values. RSYNC_ARG0 is always "rsyncd", followed by
+  the options that were used in RSYNC_ARG1, and so on.  There will be a
+  value of "." indicating that the options are done and the path args
+  are beginning -- these contain similar information to RSYNC_REQUEST,
+  but with values separated and the module name stripped off.
   it() bf(RSYNC_EXIT_STATUS): (post-xfer only) the server side's exit value.
   This will be 0 for a successful run, a positive value for an error that the
   server generated, or a -1 if rsync failed to exit properly.  Note that an
   error that occurs on the client side does not currently get sent to the
   server side, so this is not the final exit status for the whole transfer.
   it() bf(RSYNC_RAW_STATUS): (post-xfer only) the raw exit value from code(waitpid()).
@@ -618,12 +750,68 @@
 Even though the commands can be associated with a particular module, they
 are run using the permissions of the user that started the daemon (not the
 module's uid/gid setting) without any chroot restrictions.
 
 enddit()
 
+manpagesection(CONFIG DIRECTIVES)
+
+There are currently two config directives available that allow a config file to
+incorporate the contents of other files:  bf(&include) and bf(&merge).  Both
+allow a reference to either a file or a directory.  They differ in how
+segregated the file's contents are considered to be.
+
+The bf(&include) directive treats each file as more distinct, with each one
+inheriting the defaults of the parent file, starting the parameter parsing
+as globals/defaults, and leaving the defaults unchanged for the parsing of
+the rest of the parent file.
+
+The bf(&merge) directive, on the other hand, treats the file's contents as
+if it were simply inserted in place of the directive, and thus it can set
+parameters in a module started in another file, can affect the defaults for
+other files, etc.
+
+When an bf(&include) or bf(&merge) directive refers to a directory, it will read
+in all the bf(*.conf) or bf(*.inc) files (respectively) that are contained inside
+that directory (without any
+recursive scanning), with the files sorted into alpha order.  So, if you have a
+directory named "rsyncd.d" with the files "foo.conf", "bar.conf", and
+"baz.conf" inside it, this directive:
+
+verb(    &include /path/rsyncd.d )
+
+would be the same as this set of directives:
+
+verb(    &include /path/rsyncd.d/bar.conf
+    &include /path/rsyncd.d/baz.conf
+    &include /path/rsyncd.d/foo.conf )
+
+except that it adjusts as files are added and removed from the directory.
+
+The advantage of the bf(&include) directive is that you can define one or more
+modules in a separate file without worrying about unintended side-effects
+between the self-contained module files.
+
+The advantage of the bf(&merge) directive is that you can load config snippets
+that can be included into multiple module definitions, and you can also set
+global values that will affect connections (such as bf(motd file)), or globals
+that will affect other include files.
+
+For example, this is a useful /etc/rsyncd.conf file:
+
+verb(    port = 873
+    log file = /var/log/rsync.log
+    pid file = /var/lock/rsync.lock
+
+    &merge /etc/rsyncd.d
+    &include /etc/rsyncd.d )
+
+This would merge any /etc/rsyncd.d/*.inc files (for global values that should
+stay in effect), and then include any /etc/rsyncd.d/*.conf files (defining
+modules without any global-value cross-talk).
+
 manpagesection(AUTHENTICATION STRENGTH)
 
 The authentication protocol used in rsync is a 128 bit MD4 based
 challenge response system. This is fairly weak protection, though (with
 at least one brute-force hash-finding algorithm publicly available), so
 if you want really top-quality security, then I recommend that you run
@@ -703,17 +891,17 @@
 
 Please report bugs! The rsync bug tracking system is online at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 3.0.9 of rsync.
+This man page is current for version 3.1.0 of rsync.
 
 manpagesection(CREDITS)
 
-rsync is distributed under the GNU public license.  See the file
+rsync is distributed under the GNU General Public License.  See the file
 COPYING for details.
 
 The primary ftp site for rsync is
 url(ftp://rsync.samba.org/pub/rsync)(ftp://rsync.samba.org/pub/rsync).
 
 A WEB site is available at
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsync.h	2011-02-22 03:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsync.h	2013-09-29 04:55:54.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Copyright (C) 1996, 2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2008 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -58,12 +58,13 @@
 #define XMIT_SAME_DEV_pre30 (1<<10)	/* protocols 28 - 29  */
 #define XMIT_USER_NAME_FOLLOWS (1<<10)	/* protocols 30 - now */
 #define XMIT_RDEV_MINOR_8_pre30 (1<<11)	/* protocols 28 - 29  */
 #define XMIT_GROUP_NAME_FOLLOWS (1<<11) /* protocols 30 - now */
 #define XMIT_HLINK_FIRST (1<<12)	/* protocols 30 - now (HLINKED files only) */
 #define XMIT_IO_ERROR_ENDLIST (1<<12)	/* protocols 31*- now (w/XMIT_EXTENDED_FLAGS) (also protocol 30 w/'f' compat flag) */
+#define XMIT_MOD_NSEC (1<<13)		/* protocols 31 - now */
 
 /* These flags are used in the live flist data. */
 
 #define FLAG_TOP_DIR (1<<0)	/* sender/receiver/generator */
 #define FLAG_OWNED_BY_US (1<<0) /* generator: set by make_file() for aux flists only */
 #define FLAG_FILE_SENT (1<<1)	/* sender/receiver/generator */
@@ -78,12 +79,13 @@
 #define FLAG_IMPLIED_DIR (1<<6)	/* sender/receiver/generator (dirs only) */
 #define FLAG_HLINK_LAST (1<<7)	/* receiver/generator */
 #define FLAG_HLINK_DONE (1<<8)	/* receiver/generator (checked on all types) */
 #define FLAG_LENGTH64 (1<<9)	/* sender/receiver/generator */
 #define FLAG_SKIP_GROUP (1<<10)	/* receiver/generator */
 #define FLAG_TIME_FAILED (1<<11)/* generator */
+#define FLAG_MOD_NSEC (1<<12)	/* sender/receiver/generator */
 
 /* These flags are passed to functions but not stored. */
 
 #define FLAG_DIVERT_DIRS (1<<16)   /* sender, but must be unique */
 
 /* These flags are for get_dirlist(). */
@@ -93,13 +95,13 @@
 #define BITS_SET(val,bits) (((val) & (bits)) == (bits))
 #define BITS_SETnUNSET(val,onbits,offbits) (((val) & ((onbits)|(offbits))) == (onbits))
 #define BITS_EQUAL(b1,b2,mask) (((unsigned)(b1) & (unsigned)(mask)) \
 			     == ((unsigned)(b2) & (unsigned)(mask)))
 
 /* update this if you make incompatible changes */
-#define PROTOCOL_VERSION 30
+#define PROTOCOL_VERSION 31
 
 /* This is used when working on a new protocol version in CVS, and should
  * be a new non-zero value for each CVS change that affects the protocol.
  * It must ALWAYS be 0 when the protocol goes final (and NEVER before)! */
 #define SUBPROTOCOL_VERSION 0
 
@@ -121,26 +123,29 @@
  * MAX_PROTOCOL_VERSION. */
 
 #define MIN_PROTOCOL_VERSION 20
 #define OLD_PROTOCOL_VERSION 25
 #define MAX_PROTOCOL_VERSION 40
 
-#define FILECNT_LOOKAHEAD 1000
+#define MIN_FILECNT_LOOKAHEAD 1000
+#define MAX_FILECNT_LOOKAHEAD 10000
 
 #define RSYNC_PORT 873
 
 #define SPARSE_WRITE_SIZE (1024)
 #define WRITE_SIZE (32*1024)
 #define CHUNK_SIZE (32*1024)
 #define MAX_MAP_SIZE (256*1024)
-#define IO_BUFFER_SIZE (4092)
+#define IO_BUFFER_SIZE (32*1024)
 #define MAX_BLOCK_SIZE ((int32)1 << 17)
 
 /* For compatibility with older rsyncs */
 #define OLD_MAX_BLOCK_SIZE ((int32)1 << 29)
 
+#define ROUND_UP_1024(siz) ((siz) & (1024-1) ? ((siz) | (1024-1)) + 1 : (siz))
+
 #define IOERR_GENERAL	(1<<0) /* For backward compatibility, this must == 1 */
 #define IOERR_VANISHED	(1<<1)
 #define IOERR_DEL_LIMIT (1<<2)
 
 #define MAX_ARGS 1000
 #define MAX_BASIS_DIRS 20
@@ -228,26 +233,52 @@
 	MSG_ERROR_XFER=FERROR_XFER, MSG_INFO=FINFO, /* remote logging */
 	MSG_ERROR=FERROR, MSG_WARNING=FWARNING, /* protocol-30 remote logging */
 	MSG_ERROR_SOCKET=FERROR_SOCKET, /* sibling logging */
 	MSG_ERROR_UTF8=FERROR_UTF8, /* sibling logging */
 	MSG_LOG=FLOG, MSG_CLIENT=FCLIENT, /* sibling logging */
 	MSG_REDO=9,	/* reprocess indicated flist index */
-	MSG_FLIST=20,	/* extra file list over sibling socket */
-	MSG_FLIST_EOF=21,/* we've transmitted all the file lists */
+	MSG_STATS=10,	/* message has stats data for generator */
 	MSG_IO_ERROR=22,/* the sending side had an I/O error */
-	MSG_NOOP=42,	/* a do-nothing message */
+	MSG_IO_TIMEOUT=33,/* tell client about a daemon's timeout value */
+	MSG_NOOP=42,	/* a do-nothing message (legacy protocol-30 only) */
+	MSG_ERROR_EXIT=86, /* synchronize an error exit (siblings and protocol >= 31) */
 	MSG_SUCCESS=100,/* successfully updated indicated flist index */
 	MSG_DELETED=101,/* successfully deleted a file on receiving side */
 	MSG_NO_SEND=102,/* sender failed to open a file we wanted */
-	MSG_DONE=86	/* current phase is done */
 };
 
 #define NDX_DONE -1
 #define NDX_FLIST_EOF -2
+#define NDX_DEL_STATS -3
 #define NDX_FLIST_OFFSET -101
 
+/* For calling delete_item() and delete_dir_contents(). */
+#define DEL_NO_UID_WRITE 	(1<<0) /* file/dir has our uid w/o write perm */
+#define DEL_RECURSE		(1<<1) /* if dir, delete all contents */
+#define DEL_DIR_IS_EMPTY	(1<<2) /* internal delete_FUNCTIONS use only */
+#define DEL_FOR_FILE		(1<<3) /* making room for a replacement file */
+#define DEL_FOR_DIR		(1<<4) /* making room for a replacement dir */
+#define DEL_FOR_SYMLINK 	(1<<5) /* making room for a replacement symlink */
+#define DEL_FOR_DEVICE		(1<<6) /* making room for a replacement device */
+#define DEL_FOR_SPECIAL 	(1<<7) /* making room for a replacement special */
+#define DEL_FOR_BACKUP	 	(1<<8) /* the delete is for a backup operation */
+
+#define DEL_MAKE_ROOM (DEL_FOR_FILE|DEL_FOR_DIR|DEL_FOR_SYMLINK|DEL_FOR_DEVICE|DEL_FOR_SPECIAL)
+
+enum delret {
+	DR_SUCCESS = 0, DR_FAILURE, DR_AT_LIMIT, DR_NOT_EMPTY
+};
+
+/* Defines for make_path() */
+#define MKP_DROP_NAME		(1<<0) /* drop trailing filename or trailing slash */
+#define MKP_SKIP_SLASH		(1<<1) /* skip one or more leading slashes */
+
+/* Defines for maybe_send_keepalive() */
+#define MSK_ALLOW_FLUSH 	(1<<0)
+#define MSK_ACTIVE_RECEIVER 	(1<<1)
+
 #include "errcode.h"
 
 #include "config.h"
 
 /* The default RSYNC_RSH is always set in config.h. */
 
@@ -337,24 +368,32 @@
 #include <errno.h>
 
 #ifdef HAVE_UTIME_H
 #include <utime.h>
 #endif
 
-#if defined HAVE_LUTIMES || defined HAVE_UTIMENSAT
+#if defined HAVE_UTIMENSAT || defined HAVE_LUTIMES
 #define CAN_SET_SYMLINK_TIMES 1
 #endif
 
 #if defined HAVE_LCHOWN || defined CHOWN_MODIFIES_SYMLINK
 #define CAN_CHOWN_SYMLINK 1
 #endif
 
 #if defined HAVE_LCHMOD || defined HAVE_SETATTRLIST
 #define CAN_CHMOD_SYMLINK 1
 #endif
 
+#ifdef HAVE_UTIMENSAT
+#ifdef HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
+#define ST_MTIME_NSEC st_mtim.tv_nsec
+#elif defined(HAVE_STRUCT_STAT_ST_MTIMENSEC)
+#define ST_MTIME_NSEC st_mtimensec
+#endif
+#endif
+
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
 
 #ifdef HAVE_SYS_MODE_H
 /* apparently AIX needs this for S_ISLNK */
@@ -570,13 +609,13 @@
 #endif
 
 struct hashtable {
 	void *nodes;
 	int32 size, entries;
 	uint32 node_size;
-	int key64;
+	short key64;
 };
 
 struct ht_int32_node {
 	void *data;
 	int32 key;
 };
@@ -631,12 +670,29 @@
 #endif
 
 #if HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|HAVE_HPUX_ACLS
 #define ACLS_NEED_MASK 1
 #endif
 
+#if defined HAVE_FALLOCATE || HAVE_SYS_FALLOCATE
+#ifdef HAVE_LINUX_FALLOC_H
+#include <linux/falloc.h>
+#endif
+#ifdef FALLOC_FL_KEEP_SIZE
+#define SUPPORT_PREALLOCATION 1
+#elif defined HAVE_FTRUNCATE
+#define SUPPORT_PREALLOCATION 1
+#define PREALLOCATE_NEEDS_TRUNCATE 1
+#endif
+#else /* !fallocate */
+#if defined HAVE_EFFICIENT_POSIX_FALLOCATE && defined HAVE_FTRUNCATE
+#define SUPPORT_PREALLOCATION 1
+#define PREALLOCATE_NEEDS_TRUNCATE 1
+#endif
+#endif
+
 union file_extras {
 	int32 num;
 	uint32 unum;
 };
 
 struct file_struct {
@@ -662,24 +718,28 @@
 #define DIRNODE_EXTRA_CNT 3
 #define SUM_EXTRA_CNT ((MAX_DIGEST_LEN + EXTRA_LEN - 1) / EXTRA_LEN)
 
 #define REQ_EXTRA(f,ndx) ((union file_extras*)(f) - (ndx))
 #define OPT_EXTRA(f,bump) ((union file_extras*)(f) - file_extra_cnt - 1 - (bump))
 
+#define NSEC_BUMP(f) ((f)->flags & FLAG_MOD_NSEC ? 1 : 0)
 #define LEN64_BUMP(f) ((f)->flags & FLAG_LENGTH64 ? 1 : 0)
+#define START_BUMP(f) (NSEC_BUMP(f) + LEN64_BUMP(f))
 #define HLINK_BUMP(f) ((f)->flags & (FLAG_HLINKED|FLAG_HLINK_DONE) ? inc_recurse+1 : 0)
 #define ACL_BUMP(f) (acls_ndx ? 1 : 0)
 
 /* The length applies to all items. */
 #if SIZEOF_INT64 < 8
 #define F_LENGTH(f) ((int64)(f)->len32)
 #else
 #define F_LENGTH(f) ((int64)(f)->len32 + ((f)->flags & FLAG_LENGTH64 \
-		   ? (int64)OPT_EXTRA(f, 0)->unum << 32 : 0))
+		   ? (int64)OPT_EXTRA(f, NSEC_BUMP(f))->unum << 32 : 0))
 #endif
 
+#define F_MOD_NSEC(f) ((f)->flags & FLAG_MOD_NSEC ? OPT_EXTRA(f, 0)->unum : 0)
+
 /* If there is a symlink string, it is always right after the basename */
 #define F_SYMLINK(f) ((f)->basename + strlen((f)->basename) + 1)
 
 /* The sending side always has this available: */
 #define F_PATHNAME(f) (*(const char**)REQ_EXTRA(f, PTR_EXTRA_CNT))
 
@@ -691,28 +751,27 @@
 #define F_GROUP(f) REQ_EXTRA(f, gid_ndx)->unum
 #define F_ACL(f) REQ_EXTRA(f, acls_ndx)->num
 #define F_XATTR(f) REQ_EXTRA(f, xattrs_ndx)->num
 #define F_NDX(f) REQ_EXTRA(f, unsort_ndx)->num
 
 /* These items are per-entry optional: */
-#define F_HL_GNUM(f) OPT_EXTRA(f, LEN64_BUMP(f))->num /* non-dirs */
-#define F_HL_PREV(f) OPT_EXTRA(f, LEN64_BUMP(f)+inc_recurse)->num /* non-dirs */
-#define F_DIR_NODE_P(f) (&OPT_EXTRA(f, LEN64_BUMP(f) \
+#define F_HL_GNUM(f) OPT_EXTRA(f, START_BUMP(f))->num /* non-dirs */
+#define F_HL_PREV(f) OPT_EXTRA(f, START_BUMP(f)+inc_recurse)->num /* non-dirs */
+#define F_DIR_NODE_P(f) (&OPT_EXTRA(f, START_BUMP(f) \
 				+ DIRNODE_EXTRA_CNT - 1)->num) /* sender dirs */
-#define F_DIR_RELNAMES_P(f) (&OPT_EXTRA(f, LEN64_BUMP(f) + DIRNODE_EXTRA_CNT \
+#define F_DIR_RELNAMES_P(f) (&OPT_EXTRA(f, START_BUMP(f) + DIRNODE_EXTRA_CNT \
 				+ PTR_EXTRA_CNT - 1)->num) /* sender dirs */
-#define F_DIR_DEFACL(f) OPT_EXTRA(f, LEN64_BUMP(f))->unum /* receiver dirs */
-#define F_DIR_DEV_P(f) (&OPT_EXTRA(f, LEN64_BUMP(f) + ACL_BUMP(f) \
+#define F_DIR_DEFACL(f) OPT_EXTRA(f, START_BUMP(f))->unum /* receiver dirs */
+#define F_DIR_DEV_P(f) (&OPT_EXTRA(f, START_BUMP(f) + ACL_BUMP(f) \
 				+ DEV_EXTRA_CNT - 1)->unum) /* receiver dirs */
 
-/* This optional item might follow an F_HL_*() item.
- * (Note: a device doesn't need to check LEN64_BUMP(f).) */
-#define F_RDEV_P(f) (&OPT_EXTRA(f, HLINK_BUMP(f) + DEV_EXTRA_CNT - 1)->unum)
+/* This optional item might follow an F_HL_*() item. */
+#define F_RDEV_P(f) (&OPT_EXTRA(f, START_BUMP(f) + HLINK_BUMP(f) + DEV_EXTRA_CNT - 1)->unum)
 
 /* The sum is only present on regular files. */
-#define F_SUM(f) ((char*)OPT_EXTRA(f, LEN64_BUMP(f) + HLINK_BUMP(f) \
+#define F_SUM(f) ((char*)OPT_EXTRA(f, START_BUMP(f) + HLINK_BUMP(f) \
 				    + SUM_EXTRA_CNT - 1))
 
 /* Some utility defines: */
 #define F_IS_ACTIVE(f) (f)->basename[0]
 #define F_IS_HLINKED(f) ((f)->flags & FLAG_HLINKED)
 
@@ -791,66 +850,66 @@
 	int32 p_len;		/* Latest (rounded) window size		*/
 	int32 def_window_size;	/* Default window size			*/
 	int fd;			/* File Descriptor			*/
 	int status;		/* first errno from read errors		*/
 };
 
-#define MATCHFLG_WILD		(1<<0) /* pattern has '*', '[', and/or '?' */
-#define MATCHFLG_WILD2		(1<<1) /* pattern has '**' */
-#define MATCHFLG_WILD2_PREFIX	(1<<2) /* pattern starts with "**" */
-#define MATCHFLG_WILD3_SUFFIX	(1<<3) /* pattern ends with "***" */
-#define MATCHFLG_ABS_PATH	(1<<4) /* path-match on absolute path */
-#define MATCHFLG_INCLUDE	(1<<5) /* this is an include, not an exclude */
-#define MATCHFLG_DIRECTORY	(1<<6) /* this matches only directories */
-#define MATCHFLG_WORD_SPLIT	(1<<7) /* split rules on whitespace */
-#define MATCHFLG_NO_INHERIT	(1<<8) /* don't inherit these rules */
-#define MATCHFLG_NO_PREFIXES	(1<<9) /* parse no prefixes from patterns */
-#define MATCHFLG_MERGE_FILE	(1<<10)/* specifies a file to merge */
-#define MATCHFLG_PERDIR_MERGE	(1<<11)/* merge-file is searched per-dir */
-#define MATCHFLG_EXCLUDE_SELF	(1<<12)/* merge-file name should be excluded */
-#define MATCHFLG_FINISH_SETUP	(1<<13)/* per-dir merge file needs setup */
-#define MATCHFLG_NEGATE 	(1<<14)/* rule matches when pattern does not */
-#define MATCHFLG_CVS_IGNORE	(1<<15)/* rule was -C or :C */
-#define MATCHFLG_SENDER_SIDE	(1<<16)/* rule applies to the sending side */
-#define MATCHFLG_RECEIVER_SIDE	(1<<17)/* rule applies to the receiving side */
-#define MATCHFLG_CLEAR_LIST 	(1<<18)/* this item is the "!" token */
-#define MATCHFLG_PERISHABLE	(1<<19)/* perishable if parent dir goes away */
-
-#define MATCHFLGS_FROM_CONTAINER (MATCHFLG_ABS_PATH | MATCHFLG_INCLUDE \
-				| MATCHFLG_DIRECTORY | MATCHFLG_SENDER_SIDE \
-				| MATCHFLG_NEGATE | MATCHFLG_RECEIVER_SIDE \
-				| MATCHFLG_PERISHABLE)
+#define FILTRULE_WILD		(1<<0) /* pattern has '*', '[', and/or '?' */
+#define FILTRULE_WILD2		(1<<1) /* pattern has '**' */
+#define FILTRULE_WILD2_PREFIX	(1<<2) /* pattern starts with "**" */
+#define FILTRULE_WILD3_SUFFIX	(1<<3) /* pattern ends with "***" */
+#define FILTRULE_ABS_PATH	(1<<4) /* path-match on absolute path */
+#define FILTRULE_INCLUDE	(1<<5) /* this is an include, not an exclude */
+#define FILTRULE_DIRECTORY	(1<<6) /* this matches only directories */
+#define FILTRULE_WORD_SPLIT	(1<<7) /* split rules on whitespace */
+#define FILTRULE_NO_INHERIT	(1<<8) /* don't inherit these rules */
+#define FILTRULE_NO_PREFIXES	(1<<9) /* parse no prefixes from patterns */
+#define FILTRULE_MERGE_FILE	(1<<10)/* specifies a file to merge */
+#define FILTRULE_PERDIR_MERGE	(1<<11)/* merge-file is searched per-dir */
+#define FILTRULE_EXCLUDE_SELF	(1<<12)/* merge-file name should be excluded */
+#define FILTRULE_FINISH_SETUP	(1<<13)/* per-dir merge file needs setup */
+#define FILTRULE_NEGATE 	(1<<14)/* rule matches when pattern does not */
+#define FILTRULE_CVS_IGNORE	(1<<15)/* rule was -C or :C */
+#define FILTRULE_SENDER_SIDE	(1<<16)/* rule applies to the sending side */
+#define FILTRULE_RECEIVER_SIDE	(1<<17)/* rule applies to the receiving side */
+#define FILTRULE_CLEAR_LIST	(1<<18)/* this item is the "!" token */
+#define FILTRULE_PERISHABLE	(1<<19)/* perishable if parent dir goes away */
+
+#define FILTRULES_SIDES (FILTRULE_SENDER_SIDE | FILTRULE_RECEIVER_SIDE)
 
-struct filter_struct {
+typedef struct filter_struct {
 	struct filter_struct *next;
 	char *pattern;
-	uint32 match_flags;
+	uint32 rflags;
 	union {
 		int slash_cnt;
 		struct filter_list_struct *mergelist;
 	} u;
-};
+} filter_rule;
 
-struct filter_list_struct {
-	struct filter_struct *head;
-	struct filter_struct *tail;
+typedef struct filter_list_struct {
+	filter_rule *head;
+	filter_rule *tail;
+	filter_rule *parent_dirscan_head;
 	char *debug_type;
-};
+} filter_rule_list;
 
 struct stats {
 	int64 total_size;
 	int64 total_transferred_size;
 	int64 total_written;
 	int64 total_read;
 	int64 literal_data;
 	int64 matched_data;
 	int64 flist_buildtime;
 	int64 flist_xfertime;
 	int64 flist_size;
-	int num_files;
-	int num_transferred_files;
+	int num_files, num_dirs, num_symlinks, num_devices, num_specials;
+	int created_files, created_dirs, created_symlinks, created_devices, created_specials;
+	int deleted_files, deleted_dirs, deleted_symlinks, deleted_devices, deleted_specials;
+	int xferred_files;
 };
 
 struct chmod_mode_struct;
 
 struct flist_ndx_item {
 	struct flist_ndx_item *next;
@@ -879,19 +938,28 @@
 	size_t pos;  /* pos = read pos in the buf */
 	size_t len;  /* len = chars following pos */
 	size_t size; /* size = total space in buf */
 } xbuf;
 
 #define INIT_XBUF(xb, str, ln, sz) (xb).buf = (str), (xb).len = (ln), (xb).size = (sz), (xb).pos = 0
-#define INIT_XBUF_STRLEN(xb, str) (xb).buf = (str), (xb).len = strlen((xb).buf), (xb).size = (-1), (xb).pos = 0
+#define INIT_XBUF_STRLEN(xb, str) (xb).buf = (str), (xb).len = strlen((xb).buf), (xb).size = (size_t)-1, (xb).pos = 0
 /* This one is used to make an output xbuf based on a char[] buffer: */
 #define INIT_CONST_XBUF(xb, bf) (xb).buf = (bf), (xb).size = sizeof (bf), (xb).len = (xb).pos = 0
 
 #define ICB_EXPAND_OUT (1<<0)
 #define ICB_INCLUDE_BAD (1<<1)
 #define ICB_INCLUDE_INCOMPLETE (1<<2)
+#define ICB_CIRCULAR_OUT (1<<3)
+#define ICB_INIT (1<<4)
+
+#define IOBUF_KEEP_BUFS 0
+#define IOBUF_FREE_BUFS 1
+
+#define MPLX_SWITCHING IOBUF_KEEP_BUFS
+#define MPLX_ALL_DONE IOBUF_FREE_BUFS
+#define MPLX_TO_BUFFERED 2
 
 #define RL_EOL_NULLS (1<<0)
 #define RL_DUMP_COMMENTS (1<<1)
 #define RL_CONVERT (1<<2)
 
 typedef struct {
@@ -973,12 +1041,15 @@
 #ifndef HAVE_ERRNO_DECL
 extern int errno;
 #endif
 
 #ifdef HAVE_READLINK
 #define SUPPORT_LINKS 1
+#if !defined NO_SYMLINK_XATTRS && !defined NO_SYMLINK_USER_XATTRS
+#define do_readlink(path, buf, bufsiz) readlink(path, buf, bufsiz)
+#endif
 #endif
 #ifdef HAVE_LINK
 #define SUPPORT_HARD_LINKS 1
 #endif
 
 #ifdef HAVE_SIGACTION
@@ -1152,19 +1223,69 @@
 
 #ifdef FORCE_FD_ZERO_MEMSET
 #undef FD_ZERO
 #define FD_ZERO(fdsetp) memset(fdsetp, 0, sizeof (fd_set))
 #endif
 
-extern int verbose;
+extern short info_levels[], debug_levels[];
+
+#define INFO_GTE(flag, lvl) (info_levels[INFO_##flag] >= (lvl))
+#define INFO_EQ(flag, lvl) (info_levels[INFO_##flag] == (lvl))
+#define DEBUG_GTE(flag, lvl) (debug_levels[DEBUG_##flag] >= (lvl))
+#define DEBUG_EQ(flag, lvl) (debug_levels[DEBUG_##flag] == (lvl))
+
+#define INFO_BACKUP 0
+#define INFO_COPY (INFO_BACKUP+1)
+#define INFO_DEL (INFO_COPY+1)
+#define INFO_FLIST (INFO_DEL+1)
+#define INFO_MISC (INFO_FLIST+1)
+#define INFO_MOUNT (INFO_MISC+1)
+#define INFO_NAME (INFO_MOUNT+1)
+#define INFO_PROGRESS (INFO_NAME+1)
+#define INFO_REMOVE (INFO_PROGRESS+1)
+#define INFO_SKIP (INFO_REMOVE+1)
+#define INFO_STATS (INFO_SKIP+1)
+#define INFO_SYMSAFE (INFO_STATS+1)
+
+#define COUNT_INFO (INFO_SYMSAFE+1)
+
+#define DEBUG_ACL 0
+#define DEBUG_BACKUP (DEBUG_ACL+1)
+#define DEBUG_BIND (DEBUG_BACKUP+1)
+#define DEBUG_CHDIR (DEBUG_BIND+1)
+#define DEBUG_CONNECT (DEBUG_CHDIR+1)
+#define DEBUG_CMD (DEBUG_CONNECT+1)
+#define DEBUG_DEL (DEBUG_CMD+1)
+#define DEBUG_DELTASUM (DEBUG_DEL+1)
+#define DEBUG_DUP (DEBUG_DELTASUM+1)
+#define DEBUG_EXIT (DEBUG_DUP+1)
+#define DEBUG_FILTER (DEBUG_EXIT+1)
+#define DEBUG_FLIST (DEBUG_FILTER+1)
+#define DEBUG_FUZZY (DEBUG_FLIST+1)
+#define DEBUG_GENR (DEBUG_FUZZY+1)
+#define DEBUG_HASH (DEBUG_GENR+1)
+#define DEBUG_HLINK (DEBUG_HASH+1)
+#define DEBUG_ICONV (DEBUG_HLINK+1)
+#define DEBUG_IO (DEBUG_ICONV+1)
+#define DEBUG_OWN (DEBUG_IO+1)
+#define DEBUG_PROTO (DEBUG_OWN+1)
+#define DEBUG_RECV (DEBUG_PROTO+1)
+#define DEBUG_SEND (DEBUG_RECV+1)
+#define DEBUG_TIME (DEBUG_SEND+1)
+
+#define COUNT_DEBUG (DEBUG_TIME+1)
 
 #ifndef HAVE_INET_NTOP
 const char *inet_ntop(int af, const void *src, char *dst, size_t size);
 #endif
 
 #ifndef HAVE_INET_PTON
 int inet_pton(int af, const char *src, void *dst);
 #endif
 
+#ifndef HAVE_GETPASS
+char *getpass(const char *prompt);
+#endif
+
 #ifdef MAINTAINER_MODE
 const char *get_panic_action(void);
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0: rsync-ssl.in
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/rsync.yo	2011-09-24 00:13:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/rsync.yo	2013-09-29 04:55:54.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(23 Sep 2011)()()
+manpage(rsync)(1)(28 Sep 2013)()()
 manpagename(rsync)(a fast, versatile, remote (and local) file-copying tool)
 manpagesynopsis()
 
 verb(Local:  rsync [OPTION...] SRC... [DEST]
 
 Access via remote shell:
@@ -328,12 +328,15 @@
 
 manpagesection(OPTIONS SUMMARY)
 
 Here is a short summary of the options available in rsync. Please refer
 to the detailed description below for a complete description.  verb(
  -v, --verbose               increase verbosity
+     --info=FLAGS            fine-grained informational verbosity
+     --debug=FLAGS           fine-grained debug verbosity
+     --msgs2stderr           special output handling for debugging
  -q, --quiet                 suppress non-error messages
      --no-motd               suppress daemon-mode MOTD (see caveat)
  -c, --checksum              skip based on checksum, not mod-time & size
  -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)
      --no-OPTION             turn off an implied OPTION (e.g. --no-D)
  -r, --recursive             recurse into directories
@@ -348,12 +351,13 @@
      --append-verify         --append w/old data in file checksum
  -d, --dirs                  transfer directories without recursing
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            transform symlink into referent file/dir
      --copy-unsafe-links     only "unsafe" symlinks are transformed
      --safe-links            ignore symlinks that point outside the tree
+     --munge-links           munge symlinks to make them safer
  -k, --copy-dirlinks         transform symlink to dir into referent dir
  -K, --keep-dirlinks         treat symlinked dir on receiver as dir
  -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
  -E, --executability         preserve executability
      --chmod=CHMOD           affect file and/or directory permissions
@@ -363,15 +367,17 @@
  -g, --group                 preserve group
      --devices               preserve device files (super-user only)
      --specials              preserve special files
  -D                          same as --devices --specials
  -t, --times                 preserve modification times
  -O, --omit-dir-times        omit directories from --times
+ -J, --omit-link-times       omit symlinks from --times
      --super                 receiver attempts super-user activities
      --fake-super            store/recover privileged attrs using xattrs
  -S, --sparse                handle sparse files efficiently
+     --preallocate           allocate dest files before writing
  -n, --dry-run               perform a trial run with no changes made
  -W, --whole-file            copy files whole (w/o delta-xfer algorithm)
  -x, --one-file-system       don't cross filesystem boundaries
  -B, --block-size=SIZE       force a fixed checksum block-size
  -e, --rsh=COMMAND           specify the remote shell to use
      --rsync-path=PROGRAM    specify the rsync to run on remote machine
@@ -382,22 +388,27 @@
      --delete                delete extraneous files from dest dirs
      --delete-before         receiver deletes before xfer, not during
      --delete-during         receiver deletes during the transfer
      --delete-delay          find deletions during, delete after
      --delete-after          receiver deletes after transfer, not during
      --delete-excluded       also delete excluded files from dest dirs
+     --ignore-missing-args   ignore missing source args without error
+     --delete-missing-args   delete missing source args from destination
      --ignore-errors         delete even if there are I/O errors
      --force                 force deletion of dirs even if not empty
      --max-delete=NUM        don't delete more than NUM files
      --max-size=SIZE         don't transfer any file larger than SIZE
      --min-size=SIZE         don't transfer any file smaller than SIZE
      --partial               keep partially transferred files
      --partial-dir=DIR       put a partially transferred file into DIR
      --delay-updates         put all updated files into place at end
  -m, --prune-empty-dirs      prune empty directory chains from file-list
      --numeric-ids           don't map uid/gid values by user/group name
+     --usermap=STRING        custom username mapping
+     --groupmap=STRING       custom groupname mapping
+     --chown=USER:GROUP      simple username/groupname mapping
      --timeout=SECONDS       set I/O timeout in seconds
      --contimeout=SECONDS    set daemon connection timeout in seconds
  -I, --ignore-times          don't skip files that match size and time
      --size-only             skip files that match in size
      --modify-window=NUM     compare mod-times with reduced accuracy
  -T, --temp-dir=DIR          create temporary files in directory DIR
@@ -420,24 +431,26 @@
  -0, --from0                 all *from/filter files are delimited by 0s
  -s, --protect-args          no space-splitting; wildcard chars only
      --address=ADDRESS       bind address for outgoing socket to daemon
      --port=PORT             specify double-colon alternate port number
      --sockopts=OPTIONS      specify custom TCP options
      --blocking-io           use blocking I/O for the remote shell
+     --outbuf=N|L|B          set out buffering to None, Line, or Block
      --stats                 give some file-transfer stats
  -8, --8-bit-output          leave high-bit chars unescaped in output
  -h, --human-readable        output numbers in a human-readable format
      --progress              show progress during transfer
  -P                          same as --partial --progress
  -i, --itemize-changes       output a change-summary for all updates
+ -M, --remote-option=OPTION  send OPTION to the remote side only
      --out-format=FORMAT     output updates using the specified FORMAT
      --log-file=FILE         log what we're doing to the specified FILE
      --log-file-format=FMT   log updates using the specified FMT
      --password-file=FILE    read daemon-access password from FILE
      --list-only             list the files instead of copying them
-     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
+     --bwlimit=RATE          limit socket I/O bandwidth
      --write-batch=FILE      write a batched update to FILE
      --only-write-batch=FILE like --write-batch but w/o updating dest
      --read-batch=FILE       read a batched update from FILE
      --protocol=NUM          force an older protocol version to be used
      --iconv=CONVERT_SPEC    request charset conversion of filenames
      --checksum-seed=NUM     set block/file checksum seed (advanced)
@@ -447,14 +460,15 @@
 (-h) --help                  show this help (see below for -h comment))
 
 Rsync can also be run as a daemon, in which case the following options are
 accepted: verb(
      --daemon                run as an rsync daemon
      --address=ADDRESS       bind to the specified address
-     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
+     --bwlimit=RATE          limit socket I/O bandwidth
      --config=FILE           specify alternate rsyncd.conf file
+ -M, --dparam=OVERRIDE       override global daemon config parameter
      --no-detach             do not detach from the parent
      --port=PORT             listen on alternate port number
      --log-file=FILE         override the "log file" setting
      --log-file-format=FMT   override the "log format" setting
      --sockopts=OPTIONS      specify custom TCP options
  -v, --verbose               increase verbosity
@@ -489,20 +503,73 @@
 single bf(-v) will give you information about what files are being
 transferred and a brief summary at the end. Two bf(-v) options will give you
 information on what files are being skipped and slightly more
 information at the end. More than two bf(-v) options should only be used if
 you are debugging rsync.
 
-Note that the names of the transferred files that are output are done using
-a default bf(--out-format) of "%n%L", which tells you just the name of the
-file and, if the item is a link, where it points.  At the single bf(-v)
-level of verbosity, this does not mention when a file gets its attributes
-changed.  If you ask for an itemized list of changed attributes (either
-bf(--itemize-changes) or adding "%i" to the bf(--out-format) setting), the
-output (on the client) increases to mention all items that are changed in
-any way.  See the bf(--out-format) option for more details.
+In a modern rsync, the bf(-v) option is equivalent to the setting of groups
+of bf(--info) and bf(--debug) options.  You can choose to use these newer
+options in addition to, or in place of using bf(--verbose), as any
+fine-grained settings override the implied settings of bf(-v).  Both
+bf(--info) and bf(--debug) have a way to ask for help that tells you
+exactly what flags are set for each increase in verbosity.
+
+dit(bf(--info=FLAGS))
+This option lets you have fine-grained control over the
+information
+output you want to see.  An individual flag name may be followed by a level
+number, with 0 meaning to silence that output, 1 being the default output
+level, and higher numbers increasing the output of that flag (for those
+that support higher levels).  Use
+bf(--info=help)
+to see all the available flag names, what they output, and what flag names
+are added for each increase in the verbose level.  Some examples:
+
+verb(    rsync -a --info=progress2 src/ dest/
+    rsync -avv --info=stats2,misc1,flist0 src/ dest/ )
+
+Note that bf(--info=name)'s output is affected by the bf(--out-format) and
+bf(--itemize-changes) (bf(-i)) options.  See those options for more
+information on what is output and when.
+
+This option was added to 3.1.0, so an older rsync on the server side might
+reject your attempts at fine-grained control (if one or more flags needed
+to be send to the server and the server was too old to understand them).
+
+dit(bf(--debug=FLAGS))
+This option lets you have fine-grained control over the debug
+output you want to see.  An individual flag name may be followed by a level
+number, with 0 meaning to silence that output, 1 being the default output
+level, and higher numbers increasing the output of that flag (for those
+that support higher levels).  Use
+bf(--debug=help)
+to see all the available flag names, what they output, and what flag names
+are added for each increase in the verbose level.  Some examples:
+
+verb(    rsync -avvv --debug=none src/ dest/
+    rsync -avA --del --debug=del2,acl src/ dest/ )
+
+Note that some debug messages will only be output when bf(--msgs2stderr) is
+specified, especially those pertaining to I/O and buffer debugging.
+
+This option was added to 3.1.0, so an older rsync on the server side might
+reject your attempts at fine-grained control (if one or more flags needed
+to be send to the server and the server was too old to understand them).
+
+dit(bf(--msgs2stderr)) This option changes rsync to send all its output
+directly to stderr rather than to send messages to the client side via the
+protocol (which normally outputs info messages via stdout).  This is mainly
+intended for debugging in order to avoid changing the data sent via the
+protocol, since the extra protocol data can change what is being tested.
+Keep in mind that a daemon connection does not have a stderr channel to send
+messages back to the client side, so if you are doing any daemon-transfer
+debugging using this option, you should start up a daemon using bf(--no-detach)
+so that you can see the stderr output on the daemon side.
+
+This option has the side-effect of making stderr output get line-buffered so
+that the merging of the output of 3 programs happens in a more readable manner.
 
 dit(bf(-q, --quiet)) This option decreases the amount of information you
 are given during the transfer, notably suppressing information messages
 from the remote server. This option is useful when invoking rsync from
 cron.
 
@@ -835,12 +902,31 @@
 
 dit(bf(--safe-links)) This tells rsync to ignore any symbolic links
 which point outside the copied tree. All absolute symlinks are
 also ignored. Using this option in conjunction with bf(--relative) may
 give unexpected results.
 
+dit(bf(--munge-links)) This option tells rsync to (1) modify all symlinks on
+the receiving side in a way that makes them unusable but recoverable (see
+below), or (2) to unmunge symlinks on the sending side that had been stored in
+a munged state.  This is useful if you don't quite trust the source of the data
+to not try to slip in a symlink to a unexpected place.
+
+The way rsync disables the use of symlinks is to prefix each one with the
+string "/rsyncd-munged/".  This prevents the links from being used as long as
+that directory does not exist.  When this option is enabled, rsync will refuse
+to run if that path is a directory or a symlink to a directory.
+
+The option only affects the client side of the transfer, so if you need it to
+affect the server, specify it via bf(--remote-option).  (Note that in a local
+transfer, the client side is the sender.)
+
+This option has no affect on a daemon, since the daemon configures whether it
+wants munged symlinks via its "munge symlinks" parameter.  See also the
+"munge-symlinks" perl script in the support directory of the source code.
+
 dit(bf(-k, --copy-dirlinks)) This option causes the sending side to treat
 a symlink to a directory as though it were a real directory.  This is
 useful if you don't want symlinks to non-directories to be affected, as
 they would be using bf(--copy-links).
 
 Without this option, if the sending side has replaced a directory with a
@@ -1022,12 +1108,16 @@
 that all directories get marked set-gid, that no files are other-writable,
 that both are user-writable and group-writable, and that both have
 consistent executability across all bits:
 
 quote(--chmod=Dg+s,ug+w,Fo-w,+X)
 
+Using octal mode numbers is also allowed:
+
+quote(--chmod=D2775,F664)
+
 It is also legal to specify multiple bf(--chmod) options, as each
 additional option is just appended to the list of changes to make.
 
 See the bf(--perms) and bf(--executability) options for how the resulting
 permission value can be applied to the files in the transfer.
 
@@ -1074,12 +1164,15 @@
 
 dit(bf(-O, --omit-dir-times)) This tells rsync to omit directories when
 it is preserving modification times (see bf(--times)).  If NFS is sharing
 the directories on the receiving side, it is a good idea to use bf(-O).
 This option is inferred if you use bf(--backup) without bf(--backup-dir).
 
+dit(bf(-J, --omit-link-times)) This tells rsync to omit symlinks when
+it is preserving modification times (see bf(--times)).
+
 dit(bf(--super)) This tells the receiving side to attempt super-user
 activities even if the receiving rsync wasn't run by the super-user.  These
 activities include: preserving users via the bf(--owner) option, preserving
 all groups (not just the current user's groups) via the bf(--groups)
 option, and copying devices via the bf(--devices) option.  This is useful
 for systems that allow such activities without being the super-user, and
@@ -1100,31 +1193,42 @@
 extended attributes (if bf(--xattrs) was specified).
 
 This is a good way to backup data without using a super-user, and to store
 ACLs from incompatible systems.
 
 The bf(--fake-super) option only affects the side where the option is used.
-To affect the remote side of a remote-shell connection, specify an rsync
-path:
+To affect the remote side of a remote-shell connection, use the
+bf(--remote-option) (bf(-M)) option:
 
-quote(tt(  rsync -av --rsync-path="rsync --fake-super" /src/ host:/dest/))
+quote(tt(  rsync -av -M--fake-super /src/ host:/dest/))
 
-Since there is only one "side" in a local copy, this option affects both
-the sending and receiving of files.  You'll need to specify a copy using
-"localhost" if you need to avoid this, possibly using the "lsh" shell
-script (from the support directory) as a substitute for an actual remote
-shell (see bf(--rsh)).
+For a local copy, this option affects both the source and the destination.
+If you wish a local copy to enable this option just for the destination
+files, specify bf(-M--fake-super).  If you wish a local copy to enable
+this option just for the source files, combine bf(--fake-super) with
+bf(-M--super).
 
 This option is overridden by both bf(--super) and bf(--no-super).
 
 See also the "fake super" setting in the daemon's rsyncd.conf file.
 
 dit(bf(-S, --sparse)) Try to handle sparse files efficiently so they take
 up less space on the destination.  Conflicts with bf(--inplace) because it's
 not possible to overwrite data in a sparse fashion.
 
+dit(bf(--preallocate)) This tells the receiver to allocate each destination
+file to its eventual size before writing data to the file.  Rsync will only use
+the real filesystem-level preallocation support provided by Linux's
+bf(fallocate)(2) system call or Cygwin's bf(posix_fallocate)(3), not the slow
+glibc implementation that writes a zero byte into each block.
+
+Without this option, larger files may not be entirely contiguous on the
+filesystem, but with this option rsync will probably copy more slowly.  If the
+destination is not an extent-supporting filesystem (such as ext4, xfs, NTFS,
+etc.), this option may have no positive effect at all.
+
 dit(bf(-n, --dry-run)) This makes rsync perform a trial run that doesn't
 make any changes (and produces mostly the same output as a real run).  It
 is most commonly used in combination with the bf(-v, --verbose) and/or
 bf(-i, --itemize-changes) options to see what an rsync command is going
 to do before one actually runs it.
 
@@ -1200,12 +1304,15 @@
 a file that is not yet fully written.  If you can't first write the files into
 a different directory, you should use a naming idiom that lets rsync avoid
 transferring files that are not yet finished (e.g. name the file "foo.new" when
 it is written, rename it to "foo" when it is done, and then use the option
 bf(--exclude='*.new') for the rsync transfer).
 
+Starting with 3.1.0, rsync will skip the sender-side removal (and output an
+error) if the file's size or modify time has not stayed unchanged.
+
 dit(bf(--delete)) This tells rsync to delete extraneous files from the
 receiving side (ones that aren't on the sending side), but only for the
 directories that are being synchronized.  You must have asked rsync to
 send the whole directory (e.g. "dir" or "dir/") without using a wildcard
 for the directory's contents (e.g. "dir/*") since the wildcard is expanded
 by the shell and rsync thus gets a request to transfer individual files, not
@@ -1283,33 +1390,52 @@
 delete any files on the receiving side that are excluded (see bf(--exclude)).
 See the FILTER RULES section for a way to make individual exclusions behave
 this way on the receiver, and for a way to protect files from
 bf(--delete-excluded).
 See bf(--delete) (which is implied) for more details on file-deletion.
 
+dit(bf(--ignore-missing-args)) When rsync is first processing the explicitly
+requested source files (e.g. command-line arguments or bf(--files-from)
+entries), it is normally an error if the file cannot be found.  This option
+suppresses that error, and does not try to transfer the file.  This does not
+affect subsequent vanished-file errors if a file was initially found to be
+present and later is no longer there.
+
+dit(bf(--delete-missing-args)) This option takes the behavior of (the implied)
+bf(--ignore-missing-args) option a step farther:  each missing arg will become
+a deletion request of the corresponding destination file on the receiving side
+(should it exist).  If the destination file is a non-empty directory, it will
+only be successfully deleted if --force or --delete are in effect.  Other than
+that, this option is independent of any other type of delete processing.
+
+The missing source files are represented by special file-list entries which
+display as a "*missing" entry in the bf(--list-only) output.
+
 dit(bf(--ignore-errors)) Tells bf(--delete) to go ahead and delete files
 even when there are I/O errors.
 
 dit(bf(--force)) This option tells rsync to delete a non-empty directory
 when it is to be replaced by a non-directory.  This is only relevant if
 deletions are not active (see bf(--delete) for details).
 
 Note for older rsync versions: bf(--force) used to still be required when
 using bf(--delete-after), and it used to be non-functional unless the
 bf(--recursive) option was also enabled.
 
 dit(bf(--max-delete=NUM)) This tells rsync not to delete more than NUM
-files or directories.  If that limit is exceeded, a warning is output
-and rsync exits with an error code of 25 (new for 3.0.0).
+files or directories.  If that limit is exceeded, all further deletions are
+skipped through the end of the transfer.  At the end, rsync outputs a warning
+(including a count of the skipped deletions) and exits with an error code
+of 25 (unless some more important error condition also occurred).
 
-Also new for version 3.0.0, you may specify bf(--max-delete=0) to be warned
+Beginning with version 3.0.0, you may specify bf(--max-delete=0) to be warned
 about any extraneous files in the destination without removing any of them.
 Older clients interpreted this as "unlimited", so if you don't know what
 version the client is, you can use the less obvious bf(--max-delete=-1) as
 a backward-compatible way to specify that no deletions be allowed (though
-older versions didn't warn when the limit was exceeded).
+really old versions didn't warn when the limit was exceeded).
 
 dit(bf(--max-size=SIZE)) This tells rsync to avoid transferring any
 file that is larger than the specified SIZE. The SIZE value can be
 suffixed with a string to indicate a size multiplier, and
 may be a fractional value (e.g. "bf(--max-size=1.5m)").
 
@@ -1325,17 +1451,21 @@
 Finally, if the suffix ends in either "+1" or "-1", the value will
 be offset by one byte in the indicated direction.
 
 Examples: --max-size=1.5mb-1 is 1499999 bytes, and --max-size=2g+1 is
 2147483649 bytes.
 
+Note that rsync versions prior to 3.1.0 did not allow bf(--max-size=0).
+
 dit(bf(--min-size=SIZE)) This tells rsync to avoid transferring any
 file that is smaller than the specified SIZE, which can help in not
 transferring small, junk files.
 See the bf(--max-size) option for a description of SIZE and other information.
 
+Note that rsync versions prior to 3.1.0 did not allow bf(--min-size=0).
+
 dit(bf(-B, --block-size=BLOCKSIZE)) This forces the block size used in
 rsync's delta-transfer algorithm to a fixed value.  It is normally selected based on
 the size of each file being updated.  See the technical report for details.
 
 dit(bf(-e, --rsh=COMMAND)) This option allows you to choose an alternative
 remote shell program to use for communication between the local and
@@ -1381,12 +1511,42 @@
 
 One tricky example is to set a different default directory on the remote
 machine for use with the bf(--relative) option.  For instance:
 
 quote(tt(    rsync -avR --rsync-path="cd /a/b && rsync" host:c/d /e/))
 
+dit(bf(-M, --remote-option=OPTION)) This option is used for more advanced
+situations where you want certain effects to be limited to one side of the
+transfer only.  For instance, if you want to pass bf(--log-file=FILE) and
+bf(--fake-super) to the remote system, specify it like this:
+
+quote(tt(    rsync -av -M --log-file=foo -M--fake-super src/ dest/))
+
+If you want to have an option affect only the local side of a transfer when
+it normally affects both sides, send its negation to the remote side.  Like
+this:
+
+quote(tt(    rsync -av -x -M--no-x src/ dest/))
+
+Be cautious using this, as it is possible to toggle an option that will cause
+rsync to have a different idea about what data to expect next over the socket,
+and that will make it fail in a cryptic fashion.
+
+Note that it is best to use a separate bf(--remote-option) for each option you
+want to pass.  This makes your useage compatible with the bf(--protect-args)
+option.  If that option is off, any spaces in your remote options will be split
+by the remote shell unless you take steps to protect them.
+
+When performing a local transfer, the "local" side is the sender and the
+"remote" side is the receiver.
+
+Note some versions of the popt option-parsing library have a bug in them that
+prevents you from using an adjacent arg with an equal in it next to a short
+option letter (e.g. tt(-M--log-file=/tmp/foo).  If this bug affects your
+version of popt, you can use the version of popt that is included with rsync.
+
 dit(bf(-C, --cvs-exclude)) This is a useful shorthand for excluding a
 broad range of files that you often don't want to transfer between
 systems. It uses a similar algorithm to CVS to determine if
 a file should be ignored.
 
 The exclude list is initialized to exclude the following items (these
@@ -1545,12 +1705,26 @@
 
 If you use this option with bf(--iconv), the args related to the remote
 side will also be translated
 from the local to the remote character-set.  The translation happens before
 wild-cards are expanded.  See also the bf(--files-from) option.
 
+You may also control this option via the RSYNC_PROTECT_ARGS environment
+variable.  If this variable has a non-zero value, this option will be enabled
+by default, otherwise it will be disabled by default.  Either state is
+overridden by a manually specified positive or negative version of this option
+(note that bf(--no-s) and bf(--no-protect-args) are the negative versions).
+Since this option was first introduced in 3.0.0, you'll need to make sure it's
+disabled if you ever need to interact with a remote rsync that is older than
+that.
+
+Rsync can also be configured (at build time) to have this option enabled by
+default (with is overridden by both the environment and the command-line).
+This option will eventually become a new default setting at some
+as-yet-undetermined point in the future.
+
 dit(bf(-T, --temp-dir=DIR)) This option instructs rsync to use DIR as a
 scratch directory when creating temporary copies of the files transferred
 on the receiving side.  The default behavior is to create each temporary
 file in the same directory as the associated destination file.
 
 This option is most often used when the receiving disk partition does not
@@ -1583,35 +1757,45 @@
 dit(bf(-y, --fuzzy)) This option tells rsync that it should look for a
 basis file for any destination file that is missing.  The current algorithm
 looks in the same directory as the destination file for either a file that
 has an identical size and modified-time, or a similarly-named file.  If
 found, rsync uses the fuzzy basis file to try to speed up the transfer.
 
+If the option is repeated, the fuzzy scan will also be done in any matching
+alternate destination directories that are specified via bf(--compare-dest),
+bf(--copy-dest), or bf(--link-dest).
+
 Note that the use of the bf(--delete) option might get rid of any potential
 fuzzy-match files, so either use bf(--delete-after) or specify some
 filename exclusions if you need to prevent this.
 
 dit(bf(--compare-dest=DIR)) This option instructs rsync to use em(DIR) on
 the destination machine as an additional hierarchy to compare destination
 files against doing transfers (if the files are missing in the destination
 directory).  If a file is found in em(DIR) that is identical to the
 sender's file, the file will NOT be transferred to the destination
 directory.  This is useful for creating a sparse backup of just files that
 have changed from an earlier backup.
+This option is typically used to copy into an empty (or newly created)
+directory.
 
 Beginning in version 2.6.4, multiple bf(--compare-dest) directories may be
 provided, which will cause rsync to search the list in the order specified
 for an exact match.
 If a match is found that differs only in attributes, a local copy is made
 and the attributes updated.
 If a match is not found, a basis file from one of the em(DIR)s will be
 selected to try to speed up the transfer.
 
 If em(DIR) is a relative path, it is relative to the destination directory.
 See also bf(--copy-dest) and bf(--link-dest).
 
+NOTE: beginning with version 3.1.0, rsync will remove a file from a non-empty
+destination hierarchy if an exact match is found in one of the compare-dest
+hierarchies (making the end result more closely match a fresh copy).
+
 dit(bf(--copy-dest=DIR)) This option behaves like bf(--compare-dest), but
 rsync will also copy unchanged files found in em(DIR) to the destination
 directory using a local copy.
 This is useful for doing transfers to a new destination while leaving
 existing files intact, and then doing a flash-cutover when all files have
 been successfully transferred.
@@ -1643,16 +1827,17 @@
 If a match is found that differs only in attributes, a local copy is made
 and the attributes updated.
 If a match is not found, a basis file from one of the em(DIR)s will be
 selected to try to speed up the transfer.
 
 This option works best when copying into an empty destination hierarchy, as
-rsync treats existing files as definitive (so it never looks in the link-dest
-dirs when a destination file already exists), and as malleable (so it might
-change the attributes of a destination file, which affects all the hard-linked
-versions).
+existing files may get their attributes tweaked, and that can affect alternate
+destination files via hard-links.  Also, itemizing of changes can get a bit
+muddled.  Note that prior to version 3.1.0, an alternate-directory exact match
+would never be found (nor linked into the destination) when a destination file
+already exists.
 
 Note that if you combine this option with bf(--ignore-times), rsync will not
 link any files together because it only links identical files together as a
 substitute for transferring the file, never as an additional check after the
 file is updated.
 
@@ -1698,26 +1883,37 @@
 verb(    --skip-compress=gz/jpg/mp[34]/7z/bz2)
 
 The default list of suffixes that will not be compressed is this (in this
 version of rsync):
 
 bf(7z)
+bf(ace)
 bf(avi)
 bf(bz2)
 bf(deb)
+bf(gpg)
 bf(gz)
 bf(iso)
 bf(jpeg)
 bf(jpg)
+bf(lz)
+bf(lzma)
+bf(lzo)
 bf(mov)
 bf(mp3)
 bf(mp4)
 bf(ogg)
+bf(png)
+bf(rar)
 bf(rpm)
+bf(rzip)
 bf(tbz)
 bf(tgz)
+bf(tlz)
+bf(txz)
+bf(xz)
 bf(z)
 bf(zip)
 
 This list will be replaced by your bf(--skip-compress) list in all but one
 situation: a copy from a daemon rsync will add your skipped suffixes to
 its list of non-compressing files (and its list may be configured to a
@@ -1736,12 +1932,63 @@
 on the destination system, then the numeric ID
 from the source system is used instead.  See also the comments on the
 "use chroot" setting in the rsyncd.conf manpage for information on how
 the chroot setting affects rsync's ability to look up the names of the
 users and groups and what you can do about it.
 
+dit(bf(--usermap=STRING, --groupmap=STRING)) These options allow you to
+specify users and groups that should be mapped to other values by the
+receiving side.  The bf(STRING) is one or more bf(FROM):bf(TO) pairs of
+values separated by commas.  Any matching bf(FROM) value from the sender is
+replaced with a bf(TO) value from the receiver.  You may specify usernames
+or user IDs for the bf(FROM) and bf(TO) values, and the bf(FROM) value may
+also be a wild-card string, which will be matched against the sender's
+names (wild-cards do NOT match against ID numbers, though see below for
+why a '*' matches everything).  You may instead specify a range of ID
+numbers via an inclusive range: LOW-HIGH.  For example:
+
+verb(  --usermap=0-99:nobody,wayne:admin,*:normal --groupmap=usr:1,1:usr)
+
+The first match in the list is the one that is used.  You should specify
+all your user mappings using a single bf(--usermap) option, and/or all
+your group mappings using a single bf(--groupmap) option.
+
+Note that the sender's name for the 0 user and group are not transmitted
+to the receiver, so you should either match these values using a 0, or use
+the names in effect on the receiving side (typically "root").  All other
+bf(FROM) names match those in use on the sending side.  All bf(TO) names
+match those in use on the receiving side.
+
+Any IDs that do not have a name on the sending side are treated as having an
+empty name for the purpose of matching.  This allows them to be matched via
+a "*" or using an empty name.  For instance:
+
+verb(  --usermap=:nobody --groupmap=*:nobody)
+
+When the bf(--numeric-ids) option is used, the sender does not send any
+names, so all the IDs are treated as having an empty name.  This means that
+you will need to specify numeric bf(FROM) values if you want to map these
+nameless IDs to different values.
+
+For the bf(--usermap) option to have any effect, the bf(-o) (bf(--owner))
+option must be used (or implied), and the receiver will need to be running
+as a super-user (see also the bf(--fake-super) option).  For the bf(--groupmap)
+option to have any effect, the bf(-g) (bf(--groups)) option must be used
+(or implied), and the receiver will need to have permissions to set that
+group.
+
+dit(bf(--chown=USER:GROUP)) This option forces all files to be owned by USER
+with group GROUP.  This is a simpler interface than using bf(--usermap) and
+bf(--groupmap) directly, but it is implemented using those options internally,
+so you cannot mix them.  If either the USER or GROUP is empty, no mapping for
+the omitted user/group will occur.  If GROUP is empty, the trailing colon may
+be omitted, but if USER is empty, a leading colon must be supplied.
+
+If you specify "--chown=foo:bar, this is exactly the same as specifying
+"--usermap=*:foo --groupmap=*:bar", only easier.
+
 dit(bf(--timeout=TIMEOUT)) This option allows you to set a maximum I/O
 timeout in seconds. If no data is transferred for the specified time
 then rsync will exit. The default is 0, which means no timeout.
 
 dit(bf(--contimeout)) This option allows you to set the amount of time
 that rsync will wait for its connection to an rsync daemon to succeed.
@@ -1770,12 +2017,19 @@
 dit(bf(--blocking-io)) This tells rsync to use blocking I/O when launching
 a remote shell transport.  If the remote shell is either rsh or remsh,
 rsync defaults to using
 blocking I/O, otherwise it defaults to using non-blocking I/O.  (Note that
 ssh prefers non-blocking I/O.)
 
+dit(bf(--outbuf=MODE)) This sets the output buffering mode.  The mode can be
+None (aka Unbuffered), Line, or Block (aka Full).  You may specify as little
+as a single letter for the mode, and use upper or lower case.
+
+The main use of this option is to change Full buffering to Line buffering
+when rsync's output is going to a file or pipe.
+
 dit(bf(-i, --itemize-changes)) Requests a simple itemized list of the
 changes that are being made to each file, including attribute changes.
 This is exactly the same as specifying bf(--out-format='%i %n%L').
 If you repeat the option, unchanged files will also be output, but only
 if the receiving rsync is at least version 2.6.7 (you can use bf(-vv)
 with older versions of rsync, but that also turns on the output of other
@@ -1849,19 +2103,19 @@
 outputting them as a verbose message).
 
 dit(bf(--out-format=FORMAT)) This allows you to specify exactly what the
 rsync client outputs to the user on a per-update basis.  The format is a
 text string containing embedded single-character escape sequences prefixed
 with a percent (%) character.   A default format of "%n%L" is assumed if
-bf(-v) is specified (which reports the name
+either bf(--info=name) or bf(-v) is specified (this tells you just the name
 of the file and, if the item is a link, where it points).  For a full list
 of the possible escape characters, see the "log format" setting in the
 rsyncd.conf manpage.
 
-Specifying the bf(--out-format) option
-will mention each file, dir, etc. that gets updated in a significant
+Specifying the bf(--out-format) option implies the bf(--info=name) option,
+which will mention each file, dir, etc. that gets updated in a significant
 way (a transferred file, a recreated symlink/device, or a touched
 directory).  In addition, if the itemize-changes escape (%i) is included in
 the string (e.g. if the bf(--itemize-changes) option was used), the logging
 of names increases to mention any item that is changed in any way (as long
 as the receiving side is at least 2.6.4).  See the bf(--itemize-changes)
 option for a description of the output of "%i".
@@ -1880,13 +2134,13 @@
 enabled with a default format of "%i %n%L".  See the bf(--log-file-format)
 option if you wish to override this.
 
 Here's a example command that requests the remote side to log what is
 happening:
 
-verb(  rsync -av --rsync-path="rsync --log-file=/tmp/rlog" src/ dest/)
+verb(  rsync -av --remote-option=--log-file=/tmp/rlog src/ dest/)
 
 This is very useful if you need to debug why a connection is closing
 unexpectedly.
 
 dit(bf(--log-file-format=FORMAT)) This allows you to specify exactly what
 per-update logging is put into the file specified by the bf(--log-file) option
@@ -1897,20 +2151,35 @@
 
 The default FORMAT used if bf(--log-file) is specified and this option is not
 is '%i %n%L'.
 
 dit(bf(--stats)) This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective rsync's delta-transfer
-algorithm is for your data.
+algorithm is for your data.  This option is equivalent to bf(--info=stats2)
+if combined with 0 or 1 bf(-v) options, or bf(--info=stats3) if combined
+with 2 or more bf(-v) options.
 
 The current statistics are as follows: quote(itemization(
   it() bf(Number of files) is the count of all "files" (in the generic
-  sense), which includes directories, symlinks, etc.
-  it() bf(Number of files transferred) is the count of normal files that
-  were updated via rsync's delta-transfer algorithm, which does not include created
-  dirs, symlinks, etc.
+  sense), which includes directories, symlinks, etc.  The total count will
+  be followed by a list of counts by filetype (if the total is non-zero).
+  For example: "(reg: 5, dir: 3, link: 2, dev: 1, special: 1)" lists the
+  totals for regular files, directories, symlinks, devices, and special
+  files.  If any of value is 0, it is completely omitted from the list.
+  it() bf(Number of created files) is the count of how many "files" (generic
+  sense) were created (as opposed to updated).  The total count will be
+  followed by a list of counts by filetype (if the total is non-zero).
+  it() bf(Number of deleted files) is the count of how many "files" (generic
+  sense) were created (as opposed to updated).  The total count will be
+  followed by a list of counts by filetype (if the total is non-zero).
+  Note that this line is only output if deletions are in effect, and only
+  if protocol 31 is being used (the default for rsync 3.1.x).
+  it() bf(Number of regular files transferred) is the count of normal files
+  that were updated via rsync's delta-transfer algorithm, which does not
+  include dirs, symlinks, etc.  Note that rsync 3.1.0 added the word
+  "regular" into this heading.
   it() bf(Total file size) is the total sum of all file sizes in the transfer.
   This does not count any size for directories or special files, but does
   include the size of symlinks.
   it() bf(Total transferred file size) is the total sum of all files sizes
   for just the transferred files.
   it() bf(Literal data) is how much unmatched file-update data we had to
@@ -1943,16 +2212,31 @@
 The escape idiom that started in 2.6.7 is to output a literal backslash (\)
 and a hash (#), followed by exactly 3 octal digits.  For example, a newline
 would output as "\#012".  A literal backslash that is in a filename is not
 escaped unless it is followed by a hash and 3 digits (0-9).
 
 dit(bf(-h, --human-readable)) Output numbers in a more human-readable format.
-This makes big numbers output using larger units, with a K, M, or G suffix.  If
-this option was specified once, these units are K (1000), M (1000*1000), and
-G (1000*1000*1000); if the option is repeated, the units are powers of 1024
-instead of 1000.
+There are 3 possible levels:  (1) output numbers with a separator between each
+set of 3 digits (either a comma or a period, depending on if the decimal point
+is represented by a period or a comma); (2) output numbers in units of 1000
+(with a character suffix for larger units -- see below); (3) output numbers in
+units of 1024.
+
+The default is human-readable level 1.  Each bf(-h) option increases the level
+by one.  You can take the level down to 0 (to output numbers as pure digits) by
+specifing the bf(--no-human-readable) (bf(--no-h)) option.
+
+The unit letters that are appended in levels 2 and 3 are: K (kilo), M (mega),
+G (giga), or T (tera).  For example, a 1234567-byte file would output as 1.23M
+in level-2 (assuming that a period is your local decimal point).
+
+Backward compatibility note:  versions of rsync prior to 3.1.0 do not support
+human-readable level 1, and they default to level 0.  Thus, specifying one or
+two bf(-h) options will behave in a comparable manner in old and new versions
+as long as you didn't specify a bf(--no-h) option prior to one or more bf(-h)
+options.  See the bf(--list-only) option for one difference.
 
 dit(bf(--partial)) By default, rsync will delete any partially
 transferred file if the transfer is interrupted. In some circumstances
 it is more desirable to keep partially transferred files. Using the
 bf(--partial) option tells rsync to keep the partial file which should
 make a subsequent transfer of the rest of the file much faster.
@@ -2075,13 +2359,15 @@
 time-honored options of "bf(--include='*/' --exclude='*')" would work fine
 in place of the hide-filter (if that is more natural to you).
 
 dit(bf(--progress)) This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
-Implies bf(--verbose) if it wasn't already specified.
+With a modern rsync this is the same as specifying
+bf(--info=flist2,name,progress), but any user-supplied settings for those
+info flags takes precedence (e.g. "--info=flist0 --progress").
 
 While rsync is transferring a regular file, it updates a progress line that
 looks like this:
 
 verb(      782448  63%  110.64kB/s    0:00:04)
 
@@ -2097,29 +2383,47 @@
 will probably take much longer to finish than the receiver estimated as it
 was finishing the matched part of the file.
 
 When the file transfer finishes, rsync replaces the progress line with a
 summary line that looks like this:
 
-verb(     1238099 100%  146.38kB/s    0:00:08  (xfer#5, to-check=169/396))
+verb(      1,238,099 100%  146.38kB/s    0:00:08  (xfr#5, to-chk=169/396))
 
-In this example, the file was 1238099 bytes long in total, the average rate
+In this example, the file was 1,238,099 bytes long in total, the average rate
 of transfer for the whole file was 146.38 kilobytes per second over the 8
 seconds that it took to complete, it was the 5th transfer of a regular file
 during the current rsync session, and there are 169 more files for the
 receiver to check (to see if they are up-to-date or not) remaining out of
 the 396 total files in the file-list.
 
+In an incremental recursion scan, rsync won't know the total number of files
+in the file-list until it reaches the ends of the scan, but since it starts to
+transfer files during the scan, it will display a line with the text "ir-chk"
+(for incremental recursion check) instead of "to-chk" until the point that it
+knows the full size of the list, at which point it will switch to using
+"to-chk".  Thus, seeing "ir-chk" lets you know that the total count of files
+in the file list is still going to increase (and each time it does, the count
+of files left to check  will increase by the number of the files added to the
+list).
+
 dit(bf(-P)) The bf(-P) option is equivalent to bf(--partial) bf(--progress).  Its
 purpose is to make it much easier to specify these two options for a long
 transfer that may be interrupted.
 
-dit(bf(--password-file)) This option allows you to provide a password in a
-file for accessing an rsync daemon.  The file must not be world readable.
-It should contain just the password as the first line of the file (all
-other lines are ignored).
+There is also a bf(--info=progress2) option that outputs statistics based
+on the whole transfer, rather than individual files.  Use this flag without
+outputting a filename (e.g. avoid bf(-v) or specify bf(--info=name0) if you
+want to see how the transfer is doing without scrolling the screen with a
+lot of names.  (You don't need to specify the bf(--progress) option in
+order to use bf(--info=progress2).)
+
+dit(bf(--password-file=FILE)) This option allows you to provide a password for
+accessing an rsync daemon via a file or via standard input if bf(FILE) is
+bf(-).  The file should contain just the password on the first line (all other
+lines are ignored).  Rsync will exit with an error if bf(FILE) is world
+readable or if a root-run rsync command finds a non-root-owned file.
 
 This option does not supply a password to a remote shell transport such as
 ssh; to learn how to do that, consult the remote shell's documentation.
 When accessing an rsync daemon using a remote shell as the transport, this
 option only comes into effect after the remote shell finishes its
 authentication (i.e. if you have also specified a password in the daemon's
@@ -2134,27 +2438,49 @@
 Caution: keep in mind that a source arg with a wild-card is expanded by the
 shell into multiple args, so it is never safe to try to list such an arg
 without using this option.  For example:
 
 verb(    rsync -av --list-only foo* dest/)
 
+Starting with rsync 3.1.0, the sizes output by bf(--list-only) are affected
+by the bf(--human-readable) option.  By default they will contain digit
+separators, but higher levels of readability will output the sizes with
+unit suffixes.  Note also that the column width for the size output has
+increased from 11 to 14 characters for all human-readable levels.  Use
+bf(--no-h) if you want just digits in the sizes, and the old column width
+of 11 characters.
+
 Compatibility note:  when requesting a remote listing of files from an rsync
 that is version 2.6.3 or older, you may encounter an error if you ask for a
 non-recursive listing.  This is because a file listing implies the bf(--dirs)
 option w/o bf(--recursive), and older rsyncs don't have that option.  To
 avoid this problem, either specify the bf(--no-dirs) option (if you don't
 need to expand a directory's content), or turn on recursion and exclude
 the content of subdirectories: bf(-r --exclude='/*/*').
 
-dit(bf(--bwlimit=KBPS)) This option allows you to specify a maximum
-transfer rate in kilobytes per second. This option is most effective when
-using rsync with large files (several megabytes and up). Due to the nature
-of rsync transfers, blocks of data are sent, then if rsync determines the
-transfer was too fast, it will wait before sending the next data block. The
-result is an average transfer rate equaling the specified limit. A value
-of zero specifies no limit.
+dit(bf(--bwlimit=RATE)) This option allows you to specify the maximum transfer
+rate for the data sent over the socket, specified in units per second.  The
+RATE value can be suffixed with a string to indicate a size multiplier, and may
+be a fractional value (e.g.  "bf(--bwlimit=1.5m)").  If no suffix is specified,
+the value will be assumed to be in units of 1024 bytes (as if "K" or "KiB" had
+been appended).  See the bf(--max-size) option for a description of all the
+available suffixes. A value of zero specifies no limit.
+
+For backward-compatibility reasons, the rate limit will be rounded to the
+nearest KiB unit, so no rate smaller than 1024 bytes per second is possible.
+
+Rsync writes data over the socket in blocks, and this option both limits the
+size of the blocks that rsync writes, and tries to keep the average transfer
+rate at the requested limit.  Some "burstiness" may be seen where rsync writes
+out a block of data and then sleeps to bring the average rate into compliance.
+
+Due to the internal buffering of data, the bf(--progress) option may not be an
+accurate reflection on how fast the data is being sent.  This is because some
+files can show up as being rapidly sent when the data is quickly buffered,
+while other can show up as very slow when the flushing of the output buffer
+occurs.  This may be fixed in a future version.
 
 dit(bf(--write-batch=FILE)) Record a file that can later be applied to
 another identical destination with bf(--read-batch). See the "BATCH MODE"
 section for details, and also the bf(--only-write-batch) option.
 
 dit(bf(--only-write-batch=FILE)) Works like bf(--write-batch), except that
@@ -2223,21 +2549,21 @@
 rsync daemon.  See also these options in the bf(--daemon) mode section.
 
 If rsync was complied without support for IPv6, the bf(--ipv6) option
 will have no effect.  The bf(--version) output will tell you if this
 is the case.
 
-dit(bf(--checksum-seed=NUM)) Set the checksum seed to the integer
-NUM.  This 4 byte checksum seed is included in each block and file
-checksum calculation.  By default the checksum seed is generated
-by the server and defaults to the current code(time()).  This option
-is used to set a specific checksum seed, which is useful for
-applications that want repeatable block and file checksums, or
-in the case where the user wants a more random checksum seed.
-Setting NUM to 0 causes rsync to use the default of code(time())
-for checksum seed.
+dit(bf(--checksum-seed=NUM)) Set the checksum seed to the integer NUM.  This 4
+byte checksum seed is included in each block and MD4 file checksum calculation
+(the more modern MD5 file checksums don't use a seed).  By default the checksum
+seed is generated by the server and defaults to the current code(time()).  This
+option is used to set a specific checksum seed, which is useful for
+applications that want repeatable block checksums, or in the case where the
+user wants a more random checksum seed.  Setting NUM to 0 causes rsync to use
+the default of code(time()) for checksum seed.
+
 enddit()
 
 manpagesection(DAEMON OPTIONS)
 
 The options allowed when starting an rsync daemon are as follows:
 
@@ -2256,24 +2582,31 @@
 dit(bf(--address)) By default rsync will bind to the wildcard address when
 run as a daemon with the bf(--daemon) option.  The bf(--address) option
 allows you to specify a specific IP address (or hostname) to bind to.  This
 makes virtual hosting possible in conjunction with the bf(--config) option.
 See also the "address" global option in the rsyncd.conf manpage.
 
-dit(bf(--bwlimit=KBPS)) This option allows you to specify a maximum
-transfer rate in kilobytes per second for the data the daemon sends.
-The client can still specify a smaller bf(--bwlimit) value, but their
-requested value will be rounded down if they try to exceed it.  See the
-client version of this option (above) for some extra details.
+dit(bf(--bwlimit=RATE)) This option allows you to specify the maximum transfer
+rate for the data the daemon sends over the socket.  The client can still
+specify a smaller bf(--bwlimit) value, but no larger value will be allowed.
+See the client version of this option (above) for some extra details.
 
 dit(bf(--config=FILE)) This specifies an alternate config file than
 the default.  This is only relevant when bf(--daemon) is specified.
 The default is /etc/rsyncd.conf unless the daemon is running over
 a remote shell program and the remote user is not the super-user; in that case
 the default is rsyncd.conf in the current directory (typically $HOME).
 
+dit(bf(-M, --dparam=OVERRIDE)) This option can be used to set a daemon-config
+parameter when starting up rsync in daemon mode.  It is equivalent to adding
+the parameter at the end of the global settings prior to the first module's
+definition.  The parameter names can be specified without spaces, if you so
+desire.  For instance:
+
+verb(    rsync --daemon -M pidfile=/path/rsync.pid )
+
 dit(bf(--no-detach)) When running as a daemon, this option instructs
 rsync to not detach itself and become a background process.  This
 option is required when running as a service on Cygwin, and may also
 be useful when rsync is supervised by a program such as
 bf(daemontools) or AIX's bf(System Resource Controller).
 bf(--no-detach) is also recommended when rsync is run under a
@@ -2978,12 +3311,15 @@
 startdit()
 dit(bf(CVSIGNORE)) The CVSIGNORE environment variable supplements any
 ignore patterns in .cvsignore files. See the bf(--cvs-exclude) option for
 more details.
 dit(bf(RSYNC_ICONV)) Specify a default bf(--iconv) setting using this
 environment variable. (First supported in 3.0.0.)
+dit(bf(RSYNC_PROTECT_ARGS)) Specify a non-zero numeric value if you want the
+bf(--protect-args) option to be enabled by default, or a zero value to make
+sure that it is disabled by default. (First supported in 3.1.0.)
 dit(bf(RSYNC_RSH)) The RSYNC_RSH environment variable allows you to
 override the default shell used as the transport for rsync.  Command line
 options are permitted after the command name, just as in the bf(-e) option.
 dit(bf(RSYNC_PROXY)) The RSYNC_PROXY environment variable allows you to
 redirect your rsync client to use a web proxy when connecting to a
 rsync daemon. You should set RSYNC_PROXY to a hostname:port pair.
@@ -3022,13 +3358,13 @@
 
 Please report bugs! See the web site at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 3.0.9 of rsync.
+This man page is current for version 3.1.0 of rsync.
 
 manpagesection(INTERNAL OPTIONS)
 
 The options bf(--server) and bf(--sender) are used internally by rsync,
 and should never be typed by a user under normal circumstances.  Some
 awareness of these options may be needed in certain scenarios, such as
@@ -3036,13 +3372,13 @@
 the support directory of the rsync distribution has an example script
 named rrsync (for restricted rsync) that can be used with a restricted
 ssh login.
 
 manpagesection(CREDITS)
 
-rsync is distributed under the GNU public license.  See the file
+rsync is distributed under the GNU General Public License.  See the file
 COPYING for details.
 
 A WEB site is available at
 url(http://rsync.samba.org/)(http://rsync.samba.org/).  The site
 includes an FAQ-O-Matic which may cover questions unanswered by this
 manual page.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/runtests.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/runtests.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/runtests.sh	2011-09-15 22:27:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/runtests.sh	2011-09-15 22:32:07.000000000 +0800
@@ -229,14 +229,15 @@
 # has ACLs and xattr support enabled (if desired).
 scratchbase="$TOOLDIR"/testtmp
 echo "    scratchbase=$scratchbase"
 [ -d "$scratchbase" ] || mkdir "$scratchbase"
 
 suitedir="$srcdir/testsuite"
+TESTRUN_TIMEOUT=300
 
-export scratchdir suitedir
+export scratchdir suitedir TESTRUN_TIMEOUT
 
 prep_scratch() {
     [ -d "$scratchdir" ] && chmod -R u+rwX "$scratchdir" && rm -rf "$scratchdir"
     mkdir "$scratchdir"
     # Get rid of default ACLs and dir-setgid to avoid confusing some tests.
     $setfacl_nodef "$scratchdir" || true
@@ -261,14 +262,19 @@
 do
     testbase=`echo $testscript | sed -e 's!.*/!!' -e 's/.test\$//'`
     scratchdir="$scratchbase/$testbase"
 
     prep_scratch
 
+    case "$testscript" in
+    *hardlinks*) TESTRUN_TIMEOUT=600 ;;
+    *) TESTRUN_TIMEOUT=300 ;;
+    esac
+
     set +e
-    sh $RUNSHFLAGS "$testscript" >"$scratchdir/test.log" 2>&1
+    "$TOOLDIR/"testrun $RUNSHFLAGS "$testscript" >"$scratchdir/test.log" 2>&1
     result=$?
     set -e
 
     if [ "x$always_log" = xyes -o \( $result != 0 -a $result != 77 -a $result != 78 \) ]
     then
 	echo "----- $testbase log follows"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/sender.c	2009-12-13 09:23:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/sender.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Routines only used by the sending process.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,37 +17,40 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "inums.h"
 
-extern int verbose;
 extern int do_xfers;
 extern int am_server;
 extern int am_daemon;
 extern int inc_recurse;
 extern int log_before_transfer;
 extern int stdout_format_has_i;
 extern int logfile_format_has_i;
 extern int csum_length;
 extern int append_mode;
 extern int io_error;
+extern int flist_eof;
 extern int allowed_lull;
 extern int preserve_xattrs;
 extern int protocol_version;
 extern int remove_source_files;
 extern int updating_basis_file;
 extern int make_backups;
-extern int do_progress;
 extern int inplace;
 extern int batch_fd;
 extern int write_batch;
+extern int file_old_total;
 extern struct stats stats;
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
 
+BOOL extra_flist_sending_enabled;
+
 /**
  * @file
  *
  * The sender gets checksums from the generator, calculates deltas,
  * and transmits them to the receiver.  The sender process runs on the
  * machine holding the source files.
@@ -57,25 +60,25 @@
  * Receive the checksums for a buffer
  **/
 static struct sum_struct *receive_sums(int f)
 {
 	struct sum_struct *s;
 	int32 i;
-	int lull_mod = allowed_lull * 5;
+	int lull_mod = protocol_version >= 31 ? 0 : allowed_lull * 5;
 	OFF_T offset = 0;
 
 	if (!(s = new(struct sum_struct)))
 		out_of_memory("receive_sums");
 
 	read_sum_head(f, s);
 
 	s->sums = NULL;
 
-	if (verbose > 3) {
-		rprintf(FINFO, "count=%.0f n=%ld rem=%ld\n",
-			(double)s->count, (long)s->blength, (long)s->remainder);
+	if (DEBUG_GTE(DELTASUM, 3)) {
+		rprintf(FINFO, "count=%s n=%ld rem=%ld\n",
+			big_num(s->count), (long)s->blength, (long)s->remainder);
 	}
 
 	if (append_mode > 0) {
 		s->flength = (OFF_T)s->count * s->blength;
 		if (s->remainder)
 			s->flength -= s->blength - s->remainder;
@@ -98,48 +101,70 @@
 		if (i == s->count-1 && s->remainder != 0)
 			s->sums[i].len = s->remainder;
 		else
 			s->sums[i].len = s->blength;
 		offset += s->sums[i].len;
 
-		if (allowed_lull && !(i % lull_mod))
-			maybe_send_keepalive();
+		if (lull_mod && !(i % lull_mod))
+			maybe_send_keepalive(time(NULL), True);
 
-		if (verbose > 3) {
+		if (DEBUG_GTE(DELTASUM, 3)) {
 			rprintf(FINFO,
-				"chunk[%d] len=%d offset=%.0f sum1=%08x\n",
-				i, s->sums[i].len, (double)s->sums[i].offset,
+				"chunk[%d] len=%d offset=%s sum1=%08x\n",
+				i, s->sums[i].len, big_num(s->sums[i].offset),
 				s->sums[i].sum1);
 		}
 	}
 
 	s->flength = offset;
 
 	return s;
 }
 
 void successful_send(int ndx)
 {
 	char fname[MAXPATHLEN];
+	char *failed_op;
 	struct file_struct *file;
 	struct file_list *flist;
+	STRUCT_STAT st;
 
 	if (!remove_source_files)
 		return;
 
 	flist = flist_for_ndx(ndx, "successful_send");
 	file = flist->files[ndx - flist->ndx_start];
 	if (!change_pathname(file, NULL, 0))
 		return;
 	f_name(file, fname);
 
-	if (do_unlink(fname) == 0) {
-		if (verbose > 1)
+	if (do_lstat(fname, &st) < 0) {
+		failed_op = "re-lstat";
+		goto failed;
+	}
+
+	if (st.st_size != F_LENGTH(file) || st.st_mtime != file->modtime
+#ifdef ST_MTIME_NSEC
+	 || (NSEC_BUMP(file) && (uint32)st.ST_MTIME_NSEC != F_MOD_NSEC(file))
+#endif
+	) {
+		rprintf(FERROR, "ERROR: Skipping sender remove for changed file: %s\n", fname);
+		return;
+	}
+
+	if (do_unlink(fname) < 0) {
+		failed_op = "remove";
+	  failed:
+		if (errno == ENOENT)
+			rprintf(FINFO, "sender file already removed: %s\n", fname);
+		else
+			rsyserr(FERROR, errno, "sender failed to %s %s", failed_op, fname);
+	} else {
+		if (INFO_GTE(REMOVE, 1))
 			rprintf(FINFO, "sender removed %s\n", fname);
-	} else
-		rsyserr(FERROR, errno, "sender failed to remove %s", fname);
+	}
 }
 
 static void write_ndx_and_attrs(int f_out, int ndx, int iflags,
 				const char *fname, struct file_struct *file,
 				uchar fnamecmp_type, char *buf, int len)
 {
@@ -149,13 +174,14 @@
 	write_shortint(f_out, iflags);
 	if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
 		write_byte(f_out, fnamecmp_type);
 	if (iflags & ITEM_XNAME_FOLLOWS)
 		write_vstring(f_out, buf, len);
 #ifdef SUPPORT_XATTRS
-	if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers)
+	if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers
+	 && (protocol_version < 31 || !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))
 		send_xattr_request(fname, file, f_out);
 #endif
 }
 
 void send_files(int f_in, int f_out)
 {
@@ -166,47 +192,57 @@
 	char fname[MAXPATHLEN], xname[MAXPATHLEN];
 	const char *path, *slash;
 	uchar fnamecmp_type;
 	int iflags, xlen;
 	struct file_struct *file;
 	int phase = 0, max_phase = protocol_version >= 29 ? 2 : 1;
-	struct stats initial_stats;
 	int itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;
 	enum logcode log_code = log_before_transfer ? FLOG : FINFO;
 	int f_xfer = write_batch < 0 ? batch_fd : f_out;
 	int save_io_error = io_error;
 	int ndx, j;
 
-	if (verbose > 2)
+	if (DEBUG_GTE(SEND, 1))
 		rprintf(FINFO, "send_files starting\n");
 
 	while (1) {
-		if (inc_recurse)
-			send_extra_file_list(f_out, FILECNT_LOOKAHEAD);
+		if (inc_recurse) {
+			send_extra_file_list(f_out, MIN_FILECNT_LOOKAHEAD);
+			extra_flist_sending_enabled = !flist_eof;
+		}
 
 		/* This call also sets cur_flist. */
-		ndx = read_ndx_and_attrs(f_in, &iflags, &fnamecmp_type,
+		ndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,
 					 xname, &xlen);
+		extra_flist_sending_enabled = False;
+
 		if (ndx == NDX_DONE) {
+			if (!am_server && INFO_GTE(PROGRESS, 2) && cur_flist) {
+				set_current_file_index(NULL, 0);
+				end_progress(0);
+			}
 			if (inc_recurse && first_flist) {
+				file_old_total -= first_flist->used;
 				flist_free(first_flist);
 				if (first_flist) {
+					if (first_flist == cur_flist)
+						file_old_total = cur_flist->used;
 					write_ndx(f_out, NDX_DONE);
 					continue;
 				}
 			}
 			if (++phase > max_phase)
 				break;
-			if (verbose > 2)
+			if (DEBUG_GTE(SEND, 1))
 				rprintf(FINFO, "send_files phase=%d\n", phase);
 			write_ndx(f_out, NDX_DONE);
 			continue;
 		}
 
 		if (inc_recurse)
-			send_extra_file_list(f_out, FILECNT_LOOKAHEAD);
+			send_extra_file_list(f_out, MIN_FILECNT_LOOKAHEAD);
 
 		if (ndx - cur_flist->ndx_start >= 0)
 			file = cur_flist->files[ndx - cur_flist->ndx_start];
 		else
 			file = dir_flist->files[cur_flist->parent_ndx];
 		if (F_PATHNAME(file)) {
@@ -216,24 +252,40 @@
 			path = slash = "";
 		}
 		if (!change_pathname(file, NULL, 0))
 			continue;
 		f_name(file, fname);
 
-		if (verbose > 2)
+		if (DEBUG_GTE(SEND, 1))
 			rprintf(FINFO, "send_files(%d, %s%s%s)\n", ndx, path,slash,fname);
 
 #ifdef SUPPORT_XATTRS
-		if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers)
+		if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers
+		 && (protocol_version < 31 || !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))
 			recv_xattr_request(file, f_in);
 #endif
 
 		if (!(iflags & ITEM_TRANSFER)) {
 			maybe_log_item(file, iflags, itemizing, xname);
 			write_ndx_and_attrs(f_out, ndx, iflags, fname, file,
 					    fnamecmp_type, xname, xlen);
+			if (iflags & ITEM_IS_NEW) {
+				stats.created_files++;
+				if (S_ISREG(file->mode)) {
+					/* Nothing further to count. */
+				} else if (S_ISDIR(file->mode))
+					stats.created_dirs++;
+#ifdef SUPPORT_LINKS
+				else if (S_ISLNK(file->mode))
+					stats.created_symlinks++;
+#endif
+				else if (IS_DEVICE(file->mode))
+					stats.created_devices++;
+				else
+					stats.created_specials++;
+			}
 			continue;
 		}
 		if (phase == 2) {
 			rprintf(FERROR,
 				"got transfer request in phase 2 [%s]\n",
 				who_am_i());
@@ -251,31 +303,34 @@
 		} else {
 			if (csum_length != SHORT_SUM_LENGTH) {
 				make_backups = -make_backups;
 				append_mode = -append_mode;
 				csum_length = SHORT_SUM_LENGTH;
 			}
+			if (iflags & ITEM_IS_NEW)
+				stats.created_files++;
 		}
 
 		updating_basis_file = inplace && (protocol_version >= 29
 			? fnamecmp_type == FNAMECMP_FNAME : make_backups <= 0);
 
-		if (!am_server && do_progress)
+		if (!am_server && INFO_GTE(PROGRESS, 1))
 			set_current_file_index(file, ndx);
-		stats.num_transferred_files++;
+		stats.xferred_files++;
 		stats.total_transferred_size += F_LENGTH(file);
 
+		if (!log_before_transfer)
+			remember_initial_stats();
+
 		if (!do_xfers) { /* log the transfer */
-			log_item(FCLIENT, file, &stats, iflags, NULL);
+			log_item(FCLIENT, file, iflags, NULL);
 			write_ndx_and_attrs(f_out, ndx, iflags, fname, file,
 					    fnamecmp_type, xname, xlen);
 			continue;
 		}
 
-		initial_stats = stats;
-
 		if (!(s = receive_sums(f_in))) {
 			io_error |= IOERR_GENERAL;
 			rprintf(FERROR_XFER, "receive_sums failed\n");
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
@@ -303,45 +358,45 @@
 		/* map the local file */
 		if (do_fstat(fd, &st) != 0) {
 			io_error |= IOERR_GENERAL;
 			rsyserr(FERROR_XFER, errno, "fstat failed");
 			free_sums(s);
 			close(fd);
-			exit_cleanup(RERR_PROTOCOL);
+			exit_cleanup(RERR_FILEIO);
 		}
 
 		if (st.st_size) {
 			int32 read_size = MAX(s->blength * 3, MAX_MAP_SIZE);
 			mbuf = map_file(fd, st.st_size, read_size, s->blength);
 		} else
 			mbuf = NULL;
 
-		if (verbose > 2) {
-			rprintf(FINFO, "send_files mapped %s%s%s of size %.0f\n",
-				path,slash,fname, (double)st.st_size);
+		if (DEBUG_GTE(DELTASUM, 2)) {
+			rprintf(FINFO, "send_files mapped %s%s%s of size %s\n",
+				path,slash,fname, big_num(st.st_size));
 		}
 
 		write_ndx_and_attrs(f_out, ndx, iflags, fname, file,
 				    fnamecmp_type, xname, xlen);
 		write_sum_head(f_xfer, s);
 
-		if (verbose > 2)
+		if (DEBUG_GTE(DELTASUM, 2))
 			rprintf(FINFO, "calling match_sums %s%s%s\n", path,slash,fname);
 
 		if (log_before_transfer)
-			log_item(FCLIENT, file, &initial_stats, iflags, NULL);
-		else if (!am_server && verbose && do_progress)
+			log_item(FCLIENT, file, iflags, NULL);
+		else if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))
 			rprintf(FCLIENT, "%s\n", fname);
 
 		set_compression(fname);
 
 		match_sums(f_xfer, s, mbuf, st.st_size);
-		if (do_progress)
+		if (INFO_GTE(PROGRESS, 1))
 			end_progress(st.st_size);
 
-		log_item(log_code, file, &initial_stats, iflags, NULL);
+		log_item(log_code, file, iflags, NULL);
 
 		if (mbuf) {
 			j = unmap_file(mbuf);
 			if (j) {
 				io_error |= IOERR_GENERAL;
 				rsyserr(FERROR_XFER, j,
@@ -350,25 +405,25 @@
 			}
 		}
 		close(fd);
 
 		free_sums(s);
 
-		if (verbose > 2)
+		if (DEBUG_GTE(SEND, 1))
 			rprintf(FINFO, "sender finished %s%s%s\n", path,slash,fname);
 
 		/* Flag that we actually sent this entry. */
 		file->flags |= FLAG_FILE_SENT;
 	}
 	if (make_backups < 0)
 		make_backups = -make_backups;
 
 	if (io_error != save_io_error && protocol_version >= 30)
 		send_msg_int(MSG_IO_ERROR, io_error);
 
-	if (verbose > 2)
+	if (DEBUG_GTE(SEND, 1))
 		rprintf(FINFO, "send files finished\n");
 
 	match_report();
 
 	write_ndx(f_out, NDX_DONE);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/shconfig.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/shconfig.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/shconfig.in	2001-08-29 15:33:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/shconfig.in	2011-09-21 04:17:42.000000000 +0800
@@ -5,8 +5,11 @@
 # This file is processed by config.status to produce config.status,
 # containing autoconf-determined values needed by the test scripts.
 
 ECHO_T="@ECHO_T@"
 ECHO_N="@ECHO_N@"
 ECHO_C="@ECHO_C@"
+HOST_OS="@host_os@"
+SHELL_PATH="@SHELL_PATH@"
+FAKEROOT_PATH="@FAKEROOT_PATH@"
 
-export ECHO_T ECHO_N ECHO_C
+export ECHO_T ECHO_N ECHO_C HOST_OS SHELL_PATH FAKEROOT_PATH
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/socket.c	2011-08-07 02:23:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/socket.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Socket functions used in rsync.
  *
  * Copyright (C) 1992-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -22,13 +22,13 @@
 /* This file is now converted to use the new-style getaddrinfo()
  * interface, which supports IPv6 but is also supported on recent
  * IPv4-only machines.  On systems that don't have that interface, we
  * emulate it using the KAME implementation. */
 
 #include "rsync.h"
-#include "ifuncs.h"
+#include "itypes.h"
 #ifdef HAVE_NETINET_IN_SYSTM_H
 #include <netinet/in_systm.h>
 #endif
 #ifdef HAVE_NETINET_IP_H
 #include <netinet/ip.h>
 #endif
@@ -226,13 +226,13 @@
 			rprintf(FERROR,
 				"invalid proxy specification: should be HOST:PORT\n");
 			return -1;
 		}
 		*cp++ = '\0';
 		strlcpy(portbuf, cp, sizeof portbuf);
-		if (verbose >= 2) {
+		if (DEBUG_GTE(CONNECT, 1)) {
 			rprintf(FINFO, "connection via http proxy %s port %s\n",
 				h, portbuf);
 		}
 	} else {
 		snprintf(portbuf, sizeof portbuf, "%d", port);
 		h = host;
@@ -298,22 +298,22 @@
 		 && establish_proxy_connection(s, host, port,
 					       proxy_user, proxy_pass) != 0) {
 			close(s);
 			s = -1;
 			continue;
 		}
-		if (verbose >= 3) {
+		if (DEBUG_GTE(CONNECT, 2)) {
 			char buf[2048];
 			if ((error = getnameinfo(res->ai_addr, res->ai_addrlen, buf, sizeof buf, NULL, 0, NI_NUMERICHOST)) != 0)
 				snprintf(buf, sizeof buf, "*getnameinfo failure: %s*", gai_strerror(error));
 			rprintf(FINFO, "Connected to %s (%s)\n", h, buf);
 		}
 		break;
 	}
 
-	if (s < 0 || verbose >= 3) {
+	if (s < 0 || DEBUG_GTE(CONNECT, 2)) {
 		char buf[2048];
 		for (res = res0, j = 0; res; res = res->ai_next, j++) {
 			if (errnos[j] == 0)
 				continue;
 			if ((error = getnameinfo(res->ai_addr, res->ai_addrlen, buf, sizeof buf, NULL, 0, NI_NUMERICHOST)) != 0)
 				snprintf(buf, sizeof buf, "*getnameinfo failure: %s*", gai_strerror(error));
@@ -378,13 +378,13 @@
 			}
 			*t++ = *f;
 		}
 		*t = '\0';
 	}
 
-	if (verbose >= 2) {
+	if (DEBUG_GTE(CONNECT, 1)) {
 		rprintf(FINFO, "%sopening tcp connection to %s port %d\n",
 			prog ? "Using RSYNC_CONNECT_PROG instead of " : "",
 			host, port);
 	}
 	if (prog)
 		return sock_exec(prog);
@@ -486,13 +486,13 @@
 	if (all_ai)
 		freeaddrinfo(all_ai);
 
 	/* Only output the socket()/bind() messages if we were totally
 	 * unsuccessful, or if the daemon is being run with -vv. */
 	for (s = 0; s < ecnt; s++) {
-		if (!i || verbose > 1)
+		if (!i || DEBUG_GTE(BIND, 1))
 			rwrite(FLOG, errmsgs[s], strlen(errmsgs[s]), 0);
 		free(errmsgs[s]);
 	}
 	free(errmsgs);
 
 	if (!i) {
@@ -554,13 +554,13 @@
 	if (sp == NULL)
 		exit_cleanup(RERR_SOCKETIO);
 
 	/* ready to listen */
 	FD_ZERO(&deffds);
 	for (i = 0, maxfd = -1; sp[i] >= 0; i++) {
-		if (listen(sp[i], 5) < 0) {
+		if (listen(sp[i], lp_listen_backlog()) < 0) {
 			rsyserr(FERROR, errno, "listen() on socket failed");
 #ifdef INET6
 			if (errno == EADDRINUSE && i > 0) {
 				rprintf(FINFO,
 				    "Try using --ipv4 or --ipv6 to avoid this listen() error.\n");
 			}
@@ -828,13 +828,13 @@
 	int fd[2];
 
 	if (socketpair_tcp(fd) != 0) {
 		rsyserr(FERROR, errno, "socketpair_tcp failed");
 		return -1;
 	}
-	if (verbose >= 2)
+	if (DEBUG_GTE(CMD, 1))
 		rprintf(FINFO, "Running socket program: \"%s\"\n", prog);
 
 	pid = fork();
 	if (pid < 0) {
 		rsyserr(FERROR, errno, "fork");
 		exit_cleanup(RERR_IPC);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0: stunnel-rsyncd.conf.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0: stunnel-rsync.in
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/support/git-set-file-times /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support/git-set-file-times
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/support/git-set-file-times	2007-11-30 01:29:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support/git-set-file-times	2009-01-14 06:52:03.000000000 +0800
@@ -1,8 +1,9 @@
-#!/usr/bin/perl -w
+#!/usr/bin/perl
 use strict;
+use warnings;
 
 # Sets mtime and atime of files to the latest commit time in git.
 #
 # This is useful after the first clone of the rsync repository BEFORE you
 # do any building.  It is also safe if you have done a "make distclean".
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support: instant-rsyncd
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/support/lsh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support/lsh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/support/lsh	2011-06-25 06:11:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support/lsh	2013-06-10 10:40:56.000000000 +0800
@@ -1,33 +1,81 @@
-#!/bin/sh
+#!/usr/bin/perl
 # This script can be used as a "remote shell" command that is only
 # capable of pretending to connect to "localhost".  This is useful
 # for testing or for running a local copy where the sender and the
 # receiver needs to use different options (e.g. --fake-super).  If
-# we get a -l USER option, we try to use "sudo -u USER" to run the
-# command.
+# we get -l USER, we try to become the USER, either directly (must
+# be root) or by using "sudo -H -u USER" (requires --sudo option).
 
-user=''
-do_cd=y # Default path is user's home dir, just like ssh.
+use strict;
+use warnings;
+use Getopt::Long;
+use English '-no_match_vars';
 
-while : ; do
-    case "$1" in
-    -l) user="$2"; shift; shift ;;
-    -l*) user=`echo "$1" | sed 's/^-l//'`; shift ;;
-    --no-cd) do_cd=n; shift ;;
-    -*) shift ;;
-    localhost) shift; break ;;
-    *) echo "lsh: unable to connect to host $1" 1>&2; exit 1 ;;
-    esac
-done
-
-if [ "$user" ]; then
-    prefix=''
-    if [ $do_cd = y ]; then
-	home=`perl -e "print((getpwnam('$user'))[7])"`
-	prefix="cd '$home' ;"
-    fi
-    sudo -H -u "$user" sh -c "$prefix $*"
-else
-    [ $do_cd = y ] && cd
-    eval "${@}"
-fi
+&Getopt::Long::Configure('bundling');
+&Getopt::Long::Configure('require_order');
+GetOptions(
+    'l=s' => \( my $login_name ),
+    '1|2|4|6|A|a|C|f|g|k|M|N|n|q|s|T|t|V|v|X|x|Y' => sub { }, # Ignore
+    'b|c|D|e|F|i|L|m|O|o|p|R|S|w=s' => sub { }, # Ignore
+    'no-cd' => \( my $no_chdir ),
+    'sudo' => \( my $use_sudo ),
+) or &usage;
+&usage unless @ARGV > 1;
+
+my $host = shift;
+if ($host =~ s/^([^@]+)\@//) {
+    $login_name = $1;
+}
+if ($host ne 'localhost') {
+    die "lsh: unable to connect to host $host\n";
+}
+
+my ($home_dir, @cmd);
+if ($login_name) {
+    my ($uid, $gid);
+    if ($login_name =~ /\D/) {
+	$uid = getpwnam($login_name);
+	die "Unknown user: $login_name\n" unless defined $uid;
+    } else {
+	$uid = $login_name;
+    }
+    ($login_name, $gid, $home_dir) = (getpwuid($uid))[0,3,7];
+    if ($use_sudo) {
+	unshift @ARGV, "cd '$home_dir' &&" unless $no_chdir;
+	unshift @cmd, qw( sudo -H -u ), $login_name;
+	$no_chdir = 1;
+    } else {
+	my $groups = "$gid $gid";
+	while (my ($grgid, $grmembers) = (getgrent)[2,3]) {
+	    if ($grgid != $gid && $grmembers =~ /(^|\s)\Q$login_name\E(\s|$)/o) {
+		$groups .= " $grgid";
+	    }
+	}
+
+	my ($ruid, $euid) = ($UID, $EUID);
+	$GID = $EGID = $groups;
+	$UID = $EUID = $uid;
+	die "Cannot set ruid: $! (use --sudo?)\n" if $UID == $ruid && $ruid != $uid;
+	die "Cannot set euid: $! (use --sudo?)\n" if $EUID == $euid && $euid != $uid;
+
+	$ENV{USER} = $ENV{USERNAME} = $login_name;
+	$ENV{HOME} = $home_dir;
+    }
+} else {
+    $home_dir = (getpwuid($UID))[7];
+}
+
+unless ($no_chdir) {
+    chdir $home_dir or die "Unable to chdir to $home_dir: $!\n";
+}
+
+push @cmd, '/bin/sh', '-c', "@ARGV";
+exec @cmd;
+die "Failed to exec: $!\n";
+
+sub usage
+{
+    die <<EOT;
+Usage: lsh [-l user] [--sudo] [--no-cd] localhost COMMAND [...]
+EOT
+}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support: lsh.sh
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support: mapfrom
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support: mapto
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/support/rrsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support/rrsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/support/rrsync	2010-07-01 00:17:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support/rrsync	2010-05-27 02:24:00.000000000 +0800
@@ -71,21 +71,24 @@
   'delete' => 0,
   'delete-after' => 0,
   'delete-before' => 0,
   'delete-delay' => 0,
   'delete-during' => 0,
   'delete-excluded' => 0,
+  'delete-missing-args' => 0,
   'existing' => 0,
   'fake-super' => 0,
   'files-from' => 3,
   'force' => 0,
   'from0' => 0,
   'fuzzy' => 0,
+  'groupmap' => 1,
   'iconv' => 1,
   'ignore-errors' => 0,
   'ignore-existing' => 0,
+  'ignore-missing-args' => 0,
   'inplace' => 0,
   'link-dest' => 2,
   'list-only' => 0,
   'log-file' => 3,
   'log-format' => 1,
   'max-delete' => 1,
@@ -111,12 +114,13 @@
   'stats' => 0,
   'suffix' => 1,
   'super' => 0,
   'temp-dir' => 2,
   'timeout' => 1,
   'use-qsort' => 0,
+  'usermap' => 1,
 );
 
 ### END of options data produced by the cull_options script. ###
 
 if ($short_disabled ne '') {
     $short_no_arg =~ s/[$short_disabled]//go;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/support: rsync-slash-strip
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/syscall.c	2011-02-22 03:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/syscall.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * Syscall wrappers to ensure that nothing gets done in dry_run mode
  * and to handle system peculiarities.
  *
  * Copyright (C) 1998 Andrew Tridgell
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -26,14 +26,19 @@
 #include <sys/un.h>
 #endif
 #ifdef HAVE_SYS_ATTR_H
 #include <sys/attr.h>
 #endif
 
+#if defined HAVE_SYS_FALLOCATE && !defined HAVE_FALLOCATE
+#include <sys/syscall.h>
+#endif
+
 extern int dry_run;
 extern int am_root;
+extern int am_sender;
 extern int read_only;
 extern int list_only;
 extern int preserve_perms;
 extern int preserve_executability;
 
 #define RETURN_ERROR_IF(x,e) \
@@ -50,19 +55,61 @@
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	return unlink(fname);
 }
 
-int do_symlink(const char *fname1, const char *fname2)
+#ifdef SUPPORT_LINKS
+int do_symlink(const char *lnk, const char *fname)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
-	return symlink(fname1, fname2);
+
+#if defined NO_SYMLINK_XATTRS || defined NO_SYMLINK_USER_XATTRS
+	/* For --fake-super, we create a normal file with mode 0600
+	 * and write the lnk into it. */
+	if (am_root < 0) {
+		int ok, len = strlen(lnk);
+		int fd = open(fname, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR);
+		if (fd < 0)
+			return -1;
+		ok = write(fd, lnk, len) == len;
+		if (close(fd) < 0)
+			ok = 0;
+		return ok ? 0 : -1;
+	}
+#endif
+
+	return symlink(lnk, fname);
 }
 
+#if defined NO_SYMLINK_XATTRS || defined NO_SYMLINK_USER_XATTRS
+ssize_t do_readlink(const char *path, char *buf, size_t bufsiz)
+{
+	/* For --fake-super, we read the link from the file. */
+	if (am_root < 0) {
+		int fd = do_open_nofollow(path, O_RDONLY);
+		if (fd >= 0) {
+			int len = read(fd, buf, bufsiz);
+			close(fd);
+			return len;
+		}
+		if (errno != ELOOP)
+			return -1;
+		/* A real symlink needs to be turned into a fake one on the receiving
+		 * side, so tell the generator that the link has no length. */
+		if (!am_sender)
+			return 0;
+		/* Otherwise fall through and let the sender report the real length. */
+	}
+
+	return readlink(path, buf, bufsiz);
+}
+#endif
+#endif
+
 #ifdef HAVE_LINK
 int do_link(const char *fname1, const char *fname2)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	return link(fname1, fname2);
@@ -371,6 +418,74 @@
 # endif
 }
 
 #else
 #error Need utimes or utime function.
 #endif
+
+#ifdef SUPPORT_PREALLOCATION
+int do_fallocate(int fd, OFF_T offset, OFF_T length)
+{
+#ifdef FALLOC_FL_KEEP_SIZE
+#define DO_FALLOC_OPTIONS FALLOC_FL_KEEP_SIZE
+#else
+#define DO_FALLOC_OPTIONS 0
+#endif
+	RETURN_ERROR_IF(dry_run, 0);
+	RETURN_ERROR_IF_RO_OR_LO;
+#if defined HAVE_FALLOCATE
+	return fallocate(fd, DO_FALLOC_OPTIONS, offset, length);
+#elif defined HAVE_SYS_FALLOCATE
+	return syscall(SYS_fallocate, fd, DO_FALLOC_OPTIONS, (loff_t)offset, (loff_t)length);
+#elif defined HAVE_EFFICIENT_POSIX_FALLOCATE
+	return posix_fallocate(fd, offset, length);
+#else
+#error Coding error in SUPPORT_PREALLOCATION logic.
+#endif
+}
+#endif
+
+int do_open_nofollow(const char *pathname, int flags)
+{
+#ifndef O_NOFOLLOW
+	STRUCT_STAT f_st, l_st;
+#endif
+	int fd;
+
+	if (flags != O_RDONLY) {
+		RETURN_ERROR_IF(dry_run, 0);
+		RETURN_ERROR_IF_RO_OR_LO;
+#ifndef O_NOFOLLOW
+		/* This function doesn't support write attempts w/o O_NOFOLLOW. */
+		errno = EINVAL;
+		return -1;
+#endif
+	}
+
+#ifdef O_NOFOLLOW
+	fd = open(pathname, flags|O_NOFOLLOW);
+#else
+	if (do_lstat(pathname, &l_st) < 0)
+		return -1;
+	if (S_ISLNK(l_st.st_mode)) {
+		errno = ELOOP;
+		return -1;
+	}
+	if ((fd = open(pathname, flags)) < 0)
+		return fd;
+	if (do_fstat(fd, &f_st) < 0) {
+	  close_and_return_error:
+		{
+			int save_errno = errno;
+			close(fd);
+			errno = save_errno;
+		}
+		return -1;
+	}
+	if (l_st.st_dev != f_st.st_dev || l_st.st_ino != f_st.st_ino) {
+		errno = EINVAL;
+		goto close_and_return_error;
+	}
+#endif
+
+	return fd;
+}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0: testrun.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/00-hello.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/00-hello.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/00-hello.test	2002-12-24 15:25:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/00-hello.test	2008-07-15 13:47:03.000000000 +0800
@@ -1,5 +1,14 @@
 #! /bin/sh
 
+test_fail() {
+    echo "$@" >&2
+    exit 1
+}
+
 echo $0 running
 
-$RSYNC --version || exit 1
+$RSYNC --version || test_fail '--version output failed'
+
+$RSYNC --info=help || test_fail '--info=help output failed'
+
+$RSYNC --debug=help || test_fail '--debug=help output failed'
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/acls.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/acls.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/acls.test	2007-09-29 10:26:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/acls.test	2009-10-25 02:42:29.000000000 +0800
@@ -2,13 +2,13 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test that rsync handles basic ACL preservation.
 
-. $srcdir/testsuite/rsync.fns
+. $suitedir/rsync.fns
 
 $RSYNC --version | grep ", ACLs" >/dev/null || test_skipped "Rsync is configured without ACL support"
 
 makepath "$fromdir/foo"
 echo something >"$fromdir/file1"
 echo else >"$fromdir/file2"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/backup.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/backup.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/backup.test	2008-06-18 06:59:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/backup.test	2009-01-04 04:02:47.000000000 +0800
@@ -8,59 +8,59 @@
 # Test that the --backup option works right.
 
 . "$suitedir/rsync.fns"
 
 bakdir="$tmpdir/bak"
 
-makepath "$fromdir/deep" "$bakdir"
+makepath "$fromdir/deep" "$bakdir/dname"
 name1="$fromdir/deep/name1"
 name2="$fromdir/deep/name2"
 
 outfile="$scratchdir/rsync.out"
 
 cat "$srcdir"/[gr]*.[ch] > "$name1"
 cat "$srcdir"/[et]*.[ch] > "$name2"
 
-checkit "$RSYNC -avv '$fromdir/' '$todir/'" "$fromdir" "$todir"
+checkit "$RSYNC -ai --info=backup '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
-checkit "$RSYNC -avv '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
+checkit "$RSYNC -ai --info=backup '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
 cat "$srcdir"/[fgpr]*.[ch] > "$name1"
 cat "$srcdir"/[etw]*.[ch] > "$name2"
 
-$RSYNC -avv --no-whole-file --backup "$fromdir/" "$todir/" \
+$RSYNC -ai --info=backup --no-whole-file --backup "$fromdir/" "$todir/" \
     | tee "$outfile"
 for fn in deep/name1 deep/name2; do
     grep "backed up $fn to $fn~" "$outfile" >/dev/null || test_fail "no backup message output for $fn"
     diff $diffopt "$fromdir/$fn" "$todir/$fn" || test_fail "copy of $fn failed"
     diff $diffopt "$chkdir/$fn" "$todir/$fn~" || test_fail "backup of $fn to $fn~ failed"
     mv "$todir/$fn~" "$todir/$fn"
 done
 
 echo deleted-file >"$todir/dname"
 cp_touch "$todir/dname" "$chkdir"
 
-checkit "$RSYNC -avv --no-whole-file --delete-delay \
+checkit "$RSYNC -ai --info=backup --no-whole-file --delete-delay \
     --backup --backup-dir='$bakdir' '$fromdir/' '$todir/'" "$fromdir" "$todir" \
     | tee "$outfile"
 
 for fn in deep/name1 deep/name2; do
     grep "backed up $fn to .*/$fn$" "$outfile" >/dev/null || test_fail "no backup message output for $fn"
 done
 diff -r $diffopt "$chkdir" "$bakdir" || test_fail "backup dir contents are bogus"
 rm "$bakdir/dname"
 
-checkit "$RSYNC -avv --del '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
+checkit "$RSYNC -ai --info=backup --del '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
 cat "$srcdir"/[efgr]*.[ch] > "$name1"
 cat "$srcdir"/[ew]*.[ch] > "$name2"
 
-checkit "$RSYNC -avv --inplace --no-whole-file --backup --backup-dir='$bakdir' '$fromdir/' '$todir/'" "$fromdir" "$todir" \
+checkit "$RSYNC -ai --info=backup --inplace --no-whole-file --backup --backup-dir='$bakdir' '$fromdir/' '$todir/'" "$fromdir" "$todir" \
     | tee "$outfile"
 
 for fn in deep/name1 deep/name2; do
     grep "backed up $fn to .*/$fn$" "$outfile" >/dev/null || test_fail "no backup message output for $fn"
 done
 diff -r $diffopt "$chkdir" "$bakdir" || test_fail "backup dir contents are bogus"
 
-checkit "$RSYNC -avv --inplace --no-whole-file '$fromdir/' '$bakdir/'" "$fromdir" "$bakdir"
+checkit "$RSYNC -ai --info=backup --inplace --no-whole-file '$fromdir/' '$bakdir/'" "$fromdir" "$bakdir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/chmod-option.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/chmod-option.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/chmod-option.test	2007-09-04 04:43:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/chmod-option.test	2009-10-25 02:42:29.000000000 +0800
@@ -4,13 +4,13 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test that the --chmod option functions correctly.
 
-. $srcdir/testsuite/rsync.fns
+. $suitedir/rsync.fns
 
 # Build some files
 
 fromdir="$scratchdir/from"
 todir="$scratchdir/to"
 checkdir="$scratchdir/check"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/chown.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/chown.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/chown.test	2009-12-14 11:35:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/chown.test	2011-09-21 04:24:42.000000000 +0800
@@ -15,20 +15,31 @@
 
 case $0 in
 *fake*)
     $RSYNC --version | grep ", xattrs" >/dev/null || test_skipped "Rsync needs xattrs for fake device tests"
     RSYNC="$RSYNC --fake-super"
     TLS_ARGS="$TLS_ARGS --fake-super"
-    case "`xattr 2>&1`" in
-    *--list:*)
+    case "$HOST_OS" in
+    darwin*)
 	chown() {
 	    own=$1
 	    shift
 	    xattr -s 'rsync.%stat' "100644 0,0 $own" "${@}"
 	}
 	;;
+    solaris*)
+	chown() {
+	    own=$1
+	    shift
+	    for fn in "${@}"; do
+		runat "$fn" "$SHELL_PATH" <<EOF
+echo "100644 0,0 $own" > rsync.%stat
+EOF
+	    done
+	}
+	;;
     *)
 	chown() {
 	    own=$1
 	    shift
 	    setfattr -n 'user.rsync.%stat' -v "100644 0,0 $own" "${@}"
 	}
@@ -37,15 +48,15 @@
     ;;
 *)
     RSYNC="$RSYNC --super"
     case `get_testuid` in
     '') ;; # If "id" failed, try to continue...
     0)  ;;
-    *)  if [ -f /usr/bin/fakeroot ]; then
+    *)  if [ -e "$FAKEROOT_PATH" ]; then
 	    echo "Let's try re-running the script under fakeroot..."
-	    exec /usr/bin/fakeroot /bin/sh "$0"
+	    exec "$FAKEROOT_PATH" "$SHELL_PATH" "$0"
 	fi
 	;;
     esac
     ;;
 esac
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/daemon.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/daemon.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/daemon.test	2009-12-14 11:35:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/daemon.test	2013-06-10 10:40:56.000000000 +0800
@@ -21,15 +21,15 @@
 
 . "$suitedir/rsync.fns"
 
 chkfile="$scratchdir/rsync.chk"
 outfile="$scratchdir/rsync.out"
 
-SSH="src/support/lsh --no-cd"
+SSH="src/support/lsh.sh --no-cd"
 FILE_REPL='s/^\([^d][^ ]*\) *\(..........[0-9]\) /\1 \2 /'
-DIR_REPL='s/^\(d[^ ]*\)  *[0-9][0-9]* /\1         DIR /'
+DIR_REPL='s/^\(d[^ ]*\)  *[0-9][.,0-9]* /\1         DIR /'
 LS_REPL='s;[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9];####/##/## ##:##:##;'
 
 build_rsyncd_conf
 
 makepath "$fromdir/foo" "$fromdir/bar/baz"
 makepath "$todir"
@@ -47,25 +47,28 @@
     # Root needs to specify the config file, or it uses /etc/rsyncd.conf.
     echo "Forcing --config=$conf"
     confopt=" --config=$conf"
     ;;
 esac
 
-$RSYNC -ve "$SSH" --rsync-path="$RSYNC$confopt" localhost::
-
-RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
-export RSYNC_CONNECT_PROG
-
-$RSYNC -v localhost:: \
-    | tee "$outfile"
 # These have a space-padded 15-char name, then a tab, then a comment.
 sed 's/NOCOMMENT//' <<EOT >"$chkfile"
 test-from      	r/o
 test-to        	r/w
 test-scratch   	NOCOMMENT
 EOT
+
+$RSYNC -ve "$SSH" --rsync-path="$RSYNC$confopt" localhost:: | tee "$outfile"
+echo '===='
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 0 failed"
+
+RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
+export RSYNC_CONNECT_PROG
+
+$RSYNC -v localhost:: | tee "$outfile"
+echo '===='
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 1 failed"
 
 $RSYNC -r localhost::test-hidden \
     | sed "$FILE_REPL" | sed "$DIR_REPL" | sed "$LS_REPL" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/default-acls.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/default-acls.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/default-acls.test	2007-06-03 00:30:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/default-acls.test	2009-10-25 02:42:29.000000000 +0800
@@ -2,13 +2,13 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test that rsync obeys default ACLs. -- Matt McCutchen
 
-. $srcdir/testsuite/rsync.fns
+. $suitedir/rsync.fns
 
 $RSYNC --version | grep ", ACLs" >/dev/null || test_skipped "Rsync is configured without ACL support"
 
 case "$setfacl_nodef" in
 true) test_skipped "I don't know how to use your setfacl command" ;;
 *-k*) opts='-dm u::7,g::5,o:5' ;;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/devices.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/devices.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/devices.test	2011-02-22 23:59:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/devices.test	2011-09-21 04:24:42.000000000 +0800
@@ -16,14 +16,14 @@
 
 case $0 in
 *fake*)
     $RSYNC --version | grep ", xattrs" >/dev/null || test_skipped "Rsync needs xattrs for fake device tests"
     RSYNC="$RSYNC --fake-super"
     TLS_ARGS="$TLS_ARGS --fake-super"
-    case "`xattr 2>&1`" in
-    *--list:*)
+    case "$HOST_OS" in
+    darwin*)
 	mknod() {
 	    fn="$1"
 	    case "$2" in
 	    p) mode=10644 ;;
 	    c) mode=20644 ;;
 	    b) mode=60644 ;;
@@ -31,12 +31,28 @@
 	    maj="${3:-0}"
 	    min="${4:-0}"
 	    touch "$fn"
 	    xattr -s 'rsync.%stat' "$mode $maj,$min 0:0" "$fn"
 	}
 	;;
+    solaris*)
+	mknod() {
+	    fn="$1"
+	    case "$2" in
+	    p) mode=10644 ;;
+	    c) mode=20644 ;;
+	    b) mode=60644 ;;
+	    esac
+	    maj="${3:-0}"
+	    min="${4:-0}"
+	    touch "$fn"
+	    runat "$fn" "$SHELL_PATH" <<EOF
+echo "$mode $maj,$min 0:0" > rsync.%stat
+EOF
+	}
+	;;
     *)
 	mknod() {
 	    fn="$1"
 	    case "$2" in
 	    p) mode=10644 ;;
 	    c) mode=20644 ;;
@@ -51,15 +67,15 @@
     esac
     ;;
 *)
     case `get_testuid` in
     '') ;; # If "id" failed, try to continue...
     0)  ;;
-    *)  if [ -f /usr/bin/fakeroot ]; then
+    *)  if [ -e "$FAKEROOT_PATH" ]; then
 	    echo "Let's try re-running the script under fakeroot..."
-	    exec /usr/bin/fakeroot /bin/sh $RUNSHFLAGS "$0"
+	    exec "$FAKEROOT_PATH" "$SHELL_PATH" $RUNSHFLAGS "$0"
 	fi
 	test_skipped "Rsync needs root/fakeroot for device tests"
 	;;
     esac
     ;;
 esac
@@ -71,13 +87,13 @@
 mknod "$fromdir/char" c 41 67  || test_skipped "Can't create char device node"
 mknod "$fromdir/char2" c 42 68  || test_skipped "Can't create char device node"
 mknod "$fromdir/char3" c 42 69  || test_skipped "Can't create char device node"
 mknod "$fromdir/block" b 42 69 || test_skipped "Can't create block device node"
 mknod "$fromdir/block2" b 42 73 || test_skipped "Can't create block device node"
 mknod "$fromdir/block3" b 105 73 || test_skipped "Can't create block device node"
-ln "$fromdir/block3" "$fromdir/block2.5" || echo "Skipping hard-linked device test..."
+ln "$fromdir/block3" "$fromdir/block3.5" || echo "Skipping hard-linked device test..."
 mkfifo "$fromdir/fifo" || mknod "$fromdir/fifo" p || test_skipped "Can't run mkfifo"
 # Work around time rounding/truncating issue by touching both files.
 touch -r "$fromdir/block" "$fromdir/block" "$fromdir/block2"
 
 $RSYNC -ai "$fromdir/block" "$todir/block2" \
     | tee "$outfile"
@@ -107,40 +123,40 @@
 filter_outfile
 cat <<EOT >"$chkfile"
 .d..t.$dots ./
 cDc.t.$dots block
 cDc...$dots block2
 cD$all_plus block3
-hD$all_plus block2.5 => block3
+hD$all_plus block3.5 => block3
 cD$all_plus char
 cD$all_plus char2
 cD$all_plus char3
 cS$all_plus fifo
 EOT
-if test ! -r "$fromdir/block2.5"; then
-    grep -v block2.5 <"$chkfile" >"$chkfile.new"
+if test ! -r "$fromdir/block3.5"; then
+    grep -v block3.5 <"$chkfile" >"$chkfile.new"
     mv "$chkfile.new" "$chkfile"
 fi
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 4 failed"
 
 echo "check how the directory listings compare with diff:"
 echo ""
 ( cd "$fromdir" && rsync_ls_lR . ) > "$tmpdir/ls-from"
 ( cd "$todir" && rsync_ls_lR . ) > "$tmpdir/ls-to"
 diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to"
 
-if test -r "$fromdir/block2.5"; then
+if test -r "$fromdir/block3.5"; then
     set -x
     $RSYNC -aii --link-dest="$todir" "$fromdir/" "$chkdir/" \
 	| tee "$outfile"
     cat <<EOT >"$chkfile"
 cd$allspace ./
 hD$allspace block
 hD$allspace block2
-hD$allspace block2.5
 hD$allspace block3
+hD$allspace block3.5
 hD$allspace char
 hD$allspace char2
 hD$allspace char3
 hS$allspace fifo
 EOT
     diff $diffopt "$chkfile" "$outfile" || test_fail "test 5 failed"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/dir-sgid.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/dir-sgid.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/dir-sgid.test	2006-02-05 03:42:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/dir-sgid.test	2011-09-22 23:28:07.000000000 +0800
@@ -2,13 +2,13 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test that rsync obeys directory setgid. -- Matt McCutchen
 
-. $srcdir/testsuite/rsync.fns
+. $suitedir/rsync.fns
 
 umask 077
 
 # Call as: testit <dirname> <dirperms> <file-expected> <program-expected> <dir-expected>
 testit() {
     todir="$scratchdir/$1"
@@ -23,19 +23,19 @@
     check_perms "$todir/to/program" $4 "Target $1"
 }
 
 echo "File!" >"$scratchdir/file"
 echo "#!/bin/sh" >"$scratchdir/program"
 mkdir "$scratchdir/dir"
-chmod 2764 "$scratchdir/dir" || test_skipped "Can't chmod"
+chmod u=rwx,g=rw,g+s,o=r "$scratchdir/dir" || test_skipped "Can't chmod"
 chmod 664 "$scratchdir/file"
 chmod 775 "$scratchdir/program"
 [ -g "$scratchdir/dir" ] || test_skipped "The directory setgid bit vanished!"
 mkdir "$scratchdir/dir/blah"
 [ -g "$scratchdir/dir/blah" ] || test_skipped "Your filesystem doesn't use directory setgid; maybe it's BSD."
 
 # Test some target directories
 testit setgid-off 700 rw------- rwx------ rwx------
-testit setgid-on 2700 rw------- rwx------ rwx--S---
+testit setgid-on u=rwx,g=rw,g+s,o-rwx rw------- rwx------ rwx--S---
 
 # Hooray
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/executability.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/executability.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/executability.test	2006-02-05 03:28:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/executability.test	2009-10-25 02:42:29.000000000 +0800
@@ -2,13 +2,13 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test the --executability or -E option. -- Matt McCutchen
 
-. $srcdir/testsuite/rsync.fns
+. $suitedir/rsync.fns
 
 # Put some files in the From directory
 mkdir "$fromdir"
 cat <<EOF >"$fromdir/1"
 #!/bin/sh
 echo 'Program One!'
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/files-from.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/files-from.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/files-from.test	2008-11-10 13:39:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/files-from.test	2013-06-10 10:40:56.000000000 +0800
@@ -6,12 +6,14 @@
 # COPYING).
 
 # Test that --files-from=FILE works right.
 
 . "$suitedir/rsync.fns"
 
+SSH="$scratchdir/src/support/lsh.sh"
+
 hands_setup
 
 # This list of files skips the contents of "subsubdir" but includes
 # the contents of "subsubdir2" due to its trailing slash.
 cat >"$scratchdir/filelist" <<EOT
 from/./
@@ -23,8 +25,21 @@
 
 # Create a chkdir without the content that we expect to be omitted.
 $RSYNC -a --exclude=dir/text --exclude='subsubdir/**' "$fromdir/" "$chkdir/"
 
 checkit "$RSYNC -av --files-from='$scratchdir/filelist' '$scratchdir' '$todir/'" "$chkdir" "$todir"
 
+for filehost in '' 'localhost:'; do
+    for srchost in '' 'localhost:'; do
+	if [ -z "$srchost" ]; then
+	    desthost='localhost:'
+	else
+	    desthost=''
+	fi
+
+	rm -rf "$todir"
+	checkit "$RSYNC -avse '$SSH' --rsync-path='$RSYNC' --files-from='$filehost$scratchdir/filelist' '$srchost$scratchdir' '$desthost$todir/'" "$chkdir" "$todir"
+    done
+done
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/hands.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/hands.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/hands.test	2007-03-19 04:40:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/hands.test	2008-07-21 13:28:19.000000000 +0800
@@ -6,27 +6,29 @@
 # This program is distributable under the terms of the GNU GPL (see COPYING)
 
 . "$suitedir/rsync.fns"
 
 hands_setup
 
+DEBUG_OPTS="--debug=all0,deltasum0"
+
 # Main script starts here
 
 runtest "basic operation" 'checkit "$RSYNC -av \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 ln "$fromdir/filelist" "$fromdir/dir"
-runtest "hard links" 'checkit "$RSYNC -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
+runtest "hard links" 'checkit "$RSYNC -avH $DEBUG_OPTS \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 rm "$todir/text"
-runtest "one file" 'checkit "$RSYNC -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
+runtest "one file" 'checkit "$RSYNC -avH $DEBUG_OPTS \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 echo "extra line" >> "$todir/text"
-runtest "extra data" 'checkit "$RSYNC -avH --no-whole-file \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
+runtest "extra data" 'checkit "$RSYNC -avH $DEBUG_OPTS --no-whole-file \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 cp "$fromdir/text" "$todir/ThisShouldGo"
-runtest " --delete" 'checkit "$RSYNC --delete -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
+runtest " --delete" 'checkit "$RSYNC --delete -avH $DEBUG_OPTS \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 cd "$tmpdir"
 rm -rf to from/*dir
 
 # Do the real copy, touch up the parent-dir's time, and then check the copy.
 $RSYNC -av from/* to/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/hardlinks.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/hardlinks.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/hardlinks.test	2011-03-27 01:01:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/hardlinks.test	2013-06-10 10:40:56.000000000 +0800
@@ -8,13 +8,13 @@
 # Test rsync handling of hardlinks.  By default, rsync does not detect
 # hard links and they get sent as separate files.  If you specify -H,
 # then hard links are detected and linked together on the receiver.
 
 . "$suitedir/rsync.fns"
 
-SSH="$scratchdir/src/support/lsh"
+SSH="$scratchdir/src/support/lsh.sh"
 
 outfile="$scratchdir/rsync.out"
 
 # Build some hardlinks
 
 fromdir="$scratchdir/from"
@@ -30,17 +30,17 @@
 echo "This is the file" > "$name1"
 ln "$name1" "$name2" || test_skipped "Can't create hardlink"
 ln "$name2" "$name3" || fail "Can't create hardlink"
 cp "$name2" "$name4" || fail "Can't copy file"
 cat $srcdir/*.c >"$fromdir/text"
 
-checkit "$RSYNC -aHivv '$fromdir/' '$todir/'" "$fromdir" "$todir"
+checkit "$RSYNC -aHivv --debug=HLINK5 '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 echo "extra extra" >>"$todir/name1"
 
-checkit "$RSYNC -aHivv --no-whole-file '$fromdir/' '$todir/'" "$fromdir" "$todir"
+checkit "$RSYNC -aHivv --debug=HLINK5 --no-whole-file '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 # Add a new link in a new subdirectory to test that we don't try to link
 # the files before the directory gets created.  We also create a bunch of
 # extra files to ensure that an incremental-recursion transfer works across
 # distant files.
 makepath "$fromdir/subdir/down/deep"
@@ -53,31 +53,31 @@
 done
 (cd "$fromdir/subdir"; touch $files)
 
 ln "$name1" "$fromdir/subdir/down/deep/new-file"
 rm "$todir/text"
 
-checkit "$RSYNC -aHivve '$SSH' --rsync-path='$RSYNC' '$fromdir/' localhost:'$todir/'" "$fromdir" "$todir"
+checkit "$RSYNC -aHivve '$SSH' --debug=HLINK5 --rsync-path='$RSYNC' '$fromdir/' localhost:'$todir/'" "$fromdir" "$todir"
 
 # Do some duplicate copies using --link-dest and --copy-dest to test that
 # we hard-link all locally-inherited items.
-checkit "$RSYNC -aHivv --link-dest='$todir' '$fromdir/' '$chkdir/'" "$todir" "$chkdir"
+checkit "$RSYNC -aHivv --debug=HLINK5 --link-dest='$todir' '$fromdir/' '$chkdir/'" "$todir" "$chkdir"
 
 rm -rf "$chkdir"
-checkit "$RSYNC -aHivv --copy-dest='$todir' '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
+checkit "$RSYNC -aHivv --debug=HLINK5 --copy-dest='$todir' '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
 
 # Create a hard link that has only one part in the hierarchy.
 echo "This is another file" >"$fromdir/solo"
 ln "$fromdir/solo" "$chkdir/solo" || fail "Can't create hardlink"
 
 # Make sure that the checksum data doesn't slide due to an HLINK_BUMP() change.
-$RSYNC -aHivc "$fromdir/" "$chkdir/" | tee "$outfile"
+$RSYNC -aHivc --debug=HLINK5 "$fromdir/" "$chkdir/" | tee "$outfile"
 grep solo "$outfile" && test_fail "Erroneous copy of solo file occurred!"
 
 # Make sure there's nothing wrong with sending a single file with -H
 # enabled (this has broken twice so far, so we need this test).
 rm -rf "$todir"
-$RSYNC -aHivv "$name1" "$todir/"
+$RSYNC -aHivv --debug=HLINK5 "$name1" "$todir/"
 diff $diffopt "$name1" "$todir" || test_fail "solo copy of name1 failed"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/itemize.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/itemize.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/itemize.test	2010-06-30 23:29:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/itemize.test	2010-04-25 00:34:43.000000000 +0800
@@ -105,15 +105,15 @@
 $RSYNC -vvplrH "$fromdir/" "$todir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
 bar/baz/rsync is uptodate
 foo/config1 is uptodate
-foo/config2
 foo/extra is uptodate
 foo/sym is uptodate
+foo/config2
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 4 failed"
 
 chmod 747 "$todir/bar/baz/rsync"
 $RSYNC -a -f '-! */' "$fromdir/" "$todir"
 $RSYNC -ivvplrtH "$fromdir/" "$todir/" \
@@ -200,14 +200,14 @@
 bar/ is uptodate
 bar/baz/ is uptodate
 bar/baz/rsync is uptodate
 foo/ is uptodate
 foo/config1 is uptodate
 foo/config2 is uptodate
-foo/extra => foo/config1
 foo/sym $is_uptodate
+foo/extra => foo/config1
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 10 failed"
 
 rm -rf "$to2dir"
 $RSYNC -ivvplrtH --link-dest="$todir" "$fromdir/" "$to2dir/" \
     | tee "$outfile"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/missing.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/missing.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/missing.test	2008-03-19 23:59:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/missing.test	2009-10-25 02:42:29.000000000 +0800
@@ -2,13 +2,13 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test three bugs fixed by my redoing of the missing_below logic.
 
-. $srcdir/testsuite/rsync.fns
+. $suitedir/rsync.fns
 
 makepath "$fromdir/subdir" "$todir"
 echo data >"$fromdir/subdir/file"
 echo data >"$todir/other"
 
 # Test 1: Too much "not creating new..." output on a dry run
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/rsync.fns /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/rsync.fns
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/rsync.fns	2011-03-14 11:48:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/rsync.fns	2011-03-14 11:48:18.000000000 +0800
@@ -29,13 +28,13 @@
 dots='.....' # trailing dots after changes
 tab_ch='	' # a single tab character
 
 # Berkley's nice.
 PATH="$PATH:/usr/ucb"
 
-if diff -u "$srcdir/testsuite/rsync.fns" "$srcdir/testsuite/rsync.fns" >/dev/null 2>&1; then
+if diff -u "$suitedir/rsync.fns" "$suitedir/rsync.fns" >/dev/null 2>&1; then
     diffopt="-u"
 else
     diffopt="-c"
 fi
 
 HOME="$scratchdir"
@@ -260,26 +259,37 @@
 
     port=2612
     pidfile="$scratchdir/rsyncd.pid"
     logfile="$scratchdir/rsyncd.log"
     hostname=`uname -n`
 
+    uid_setting='uid = 0'
+    gid_setting='gid = 0'
+    case `get_testuid` in
+    0) ;;
+    *)
+	# Non-root cannot specify uid & gid settings
+	uid_setting="#$uid_setting"
+	gid_setting="#$gid_setting"
+	;;
+    esac
+
     cat >"$conf" <<EOF
 # rsyncd configuration file autogenerated by $0
 
 pid file = $pidfile
 use chroot = no
 munge symlinks = no
 hosts allow = localhost 127.0.0.0/24 192.168.0.0/16 10.0.0.0/8 $hostname
 log file = $logfile
 log format = %i %h [%a] %m (%u) %l %f%L
 transfer logging = yes
 exclude = ? foobar.baz
-max verbosity = 9
-uid = 0
-gid = 0
+max verbosity = 4
+$uid_setting
+$gid_setting
 
 [test-from]
 	path = $fromdir
 	read only = yes
 	comment = r/o
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/ssh-basic.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/ssh-basic.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/ssh-basic.test	2009-03-06 23:08:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/ssh-basic.test	2013-06-10 10:40:56.000000000 +0800
@@ -7,13 +7,13 @@
 # COPYING)
 
 # This script tests ssh, if possible.  It's called by runtests.sh
 
 . "$suitedir/rsync.fns"
 
-SSH="$scratchdir/src/support/lsh"
+SSH="$scratchdir/src/support/lsh.sh"
 
 if test x"$rsync_enable_ssh_tests" = xyes; then
     if type ssh >/dev/null ; then
 	SSH=ssh
     fi
 fi
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/xattrs.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/xattrs.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/testsuite/xattrs.test	2011-03-27 01:01:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/testsuite/xattrs.test	2011-09-21 04:24:42.000000000 +0800
@@ -2,31 +2,52 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test that rsync handles basic xattr preservation.
 
-. $srcdir/testsuite/rsync.fns
+. $suitedir/rsync.fns
 lnkdir="$tmpdir/lnk"
 
 $RSYNC --version | grep ", xattrs" >/dev/null || test_skipped "Rsync is configured without xattr support"
 
-case "`xattr 2>&1`" in
-*--list:*)
+case "$HOST_OS" in
+darwin*)
     xset() {
 	xnam="$1"
 	xval="$2"
 	shift 2
 	xattr -s "$xnam" "$xval" "${@}"
     }
     xls() {
 	xattr -l "${@}" | sed "s/^[ $tab_ch]*//"
     }
     RSYNC_PREFIX='rsync'
     RUSR='rsync.nonuser'
     ;;
+solaris*)
+    xset() {
+	xnam="$1"
+	xval="$2"
+	shift 2
+	for fn in "${@}"; do
+	    runat "$fn" "$SHELL_PATH" <<EOF
+echo "${xval}" > "${xnam}"
+EOF
+	done
+    }
+    xls() {
+	for fn in "${@}"; do
+	    runat "$fn" "$SHELL_PATH" <<EOF
+for x in *; do echo "\$x=\`cat \$x\`"; done
+EOF
+       done
+    }
+    RSYNC_PREFIX='rsync'
+    RUSR='rsync.nonuser'
+    ;;
 *)
     xset() {
 	xnam="$1"
 	xval="$2"
 	shift 2
 	setfattr -n "$xnam" -v "$xval" "${@}"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/tls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/tls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/tls.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/tls.c	2013-09-29 04:53:23.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Trivial ls for comparing two directories after running an rsync.
  *
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -40,16 +40,18 @@
 
 #define PROGRAM "tls"
 
 /* These are to make syscall.o shut up. */
 int dry_run = 0;
 int am_root = 0;
+int am_sender = 1;
 int read_only = 1;
 int list_only = 0;
 int link_times = 0;
 int link_owner = 0;
+int nsec_times = 0;
 int preserve_perms = 0;
 int preserve_executability = 0;
 
 #ifdef SUPPORT_XATTRS
 
 #ifdef HAVE_LINUX_XATTRS
@@ -143,59 +145,72 @@
 		if (!link_times)
 			buf.st_mtime = (time_t)0;
 		if (!link_owner)
 			buf.st_uid = buf.st_gid = 0;
 		strlcpy(linkbuf, " -> ", sizeof linkbuf);
 		/* const-cast required for silly UNICOS headers */
-		len = readlink((char *) fname, linkbuf+4, sizeof(linkbuf) - 4);
+		len = do_readlink((char *) fname, linkbuf+4, sizeof(linkbuf) - 4);
 		if (len == -1)
-			failed("readlink", fname);
+			failed("do_readlink", fname);
 		else
 			/* it's not nul-terminated */
 			linkbuf[4+len] = 0;
 	} else {
 		linkbuf[0] = 0;
 	}
 
 	permstring(permbuf, buf.st_mode);
 
 	if (buf.st_mtime) {
+		int len;
 		mt = gmtime(&buf.st_mtime);
 
-		snprintf(datebuf, sizeof datebuf,
+		len = snprintf(datebuf, sizeof datebuf,
 			"%04d-%02d-%02d %02d:%02d:%02d",
 			(int)mt->tm_year + 1900,
 			(int)mt->tm_mon + 1,
 			(int)mt->tm_mday,
 			(int)mt->tm_hour,
 			(int)mt->tm_min,
 			(int)mt->tm_sec);
-	} else
-		strlcpy(datebuf, "                   ", sizeof datebuf);
+#ifdef ST_MTIME_NSEC
+		if (nsec_times) {
+			snprintf(datebuf + len, sizeof datebuf - len,
+				".%09d", (int)buf.ST_MTIME_NSEC);
+		}
+#endif
+	} else {
+		int len = MIN(19 + 9*nsec_times, (int)sizeof datebuf - 1);
+		memset(datebuf, ' ', len);
+		datebuf[len] = '\0';
+	}
 
 	/* TODO: Perhaps escape special characters in fname? */
 
 	printf("%s ", permbuf);
 	if (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)) {
 		printf("%5ld,%6ld",
 		    (long)major(buf.st_rdev),
 		    (long)minor(buf.st_rdev));
-	} else /* NB: use double for size since it might not fit in a long. */
-		printf("%12.0f", (double)buf.st_size);
+	} else
+		printf("%15s", do_big_num(buf.st_size, 1, NULL));
 	printf(" %6ld.%-6ld %6ld %s %s%s\n",
 	       (long)buf.st_uid, (long)buf.st_gid, (long)buf.st_nlink,
 	       datebuf, fname, linkbuf);
 }
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"link-times",      'l', POPT_ARG_NONE,   &link_times, 0, 0, 0 },
   {"link-owner",      'L', POPT_ARG_NONE,   &link_owner, 0, 0, 0 },
 #ifdef SUPPORT_XATTRS
   {"fake-super",      'f', POPT_ARG_VAL,    &am_root, -1, 0, 0 },
 #endif
+#ifdef ST_MTIME_NSEC
+  {"nsec",            's', POPT_ARG_NONE,   &nsec_times, 0, 0, 0 },
+#endif
   {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
   {0,0,0,0,0,0,0}
 };
 
 static void tls_usage(int ret)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/token.c	2010-07-03 23:47:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/token.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Routines used by the file-transfer code.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -17,16 +17,21 @@
  *
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
-#include "ifuncs.h"
-#include "zlib/zlib.h"
+#include "itypes.h"
+#include <zlib.h>
+
+#ifndef Z_INSERT_ONLY
+#define Z_INSERT_ONLY Z_SYNC_FLUSH
+#endif
 
 extern int do_compression;
+extern int protocol_version;
 extern int module_id;
 extern int def_compress_level;
 extern char *skip_compress;
 
 static int compression_level, per_file_default_level;
 
@@ -305,13 +310,13 @@
 			tx_strm.zalloc = NULL;
 			tx_strm.zfree = NULL;
 			if (deflateInit2(&tx_strm, compression_level,
 					 Z_DEFLATED, -15, 8,
 					 Z_DEFAULT_STRATEGY) != Z_OK) {
 				rprintf(FERROR, "compression init failed\n");
-				exit_cleanup(RERR_STREAMIO);
+				exit_cleanup(RERR_PROTOCOL);
 			}
 			if ((obuf = new_array(char, OBUF_SIZE)) == NULL)
 				out_of_memory("send_deflated_token");
 			init_done = 1;
 		} else
 			deflateReset(&tx_strm);
@@ -408,20 +413,24 @@
 			/* Break up long sections in the same way that
 			 * see_deflate_token() does. */
 			int32 n1 = toklen > 0xffff ? 0xffff : toklen;
 			toklen -= n1;
 			tx_strm.next_in = (Bytef *)map_ptr(buf, offset, n1);
 			tx_strm.avail_in = n1;
-			tx_strm.next_out = (Bytef *) obuf;
-			tx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);
-			r = deflate(&tx_strm, Z_INSERT_ONLY);
-			if (r != Z_OK || tx_strm.avail_in != 0) {
-				rprintf(FERROR, "deflate on token returned %d (%d bytes left)\n",
-					r, tx_strm.avail_in);
-				exit_cleanup(RERR_STREAMIO);
-			}
+			if (protocol_version >= 31) /* Newer protocols avoid a data-duplicating bug */
+				offset += n1;
+			do {
+				tx_strm.next_out = (Bytef *) obuf;
+				tx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);
+				r = deflate(&tx_strm, Z_INSERT_ONLY);
+				if (r != Z_OK) {
+					rprintf(FERROR, "deflate on token returned %d (%d bytes left)\n",
+						r, tx_strm.avail_in);
+					exit_cleanup(RERR_STREAMIO);
+				}
+			} while (tx_strm.avail_in != 0);
 		} while (toklen > 0);
 	}
 }
 
 /* tells us what the receiver is in the middle of doing */
 static enum { r_init, r_idle, r_running, r_inflating, r_inflated } recv_state;
@@ -449,13 +458,13 @@
 			if (!init_done) {
 				rx_strm.next_out = NULL;
 				rx_strm.zalloc = NULL;
 				rx_strm.zfree = NULL;
 				if (inflateInit2(&rx_strm, -15) != Z_OK) {
 					rprintf(FERROR, "inflate init failed\n");
-					exit_cleanup(RERR_STREAMIO);
+					exit_cleanup(RERR_PROTOCOL);
 				}
 				if (!(cbuf = new_array(char, MAX_DATA_COUNT))
 				    || !(dbuf = new_array(char, AVAIL_OUT_SIZE(CHUNK_SIZE))))
 					out_of_memory("recv_deflated_token");
 				init_done = 1;
 			} else {
@@ -590,12 +599,14 @@
 				hdr[2] = blklen >> 8;
 				hdr[3] = ~hdr[1];
 				hdr[4] = ~hdr[2];
 			} else {
 				rx_strm.next_in = (Bytef *)buf;
 				rx_strm.avail_in = blklen;
+				if (protocol_version >= 31) /* Newer protocols avoid a data-duplicating bug */
+					buf += blklen;
 				len -= blklen;
 				blklen = 0;
 			}
 		}
 		rx_strm.next_out = (Bytef *)dbuf;
 		rx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/trimslash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/trimslash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/trimslash.c	2008-01-26 08:57:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/trimslash.c	2013-06-12 04:28:45.000000000 +0800
@@ -20,12 +20,13 @@
 
 #include "rsync.h"
 
 /* These are to make syscall.o shut up. */
 int dry_run = 0;
 int am_root = 0;
+int am_sender = 1;
 int read_only = 1;
 int list_only = 0;
 int preserve_perms = 0;
 int preserve_executability = 0;
 
 int
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/t_stub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/t_stub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/t_stub.c	2011-02-22 03:32:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/t_stub.c	2013-06-12 09:06:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * This file contains really simple implementations for rsync global
  * functions, so that module test harnesses can run standalone.
  *
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -19,22 +19,24 @@
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 int modify_window = 0;
+int preallocate_files = 0;
+int protect_args = 0;
 int module_id = -1;
+int checksum_len = 0;
 int relative_paths = 0;
-int human_readable = 0;
 int module_dirlen = 0;
+int preserve_acls = 0;
 int preserve_times = 0;
 int preserve_xattrs = 0;
-mode_t orig_umask = 002;
 char *partial_dir;
 char *module_dir;
-struct filter_list_struct daemon_filter_list;
+filter_rule_list daemon_filter_list;
 
  void rprintf(UNUSED(enum logcode code), const char *format, ...)
 {
 	va_list ap;
 	va_start(ap, format);
 	vfprintf(stderr, format, ap);
@@ -55,28 +57,33 @@
 {
 	fprintf(stderr, "exit(%d): %s(%d)\n",
 		code, file, line);
 	exit(code);
 }
 
- int check_filter(UNUSED(struct filter_list_struct *listp), UNUSED(enum logcode code),
+ int check_filter(UNUSED(filter_rule_list *listp), UNUSED(enum logcode code),
 		  UNUSED(const char *name), UNUSED(int name_is_dir))
 {
 	/* This function doesn't really get called in this test context, so
 	 * just return 0. */
 	return 0;
 }
 
- int make_bak_dir(UNUSED(const char *fullpath))
+ int copy_xattrs(UNUSED(const char *source), UNUSED(const char *dest))
 {
 	return -1;
 }
 
- int copy_xattrs(UNUSED(const char *source), UNUSED(const char *dest))
+ void free_xattr(UNUSED(stat_x *sxp))
 {
-	return -1;
+	return;
+}
+
+ void free_acl(UNUSED(stat_x *sxp))
+{
+	return;
 }
 
  char *lp_name(UNUSED(int mod))
 {
 	return NULL;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/t_unsafe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/t_unsafe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/t_unsafe.c	2009-01-18 05:41:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/t_unsafe.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,11 +1,11 @@
 /*
  * Test harness for unsafe_symlink().  Not linked into rsync itself.
  *
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -22,17 +22,19 @@
  * Always returns 0 unless something extraordinary happens. */
 
 #include "rsync.h"
 
 int dry_run = 0;
 int am_root = 0;
+int am_sender = 1;
 int read_only = 0;
 int list_only = 0;
-int verbose = 0;
+int human_readable = 0;
 int preserve_perms = 0;
 int preserve_executability = 0;
+short info_levels[COUNT_INFO], debug_levels[COUNT_DEBUG];
 
 int
 main(int argc, char **argv)
 {
 	if (argc != 3) {
 		fprintf(stderr, "usage: t_unsafe LINKDEST SRCDIR\n");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/uidlist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/uidlist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/uidlist.c	2011-02-23 02:48:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/uidlist.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Handle the mapping of uid/gid and user/group names between systems.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2004-2009 Wayne Davison
+ * Copyright (C) 2004-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -21,84 +21,132 @@
 
 /* If the source username/group does not exist on the target then use
  * the numeric IDs.  Never do any mapping for uid=0 or gid=0 as these
  * are special. */
 
 #include "rsync.h"
+#include "ifuncs.h"
+#include "itypes.h"
 #include "io.h"
 
-extern int verbose;
 extern int am_root;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_acls;
 extern int numeric_ids;
+extern gid_t our_gid;
+extern char *usermap;
+extern char *groupmap;
 
 #ifdef HAVE_GETGROUPS
 # ifndef GETGROUPS_T
 #  define GETGROUPS_T gid_t
 # endif
 #endif
 
+#define NFLAGS_WILD_NAME_MATCH (1<<0)
+#define NFLAGS_NAME_MATCH (1<<1)
+
+union name_or_id {
+    const char *name;
+    id_t max_id;
+};
+
 struct idlist {
 	struct idlist *next;
-	const char *name;
+	union name_or_id u;
 	id_t id, id2;
 	uint16 flags;
 };
 
-static struct idlist *uidlist;
-static struct idlist *gidlist;
+static struct idlist *uidlist, *uidmap;
+static struct idlist *gidlist, *gidmap;
+
+static id_t id_parse(const char *num_str)
+{
+	id_t tmp, num = 0;
+	const char *cp = num_str;
+
+	while (*cp) {
+		if (!isDigit(cp)) {
+		  invalid_num:
+			rprintf(FERROR, "Invalid ID number: %s\n", num_str);
+			exit_cleanup(RERR_SYNTAX);
+		}
+		tmp = num * 10 + *cp++ - '0';
+		if (tmp < num)
+			goto invalid_num;
+		num = tmp;
+	}
+
+	return num;
+}
 
-static struct idlist *add_to_list(struct idlist **root, id_t id, const char *name,
+static struct idlist *add_to_list(struct idlist **root, id_t id, union name_or_id noiu,
 				  id_t id2, uint16 flags)
 {
 	struct idlist *node = new(struct idlist);
 	if (!node)
 		out_of_memory("add_to_list");
 	node->next = *root;
-	node->name = name;
+	node->u = noiu;
 	node->id = id;
 	node->id2 = id2;
 	node->flags = flags;
 	*root = node;
 	return node;
 }
 
 /* turn a uid into a user name */
-static const char *uid_to_name(uid_t uid)
+char *uid_to_user(uid_t uid)
 {
 	struct passwd *pass = getpwuid(uid);
 	if (pass)
 		return strdup(pass->pw_name);
 	return NULL;
 }
 
 /* turn a gid into a group name */
-static const char *gid_to_name(gid_t gid)
+char *gid_to_group(gid_t gid)
 {
 	struct group *grp = getgrgid(gid);
 	if (grp)
 		return strdup(grp->gr_name);
 	return NULL;
 }
 
-static uid_t map_uid(uid_t id, const char *name)
+/* Parse a user name or (optionally) a number into a uid */
+int user_to_uid(const char *name, uid_t *uid_p, BOOL num_ok)
 {
-	uid_t uid;
-	if (id != 0 && name_to_uid(name, &uid))
-		return uid;
-	return id;
+	struct passwd *pass;
+	if (!name || !*name)
+		return 0;
+	if (num_ok && name[strspn(name, "0123456789")] == '\0') {
+		*uid_p = id_parse(name);
+		return 1;
+	}
+	if (!(pass = getpwnam(name)))
+		return 0;
+	*uid_p = pass->pw_uid;
+	return 1;
 }
 
-static gid_t map_gid(gid_t id, const char *name)
+/* Parse a group name or (optionally) a number into a gid */
+int group_to_gid(const char *name, gid_t *gid_p, BOOL num_ok)
 {
-	gid_t gid;
-	if (id != 0 && name_to_gid(name, &gid))
-		return gid;
-	return id;
+	struct group *grp;
+	if (!name || !*name)
+		return 0;
+	if (num_ok && name[strspn(name, "0123456789")] == '\0') {
+		*gid_p = id_parse(name);
+		return 1;
+	}
+	if (!(grp = getgrnam(name)))
+		return 0;
+	*gid_p = grp->gr_gid;
+	return 1;
 }
 
 static int is_in_group(gid_t gid)
 {
 #ifdef HAVE_GETGROUPS
 	static gid_t last_in;
@@ -106,28 +154,27 @@
 	static GETGROUPS_T *gidset;
 	int n;
 
 	if (gid == last_in && last_out >= 0)
 		return last_out;
 	if (ngroups < -1) {
-		gid_t mygid = MY_GID();
 		if ((ngroups = getgroups(0, NULL)) < 0)
 			ngroups = 0;
 		gidset = new_array(GETGROUPS_T, ngroups+1);
 		if (!gidset)
 			out_of_memory("is_in_group");
 		if (ngroups > 0)
 			ngroups = getgroups(ngroups, gidset);
 		/* The default gid might not be in the list on some systems. */
 		for (n = 0; n < ngroups; n++) {
-			if (gidset[n] == mygid)
+			if (gidset[n] == our_gid)
 				break;
 		}
 		if (n == ngroups)
-			gidset[ngroups++] = mygid;
-		if (verbose > 3) {
+			gidset[ngroups++] = our_gid;
+		if (DEBUG_GTE(OWN, 2)) {
 			int pos;
 			char *gidbuf = new_array(char, ngroups*21+32);
 			if (!gidbuf)
 				out_of_memory("is_in_group");
 			pos = snprintf(gidbuf, 32, "process has %d gid%s: ",
 				       ngroups, ngroups == 1? "" : "s");
@@ -144,75 +191,89 @@
 		if (gidset[n] == gid)
 			return last_out = 1;
 	}
 	return last_out = 0;
 
 #else
-	static gid_t mygid = GID_NONE;
-	if (mygid == GID_NONE) {
-		mygid = MY_GID();
-		if (verbose > 3)
-			rprintf(FINFO, "process has gid %u\n", (unsigned)mygid);
-	}
-	return gid == mygid;
+	return gid == our_gid;
 #endif
 }
 
-/* Add a uid to the list of uids.  Only called on receiving side. */
-static struct idlist *recv_add_uid(uid_t id, const char *name)
+/* Add a uid/gid to its list of ids.  Only called on receiving side. */
+static struct idlist *recv_add_id(struct idlist **idlist_ptr, struct idlist *idmap,
+				  id_t id, const char *name)
 {
-	uid_t id2 = name ? map_uid(id, name) : id;
 	struct idlist *node;
+	union name_or_id noiu;
+	int flag;
+	id_t id2;
 
-	node = add_to_list(&uidlist, id, name, id2, 0);
+	noiu.name = name; /* ensure that add_to_list() gets the raw value. */
+	if (!name)
+		name = "";
 
-	if (verbose > 3) {
-		rprintf(FINFO, "uid %u(%s) maps to %u\n",
-			(unsigned)id, name ? name : "", (unsigned)id2);
+	for (node = idmap; node; node = node->next) {
+		if (node->flags & NFLAGS_WILD_NAME_MATCH) {
+			if (!wildmatch(node->u.name, name))
+				continue;
+		} else if (node->flags & NFLAGS_NAME_MATCH) {
+			if (strcmp(node->u.name, name) != 0)
+				continue;
+		} else if (node->u.max_id) {
+			if (id < node->id || id > node->u.max_id)
+				continue;
+		} else {
+			if (node->id != id)
+				continue;
+		}
+		break;
 	}
+	if (node)
+		id2 = node->id2;
+	else if (*name && id) {
+		if (idlist_ptr == &uidlist) {
+			uid_t uid;
+			id2 = user_to_uid(name, &uid, False) ? uid : id;
+		} else {
+			gid_t gid;
+			id2 = group_to_gid(name, &gid, False) ? gid : id;
+		}
+	} else
+		id2 = id;
 
-	return node;
-}
-
-/* Add a gid to the list of gids.  Only called on receiving side. */
-static struct idlist *recv_add_gid(gid_t id, const char *name)
-{
-	gid_t id2 = name ? map_gid(id, name) : id;
-	struct idlist *node;
-
-	node = add_to_list(&gidlist, id, name, id2,
-		!am_root && !is_in_group(id2) ? FLAG_SKIP_GROUP : 0);
+	flag = idlist_ptr == &gidlist && !am_root && !is_in_group(id2) ? FLAG_SKIP_GROUP : 0;
+	node = add_to_list(idlist_ptr, id, noiu, id2, flag);
 
-	if (verbose > 3) {
-		rprintf(FINFO, "gid %u(%s) maps to %u\n",
-			(unsigned)id, name ? name : "", (unsigned)id2);
+	if (DEBUG_GTE(OWN, 2)) {
+		rprintf(FINFO, "%sid %u(%s) maps to %u\n",
+			idlist_ptr == &uidlist ? "u" : "g",
+			(unsigned)id, name, (unsigned)id2);
 	}
 
 	return node;
 }
 
 /* this function is a definate candidate for a faster algorithm */
 uid_t match_uid(uid_t uid)
 {
-	static uid_t last_in, last_out;
+	static struct idlist *last = NULL;
 	struct idlist *list;
 
-	if (uid == 0)
-		return 0;
-
-	if (uid == last_in)
-		return last_out;
-
-	last_in = uid;
+	if (last && uid == last->id)
+		return last->id2;
 
 	for (list = uidlist; list; list = list->next) {
 		if (list->id == uid)
-			return last_out = list->id2;
+			break;
 	}
 
-	return last_out = uid;
+	if (!list)
+		list = recv_add_id(&uidlist, uidmap, uid, NULL);
+	last = list;
+
+	return list->id2;
 }
 
 gid_t match_gid(gid_t gid, uint16 *flags_ptr)
 {
 	static struct idlist *last = NULL;
 	struct idlist *list;
@@ -222,13 +283,13 @@
 	else {
 		for (list = gidlist; list; list = list->next) {
 			if (list->id == gid)
 				break;
 		}
 		if (!list)
-			list = recv_add_gid(gid, NULL);
+			list = recv_add_id(&gidlist, gidmap, gid, NULL);
 		last = list;
 	}
 
 	if (flags_ptr && list->flags & FLAG_SKIP_GROUP)
 		*flags_ptr |= FLAG_SKIP_GROUP;
 	return list->id2;
@@ -236,74 +297,78 @@
 
 /* Add a uid to the list of uids.  Only called on sending side. */
 const char *add_uid(uid_t uid)
 {
 	struct idlist *list;
 	struct idlist *node;
+	union name_or_id noiu;
 
 	if (uid == 0)	/* don't map root */
 		return NULL;
 
 	for (list = uidlist; list; list = list->next) {
 		if (list->id == uid)
 			return NULL;
 	}
 
-	node = add_to_list(&uidlist, uid, uid_to_name(uid), 0, 0);
-	return node->name;
+	noiu.name = uid_to_user(uid);
+	node = add_to_list(&uidlist, uid, noiu, 0, 0);
+	return node->u.name;
 }
 
 /* Add a gid to the list of gids.  Only called on sending side. */
 const char *add_gid(gid_t gid)
 {
 	struct idlist *list;
 	struct idlist *node;
+	union name_or_id noiu;
 
 	if (gid == 0)	/* don't map root */
 		return NULL;
 
 	for (list = gidlist; list; list = list->next) {
 		if (list->id == gid)
 			return NULL;
 	}
 
-	node = add_to_list(&gidlist, gid, gid_to_name(gid), 0, 0);
-	return node->name;
+	noiu.name = gid_to_group(gid);
+	node = add_to_list(&gidlist, gid, noiu, 0, 0);
+	return node->u.name;
 }
 
 /* send a complete uid/gid mapping to the peer */
 void send_id_list(int f)
 {
 	struct idlist *list;
 
 	if (preserve_uid || preserve_acls) {
 		int len;
 		/* we send sequences of uid/byte-length/name */
 		for (list = uidlist; list; list = list->next) {
-			if (!list->name)
+			if (!list->u.name)
 				continue;
-			len = strlen(list->name);
+			len = strlen(list->u.name);
 			write_varint30(f, list->id);
 			write_byte(f, len);
-			write_buf(f, list->name, len);
+			write_buf(f, list->u.name, len);
 		}
 
 		/* terminate the uid list with a 0 uid. We explicitly exclude
 		 * 0 from the list */
 		write_varint30(f, 0);
 	}
 
 	if (preserve_gid || preserve_acls) {
 		int len;
 		for (list = gidlist; list; list = list->next) {
-			if (!list->name)
+			if (!list->u.name)
 				continue;
-			len = strlen(list->name);
+			len = strlen(list->u.name);
 			write_varint30(f, list->id);
 			write_byte(f, len);
-			write_buf(f, list->name, len);
+			write_buf(f, list->u.name, len);
 		}
 		write_varint30(f, 0);
 	}
 }
 
 uid_t recv_user_name(int f, uid_t uid)
@@ -315,13 +380,13 @@
 		out_of_memory("recv_user_name");
 	read_sbuf(f, name, len);
 	if (numeric_ids < 0) {
 		free(name);
 		name = NULL;
 	}
-	node = recv_add_uid(uid, name); /* node keeps name's memory */
+	node = recv_add_id(&uidlist, uidmap, uid, name); /* node keeps name's memory */
 	return node->id2;
 }
 
 gid_t recv_group_name(int f, gid_t gid, uint16 *flags_ptr)
 {
 	struct idlist *node;
@@ -331,13 +396,13 @@
 		out_of_memory("recv_group_name");
 	read_sbuf(f, name, len);
 	if (numeric_ids < 0) {
 		free(name);
 		name = NULL;
 	}
-	node = recv_add_gid(gid, name); /* node keeps name's memory */
+	node = recv_add_id(&gidlist, gidmap, gid, name); /* node keeps name's memory */
 	if (flags_ptr && node->flags & FLAG_SKIP_GROUP)
 		*flags_ptr |= FLAG_SKIP_GROUP;
 	return node->id2;
 }
 
 /* recv a complete uid/gid mapping from the peer and map the uid/gid
@@ -358,20 +423,123 @@
 		while ((id = read_varint30(f)) != 0)
 			recv_group_name(f, id, NULL);
 	}
 
 	/* Now convert all the uids/gids from sender values to our values. */
 #ifdef SUPPORT_ACLS
-	if (preserve_acls && !numeric_ids)
+	if (preserve_acls && (!numeric_ids || usermap || groupmap))
 		match_acl_ids();
 #endif
-	if (am_root && preserve_uid && !numeric_ids) {
+	if (am_root && preserve_uid && (!numeric_ids || usermap)) {
 		for (i = 0; i < flist->used; i++)
 			F_OWNER(flist->files[i]) = match_uid(F_OWNER(flist->files[i]));
 	}
-	if (preserve_gid && (!am_root || !numeric_ids)) {
+	if (preserve_gid && (!am_root || !numeric_ids || groupmap)) {
 		for (i = 0; i < flist->used; i++) {
 			F_GROUP(flist->files[i]) = match_gid(F_GROUP(flist->files[i]),
 							     &flist->files[i]->flags);
 		}
 	}
 }
+
+void parse_name_map(char *map, BOOL usernames)
+{
+	struct idlist **idmap_ptr = usernames ? &uidmap : &gidmap;
+	struct idlist **idlist_ptr = usernames ? &uidlist : &gidlist;
+	char *colon, *cp = map + strlen(map);
+	union name_or_id noiu;
+	id_t id1;
+	uint16 flags;
+
+	/* Parse the list in reverse, so the order in the struct is right. */
+	while (1) {
+		while (cp > map && cp[-1] != ',') cp--;
+		if (!(colon = strchr(cp, ':'))) {
+			rprintf(FERROR, "No colon found in --%smap: %s\n",
+				usernames ? "user" : "group", cp);
+			exit_cleanup(RERR_SYNTAX);
+		}
+		if (!colon[1]) {
+			rprintf(FERROR, "No name found after colon --%smap: %s\n",
+				usernames ? "user" : "group", cp);
+			exit_cleanup(RERR_SYNTAX);
+		}
+		*colon = '\0';
+
+		if (isDigit(cp)) {
+			char *dash = strchr(cp, '-');
+			if (strspn(cp, "0123456789-") != (size_t)(colon - cp)
+			 || (dash && (!dash[1] || strchr(dash+1, '-')))) {
+				rprintf(FERROR, "Invalid number in --%smap: %s\n",
+					usernames ? "user" : "group", cp);
+				exit_cleanup(RERR_SYNTAX);
+			}
+			if (dash)
+				noiu.max_id = id_parse(dash+1);
+			else
+				noiu.max_id = 0;
+			flags = 0;
+			id1 = id_parse(cp);
+		} else if (strpbrk(cp, "*[?")) {
+			flags = NFLAGS_WILD_NAME_MATCH;
+			noiu.name = cp;
+			id1 = 0;
+		} else {
+			flags = NFLAGS_NAME_MATCH;
+			noiu.name = cp;
+			id1 = 0;
+		}
+
+		if (usernames) {
+			uid_t uid;
+			if (user_to_uid(colon+1, &uid, True))
+				add_to_list(idmap_ptr, id1, noiu, uid, flags);
+			else {
+				rprintf(FERROR,
+				    "Unknown --usermap name on receiver: %s\n",
+				    colon+1);
+			}
+		} else {
+			gid_t gid;
+			if (group_to_gid(colon+1, &gid, True))
+				add_to_list(idmap_ptr, id1, noiu, gid, flags);
+			else {
+				rprintf(FERROR,
+				    "Unknown --groupmap name on receiver: %s\n",
+				    colon+1);
+			}
+		}
+
+		if (cp == map)
+			break;
+
+		*--cp = '\0'; /* replace comma */
+	}
+
+	/* The 0 user/group doesn't get its name sent, so add it explicitly. */
+	recv_add_id(idlist_ptr, *idmap_ptr, 0,
+		    numeric_ids ? NULL : usernames ? uid_to_user(0) : gid_to_group(0));
+}
+
+#ifdef HAVE_GETGROUPLIST
+const char *getallgroups(uid_t uid, gid_t *gid_list, int *size_ptr)
+{
+	struct passwd *pw;
+	if ((pw = getpwuid(uid)) == NULL)
+		return "getpwuid failed";
+	/* Get all the process's groups, with the pw_gid group first. */
+	if (getgrouplist(pw->pw_name, pw->pw_gid, gid_list, size_ptr) < 0)
+		return "getgrouplist failed";
+	/* Paranoia: is the default group not first in the list? */
+	if (gid_list[0] != pw->pw_gid) {
+		int j;
+		for (j = 0; j < *size_ptr; j++) {
+			if (gid_list[j] == pw->pw_gid) {
+				gid_list[j] = gid_list[0];
+				gid_list[0] = pw->pw_gid;
+				break;
+			}
+		}
+	}
+	return NULL;
+}
+#endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0: util2.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/util.c	2011-04-23 06:51:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/util.c	2013-06-12 04:36:44.000000000 +0800
@@ -1,13 +1,13 @@
 /*
  * Utility routines used in rsync.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -19,25 +19,26 @@
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 #include "ifuncs.h"
+#include "itypes.h"
+#include "inums.h"
 
-extern int verbose;
 extern int module_id;
+extern int protect_args;
 extern int modify_window;
 extern int relative_paths;
 extern int preserve_times;
-extern int human_readable;
 extern int preserve_xattrs;
+extern int preallocate_files;
 extern char *module_dir;
 extern unsigned int module_dirlen;
-extern mode_t orig_umask;
 extern char *partial_dir;
-extern struct filter_list_struct daemon_filter_list;
+extern filter_rule_list daemon_filter_list;
 
 int sanitize_paths = 0;
 
 char curr_dir[MAXPATHLEN];
 unsigned int curr_dir_len;
 int curr_dir_depth; /* This is only set for a sanitizing daemon. */
@@ -91,12 +92,13 @@
 
 	return ret;
 }
 
 void print_child_argv(const char *prefix, char **cmd)
 {
+	int cnt = 0;
 	rprintf(FCLIENT, "%s ", prefix);
 	for (; *cmd; cmd++) {
 		/* Look for characters that ought to be quoted.  This
 		* is not a great quoting algorithm, but it's
 		* sufficient for a log message. */
 		if (strspn(*cmd, "abcdefghijklmnopqrstuvwxyz"
@@ -104,54 +106,43 @@
 			   "0123456789"
 			   ",.-_=+@/") != strlen(*cmd)) {
 			rprintf(FCLIENT, "\"%s\" ", *cmd);
 		} else {
 			rprintf(FCLIENT, "%s ", *cmd);
 		}
+		cnt++;
 	}
-	rprintf(FCLIENT, "\n");
-}
-
-NORETURN void out_of_memory(const char *str)
-{
-	rprintf(FERROR, "ERROR: out of memory in %s [%s]\n", str, who_am_i());
-	exit_cleanup(RERR_MALLOC);
-}
-
-NORETURN void overflow_exit(const char *str)
-{
-	rprintf(FERROR, "ERROR: buffer overflow in %s [%s]\n", str, who_am_i());
-	exit_cleanup(RERR_MALLOC);
+	rprintf(FCLIENT, " (%d args)\n", cnt);
 }
 
 /* This returns 0 for success, 1 for a symlink if symlink time-setting
  * is not possible, or -1 for any other error. */
-int set_modtime(const char *fname, time_t modtime, mode_t mode)
+int set_modtime(const char *fname, time_t modtime, uint32 mod_nsec, mode_t mode)
 {
 	static int switch_step = 0;
 
-	if (verbose > 2) {
+	if (DEBUG_GTE(TIME, 1)) {
 		rprintf(FINFO, "set modtime of %s to (%ld) %s",
 			fname, (long)modtime,
 			asctime(localtime(&modtime)));
 	}
 
 	switch (switch_step) {
 #ifdef HAVE_UTIMENSAT
 #include "case_N.h"
-		if (do_utimensat(fname, modtime, 0) == 0)
+		if (do_utimensat(fname, modtime, mod_nsec) == 0)
 			break;
 		if (errno != ENOSYS)
 			return -1;
 		switch_step++;
 		/* FALLTHROUGH */
 #endif
 
 #ifdef HAVE_LUTIMES
 #include "case_N.h"
-		if (do_lutimes(fname, modtime, 0) == 0)
+		if (do_lutimes(fname, modtime, mod_nsec) == 0)
 			break;
 		if (errno != ENOSYS)
 			return -1;
 		switch_step++;
 		/* FALLTHROUGH */
 #endif
@@ -164,60 +155,91 @@
 				return 1;
 		}
 		/* FALLTHROUGH */
 
 #include "case_N.h"
 #ifdef HAVE_UTIMES
-		if (do_utimes(fname, modtime, 0) == 0)
+		if (do_utimes(fname, modtime, mod_nsec) == 0)
 			break;
 #else
-		if (do_utime(fname, modtime, 0) == 0)
+		if (do_utime(fname, modtime, mod_nsec) == 0)
 			break;
 #endif
 
 		return -1;
 	}
 
 	return 0;
 }
 
-/* This creates a new directory with default permissions.  Since there
- * might be some directory-default permissions affecting this, we can't
- * force the permissions directly using the original umask and mkdir(). */
-int mkdir_defmode(char *fname)
-{
-	int ret;
-
-	umask(orig_umask);
-	ret = do_mkdir(fname, ACCESSPERMS);
-	umask(0);
-
-	return ret;
-}
-
 /* Create any necessary directories in fname.  Any missing directories are
- * created with default permissions. */
-int create_directory_path(char *fname)
+ * created with default permissions.  Returns < 0 on error, or the number
+ * of directories created. */
+int make_path(char *fname, int flags)
 {
-	char *p;
+	char *end, *p;
 	int ret = 0;
 
-	while (*fname == '/')
-		fname++;
-	while (strncmp(fname, "./", 2) == 0)
+	if (flags & MKP_SKIP_SLASH) {
+		while (*fname == '/')
+			fname++;
+	}
+
+	while (*fname == '.' && fname[1] == '/')
 		fname += 2;
 
-	umask(orig_umask);
-	p = fname;
-	while ((p = strchr(p,'/')) != NULL) {
-		*p = '\0';
-		if (do_mkdir(fname, ACCESSPERMS) < 0 && errno != EEXIST)
-		    ret = -1;
-		*p++ = '/';
+	if (flags & MKP_DROP_NAME) {
+		end = strrchr(fname, '/');
+		if (!end)
+			return 0;
+		*end = '\0';
+	} else
+		end = fname + strlen(fname);
+
+	/* Try to find an existing dir, starting from the deepest dir. */
+	for (p = end; ; ) {
+		if (do_mkdir(fname, ACCESSPERMS) == 0) {
+			ret++;
+			break;
+		}
+		if (errno != ENOENT) {
+			if (errno != EEXIST)
+				ret = -ret - 1;
+			break;
+		}
+		while (1) {
+			if (p == fname) {
+				ret = -ret - 1;
+				goto double_break;
+			}
+			if (*--p == '/') {
+				if (p == fname) {
+					ret = -ret - 1; /* impossible... */
+					goto double_break;
+				}
+				*p = '\0';
+				break;
+			}
+		}
 	}
-	umask(0);
+  double_break:
+
+	/* Make all the dirs that we didn't find on the way here. */
+	while (p != end) {
+		*p = '/';
+		p += strlen(p);
+		if (ret < 0) /* Skip mkdir on error, but keep restoring the path. */
+			continue;
+		if (do_mkdir(fname, ACCESSPERMS) < 0)
+			ret = -ret - 1;
+		else
+			ret++;
+	}
+
+	if (flags & MKP_DROP_NAME)
+		*end = '/';
 
 	return ret;
 }
 
 /**
  * Write @p len bytes at @p ptr to descriptor @p desc, retrying if
@@ -277,18 +299,20 @@
  * Otherwise, it just writes to and closes the provided file descriptor.
  * In either case, if --xattrs are being preserved, the dest file will
  * have its xattrs set from the source file.
  *
  * This is used in conjunction with the --temp-dir, --backup, and
  * --copy-dest options. */
-int copy_file(const char *source, const char *dest, int ofd,
-	      mode_t mode, int create_bak_dir)
+int copy_file(const char *source, const char *dest, int ofd, mode_t mode)
 {
 	int ifd;
 	char buf[1024 * 8];
 	int len;   /* Number of bytes read into `buf'. */
+#ifdef PREALLOCATE_NEEDS_TRUNCATE
+	OFF_T preallocated_len = 0, offset = 0;
+#endif
 
 	if ((ifd = do_open(source, O_RDONLY, 0)) < 0) {
 		int save_errno = errno;
 		rsyserr(FERROR_XFER, errno, "open %s", full_fname(source));
 		errno = save_errno;
 		return -1;
@@ -299,38 +323,57 @@
 			int save_errno = errno;
 			rsyserr(FERROR_XFER, errno, "unlink %s", full_fname(dest));
 			errno = save_errno;
 			return -1;
 		}
 
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs)
+			mode |= S_IWUSR;
+#endif
+		mode &= INITACCESSPERMS;
 		if ((ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode)) < 0) {
-			int save_errno = errno ? errno : EINVAL; /* 0 paranoia */
-			if (create_bak_dir && errno == ENOENT && make_bak_dir(dest) == 0) {
-				if ((ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode)) < 0)
-					save_errno = errno ? errno : save_errno;
-				else
-					save_errno = 0;
-			}
-			if (save_errno) {
-				rsyserr(FERROR_XFER, save_errno, "open %s", full_fname(dest));
-				close(ifd);
-				errno = save_errno;
-				return -1;
-			}
+			int save_errno = errno;
+			rsyserr(FERROR_XFER, save_errno, "open %s", full_fname(dest));
+			close(ifd);
+			errno = save_errno;
+			return -1;
+		}
+	}
+
+#ifdef SUPPORT_PREALLOCATION
+	if (preallocate_files) {
+		STRUCT_STAT srcst;
+
+		/* Try to preallocate enough space for file's eventual length.  Can
+		 * reduce fragmentation on filesystems like ext4, xfs, and NTFS. */
+		if (do_fstat(ifd, &srcst) < 0)
+			rsyserr(FWARNING, errno, "fstat %s", full_fname(source));
+		else if (srcst.st_size > 0) {
+			if (do_fallocate(ofd, 0, srcst.st_size) == 0) {
+#ifdef PREALLOCATE_NEEDS_TRUNCATE
+				preallocated_len = srcst.st_size;
+#endif
+			} else
+				rsyserr(FWARNING, errno, "do_fallocate %s", full_fname(dest));
 		}
 	}
+#endif
 
 	while ((len = safe_read(ifd, buf, sizeof buf)) > 0) {
 		if (full_write(ofd, buf, len) < 0) {
 			int save_errno = errno;
 			rsyserr(FERROR_XFER, errno, "write %s", full_fname(dest));
 			close(ifd);
 			close(ofd);
 			errno = save_errno;
 			return -1;
 		}
+#ifdef PREALLOCATE_NEEDS_TRUNCATE
+		offset += len;
+#endif
 	}
 
 	if (len < 0) {
 		int save_errno = errno;
 		rsyserr(FERROR_XFER, errno, "read %s", full_fname(source));
 		close(ifd);
@@ -341,12 +384,22 @@
 
 	if (close(ifd) < 0) {
 		rsyserr(FWARNING, errno, "close failed on %s",
 			full_fname(source));
 	}
 
+#ifdef PREALLOCATE_NEEDS_TRUNCATE
+	/* Source file might have shrunk since we fstatted it.
+	 * Cut off any extra preallocated zeros from dest file. */
+	if (offset < preallocated_len && do_ftruncate(ofd, offset) < 0) {
+		/* If we fail to truncate, the dest file may be wrong, so we
+		 * must trigger the "partial transfer" error. */
+		rsyserr(FERROR_XFER, errno, "ftruncate %s", full_fname(dest));
+	}
+#endif
+
 	if (close(ofd) < 0) {
 		int save_errno = errno;
 		rsyserr(FERROR_XFER, errno, "close failed on %s",
 			full_fname(dest));
 		errno = save_errno;
 		return -1;
@@ -404,13 +457,13 @@
 	do {
 		snprintf(&path[pos], MAX_RENAMES_DIGITS+1, "%03d", counter);
 		if (++counter >= MAX_RENAMES)
 			counter = 1;
 	} while ((rc = access(path, 0)) == 0 && counter != start);
 
-	if (verbose > 0) {
+	if (INFO_GTE(MISC, 1)) {
 		rprintf(FWARNING, "renaming %s to %s because of text busy\n",
 			fname, path);
 	}
 
 	/* maybe we should return rename()'s exit status? Nah. */
 	if (do_rename(fname, path) != 0) {
@@ -447,13 +500,13 @@
 		case EXDEV:
 			if (partialptr) {
 				if (!handle_partial_dir(partialptr,PDIR_CREATE))
 					return -2;
 				to = partialptr;
 			}
-			if (copy_file(from, to, -1, mode, 0) != 0)
+			if (copy_file(from, to, -1, mode) != 0)
 				return -2;
 			do_unlink(from);
 			return 1;
 		default:
 			return -1;
 		}
@@ -501,36 +554,12 @@
 			continue;
 
 		kill(p, sig);
 	}
 }
 
-/** Turn a user name into a uid */
-int name_to_uid(const char *name, uid_t *uid_p)
-{
-	struct passwd *pass;
-	if (!name || !*name)
-		return 0;
-	if (!(pass = getpwnam(name)))
-		return 0;
-	*uid_p = pass->pw_uid;
-	return 1;
-}
-
-/** Turn a group name into a gid */
-int name_to_gid(const char *name, gid_t *gid_p)
-{
-	struct group *grp;
-	if (!name || !*name)
-		return 0;
-	if (!(grp = getgrnam(name)))
-		return 0;
-	*gid_p = grp->gr_gid;
-	return 1;
-}
-
 /** Lock a byte range in a open file */
 int lock_range(int fd, int offset, int len)
 {
 	struct flock lock;
 
 	lock.l_type = F_WRLCK;
@@ -716,16 +745,21 @@
 	if (!arg || !*arg)
 		return;
 
 	if (strncmp(arg, base, base_len) == 0)
 		arg += base_len;
 
+	if (protect_args) {
+		glob_expand(arg, argv_p, argc_p, maxargs_p);
+		return;
+	}
+
 	if (!(arg = strdup(arg)))
 		out_of_memory("glob_expand_module");
 
-	if (asprintf(&base," %s/", base1) <= 0)
+	if (asprintf(&base," %s/", base1) < 0)
 		out_of_memory("glob_expand_module");
 	base_len++;
 
 	for (s = arg; *s; s = p + base_len) {
 		if ((p = strstr(s, base)) != NULL)
 			*p = '\0'; /* split it at this point */
@@ -989,13 +1023,13 @@
 
 /* Like chdir(), but it keeps track of the current directory (in the
  * global "curr_dir"), and ensures that the path size doesn't overflow.
  * Also cleans the path using the clean_fname() function. */
 int change_dir(const char *dir, int set_path_only)
 {
-	static int initialised;
+	static int initialised, skipped_chdir;
 	unsigned int len;
 
 	if (!initialised) {
 		initialised = 1;
 		if (getcwd(curr_dir, sizeof curr_dir - 1) == NULL) {
 			rsyserr(FERROR, errno, "getcwd()");
@@ -1005,22 +1039,23 @@
 	}
 
 	if (!dir)	/* this call was probably just to initialize */
 		return 0;
 
 	len = strlen(dir);
-	if (len == 1 && *dir == '.')
+	if (len == 1 && *dir == '.' && (!skipped_chdir || set_path_only))
 		return 1;
 
 	if (*dir == '/') {
 		if (len >= sizeof curr_dir) {
 			errno = ENAMETOOLONG;
 			return 0;
 		}
 		if (!set_path_only && chdir(dir))
 			return 0;
+		skipped_chdir = set_path_only;
 		memcpy(curr_dir, dir, len + 1);
 	} else {
 		if (curr_dir_len + 1 + len >= sizeof curr_dir) {
 			errno = ENAMETOOLONG;
 			return 0;
 		}
@@ -1029,22 +1064,23 @@
 		memcpy(curr_dir + curr_dir_len, dir, len + 1);
 
 		if (!set_path_only && chdir(curr_dir)) {
 			curr_dir[curr_dir_len] = '\0';
 			return 0;
 		}
+		skipped_chdir = set_path_only;
 	}
 
-	curr_dir_len = clean_fname(curr_dir, CFN_COLLAPSE_DOT_DOT_DIRS);
+	curr_dir_len = clean_fname(curr_dir, CFN_COLLAPSE_DOT_DOT_DIRS | CFN_DROP_TRAILING_DOT_DIR);
 	if (sanitize_paths) {
 		if (module_dirlen > curr_dir_len)
 			module_dirlen = curr_dir_len;
 		curr_dir_depth = count_dir_elements(curr_dir + module_dirlen);
 	}
 
-	if (verbose >= 5 && !set_path_only)
+	if (DEBUG_GTE(CHDIR, 1) && !set_path_only)
 		rprintf(FINFO, "[%s] change_dir(%s)\n", who_am_i(), curr_dir);
 
 	return 1;
 }
 
 /* This will make a relative path absolute and clean it up via clean_fname().
@@ -1101,13 +1137,13 @@
 		m1 = " (in ";
 		m2 = lp_name(module_id);
 		m3 = ")";
 	} else
 		m1 = m2 = m3 = "";
 
-	if (asprintf(&result, "\"%s%s%s\"%s%s%s", p1, p2, fn, m1, m2, m3) <= 0)
+	if (asprintf(&result, "\"%s%s%s\"%s%s%s", p1, p2, fn, m1, m2, m3) < 0)
 		out_of_memory("full_fname");
 
 	return result;
 }
 
 static char partial_fname[MAXPATHLEN];
@@ -1235,93 +1271,12 @@
 	if (*name == '.' && name[1] == '.' && name[2] == '\0')
 		depth--;
 
 	return depth < 0;
 }
 
-#define HUMANIFY(mult) \
-	do { \
-		if (num >= mult || num <= -mult) { \
-			double dnum = (double)num / mult; \
-			char units; \
-			if (num < 0) \
-				dnum = -dnum; \
-			if (dnum < mult) \
-				units = 'K'; \
-			else if ((dnum /= mult) < mult) \
-				units = 'M'; \
-			else { \
-				dnum /= mult; \
-				units = 'G'; \
-			} \
-			if (num < 0) \
-				dnum = -dnum; \
-			snprintf(bufs[n], sizeof bufs[0], "%.2f%c", dnum, units); \
-			return bufs[n]; \
-		} \
-	} while (0)
-
-/* Return the int64 number as a string.  If the --human-readable option was
- * specified, we may output the number in K, M, or G units.  We can return
- * up to 4 buffers at a time. */
-char *human_num(int64 num)
-{
-	static char bufs[4][128]; /* more than enough room */
-	static unsigned int n;
-	char *s;
-	int negated;
-
-	n = (n + 1) % (sizeof bufs / sizeof bufs[0]);
-
-	if (human_readable) {
-		if (human_readable == 1)
-			HUMANIFY(1000);
-		else
-			HUMANIFY(1024);
-	}
-
-	s = bufs[n] + sizeof bufs[0] - 1;
-	*s = '\0';
-
-	if (!num)
-		*--s = '0';
-	if (num < 0) {
-		/* A maximum-size negated number can't fit as a positive,
-		 * so do one digit in negated form to start us off. */
-		*--s = (char)(-(num % 10)) + '0';
-		num = -(num / 10);
-		negated = 1;
-	} else
-		negated = 0;
-
-	while (num) {
-		*--s = (char)(num % 10) + '0';
-		num /= 10;
-	}
-
-	if (negated)
-		*--s = '-';
-
-	return s;
-}
-
-/* Return the double number as a string.  If the --human-readable option was
- * specified, we may output the number in K, M, or G units.  We use a buffer
- * from human_num() to return our result. */
-char *human_dnum(double dnum, int decimal_digits)
-{
-	char *buf = human_num(dnum);
-	int len = strlen(buf);
-	if (isDigit(buf + len - 1)) {
-		/* There's extra room in buf prior to the start of the num. */
-		buf -= decimal_digits + 2;
-		snprintf(buf, len + decimal_digits + 3, "%.*f", decimal_digits, dnum);
-	}
-	return buf;
-}
-
 /* Return the date and time as a string.  Some callers tweak returned buf. */
 char *timestring(time_t t)
 {
 	static char TimeBuf[200];
 	struct tm *tm = localtime(&t);
 	char *p;
@@ -1335,40 +1290,12 @@
 	if ((p = strchr(TimeBuf, '\n')) != NULL)
 		*p = '\0';
 
 	return TimeBuf;
 }
 
-/**
- * Sleep for a specified number of milliseconds.
- *
- * Always returns TRUE.  (In the future it might return FALSE if
- * interrupted.)
- **/
-int msleep(int t)
-{
-	int tdiff = 0;
-	struct timeval tval, t1, t2;
-
-	gettimeofday(&t1, NULL);
-
-	while (tdiff < t) {
-		tval.tv_sec = (t-tdiff)/1000;
-		tval.tv_usec = 1000*((t-tdiff)%1000);
-
-		errno = 0;
-		select(0,NULL,NULL, NULL, &tval);
-
-		gettimeofday(&t2, NULL);
-		tdiff = (t2.tv_sec - t1.tv_sec)*1000 +
-			(t2.tv_usec - t1.tv_usec)/1000;
-	}
-
-	return True;
-}
-
 /* Determine if two time_t values are equivalent (either exact, or in
  * the modification timestamp window established by --modify-window).
  *
  * @retval 0 if the times should be treated as the same
  *
  * @retval +1 if the first is later
@@ -1396,17 +1323,19 @@
    with insure. A xterm with a gdb is popped up when insure catches
    a error. It is Linux specific.
 **/
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6)
 {
 	static int (*fn)();
-	int ret;
+	int ret, pid_int = getpid();
 	char *cmd;
 
-	asprintf(&cmd, "/usr/X11R6/bin/xterm -display :0 -T Panic -n Panic -e /bin/sh -c 'cat /tmp/ierrs.*.%d ; gdb /proc/%d/exe %d'",
-		getpid(), getpid(), getpid());
+	if (asprintf(&cmd,
+	    "/usr/X11R6/bin/xterm -display :0 -T Panic -n Panic -e /bin/sh -c 'cat /tmp/ierrs.*.%d ; "
+	    "gdb /proc/%d/exe %d'", pid_int, pid_int, pid_int) < 0)
+		return -1;
 
 	if (!fn) {
 		static void *h;
 		h = dlopen("/usr/local/parasoft/insure++lite/lib.linux2/libinsure.so", RTLD_LAZY);
 		fn = dlsym(h, "_Insure_trap_error");
 	}
@@ -1418,30 +1347,12 @@
 	free(cmd);
 
 	return ret;
 }
 #endif
 
-#define MALLOC_MAX 0x40000000
-
-void *_new_array(unsigned long num, unsigned int size, int use_calloc)
-{
-	if (num >= MALLOC_MAX/size)
-		return NULL;
-	return use_calloc ? calloc(num, size) : malloc(num * size);
-}
-
-void *_realloc_array(void *ptr, unsigned int size, size_t num)
-{
-	if (num >= MALLOC_MAX/size)
-		return NULL;
-	if (!ptr)
-		return malloc(size * num);
-	return realloc(ptr, size * num);
-}
-
 /* Take a filename and filename length and return the most significant
  * filename suffix we can find.  This ignores suffixes such as "~",
  * ".bak", ".orig", ".~1~", etc. */
 const char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr)
 {
 	const char *suf, *s;
@@ -1500,17 +1411,17 @@
  * between changed characters as a minor distance quantity.  The normal
  * Levenshtein units of distance (each signifying a single change between
  * the two strings) are defined as a "UNIT". */
 
 #define UNIT (1 << 16)
 
-uint32 fuzzy_distance(const char *s1, int len1, const char *s2, int len2)
+uint32 fuzzy_distance(const char *s1, unsigned len1, const char *s2, unsigned len2)
 {
 	uint32 a[MAXPATHLEN], diag, above, left, diag_inc, above_inc, left_inc;
 	int32 cost;
-	int i1, i2;
+	unsigned i1, i2;
 
 	if (!len1 || !len2) {
 		if (!len1) {
 			s1 = s2;
 			len1 = len2;
 		}
@@ -1685,15 +1596,15 @@
 		else
 			new_size *= 2;
 		if (new_size < lp->malloced)
 			overflow_exit("expand_item_list");
 		/* Using _realloc_array() lets us pass the size, not a type. */
 		new_ptr = _realloc_array(lp->items, item_size, new_size);
-		if (verbose >= 4) {
-			rprintf(FINFO, "[%s] expand %s to %.0f bytes, did%s move\n",
-				who_am_i(), desc, (double)new_size * item_size,
+		if (DEBUG_GTE(FLIST, 3)) {
+			rprintf(FINFO, "[%s] expand %s to %s bytes, did%s move\n",
+				who_am_i(), desc, big_num(new_size * item_size),
 				new_ptr == lp->items ? " not" : "");
 		}
 		if (!new_ptr)
 			out_of_memory("expand_item_list");
 
 		lp->items = new_ptr;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/wildtest.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/wildtest.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/wildtest.c	2011-09-23 14:33:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/wildtest.c	2013-06-12 04:28:45.000000000 +0800
@@ -1,10 +1,10 @@
 /*
  * Test suite for the wildmatch code.
  *
- * Copyright (C) 2003-2009 Wayne Davison
+ * Copyright (C) 2003-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/xattrs.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/xattrs.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/xattrs.c	2011-09-23 00:02:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/xattrs.c	2013-01-20 03:05:53.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * Extended Attribute support for rsync.
  * Written by Jay Fenlason, vaguely based on the ACLs patch.
  *
  * Copyright (C) 2004 Red Hat, Inc.
- * Copyright (C) 2006-2009 Wayne Davison
+ * Copyright (C) 2006-2013 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
@@ -18,12 +18,13 @@
  * You should have received a copy of the GNU General Public License along
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 #include "ifuncs.h"
+#include "inums.h"
 #include "lib/sysxattrs.h"
 
 #ifdef SUPPORT_XATTRS
 
 extern int dry_run;
 extern int am_root;
@@ -119,13 +120,13 @@
 	return strcmp(xa1->name, xa2->name);
 }
 
 static ssize_t get_xattr_names(const char *fname)
 {
 	ssize_t list_len;
-	double arg;
+	int64 arg;
 
 	if (!namebuf) {
 		namebuf_len = 1024;
 		namebuf = new_array(char, namebuf_len);
 		if (!namebuf)
 			out_of_memory("get_xattr_names");
@@ -137,17 +138,17 @@
 		if (list_len >= 0) {
 			if ((size_t)list_len <= namebuf_len)
 				break;
 		} else if (errno == ENOTSUP)
 			return 0;
 		else if (errno != ERANGE) {
-			arg = (double)namebuf_len;
+			arg = namebuf_len;
 		  got_error:
 			rsyserr(FERROR_XFER, errno,
-				"get_xattr_names: llistxattr(\"%s\",%.0f) failed",
-				full_fname(fname), arg);
+				"get_xattr_names: llistxattr(\"%s\",%s) failed",
+				full_fname(fname), big_num(arg));
 			return -1;
 		}
 		list_len = sys_llistxattr(fname, NULL, 0);
 		if (list_len < 0) {
 			arg = 0;
 			goto got_error;
@@ -215,13 +216,13 @@
 static int rsync_xal_get(const char *fname, item_list *xalp)
 {
 	ssize_t list_len, name_len;
 	size_t datum_len, name_offset;
 	char *name, *ptr;
 #ifdef HAVE_LINUX_XATTRS
-	int user_only = am_sender ? 0 : am_root <= 0;
+	int user_only = am_sender ? 0 : !am_root;
 #endif
 	rsync_xa *rxa;
 	int count;
 
 	/* This puts the name list into the "namebuf" buffer. */
 	if ((list_len = get_xattr_names(fname)) < 0)
@@ -319,13 +320,13 @@
 int copy_xattrs(const char *source, const char *dest)
 {
 	ssize_t list_len, name_len;
 	size_t datum_len;
 	char *name, *ptr;
 #ifdef HAVE_LINUX_XATTRS
-	int user_only = am_root <= 0;
+	int user_only = am_sender ? 0 : am_root <= 0;
 #endif
 
 	/* This puts the name list into the "namebuf" buffer. */
 	if ((list_len = get_xattr_names(source)) < 0)
 		return -1;
 
@@ -662,13 +663,13 @@
 #endif
 	int ndx = read_varint(f);
 
 	if (ndx < 0 || (size_t)ndx > rsync_xal_l.count) {
 		rprintf(FERROR, "receive_xattr: xa index %d out of"
 			" range for %s\n", ndx, f_name(file, NULL));
-		exit_cleanup(RERR_PROTOCOL);
+		exit_cleanup(RERR_STREAMIO);
 	}
 
 	if (ndx != 0) {
 		F_XATTR(file) = ndx - 1;
 		return;
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/adler32.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/adler32.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/adler32.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/adler32.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,59 +1,67 @@
 /* adler32.c -- compute the Adler-32 checksum of a data stream
- * Copyright (C) 1995-2004 Mark Adler
+ * Copyright (C) 1995-2011 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* @(#) $Id$ */
 
-#define ZLIB_INTERNAL
-#include "zlib.h"
+#include "zutil.h"
 
-#define BASE 65521UL    /* largest prime smaller than 65536 */
+#define local static
+
+local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));
+
+#define BASE 65521      /* largest prime smaller than 65536 */
 #define NMAX 5552
 /* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
 
 #define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
 #define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
 #define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
 #define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
 #define DO16(buf)   DO8(buf,0); DO8(buf,8);
 
-/* use NO_DIVIDE if your processor does not do division in hardware */
+/* use NO_DIVIDE if your processor does not do division in hardware --
+   try it both ways to see which is faster */
 #ifdef NO_DIVIDE
-#  define MOD(a) \
+/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
+   (thank you to John Reiser for pointing this out) */
+#  define CHOP(a) \
     do { \
-        if (a >= (BASE << 16)) a -= (BASE << 16); \
-        if (a >= (BASE << 15)) a -= (BASE << 15); \
-        if (a >= (BASE << 14)) a -= (BASE << 14); \
-        if (a >= (BASE << 13)) a -= (BASE << 13); \
-        if (a >= (BASE << 12)) a -= (BASE << 12); \
-        if (a >= (BASE << 11)) a -= (BASE << 11); \
-        if (a >= (BASE << 10)) a -= (BASE << 10); \
-        if (a >= (BASE << 9)) a -= (BASE << 9); \
-        if (a >= (BASE << 8)) a -= (BASE << 8); \
-        if (a >= (BASE << 7)) a -= (BASE << 7); \
-        if (a >= (BASE << 6)) a -= (BASE << 6); \
-        if (a >= (BASE << 5)) a -= (BASE << 5); \
-        if (a >= (BASE << 4)) a -= (BASE << 4); \
-        if (a >= (BASE << 3)) a -= (BASE << 3); \
-        if (a >= (BASE << 2)) a -= (BASE << 2); \
-        if (a >= (BASE << 1)) a -= (BASE << 1); \
+        unsigned long tmp = a >> 16; \
+        a &= 0xffffUL; \
+        a += (tmp << 4) - tmp; \
+    } while (0)
+#  define MOD28(a) \
+    do { \
+        CHOP(a); \
         if (a >= BASE) a -= BASE; \
     } while (0)
-#  define MOD4(a) \
+#  define MOD(a) \
     do { \
-        if (a >= (BASE << 4)) a -= (BASE << 4); \
-        if (a >= (BASE << 3)) a -= (BASE << 3); \
-        if (a >= (BASE << 2)) a -= (BASE << 2); \
-        if (a >= (BASE << 1)) a -= (BASE << 1); \
+        CHOP(a); \
+        MOD28(a); \
+    } while (0)
+#  define MOD63(a) \
+    do { /* this assumes a is not negative */ \
+        z_off64_t tmp = a >> 32; \
+        a &= 0xffffffffL; \
+        a += (tmp << 8) - (tmp << 5) + tmp; \
+        tmp = a >> 16; \
+        a &= 0xffffL; \
+        a += (tmp << 4) - tmp; \
+        tmp = a >> 16; \
+        a &= 0xffffL; \
+        a += (tmp << 4) - tmp; \
         if (a >= BASE) a -= BASE; \
     } while (0)
 #else
 #  define MOD(a) a %= BASE
-#  define MOD4(a) a %= BASE
+#  define MOD28(a) a %= BASE
+#  define MOD63(a) a %= BASE
 #endif
 
 /* ========================================================================= */
 uLong ZEXPORT adler32(adler, buf, len)
     uLong adler;
     const Bytef *buf;
@@ -86,13 +94,13 @@
         while (len--) {
             adler += *buf++;
             sum2 += adler;
         }
         if (adler >= BASE)
             adler -= BASE;
-        MOD4(sum2);             /* only added so many BASE's */
+        MOD28(sum2);            /* only added so many BASE's */
         return adler | (sum2 << 16);
     }
 
     /* do length NMAX blocks -- requires just one modulo operation */
     while (len >= NMAX) {
         len -= NMAX;
@@ -122,28 +130,50 @@
 
     /* return recombined sums */
     return adler | (sum2 << 16);
 }
 
 /* ========================================================================= */
-uLong ZEXPORT adler32_combine(adler1, adler2, len2)
+local uLong adler32_combine_(adler1, adler2, len2)
     uLong adler1;
     uLong adler2;
-    z_off_t len2;
+    z_off64_t len2;
 {
     unsigned long sum1;
     unsigned long sum2;
     unsigned rem;
 
+    /* for negative len, return invalid adler32 as a clue for debugging */
+    if (len2 < 0)
+        return 0xffffffffUL;
+
     /* the derivation of this formula is left as an exercise for the reader */
-    rem = (unsigned)(len2 % BASE);
+    MOD63(len2);                /* assumes len2 >= 0 */
+    rem = (unsigned)len2;
     sum1 = adler1 & 0xffff;
     sum2 = rem * sum1;
     MOD(sum2);
     sum1 += (adler2 & 0xffff) + BASE - 1;
     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
-    if (sum1 > BASE) sum1 -= BASE;
-    if (sum1 > BASE) sum1 -= BASE;
-    if (sum2 > (BASE << 1)) sum2 -= (BASE << 1);
-    if (sum2 > BASE) sum2 -= BASE;
+    if (sum1 >= BASE) sum1 -= BASE;
+    if (sum1 >= BASE) sum1 -= BASE;
+    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);
+    if (sum2 >= BASE) sum2 -= BASE;
     return sum1 | (sum2 << 16);
 }
+
+/* ========================================================================= */
+uLong ZEXPORT adler32_combine(adler1, adler2, len2)
+    uLong adler1;
+    uLong adler2;
+    z_off_t len2;
+{
+    return adler32_combine_(adler1, adler2, len2);
+}
+
+uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
+    uLong adler1;
+    uLong adler2;
+    z_off64_t len2;
+{
+    return adler32_combine_(adler1, adler2, len2);
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/ChangeLog /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/ChangeLog
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/ChangeLog	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/ChangeLog	2013-06-10 13:27:33.000000000 +0800
@@ -1,22 +1,639 @@
 
                 ChangeLog file for zlib
 
+Changes in 1.2.8 (28 Apr 2013)
+- Update contrib/minizip/iowin32.c for Windows RT [Vollant]
+- Do not force Z_CONST for C++
+- Clean up contrib/vstudio [Ro]
+- Correct spelling error in zlib.h
+- Fix mixed line endings in contrib/vstudio
+
+Changes in 1.2.7.3 (13 Apr 2013)
+- Fix version numbers and DLL names in contrib/vstudio/*/zlib.rc
+
+Changes in 1.2.7.2 (13 Apr 2013)
+- Change check for a four-byte type back to hexadecimal
+- Fix typo in win32/Makefile.msc
+- Add casts in gzwrite.c for pointer differences
+
+Changes in 1.2.7.1 (24 Mar 2013)
+- Replace use of unsafe string functions with snprintf if available
+- Avoid including stddef.h on Windows for Z_SOLO compile [Niessink]
+- Fix gzgetc undefine when Z_PREFIX set [Turk]
+- Eliminate use of mktemp in Makefile (not always available)
+- Fix bug in 'F' mode for gzopen()
+- Add inflateGetDictionary() function
+- Correct comment in deflate.h
+- Use _snprintf for snprintf in Microsoft C
+- On Darwin, only use /usr/bin/libtool if libtool is not Apple
+- Delete "--version" file if created by "ar --version" [Richard G.]
+- Fix configure check for veracity of compiler error return codes
+- Fix CMake compilation of static lib for MSVC2010 x64
+- Remove unused variable in infback9.c
+- Fix argument checks in gzlog_compress() and gzlog_write()
+- Clean up the usage of z_const and respect const usage within zlib
+- Clean up examples/gzlog.[ch] comparisons of different types
+- Avoid shift equal to bits in type (caused endless loop)
+- Fix unintialized value bug in gzputc() introduced by const patches
+- Fix memory allocation error in examples/zran.c [Nor]
+- Fix bug where gzopen(), gzclose() would write an empty file
+- Fix bug in gzclose() when gzwrite() runs out of memory
+- Check for input buffer malloc failure in examples/gzappend.c
+- Add note to contrib/blast to use binary mode in stdio
+- Fix comparisons of differently signed integers in contrib/blast
+- Check for invalid code length codes in contrib/puff
+- Fix serious but very rare decompression bug in inftrees.c
+- Update inflateBack() comments, since inflate() can be faster
+- Use underscored I/O function names for WINAPI_FAMILY
+- Add _tr_flush_bits to the external symbols prefixed by --zprefix
+- Add contrib/vstudio/vc10 pre-build step for static only
+- Quote --version-script argument in CMakeLists.txt
+- Don't specify --version-script on Apple platforms in CMakeLists.txt
+- Fix casting error in contrib/testzlib/testzlib.c
+- Fix types in contrib/minizip to match result of get_crc_table()
+- Simplify contrib/vstudio/vc10 with 'd' suffix
+- Add TOP support to win32/Makefile.msc
+- Suport i686 and amd64 assembler builds in CMakeLists.txt
+- Fix typos in the use of _LARGEFILE64_SOURCE in zconf.h
+- Add vc11 and vc12 build files to contrib/vstudio
+- Add gzvprintf() as an undocumented function in zlib
+- Fix configure for Sun shell
+- Remove runtime check in configure for four-byte integer type
+- Add casts and consts to ease user conversion to C++
+- Add man pages for minizip and miniunzip
+- In Makefile uninstall, don't rm if preceding cd fails
+- Do not return Z_BUF_ERROR if deflateParam() has nothing to write
+
+Changes in 1.2.7 (2 May 2012)
+- Replace use of memmove() with a simple copy for portability
+- Test for existence of strerror
+- Restore gzgetc_ for backward compatibility with 1.2.6
+- Fix build with non-GNU make on Solaris
+- Require gcc 4.0 or later on Mac OS X to use the hidden attribute
+- Include unistd.h for Watcom C
+- Use __WATCOMC__ instead of __WATCOM__
+- Do not use the visibility attribute if NO_VIZ defined
+- Improve the detection of no hidden visibility attribute
+- Avoid using __int64 for gcc or solo compilation
+- Cast to char * in gzprintf to avoid warnings [Zinser]
+- Fix make_vms.com for VAX [Zinser]
+- Don't use library or built-in byte swaps
+- Simplify test and use of gcc hidden attribute
+- Fix bug in gzclose_w() when gzwrite() fails to allocate memory
+- Add "x" (O_EXCL) and "e" (O_CLOEXEC) modes support to gzopen()
+- Fix bug in test/minigzip.c for configure --solo
+- Fix contrib/vstudio project link errors [Mohanathas]
+- Add ability to choose the builder in make_vms.com [Schweda]
+- Add DESTDIR support to mingw32 win32/Makefile.gcc
+- Fix comments in win32/Makefile.gcc for proper usage
+- Allow overriding the default install locations for cmake
+- Generate and install the pkg-config file with cmake
+- Build both a static and a shared version of zlib with cmake
+- Include version symbols for cmake builds
+- If using cmake with MSVC, add the source directory to the includes
+- Remove unneeded EXTRA_CFLAGS from win32/Makefile.gcc [Truta]
+- Move obsolete emx makefile to old [Truta]
+- Allow the use of -Wundef when compiling or using zlib
+- Avoid the use of the -u option with mktemp
+- Improve inflate() documentation on the use of Z_FINISH
+- Recognize clang as gcc
+- Add gzopen_w() in Windows for wide character path names
+- Rename zconf.h in CMakeLists.txt to move it out of the way
+- Add source directory in CMakeLists.txt for building examples
+- Look in build directory for zlib.pc in CMakeLists.txt
+- Remove gzflags from zlibvc.def in vc9 and vc10
+- Fix contrib/minizip compilation in the MinGW environment
+- Update ./configure for Solaris, support --64 [Mooney]
+- Remove -R. from Solaris shared build (possible security issue)
+- Avoid race condition for parallel make (-j) running example
+- Fix type mismatch between get_crc_table() and crc_table
+- Fix parsing of version with "-" in CMakeLists.txt [Snider, Ziegler]
+- Fix the path to zlib.map in CMakeLists.txt
+- Force the native libtool in Mac OS X to avoid GNU libtool [Beebe]
+- Add instructions to win32/Makefile.gcc for shared install [Torri]
+
+Changes in 1.2.6.1 (12 Feb 2012)
+- Avoid the use of the Objective-C reserved name "id"
+- Include io.h in gzguts.h for Microsoft compilers
+- Fix problem with ./configure --prefix and gzgetc macro
+- Include gz_header definition when compiling zlib solo
+- Put gzflags() functionality back in zutil.c
+- Avoid library header include in crc32.c for Z_SOLO
+- Use name in GCC_CLASSIC as C compiler for coverage testing, if set
+- Minor cleanup in contrib/minizip/zip.c [Vollant]
+- Update make_vms.com [Zinser]
+- Remove unnecessary gzgetc_ function
+- Use optimized byte swap operations for Microsoft and GNU [Snyder]
+- Fix minor typo in zlib.h comments [Rzesniowiecki]
+
+Changes in 1.2.6 (29 Jan 2012)
+- Update the Pascal interface in contrib/pascal
+- Fix function numbers for gzgetc_ in zlibvc.def files
+- Fix configure.ac for contrib/minizip [Schiffer]
+- Fix large-entry detection in minizip on 64-bit systems [Schiffer]
+- Have ./configure use the compiler return code for error indication
+- Fix CMakeLists.txt for cross compilation [McClure]
+- Fix contrib/minizip/zip.c for 64-bit architectures [Dalsnes]
+- Fix compilation of contrib/minizip on FreeBSD [Marquez]
+- Correct suggested usages in win32/Makefile.msc [Shachar, Horvath]
+- Include io.h for Turbo C / Borland C on all platforms [Truta]
+- Make version explicit in contrib/minizip/configure.ac [Bosmans]
+- Avoid warning for no encryption in contrib/minizip/zip.c [Vollant]
+- Minor cleanup up contrib/minizip/unzip.c [Vollant]
+- Fix bug when compiling minizip with C++ [Vollant]
+- Protect for long name and extra fields in contrib/minizip [Vollant]
+- Avoid some warnings in contrib/minizip [Vollant]
+- Add -I../.. -L../.. to CFLAGS for minizip and miniunzip
+- Add missing libs to minizip linker command
+- Add support for VPATH builds in contrib/minizip
+- Add an --enable-demos option to contrib/minizip/configure
+- Add the generation of configure.log by ./configure
+- Exit when required parameters not provided to win32/Makefile.gcc
+- Have gzputc return the character written instead of the argument
+- Use the -m option on ldconfig for BSD systems [Tobias]
+- Correct in zlib.map when deflateResetKeep was added
+
+Changes in 1.2.5.3 (15 Jan 2012)
+- Restore gzgetc function for binary compatibility
+- Do not use _lseeki64 under Borland C++ [Truta]
+- Update win32/Makefile.msc to build test/*.c [Truta]
+- Remove old/visualc6 given CMakefile and other alternatives
+- Update AS400 build files and documentation [Monnerat]
+- Update win32/Makefile.gcc to build test/*.c [Truta]
+- Permit stronger flushes after Z_BLOCK flushes
+- Avoid extraneous empty blocks when doing empty flushes
+- Permit Z_NULL arguments to deflatePending
+- Allow deflatePrime() to insert bits in the middle of a stream
+- Remove second empty static block for Z_PARTIAL_FLUSH
+- Write out all of the available bits when using Z_BLOCK
+- Insert the first two strings in the hash table after a flush
+
+Changes in 1.2.5.2 (17 Dec 2011)
+- fix ld error: unable to find version dependency 'ZLIB_1.2.5'
+- use relative symlinks for shared libs
+- Avoid searching past window for Z_RLE strategy
+- Assure that high-water mark initialization is always applied in deflate
+- Add assertions to fill_window() in deflate.c to match comments
+- Update python link in README
+- Correct spelling error in gzread.c
+- Fix bug in gzgets() for a concatenated empty gzip stream
+- Correct error in comment for gz_make()
+- Change gzread() and related to ignore junk after gzip streams
+- Allow gzread() and related to continue after gzclearerr()
+- Allow gzrewind() and gzseek() after a premature end-of-file
+- Simplify gzseek() now that raw after gzip is ignored
+- Change gzgetc() to a macro for speed (~40% speedup in testing)
+- Fix gzclose() to return the actual error last encountered
+- Always add large file support for windows
+- Include zconf.h for windows large file support
+- Include zconf.h.cmakein for windows large file support
+- Update zconf.h.cmakein on make distclean
+- Merge vestigial vsnprintf determination from zutil.h to gzguts.h
+- Clarify how gzopen() appends in zlib.h comments
+- Correct documentation of gzdirect() since junk at end now ignored
+- Add a transparent write mode to gzopen() when 'T' is in the mode
+- Update python link in zlib man page
+- Get inffixed.h and MAKEFIXED result to match
+- Add a ./config --solo option to make zlib subset with no libary use
+- Add undocumented inflateResetKeep() function for CAB file decoding
+- Add --cover option to ./configure for gcc coverage testing
+- Add #define ZLIB_CONST option to use const in the z_stream interface
+- Add comment to gzdopen() in zlib.h to use dup() when using fileno()
+- Note behavior of uncompress() to provide as much data as it can
+- Add files in contrib/minizip to aid in building libminizip
+- Split off AR options in Makefile.in and configure
+- Change ON macro to Z_ARG to avoid application conflicts
+- Facilitate compilation with Borland C++ for pragmas and vsnprintf
+- Include io.h for Turbo C / Borland C++
+- Move example.c and minigzip.c to test/
+- Simplify incomplete code table filling in inflate_table()
+- Remove code from inflate.c and infback.c that is impossible to execute
+- Test the inflate code with full coverage
+- Allow deflateSetDictionary, inflateSetDictionary at any time (in raw)
+- Add deflateResetKeep and fix inflateResetKeep to retain dictionary
+- Fix gzwrite.c to accommodate reduced memory zlib compilation
+- Have inflate() with Z_FINISH avoid the allocation of a window
+- Do not set strm->adler when doing raw inflate
+- Fix gzeof() to behave just like feof() when read is not past end of file
+- Fix bug in gzread.c when end-of-file is reached
+- Avoid use of Z_BUF_ERROR in gz* functions except for premature EOF
+- Document gzread() capability to read concurrently written files
+- Remove hard-coding of resource compiler in CMakeLists.txt [Blammo]
+
+Changes in 1.2.5.1 (10 Sep 2011)
+- Update FAQ entry on shared builds (#13)
+- Avoid symbolic argument to chmod in Makefile.in
+- Fix bug and add consts in contrib/puff [Oberhumer]
+- Update contrib/puff/zeros.raw test file to have all block types
+- Add full coverage test for puff in contrib/puff/Makefile
+- Fix static-only-build install in Makefile.in
+- Fix bug in unzGetCurrentFileInfo() in contrib/minizip [Kuno]
+- Add libz.a dependency to shared in Makefile.in for parallel builds
+- Spell out "number" (instead of "nb") in zlib.h for total_in, total_out
+- Replace $(...) with `...` in configure for non-bash sh [Bowler]
+- Add darwin* to Darwin* and solaris* to SunOS\ 5* in configure [Groffen]
+- Add solaris* to Linux* in configure to allow gcc use [Groffen]
+- Add *bsd* to Linux* case in configure [Bar-Lev]
+- Add inffast.obj to dependencies in win32/Makefile.msc
+- Correct spelling error in deflate.h [Kohler]
+- Change libzdll.a again to libz.dll.a (!) in win32/Makefile.gcc
+- Add test to configure for GNU C looking for gcc in output of $cc -v
+- Add zlib.pc generation to win32/Makefile.gcc [Weigelt]
+- Fix bug in zlib.h for _FILE_OFFSET_BITS set and _LARGEFILE64_SOURCE not
+- Add comment in zlib.h that adler32_combine with len2 < 0 makes no sense
+- Make NO_DIVIDE option in adler32.c much faster (thanks to John Reiser)
+- Make stronger test in zconf.h to include unistd.h for LFS
+- Apply Darwin patches for 64-bit file offsets to contrib/minizip [Slack]
+- Fix zlib.h LFS support when Z_PREFIX used
+- Add updated as400 support (removed from old) [Monnerat]
+- Avoid deflate sensitivity to volatile input data
+- Avoid division in adler32_combine for NO_DIVIDE
+- Clarify the use of Z_FINISH with deflateBound() amount of space
+- Set binary for output file in puff.c
+- Use u4 type for crc_table to avoid conversion warnings
+- Apply casts in zlib.h to avoid conversion warnings
+- Add OF to prototypes for adler32_combine_ and crc32_combine_ [Miller]
+- Improve inflateSync() documentation to note indeterminancy
+- Add deflatePending() function to return the amount of pending output
+- Correct the spelling of "specification" in FAQ [Randers-Pehrson]
+- Add a check in configure for stdarg.h, use for gzprintf()
+- Check that pointers fit in ints when gzprint() compiled old style
+- Add dummy name before $(SHAREDLIBV) in Makefile [Bar-Lev, Bowler]
+- Delete line in configure that adds -L. libz.a to LDFLAGS [Weigelt]
+- Add debug records in assmebler code [Londer]
+- Update RFC references to use http://tools.ietf.org/html/... [Li]
+- Add --archs option, use of libtool to configure for Mac OS X [Borstel]
+
+Changes in 1.2.5 (19 Apr 2010)
+- Disable visibility attribute in win32/Makefile.gcc [Bar-Lev]
+- Default to libdir as sharedlibdir in configure [Nieder]
+- Update copyright dates on modified source files
+- Update trees.c to be able to generate modified trees.h
+- Exit configure for MinGW, suggesting win32/Makefile.gcc
+- Check for NULL path in gz_open [Homurlu]
+
+Changes in 1.2.4.5 (18 Apr 2010)
+- Set sharedlibdir in configure [Torok]
+- Set LDFLAGS in Makefile.in [Bar-Lev]
+- Avoid mkdir objs race condition in Makefile.in [Bowler]
+- Add ZLIB_INTERNAL in front of internal inter-module functions and arrays
+- Define ZLIB_INTERNAL to hide internal functions and arrays for GNU C
+- Don't use hidden attribute when it is a warning generator (e.g. Solaris)
+
+Changes in 1.2.4.4 (18 Apr 2010)
+- Fix CROSS_PREFIX executable testing, CHOST extract, mingw* [Torok]
+- Undefine _LARGEFILE64_SOURCE in zconf.h if it is zero, but not if empty
+- Try to use bash or ksh regardless of functionality of /bin/sh
+- Fix configure incompatibility with NetBSD sh
+- Remove attempt to run under bash or ksh since have better NetBSD fix
+- Fix win32/Makefile.gcc for MinGW [Bar-Lev]
+- Add diagnostic messages when using CROSS_PREFIX in configure
+- Added --sharedlibdir option to configure [Weigelt]
+- Use hidden visibility attribute when available [Frysinger]
+
+Changes in 1.2.4.3 (10 Apr 2010)
+- Only use CROSS_PREFIX in configure for ar and ranlib if they exist
+- Use CROSS_PREFIX for nm [Bar-Lev]
+- Assume _LARGEFILE64_SOURCE defined is equivalent to true
+- Avoid use of undefined symbols in #if with && and ||
+- Make *64 prototypes in gzguts.h consistent with functions
+- Add -shared load option for MinGW in configure [Bowler]
+- Move z_off64_t to public interface, use instead of off64_t
+- Remove ! from shell test in configure (not portable to Solaris)
+- Change +0 macro tests to -0 for possibly increased portability
+
+Changes in 1.2.4.2 (9 Apr 2010)
+- Add consistent carriage returns to readme.txt's in masmx86 and masmx64
+- Really provide prototypes for *64 functions when building without LFS
+- Only define unlink() in minigzip.c if unistd.h not included
+- Update README to point to contrib/vstudio project files
+- Move projects/vc6 to old/ and remove projects/
+- Include stdlib.h in minigzip.c for setmode() definition under WinCE
+- Clean up assembler builds in win32/Makefile.msc [Rowe]
+- Include sys/types.h for Microsoft for off_t definition
+- Fix memory leak on error in gz_open()
+- Symbolize nm as $NM in configure [Weigelt]
+- Use TEST_LDSHARED instead of LDSHARED to link test programs [Weigelt]
+- Add +0 to _FILE_OFFSET_BITS and _LFS64_LARGEFILE in case not defined
+- Fix bug in gzeof() to take into account unused input data
+- Avoid initialization of structures with variables in puff.c
+- Updated win32/README-WIN32.txt [Rowe]
+
+Changes in 1.2.4.1 (28 Mar 2010)
+- Remove the use of [a-z] constructs for sed in configure [gentoo 310225]
+- Remove $(SHAREDLIB) from LIBS in Makefile.in [Creech]
+- Restore "for debugging" comment on sprintf() in gzlib.c
+- Remove fdopen for MVS from gzguts.h
+- Put new README-WIN32.txt in win32 [Rowe]
+- Add check for shell to configure and invoke another shell if needed
+- Fix big fat stinking bug in gzseek() on uncompressed files
+- Remove vestigial F_OPEN64 define in zutil.h
+- Set and check the value of _LARGEFILE_SOURCE and _LARGEFILE64_SOURCE
+- Avoid errors on non-LFS systems when applications define LFS macros
+- Set EXE to ".exe" in configure for MINGW [Kahle]
+- Match crc32() in crc32.c exactly to the prototype in zlib.h [Sherrill]
+- Add prefix for cross-compilation in win32/makefile.gcc [Bar-Lev]
+- Add DLL install in win32/makefile.gcc [Bar-Lev]
+- Allow Linux* or linux* from uname in configure [Bar-Lev]
+- Allow ldconfig to be redefined in configure and Makefile.in [Bar-Lev]
+- Add cross-compilation prefixes to configure [Bar-Lev]
+- Match type exactly in gz_load() invocation in gzread.c
+- Match type exactly of zcalloc() in zutil.c to zlib.h alloc_func
+- Provide prototypes for *64 functions when building zlib without LFS
+- Don't use -lc when linking shared library on MinGW
+- Remove errno.h check in configure and vestigial errno code in zutil.h
+
+Changes in 1.2.4 (14 Mar 2010)
+- Fix VER3 extraction in configure for no fourth subversion
+- Update zlib.3, add docs to Makefile.in to make .pdf out of it
+- Add zlib.3.pdf to distribution
+- Don't set error code in gzerror() if passed pointer is NULL
+- Apply destination directory fixes to CMakeLists.txt [Lowman]
+- Move #cmakedefine's to a new zconf.in.cmakein
+- Restore zconf.h for builds that don't use configure or cmake
+- Add distclean to dummy Makefile for convenience
+- Update and improve INDEX, README, and FAQ
+- Update CMakeLists.txt for the return of zconf.h [Lowman]
+- Update contrib/vstudio/vc9 and vc10 [Vollant]
+- Change libz.dll.a back to libzdll.a in win32/Makefile.gcc
+- Apply license and readme changes to contrib/asm686 [Raiter]
+- Check file name lengths and add -c option in minigzip.c [Li]
+- Update contrib/amd64 and contrib/masmx86/ [Vollant]
+- Avoid use of "eof" parameter in trees.c to not shadow library variable
+- Update make_vms.com for removal of zlibdefs.h [Zinser]
+- Update assembler code and vstudio projects in contrib [Vollant]
+- Remove outdated assembler code contrib/masm686 and contrib/asm586
+- Remove old vc7 and vc8 from contrib/vstudio
+- Update win32/Makefile.msc, add ZLIB_VER_SUBREVISION [Rowe]
+- Fix memory leaks in gzclose_r() and gzclose_w(), file leak in gz_open()
+- Add contrib/gcc_gvmat64 for longest_match and inflate_fast [Vollant]
+- Remove *64 functions from win32/zlib.def (they're not 64-bit yet)
+- Fix bug in void-returning vsprintf() case in gzwrite.c
+- Fix name change from inflate.h in contrib/inflate86/inffas86.c
+- Check if temporary file exists before removing in make_vms.com [Zinser]
+- Fix make install and uninstall for --static option
+- Fix usage of _MSC_VER in gzguts.h and zutil.h [Truta]
+- Update readme.txt in contrib/masmx64 and masmx86 to assemble
+
+Changes in 1.2.3.9 (21 Feb 2010)
+- Expunge gzio.c
+- Move as400 build information to old
+- Fix updates in contrib/minizip and contrib/vstudio
+- Add const to vsnprintf test in configure to avoid warnings [Weigelt]
+- Delete zconf.h (made by configure) [Weigelt]
+- Change zconf.in.h to zconf.h.in per convention [Weigelt]
+- Check for NULL buf in gzgets()
+- Return empty string for gzgets() with len == 1 (like fgets())
+- Fix description of gzgets() in zlib.h for end-of-file, NULL return
+- Update minizip to 1.1 [Vollant]
+- Avoid MSVC loss of data warnings in gzread.c, gzwrite.c
+- Note in zlib.h that gzerror() should be used to distinguish from EOF
+- Remove use of snprintf() from gzlib.c
+- Fix bug in gzseek()
+- Update contrib/vstudio, adding vc9 and vc10 [Kuno, Vollant]
+- Fix zconf.h generation in CMakeLists.txt [Lowman]
+- Improve comments in zconf.h where modified by configure
+
+Changes in 1.2.3.8 (13 Feb 2010)
+- Clean up text files (tabs, trailing whitespace, etc.) [Oberhumer]
+- Use z_off64_t in gz_zero() and gz_skip() to match state->skip
+- Avoid comparison problem when sizeof(int) == sizeof(z_off64_t)
+- Revert to Makefile.in from 1.2.3.6 (live with the clutter)
+- Fix missing error return in gzflush(), add zlib.h note
+- Add *64 functions to zlib.map [Levin]
+- Fix signed/unsigned comparison in gz_comp()
+- Use SFLAGS when testing shared linking in configure
+- Add --64 option to ./configure to use -m64 with gcc
+- Fix ./configure --help to correctly name options
+- Have make fail if a test fails [Levin]
+- Avoid buffer overrun in contrib/masmx64/gvmat64.asm [Simpson]
+- Remove assembler object files from contrib
+
+Changes in 1.2.3.7 (24 Jan 2010)
+- Always gzopen() with O_LARGEFILE if available
+- Fix gzdirect() to work immediately after gzopen() or gzdopen()
+- Make gzdirect() more precise when the state changes while reading
+- Improve zlib.h documentation in many places
+- Catch memory allocation failure in gz_open()
+- Complete close operation if seek forward in gzclose_w() fails
+- Return Z_ERRNO from gzclose_r() if close() fails
+- Return Z_STREAM_ERROR instead of EOF for gzclose() being passed NULL
+- Return zero for gzwrite() errors to match zlib.h description
+- Return -1 on gzputs() error to match zlib.h description
+- Add zconf.in.h to allow recovery from configure modification [Weigelt]
+- Fix static library permissions in Makefile.in [Weigelt]
+- Avoid warnings in configure tests that hide functionality [Weigelt]
+- Add *BSD and DragonFly to Linux case in configure [gentoo 123571]
+- Change libzdll.a to libz.dll.a in win32/Makefile.gcc [gentoo 288212]
+- Avoid access of uninitialized data for first inflateReset2 call [Gomes]
+- Keep object files in subdirectories to reduce the clutter somewhat
+- Remove default Makefile and zlibdefs.h, add dummy Makefile
+- Add new external functions to Z_PREFIX, remove duplicates, z_z_ -> z_
+- Remove zlibdefs.h completely -- modify zconf.h instead
+
+Changes in 1.2.3.6 (17 Jan 2010)
+- Avoid void * arithmetic in gzread.c and gzwrite.c
+- Make compilers happier with const char * for gz_error message
+- Avoid unused parameter warning in inflate.c
+- Avoid signed-unsigned comparison warning in inflate.c
+- Indent #pragma's for traditional C
+- Fix usage of strwinerror() in glib.c, change to gz_strwinerror()
+- Correct email address in configure for system options
+- Update make_vms.com and add make_vms.com to contrib/minizip [Zinser]
+- Update zlib.map [Brown]
+- Fix Makefile.in for Solaris 10 make of example64 and minizip64 [Torok]
+- Apply various fixes to CMakeLists.txt [Lowman]
+- Add checks on len in gzread() and gzwrite()
+- Add error message for no more room for gzungetc()
+- Remove zlib version check in gzwrite()
+- Defer compression of gzprintf() result until need to
+- Use snprintf() in gzdopen() if available
+- Remove USE_MMAP configuration determination (only used by minigzip)
+- Remove examples/pigz.c (available separately)
+- Update examples/gun.c to 1.6
+
+Changes in 1.2.3.5 (8 Jan 2010)
+- Add space after #if in zutil.h for some compilers
+- Fix relatively harmless bug in deflate_fast() [Exarevsky]
+- Fix same problem in deflate_slow()
+- Add $(SHAREDLIBV) to LIBS in Makefile.in [Brown]
+- Add deflate_rle() for faster Z_RLE strategy run-length encoding
+- Add deflate_huff() for faster Z_HUFFMAN_ONLY encoding
+- Change name of "write" variable in inffast.c to avoid library collisions
+- Fix premature EOF from gzread() in gzio.c [Brown]
+- Use zlib header window size if windowBits is 0 in inflateInit2()
+- Remove compressBound() call in deflate.c to avoid linking compress.o
+- Replace use of errno in gz* with functions, support WinCE [Alves]
+- Provide alternative to perror() in minigzip.c for WinCE [Alves]
+- Don't use _vsnprintf on later versions of MSVC [Lowman]
+- Add CMake build script and input file [Lowman]
+- Update contrib/minizip to 1.1 [Svensson, Vollant]
+- Moved nintendods directory from contrib to .
+- Replace gzio.c with a new set of routines with the same functionality
+- Add gzbuffer(), gzoffset(), gzclose_r(), gzclose_w() as part of above
+- Update contrib/minizip to 1.1b
+- Change gzeof() to return 0 on error instead of -1 to agree with zlib.h
+
+Changes in 1.2.3.4 (21 Dec 2009)
+- Use old school .SUFFIXES in Makefile.in for FreeBSD compatibility
+- Update comments in configure and Makefile.in for default --shared
+- Fix test -z's in configure [Marquess]
+- Build examplesh and minigzipsh when not testing
+- Change NULL's to Z_NULL's in deflate.c and in comments in zlib.h
+- Import LDFLAGS from the environment in configure
+- Fix configure to populate SFLAGS with discovered CFLAGS options
+- Adapt make_vms.com to the new Makefile.in [Zinser]
+- Add zlib2ansi script for C++ compilation [Marquess]
+- Add _FILE_OFFSET_BITS=64 test to make test (when applicable)
+- Add AMD64 assembler code for longest match to contrib [Teterin]
+- Include options from $SFLAGS when doing $LDSHARED
+- Simplify 64-bit file support by introducing z_off64_t type
+- Make shared object files in objs directory to work around old Sun cc
+- Use only three-part version number for Darwin shared compiles
+- Add rc option to ar in Makefile.in for when ./configure not run
+- Add -WI,-rpath,. to LDFLAGS for OSF 1 V4*
+- Set LD_LIBRARYN32_PATH for SGI IRIX shared compile
+- Protect against _FILE_OFFSET_BITS being defined when compiling zlib
+- Rename Makefile.in targets allstatic to static and allshared to shared
+- Fix static and shared Makefile.in targets to be independent
+- Correct error return bug in gz_open() by setting state [Brown]
+- Put spaces before ;;'s in configure for better sh compatibility
+- Add pigz.c (parallel implementation of gzip) to examples/
+- Correct constant in crc32.c to UL [Leventhal]
+- Reject negative lengths in crc32_combine()
+- Add inflateReset2() function to work like inflateEnd()/inflateInit2()
+- Include sys/types.h for _LARGEFILE64_SOURCE [Brown]
+- Correct typo in doc/algorithm.txt [Janik]
+- Fix bug in adler32_combine() [Zhu]
+- Catch missing-end-of-block-code error in all inflates and in puff
+    Assures that random input to inflate eventually results in an error
+- Added enough.c (calculation of ENOUGH for inftrees.h) to examples/
+- Update ENOUGH and its usage to reflect discovered bounds
+- Fix gzerror() error report on empty input file [Brown]
+- Add ush casts in trees.c to avoid pedantic runtime errors
+- Fix typo in zlib.h uncompress() description [Reiss]
+- Correct inflate() comments with regard to automatic header detection
+- Remove deprecation comment on Z_PARTIAL_FLUSH (it stays)
+- Put new version of gzlog (2.0) in examples with interruption recovery
+- Add puff compile option to permit invalid distance-too-far streams
+- Add puff TEST command options, ability to read piped input
+- Prototype the *64 functions in zlib.h when _FILE_OFFSET_BITS == 64, but
+  _LARGEFILE64_SOURCE not defined
+- Fix Z_FULL_FLUSH to truly erase the past by resetting s->strstart
+- Fix deflateSetDictionary() to use all 32K for output consistency
+- Remove extraneous #define MIN_LOOKAHEAD in deflate.c (in deflate.h)
+- Clear bytes after deflate lookahead to avoid use of uninitialized data
+- Change a limit in inftrees.c to be more transparent to Coverity Prevent
+- Update win32/zlib.def with exported symbols from zlib.h
+- Correct spelling errors in zlib.h [Willem, Sobrado]
+- Allow Z_BLOCK for deflate() to force a new block
+- Allow negative bits in inflatePrime() to delete existing bit buffer
+- Add Z_TREES flush option to inflate() to return at end of trees
+- Add inflateMark() to return current state information for random access
+- Add Makefile for NintendoDS to contrib [Costa]
+- Add -w in configure compile tests to avoid spurious warnings [Beucler]
+- Fix typos in zlib.h comments for deflateSetDictionary()
+- Fix EOF detection in transparent gzread() [Maier]
+
+Changes in 1.2.3.3 (2 October 2006)
+- Make --shared the default for configure, add a --static option
+- Add compile option to permit invalid distance-too-far streams
+- Add inflateUndermine() function which is required to enable above
+- Remove use of "this" variable name for C++ compatibility [Marquess]
+- Add testing of shared library in make test, if shared library built
+- Use ftello() and fseeko() if available instead of ftell() and fseek()
+- Provide two versions of all functions that use the z_off_t type for
+  binary compatibility -- a normal version and a 64-bit offset version,
+  per the Large File Support Extension when _LARGEFILE64_SOURCE is
+  defined; use the 64-bit versions by default when _FILE_OFFSET_BITS
+  is defined to be 64
+- Add a --uname= option to configure to perhaps help with cross-compiling
+
+Changes in 1.2.3.2 (3 September 2006)
+- Turn off silly Borland warnings [Hay]
+- Use off64_t and define _LARGEFILE64_SOURCE when present
+- Fix missing dependency on inffixed.h in Makefile.in
+- Rig configure --shared to build both shared and static [Teredesai, Truta]
+- Remove zconf.in.h and instead create a new zlibdefs.h file
+- Fix contrib/minizip/unzip.c non-encrypted after encrypted [Vollant]
+- Add treebuild.xml (see http://treebuild.metux.de/) [Weigelt]
+
+Changes in 1.2.3.1 (16 August 2006)
+- Add watcom directory with OpenWatcom make files [Daniel]
+- Remove #undef of FAR in zconf.in.h for MVS [Fedtke]
+- Update make_vms.com [Zinser]
+- Use -fPIC for shared build in configure [Teredesai, Nicholson]
+- Use only major version number for libz.so on IRIX and OSF1 [Reinholdtsen]
+- Use fdopen() (not _fdopen()) for Interix in zutil.h [Bck]
+- Add some FAQ entries about the contrib directory
+- Update the MVS question in the FAQ
+- Avoid extraneous reads after EOF in gzio.c [Brown]
+- Correct spelling of "successfully" in gzio.c [Randers-Pehrson]
+- Add comments to zlib.h about gzerror() usage [Brown]
+- Set extra flags in gzip header in gzopen() like deflate() does
+- Make configure options more compatible with double-dash conventions
+  [Weigelt]
+- Clean up compilation under Solaris SunStudio cc [Rowe, Reinholdtsen]
+- Fix uninstall target in Makefile.in [Truta]
+- Add pkgconfig support [Weigelt]
+- Use $(DESTDIR) macro in Makefile.in [Reinholdtsen, Weigelt]
+- Replace set_data_type() with a more accurate detect_data_type() in
+  trees.c, according to the txtvsbin.txt document [Truta]
+- Swap the order of #include <stdio.h> and #include "zlib.h" in
+  gzio.c, example.c and minigzip.c [Truta]
+- Shut up annoying VS2005 warnings about standard C deprecation [Rowe,
+  Truta] (where?)
+- Fix target "clean" from win32/Makefile.bor [Truta]
+- Create .pdb and .manifest files in win32/makefile.msc [Ziegler, Rowe]
+- Update zlib www home address in win32/DLL_FAQ.txt [Truta]
+- Update contrib/masmx86/inffas32.asm for VS2005 [Vollant, Van Wassenhove]
+- Enable browse info in the "Debug" and "ASM Debug" configurations in
+  the Visual C++ 6 project, and set (non-ASM) "Debug" as default [Truta]
+- Add pkgconfig support [Weigelt]
+- Add ZLIB_VER_MAJOR, ZLIB_VER_MINOR and ZLIB_VER_REVISION in zlib.h,
+  for use in win32/zlib1.rc [Polushin, Rowe, Truta]
+- Add a document that explains the new text detection scheme to
+  doc/txtvsbin.txt [Truta]
+- Add rfc1950.txt, rfc1951.txt and rfc1952.txt to doc/ [Truta]
+- Move algorithm.txt into doc/ [Truta]
+- Synchronize FAQ with website
+- Fix compressBound(), was low for some pathological cases [Fearnley]
+- Take into account wrapper variations in deflateBound()
+- Set examples/zpipe.c input and output to binary mode for Windows
+- Update examples/zlib_how.html with new zpipe.c (also web site)
+- Fix some warnings in examples/gzlog.c and examples/zran.c (it seems
+  that gcc became pickier in 4.0)
+- Add zlib.map for Linux: "All symbols from zlib-1.1.4 remain
+  un-versioned, the patch adds versioning only for symbols introduced in
+  zlib-1.2.0 or later.  It also declares as local those symbols which are
+  not designed to be exported." [Levin]
+- Update Z_PREFIX list in zconf.in.h, add --zprefix option to configure
+- Do not initialize global static by default in trees.c, add a response
+  NO_INIT_GLOBAL_POINTERS to initialize them if needed [Marquess]
+- Don't use strerror() in gzio.c under WinCE [Yakimov]
+- Don't use errno.h in zutil.h under WinCE [Yakimov]
+- Move arguments for AR to its usage to allow replacing ar [Marot]
+- Add HAVE_VISIBILITY_PRAGMA in zconf.in.h for Mozilla [Randers-Pehrson]
+- Improve inflateInit() and inflateInit2() documentation
+- Fix structure size comment in inflate.h
+- Change configure help option from --h* to --help [Santos]
+
 Changes in 1.2.3 (18 July 2005)
 - Apply security vulnerability fixes to contrib/infback9 as well
 - Clean up some text files (carriage returns, trailing space)
 - Update testzlib, vstudio, masmx64, and masmx86 in contrib [Vollant]
 
 Changes in 1.2.2.4 (11 July 2005)
 - Add inflatePrime() function for starting inflation at bit boundary
 - Avoid some Visual C warnings in deflate.c
 - Avoid more silly Visual C warnings in inflate.c and inftrees.c for 64-bit
   compile
 - Fix some spelling errors in comments [Betts]
 - Correct inflateInit2() error return documentation in zlib.h
-- Added zran.c example of compressed data random access to examples
+- Add zran.c example of compressed data random access to examples
   directory, shows use of inflatePrime()
 - Fix cast for assignments to strm->state in inflate.c and infback.c
 - Fix zlibCompileFlags() in zutil.c to use 1L for long shifts [Oberhumer]
 - Move declarations of gf2 functions to right place in crc32.c [Oberhumer]
 - Add cast in trees.c t avoid a warning [Oberhumer]
 - Avoid some warnings in fitblk.c, gun.c, gzjoin.c in examples [Oberhumer]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/compress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/compress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/compress.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/compress.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* compress.c -- compress a memory buffer
- * Copyright (C) 1995-2003 Jean-loup Gailly.
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* @(#) $Id$ */
 
 #define ZLIB_INTERNAL
@@ -26,13 +26,13 @@
     uLong sourceLen;
     int level;
 {
     z_stream stream;
     int err;
 
-    stream.next_in = (Bytef*)source;
+    stream.next_in = (z_const Bytef *)source;
     stream.avail_in = (uInt)sourceLen;
 #ifdef MAXSEG_64K
     /* Check for source > 64K on 16-bit machine: */
     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
 #endif
     stream.next_out = dest;
@@ -72,8 +72,9 @@
      If the default memLevel or windowBits for deflateInit() is changed, then
    this function needs to be updated.
  */
 uLong ZEXPORT compressBound (sourceLen)
     uLong sourceLen;
 {
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + 11;
+    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
+           (sourceLen >> 25) + 13;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/crc32.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/crc32.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/crc32.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/crc32.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-2005 Mark Adler
+ * Copyright (C) 1995-2006, 2010, 2011, 2012 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  *
  * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
  * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
  * tables for updating the shift register in one step with three exclusive-ors
  * instead of four steps with four exclusive-ors.  This results in about a
@@ -14,12 +14,14 @@
 /*
   Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
   protection on the static variables used to control the first-use generation
   of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
   first call get_crc_table() to initialize the tables before allowing more than
   one thread to use crc32().
+
+  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
  */
 
 #ifdef MAKECRCH
 #  include <stdio.h>
 #  ifndef DYNAMIC_CRC_TABLE
 #    define DYNAMIC_CRC_TABLE
@@ -27,37 +29,17 @@
 #endif /* MAKECRCH */
 
 #include "zutil.h"      /* for STDC and FAR definitions */
 
 #define local static
 
-/* Find a four-byte integer type for crc32_little() and crc32_big(). */
-#ifndef NOBYFOUR
-#  ifdef STDC           /* need ANSI C limits.h to determine sizes */
-#    include <limits.h>
-#    define BYFOUR
-#    if (UINT_MAX == 0xffffffffUL)
-       typedef unsigned int u4;
-#    else
-#      if (ULONG_MAX == 0xffffffffUL)
-         typedef unsigned long u4;
-#      else
-#        if (USHRT_MAX == 0xffffffffUL)
-           typedef unsigned short u4;
-#        else
-#          undef BYFOUR     /* can't find a four-byte integer type! */
-#        endif
-#      endif
-#    endif
-#  endif /* STDC */
-#endif /* !NOBYFOUR */
-
 /* Definitions for doing the crc four data bytes at a time. */
+#if !defined(NOBYFOUR) && defined(Z_U4)
+#  define BYFOUR
+#endif
 #ifdef BYFOUR
-#  define REV(w) (((w)>>24)+(((w)>>8)&0xff00)+ \
-                (((w)&0xff00)<<8)+(((w)&0xff)<<24))
    local unsigned long crc32_little OF((unsigned long,
                         const unsigned char FAR *, unsigned));
    local unsigned long crc32_big OF((unsigned long,
                         const unsigned char FAR *, unsigned));
 #  define TBLS 8
 #else
@@ -65,20 +47,22 @@
 #endif /* BYFOUR */
 
 /* Local functions for crc concatenation */
 local unsigned long gf2_matrix_times OF((unsigned long *mat,
                                          unsigned long vec));
 local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
+local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));
+
 
 #ifdef DYNAMIC_CRC_TABLE
 
 local volatile int crc_table_empty = 1;
-local unsigned long FAR crc_table[TBLS][256];
+local z_crc_t FAR crc_table[TBLS][256];
 local void make_crc_table OF((void));
 #ifdef MAKECRCH
-   local void write_table OF((FILE *, const unsigned long FAR *));
+   local void write_table OF((FILE *, const z_crc_t FAR *));
 #endif /* MAKECRCH */
 /*
   Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
 
   Polynomials over GF(2) are represented in binary, one bit per coefficient,
@@ -102,48 +86,48 @@
   combinations of CRC register values and incoming bytes.  The remaining tables
   allow for word-at-a-time CRC calculation for both big-endian and little-
   endian machines, where a word is four bytes.
 */
 local void make_crc_table()
 {
-    unsigned long c;
+    z_crc_t c;
     int n, k;
-    unsigned long poly;                 /* polynomial exclusive-or pattern */
+    z_crc_t poly;                       /* polynomial exclusive-or pattern */
     /* terms of polynomial defining this crc (except x^32): */
     static volatile int first = 1;      /* flag to limit concurrent making */
     static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
 
     /* See if another task is already doing this (not thread-safe, but better
        than nothing -- significantly reduces duration of vulnerability in
        case the advice about DYNAMIC_CRC_TABLE is ignored) */
     if (first) {
         first = 0;
 
         /* make exclusive-or pattern from polynomial (0xedb88320UL) */
-        poly = 0UL;
-        for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)
-            poly |= 1UL << (31 - p[n]);
+        poly = 0;
+        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
+            poly |= (z_crc_t)1 << (31 - p[n]);
 
         /* generate a crc for every 8-bit value */
         for (n = 0; n < 256; n++) {
-            c = (unsigned long)n;
+            c = (z_crc_t)n;
             for (k = 0; k < 8; k++)
                 c = c & 1 ? poly ^ (c >> 1) : c >> 1;
             crc_table[0][n] = c;
         }
 
 #ifdef BYFOUR
         /* generate crc for each value followed by one, two, and three zeros,
            and then the byte reversal of those as well as the first table */
         for (n = 0; n < 256; n++) {
             c = crc_table[0][n];
-            crc_table[4][n] = REV(c);
+            crc_table[4][n] = ZSWAP32(c);
             for (k = 1; k < 4; k++) {
                 c = crc_table[0][c & 0xff] ^ (c >> 8);
                 crc_table[k][n] = c;
-                crc_table[k + 4][n] = REV(c);
+                crc_table[k + 4][n] = ZSWAP32(c);
             }
         }
 #endif /* BYFOUR */
 
         crc_table_empty = 0;
     }
@@ -159,13 +143,13 @@
         FILE *out;
 
         out = fopen("crc32.h", "w");
         if (out == NULL) return;
         fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
         fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
-        fprintf(out, "local const unsigned long FAR ");
+        fprintf(out, "local const z_crc_t FAR ");
         fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
         write_table(out, crc_table[0]);
 #  ifdef BYFOUR
         fprintf(out, "#ifdef BYFOUR\n");
         for (k = 1; k < 8; k++) {
             fprintf(out, "  },\n  {\n");
@@ -179,18 +163,19 @@
 #endif /* MAKECRCH */
 }
 
 #ifdef MAKECRCH
 local void write_table(out, table)
     FILE *out;
-    const unsigned long FAR *table;
+    const z_crc_t FAR *table;
 {
     int n;
 
     for (n = 0; n < 256; n++)
-        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ", table[n],
+        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
+                (unsigned long)(table[n]),
                 n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
 }
 #endif /* MAKECRCH */
 
 #else /* !DYNAMIC_CRC_TABLE */
 /* ========================================================================
@@ -199,41 +184,41 @@
 #include "crc32.h"
 #endif /* DYNAMIC_CRC_TABLE */
 
 /* =========================================================================
  * This function can be used by asm versions of crc32()
  */
-const unsigned long FAR * ZEXPORT get_crc_table()
+const z_crc_t FAR * ZEXPORT get_crc_table()
 {
 #ifdef DYNAMIC_CRC_TABLE
     if (crc_table_empty)
         make_crc_table();
 #endif /* DYNAMIC_CRC_TABLE */
-    return (const unsigned long FAR *)crc_table;
+    return (const z_crc_t FAR *)crc_table;
 }
 
 /* ========================================================================= */
 #define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
 #define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
 
 /* ========================================================================= */
 unsigned long ZEXPORT crc32(crc, buf, len)
     unsigned long crc;
     const unsigned char FAR *buf;
-    unsigned len;
+    uInt len;
 {
     if (buf == Z_NULL) return 0UL;
 
 #ifdef DYNAMIC_CRC_TABLE
     if (crc_table_empty)
         make_crc_table();
 #endif /* DYNAMIC_CRC_TABLE */
 
 #ifdef BYFOUR
     if (sizeof(void *) == sizeof(ptrdiff_t)) {
-        u4 endian;
+        z_crc_t endian;
 
         endian = 1;
         if (*((unsigned char *)(&endian)))
             return crc32_little(crc, buf, len);
         else
             return crc32_big(crc, buf, len);
@@ -261,23 +246,23 @@
 /* ========================================================================= */
 local unsigned long crc32_little(crc, buf, len)
     unsigned long crc;
     const unsigned char FAR *buf;
     unsigned len;
 {
-    register u4 c;
-    register const u4 FAR *buf4;
+    register z_crc_t c;
+    register const z_crc_t FAR *buf4;
 
-    c = (u4)crc;
+    c = (z_crc_t)crc;
     c = ~c;
     while (len && ((ptrdiff_t)buf & 3)) {
         c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
         len--;
     }
 
-    buf4 = (const u4 FAR *)(const void FAR *)buf;
+    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
     while (len >= 32) {
         DOLIT32;
         len -= 32;
     }
     while (len >= 4) {
         DOLIT4;
@@ -301,23 +286,23 @@
 /* ========================================================================= */
 local unsigned long crc32_big(crc, buf, len)
     unsigned long crc;
     const unsigned char FAR *buf;
     unsigned len;
 {
-    register u4 c;
-    register const u4 FAR *buf4;
+    register z_crc_t c;
+    register const z_crc_t FAR *buf4;
 
-    c = REV((u4)crc);
+    c = ZSWAP32((z_crc_t)crc);
     c = ~c;
     while (len && ((ptrdiff_t)buf & 3)) {
         c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
         len--;
     }
 
-    buf4 = (const u4 FAR *)(const void FAR *)buf;
+    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
     buf4--;
     while (len >= 32) {
         DOBIG32;
         len -= 32;
     }
     while (len >= 4) {
@@ -328,13 +313,13 @@
     buf = (const unsigned char FAR *)buf4;
 
     if (len) do {
         c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
     } while (--len);
     c = ~c;
-    return (unsigned long)(REV(c));
+    return (unsigned long)(ZSWAP32(c));
 }
 
 #endif /* BYFOUR */
 
 #define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
 
@@ -364,28 +349,28 @@
 
     for (n = 0; n < GF2_DIM; n++)
         square[n] = gf2_matrix_times(mat, mat[n]);
 }
 
 /* ========================================================================= */
-uLong ZEXPORT crc32_combine(crc1, crc2, len2)
+local uLong crc32_combine_(crc1, crc2, len2)
     uLong crc1;
     uLong crc2;
-    z_off_t len2;
+    z_off64_t len2;
 {
     int n;
     unsigned long row;
     unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
     unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
 
-    /* degenerate case */
-    if (len2 == 0)
+    /* degenerate case (also disallow negative lengths) */
+    if (len2 <= 0)
         return crc1;
 
     /* put operator for one zero bit in odd */
-    odd[0] = 0xedb88320L;           /* CRC-32 polynomial */
+    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
     row = 1;
     for (n = 1; n < GF2_DIM; n++) {
         odd[n] = row;
         row <<= 1;
     }
 
@@ -418,6 +403,23 @@
     } while (len2 != 0);
 
     /* return combined crc */
     crc1 ^= crc2;
     return crc1;
 }
+
+/* ========================================================================= */
+uLong ZEXPORT crc32_combine(crc1, crc2, len2)
+    uLong crc1;
+    uLong crc2;
+    z_off_t len2;
+{
+    return crc32_combine_(crc1, crc2, len2);
+}
+
+uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
+    uLong crc1;
+    uLong crc2;
+    z_off64_t len2;
+{
+    return crc32_combine_(crc1, crc2, len2);
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/crc32.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/crc32.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/crc32.h	2005-07-08 04:48:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/crc32.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,11 +1,11 @@
 /* crc32.h -- tables for rapid CRC calculation
  * Generated automatically by crc32.c
  */
 
-local const unsigned long FAR crc_table[TBLS][256] =
+local const z_crc_t FAR crc_table[TBLS][256] =
 {
   {
     0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
     0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
     0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
     0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/deflate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/deflate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/deflate.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/deflate.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /*
  *  ALGORITHM
  *
@@ -34,13 +34,13 @@
  *      I found it in 'freeze' written by Leonid Broukhis.
  *      Thanks to many people for bug reports and testing.
  *
  *  REFERENCES
  *
  *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in http://www.ietf.org/rfc/rfc1951.txt
+ *      Available in http://tools.ietf.org/html/rfc1951
  *
  *      A description of the Rabin and Karp algorithm is given in the book
  *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
  *
  *      Fiala,E.R., and Greene,D.H.
  *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
@@ -51,13 +51,13 @@
 
 #include "deflate.h"
 
 #define read_buf dread_buf
 
 const char deflate_copyright[] =
-   " deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly ";
+   " deflate 1.2.8 Copyright 1995-2013 Jean-loup Gailly and Mark Adler ";
 /*
   If you use the zlib library in a product, an acknowledgment is welcome
   in the documentation of your product. If for some reason you cannot
   include such an acknowledgment, I would appreciate that you keep this
   copyright string in the executable of your product.
  */
@@ -78,25 +78,24 @@
 local void fill_window    OF((deflate_state *s));
 local block_state deflate_stored OF((deflate_state *s, int flush));
 local block_state deflate_fast   OF((deflate_state *s, int flush));
 #ifndef FASTEST
 local block_state deflate_slow   OF((deflate_state *s, int flush));
 #endif
+local block_state deflate_rle    OF((deflate_state *s, int flush));
+local block_state deflate_huff   OF((deflate_state *s, int flush));
 local void lm_init        OF((deflate_state *s));
 local void putShortMSB    OF((deflate_state *s, uInt b));
 local void flush_pending  OF((z_streamp strm));
 local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
-#ifndef FASTEST
 #ifdef ASMV
       void match_init OF((void)); /* asm code initialization */
       uInt longest_match  OF((deflate_state *s, IPos cur_match));
 #else
 local uInt longest_match  OF((deflate_state *s, IPos cur_match));
 #endif
-#endif
-local uInt longest_match_fast OF((deflate_state *s, IPos cur_match));
 
 #ifdef DEBUG
 local  void check_match OF((deflate_state *s, IPos start, IPos match,
                             int length));
 #endif
 
@@ -109,17 +108,12 @@
 
 #ifndef TOO_FAR
 #  define TOO_FAR 4096
 #endif
 /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
 
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
 /* Values for max_lazy_match, good_match and max_chain_length, depending on
  * the desired pack level (0..9). The values given below have been tuned to
  * exclude worst case performance for pathological files. Better values may be
  * found for specific files.
  */
 typedef struct config_s {
@@ -160,12 +154,15 @@
 /* result of memcmp for equal strings */
 
 #ifndef NO_DUMMY_DECL
 struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
 #endif
 
+/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
+#define RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))
+
 /* ===========================================================================
  * Update a hash value with the given input byte
  * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
  *    input characters, so that a running hash key can be computed from the
  *    previous key instead of complete recalculation each time.
  */
@@ -240,16 +237,25 @@
         return Z_VERSION_ERROR;
     }
     if (strm == Z_NULL) return Z_STREAM_ERROR;
 
     strm->msg = Z_NULL;
     if (strm->zalloc == (alloc_func)0) {
+#ifdef Z_SOLO
+        return Z_STREAM_ERROR;
+#else
         strm->zalloc = zcalloc;
         strm->opaque = (voidpf)0;
+#endif
     }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
+    if (strm->zfree == (free_func)0)
+#ifdef Z_SOLO
+        return Z_STREAM_ERROR;
+#else
+        strm->zfree = zcfree;
+#endif
 
 #ifdef FASTEST
     if (level != 0) level = 1;
 #else
     if (level == Z_DEFAULT_COMPRESSION) level = 6;
 #endif
@@ -287,22 +293,24 @@
     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
 
     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
 
+    s->high_water = 0;      /* nothing written to s->window yet */
+
     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
 
     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
     s->pending_buf = (uchf *) overlay;
     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
 
     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
         s->pending_buf == Z_NULL) {
         s->status = FINISH_STATE;
-        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
+        strm->msg = ERR_MSG(Z_MEM_ERROR);
         deflateEnd (strm);
         return Z_MEM_ERROR;
     }
     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
 
@@ -317,49 +325,76 @@
 int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
     z_streamp strm;
     const Bytef *dictionary;
     uInt  dictLength;
 {
     deflate_state *s;
-    uInt length = dictLength;
-    uInt n;
-    IPos hash_head = 0;
-
-    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
-        strm->state->wrap == 2 ||
-        (strm->state->wrap == 1 && strm->state->status != INIT_STATE))
-        return Z_STREAM_ERROR;
+    uInt str, n;
+    int wrap;
+    unsigned avail;
+    z_const unsigned char *next;
 
+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
+        return Z_STREAM_ERROR;
     s = strm->state;
-    if (s->wrap)
+    wrap = s->wrap;
+    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
+        return Z_STREAM_ERROR;
+
+    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
+    if (wrap == 1)
         strm->adler = adler32(strm->adler, dictionary, dictLength);
+    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
 
-    if (length < MIN_MATCH) return Z_OK;
-    if (length > MAX_DIST(s)) {
-        length = MAX_DIST(s);
-        dictionary += dictLength - length; /* use the tail of the dictionary */
-    }
-    zmemcpy(s->window, dictionary, length);
-    s->strstart = length;
-    s->block_start = (long)length;
-
-    /* Insert all strings in the hash table (except for the last two bytes).
-     * s->lookahead stays null, so s->ins_h will be recomputed at the next
-     * call of fill_window.
-     */
-    s->ins_h = s->window[0];
-    UPDATE_HASH(s, s->ins_h, s->window[1]);
-    for (n = 0; n <= length - MIN_MATCH; n++) {
-        INSERT_STRING(s, n, hash_head);
-    }
-    if (hash_head) hash_head = 0;  /* to make compiler happy */
+    /* if dictionary would fill window, just replace the history */
+    if (dictLength >= s->w_size) {
+        if (wrap == 0) {            /* already empty otherwise */
+            CLEAR_HASH(s);
+            s->strstart = 0;
+            s->block_start = 0L;
+            s->insert = 0;
+        }
+        dictionary += dictLength - s->w_size;  /* use the tail */
+        dictLength = s->w_size;
+    }
+
+    /* insert dictionary into window and hash */
+    avail = strm->avail_in;
+    next = strm->next_in;
+    strm->avail_in = dictLength;
+    strm->next_in = (z_const Bytef *)dictionary;
+    fill_window(s);
+    while (s->lookahead >= MIN_MATCH) {
+        str = s->strstart;
+        n = s->lookahead - (MIN_MATCH-1);
+        do {
+            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
+#ifndef FASTEST
+            s->prev[str & s->w_mask] = s->head[s->ins_h];
+#endif
+            s->head[s->ins_h] = (Pos)str;
+            str++;
+        } while (--n);
+        s->strstart = str;
+        s->lookahead = MIN_MATCH-1;
+        fill_window(s);
+    }
+    s->strstart += s->lookahead;
+    s->block_start = (long)s->strstart;
+    s->insert = s->lookahead;
+    s->lookahead = 0;
+    s->match_length = s->prev_length = MIN_MATCH-1;
+    s->match_available = 0;
+    strm->next_in = next;
+    strm->avail_in = avail;
+    s->wrap = wrap;
     return Z_OK;
 }
 
 /* ========================================================================= */
-int ZEXPORT deflateReset (strm)
+int ZEXPORT deflateResetKeep (strm)
     z_streamp strm;
 {
     deflate_state *s;
 
     if (strm == Z_NULL || strm->state == Z_NULL ||
         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
@@ -383,37 +418,76 @@
         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
 #endif
         adler32(0L, Z_NULL, 0);
     s->last_flush = Z_NO_FLUSH;
 
     _tr_init(s);
-    lm_init(s);
 
     return Z_OK;
 }
 
 /* ========================================================================= */
+int ZEXPORT deflateReset (strm)
+    z_streamp strm;
+{
+    int ret;
+
+    ret = deflateResetKeep(strm);
+    if (ret == Z_OK)
+        lm_init(strm->state);
+    return ret;
+}
+
+/* ========================================================================= */
 int ZEXPORT deflateSetHeader (strm, head)
     z_streamp strm;
     gz_headerp head;
 {
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     if (strm->state->wrap != 2) return Z_STREAM_ERROR;
     strm->state->gzhead = head;
     return Z_OK;
 }
 
 /* ========================================================================= */
+int ZEXPORT deflatePending (strm, pending, bits)
+    unsigned *pending;
+    int *bits;
+    z_streamp strm;
+{
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    if (pending != Z_NULL)
+        *pending = strm->state->pending;
+    if (bits != Z_NULL)
+        *bits = strm->state->bi_valid;
+    return Z_OK;
+}
+
+/* ========================================================================= */
 int ZEXPORT deflatePrime (strm, bits, value)
     z_streamp strm;
     int bits;
     int value;
 {
+    deflate_state *s;
+    int put;
+
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    strm->state->bi_valid = bits;
-    strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));
+    s = strm->state;
+    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
+        return Z_BUF_ERROR;
+    do {
+        put = Buf_size - s->bi_valid;
+        if (put > bits)
+            put = bits;
+        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
+        s->bi_valid += put;
+        _tr_flush_bits(s);
+        value >>= put;
+        bits -= put;
+    } while (bits);
     return Z_OK;
 }
 
 /* ========================================================================= */
 int ZEXPORT deflateParams(strm, level, strategy)
     z_streamp strm;
@@ -434,15 +508,18 @@
 #endif
     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
         return Z_STREAM_ERROR;
     }
     func = configuration_table[s->level].func;
 
-    if (func != configuration_table[level].func && strm->total_in != 0) {
+    if ((strategy != s->strategy || func != configuration_table[level].func) &&
+        strm->total_in != 0) {
         /* Flush the last buffer: */
-        err = deflate(strm, Z_PARTIAL_FLUSH);
+        err = deflate(strm, Z_BLOCK);
+        if (err == Z_BUF_ERROR && s->pending == 0)
+            err = Z_OK;
     }
     if (s->level != level) {
         s->level = level;
         s->max_lazy_match   = configuration_table[level].max_lazy;
         s->good_match       = configuration_table[level].good_length;
         s->nice_match       = configuration_table[level].nice_length;
@@ -480,39 +557,72 @@
  *
  * For any setting other than those defaults for windowBits and memLevel,
  * the value returned is a conservative worst case for the maximum expansion
  * resulting from using fixed blocks instead of stored blocks, which deflate
  * can emit on compressed data for some combinations of the parameters.
  *
- * This function could be more sophisticated to provide closer upper bounds
- * for every combination of windowBits and memLevel, as well as wrap.
- * But even the conservative upper bound of about 14% expansion does not
- * seem onerous for output buffer allocation.
+ * This function could be more sophisticated to provide closer upper bounds for
+ * every combination of windowBits and memLevel.  But even the conservative
+ * upper bound of about 14% expansion does not seem onerous for output buffer
+ * allocation.
  */
 uLong ZEXPORT deflateBound(strm, sourceLen)
     z_streamp strm;
     uLong sourceLen;
 {
     deflate_state *s;
-    uLong destLen;
+    uLong complen, wraplen;
+    Bytef *str;
 
-    /* conservative upper bound */
-    destLen = sourceLen +
-              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 11;
+    /* conservative upper bound for compressed data */
+    complen = sourceLen +
+              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
 
-    /* if can't get parameters, return conservative bound */
+    /* if can't get parameters, return conservative bound plus zlib wrapper */
     if (strm == Z_NULL || strm->state == Z_NULL)
-        return destLen;
+        return complen + 6;
 
-    /* if not default parameters, return conservative bound */
+    /* compute wrapper length */
     s = strm->state;
+    switch (s->wrap) {
+    case 0:                                 /* raw deflate */
+        wraplen = 0;
+        break;
+    case 1:                                 /* zlib wrapper */
+        wraplen = 6 + (s->strstart ? 4 : 0);
+        break;
+    case 2:                                 /* gzip wrapper */
+        wraplen = 18;
+        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
+            if (s->gzhead->extra != Z_NULL)
+                wraplen += 2 + s->gzhead->extra_len;
+            str = s->gzhead->name;
+            if (str != Z_NULL)
+                do {
+                    wraplen++;
+                } while (*str++);
+            str = s->gzhead->comment;
+            if (str != Z_NULL)
+                do {
+                    wraplen++;
+                } while (*str++);
+            if (s->gzhead->hcrc)
+                wraplen += 2;
+        }
+        break;
+    default:                                /* for compiler happiness */
+        wraplen = 6;
+    }
+
+    /* if not default parameters, return conservative bound */
     if (s->w_bits != 15 || s->hash_bits != 8 + 7)
-        return destLen;
+        return complen + wraplen;
 
     /* default settings: return tight bound for that case */
-    return compressBound(sourceLen);
+    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
+           (sourceLen >> 25) + 13 - 6 + wraplen;
 }
 
 /* =========================================================================
  * Put a short in the pending buffer. The 16-bit value is put in MSB order.
  * IN assertion: the stream state is correct and there is enough room in
  * pending_buf.
@@ -531,38 +641,41 @@
  * to avoid allocating a large strm->next_out buffer and copying into it.
  * (See also read_buf()).
  */
 local void flush_pending(strm)
     z_streamp strm;
 {
-    unsigned len = strm->state->pending;
+    unsigned len;
+    deflate_state *s = strm->state;
 
+    _tr_flush_bits(s);
+    len = s->pending;
     if (len > strm->avail_out) len = strm->avail_out;
     if (len == 0) return;
 
-    zmemcpy(strm->next_out, strm->state->pending_out, len);
+    zmemcpy(strm->next_out, s->pending_out, len);
     strm->next_out  += len;
-    strm->state->pending_out  += len;
+    s->pending_out  += len;
     strm->total_out += len;
     strm->avail_out  -= len;
-    strm->state->pending -= len;
-    if (strm->state->pending == 0) {
-        strm->state->pending_out = strm->state->pending_buf;
+    s->pending -= len;
+    if (s->pending == 0) {
+        s->pending_out = s->pending_buf;
     }
 }
 
 /* ========================================================================= */
 int ZEXPORT deflate (strm, flush)
     z_streamp strm;
     int flush;
 {
     int old_flush; /* value of flush param for previous deflate call */
     deflate_state *s;
 
     if (strm == Z_NULL || strm->state == Z_NULL ||
-        flush > Z_INSERT_ONLY || flush < 0) {
+        (flush > Z_BLOCK && flush != Z_INSERT_ONLY) || flush < 0) {
         return Z_STREAM_ERROR;
     }
     s = strm->state;
 
     if (strm->next_out == Z_NULL ||
         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
@@ -580,13 +693,13 @@
 #ifdef GZIP
         if (s->wrap == 2) {
             strm->adler = crc32(0L, Z_NULL, 0);
             put_byte(s, 31);
             put_byte(s, 139);
             put_byte(s, 8);
-            if (s->gzhead == NULL) {
+            if (s->gzhead == Z_NULL) {
                 put_byte(s, 0);
                 put_byte(s, 0);
                 put_byte(s, 0);
                 put_byte(s, 0);
                 put_byte(s, 0);
                 put_byte(s, s->level == 9 ? 2 :
@@ -607,13 +720,13 @@
                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
                 put_byte(s, s->level == 9 ? 2 :
                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                              4 : 0));
                 put_byte(s, s->gzhead->os & 0xff);
-                if (s->gzhead->extra != NULL) {
+                if (s->gzhead->extra != Z_NULL) {
                     put_byte(s, s->gzhead->extra_len & 0xff);
                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
                 }
                 if (s->gzhead->hcrc)
                     strm->adler = crc32(strm->adler, s->pending_buf,
                                         s->pending);
@@ -649,13 +762,13 @@
             }
             strm->adler = adler32(0L, Z_NULL, 0);
         }
     }
 #ifdef GZIP
     if (s->status == EXTRA_STATE) {
-        if (s->gzhead->extra != NULL) {
+        if (s->gzhead->extra != Z_NULL) {
             uInt beg = s->pending;  /* start of bytes to update crc */
 
             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
                 if (s->pending == s->pending_buf_size) {
                     if (s->gzhead->hcrc && s->pending > beg)
                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
@@ -677,13 +790,13 @@
             }
         }
         else
             s->status = NAME_STATE;
     }
     if (s->status == NAME_STATE) {
-        if (s->gzhead->name != NULL) {
+        if (s->gzhead->name != Z_NULL) {
             uInt beg = s->pending;  /* start of bytes to update crc */
             int val;
 
             do {
                 if (s->pending == s->pending_buf_size) {
                     if (s->gzhead->hcrc && s->pending > beg)
@@ -708,13 +821,13 @@
             }
         }
         else
             s->status = COMMENT_STATE;
     }
     if (s->status == COMMENT_STATE) {
-        if (s->gzhead->comment != NULL) {
+        if (s->gzhead->comment != Z_NULL) {
             uInt beg = s->pending;  /* start of bytes to update crc */
             int val;
 
             do {
                 if (s->pending == s->pending_buf_size) {
                     if (s->gzhead->hcrc && s->pending > beg)
@@ -770,13 +883,13 @@
         }
 
     /* Make sure there is something to do and avoid duplicate consecutive
      * flushes. For repeated and useless calls with Z_FINISH, we keep
      * returning Z_STREAM_END instead of Z_BUF_ERROR.
      */
-    } else if (strm->avail_in == 0 && flush <= old_flush &&
+    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
                flush != Z_FINISH) {
         ERR_RETURN(strm, Z_BUF_ERROR);
     }
 
     /* User must not provide more input after the first FINISH: */
     if (s->status == FINISH_STATE && strm->avail_in != 0) {
@@ -786,13 +899,15 @@
     /* Start a new block or continue the current one.
      */
     if (strm->avail_in != 0 || s->lookahead != 0 ||
         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
         block_state bstate;
 
-        bstate = (*(configuration_table[s->level].func))(s, flush);
+        bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
+                    (s->strategy == Z_RLE ? deflate_rle(s, flush) :
+                        (*(configuration_table[s->level].func))(s, flush));
 
         if (bstate == finish_started || bstate == finish_done) {
             s->status = FINISH_STATE;
         }
         if (bstate == need_more || bstate == finish_started) {
             if (strm->avail_out == 0) {
@@ -807,19 +922,24 @@
              * one empty block.
              */
         }
         if (bstate == block_done) {
             if (flush == Z_PARTIAL_FLUSH) {
                 _tr_align(s);
-            } else { /* FULL_FLUSH or SYNC_FLUSH */
+            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                 _tr_stored_block(s, (char*)0, 0L, 0);
                 /* For a full flush, this empty block will be recognized
                  * as a special marker by inflate_sync().
                  */
                 if (flush == Z_FULL_FLUSH) {
                     CLEAR_HASH(s);             /* forget history */
+                    if (s->lookahead == 0) {
+                        s->strstart = 0;
+                        s->block_start = 0L;
+                        s->insert = 0;
+                    }
                 }
             }
             flush_pending(strm);
             if (strm->avail_out == 0) {
               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
               return Z_OK;
@@ -908,18 +1028,18 @@
     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
         return Z_STREAM_ERROR;
     }
 
     ss = source->state;
 
-    zmemcpy(dest, source, sizeof(z_stream));
+    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
 
     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
     if (ds == Z_NULL) return Z_MEM_ERROR;
     dest->state = (struct internal_state FAR *) ds;
-    zmemcpy(ds, ss, sizeof(deflate_state));
+    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
     ds->strm = dest;
 
     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
@@ -929,14 +1049,14 @@
         ds->pending_buf == Z_NULL) {
         deflateEnd (dest);
         return Z_MEM_ERROR;
     }
     /* following zmemcpy do not work for 16-bit MSDOS */
     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
+    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
+    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
 
     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
 
@@ -964,21 +1084,21 @@
 
     if (len > size) len = size;
     if (len == 0) return 0;
 
     strm->avail_in  -= len;
 
+    zmemcpy(buf, strm->next_in, len);
     if (strm->state->wrap == 1) {
-        strm->adler = adler32(strm->adler, strm->next_in, len);
+        strm->adler = adler32(strm->adler, buf, len);
     }
 #ifdef GZIP
     else if (strm->state->wrap == 2) {
-        strm->adler = crc32(strm->adler, strm->next_in, len);
+        strm->adler = crc32(strm->adler, buf, len);
     }
 #endif
-    zmemcpy(buf, strm->next_in, len);
     strm->next_in  += len;
     strm->total_in += len;
 
     return (int)len;
 }
 
@@ -999,12 +1119,13 @@
     s->nice_match       = configuration_table[s->level].nice_length;
     s->max_chain_length = configuration_table[s->level].max_chain;
 
     s->strstart = 0;
     s->block_start = 0L;
     s->lookahead = 0;
+    s->insert = 0;
     s->match_length = s->prev_length = MIN_MATCH-1;
     s->match_available = 0;
     s->ins_h = 0;
 #ifndef FASTEST
 #ifdef ASMV
     match_init(); /* initialize the asm code */
@@ -1166,18 +1287,19 @@
              && --chain_length != 0);
 
     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
     return s->lookahead;
 }
 #endif /* ASMV */
-#endif /* FASTEST */
+
+#else /* FASTEST */
 
 /* ---------------------------------------------------------------------------
- * Optimized version for level == 1 or strategy == Z_RLE only
+ * Optimized version for FASTEST only
  */
-local uInt longest_match_fast(s, cur_match)
+local uInt longest_match(s, cur_match)
     deflate_state *s;
     IPos cur_match;                             /* current match */
 {
     register Bytef *scan = s->window + s->strstart; /* current string */
     register Bytef *match;                       /* matched string */
     register int len;                           /* length of current match */
@@ -1224,12 +1346,14 @@
     if (len < MIN_MATCH) return MIN_MATCH - 1;
 
     s->match_start = cur_match;
     return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
 }
 
+#endif /* FASTEST */
+
 #ifdef DEBUG
 /* ===========================================================================
  * Check that the match at match_start is indeed a match.
  */
 local void check_match(s, start, match, length)
     deflate_state *s;
@@ -1270,12 +1394,14 @@
 {
     register unsigned n, m;
     register Posf *p;
     unsigned more;    /* Amount of free space at the end of the window. */
     uInt wsize = s->w_size;
 
+    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
+
     do {
         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
 
         /* Deal with !@#$% 64K limit: */
         if (sizeof(int) <= 2) {
             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
@@ -1302,13 +1428,12 @@
             /* Slide the hash table (could be avoided with 32 bit values
                at the expense of memory usage). We slide even when level == 0
                to keep the hash table consistent if we switch back to level > 0
                later. (Using level 0 permanently is not an optimal usage of
                zlib, so we don't care about this pathological case.)
              */
-            /* %%% avoid this when Z_RLE */
             n = s->hash_size;
             p = &s->head[n];
             do {
                 m = *--p;
                 *p = (Pos)(m >= wsize ? m-wsize : NIL);
             } while (--n);
@@ -1323,13 +1448,13 @@
                  * its value will never be used.
                  */
             } while (--n);
 #endif
             more += wsize;
         }
-        if (s->strm->avail_in == 0) return;
+        if (s->strm->avail_in == 0) break;
 
         /* If there was no sliding:
          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
          *    more == window_size - lookahead - strstart
          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
          * => more >= window_size - 2*WSIZE + 2
@@ -1342,45 +1467,94 @@
         Assert(more >= 2, "more < 2");
 
         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
         s->lookahead += n;
 
         /* Initialize the hash value now that we have some input: */
-        if (s->lookahead >= MIN_MATCH) {
-            s->ins_h = s->window[s->strstart];
-            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+        if (s->lookahead + s->insert >= MIN_MATCH) {
+            uInt str = s->strstart - s->insert;
+            s->ins_h = s->window[str];
+            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
 #if MIN_MATCH != 3
             Call UPDATE_HASH() MIN_MATCH-3 more times
 #endif
+            while (s->insert) {
+                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
+#ifndef FASTEST
+                s->prev[str & s->w_mask] = s->head[s->ins_h];
+#endif
+                s->head[s->ins_h] = (Pos)str;
+                str++;
+                s->insert--;
+                if (s->lookahead + s->insert < MIN_MATCH)
+                    break;
+            }
         }
         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
          * but this is not important since only literal bytes will be emitted.
          */
 
     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
+
+    /* If the WIN_INIT bytes after the end of the current data have never been
+     * written, then zero those bytes in order to avoid memory check reports of
+     * the use of uninitialized (or uninitialised as Julian writes) bytes by
+     * the longest match routines.  Update the high water mark for the next
+     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
+     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
+     */
+    if (s->high_water < s->window_size) {
+        ulg curr = s->strstart + (ulg)(s->lookahead);
+        ulg init;
+
+        if (s->high_water < curr) {
+            /* Previous high water mark below current data -- zero WIN_INIT
+             * bytes or up to end of window, whichever is less.
+             */
+            init = s->window_size - curr;
+            if (init > WIN_INIT)
+                init = WIN_INIT;
+            zmemzero(s->window + curr, (unsigned)init);
+            s->high_water = curr + init;
+        }
+        else if (s->high_water < (ulg)curr + WIN_INIT) {
+            /* High water mark at or above current data, but below current data
+             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
+             * to end of window, whichever is less.
+             */
+            init = (ulg)curr + WIN_INIT - s->high_water;
+            if (init > s->window_size - s->high_water)
+                init = s->window_size - s->high_water;
+            zmemzero(s->window + s->high_water, (unsigned)init);
+            s->high_water += init;
+        }
+    }
+
+    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
+           "not enough room for search");
 }
 
 /* ===========================================================================
  * Flush the current block, with given end-of-file flag.
  * IN assertion: strstart is set to the end of the current match.
  */
-#define FLUSH_BLOCK_ONLY(s, eof) { \
+#define FLUSH_BLOCK_ONLY(s, last) { \
    _tr_flush_block(s, (s->block_start >= 0L ? \
                    (charf *)&s->window[(unsigned)s->block_start] : \
                    (charf *)Z_NULL), \
                 (ulg)((long)s->strstart - s->block_start), \
-                (eof)); \
+                (last)); \
    s->block_start = s->strstart; \
    flush_pending(s->strm); \
    Tracev((stderr,"[FLUSH]")); \
 }
 
 /* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, eof) { \
-   FLUSH_BLOCK_ONLY(s, eof); \
-   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
+#define FLUSH_BLOCK(s, last) { \
+   FLUSH_BLOCK_ONLY(s, last); \
+   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
 }
 
 /* ===========================================================================
  * Copy without compression as much as possible from the input stream, return
  * the current block state.
  * This function does not insert new strings in the dictionary since
@@ -1438,19 +1612,24 @@
          * negative and the data will be gone:
          */
         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
             FLUSH_BLOCK(s, 0);
         }
     }
+    s->insert = 0;
     if (flush == Z_INSERT_ONLY) {
 	s->block_start = s->strstart;
 	return need_more;
     }
-
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
+    if (flush == Z_FINISH) {
+        FLUSH_BLOCK(s, 1);
+        return finish_done;
+    }
+    if ((long)s->strstart > s->block_start)
+        FLUSH_BLOCK(s, 0);
+    return block_done;
 }
 
 /* ===========================================================================
  * Compress as much as possible from the input stream, return the current
  * block state.
  * This function does not perform lazy evaluation of matches and inserts
@@ -1458,13 +1637,13 @@
  * matches. It is used only for the fast compression options.
  */
 local block_state deflate_fast(s, flush)
     deflate_state *s;
     int flush;
 {
-    IPos hash_head = NIL; /* head of the hash chain */
+    IPos hash_head;       /* head of the hash chain */
     int bflush;           /* set if current block must be flushed */
 
     for (;;) {
         /* Make sure that we always have enough lookahead, except
          * at the end of the input file. We need MAX_MATCH bytes
          * for the next match, plus MIN_MATCH bytes to insert the
@@ -1478,12 +1657,13 @@
             if (s->lookahead == 0) break; /* flush the current block */
         }
 
         /* Insert the string window[strstart .. strstart+2] in the
          * dictionary, and set hash_head to the head of the hash chain:
          */
+        hash_head = NIL;
         if (s->lookahead >= MIN_MATCH) {
             INSERT_STRING(s, s->strstart, hash_head);
         }
 
 	if (flush == Z_INSERT_ONLY) {
 	    s->strstart++;
@@ -1496,25 +1676,14 @@
          */
         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
             /* To simplify the code, we prevent matches with the string
              * of window index 0 (in particular we have to avoid a match
              * of the string with itself at the start of the input file).
              */
-#ifdef FASTEST
-            if ((s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) ||
-                (s->strategy == Z_RLE && s->strstart - hash_head == 1)) {
-                s->match_length = longest_match_fast (s, hash_head);
-            }
-#else
-            if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
-                s->match_length = longest_match (s, hash_head);
-            } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
-                s->match_length = longest_match_fast (s, hash_head);
-            }
-#endif
-            /* longest_match() or longest_match_fast() sets match_start */
+            s->match_length = longest_match (s, hash_head);
+            /* longest_match() sets match_start */
         }
         if (s->match_length >= MIN_MATCH) {
             check_match(s, s->strstart, s->match_start, s->match_length);
 
             _tr_tally_dist(s, s->strstart - s->match_start,
                            s->match_length - MIN_MATCH, bflush);
@@ -1560,27 +1729,33 @@
         if (bflush) FLUSH_BLOCK(s, 0);
     }
     if (flush == Z_INSERT_ONLY) {
 	s->block_start = s->strstart;
 	return need_more;
     }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
+    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
+    if (flush == Z_FINISH) {
+        FLUSH_BLOCK(s, 1);
+        return finish_done;
+    }
+    if (s->last_lit)
+        FLUSH_BLOCK(s, 0);
+    return block_done;
 }
 
 #ifndef FASTEST
 /* ===========================================================================
  * Same as above, but achieves better compression. We use a lazy
  * evaluation for matches: a match is finally adopted only if there is
  * no better match at the next window position.
  */
 local block_state deflate_slow(s, flush)
     deflate_state *s;
     int flush;
 {
-    IPos hash_head = NIL;    /* head of hash chain */
+    IPos hash_head;          /* head of hash chain */
     int bflush;              /* set if current block must be flushed */
 
     /* Process the input block. */
     for (;;) {
         /* Make sure that we always have enough lookahead, except
          * at the end of the input file. We need MAX_MATCH bytes
@@ -1595,12 +1770,13 @@
             if (s->lookahead == 0) break; /* flush the current block */
         }
 
         /* Insert the string window[strstart .. strstart+2] in the
          * dictionary, and set hash_head to the head of the hash chain:
          */
+        hash_head = NIL;
         if (s->lookahead >= MIN_MATCH) {
             INSERT_STRING(s, s->strstart, hash_head);
         }
 
 	if (flush == Z_INSERT_ONLY) {
 	    s->strstart++;
@@ -1616,18 +1792,14 @@
         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
             s->strstart - hash_head <= MAX_DIST(s)) {
             /* To simplify the code, we prevent matches with the string
              * of window index 0 (in particular we have to avoid a match
              * of the string with itself at the start of the input file).
              */
-            if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
-                s->match_length = longest_match (s, hash_head);
-            } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
-                s->match_length = longest_match_fast (s, hash_head);
-            }
-            /* longest_match() or longest_match_fast() sets match_start */
+            s->match_length = longest_match (s, hash_head);
+            /* longest_match() sets match_start */
 
             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
 #if TOO_FAR <= 32767
                 || (s->match_length == MIN_MATCH &&
                     s->strstart - s->match_start > TOO_FAR)
 #endif
@@ -1698,71 +1870,129 @@
     Assert (flush != Z_NO_FLUSH, "no flush?");
     if (s->match_available) {
         Tracevv((stderr,"%c", s->window[s->strstart-1]));
         _tr_tally_lit(s, s->window[s->strstart-1], bflush);
         s->match_available = 0;
     }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
+    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
+    if (flush == Z_FINISH) {
+        FLUSH_BLOCK(s, 1);
+        return finish_done;
+    }
+    if (s->last_lit)
+        FLUSH_BLOCK(s, 0);
+    return block_done;
 }
 #endif /* FASTEST */
 
-#if 0
 /* ===========================================================================
  * For Z_RLE, simply look for runs of bytes, generate matches only of distance
  * one.  Do not maintain a hash table.  (It will be regenerated if this run of
  * deflate switches away from Z_RLE.)
  */
 local block_state deflate_rle(s, flush)
     deflate_state *s;
     int flush;
 {
-    int bflush;         /* set if current block must be flushed */
-    uInt run;           /* length of run */
-    uInt max;           /* maximum length of run */
-    uInt prev;          /* byte at distance one to match */
-    Bytef *scan;        /* scan for end of run */
+    int bflush;             /* set if current block must be flushed */
+    uInt prev;              /* byte at distance one to match */
+    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
 
     for (;;) {
         /* Make sure that we always have enough lookahead, except
          * at the end of the input file. We need MAX_MATCH bytes
-         * for the longest encodable run.
+         * for the longest run, plus one for the unrolled loop.
          */
-        if (s->lookahead < MAX_MATCH) {
+        if (s->lookahead <= MAX_MATCH) {
             fill_window(s);
-            if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {
+            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
                 return need_more;
             }
             if (s->lookahead == 0) break; /* flush the current block */
         }
 
         /* See how many times the previous byte repeats */
-        run = 0;
-        if (s->strstart > 0) {      /* if there is a previous byte, that is */
-            max = s->lookahead < MAX_MATCH ? s->lookahead : MAX_MATCH;
+        s->match_length = 0;
+        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
             scan = s->window + s->strstart - 1;
-            prev = *scan++;
-            do {
-                if (*scan++ != prev)
-                    break;
-            } while (++run < max);
+            prev = *scan;
+            if (prev == *++scan && prev == *++scan && prev == *++scan) {
+                strend = s->window + s->strstart + MAX_MATCH;
+                do {
+                } while (prev == *++scan && prev == *++scan &&
+                         prev == *++scan && prev == *++scan &&
+                         prev == *++scan && prev == *++scan &&
+                         prev == *++scan && prev == *++scan &&
+                         scan < strend);
+                s->match_length = MAX_MATCH - (int)(strend - scan);
+                if (s->match_length > s->lookahead)
+                    s->match_length = s->lookahead;
+            }
+            Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
         }
 
         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
-        if (run >= MIN_MATCH) {
-            check_match(s, s->strstart, s->strstart - 1, run);
-            _tr_tally_dist(s, 1, run - MIN_MATCH, bflush);
-            s->lookahead -= run;
-            s->strstart += run;
+        if (s->match_length >= MIN_MATCH) {
+            check_match(s, s->strstart, s->strstart - 1, s->match_length);
+
+            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
+
+            s->lookahead -= s->match_length;
+            s->strstart += s->match_length;
+            s->match_length = 0;
         } else {
             /* No match, output a literal byte */
             Tracevv((stderr,"%c", s->window[s->strstart]));
             _tr_tally_lit (s, s->window[s->strstart], bflush);
             s->lookahead--;
             s->strstart++;
         }
         if (bflush) FLUSH_BLOCK(s, 0);
     }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
+    s->insert = 0;
+    if (flush == Z_FINISH) {
+        FLUSH_BLOCK(s, 1);
+        return finish_done;
+    }
+    if (s->last_lit)
+        FLUSH_BLOCK(s, 0);
+    return block_done;
+}
+
+/* ===========================================================================
+ * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
+ * (It will be regenerated if this run of deflate switches away from Huffman.)
+ */
+local block_state deflate_huff(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    int bflush;             /* set if current block must be flushed */
+
+    for (;;) {
+        /* Make sure that we have a literal to write. */
+        if (s->lookahead == 0) {
+            fill_window(s);
+            if (s->lookahead == 0) {
+                if (flush == Z_NO_FLUSH)
+                    return need_more;
+                break;      /* flush the current block */
+            }
+        }
+
+        /* Output a literal byte */
+        s->match_length = 0;
+        Tracevv((stderr,"%c", s->window[s->strstart]));
+        _tr_tally_lit (s, s->window[s->strstart], bflush);
+        s->lookahead--;
+        s->strstart++;
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    s->insert = 0;
+    if (flush == Z_FINISH) {
+        FLUSH_BLOCK(s, 1);
+        return finish_done;
+    }
+    if (s->last_lit)
+        FLUSH_BLOCK(s, 0);
+    return block_done;
 }
-#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/deflate.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/deflate.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/deflate.h	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/deflate.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* deflate.h -- internal compression state
- * Copyright (C) 1995-2004 Jean-loup Gailly
+ * Copyright (C) 1995-2012 Jean-loup Gailly
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* WARNING: this file should *not* be used by applications. It is
    part of the implementation of the compression library and is
    subject to change. Applications should only use zlib.h.
@@ -45,12 +45,15 @@
 #define HEAP_SIZE (2*L_CODES+1)
 /* maximum heap size */
 
 #define MAX_BITS 15
 /* All codes must not exceed MAX_BITS bits */
 
+#define Buf_size 16
+/* size of bit buffer in bi_buf */
+
 #define INIT_STATE    42
 #define EXTRA_STATE   69
 #define NAME_STATE    73
 #define COMMENT_STATE 91
 #define HCRC_STATE   103
 #define BUSY_STATE   113
@@ -98,13 +101,13 @@
     ulg   pending_buf_size; /* size of pending_buf */
     Bytef *pending_out;  /* next pending byte to output to the stream */
     uInt   pending;      /* nb of bytes in the pending buffer */
     int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
     gz_headerp  gzhead;  /* gzip header information to write */
     uInt   gzindex;      /* where in extra, name, or comment */
-    Byte  method;        /* STORED (for zip only) or DEFLATED */
+    Byte  method;        /* can only be DEFLATED */
     int   last_flush;    /* value of flush param for previous deflate call */
 
                 /* used by deflate.c: */
 
     uInt  w_size;        /* LZ77 window size (32K by default) */
     uInt  w_bits;        /* log2(w_size)  (8..16) */
@@ -185,13 +188,13 @@
     uInt good_match;
     /* Use a faster search when the previous match is longer than this */
 
     int nice_match; /* Stop searching when current match exceeds this */
 
                 /* used by trees.c: */
-    /* Didn't use ct_data typedef below to supress compiler warning */
+    /* Didn't use ct_data typedef below to suppress compiler warning */
     struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
     struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
     struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
 
     struct tree_desc_s l_desc;               /* desc. for literal tree */
     struct tree_desc_s d_desc;               /* desc. for distance tree */
@@ -241,13 +244,13 @@
      * array would be necessary.
      */
 
     ulg opt_len;        /* bit length of current block with optimal trees */
     ulg static_len;     /* bit length of current block with static trees */
     uInt matches;       /* number of string matches in current block */
-    int last_eob_len;   /* bit length of EOB code for last block */
+    uInt insert;        /* bytes at end of window left to insert */
 
 #ifdef DEBUG
     ulg compressed_len; /* total bit length of compressed file mod 2^32 */
     ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
 #endif
 
@@ -257,12 +260,19 @@
      */
     int bi_valid;
     /* Number of valid bits in bi_buf.  All bits above the last valid bit
      * are always zero.
      */
 
+    ulg high_water;
+    /* High water mark offset in window for initialized bytes -- bytes above
+     * this are set to zero in order to avoid memory check warnings when
+     * longest match routines access bytes past the input.  This is then
+     * updated to the new high water mark.
+     */
+
 } FAR deflate_state;
 
 /* Output a byte on the stream.
  * IN assertion: there is enough room in pending_buf.
  */
 #define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
@@ -275,37 +285,42 @@
 
 #define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
 /* In order to simplify the code, particularly on 16 bit machines, match
  * distances are limited to MAX_DIST instead of WSIZE.
  */
 
+#define WIN_INIT MAX_MATCH
+/* Number of bytes after end of data in window to initialize in order to avoid
+   memory checker errors from longest match routines */
+
         /* in trees.c */
-void _tr_init         OF((deflate_state *s));
-int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
-void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
-                          int eof));
-void _tr_align        OF((deflate_state *s));
-void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
-                          int eof));
+void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
+int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
+void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
+                        ulg stored_len, int last));
+void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));
+void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
+void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
+                        ulg stored_len, int last));
 
 #define d_code(dist) \
    ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
 /* Mapping from a distance to a distance code. dist is the distance - 1 and
  * must not have side effects. _dist_code[256] and _dist_code[257] are never
  * used.
  */
 
 #ifndef DEBUG
 /* Inline versions of _tr_tally for speed: */
 
 #if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch _length_code[];
-  extern uch _dist_code[];
+  extern uch ZLIB_INTERNAL _length_code[];
+  extern uch ZLIB_INTERNAL _dist_code[];
 #else
-  extern const uch _length_code[];
-  extern const uch _dist_code[];
+  extern const uch ZLIB_INTERNAL _length_code[];
+  extern const uch ZLIB_INTERNAL _dist_code[];
 #endif
 
 # define _tr_tally_lit(s, c, flush) \
   { uch cc = (c); \
     s->d_buf[s->last_lit] = 0; \
     s->l_buf[s->last_lit++] = cc; \
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib: gzguts.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inffast.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inffast.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inffast.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inffast.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* inffast.c -- fast decoding
- * Copyright (C) 1995-2004 Mark Adler
+ * Copyright (C) 1995-2008, 2010, 2013 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 #include "zutil.h"
 #include "inftrees.h"
 #include "inflate.h"
@@ -61,36 +61,36 @@
 
     - The maximum bytes that a single length/distance pair can output is 258
       bytes, which is the maximum length that can be coded.  inflate_fast()
       requires strm->avail_out >= 258 for each loop to avoid checking for
       output space.
  */
-void inflate_fast(strm, start)
+void ZLIB_INTERNAL inflate_fast(strm, start)
 z_streamp strm;
 unsigned start;         /* inflate()'s starting value for strm->avail_out */
 {
     struct inflate_state FAR *state;
-    unsigned char FAR *in;      /* local strm->next_in */
-    unsigned char FAR *last;    /* while in < last, enough input available */
+    z_const unsigned char FAR *in;      /* local strm->next_in */
+    z_const unsigned char FAR *last;    /* have enough input while in < last */
     unsigned char FAR *out;     /* local strm->next_out */
     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
     unsigned char FAR *end;     /* while out < end, enough space available */
 #ifdef INFLATE_STRICT
     unsigned dmax;              /* maximum distance from zlib header */
 #endif
     unsigned wsize;             /* window size or zero if not using window */
     unsigned whave;             /* valid bytes in the window */
-    unsigned write;             /* window write index */
+    unsigned wnext;             /* window write index */
     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
     unsigned long hold;         /* local strm->hold */
     unsigned bits;              /* local strm->bits */
     code const FAR *lcode;      /* local strm->lencode */
     code const FAR *dcode;      /* local strm->distcode */
     unsigned lmask;             /* mask for first level of length codes */
     unsigned dmask;             /* mask for first level of distance codes */
-    code this;                  /* retrieved table entry */
+    code here;                  /* retrieved table entry */
     unsigned op;                /* code bits, operation, extra bits, or */
                                 /*  window position, window bytes to copy */
     unsigned len;               /* match length, unused bytes */
     unsigned dist;              /* match distance */
     unsigned char FAR *from;    /* where to copy match from */
 
@@ -103,13 +103,13 @@
     end = out + (strm->avail_out - 257);
 #ifdef INFLATE_STRICT
     dmax = state->dmax;
 #endif
     wsize = state->wsize;
     whave = state->whave;
-    write = state->write;
+    wnext = state->wnext;
     window = state->window;
     hold = state->hold;
     bits = state->bits;
     lcode = state->lencode;
     dcode = state->distcode;
     lmask = (1U << state->lenbits) - 1;
@@ -121,26 +121,26 @@
         if (bits < 15) {
             hold += (unsigned long)(PUP(in)) << bits;
             bits += 8;
             hold += (unsigned long)(PUP(in)) << bits;
             bits += 8;
         }
-        this = lcode[hold & lmask];
+        here = lcode[hold & lmask];
       dolen:
-        op = (unsigned)(this.bits);
+        op = (unsigned)(here.bits);
         hold >>= op;
         bits -= op;
-        op = (unsigned)(this.op);
+        op = (unsigned)(here.op);
         if (op == 0) {                          /* literal */
-            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                     "inflate:         literal '%c'\n" :
-                    "inflate:         literal 0x%02x\n", this.val));
-            PUP(out) = (unsigned char)(this.val);
+                    "inflate:         literal 0x%02x\n", here.val));
+            PUP(out) = (unsigned char)(here.val);
         }
         else if (op & 16) {                     /* length base */
-            len = (unsigned)(this.val);
+            len = (unsigned)(here.val);
             op &= 15;                           /* number of extra bits */
             if (op) {
                 if (bits < op) {
                     hold += (unsigned long)(PUP(in)) << bits;
                     bits += 8;
                 }
@@ -152,20 +152,20 @@
             if (bits < 15) {
                 hold += (unsigned long)(PUP(in)) << bits;
                 bits += 8;
                 hold += (unsigned long)(PUP(in)) << bits;
                 bits += 8;
             }
-            this = dcode[hold & dmask];
+            here = dcode[hold & dmask];
           dodist:
-            op = (unsigned)(this.bits);
+            op = (unsigned)(here.bits);
             hold >>= op;
             bits -= op;
-            op = (unsigned)(this.op);
+            op = (unsigned)(here.op);
             if (op & 16) {                      /* distance base */
-                dist = (unsigned)(this.val);
+                dist = (unsigned)(here.val);
                 op &= 15;                       /* number of extra bits */
                 if (bits < op) {
                     hold += (unsigned long)(PUP(in)) << bits;
                     bits += 8;
                     if (bits < op) {
                         hold += (unsigned long)(PUP(in)) << bits;
@@ -184,48 +184,70 @@
                 bits -= op;
                 Tracevv((stderr, "inflate:         distance %u\n", dist));
                 op = (unsigned)(out - beg);     /* max distance in output */
                 if (dist > op) {                /* see if copy from window */
                     op = dist - op;             /* distance back in window */
                     if (op > whave) {
-                        strm->msg = (char *)"invalid distance too far back";
-                        state->mode = BAD;
-                        break;
+                        if (state->sane) {
+                            strm->msg =
+                                (char *)"invalid distance too far back";
+                            state->mode = BAD;
+                            break;
+                        }
+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+                        if (len <= op - whave) {
+                            do {
+                                PUP(out) = 0;
+                            } while (--len);
+                            continue;
+                        }
+                        len -= op - whave;
+                        do {
+                            PUP(out) = 0;
+                        } while (--op > whave);
+                        if (op == 0) {
+                            from = out - dist;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--len);
+                            continue;
+                        }
+#endif
                     }
                     from = window - OFF;
-                    if (write == 0) {           /* very common case */
+                    if (wnext == 0) {           /* very common case */
                         from += wsize - op;
                         if (op < len) {         /* some from window */
                             len -= op;
                             do {
                                 PUP(out) = PUP(from);
                             } while (--op);
                             from = out - dist;  /* rest from output */
                         }
                     }
-                    else if (write < op) {      /* wrap around window */
-                        from += wsize + write - op;
-                        op -= write;
+                    else if (wnext < op) {      /* wrap around window */
+                        from += wsize + wnext - op;
+                        op -= wnext;
                         if (op < len) {         /* some from end of window */
                             len -= op;
                             do {
                                 PUP(out) = PUP(from);
                             } while (--op);
                             from = window - OFF;
-                            if (write < len) {  /* some from start of window */
-                                op = write;
+                            if (wnext < len) {  /* some from start of window */
+                                op = wnext;
                                 len -= op;
                                 do {
                                     PUP(out) = PUP(from);
                                 } while (--op);
                                 from = out - dist;      /* rest from output */
                             }
                         }
                     }
                     else {                      /* contiguous in window */
-                        from += write - op;
+                        from += wnext - op;
                         if (op < len) {         /* some from window */
                             len -= op;
                             do {
                                 PUP(out) = PUP(from);
                             } while (--op);
                             from = out - dist;  /* rest from output */
@@ -256,23 +278,23 @@
                         if (len > 1)
                             PUP(out) = PUP(from);
                     }
                 }
             }
             else if ((op & 64) == 0) {          /* 2nd level distance code */
-                this = dcode[this.val + (hold & ((1U << op) - 1))];
+                here = dcode[here.val + (hold & ((1U << op) - 1))];
                 goto dodist;
             }
             else {
                 strm->msg = (char *)"invalid distance code";
                 state->mode = BAD;
                 break;
             }
         }
         else if ((op & 64) == 0) {              /* 2nd level length code */
-            this = lcode[this.val + (hold & ((1U << op) - 1))];
+            here = lcode[here.val + (hold & ((1U << op) - 1))];
             goto dolen;
         }
         else if (op & 32) {                     /* end-of-block */
             Tracevv((stderr, "inflate:         end of block\n"));
             state->mode = TYPE;
             break;
@@ -302,13 +324,13 @@
 }
 
 /*
    inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
    - Using bit fields for code structure
    - Different op definition to avoid & for extra bits (do & for table bits)
-   - Three separate decoding do-loops for direct, window, and write == 0
+   - Three separate decoding do-loops for direct, window, and wnext == 0
    - Special case for distance > 1 copies to do overlapped load and store copy
    - Explicit branch predictions (based on measured branch probabilities)
    - Deferring match copy and interspersed it with decoding subsequent codes
    - Swapping literal/length else
    - Swapping window/direct else
    - Larger unrolled copy loops (three is about right)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inffast.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inffast.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inffast.h	2005-07-08 04:48:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inffast.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,11 +1,11 @@
 /* inffast.h -- header to use inffast.c
- * Copyright (C) 1995-2003 Mark Adler
+ * Copyright (C) 1995-2003, 2010 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* WARNING: this file should *not* be used by applications. It is
    part of the implementation of the compression library and is
    subject to change. Applications should only use zlib.h.
  */
 
-void inflate_fast OF((z_streamp strm, unsigned start));
+void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inffixed.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inffixed.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inffixed.h	2005-07-08 04:48:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inffixed.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,13 +1,13 @@
     /* inffixed.h -- table for decoding fixed codes
      * Generated automatically by makefixed().
      */
 
-    /* WARNING: this file should *not* be used by applications. It
-       is part of the implementation of the compression library and
-       is subject to change. Applications should only use zlib.h.
+    /* WARNING: this file should *not* be used by applications.
+       It is part of the implementation of this library and is
+       subject to change. Applications should only use zlib.h.
      */
 
     static const code lenfix[512] = {
         {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
         {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
         {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inflate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inflate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inflate.c	2007-05-21 18:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inflate.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* inflate.c -- zlib decompression
- * Copyright (C) 1995-2005 Mark Adler
+ * Copyright (C) 1995-2012 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /*
  * Change history:
  *
@@ -42,13 +42,13 @@
  * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
  * - Move a comment on output buffer sizes from inffast.c to inflate.c
  * - Add comments in inffast.c to introduce the inflate_fast() routine
  * - Rearrange window copies in inflate_fast() for speed and simplification
  * - Unroll last copy for window match in inflate_fast()
  * - Use local copies of window variables in inflate_fast() for speed
- * - Pull out common write == 0 case for speed in inflate_fast()
+ * - Pull out common wnext == 0 case for speed in inflate_fast()
  * - Make op and len in inflate_fast() unsigned for consistency
  * - Add FAR to lcode and dcode declarations in inflate_fast()
  * - Simplified bad distance check in inflate_fast()
  * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
  *   source file infback.c to provide a call-back interface to inflate for
  *   programs like gzip and unzip -- uses window as output buffer to avoid
@@ -90,111 +90,167 @@
 #    define BUILDFIXED
 #  endif
 #endif
 
 /* function prototypes */
 local void fixedtables OF((struct inflate_state FAR *state));
-local int updatewindow OF((z_streamp strm, unsigned out));
+local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
+                           unsigned copy));
 #ifdef BUILDFIXED
    void makefixed OF((void));
 #endif
-local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,
+local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
                               unsigned len));
 
-int ZEXPORT inflateReset(strm)
+int ZEXPORT inflateResetKeep(strm)
 z_streamp strm;
 {
     struct inflate_state FAR *state;
 
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state FAR *)strm->state;
     strm->total_in = strm->total_out = state->total = 0;
     strm->msg = Z_NULL;
-    strm->adler = 1;        /* to support ill-conceived Java test suite */
+    if (state->wrap)        /* to support ill-conceived Java test suite */
+        strm->adler = state->wrap & 1;
     state->mode = HEAD;
     state->last = 0;
     state->havedict = 0;
     state->dmax = 32768U;
     state->head = Z_NULL;
-    state->wsize = 0;
-    state->whave = 0;
-    state->write = 0;
     state->hold = 0;
     state->bits = 0;
     state->lencode = state->distcode = state->next = state->codes;
+    state->sane = 1;
+    state->back = -1;
     Tracev((stderr, "inflate: reset\n"));
     return Z_OK;
 }
 
-int ZEXPORT inflatePrime(strm, bits, value)
+int ZEXPORT inflateReset(strm)
 z_streamp strm;
-int bits;
-int value;
 {
     struct inflate_state FAR *state;
 
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state FAR *)strm->state;
-    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
-    value &= (1L << bits) - 1;
-    state->hold += value << state->bits;
-    state->bits += bits;
-    return Z_OK;
+    state->wsize = 0;
+    state->whave = 0;
+    state->wnext = 0;
+    return inflateResetKeep(strm);
+}
+
+int ZEXPORT inflateReset2(strm, windowBits)
+z_streamp strm;
+int windowBits;
+{
+    int wrap;
+    struct inflate_state FAR *state;
+
+    /* get the state */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+
+    /* extract wrap request from windowBits parameter */
+    if (windowBits < 0) {
+        wrap = 0;
+        windowBits = -windowBits;
+    }
+    else {
+        wrap = (windowBits >> 4) + 1;
+#ifdef GUNZIP
+        if (windowBits < 48)
+            windowBits &= 15;
+#endif
+    }
+
+    /* set number of window bits, free window if different */
+    if (windowBits && (windowBits < 8 || windowBits > 15))
+        return Z_STREAM_ERROR;
+    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
+        ZFREE(strm, state->window);
+        state->window = Z_NULL;
+    }
+
+    /* update state and reset the rest of it */
+    state->wrap = wrap;
+    state->wbits = (unsigned)windowBits;
+    return inflateReset(strm);
 }
 
 int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
 z_streamp strm;
 int windowBits;
 const char *version;
 int stream_size;
 {
+    int ret;
     struct inflate_state FAR *state;
 
     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
         stream_size != (int)(sizeof(z_stream)))
         return Z_VERSION_ERROR;
     if (strm == Z_NULL) return Z_STREAM_ERROR;
     strm->msg = Z_NULL;                 /* in case we return an error */
     if (strm->zalloc == (alloc_func)0) {
+#ifdef Z_SOLO
+        return Z_STREAM_ERROR;
+#else
         strm->zalloc = zcalloc;
         strm->opaque = (voidpf)0;
+#endif
     }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
+    if (strm->zfree == (free_func)0)
+#ifdef Z_SOLO
+        return Z_STREAM_ERROR;
+#else
+        strm->zfree = zcfree;
+#endif
     state = (struct inflate_state FAR *)
             ZALLOC(strm, 1, sizeof(struct inflate_state));
     if (state == Z_NULL) return Z_MEM_ERROR;
     Tracev((stderr, "inflate: allocated\n"));
     strm->state = (struct internal_state FAR *)state;
-    if (windowBits < 0) {
-        state->wrap = 0;
-        windowBits = -windowBits;
-    }
-    else {
-        state->wrap = (windowBits >> 4) + 1;
-#ifdef GUNZIP
-        if (windowBits < 48) windowBits &= 15;
-#endif
-    }
-    if (windowBits < 8 || windowBits > 15) {
+    state->window = Z_NULL;
+    ret = inflateReset2(strm, windowBits);
+    if (ret != Z_OK) {
         ZFREE(strm, state);
         strm->state = Z_NULL;
-        return Z_STREAM_ERROR;
     }
-    state->wbits = (unsigned)windowBits;
-    state->window = Z_NULL;
-    return inflateReset(strm);
+    return ret;
 }
 
 int ZEXPORT inflateInit_(strm, version, stream_size)
 z_streamp strm;
 const char *version;
 int stream_size;
 {
     return inflateInit2_(strm, DEF_WBITS, version, stream_size);
 }
 
+int ZEXPORT inflatePrime(strm, bits, value)
+z_streamp strm;
+int bits;
+int value;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    if (bits < 0) {
+        state->hold = 0;
+        state->bits = 0;
+        return Z_OK;
+    }
+    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
+    value &= (1L << bits) - 1;
+    state->hold += value << state->bits;
+    state->bits += bits;
+    return Z_OK;
+}
+
 /*
    Return state with length and distance decoding tables and index sizes set to
    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
    If BUILDFIXED is defined, then instead this routine builds the tables the
    first time it's called, and returns those tables the first time and
    thereafter.  This reduces the size of the code by about 2K bytes, in
@@ -283,14 +339,14 @@
     puts("");
     size = 1U << 9;
     printf("    static const code lenfix[%u] = {", size);
     low = 0;
     for (;;) {
         if ((low % 7) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.lencode[low].op, state.lencode[low].bits,
-               state.lencode[low].val);
+        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
+               state.lencode[low].bits, state.lencode[low].val);
         if (++low == size) break;
         putchar(',');
     }
     puts("\n    };");
     size = 1U << 5;
     printf("\n    static const code distfix[%u] = {", size);
@@ -317,18 +373,19 @@
    Providing output buffers larger than 32K to inflate() should provide a speed
    advantage, since only the last 32K of output is copied to the sliding window
    upon return from inflate(), and since all distances after the first 32K of
    output will fall in the output data, making match copies simpler and faster.
    The advantage may be dependent on the size of the processor's data caches.
  */
-local int updatewindow(strm, out)
+local int updatewindow(strm, end, copy)
 z_streamp strm;
-unsigned out;
+const Bytef *end;
+unsigned copy;
 {
     struct inflate_state FAR *state;
-    unsigned copy, dist;
+    unsigned dist;
 
     state = (struct inflate_state FAR *)strm->state;
 
     /* if it hasn't been done already, allocate space for the window */
     if (state->window == Z_NULL) {
         state->window = (unsigned char FAR *)
@@ -337,36 +394,35 @@
         if (state->window == Z_NULL) return 1;
     }
 
     /* if window not in use yet, initialize */
     if (state->wsize == 0) {
         state->wsize = 1U << state->wbits;
-        state->write = 0;
+        state->wnext = 0;
         state->whave = 0;
     }
 
     /* copy state->wsize or less output bytes into the circular window */
-    copy = out - strm->avail_out;
     if (copy >= state->wsize) {
-        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
-        state->write = 0;
+        zmemcpy(state->window, end - state->wsize, state->wsize);
+        state->wnext = 0;
         state->whave = state->wsize;
     }
     else {
-        dist = state->wsize - state->write;
+        dist = state->wsize - state->wnext;
         if (dist > copy) dist = copy;
-        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
+        zmemcpy(state->window + state->wnext, end - copy, dist);
         copy -= dist;
         if (copy) {
-            zmemcpy(state->window, strm->next_out - copy, copy);
-            state->write = copy;
+            zmemcpy(state->window, end - copy, copy);
+            state->wnext = copy;
             state->whave = state->wsize;
         }
         else {
-            state->write += dist;
-            if (state->write == state->wsize) state->write = 0;
+            state->wnext += dist;
+            if (state->wnext == state->wsize) state->wnext = 0;
             if (state->whave < state->wsize) state->whave += dist;
         }
     }
     return 0;
 }
 
@@ -461,17 +517,12 @@
 #define BYTEBITS() \
     do { \
         hold >>= bits & 7; \
         bits -= bits & 7; \
     } while (0)
 
-/* Reverse the bytes in a 32-bit value */
-#define REVERSE(q) \
-    ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
-     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
-
 /*
    inflate() uses a state machine to process as much input data and generate as
    much output data as possible before returning.  The state machine is
    structured roughly as follows:
 
     for (;;) switch (state) {
@@ -553,21 +604,21 @@
 
 int ZEXPORT inflate(strm, flush)
 z_streamp strm;
 int flush;
 {
     struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
+    z_const unsigned char FAR *next;    /* next input */
     unsigned char FAR *put;     /* next output */
     unsigned have, left;        /* available input and output */
     unsigned long hold;         /* bit buffer */
     unsigned bits;              /* bits in bit buffer */
     unsigned in, out;           /* save starting available input and output */
     unsigned copy;              /* number of stored or match bytes to copy */
     unsigned char FAR *from;    /* where to copy match bytes from */
-    code this;                  /* current decoding table entry */
+    code here;                  /* current decoding table entry */
     code last;                  /* parent table entry */
     unsigned len;               /* length to copy for repeats, bits to drop */
     int ret;                    /* return code */
 #ifdef GUNZIP
     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
 #endif
@@ -616,13 +667,15 @@
                 strm->msg = (char *)"unknown compression method";
                 state->mode = BAD;
                 break;
             }
             DROPBITS(4);
             len = BITS(4) + 8;
-            if (len > state->wbits) {
+            if (state->wbits == 0)
+                state->wbits = len;
+            else if (len > state->wbits) {
                 strm->msg = (char *)"invalid window size";
                 state->mode = BAD;
                 break;
             }
             state->dmax = 1U << len;
             Tracev((stderr, "inflate:   zlib header ok\n"));
@@ -764,26 +817,26 @@
             strm->adler = state->check = crc32(0L, Z_NULL, 0);
             state->mode = TYPE;
             break;
 #endif
         case DICTID:
             NEEDBITS(32);
-            strm->adler = state->check = REVERSE(hold);
+            strm->adler = state->check = ZSWAP32(hold);
             INITBITS();
             state->mode = DICT;
 	    /* FALL THROUGH */
         case DICT:
             if (state->havedict == 0) {
                 RESTORE();
                 return Z_NEED_DICT;
             }
             strm->adler = state->check = adler32(0L, Z_NULL, 0);
             state->mode = TYPE;
 	    /* FALL THROUGH */
         case TYPE:
-            if (flush == Z_BLOCK) goto inf_leave;
+            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
 	    /* FALL THROUGH */
         case TYPEDO:
             if (state->last) {
                 BYTEBITS();
                 state->mode = CHECK;
                 break;
@@ -798,13 +851,17 @@
                 state->mode = STORED;
                 break;
             case 1:                             /* fixed block */
                 fixedtables(state);
                 Tracev((stderr, "inflate:     fixed codes block%s\n",
                         state->last ? " (last)" : ""));
-                state->mode = LEN;              /* decode codes */
+                state->mode = LEN_;             /* decode codes */
+                if (flush == Z_TREES) {
+                    DROPBITS(2);
+                    goto inf_leave;
+                }
                 break;
             case 2:                             /* dynamic block */
                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
                         state->last ? " (last)" : ""));
                 state->mode = TABLE;
                 break;
@@ -823,12 +880,15 @@
                 break;
             }
             state->length = (unsigned)hold & 0xffff;
             Tracev((stderr, "inflate:       stored length %u\n",
                     state->length));
             INITBITS();
+            state->mode = COPY_;
+            if (flush == Z_TREES) goto inf_leave;
+        case COPY_:
             state->mode = COPY;
 	    /* FALL THROUGH */
         case COPY:
             copy = state->length;
             if (copy) {
                 if (copy > have) copy = have;
@@ -870,13 +930,13 @@
                 state->lens[order[state->have++]] = (unsigned short)BITS(3);
                 DROPBITS(3);
             }
             while (state->have < 19)
                 state->lens[order[state->have++]] = 0;
             state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
+            state->lencode = (const code FAR *)(state->next);
             state->lenbits = 7;
             ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                 &(state->lenbits), state->work);
             if (ret) {
                 strm->msg = (char *)"invalid code lengths set";
                 state->mode = BAD;
@@ -886,44 +946,43 @@
             state->have = 0;
             state->mode = CODELENS;
 	    /* FALL THROUGH */
         case CODELENS:
             while (state->have < state->nlen + state->ndist) {
                 for (;;) {
-                    this = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(this.bits) <= bits) break;
+                    here = state->lencode[BITS(state->lenbits)];
+                    if ((unsigned)(here.bits) <= bits) break;
                     PULLBYTE();
                 }
-                if (this.val < 16) {
-                    NEEDBITS(this.bits);
-                    DROPBITS(this.bits);
-                    state->lens[state->have++] = this.val;
+                if (here.val < 16) {
+                    DROPBITS(here.bits);
+                    state->lens[state->have++] = here.val;
                 }
                 else {
-                    if (this.val == 16) {
-                        NEEDBITS(this.bits + 2);
-                        DROPBITS(this.bits);
+                    if (here.val == 16) {
+                        NEEDBITS(here.bits + 2);
+                        DROPBITS(here.bits);
                         if (state->have == 0) {
                             strm->msg = (char *)"invalid bit length repeat";
                             state->mode = BAD;
                             break;
                         }
                         len = state->lens[state->have - 1];
                         copy = 3 + BITS(2);
                         DROPBITS(2);
                     }
-                    else if (this.val == 17) {
-                        NEEDBITS(this.bits + 3);
-                        DROPBITS(this.bits);
+                    else if (here.val == 17) {
+                        NEEDBITS(here.bits + 3);
+                        DROPBITS(here.bits);
                         len = 0;
                         copy = 3 + BITS(3);
                         DROPBITS(3);
                     }
                     else {
-                        NEEDBITS(this.bits + 7);
-                        DROPBITS(this.bits);
+                        NEEDBITS(here.bits + 7);
+                        DROPBITS(here.bits);
                         len = 0;
                         copy = 11 + BITS(7);
                         DROPBITS(7);
                     }
                     if (state->have + copy > state->nlen + state->ndist) {
                         strm->msg = (char *)"invalid bit length repeat";
@@ -935,146 +994,185 @@
                 }
             }
 
             /* handle error breaks in while */
             if (state->mode == BAD) break;
 
-            /* build code tables */
+            /* check for end-of-block code (better have one) */
+            if (state->lens[256] == 0) {
+                strm->msg = (char *)"invalid code -- missing end-of-block";
+                state->mode = BAD;
+                break;
+            }
+
+            /* build code tables -- note: do not change the lenbits or distbits
+               values here (9 and 6) without reading the comments in inftrees.h
+               concerning the ENOUGH constants, which depend on those values */
             state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
+            state->lencode = (const code FAR *)(state->next);
             state->lenbits = 9;
             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                 &(state->lenbits), state->work);
             if (ret) {
                 strm->msg = (char *)"invalid literal/lengths set";
                 state->mode = BAD;
                 break;
             }
-            state->distcode = (code const FAR *)(state->next);
+            state->distcode = (const code FAR *)(state->next);
             state->distbits = 6;
             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                             &(state->next), &(state->distbits), state->work);
             if (ret) {
                 strm->msg = (char *)"invalid distances set";
                 state->mode = BAD;
                 break;
             }
             Tracev((stderr, "inflate:       codes ok\n"));
+            state->mode = LEN_;
+            if (flush == Z_TREES) goto inf_leave;
+	    /* FALL THROUGH */
+        case LEN_:
             state->mode = LEN;
 	    /* FALL THROUGH */
         case LEN:
             if (have >= 6 && left >= 258) {
                 RESTORE();
                 inflate_fast(strm, out);
                 LOAD();
+                if (state->mode == TYPE)
+                    state->back = -1;
                 break;
             }
+            state->back = 0;
             for (;;) {
-                this = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(this.bits) <= bits) break;
+                here = state->lencode[BITS(state->lenbits)];
+                if ((unsigned)(here.bits) <= bits) break;
                 PULLBYTE();
             }
-            if (this.op && (this.op & 0xf0) == 0) {
-                last = this;
+            if (here.op && (here.op & 0xf0) == 0) {
+                last = here;
                 for (;;) {
-                    this = state->lencode[last.val +
+                    here = state->lencode[last.val +
                             (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                     PULLBYTE();
                 }
                 DROPBITS(last.bits);
+                state->back += last.bits;
             }
-            DROPBITS(this.bits);
-            state->length = (unsigned)this.val;
-            if ((int)(this.op) == 0) {
-                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
+            DROPBITS(here.bits);
+            state->back += here.bits;
+            state->length = (unsigned)here.val;
+            if ((int)(here.op) == 0) {
+                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                         "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", this.val));
+                        "inflate:         literal 0x%02x\n", here.val));
                 state->mode = LIT;
                 break;
             }
-            if (this.op & 32) {
+            if (here.op & 32) {
                 Tracevv((stderr, "inflate:         end of block\n"));
+                state->back = -1;
                 state->mode = TYPE;
                 break;
             }
-            if (this.op & 64) {
+            if (here.op & 64) {
                 strm->msg = (char *)"invalid literal/length code";
                 state->mode = BAD;
                 break;
             }
-            state->extra = (unsigned)(this.op) & 15;
+            state->extra = (unsigned)(here.op) & 15;
             state->mode = LENEXT;
 	    /* FALL THROUGH */
         case LENEXT:
             if (state->extra) {
                 NEEDBITS(state->extra);
                 state->length += BITS(state->extra);
                 DROPBITS(state->extra);
+                state->back += state->extra;
             }
             Tracevv((stderr, "inflate:         length %u\n", state->length));
+            state->was = state->length;
             state->mode = DIST;
 	    /* FALL THROUGH */
         case DIST:
             for (;;) {
-                this = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(this.bits) <= bits) break;
+                here = state->distcode[BITS(state->distbits)];
+                if ((unsigned)(here.bits) <= bits) break;
                 PULLBYTE();
             }
-            if ((this.op & 0xf0) == 0) {
-                last = this;
+            if ((here.op & 0xf0) == 0) {
+                last = here;
                 for (;;) {
-                    this = state->distcode[last.val +
+                    here = state->distcode[last.val +
                             (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + this.bits) <= bits) break;
+                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                     PULLBYTE();
                 }
                 DROPBITS(last.bits);
+                state->back += last.bits;
             }
-            DROPBITS(this.bits);
-            if (this.op & 64) {
+            DROPBITS(here.bits);
+            state->back += here.bits;
+            if (here.op & 64) {
                 strm->msg = (char *)"invalid distance code";
                 state->mode = BAD;
                 break;
             }
-            state->offset = (unsigned)this.val;
-            state->extra = (unsigned)(this.op) & 15;
+            state->offset = (unsigned)here.val;
+            state->extra = (unsigned)(here.op) & 15;
             state->mode = DISTEXT;
 	    /* FALL THROUGH */
         case DISTEXT:
             if (state->extra) {
                 NEEDBITS(state->extra);
                 state->offset += BITS(state->extra);
                 DROPBITS(state->extra);
+                state->back += state->extra;
             }
 #ifdef INFLATE_STRICT
             if (state->offset > state->dmax) {
                 strm->msg = (char *)"invalid distance too far back";
                 state->mode = BAD;
                 break;
             }
 #endif
-            if (state->offset > state->whave + out - left) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
             state->mode = MATCH;
 	    /* FALL THROUGH */
         case MATCH:
             if (left == 0) goto inf_leave;
             copy = out - left;
             if (state->offset > copy) {         /* copy from window */
                 copy = state->offset - copy;
-                if (copy > state->write) {
-                    copy -= state->write;
+                if (copy > state->whave) {
+                    if (state->sane) {
+                        strm->msg = (char *)"invalid distance too far back";
+                        state->mode = BAD;
+                        break;
+                    }
+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+                    Trace((stderr, "inflate.c too far\n"));
+                    copy -= state->whave;
+                    if (copy > state->length) copy = state->length;
+                    if (copy > left) copy = left;
+                    left -= copy;
+                    state->length -= copy;
+                    do {
+                        *put++ = 0;
+                    } while (--copy);
+                    if (state->length == 0) state->mode = LEN;
+                    break;
+#endif
+                }
+                if (copy > state->wnext) {
+                    copy -= state->wnext;
                     from = state->window + (state->wsize - copy);
                 }
                 else
-                    from = state->window + (state->write - copy);
+                    from = state->window + (state->wnext - copy);
                 if (copy > state->length) copy = state->length;
             }
             else {                              /* copy from output */
                 from = put - state->offset;
                 copy = state->length;
             }
@@ -1103,13 +1201,13 @@
                         UPDATE(state->check, put - out, out);
                 out = left;
                 if ((
 #ifdef GUNZIP
                      state->flags ? hold :
 #endif
-                     REVERSE(hold)) != state->check) {
+                     ZSWAP32(hold)) != state->check) {
                     strm->msg = (char *)"incorrect data check";
                     state->mode = BAD;
                     break;
                 }
                 INITBITS();
                 Tracev((stderr, "inflate:   check matches trailer\n"));
@@ -1149,27 +1247,29 @@
        If there was no progress during the inflate() call, return a buffer
        error.  Call updatewindow() to create and/or update the window state.
        Note: a memory error from inflate() is non-recoverable.
      */
   inf_leave:
     RESTORE();
-    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
-        if (updatewindow(strm, out)) {
+    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
+            (state->mode < CHECK || flush != Z_FINISH)))
+        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
             state->mode = MEM;
             return Z_MEM_ERROR;
         }
     in -= strm->avail_in;
     out -= strm->avail_out;
     strm->total_in += in;
     strm->total_out += out;
     state->total += out;
     if (state->wrap && out)
         strm->adler = state->check =
             UPDATE(state->check, strm->next_out - out, out);
     strm->data_type = state->bits + (state->last ? 64 : 0) +
-                      (state->mode == TYPE ? 128 : 0);
+                      (state->mode == TYPE ? 128 : 0) +
+                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
         ret = Z_BUF_ERROR;
     return ret;
 }
 
 int ZEXPORT inflateEnd(strm)
@@ -1183,49 +1283,65 @@
     ZFREE(strm, strm->state);
     strm->state = Z_NULL;
     Tracev((stderr, "inflate: end\n"));
     return Z_OK;
 }
 
+int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
+z_streamp strm;
+Bytef *dictionary;
+uInt *dictLength;
+{
+    struct inflate_state FAR *state;
+
+    /* check state */
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+
+    /* copy dictionary */
+    if (state->whave && dictionary != Z_NULL) {
+        zmemcpy(dictionary, state->window + state->wnext,
+                state->whave - state->wnext);
+        zmemcpy(dictionary + state->whave - state->wnext,
+                state->window, state->wnext);
+    }
+    if (dictLength != Z_NULL)
+        *dictLength = state->whave;
+    return Z_OK;
+}
+
 int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
 z_streamp strm;
 const Bytef *dictionary;
 uInt dictLength;
 {
     struct inflate_state FAR *state;
-    unsigned long id;
+    unsigned long dictid;
+    int ret;
 
     /* check state */
     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
     state = (struct inflate_state FAR *)strm->state;
     if (state->wrap != 0 && state->mode != DICT)
         return Z_STREAM_ERROR;
 
-    /* check for correct dictionary id */
+    /* check for correct dictionary identifier */
     if (state->mode == DICT) {
-        id = adler32(0L, Z_NULL, 0);
-        id = adler32(id, dictionary, dictLength);
-        if (id != state->check)
+        dictid = adler32(0L, Z_NULL, 0);
+        dictid = adler32(dictid, dictionary, dictLength);
+        if (dictid != state->check)
             return Z_DATA_ERROR;
     }
 
-    /* copy dictionary to window */
-    if (updatewindow(strm, strm->avail_out)) {
+    /* copy dictionary to window using updatewindow(), which will amend the
+       existing dictionary if appropriate */
+    ret = updatewindow(strm, dictionary + dictLength, dictLength);
+    if (ret) {
         state->mode = MEM;
         return Z_MEM_ERROR;
     }
-    if (dictLength > state->wsize) {
-        zmemcpy(state->window, dictionary + dictLength - state->wsize,
-                state->wsize);
-        state->whave = state->wsize;
-    }
-    else {
-        zmemcpy(state->window + state->wsize - dictLength, dictionary,
-                dictLength);
-        state->whave = dictLength;
-    }
     state->havedict = 1;
     Tracev((stderr, "inflate:   dictionary set\n"));
     return Z_OK;
 }
 
 int ZEXPORT inflateGetHeader(strm, head)
@@ -1255,13 +1371,13 @@
    yet and the return value is len.  In the latter case, syncsearch() can be
    called again with more data and the *have state.  *have is initialized to
    zero for the first call.
  */
 local unsigned syncsearch(have, buf, len)
 unsigned FAR *have;
-unsigned char FAR *buf;
+const unsigned char FAR *buf;
 unsigned len;
 {
     unsigned got;
     unsigned next;
 
     got = *have;
@@ -1367,14 +1483,14 @@
             ZFREE(source, copy);
             return Z_MEM_ERROR;
         }
     }
 
     /* copy state */
-    zmemcpy(dest, source, sizeof(z_stream));
-    zmemcpy(copy, state, sizeof(struct inflate_state));
+    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
+    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
     if (state->lencode >= state->codes &&
         state->lencode <= state->codes + ENOUGH - 1) {
         copy->lencode = copy->codes + (state->lencode - state->codes);
         copy->distcode = copy->codes + (state->distcode - state->codes);
     }
     copy->next = copy->codes + (state->next - state->codes);
@@ -1383,6 +1499,35 @@
         zmemcpy(window, state->window, wsize);
     }
     copy->window = window;
     dest->state = (struct internal_state FAR *)copy;
     return Z_OK;
 }
+
+int ZEXPORT inflateUndermine(strm, subvert)
+z_streamp strm;
+int subvert;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm->state;
+    state->sane = !subvert;
+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+    return Z_OK;
+#else
+    state->sane = 1;
+    return Z_DATA_ERROR;
+#endif
+}
+
+long ZEXPORT inflateMark(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
+    state = (struct inflate_state FAR *)strm->state;
+    return ((long)(state->back) << 16) +
+        (state->mode == COPY ? state->length :
+            (state->mode == MATCH ? state->was - state->length : 0));
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inflate.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inflate.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inflate.h	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inflate.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* inflate.h -- internal inflate state definition
- * Copyright (C) 1995-2004 Mark Adler
+ * Copyright (C) 1995-2009 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* WARNING: this file should *not* be used by applications. It is
    part of the implementation of the compression library and is
    subject to change. Applications should only use zlib.h.
@@ -33,17 +33,19 @@
     HCRC,       /* i: waiting for header crc (gzip) */
     DICTID,     /* i: waiting for dictionary check value */
     DICT,       /* waiting for inflateSetDictionary() call */
         TYPE,       /* i: waiting for type bits, including last-flag bit */
         TYPEDO,     /* i: same, but skip check to exit inflate on new block */
         STORED,     /* i: waiting for stored size (length and complement) */
+        COPY_,      /* i/o: same as COPY below, but only first time in */
         COPY,       /* i/o: waiting for input or output to copy stored block */
         TABLE,      /* i: waiting for dynamic block table lengths */
         LENLENS,    /* i: waiting for code length code lengths */
         CODELENS,   /* i: waiting for length/lit and distance code lengths */
-            LEN,        /* i: waiting for length/lit code */
+            LEN_,       /* i: same as LEN below, but only first time in */
+            LEN,        /* i: waiting for length/lit/eob code */
             LENEXT,     /* i: waiting for length extra bits */
             DIST,       /* i: waiting for distance code */
             DISTEXT,    /* i: waiting for distance extra bits */
             MATCH,      /* o: waiting for output space to copy string */
             LIT,        /* o: waiting for output space to write literal */
     CHECK,      /* i: waiting for 32-bit check value */
@@ -54,33 +56,35 @@
     SYNC        /* looking for synchronization bytes to restart inflate() */
 } inflate_mode;
 
 /*
     State transitions between above modes -
 
-    (most modes can go to the BAD or MEM mode -- not shown for clarity)
+    (most modes can go to BAD or MEM on error -- not shown for clarity)
 
     Process header:
-        HEAD -> (gzip) or (zlib)
-        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME
-        NAME -> COMMENT -> HCRC -> TYPE
+        HEAD -> (gzip) or (zlib) or (raw)
+        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
+                  HCRC -> TYPE
         (zlib) -> DICTID or TYPE
         DICTID -> DICT -> TYPE
+        (raw) -> TYPEDO
     Read deflate blocks:
-            TYPE -> STORED or TABLE or LEN or CHECK
-            STORED -> COPY -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN
-    Read deflate codes:
+            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
+            STORED -> COPY_ -> COPY -> TYPE
+            TABLE -> LENLENS -> CODELENS -> LEN_
+            LEN_ -> LEN
+    Read deflate codes in fixed or dynamic block:
                 LEN -> LENEXT or LIT or TYPE
                 LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
                 LIT -> LEN
     Process trailer:
         CHECK -> LENGTH -> DONE
  */
 
-/* state maintained between inflate() calls.  Approximately 7K bytes. */
+/* state maintained between inflate() calls.  Approximately 10K bytes. */
 struct inflate_state {
     inflate_mode mode;          /* current inflate mode */
     int last;                   /* true if processing last block */
     int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
     int havedict;               /* true if dictionary provided */
     int flags;                  /* gzip header method and flags (0 if zlib) */
@@ -89,13 +93,13 @@
     unsigned long total;        /* protected copy of output count */
     gz_headerp head;            /* where to save gzip header information */
         /* sliding window */
     unsigned wbits;             /* log base 2 of requested window size */
     unsigned wsize;             /* window size or zero if not using window */
     unsigned whave;             /* valid bytes in the window */
-    unsigned write;             /* window write index */
+    unsigned wnext;             /* window write index */
     unsigned char FAR *window;  /* allocated sliding window, if needed */
         /* bit accumulator */
     unsigned long hold;         /* input bit accumulator */
     unsigned bits;              /* number of bits in "in" */
         /* for string and stored block copying */
     unsigned length;            /* literal or length of data to copy */
@@ -113,7 +117,10 @@
     unsigned ndist;             /* number of distance code lengths */
     unsigned have;              /* number of code lengths in lens[] */
     code FAR *next;             /* next available space in codes[] */
     unsigned short lens[320];   /* temporary storage for code lengths */
     unsigned short work[288];   /* work area for code table building */
     code codes[ENOUGH];         /* space for code tables */
+    int sane;                   /* if false, allow invalid distance too far */
+    int back;                   /* bits back of last unprocessed length/lit */
+    unsigned was;               /* initial length of match */
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inftrees.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inftrees.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inftrees.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inftrees.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,18 +1,18 @@
 /* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2005 Mark Adler
+ * Copyright (C) 1995-2013 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 #include "zutil.h"
 #include "inftrees.h"
 
 #define MAXBITS 15
 
 const char inflate_copyright[] =
-   " inflate 1.2.3 Copyright 1995-2005 Mark Adler ";
+   " inflate 1.2.8 Copyright 1995-2013 Mark Adler ";
 /*
   If you use the zlib library in a product, an acknowledgment is welcome
   in the documentation of your product. If for some reason you cannot
   include such an acknowledgment, I would appreciate that you keep this
   copyright string in the executable of your product.
  */
@@ -26,13 +26,13 @@
    -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
    on return points to the next available entry's address.  bits is the
    requested root table index bits, and on return it is the actual root
    table index bits.  It will differ if the request is greater than the
    longest code or if it is less than the shortest code.
  */
-int inflate_table(type, lens, codes, table, bits, work)
+int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
 codetype type;
 unsigned short FAR *lens;
 unsigned codes;
 code FAR * FAR *table;
 unsigned FAR *bits;
 unsigned short FAR *work;
@@ -47,25 +47,25 @@
     unsigned used;              /* code entries in table used */
     unsigned huff;              /* Huffman code */
     unsigned incr;              /* for incrementing code, index */
     unsigned fill;              /* index for replicating entries */
     unsigned low;               /* low bits for current root entry */
     unsigned mask;              /* mask for low root bits */
-    code this;                  /* table entry for duplication */
+    code here;                  /* table entry for duplication */
     code FAR *next;             /* next available space in table */
     const unsigned short FAR *base;     /* base value table to use */
     const unsigned short FAR *extra;    /* extra bits table to use */
     int end;                    /* use base and extra for symbol > end */
     unsigned short count[MAXBITS+1];    /* number of codes of each length */
     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78};
     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
         8193, 12289, 16385, 24577, 0, 0};
     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
@@ -112,21 +112,21 @@
     /* bound code lengths, force root to be within code lengths */
     root = *bits;
     for (max = MAXBITS; max >= 1; max--)
         if (count[max] != 0) break;
     if (root > max) root = max;
     if (max == 0) {                     /* no symbols to code at all */
-        this.op = (unsigned char)64;    /* invalid code marker */
-        this.bits = (unsigned char)1;
-        this.val = (unsigned short)0;
-        *(*table)++ = this;             /* make a table to force an error */
-        *(*table)++ = this;
+        here.op = (unsigned char)64;    /* invalid code marker */
+        here.bits = (unsigned char)1;
+        here.val = (unsigned short)0;
+        *(*table)++ = here;             /* make a table to force an error */
+        *(*table)++ = here;
         *bits = 1;
         return 0;     /* no symbols, but wait for decoding to report error */
     }
-    for (min = 1; min <= MAXBITS; min++)
+    for (min = 1; min < max; min++)
         if (count[min] != 0) break;
     if (root < min) root = min;
 
     /* check for an over-subscribed or incomplete set of lengths */
     left = 1;
     for (len = 1; len <= MAXBITS; len++) {
@@ -163,17 +163,16 @@
        When a new sub-table is needed, it is necessary to look ahead in the
        code lengths to determine what size sub-table is needed.  The length
        counts are used for this, and so count[] is decremented as codes are
        entered in the tables.
 
        used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked when a LENS table is being made
-       against the space in *table, ENOUGH, minus the maximum space needed by
-       the worst case distance code, MAXD.  This should never happen, but the
-       sufficiency of ENOUGH has not been proven exhaustively, hence the check.
-       This assumes that when type == LENS, bits == 9.
+       provided *table space.  It is checked for LENS and DIST tables against
+       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
+       the initial root table size constants.  See the comments in inftrees.h
+       for more information.
 
        sym increments through all symbols, and the loop terminates when
        all codes of length max, i.e. all codes, have been processed.  This
        routine permits incomplete codes, so another loop after this one fills
        in the rest of the decoding tables with invalid code markers.
      */
@@ -206,39 +205,40 @@
     drop = 0;                   /* current bits to drop from code for index */
     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
     used = 1U << root;          /* use root table entries */
     mask = used - 1;            /* mask for comparing low */
 
     /* check available table space */
-    if (type == LENS && used >= ENOUGH - MAXD)
+    if ((type == LENS && used > ENOUGH_LENS) ||
+        (type == DISTS && used > ENOUGH_DISTS))
         return 1;
 
     /* process all codes and make table entries */
     for (;;) {
         /* create table entry */
-        this.bits = (unsigned char)(len - drop);
+        here.bits = (unsigned char)(len - drop);
         if ((int)(work[sym]) < end) {
-            this.op = (unsigned char)0;
-            this.val = work[sym];
+            here.op = (unsigned char)0;
+            here.val = work[sym];
         }
         else if ((int)(work[sym]) > end) {
-            this.op = (unsigned char)(extra[work[sym]]);
-            this.val = base[work[sym]];
+            here.op = (unsigned char)(extra[work[sym]]);
+            here.val = base[work[sym]];
         }
         else {
-            this.op = (unsigned char)(32 + 64);         /* end of block */
-            this.val = 0;
+            here.op = (unsigned char)(32 + 64);         /* end of block */
+            here.val = 0;
         }
 
         /* replicate for those indices with low len bits equal to huff */
         incr = 1U << (len - drop);
         fill = 1U << curr;
         min = fill;                 /* save offset to next table */
         do {
             fill -= incr;
-            next[(huff >> drop) + fill] = this;
+            next[(huff >> drop) + fill] = here;
         } while (fill != 0);
 
         /* backwards increment the len-bit code huff */
         incr = 1U << (len - 1);
         while (huff & incr)
             incr >>= 1;
@@ -274,55 +274,32 @@
                 curr++;
                 left <<= 1;
             }
 
             /* check for enough space */
             used += 1U << curr;
-            if (type == LENS && used >= ENOUGH - MAXD)
+            if ((type == LENS && used > ENOUGH_LENS) ||
+                (type == DISTS && used > ENOUGH_DISTS))
                 return 1;
 
             /* point entry in root table to sub-table */
             low = huff & mask;
             (*table)[low].op = (unsigned char)curr;
             (*table)[low].bits = (unsigned char)root;
             (*table)[low].val = (unsigned short)(next - *table);
         }
     }
 
-    /*
-       Fill in rest of table for incomplete codes.  This loop is similar to the
-       loop above in incrementing huff for table indices.  It is assumed that
-       len is equal to curr + drop, so there is no loop needed to increment
-       through high index bits.  When the current sub-table is filled, the loop
-       drops back to the root table to fill in any remaining entries there.
-     */
-    this.op = (unsigned char)64;                /* invalid code marker */
-    this.bits = (unsigned char)(len - drop);
-    this.val = (unsigned short)0;
-    while (huff != 0) {
-        /* when done with sub-table, drop back to root table */
-        if (drop != 0 && (huff & mask) != low) {
-            drop = 0;
-            len = root;
-            next = *table;
-            this.bits = (unsigned char)len;
-        }
-
-        /* put invalid code marker in table */
-        next[huff >> drop] = this;
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
+    /* fill in remaining table entry if code is incomplete (guaranteed to have
+       at most one remaining entry, since if the code is incomplete, the
+       maximum code length that was allowed to get this far is one bit) */
+    if (huff != 0) {
+        here.op = (unsigned char)64;            /* invalid code marker */
+        here.bits = (unsigned char)(len - drop);
+        here.val = (unsigned short)0;
+        next[huff] = here;
     }
 
     /* set return parameters */
     *table += used;
     *bits = root;
     return 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inftrees.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inftrees.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/inftrees.h	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/inftrees.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-2005 Mark Adler
+ * Copyright (C) 1995-2005, 2010 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* WARNING: this file should *not* be used by applications. It is
    part of the implementation of the compression library and is
    subject to change. Applications should only use zlib.h.
@@ -32,24 +32,31 @@
     0000tttt - table link, tttt != 0 is the number of table index bits
     0001eeee - length or distance, eeee is the number of extra bits
     01100000 - end of block
     01000000 - invalid code
  */
 
-/* Maximum size of dynamic tree.  The maximum found in a long but non-
-   exhaustive search was 1444 code structures (852 for length/literals
-   and 592 for distances, the latter actually the result of an
-   exhaustive search).  The true maximum is not known, but the value
-   below is more than safe. */
-#define ENOUGH 2048
-#define MAXD 592
+/* Maximum size of the dynamic table.  The maximum number of code structures is
+   1444, which is the sum of 852 for literal/length codes and 592 for distance
+   codes.  These values were found by exhaustive searches using the program
+   examples/enough.c found in the zlib distribtution.  The arguments to that
+   program are the number of symbols, the initial root table size, and the
+   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
+   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
+   The initial root table size (9 or 6) is found in the fifth argument of the
+   inflate_table() calls in inflate.c and infback.c.  If the root table size is
+   changed, then these maximum sizes would be need to be recalculated and
+   updated. */
+#define ENOUGH_LENS 852
+#define ENOUGH_DISTS 592
+#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
 
-/* Type of code to build for inftable() */
+/* Type of code to build for inflate_table() */
 typedef enum {
     CODES,
     LENS,
     DISTS
 } codetype;
 
-extern int inflate_table OF((codetype type, unsigned short FAR *lens,
+int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
                              unsigned codes, code FAR * FAR *table,
                              unsigned FAR *bits, unsigned short FAR *work));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/README	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/README	2013-06-10 13:27:33.000000000 +0800
@@ -1,59 +1,55 @@
 ZLIB DATA COMPRESSION LIBRARY
 
-zlib 1.2.3 is a general purpose data compression library.  All the code is
+zlib 1.2.8 is a general purpose data compression library.  All the code is
 thread safe.  The data format used by the zlib library is described by RFCs
 (Request for Comments) 1950 to 1952 in the files
-http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)
-and rfc1952.txt (gzip format). These documents are also available in other
-formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html
+http://tools.ietf.org/html/rfc1950 (zlib format), rfc1951 (deflate format) and
+rfc1952 (gzip format).
 
 All functions of the compression library are documented in the file zlib.h
-(volunteer to write man pages welcome, contact zlib@gzip.org). A usage example
-of the library is given in the file example.c which also tests that the library
-is working correctly. Another example is given in the file minigzip.c. The
-compression library itself is composed of all source files except example.c and
-minigzip.c.
+(volunteer to write man pages welcome, contact zlib@gzip.org).  A usage example
+of the library is given in the file test/example.c which also tests that
+the library is working correctly.  Another example is given in the file
+test/minigzip.c.  The compression library itself is composed of all source
+files in the root directory.
 
 To compile all files and run the test program, follow the instructions given at
-the top of Makefile. In short "make test; make install" should work for most
-machines. For Unix: "./configure; make test; make install". For MSDOS, use one
-of the special makefiles such as Makefile.msc. For VMS, use make_vms.com.
+the top of Makefile.in.  In short "./configure; make test", and if that goes
+well, "make install" should work for most flavors of Unix.  For Windows, use
+one of the special makefiles in win32/ or contrib/vstudio/ .  For VMS, use
+make_vms.com.
 
 Questions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant
-<info@winimage.com> for the Windows DLL version. The zlib home page is
-http://www.zlib.org or http://www.gzip.org/zlib/ Before reporting a problem,
-please check this site to verify that you have the latest version of zlib;
-otherwise get the latest version and check whether the problem still exists or
-not.
-
-PLEASE read the zlib FAQ http://www.gzip.org/zlib/zlib_faq.html before asking
-for help.
-
-Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan. 1997
-issue of  Dr. Dobb's Journal; a copy of the article is available in
-http://dogma.net/markn/articles/zlibtool/zlibtool.htm
-
-The changes made in version 1.2.3 are documented in the file ChangeLog.
-
-Unsupported third party contributions are provided in directory "contrib".
-
-A Java implementation of zlib is available in the Java Development Kit
-http://java.sun.com/j2se/1.4.2/docs/api/java/util/zip/package-summary.html
-See the zlib home page http://www.zlib.org for details.
-
-A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is in the
-CPAN (Comprehensive Perl Archive Network) sites
-http://www.cpan.org/modules/by-module/Compress/
+<info@winimage.com> for the Windows DLL version.  The zlib home page is
+http://zlib.net/ .  Before reporting a problem, please check this site to
+verify that you have the latest version of zlib; otherwise get the latest
+version and check whether the problem still exists or not.
+
+PLEASE read the zlib FAQ http://zlib.net/zlib_faq.html before asking for help.
+
+Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan.  1997
+issue of Dr.  Dobb's Journal; a copy of the article is available at
+http://marknelson.us/1997/01/01/zlib-engine/ .
+
+The changes made in version 1.2.8 are documented in the file ChangeLog.
+
+Unsupported third party contributions are provided in directory contrib/ .
+
+zlib is available in Java using the java.util.zip package, documented at
+http://java.sun.com/developer/technicalArticles/Programming/compression/ .
+
+A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is available
+at CPAN (Comprehensive Perl Archive Network) sites, including
+http://search.cpan.org/~pmqs/IO-Compress-Zlib/ .
 
 A Python interface to zlib written by A.M. Kuchling <amk@amk.ca> is
 available in Python 1.5 and later versions, see
-http://www.python.org/doc/lib/module-zlib.html
+http://docs.python.org/library/zlib.html .
 
-A zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com> is
-availlable at http://www.oche.de/~akupries/soft/trf/trf_zip.html
+zlib is built into tcl: http://wiki.tcl.tk/4610 .
 
 An experimental package to read and write files in .zip format, written on top
 of zlib by Gilles Vollant <info@winimage.com>, is available in the
 contrib/minizip directory of zlib.
 
 
@@ -71,31 +67,27 @@
 - On Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1 is
   necessary to get gzprintf working correctly. This is done by configure.
 
 - zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works with
   other compilers. Use "make test" to check your compiler.
 
-- gzdopen is not supported on RISCOS, BEOS and by some Mac compilers.
+- gzdopen is not supported on RISCOS or BEOS.
 
 - For PalmOs, see http://palmzlib.sourceforge.net/
 
-- When building a shared, i.e. dynamic library on Mac OS X, the library must be
-  installed before testing (do "make install" before "make test"), since the
-  library location is specified in the library.
-
 
 Acknowledgments:
 
-  The deflate format used by zlib was defined by Phil Katz. The deflate
-  and zlib specifications were written by L. Peter Deutsch. Thanks to all the
-  people who reported problems and suggested various improvements in zlib;
-  they are too numerous to cite here.
+  The deflate format used by zlib was defined by Phil Katz.  The deflate and
+  zlib specifications were written by L.  Peter Deutsch.  Thanks to all the
+  people who reported problems and suggested various improvements in zlib; they
+  are too numerous to cite here.
 
 Copyright notice:
 
- (C) 1995-2004 Jean-loup Gailly and Mark Adler
+ (C) 1995-2013 Jean-loup Gailly and Mark Adler
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
   arising from the use of this software.
 
   Permission is granted to anyone to use this software for any purpose,
@@ -110,16 +102,14 @@
      misrepresented as being the original software.
   3. This notice may not be removed or altered from any source distribution.
 
   Jean-loup Gailly        Mark Adler
   jloup@gzip.org          madler@alumni.caltech.edu
 
-If you use the zlib library in a product, we would appreciate *not*
-receiving lengthy legal documents to sign. The sources are provided
-for free but without warranty of any kind.  The library has been
-entirely written by Jean-loup Gailly and Mark Adler; it does not
-include third-party code.
-
-If you redistribute modified sources, we would appreciate that you include
-in the file ChangeLog history information documenting your changes. Please
-read the FAQ for more information on the distribution of modified source
-versions.
+If you use the zlib library in a product, we would appreciate *not* receiving
+lengthy legal documents to sign.  The sources are provided for free but without
+warranty of any kind.  The library has been entirely written by Jean-loup
+Gailly and Mark Adler; it does not include third-party code.
+
+If you redistribute modified sources, we would appreciate that you include in
+the file ChangeLog history information documenting your changes.  Please read
+the FAQ for more information on the distribution of modified source versions.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/trees.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/trees.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/trees.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/trees.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,9 @@
 /* trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-2005 Jean-loup Gailly
+ * Copyright (C) 1995-2012 Jean-loup Gailly
+ * detect_data_type() function provided freely by Cosmin Truta, 2006
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /*
  *  ALGORITHM
  *
@@ -70,17 +71,12 @@
 local const uch bl_order[BL_CODES]
    = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
 /* The lengths of the bit length codes are sent in order of decreasing
  * probability, to avoid transmitting the lengths for unused bit length codes.
  */
 
-#define Buf_size (8 * 2*sizeof(char))
-/* Number of bits used within bi_buf. (bi_buf might be implemented on
- * more than 16 bits on some systems.)
- */
-
 /* ===========================================================================
  * Local data. These are initialized only once.
  */
 
 #define DIST_CODE_LEN  512 /* see definition of array dist_code below */
 
@@ -147,15 +143,15 @@
 local void build_tree     OF((deflate_state *s, tree_desc *desc));
 local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
 local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
 local int  build_bl_tree  OF((deflate_state *s));
 local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                               int blcodes));
-local void compress_block OF((deflate_state *s, ct_data *ltree,
-                              ct_data *dtree));
-local void set_data_type  OF((deflate_state *s));
+local void compress_block OF((deflate_state *s, const ct_data *ltree,
+                              const ct_data *dtree));
+local int  detect_data_type OF((deflate_state *s));
 local unsigned bi_reverse OF((unsigned value, int length));
 local void bi_windup      OF((deflate_state *s));
 local void bi_flush       OF((deflate_state *s));
 local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                               int header));
 
@@ -200,33 +196,33 @@
 
     /* If not enough room in bi_buf, use (valid) bits from bi_buf and
      * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
      * unused bits in value.
      */
     if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (value << s->bi_valid);
+        s->bi_buf |= (ush)value << s->bi_valid;
         put_short(s, s->bi_buf);
         s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
         s->bi_valid += length - Buf_size;
     } else {
-        s->bi_buf |= value << s->bi_valid;
+        s->bi_buf |= (ush)value << s->bi_valid;
         s->bi_valid += length;
     }
 }
 #else /* !DEBUG */
 
 #define send_bits(s, value, length) \
 { int len = length;\
   if (s->bi_valid > (int)Buf_size - len) {\
     int val = value;\
-    s->bi_buf |= (val << s->bi_valid);\
+    s->bi_buf |= (ush)val << s->bi_valid;\
     put_short(s, s->bi_buf);\
     s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
     s->bi_valid += len - Buf_size;\
   } else {\
-    s->bi_buf |= (value) << s->bi_valid;\
+    s->bi_buf |= (ush)(value) << s->bi_valid;\
     s->bi_valid += len;\
   }\
 }
 #endif /* DEBUG */
 
 
@@ -247,17 +243,19 @@
     ush bl_count[MAX_BITS+1];
     /* number of codes at each bit length for an optimal tree */
 
     if (static_init_done) return;
 
     /* For some embedded targets, global variables are not initialized: */
+#ifdef NO_INIT_GLOBAL_POINTERS
     static_l_desc.static_tree = static_ltree;
     static_l_desc.extra_bits = extra_lbits;
     static_d_desc.static_tree = static_dtree;
     static_d_desc.extra_bits = extra_dbits;
     static_bl_desc.extra_bits = extra_blbits;
+#endif
 
     /* Initialize the mapping length (0..255) -> length code (0..28) */
     length = 0;
     for (code = 0; code < LENGTH_CODES-1; code++) {
         base_length[code] = length;
         for (n = 0; n < (1<<extra_lbits[code]); n++) {
@@ -345,19 +343,20 @@
     fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
     for (i = 0; i < D_CODES; i++) {
         fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
                 static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
     }
 
-    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
+    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
     for (i = 0; i < DIST_CODE_LEN; i++) {
         fprintf(header, "%2u%s", _dist_code[i],
                 SEPARATOR(i, DIST_CODE_LEN-1, 20));
     }
 
-    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
+    fprintf(header,
+        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
     for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
         fprintf(header, "%2u%s", _length_code[i],
                 SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
     }
 
     fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
@@ -376,13 +375,13 @@
 }
 #endif /* GEN_TREES_H */
 
 /* ===========================================================================
  * Initialize the tree data structures for a new zlib stream.
  */
-void _tr_init(s)
+void ZLIB_INTERNAL _tr_init(s)
     deflate_state *s;
 {
     tr_static_init();
 
     s->l_desc.dyn_tree = s->dyn_ltree;
     s->l_desc.stat_desc = &static_l_desc;
@@ -392,13 +391,12 @@
 
     s->bl_desc.dyn_tree = s->bl_tree;
     s->bl_desc.stat_desc = &static_bl_desc;
 
     s->bi_buf = 0;
     s->bi_valid = 0;
-    s->last_eob_len = 8; /* enough lookahead for inflate */
 #ifdef DEBUG
     s->compressed_len = 0L;
     s->bits_sent = 0L;
 #endif
 
     /* Initialize the first block of the first file: */
@@ -861,81 +859,69 @@
     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
 }
 
 /* ===========================================================================
  * Send a stored block
  */
-void _tr_stored_block(s, buf, stored_len, eof)
+void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
     deflate_state *s;
     charf *buf;       /* input block */
     ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
+    int last;         /* one if this is the last block for a file */
 {
-    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
+    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
 #ifdef DEBUG
     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
     s->compressed_len += (stored_len + 4) << 3;
 #endif
     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
 }
 
 /* ===========================================================================
+ * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
+ */
+void ZLIB_INTERNAL _tr_flush_bits(s)
+    deflate_state *s;
+{
+    bi_flush(s);
+}
+
+/* ===========================================================================
  * Send one empty static block to give enough lookahead for inflate.
  * This takes 10 bits, of which 7 may remain in the bit buffer.
- * The current inflate code requires 9 bits of lookahead. If the
- * last two codes for the previous block (real code plus EOB) were coded
- * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
- * the last real code. In this case we send two empty static blocks instead
- * of one. (There are no problems if the previous block is stored or fixed.)
- * To simplify the code, we assume the worst case of last real code encoded
- * on one bit only.
  */
-void _tr_align(s)
+void ZLIB_INTERNAL _tr_align(s)
     deflate_state *s;
 {
     send_bits(s, STATIC_TREES<<1, 3);
     send_code(s, END_BLOCK, static_ltree);
 #ifdef DEBUG
     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
 #endif
     bi_flush(s);
-    /* Of the 10 bits for the empty block, we have already sent
-     * (10 - bi_valid) bits. The lookahead for the last real code (before
-     * the EOB of the previous block) was thus at least one plus the length
-     * of the EOB plus what we have just sent of the empty static block.
-     */
-    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
-        send_bits(s, STATIC_TREES<<1, 3);
-        send_code(s, END_BLOCK, static_ltree);
-#ifdef DEBUG
-        s->compressed_len += 10L;
-#endif
-        bi_flush(s);
-    }
-    s->last_eob_len = 7;
 }
 
 /* ===========================================================================
  * Determine the best encoding for the current block: dynamic trees, static
  * trees or store, and output the encoded block to the zip file.
  */
-void _tr_flush_block(s, buf, stored_len, eof)
+void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
     deflate_state *s;
     charf *buf;       /* input block, or NULL if too old */
     ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
+    int last;         /* one if this is the last block for a file */
 {
     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
     int max_blindex = 0;  /* index of last bit length code of non zero freq */
 
     /* Build the Huffman trees unless a stored block is forced */
     if (s->level > 0) {
 
         /* Check if the file is binary or text */
-        if (stored_len > 0 && s->strm->data_type == Z_UNKNOWN)
-            set_data_type(s);
+        if (s->strm->data_type == Z_UNKNOWN)
+            s->strm->data_type = detect_data_type(s);
 
         /* Construct the literal and distance trees */
         build_tree(s, (tree_desc *)(&(s->l_desc)));
         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                 s->static_len));
 
@@ -975,54 +961,56 @@
         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
          * Otherwise we can't have processed more than WSIZE input bytes since
          * the last block flush, because compression would have been
          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
          * transform a block into a stored block.
          */
-        _tr_stored_block(s, buf, stored_len, eof);
+        _tr_stored_block(s, buf, stored_len, last);
 
 #ifdef FORCE_STATIC
     } else if (static_lenb >= 0) { /* force static trees */
 #else
     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
 #endif
-        send_bits(s, (STATIC_TREES<<1)+eof, 3);
-        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
+        send_bits(s, (STATIC_TREES<<1)+last, 3);
+        compress_block(s, (const ct_data *)static_ltree,
+                       (const ct_data *)static_dtree);
 #ifdef DEBUG
         s->compressed_len += 3 + s->static_len;
 #endif
     } else {
-        send_bits(s, (DYN_TREES<<1)+eof, 3);
+        send_bits(s, (DYN_TREES<<1)+last, 3);
         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                        max_blindex+1);
-        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
+        compress_block(s, (const ct_data *)s->dyn_ltree,
+                       (const ct_data *)s->dyn_dtree);
 #ifdef DEBUG
         s->compressed_len += 3 + s->opt_len;
 #endif
     }
     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
     /* The above check is made mod 2^32, for files larger than 512 MB
      * and uLong implemented on 32 bits.
      */
     init_block(s);
 
-    if (eof) {
+    if (last) {
         bi_windup(s);
 #ifdef DEBUG
         s->compressed_len += 7;  /* align on byte boundary */
 #endif
     }
     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
-           s->compressed_len-7*eof));
+           s->compressed_len-7*last));
 }
 
 /* ===========================================================================
  * Save the match info and tally the frequency counts. Return true if
  * the current block must be flushed.
  */
-int _tr_tally (s, dist, lc)
+int ZLIB_INTERNAL _tr_tally (s, dist, lc)
     deflate_state *s;
     unsigned dist;  /* distance of matched string */
     unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
 {
     s->d_buf[s->last_lit] = (ush)dist;
     s->l_buf[s->last_lit++] = (uch)lc;
@@ -1068,14 +1056,14 @@
 
 /* ===========================================================================
  * Send the block data compressed using the given Huffman trees
  */
 local void compress_block(s, ltree, dtree)
     deflate_state *s;
-    ct_data *ltree; /* literal tree */
-    ct_data *dtree; /* distance tree */
+    const ct_data *ltree; /* literal tree */
+    const ct_data *dtree; /* distance tree */
 {
     unsigned dist;      /* distance of matched string */
     int lc;             /* match length or unmatched char (if dist == 0) */
     unsigned lx = 0;    /* running index in l_buf */
     unsigned code;      /* the code to send */
     int extra;          /* number of extra bits to send */
@@ -1111,34 +1099,54 @@
         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
                "pendingBuf overflow");
 
     } while (lx < s->last_lit);
 
     send_code(s, END_BLOCK, ltree);
-    s->last_eob_len = ltree[END_BLOCK].Len;
 }
 
 /* ===========================================================================
- * Set the data type to BINARY or TEXT, using a crude approximation:
- * set it to Z_TEXT if all symbols are either printable characters (33 to 255)
- * or white spaces (9 to 13, or 32); or set it to Z_BINARY otherwise.
+ * Check if the data type is TEXT or BINARY, using the following algorithm:
+ * - TEXT if the two conditions below are satisfied:
+ *    a) There are no non-portable control characters belonging to the
+ *       "black list" (0..6, 14..25, 28..31).
+ *    b) There is at least one printable character belonging to the
+ *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
+ * - BINARY otherwise.
+ * - The following partially-portable control characters form a
+ *   "gray list" that is ignored in this detection algorithm:
+ *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
  * IN assertion: the fields Freq of dyn_ltree are set.
  */
-local void set_data_type(s)
+local int detect_data_type(s)
     deflate_state *s;
 {
+    /* black_mask is the bit mask of black-listed bytes
+     * set bits 0..6, 14..25, and 28..31
+     * 0xf3ffc07f = binary 11110011111111111100000001111111
+     */
+    unsigned long black_mask = 0xf3ffc07fUL;
     int n;
 
-    for (n = 0; n < 9; n++)
+    /* Check for non-textual ("black-listed") bytes. */
+    for (n = 0; n <= 31; n++, black_mask >>= 1)
+        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
+            return Z_BINARY;
+
+    /* Check for textual ("white-listed") bytes. */
+    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
+            || s->dyn_ltree[13].Freq != 0)
+        return Z_TEXT;
+    for (n = 32; n < LITERALS; n++)
         if (s->dyn_ltree[n].Freq != 0)
-            break;
-    if (n == 9)
-        for (n = 14; n < 32; n++)
-            if (s->dyn_ltree[n].Freq != 0)
-                break;
-    s->strm->data_type = (n == 32) ? Z_TEXT : Z_BINARY;
+            return Z_TEXT;
+
+    /* There are no "black-listed" or "white-listed" bytes:
+     * this stream either is empty or has tolerated ("gray-listed") bytes only.
+     */
+    return Z_BINARY;
 }
 
 /* ===========================================================================
  * Reverse the first len bits of a code, using straightforward code (a faster
  * method would use a table)
  * IN assertion: 1 <= len <= 15
@@ -1198,13 +1206,12 @@
     deflate_state *s;
     charf    *buf;    /* the input data */
     unsigned len;     /* its length */
     int      header;  /* true if block header must be written */
 {
     bi_windup(s);        /* align on byte boundary */
-    s->last_eob_len = 8; /* enough lookahead for inflate */
 
     if (header) {
         put_short(s, (ush)len);
         put_short(s, (ush)~len);
 #ifdef DEBUG
         s->bits_sent += 2*16;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/trees.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/trees.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/trees.h	1998-05-07 14:19:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/trees.h	2013-06-10 13:27:33.000000000 +0800
@@ -67,13 +67,13 @@
 {{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
 {{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
 {{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
 {{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
 };
 
-const uch _dist_code[DIST_CODE_LEN] = {
+const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
  0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
@@ -96,13 +96,13 @@
 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
 };
 
-const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
+const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
  0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/zconf.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/zconf.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/zconf.h	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/zconf.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,65 +1,158 @@
 /* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * Copyright (C) 1995-2013 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* @(#) $Id$ */
 
 #ifndef ZCONF_H
 #define ZCONF_H
 
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ * Even better than compiling with -DZ_PREFIX would be to use configure to set
+ * this permanently in zconf.h using "./configure --zprefix".
  */
-#ifdef Z_PREFIX
-#  define deflateInit_          z_deflateInit_
+#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
+#  define Z_PREFIX_SET
+
+/* all linked symbols */
+#  define _dist_code            z__dist_code
+#  define _length_code          z__length_code
+#  define _tr_align             z__tr_align
+#  define _tr_flush_bits        z__tr_flush_bits
+#  define _tr_flush_block       z__tr_flush_block
+#  define _tr_init              z__tr_init
+#  define _tr_stored_block      z__tr_stored_block
+#  define _tr_tally             z__tr_tally
+#  define adler32               z_adler32
+#  define adler32_combine       z_adler32_combine
+#  define adler32_combine64     z_adler32_combine64
+#  ifndef Z_SOLO
+#    define compress              z_compress
+#    define compress2             z_compress2
+#    define compressBound         z_compressBound
+#  endif
+#  define crc32                 z_crc32
+#  define crc32_combine         z_crc32_combine
+#  define crc32_combine64       z_crc32_combine64
 #  define deflate               z_deflate
+#  define deflateBound          z_deflateBound
+#  define deflateCopy           z_deflateCopy
 #  define deflateEnd            z_deflateEnd
-#  define inflateInit_          z_inflateInit_
-#  define inflate               z_inflate
-#  define inflateEnd            z_inflateEnd
 #  define deflateInit2_         z_deflateInit2_
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateCopy           z_deflateCopy
-#  define deflateReset          z_deflateReset
+#  define deflateInit_          z_deflateInit_
 #  define deflateParams         z_deflateParams
-#  define deflateBound          z_deflateBound
+#  define deflatePending        z_deflatePending
 #  define deflatePrime          z_deflatePrime
+#  define deflateReset          z_deflateReset
+#  define deflateResetKeep      z_deflateResetKeep
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateSetHeader      z_deflateSetHeader
+#  define deflateTune           z_deflateTune
+#  define deflate_copyright     z_deflate_copyright
+#  define get_crc_table         z_get_crc_table
+#  ifndef Z_SOLO
+#    define gz_error              z_gz_error
+#    define gz_intmax             z_gz_intmax
+#    define gz_strwinerror        z_gz_strwinerror
+#    define gzbuffer              z_gzbuffer
+#    define gzclearerr            z_gzclearerr
+#    define gzclose               z_gzclose
+#    define gzclose_r             z_gzclose_r
+#    define gzclose_w             z_gzclose_w
+#    define gzdirect              z_gzdirect
+#    define gzdopen               z_gzdopen
+#    define gzeof                 z_gzeof
+#    define gzerror               z_gzerror
+#    define gzflush               z_gzflush
+#    define gzgetc                z_gzgetc
+#    define gzgetc_               z_gzgetc_
+#    define gzgets                z_gzgets
+#    define gzoffset              z_gzoffset
+#    define gzoffset64            z_gzoffset64
+#    define gzopen                z_gzopen
+#    define gzopen64              z_gzopen64
+#    ifdef _WIN32
+#      define gzopen_w              z_gzopen_w
+#    endif
+#    define gzprintf              z_gzprintf
+#    define gzvprintf             z_gzvprintf
+#    define gzputc                z_gzputc
+#    define gzputs                z_gzputs
+#    define gzread                z_gzread
+#    define gzrewind              z_gzrewind
+#    define gzseek                z_gzseek
+#    define gzseek64              z_gzseek64
+#    define gzsetparams           z_gzsetparams
+#    define gztell                z_gztell
+#    define gztell64              z_gztell64
+#    define gzungetc              z_gzungetc
+#    define gzwrite               z_gzwrite
+#  endif
+#  define inflate               z_inflate
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define inflateBackInit_      z_inflateBackInit_
+#  define inflateCopy           z_inflateCopy
+#  define inflateEnd            z_inflateEnd
+#  define inflateGetHeader      z_inflateGetHeader
 #  define inflateInit2_         z_inflateInit2_
+#  define inflateInit_          z_inflateInit_
+#  define inflateMark           z_inflateMark
+#  define inflatePrime          z_inflatePrime
+#  define inflateReset          z_inflateReset
+#  define inflateReset2         z_inflateReset2
 #  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateGetDictionary  z_inflateGetDictionary
 #  define inflateSync           z_inflateSync
 #  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateCopy           z_inflateCopy
-#  define inflateReset          z_inflateReset
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define compress              z_compress
-#  define compress2             z_compress2
-#  define compressBound         z_compressBound
-#  define uncompress            z_uncompress
-#  define adler32               z_adler32
-#  define crc32                 z_crc32
-#  define get_crc_table         z_get_crc_table
+#  define inflateUndermine      z_inflateUndermine
+#  define inflateResetKeep      z_inflateResetKeep
+#  define inflate_copyright     z_inflate_copyright
+#  define inflate_fast          z_inflate_fast
+#  define inflate_table         z_inflate_table
+#  ifndef Z_SOLO
+#    define uncompress            z_uncompress
+#  endif
 #  define zError                z_zError
+#  ifndef Z_SOLO
+#    define zcalloc               z_zcalloc
+#    define zcfree                z_zcfree
+#  endif
+#  define zlibCompileFlags      z_zlibCompileFlags
+#  define zlibVersion           z_zlibVersion
 
+/* all zlib typedefs in zlib.h and zconf.h */
+#  define Byte                  z_Byte
+#  define Bytef                 z_Bytef
 #  define alloc_func            z_alloc_func
+#  define charf                 z_charf
 #  define free_func             z_free_func
+#  ifndef Z_SOLO
+#    define gzFile                z_gzFile
+#  endif
+#  define gz_header             z_gz_header
+#  define gz_headerp            z_gz_headerp
 #  define in_func               z_in_func
+#  define intf                  z_intf
 #  define out_func              z_out_func
-#  define Byte                  z_Byte
 #  define uInt                  z_uInt
-#  define uLong                 z_uLong
-#  define Bytef                 z_Bytef
-#  define charf                 z_charf
-#  define intf                  z_intf
 #  define uIntf                 z_uIntf
+#  define uLong                 z_uLong
 #  define uLongf                z_uLongf
-#  define voidpf                z_voidpf
 #  define voidp                 z_voidp
+#  define voidpc                z_voidpc
+#  define voidpf                z_voidpf
+
+/* all zlib structs in zlib.h and zconf.h */
+#  define gz_header_s           z_gz_header_s
+#  define internal_state        z_internal_state
+
 #endif
 
 #if defined(__MSDOS__) && !defined(MSDOS)
 #  define MSDOS
 #endif
 #if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
@@ -122,12 +215,18 @@
 #ifndef STDC
 #  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
 #    define const       /* note: need a more gentle solution here */
 #  endif
 #endif
 
+#if defined(ZLIB_CONST) && !defined(z_const)
+#  define z_const const
+#else
+#  define z_const
+#endif
+
 /* Some Mac compilers merge all .h files incorrectly: */
 #if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
 #  define NO_DUMMY_DECL
 #endif
 
 /* Maximum value for memLevel in deflateInit2 */
@@ -168,12 +267,20 @@
 #    define OF(args)  args
 #  else
 #    define OF(args)  ()
 #  endif
 #endif
 
+#ifndef Z_ARG /* function prototypes for stdarg */
+#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
+#    define Z_ARG(args)  args
+#  else
+#    define Z_ARG(args)  ()
+#  endif
+#endif
+
 /* The following definitions for FAR are needed only for MSDOS mixed
  * model programming (small or medium model with some far allocations).
  * This was tested only with MSC; for other MSDOS compilers you may have
  * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
  * just define FAR to be empty.
  */
@@ -281,52 +388,124 @@
 #else
    typedef Byte const *voidpc;
    typedef Byte FAR   *voidpf;
    typedef Byte       *voidp;
 #endif
 
-#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
-#  include <sys/types.h> /* for off_t */
-#  include <unistd.h>    /* for SEEK_* and off_t */
-#  ifdef VMS
-#    include <unixio.h>   /* for off_t */
+#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
+#  include <limits.h>
+#  if (UINT_MAX == 0xffffffffUL)
+#    define Z_U4 unsigned
+#  elif (ULONG_MAX == 0xffffffffUL)
+#    define Z_U4 unsigned long
+#  elif (USHRT_MAX == 0xffffffffUL)
+#    define Z_U4 unsigned short
+#  endif
+#endif
+
+#ifdef Z_U4
+   typedef Z_U4 z_crc_t;
+#else
+   typedef unsigned long z_crc_t;
+#endif
+
+#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
+#  define Z_HAVE_UNISTD_H
+#endif
+
+#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
+#  define Z_HAVE_STDARG_H
+#endif
+
+#ifdef STDC
+#  ifndef Z_SOLO
+#    include <sys/types.h>      /* for off_t */
+#  endif
+#endif
+
+#if defined(STDC) || defined(Z_HAVE_STDARG_H)
+#  ifndef Z_SOLO
+#    include <stdarg.h>         /* for va_list */
+#  endif
+#endif
+
+#ifdef _WIN32
+#  ifndef Z_SOLO
+#    include <stddef.h>         /* for wchar_t */
+#  endif
+#endif
+
+/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
+ * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
+ * though the former does not conform to the LFS document), but considering
+ * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
+ * equivalently requesting no 64-bit operations
+ */
+#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
+#  undef _LARGEFILE64_SOURCE
+#endif
+
+#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
+#  define Z_HAVE_UNISTD_H
+#endif
+#ifndef Z_SOLO
+#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
+#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
+#    ifdef VMS
+#      include <unixio.h>       /* for off_t */
+#    endif
+#    ifndef z_off_t
+#      define z_off_t off_t
+#    endif
 #  endif
-#  define z_off_t off_t
 #endif
-#ifndef SEEK_SET
+
+#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
+#  define Z_LFS64
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
+#  define Z_LARGE64
+#endif
+
+#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
+#  define Z_WANT64
+#endif
+
+#if !defined(SEEK_SET) && !defined(Z_SOLO)
 #  define SEEK_SET        0       /* Seek from beginning of file.  */
 #  define SEEK_CUR        1       /* Seek from current position.  */
 #  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
 #endif
+
 #ifndef z_off_t
 #  define z_off_t long
 #endif
 
-#if defined(__OS400__)
-#  define NO_vsnprintf
-#endif
-
-#if defined(__MVS__)
-#  define NO_vsnprintf
-#  ifdef FAR
-#    undef FAR
+#if !defined(_WIN32) && defined(Z_LARGE64)
+#  define z_off64_t off64_t
+#else
+#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
+#    define z_off64_t __int64
+#  else
+#    define z_off64_t z_off_t
 #  endif
 #endif
 
 /* MVS linker does not support external names larger than 8 bytes */
 #if defined(__MVS__)
-#   pragma map(deflateInit_,"DEIN")
-#   pragma map(deflateInit2_,"DEIN2")
-#   pragma map(deflateEnd,"DEEND")
-#   pragma map(deflateBound,"DEBND")
-#   pragma map(inflateInit_,"ININ")
-#   pragma map(inflateInit2_,"ININ2")
-#   pragma map(inflateEnd,"INEND")
-#   pragma map(inflateSync,"INSY")
-#   pragma map(inflateSetDictionary,"INSEDI")
-#   pragma map(compressBound,"CMBND")
-#   pragma map(inflate_table,"INTABL")
-#   pragma map(inflate_fast,"INFA")
-#   pragma map(inflate_copyright,"INCOPY")
+  #pragma map(deflateInit_,"DEIN")
+  #pragma map(deflateInit2_,"DEIN2")
+  #pragma map(deflateEnd,"DEEND")
+  #pragma map(deflateBound,"DEBND")
+  #pragma map(inflateInit_,"ININ")
+  #pragma map(inflateInit2_,"ININ2")
+  #pragma map(inflateEnd,"INEND")
+  #pragma map(inflateSync,"INSY")
+  #pragma map(inflateSetDictionary,"INSEDI")
+  #pragma map(compressBound,"CMBND")
+  #pragma map(inflate_table,"INTABL")
+  #pragma map(inflate_fast,"INFA")
+  #pragma map(inflate_copyright,"INCOPY")
 #endif
 
 #endif /* ZCONF_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/zlib.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/zlib.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/zlib.h	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/zlib.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,10 +1,10 @@
 /* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.3, July 18th, 2005
+  version 1.2.8, April 28th, 2013
 
-  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
+  Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler
 
   This software is provided 'as-is', without any express or implied
   warranty.  In no event will the authors be held liable for any damages
   arising from the use of this software.
 
   Permission is granted to anyone to use this software for any purpose,
@@ -21,77 +21,80 @@
 
   Jean-loup Gailly        Mark Adler
   jloup@gzip.org          madler@alumni.caltech.edu
 
 
   The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
-  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
+  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
 */
 
 #ifndef ZLIB_H
 #define ZLIB_H
 
 #include "zconf.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#define ZLIB_VERSION "1.2.3"
-#define ZLIB_VERNUM 0x1230
-
-/*
-     The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed
-  data.  This version of the library supports only one compression method
-  (deflation) but other algorithms will be added later and will have the same
-  stream interface.
-
-     Compression can be done in a single step if the buffers are large
-  enough (for example if an input file is mmap'ed), or can be done by
-  repeated calls of the compression function.  In the latter case, the
-  application must provide more input and/or consume the output
+#define ZLIB_VERSION "1.2.8"
+#define ZLIB_VERNUM 0x1280
+#define ZLIB_VER_MAJOR 1
+#define ZLIB_VER_MINOR 2
+#define ZLIB_VER_REVISION 8
+#define ZLIB_VER_SUBREVISION 0
+
+/*
+    The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed data.
+  This version of the library supports only one compression method (deflation)
+  but other algorithms will be added later and will have the same stream
+  interface.
+
+    Compression can be done in a single step if the buffers are large enough,
+  or can be done by repeated calls of the compression function.  In the latter
+  case, the application must provide more input and/or consume the output
   (providing more output space) before each call.
 
-     The compressed data format used by default by the in-memory functions is
+    The compressed data format used by default by the in-memory functions is
   the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
   around a deflate stream, which is itself documented in RFC 1951.
 
-     The library also supports reading and writing files in gzip (.gz) format
+    The library also supports reading and writing files in gzip (.gz) format
   with an interface similar to that of stdio using the functions that start
   with "gz".  The gzip format is different from the zlib format.  gzip is a
   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
 
-     This library can optionally read and write gzip streams in memory as well.
+    This library can optionally read and write gzip streams in memory as well.
 
-     The zlib format was designed to be compact and fast for use in memory
+    The zlib format was designed to be compact and fast for use in memory
   and on communications channels.  The gzip format was designed for single-
   file compression on file systems, has a larger header than zlib to maintain
   directory information, and uses a different, slower check method than zlib.
 
-     The library does not install any signal handler. The decoder checks
-  the consistency of the compressed data, so the library should never
-  crash even in case of corrupted input.
+    The library does not install any signal handler.  The decoder checks
+  the consistency of the compressed data, so the library should never crash
+  even in case of corrupted input.
 */
 
 typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
 typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
 
 struct internal_state;
 
 typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
+    z_const Bytef *next_in;     /* next input byte */
     uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total nb of input bytes read so far */
+    uLong    total_in;  /* total number of input bytes read so far */
 
     Bytef    *next_out; /* next output byte should be put there */
     uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total nb of bytes output so far */
+    uLong    total_out; /* total number of bytes output so far */
 
-    char     *msg;      /* last error message, NULL if no error */
+    z_const char *msg;  /* last error message, NULL if no error */
     struct internal_state FAR *state; /* not visible by applications */
 
     alloc_func zalloc;  /* used to allocate the internal state */
     free_func  zfree;   /* used to free the internal state */
     voidpf     opaque;  /* private data object passed to zalloc and zfree */
 
@@ -123,65 +126,65 @@
                            when writing a gzip file) */
 } gz_header;
 
 typedef gz_header FAR *gz_headerp;
 
 /*
-   The application must update next_in and avail_in when avail_in has
-   dropped to zero. It must update next_out and avail_out when avail_out
-   has dropped to zero. The application must initialize zalloc, zfree and
-   opaque before calling the init function. All other fields are set by the
-   compression library and must not be updated by the application.
-
-   The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree. This can be useful for custom
-   memory management. The compression library attaches no meaning to the
+     The application must update next_in and avail_in when avail_in has dropped
+   to zero.  It must update next_out and avail_out when avail_out has dropped
+   to zero.  The application must initialize zalloc, zfree and opaque before
+   calling the init function.  All other fields are set by the compression
+   library and must not be updated by the application.
+
+     The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree.  This can be useful for custom
+   memory management.  The compression library attaches no meaning to the
    opaque value.
 
-   zalloc must return Z_NULL if there is not enough memory for the object.
+     zalloc must return Z_NULL if there is not enough memory for the object.
    If zlib is used in a multi-threaded application, zalloc and zfree must be
    thread safe.
 
-   On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this
-   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
-   pointers returned by zalloc for objects of exactly 65536 bytes *must*
-   have their offset normalized to zero. The default allocation function
-   provided by this library ensures this (see zutil.c). To reduce memory
-   requirements and avoid any allocation of 64K objects, at the expense of
-   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
-
-   The fields total_in and total_out can be used for statistics or
-   progress reports. After compression, total_in holds the total size of
-   the uncompressed data and may be saved for use in the decompressor
-   (particularly if the decompressor wants to decompress everything in
-   a single step).
+     On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this if
+   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
+   returned by zalloc for objects of exactly 65536 bytes *must* have their
+   offset normalized to zero.  The default allocation function provided by this
+   library ensures this (see zutil.c).  To reduce memory requirements and avoid
+   any allocation of 64K objects, at the expense of compression ratio, compile
+   the library with -DMAX_WBITS=14 (see zconf.h).
+
+     The fields total_in and total_out can be used for statistics or progress
+   reports.  After compression, total_in holds the total size of the
+   uncompressed data and may be saved for use in the decompressor (particularly
+   if the decompressor wants to decompress everything in a single step).
 */
 
                         /* constants */
 
 #define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_PARTIAL_FLUSH 1
 #define Z_SYNC_FLUSH    2
 #define Z_FULL_FLUSH    3
 #define Z_FINISH        4
 #define Z_BLOCK         5
+#define Z_TREES         6
 /* Allowed flush values; see deflate() and inflate() below for details */
-#define Z_INSERT_ONLY	6
+#define Z_INSERT_ONLY	7
 
 #define Z_OK            0
 #define Z_STREAM_END    1
 #define Z_NEED_DICT     2
 #define Z_ERRNO        (-1)
 #define Z_STREAM_ERROR (-2)
 #define Z_DATA_ERROR   (-3)
 #define Z_MEM_ERROR    (-4)
 #define Z_BUF_ERROR    (-5)
 #define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative
- * values are errors, positive values are used for special but normal events.
+/* Return codes for the compression/decompression functions. Negative values
+ * are errors, positive values are used for special but normal events.
  */
 
 #define Z_NO_COMPRESSION         0
 #define Z_BEST_SPEED             1
 #define Z_BEST_COMPRESSION       9
 #define Z_DEFAULT_COMPRESSION  (-1)
@@ -205,275 +208,319 @@
 
 #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
 
 #define zlib_version zlibVersion()
 /* for compatibility with versions < 1.0.2 */
 
+
                         /* basic functions */
 
 ZEXTERN const char * ZEXPORT zlibVersion OF((void));
 /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is
-   not compatible with the zlib.h header file used by the application.
-   This check is automatically made by deflateInit and inflateInit.
+   If the first character differs, the library code actually used is not
+   compatible with the zlib.h header file used by the application.  This check
+   is automatically made by deflateInit and inflateInit.
  */
 
 /*
 ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
 
-     Initializes the internal stream state for compression. The fields
-   zalloc, zfree and opaque must be initialized before by the caller.
-   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
-   use default allocation functions.
+     Initializes the internal stream state for compression.  The fields
+   zalloc, zfree and opaque must be initialized before by the caller.  If
+   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
+   allocation functions.
 
      The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at
-   all (the input data is simply copied a block at a time).
-   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
-   compression (currently equivalent to level 6).
+   1 gives best speed, 9 gives best compression, 0 gives no compression at all
+   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
+   requests a default compromise between speed and compression (currently
+   equivalent to level 6).
 
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if level is not a valid compression level, or
    Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).
-   msg is set to null if there is no error message.  deflateInit does not
-   perform any compression: this will be done by deflate().
+   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
+   if there is no error message.  deflateInit does not perform any compression:
+   this will be done by deflate().
 */
 
 
 ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
 /*
     deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may introduce some
-  output latency (reading input without producing any output) except when
+  buffer becomes empty or the output buffer becomes full.  It may introduce
+  some output latency (reading input without producing any output) except when
   forced to flush.
 
-    The detailed semantics are as follows. deflate performs one or both of the
+    The detailed semantics are as follows.  deflate performs one or both of the
   following actions:
 
   - Compress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
+    accordingly.  If not all input can be processed (because there is not
     enough room in the output buffer), next_in and avail_in are updated and
     processing will resume at this point for the next call of deflate().
 
   - Provide more output starting at next_out and update next_out and avail_out
-    accordingly. This action is forced if the parameter flush is non zero.
+    accordingly.  This action is forced if the parameter flush is non zero.
     Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).
-    Some output may be provided even if flush is not set.
+    should be set only when necessary (in interactive applications).  Some
+    output may be provided even if flush is not set.
 
-  Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating avail_in or avail_out accordingly; avail_out
-  should never be zero before the call. The application can consume the
-  compressed output when it wants, for example when the output buffer is full
-  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
-  and with zero avail_out, it must be called again after making room in the
-  output buffer because there might be more output pending.
+    Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming more
+  output, and updating avail_in or avail_out accordingly; avail_out should
+  never be zero before the call.  The application can consume the compressed
+  output when it wants, for example when the output buffer is full (avail_out
+  == 0), or after each call of deflate().  If deflate returns Z_OK and with
+  zero avail_out, it must be called again after making room in the output
+  buffer because there might be more output pending.
 
     Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumualte before producing output, in order to
+  decide how much data to accumulate before producing output, in order to
   maximize compression.
 
     If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
   flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far. (In particular
-  avail_in is zero after the call if enough output space has been provided
-  before the call.)  Flushing may degrade compression for some compression
-  algorithms and so it should be used only when necessary.
+  that the decompressor can get all input data available so far.  (In
+  particular avail_in is zero after the call if enough output space has been
+  provided before the call.) Flushing may degrade compression for some
+  compression algorithms and so it should be used only when necessary.  This
+  completes the current deflate block and follows it with an empty stored block
+  that is three bits plus filler bits to the next byte, followed by four bytes
+  (00 00 ff ff).
+
+    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
+  output buffer, but the output is not aligned to a byte boundary.  All of the
+  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
+  This completes the current deflate block and follows it with an empty fixed
+  codes block that is 10 bits long.  This assures that enough bytes are output
+  in order for the decompressor to finish the block before the empty fixed code
+  block.
+
+    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
+  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
+  seven bits of the current block are held to be written as the next byte after
+  the next deflate block is completed.  In this case, the decompressor may not
+  be provided enough bits at this point in order to complete decompression of
+  the data provided so far to the compressor.  It may need to wait for the next
+  block to be emitted.  This is for advanced applications that need to control
+  the emission of deflate blocks.
 
     If flush is set to Z_FULL_FLUSH, all output is flushed as with
   Z_SYNC_FLUSH, and the compression state is reset so that decompression can
   restart from this point if previous compressed data has been damaged or if
-  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
   compression.
 
     If deflate returns with avail_out == 0, this function must be called again
   with the same value of the flush parameter and more output space (updated
   avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
   avail_out is greater than six to avoid repeated flush markers due to
   avail_out == 0 on return.
 
     If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there
-  was enough output space; if deflate returns with Z_OK, this function must be
+  pending output is flushed and deflate returns with Z_STREAM_END if there was
+  enough output space; if deflate returns with Z_OK, this function must be
   called again with Z_FINISH and more output space (updated avail_out) but no
-  more input data, until it returns with Z_STREAM_END or an error. After
-  deflate has returned Z_STREAM_END, the only possible operations on the
-  stream are deflateReset or deflateEnd.
+  more input data, until it returns with Z_STREAM_END or an error.  After
+  deflate has returned Z_STREAM_END, the only possible operations on the stream
+  are deflateReset or deflateEnd.
 
     Z_FINISH can be used immediately after deflateInit if all the compression
-  is to be done in a single step. In this case, avail_out must be at least
-  the value returned by deflateBound (see below). If deflate does not return
-  Z_STREAM_END, then it must be called again as described above.
+  is to be done in a single step.  In this case, avail_out must be at least the
+  value returned by deflateBound (see below).  Then deflate is guaranteed to
+  return Z_STREAM_END.  If not enough output space is provided, deflate will
+  not return Z_STREAM_END, and it must be called again as described above.
 
     deflate() sets strm->adler to the adler32 checksum of all input read
   so far (that is, total_in bytes).
 
     deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered
-  binary. This field is only for information purposes and does not affect
-  the compression algorithm in any manner.
+  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered
+  binary.  This field is only for information purposes and does not affect the
+  compression algorithm in any manner.
 
     deflate() returns Z_OK if some progress has been made (more input
   processed or more output produced), Z_STREAM_END if all input has been
   consumed and all output has been produced (only when flush is set to
   Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
-  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
+  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
   fatal, and deflate() can be called again with more input and more output
   space to continue compressing.
 */
 
 
 ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
 /*
      All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
+   This function discards any unprocessed input and does not flush any pending
+   output.
 
      deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
    stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded). In the error case,
-   msg may be set but then points to a static string (which must not be
+   prematurely (some input or output was discarded).  In the error case, msg
+   may be set but then points to a static string (which must not be
    deallocated).
 */
 
 
 /*
 ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
 
-     Initializes the internal stream state for decompression. The fields
+     Initializes the internal stream state for decompression.  The fields
    next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
-   value depends on the compression method), inflateInit determines the
+   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
+   exact value depends on the compression method), inflateInit determines the
    compression method from the zlib header and allocates all data structures
    accordingly; otherwise the allocation will be deferred to the first call of
    inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
    use default allocation functions.
 
      inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
    memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller.  msg is set to null if there is no error
-   message. inflateInit does not perform any decompression apart from reading
-   the zlib header if present: this will be done by inflate().  (So next_in and
-   avail_in may be modified, but next_out and avail_out are unchanged.)
+   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
+   invalid, such as a null pointer to the structure.  msg is set to null if
+   there is no error message.  inflateInit does not perform any decompression
+   apart from possibly reading the zlib header if present: actual decompression
+   will be done by inflate().  (So next_in and avail_in may be modified, but
+   next_out and avail_out are unused and unchanged.) The current implementation
+   of inflateInit() does not process any header information -- that is deferred
+   until inflate() is called.
 */
 
 
 ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
 /*
     inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may introduce
+  buffer becomes empty or the output buffer becomes full.  It may introduce
   some output latency (reading input without producing any output) except when
   forced to flush.
 
-  The detailed semantics are as follows. inflate performs one or both of the
+  The detailed semantics are as follows.  inflate performs one or both of the
   following actions:
 
   - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing
-    will resume at this point for the next call of inflate().
+    accordingly.  If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing will
+    resume at this point for the next call of inflate().
 
   - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there
-    is no more input data or no more space in the output buffer (see below
-    about the flush parameter).
-
-  Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating the next_* and avail_* values accordingly.
-  The application can consume the uncompressed output when it wants, for
-  example when the output buffer is full (avail_out == 0), or after each
-  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
-  must be called again after making room in the output buffer because there
-  might be more output pending.
-
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
-  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
-  if and when it gets to the next deflate block boundary. When decoding the
-  zlib or gzip format, this will cause inflate() to return immediately after
-  the header and before the first block. When doing a raw inflate, inflate()
-  will go ahead and process the first block, and will return when it gets to
-  the end of that block, or when it runs out of data.
+    accordingly.  inflate() provides as much output as possible, until there is
+    no more input data or no more space in the output buffer (see below about
+    the flush parameter).
+
+    Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming more
+  output, and updating the next_* and avail_* values accordingly.  The
+  application can consume the uncompressed output when it wants, for example
+  when the output buffer is full (avail_out == 0), or after each call of
+  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
+  called again after making room in the output buffer because there might be
+  more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
+  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer.  Z_BLOCK requests that inflate()
+  stop if and when it gets to the next deflate block boundary.  When decoding
+  the zlib or gzip format, this will cause inflate() to return immediately
+  after the header and before the first block.  When doing a raw inflate,
+  inflate() will go ahead and process the first block, and will return when it
+  gets to the end of that block, or when it runs out of data.
 
     The Z_BLOCK option assists in appending to or combining deflate streams.
   Also to assist in this, on return inflate() will set strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64
-  if inflate() is currently decoding the last block in the deflate stream,
-  plus 128 if inflate() returned immediately after decoding an end-of-block
-  code or decoding the complete header up to just before the first byte of the
-  deflate stream. The end-of-block will not be indicated until all of the
-  uncompressed data from that block has been written to strm->next_out.  The
-  number of unused bits may in general be greater than seven, except when
-  bit 7 of data_type is set, in which case the number of unused bits will be
-  less than eight.
+  number of unused bits in the last byte taken from strm->next_in, plus 64 if
+  inflate() is currently decoding the last block in the deflate stream, plus
+  128 if inflate() returned immediately after decoding an end-of-block code or
+  decoding the complete header up to just before the first byte of the deflate
+  stream.  The end-of-block will not be indicated until all of the uncompressed
+  data from that block has been written to strm->next_out.  The number of
+  unused bits may in general be greater than seven, except when bit 7 of
+  data_type is set, in which case the number of unused bits will be less than
+  eight.  data_type is set as noted here every time inflate() returns for all
+  flush options, and so can be used to determine the amount of currently
+  consumed input in bits.
+
+    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
+  end of each deflate block header is reached, before any actual data in that
+  block is decoded.  This allows the caller to determine the length of the
+  deflate block header for later use in random access within a deflate block.
+  256 is added to the value of strm->data_type when inflate() returns
+  immediately after reaching the end of the deflate block header.
 
     inflate() should normally be called until it returns Z_STREAM_END or an
-  error. However if all decompression is to be performed in a single step
-  (a single call of inflate), the parameter flush should be set to
-  Z_FINISH. In this case all pending input is processed and all pending
-  output is flushed; avail_out must be large enough to hold all the
-  uncompressed data. (The size of the uncompressed data may have been saved
-  by the compressor for this purpose.) The next operation on this stream must
-  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
-  is never required, but can be used to inform inflate that a faster approach
-  may be used for the single inflate() call.
+  error.  However if all decompression is to be performed in a single step (a
+  single call of inflate), the parameter flush should be set to Z_FINISH.  In
+  this case all pending input is processed and all pending output is flushed;
+  avail_out must be large enough to hold all of the uncompressed data for the
+  operation to complete.  (The size of the uncompressed data may have been
+  saved by the compressor for this purpose.) The use of Z_FINISH is not
+  required to perform an inflation in one step.  However it may be used to
+  inform inflate that a faster approach can be used for the single inflate()
+  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
+  stream completes, which reduces inflate's memory footprint.  If the stream
+  does not complete, either because not all of the stream is provided or not
+  enough output space is provided, then a sliding window will be allocated and
+  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
+  been used.
 
      In this implementation, inflate() always flushes as much output as
   possible to the output buffer, and always uses the faster approach on the
-  first call. So the only effect of the flush parameter in this implementation
-  is on the return value of inflate(), as noted below, or when it returns early
-  because Z_BLOCK is used.
+  first call.  So the effects of the flush parameter in this implementation are
+  on the return value of inflate() as noted below, when inflate() returns early
+  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
+  memory for a sliding window when Z_FINISH is used.
 
      If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the adler32 checksum of the dictionary
+  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
   chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the adler32 checksum of all output produced so far (that is,
+  strm->adler to the Adler-32 checksum of all output produced so far (that is,
   total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below. At the end of the stream, inflate() checks that its computed adler32
+  below.  At the end of the stream, inflate() checks that its computed adler32
   checksum is equal to that saved by the compressor and returns Z_STREAM_END
   only if the checksum is correct.
 
-    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically.  Any information
-  contained in the gzip header is not retained, so applications that need that
-  information should instead use raw inflate, see inflateInit2() below, or
-  inflateBack() and perform their own processing of the gzip header and
-  trailer.
+    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically, if requested when
+  initializing with inflateInit2().  Any information contained in the gzip
+  header is not retained, so applications that need that information should
+  instead use raw inflate, see inflateInit2() below, or inflateBack() and
+  perform their own processing of the gzip header and trailer.  When processing
+  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
+  producted so far.  The CRC-32 is checked against the gzip trailer.
 
     inflate() returns Z_OK if some progress has been made (more input processed
   or more output produced), Z_STREAM_END if the end of the compressed data has
   been reached and all uncompressed output has been produced, Z_NEED_DICT if a
   preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
   corrupted (input stream not conforming to the zlib format or incorrect check
   value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
+  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
   Z_BUF_ERROR if no progress is possible or if there was not enough room in the
-  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
+  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
   inflate() can be called again with more input and more output space to
-  continue decompressing. If Z_DATA_ERROR is returned, the application may then
-  call inflateSync() to look for a good compression block if a partial recovery
-  of the data is desired.
+  continue decompressing.  If Z_DATA_ERROR is returned, the application may
+  then call inflateSync() to look for a good compression block if a partial
+  recovery of the data is desired.
 */
 
 
 ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
 /*
      All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
+   This function discards any unprocessed input and does not flush any pending
+   output.
 
      inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent. In the error case, msg may be set but then points to a
+   was inconsistent.  In the error case, msg may be set but then points to a
    static string (which must not be deallocated).
 */
 
+
                         /* Advanced functions */
 
 /*
     The following functions are needed only in some special applications.
 */
 
@@ -482,150 +529,157 @@
                                      int  level,
                                      int  method,
                                      int  windowBits,
                                      int  memLevel,
                                      int  strategy));
 
-     This is another version of deflateInit with more compression options. The
-   fields next_in, zalloc, zfree and opaque must be initialized before by
-   the caller.
+     This is another version of deflateInit with more compression options.  The
+   fields next_in, zalloc, zfree and opaque must be initialized before by the
+   caller.
 
-     The method parameter is the compression method. It must be Z_DEFLATED in
+     The method parameter is the compression method.  It must be Z_DEFLATED in
    this version of the library.
 
      The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer). It should be in the range 8..15 for this
-   version of the library. Larger values of this parameter result in better
-   compression at the expense of memory usage. The default value is 15 if
+   (the size of the history buffer).  It should be in the range 8..15 for this
+   version of the library.  Larger values of this parameter result in better
+   compression at the expense of memory usage.  The default value is 15 if
    deflateInit is used instead.
 
-     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
-   determines the window size. deflate() will then generate raw deflate data
+     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
+   determines the window size.  deflate() will then generate raw deflate data
    with no zlib header or trailer, and will not compute an adler32 check value.
 
-     windowBits can also be greater than 15 for optional gzip encoding. Add
+     windowBits can also be greater than 15 for optional gzip encoding.  Add
    16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper. The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero),
-   no header crc, and the operating system will be set to 255 (unknown).  If a
+   compressed data instead of a zlib wrapper.  The gzip header will have no
+   file name, no extra data, no comment, no modification time (set to zero), no
+   header crc, and the operating system will be set to 255 (unknown).  If a
    gzip stream is being written, strm->adler is a crc32 instead of an adler32.
 
      The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state. memLevel=1 uses minimum memory but
-   is slow and reduces compression ratio; memLevel=9 uses maximum memory
-   for optimal speed. The default value is 8. See zconf.h for total memory
-   usage as a function of windowBits and memLevel.
+   for the internal compression state.  memLevel=1 uses minimum memory but is
+   slow and reduces compression ratio; memLevel=9 uses maximum memory for
+   optimal speed.  The default value is 8.  See zconf.h for total memory usage
+   as a function of windowBits and memLevel.
 
-     The strategy parameter is used to tune the compression algorithm. Use the
+     The strategy parameter is used to tune the compression algorithm.  Use the
    value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
    filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
    string match), or Z_RLE to limit match distances to one (run-length
-   encoding). Filtered data consists mostly of small values with a somewhat
-   random distribution. In this case, the compression algorithm is tuned to
-   compress them better. The effect of Z_FILTERED is to force more Huffman
+   encoding).  Filtered data consists mostly of small values with a somewhat
+   random distribution.  In this case, the compression algorithm is tuned to
+   compress them better.  The effect of Z_FILTERED is to force more Huffman
    coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
-   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
-   parameter only affects the compression ratio but not the correctness of the
-   compressed output even if it is not set appropriately.  Z_FIXED prevents the
-   use of dynamic Huffman codes, allowing for a simpler decoder for special
-   applications.
-
-      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
-   method). msg is set to null if there is no error message.  deflateInit2 does
-   not perform any compression: this will be done by deflate().
+   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
+   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
+   strategy parameter only affects the compression ratio but not the
+   correctness of the compressed output even if it is not set appropriately.
+   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
+   decoder for special applications.
+
+     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
+   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
+   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
+   set to null if there is no error message.  deflateInit2 does not perform any
+   compression: this will be done by deflate().
 */
 
 ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                              const Bytef *dictionary,
                                              uInt  dictLength));
 /*
      Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output. This function must be called
-   immediately after deflateInit, deflateInit2 or deflateReset, before any
-   call of deflate. The compressor and decompressor must use exactly the same
-   dictionary (see inflateSetDictionary).
+   without producing any compressed output.  When using the zlib format, this
+   function must be called immediately after deflateInit, deflateInit2 or
+   deflateReset, and before any call of deflate.  When doing raw deflate, this
+   function must be called either before any call of deflate, or immediately
+   after the completion of a deflate block, i.e. after all input has been
+   consumed and all output has been delivered when using any of the flush
+   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
+   compressor and decompressor must use exactly the same dictionary (see
+   inflateSetDictionary).
 
      The dictionary should consist of strings (byte sequences) that are likely
    to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary. Using a
+   used strings preferably put towards the end of the dictionary.  Using a
    dictionary is most useful when the data to be compressed is short and can be
    predicted with good accuracy; the data can then be compressed better than
    with the default empty dictionary.
 
      Depending on the size of the compression data structures selected by
    deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size in
-   deflate or deflate2. Thus the strings most likely to be useful should be
-   put at the end of the dictionary, not at the front. In addition, the
-   current implementation of deflate will use at most the window size minus
-   262 bytes of the provided dictionary.
+   discarded, for example if the dictionary is larger than the window size
+   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
+   useful should be put at the end of the dictionary, not at the front.  In
+   addition, the current implementation of deflate will use at most the window
+   size minus 262 bytes of the provided dictionary.
 
      Upon return of this function, strm->adler is set to the adler32 value
    of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor. (The adler32 value
+   which dictionary has been used by the compressor.  (The adler32 value
    applies to the whole dictionary even if only a subset of the dictionary is
    actually used by the compressor.) If a raw deflate was requested, then the
    adler32 value is not computed and strm->adler is not set.
 
      deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (such as NULL dictionary) or the stream state is
+   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
    inconsistent (for example if deflate has already been called for this stream
-   or if the compression method is bsort). deflateSetDictionary does not
-   perform any compression: this will be done by deflate().
+   or if not at a block boundary for raw deflate).  deflateSetDictionary does
+   not perform any compression: this will be done by deflate().
 */
 
 ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                     z_streamp source));
 /*
      Sets the destination stream as a complete copy of the source stream.
 
      This function can be useful when several compression strategies will be
    tried, for example when there are several ways of pre-processing the input
-   data with a filter. The streams that will be discarded should then be freed
+   data with a filter.  The streams that will be discarded should then be freed
    by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and
-   can consume lots of memory.
+   compression state which can be quite large, so this strategy is slow and can
+   consume lots of memory.
 
      deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being NULL). msg is left unchanged in both source and
+   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
    destination.
 */
 
 ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
 /*
      This function is equivalent to deflateEnd followed by deflateInit,
-   but does not free and reallocate all the internal compression state.
-   The stream will keep the same compression level and any other attributes
-   that may have been set by deflateInit2.
+   but does not free and reallocate all the internal compression state.  The
+   stream will keep the same compression level and any other attributes that
+   may have been set by deflateInit2.
 
-      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
+     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being Z_NULL).
 */
 
 ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
                                       int level,
                                       int strategy));
 /*
      Dynamically update the compression level and compression strategy.  The
    interpretation of level and strategy is as in deflateInit2.  This can be
    used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different
-   strategy. If the compression level is changed, the input available so far
-   is compressed with the old level (and may be flushed); the new level will
-   take effect only at the next call of deflate().
+   to switch to a different kind of input data requiring a different strategy.
+   If the compression level is changed, the input available so far is
+   compressed with the old level (and may be flushed); the new level will take
+   effect only at the next call of deflate().
 
      Before the call of deflateParams, the stream state must be set as for
-   a call of deflate(), since the currently available input may have to
-   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+   a call of deflate(), since the currently available input may have to be
+   compressed and flushed.  In particular, strm->avail_out must be non-zero.
 
      deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
-   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
-   if strm->avail_out was zero.
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if
+   strm->avail_out was zero.
 */
 
 ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
                                     int good_length,
                                     int max_lazy,
                                     int nice_length,
@@ -643,135 +697,184 @@
  */
 
 ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
                                        uLong sourceLen));
 /*
      deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit()
-   or deflateInit2().  This would be used to allocate an output buffer
-   for deflation in a single pass, and so would be called before deflate().
-*/
+   deflation of sourceLen bytes.  It must be called after deflateInit() or
+   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
+   to allocate an output buffer for deflation in a single pass, and so would be
+   called before deflate().  If that first deflate() call is provided the
+   sourceLen input bytes, an output buffer allocated to the size returned by
+   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
+   to return Z_STREAM_END.  Note that it is possible for the compressed size to
+   be larger than the value returned by deflateBound() if flush options other
+   than Z_FINISH or Z_NO_FLUSH are used.
+*/
+
+ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
+                                       unsigned *pending,
+                                       int *bits));
+/*
+     deflatePending() returns the number of bytes and bits of output that have
+   been generated, but not yet provided in the available output.  The bytes not
+   provided would be due to the available output space having being consumed.
+   The number of bits of output not provided are between 0 and 7, where they
+   await more bits to join them in order to fill out a full byte.  If pending
+   or bits are Z_NULL, then those values are not set.
+
+     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+ */
 
 ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
                                      int bits,
                                      int value));
 /*
      deflatePrime() inserts bits in the deflate output stream.  The intent
-  is that this function is used to start off the deflate output with the
-  bits leftover from a previous deflate stream when appending to it.  As such,
-  this function can only be used for raw deflate, and must be used before the
-  first deflate() call after a deflateInit2() or deflateReset().  bits must be
-  less than or equal to 16, and that many of the least significant bits of
-  value will be inserted in the output.
-
-      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
+   is that this function is used to start off the deflate output with the bits
+   leftover from a previous deflate stream when appending to it.  As such, this
+   function can only be used for raw deflate, and must be used before the first
+   deflate() call after a deflateInit2() or deflateReset().  bits must be less
+   than or equal to 16, and that many of the least significant bits of value
+   will be inserted in the output.
+
+     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
+   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
+   source stream state was inconsistent.
 */
 
 ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
                                          gz_headerp head));
 /*
-      deflateSetHeader() provides gzip header information for when a gzip
+     deflateSetHeader() provides gzip header information for when a gzip
    stream is requested by deflateInit2().  deflateSetHeader() may be called
    after deflateInit2() or deflateReset() and before the first call of
    deflate().  The text, time, os, extra field, name, and comment information
    in the provided gz_header structure are written to the gzip header (xflag is
    ignored -- the extra flags are set according to the compression level).  The
    caller must assure that, if not Z_NULL, name and comment are terminated with
    a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
    available there.  If hcrc is true, a gzip header crc is included.  Note that
    the current versions of the command-line version of gzip (up through version
    1.3.x) do not support header crc's, and will report that it is a "multi-part
    gzip file" and give up.
 
-      If deflateSetHeader is not used, the default gzip header has text false,
+     If deflateSetHeader is not used, the default gzip header has text false,
    the time set to zero, and os set to 255, with no extra, name, or comment
    fields.  The gzip header is returned to the default state by deflateReset().
 
-      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
    stream state was inconsistent.
 */
 
 /*
 ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                      int  windowBits));
 
-     This is another version of inflateInit with an extra parameter. The
+     This is another version of inflateInit with an extra parameter.  The
    fields next_in, avail_in, zalloc, zfree and opaque must be initialized
    before by the caller.
 
      The windowBits parameter is the base two logarithm of the maximum window
    size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library. The default value is 15 if inflateInit is used
-   instead. windowBits must be greater than or equal to the windowBits value
+   this version of the library.  The default value is 15 if inflateInit is used
+   instead.  windowBits must be greater than or equal to the windowBits value
    provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used. If a compressed stream with a larger window
+   deflateInit2() was not used.  If a compressed stream with a larger window
    size is given as input, inflate() will return with the error code
    Z_DATA_ERROR instead of trying to allocate a larger window.
 
-     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
-   determines the window size. inflate() will then process raw deflate data,
+     windowBits can also be zero to request that inflate use the window size in
+   the zlib header of the compressed stream.
+
+     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
+   determines the window size.  inflate() will then process raw deflate data,
    not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream. This
+   looking for any check values for comparison at the end of the stream.  This
    is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values. If a custom
+   such as zip.  Those formats provide their own check values.  If a custom
    format is developed using the raw deflate format for compressed data, it is
    recommended that a check value such as an adler32 or a crc32 be applied to
    the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is. Note that comments
+   most applications, the zlib format should be used as is.  Note that comments
    above on the use in deflateInit2() applies to the magnitude of windowBits.
 
-     windowBits can also be greater than 15 for optional gzip decoding. Add
+     windowBits can also be greater than 15 for optional gzip decoding.  Add
    32 to windowBits to enable zlib and gzip decoding with automatic header
    detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is
-   a crc32 instead of an adler32.
+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
+   crc32 instead of an adler32.
 
      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg
-   is set to null if there is no error message.  inflateInit2 does not perform
-   any decompression apart from reading the zlib header if present: this will
-   be done by inflate(). (So next_in and avail_in may be modified, but next_out
-   and avail_out are unchanged.)
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
+   invalid, such as a null pointer to the structure.  msg is set to null if
+   there is no error message.  inflateInit2 does not perform any decompression
+   apart from possibly reading the zlib header if present: actual decompression
+   will be done by inflate().  (So next_in and avail_in may be modified, but
+   next_out and avail_out are unused and unchanged.) The current implementation
+   of inflateInit2() does not process any header information -- that is
+   deferred until inflate() is called.
 */
 
 ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                              const Bytef *dictionary,
                                              uInt  dictLength));
 /*
      Initializes the decompression dictionary from the given uncompressed byte
-   sequence. This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   sequence.  This function must be called immediately after a call of inflate,
+   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
    can be determined from the adler32 value returned by that call of inflate.
    The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called
-   immediately after inflateInit2() or inflateReset() and before any call of
-   inflate() to set the dictionary.  The application must insure that the
-   dictionary that was used for compression is provided.
+   deflateSetDictionary).  For raw inflate, this function can be called at any
+   time to set the dictionary.  If the provided dictionary is smaller than the
+   window and there is already data in the window, then the provided dictionary
+   will amend what's there.  The application must insure that the dictionary
+   that was used for compression is provided.
 
      inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (such as NULL dictionary) or the stream state is
+   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
    inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect adler32 value). inflateSetDictionary does not
+   expected one (incorrect adler32 value).  inflateSetDictionary does not
    perform any decompression: this will be done by subsequent calls of
    inflate().
 */
 
+ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
+                                             Bytef *dictionary,
+                                             uInt  *dictLength));
+/*
+     Returns the sliding dictionary being maintained by inflate.  dictLength is
+   set to the number of bytes in the dictionary, and that many bytes are copied
+   to dictionary.  dictionary must have enough space, where 32768 bytes is
+   always enough.  If inflateGetDictionary() is called with dictionary equal to
+   Z_NULL, then only the dictionary length is returned, and nothing is copied.
+   Similary, if dictLength is Z_NULL, then it is not set.
+
+     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
+   stream state is inconsistent.
+*/
+
 ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
 /*
-    Skips invalid compressed data until a full flush point (see above the
-  description of deflate with Z_FULL_FLUSH) can be found, or until all
-  available input is skipped. No output is provided.
-
-    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
-  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
-  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
-  case, the application may save the current current value of total_in which
-  indicates where valid compressed data was found. In the error case, the
-  application may repeatedly call inflateSync, providing more input each time,
-  until success or end of the input data.
+     Skips invalid compressed data until a possible full flush point (see above
+   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
+   available input is skipped.  No output is provided.
+
+     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
+   All full flush points have this pattern, but not all occurrences of this
+   pattern are full flush points.
+
+     inflateSync returns Z_OK if a possible full flush point has been found,
+   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
+   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
+   In the success case, the application may save the current current value of
+   total_in which indicates where valid compressed data was found.  In the
+   error case, the application may repeatedly call inflateSync, providing more
+   input each time, until success or end of the input data.
 */
 
 ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
                                     z_streamp source));
 /*
      Sets the destination stream as a complete copy of the source stream.
@@ -780,79 +883,124 @@
    first pass through the stream can periodically record the inflate state,
    allowing restarting inflate at those points when randomly accessing the
    stream.
 
      inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being NULL). msg is left unchanged in both source and
+   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
    destination.
 */
 
 ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
 /*
      This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.
-   The stream will keep attributes that may have been set by inflateInit2.
+   but does not free and reallocate all the internal decompression state.  The
+   stream will keep attributes that may have been set by inflateInit2.
 
-      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
+     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being Z_NULL).
+*/
+
+ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
+                                      int windowBits));
+/*
+     This function is the same as inflateReset, but it also permits changing
+   the wrap and window size requests.  The windowBits parameter is interpreted
+   the same as it is for inflateInit2.
+
+     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
+   the windowBits parameter is invalid.
 */
 
 ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
                                      int bits,
                                      int value));
 /*
      This function inserts bits in the inflate input stream.  The intent is
-  that this function is used to start inflating at a bit position in the
-  middle of a byte.  The provided bits will be used before any bytes are used
-  from next_in.  This function should only be used with raw inflate, and
-  should be used before the first inflate() call after inflateInit2() or
-  inflateReset().  bits must be less than or equal to 16, and that many of the
-  least significant bits of value will be inserted in the input.
+   that this function is used to start inflating at a bit position in the
+   middle of a byte.  The provided bits will be used before any bytes are used
+   from next_in.  This function should only be used with raw inflate, and
+   should be used before the first inflate() call after inflateInit2() or
+   inflateReset().  bits must be less than or equal to 16, and that many of the
+   least significant bits of value will be inserted in the input.
+
+     If bits is negative, then the input stream bit buffer is emptied.  Then
+   inflatePrime() can be called again to put bits in the buffer.  This is used
+   to clear out bits leftover after feeding inflate a block description prior
+   to feeding inflate codes.
 
-      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
    stream state was inconsistent.
 */
 
+ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
+/*
+     This function returns two values, one in the lower 16 bits of the return
+   value, and the other in the remaining upper bits, obtained by shifting the
+   return value down 16 bits.  If the upper value is -1 and the lower value is
+   zero, then inflate() is currently decoding information outside of a block.
+   If the upper value is -1 and the lower value is non-zero, then inflate is in
+   the middle of a stored block, with the lower value equaling the number of
+   bytes from the input remaining to copy.  If the upper value is not -1, then
+   it is the number of bits back from the current bit position in the input of
+   the code (literal or length/distance pair) currently being processed.  In
+   that case the lower value is the number of bytes already emitted for that
+   code.
+
+     A code is being processed if inflate is waiting for more input to complete
+   decoding of the code, or if it has completed decoding but is waiting for
+   more output space to write the literal or match data.
+
+     inflateMark() is used to mark locations in the input data for random
+   access, which may be at bit positions, and to note those cases where the
+   output of a code may span boundaries of random access blocks.  The current
+   location in the input stream can be determined from avail_in and data_type
+   as noted in the description for the Z_BLOCK flush parameter for inflate.
+
+     inflateMark returns the value noted above or -1 << 16 if the provided
+   source stream state was inconsistent.
+*/
+
 ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
                                          gz_headerp head));
 /*
-      inflateGetHeader() requests that gzip header information be stored in the
+     inflateGetHeader() requests that gzip header information be stored in the
    provided gz_header structure.  inflateGetHeader() may be called after
    inflateInit2() or inflateReset(), and before the first call of inflate().
    As inflate() processes the gzip stream, head->done is zero until the header
    is completed, at which time head->done is set to one.  If a zlib stream is
    being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK can be used to
-   force inflate() to return immediately after header processing is complete
-   and before any actual data is decompressed.
+   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
+   used to force inflate() to return immediately after header processing is
+   complete and before any actual data is decompressed.
 
-      The text, time, xflags, and os fields are filled in with the gzip header
+     The text, time, xflags, and os fields are filled in with the gzip header
    contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.)  If extra is not Z_NULL, then extra_max
+   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
    contains the maximum number of bytes to write to extra.  Once done is true,
    extra_len contains the actual extra field length, and extra contains the
    extra field, or that field truncated if extra_max is less than extra_len.
    If name is not Z_NULL, then up to name_max characters are written there,
    terminated with a zero unless the length is greater than name_max.  If
    comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When
-   any of extra, name, or comment are not Z_NULL and the respective field is
-   not present in the header, then that field is set to Z_NULL to signal its
+   terminated with a zero unless the length is greater than comm_max.  When any
+   of extra, name, or comment are not Z_NULL and the respective field is not
+   present in the header, then that field is set to Z_NULL to signal its
    absence.  This allows the use of deflateSetHeader() with the returned
    structure to duplicate the header.  However if those fields are set to
    allocated memory, then the application will need to save those pointers
    elsewhere so that they can be eventually freed.
 
-      If inflateGetHeader is not used, then the header information is simply
+     If inflateGetHeader is not used, then the header information is simply
    discarded.  The header is always checked for validity, including the header
    CRC if present.  inflateReset() will reset the process to discard the header
    information.  The application would need to call inflateGetHeader() again to
    retrieve the header from the next gzip stream.
 
-      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
    stream state was inconsistent.
 */
 
 /*
 ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
                                         unsigned char FAR *window));
@@ -867,43 +1015,45 @@
    and a 32K byte window must be supplied to be able to decompress general
    deflate streams.
 
      See inflateBack() for the usage of these routines.
 
      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
-   be allocated, or Z_VERSION_ERROR if the version of the library does not
-   match the version of the header file.
+   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
+   allocated, or Z_VERSION_ERROR if the version of the library does not match
+   the version of the header file.
 */
 
-typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
+typedef unsigned (*in_func) OF((void FAR *,
+                                z_const unsigned char FAR * FAR *));
 typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
 
 ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
                                     in_func in, void FAR *in_desc,
                                     out_func out, void FAR *out_desc));
 /*
      inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is more efficient than inflate() for
-   file i/o applications in that it avoids copying between the output and the
-   sliding window by simply making the window itself the output buffer.  This
-   function trusts the application to not change the output buffer passed by
-   the output function, at least until inflateBack() returns.
+   interface for input and output.  This is potentially more efficient than
+   inflate() for file i/o applications, in that it avoids copying between the
+   output and the sliding window by simply making the window itself the output
+   buffer.  inflate() can be faster on modern CPUs when used with large
+   buffers.  inflateBack() trusts the application to not change the output
+   buffer passed by the output function, at least until inflateBack() returns.
 
      inflateBackInit() must be called first to allocate the internal state
    and to initialize the state with the user-provided window buffer.
    inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free
-   the allocated state.
+   deflate stream with each call.  inflateBackEnd() is then called to free the
+   allocated state.
 
      A raw deflate stream is one with no zlib or gzip header or trailer.
    This routine would normally be used in a utility that reads zip or gzip
    files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects
-   only the raw deflate stream to decompress.  This is different from the
-   normal behavior of inflate(), which expects either a zlib or gzip header and
+   header and process the trailer on its own, hence this routine expects only
+   the raw deflate stream to decompress.  This is different from the normal
+   behavior of inflate(), which expects either a zlib or gzip header and
    trailer around the deflate stream.
 
      inflateBack() uses two subroutines supplied by the caller that are then
    called by inflateBack() for input and output.  inflateBack() calls those
    routines until it reads a complete deflate stream and writes out all of the
    uncompressed data, or until it encounters an error.  The function's
@@ -923,31 +1073,31 @@
      For convenience, inflateBack() can be provided input on the first call by
    setting strm->next_in and strm->avail_in.  If that input is exhausted, then
    in() will be called.  Therefore strm->next_in must be initialized before
    calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
    immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
    must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 .. strm->avail_in - 1].
+   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
 
      The in_desc and out_desc parameters of inflateBack() is passed as the
    first parameter of in() and out() respectively when they are called.  These
    descriptors can be optionally used to pass any information that the caller-
    supplied in() and out() functions need to do their job.
 
      On return, inflateBack() will set strm->next_in and strm->avail_in to
    pass back any unused input that was provided by the last in() call.  The
    return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format
-   error in the deflate stream (in which case strm->msg is set to indicate the
-   nature of the error), or Z_STREAM_ERROR if the stream was not properly
-   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
-   distinguished using strm->next_in which will be Z_NULL only if in() returned
-   an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
-   out() returning non-zero.  (in() will always be called before out(), so
-   strm->next_in is assured to be defined if out() returns non-zero.)  Note
-   that inflateBack() cannot return Z_OK.
+   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
+   in the deflate stream (in which case strm->msg is set to indicate the nature
+   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
+   In the case of Z_BUF_ERROR, an input or output error can be distinguished
+   using strm->next_in which will be Z_NULL only if in() returned an error.  If
+   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
+   non-zero.  (in() will always be called before out(), so strm->next_in is
+   assured to be defined if out() returns non-zero.) Note that inflateBack()
+   cannot return Z_OK.
 */
 
 ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
 /*
      All memory allocated by inflateBackInit() is freed.
 
@@ -993,305 +1143,471 @@
      26: 0 = returns value, 1 = void -- 1 means inferred string length returned
 
     Remainder:
      27-31: 0 (reserved)
  */
 
+#ifndef Z_SOLO
 
                         /* utility functions */
 
 /*
-     The following utility functions are implemented on top of the
-   basic stream-oriented functions. To simplify the interface, some
-   default options are assumed (compression level and memory usage,
-   standard memory allocation functions). The source code of these
-   utility functions can easily be modified if you need special options.
+     The following utility functions are implemented on top of the basic
+   stream-oriented functions.  To simplify the interface, some default options
+   are assumed (compression level and memory usage, standard memory allocation
+   functions).  The source code of these utility functions can be modified if
+   you need special options.
 */
 
 ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen));
 /*
      Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be at least the value returned
-   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   the byte length of the source buffer.  Upon entry, destLen is the total size
+   of the destination buffer, which must be at least the value returned by
+   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
    compressed buffer.
-     This function can be used to compress a whole file at once if the
-   input file is mmap'ed.
+
      compress returns Z_OK if success, Z_MEM_ERROR if there was not
    enough memory, Z_BUF_ERROR if there was not enough room in the output
    buffer.
 */
 
 ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen,
                                   int level));
 /*
-     Compresses the source buffer into the destination buffer. The level
+     Compresses the source buffer into the destination buffer.  The level
    parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
+   length of the source buffer.  Upon entry, destLen is the total size of the
    destination buffer, which must be at least the value returned by
-   compressBound(sourceLen). Upon exit, destLen is the actual size of the
+   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
    compressed buffer.
 
      compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
    Z_STREAM_ERROR if the level parameter is invalid.
 */
 
 ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
 /*
      compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before
-   a compress() or compress2() call to allocate the destination buffer.
+   compress() or compress2() on sourceLen bytes.  It would be used before a
+   compress() or compress2() call to allocate the destination buffer.
 */
 
 ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                    const Bytef *source, uLong sourceLen));
 /*
      Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer.
-     This function can be used to decompress a whole file at once if the
-   input file is mmap'ed.
+   the byte length of the source buffer.  Upon entry, destLen is the total size
+   of the destination buffer, which must be large enough to hold the entire
+   uncompressed data.  (The size of the uncompressed data must have been saved
+   previously by the compressor and transmitted to the decompressor by some
+   mechanism outside the scope of this compression library.) Upon exit, destLen
+   is the actual size of the uncompressed buffer.
 
      uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
    enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
+   the case where there is not enough room, uncompress() will fill the output
+   buffer with the uncompressed data up to that point.
 */
 
+                        /* gzip file access functions */
 
-typedef voidp gzFile;
+/*
+     This library supports reading and writing files in gzip (.gz) format with
+   an interface similar to that of stdio, using the functions that start with
+   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
+   wrapper, documented in RFC 1952, wrapped around a deflate stream.
+*/
+
+typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
 
-ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
 /*
-     Opens a gzip (.gz) file for reading or writing. The mode parameter
-   is as in fopen ("rb" or "wb") but can also include a compression level
-   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
-   Huffman only compression as in "wb1h", or 'R' for run-length encoding
-   as in "wb1R". (See the description of deflateInit2 for more information
-   about the strategy parameter.)
+ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
+
+     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
+   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
+   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
+   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
+   for fixed code compression as in "wb9F".  (See the description of
+   deflateInit2 for more information about the strategy parameter.)  'T' will
+   request transparent writing or appending with no compression and not using
+   the gzip format.
+
+     "a" can be used instead of "w" to request that the gzip stream that will
+   be written be appended to the file.  "+" will result in an error, since
+   reading and writing to the same gzip file is not supported.  The addition of
+   "x" when writing will create the file exclusively, which fails if the file
+   already exists.  On systems that support it, the addition of "e" when
+   reading or writing will set the flag to close the file on an execve() call.
+
+     These functions, as well as gzip, will read and decode a sequence of gzip
+   streams in a file.  The append function of gzopen() can be used to create
+   such a file.  (Also see gzflush() for another way to do this.)  When
+   appending, gzopen does not test whether the file begins with a gzip stream,
+   nor does it look for the end of the gzip streams to begin appending.  gzopen
+   will simply append a gzip stream to the existing file.
 
      gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.
+   case gzread will directly read from the file without decompression.  When
+   reading, this will be detected automatically by looking for the magic two-
+   byte gzip header.
+
+     gzopen returns NULL if the file could not be opened, if there was
+   insufficient memory to allocate the gzFile state, or if an invalid mode was
+   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
+   errno can be checked to determine if the reason gzopen failed was that the
+   file could not be opened.
+*/
+
+ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
+/*
+     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
+   are obtained from calls like open, dup, creat, pipe or fileno (if the file
+   has been previously opened with fopen).  The mode parameter is as in gzopen.
+
+     The next call of gzclose on the returned gzFile will also close the file
+   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
+   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
+   mode);.  The duplicated descriptor should be saved to avoid a leak, since
+   gzdopen does not close fd if it fails.  If you are using fileno() to get the
+   file descriptor from a FILE *, then you will have to use dup() to avoid
+   double-close()ing the file descriptor.  Both gzclose() and fclose() will
+   close the associated file descriptor, so they need to have different file
+   descriptors.
+
+     gzdopen returns NULL if there was insufficient memory to allocate the
+   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
+   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
+   used until the next gz* read, write, seek, or close operation, so gzdopen
+   will not detect if fd is invalid (unless fd is -1).
+*/
+
+ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
+/*
+     Set the internal buffer size used by this library's functions.  The
+   default buffer size is 8192 bytes.  This function must be called after
+   gzopen() or gzdopen(), and before any other calls that read or write the
+   file.  The buffer memory allocation is always deferred to the first read or
+   write.  Two buffers are allocated, either both of the specified size when
+   writing, or one of the specified size and the other twice that size when
+   reading.  A larger buffer size of, for example, 64K or 128K bytes will
+   noticeably increase the speed of decompression (reading).
 
-     gzopen returns NULL if the file could not be opened or if there was
-   insufficient memory to allocate the (de)compression state; errno
-   can be checked to distinguish the two cases (if errno is zero, the
-   zlib error is Z_MEM_ERROR).  */
-
-ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
-/*
-     gzdopen() associates a gzFile with the file descriptor fd.  File
-   descriptors are obtained from calls like open, dup, creat, pipe or
-   fileno (in the file has been previously opened with fopen).
-   The mode parameter is as in gzopen.
-     The next call of gzclose on the returned gzFile will also close the
-   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
-   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
-     gzdopen returns NULL if there was insufficient memory to allocate
-   the (de)compression state.
+     The new buffer size also affects the maximum length for gzprintf().
+
+     gzbuffer() returns 0 on success, or -1 on failure, such as being called
+   too late.
 */
 
 ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
 /*
-     Dynamically update the compression level or strategy. See the description
+     Dynamically update the compression level or strategy.  See the description
    of deflateInit2 for the meaning of these parameters.
+
      gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
    opened for writing.
 */
 
-ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
 /*
-     Reads the given number of uncompressed bytes from the compressed file.
-   If the input file was not in gzip format, gzread copies the given number
-   of bytes into the buffer.
-     gzread returns the number of uncompressed bytes actually read (0 for
-   end of file, -1 for error). */
+     Reads the given number of uncompressed bytes from the compressed file.  If
+   the input file is not in gzip format, gzread copies the given number of
+   bytes into the buffer directly from the file.
+
+     After reaching the end of a gzip stream in the input, gzread will continue
+   to read, looking for another gzip stream.  Any number of gzip streams may be
+   concatenated in the input file, and will all be decompressed by gzread().
+   If something other than a gzip stream is encountered after a gzip stream,
+   that remaining trailing garbage is ignored (and no error is returned).
+
+     gzread can be used to read a gzip file that is being concurrently written.
+   Upon reaching the end of the input, gzread will return with the available
+   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
+   gzclearerr can be used to clear the end of file indicator in order to permit
+   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
+   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
+   middle of a gzip stream.  Note that gzread does not return -1 in the event
+   of an incomplete gzip stream.  This error is deferred until gzclose(), which
+   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
+   stream.  Alternatively, gzerror can be used before gzclose to detect this
+   case.
+
+     gzread returns the number of uncompressed bytes actually read, less than
+   len for end of file, or -1 for error.
+*/
 
-ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
-                                   voidpc buf, unsigned len));
+ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
+                                voidpc buf, unsigned len));
 /*
      Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes actually written
-   (0 in case of error).
+   gzwrite returns the number of uncompressed bytes written or 0 in case of
+   error.
 */
 
-ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
 /*
-     Converts, formats, and writes the args to the compressed file under
-   control of the format string, as in fprintf. gzprintf returns the number of
-   uncompressed bytes actually written (0 in case of error).  The number of
-   uncompressed bytes written is limited to 4095. The caller should assure that
-   this limit is not exceeded. If it is exceeded, then gzprintf() will return
-   return an error (0) with nothing written. In this case, there may also be a
-   buffer overflow with unpredictable consequences, which is possible only if
-   zlib was compiled with the insecure functions sprintf() or vsprintf()
-   because the secure snprintf() or vsnprintf() functions were not available.
+     Converts, formats, and writes the arguments to the compressed file under
+   control of the format string, as in fprintf.  gzprintf returns the number of
+   uncompressed bytes actually written, or 0 in case of error.  The number of
+   uncompressed bytes written is limited to 8191, or one less than the buffer
+   size given to gzbuffer().  The caller should assure that this limit is not
+   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with
+   nothing written.  In this case, there may also be a buffer overflow with
+   unpredictable consequences, which is possible only if zlib was compiled with
+   the insecure functions sprintf() or vsprintf() because the secure snprintf()
+   or vsnprintf() functions were not available.  This can be determined using
+   zlibCompileFlags().
 */
 
 ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
 /*
-      Writes the given null-terminated string to the compressed file, excluding
+     Writes the given null-terminated string to the compressed file, excluding
    the terminating null character.
-      gzputs returns the number of characters written, or -1 in case of error.
+
+     gzputs returns the number of characters written, or -1 in case of error.
 */
 
 ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
 /*
-      Reads bytes from the compressed file until len-1 characters are read, or
-   a newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  The string is then terminated with a null
-   character.
-      gzgets returns buf, or Z_NULL in case of error.
+     Reads bytes from the compressed file until len-1 characters are read, or a
+   newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  If any characters are read or if len == 1, the
+   string is terminated with a null character.  If no characters are read due
+   to an end-of-file or len < 1, then the buffer is left untouched.
+
+     gzgets returns buf which is a null-terminated string, or it returns NULL
+   for end-of-file or in case of error.  If there was an error, the contents at
+   buf are indeterminate.
 */
 
-ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
 /*
-      Writes c, converted to an unsigned char, into the compressed file.
-   gzputc returns the value that was written, or -1 in case of error.
+     Writes c, converted to an unsigned char, into the compressed file.  gzputc
+   returns the value that was written, or -1 in case of error.
 */
 
-ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
 /*
-      Reads one byte from the compressed file. gzgetc returns this byte
-   or -1 in case of end of file or error.
+     Reads one byte from the compressed file.  gzgetc returns this byte or -1
+   in case of end of file or error.  This is implemented as a macro for speed.
+   As such, it does not do all of the checking the other functions do.  I.e.
+   it does not check to see if file is NULL, nor whether the structure file
+   points to has been clobbered or not.
 */
 
-ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
+ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
 /*
-      Push one character back onto the stream to be read again later.
-   Only one character of push-back is allowed.  gzungetc() returns the
-   character pushed, or -1 on failure.  gzungetc() will fail if a
-   character has been pushed but not read yet, or if c is -1. The pushed
-   character will be discarded if the stream is repositioned with gzseek()
-   or gzrewind().
+     Push one character back onto the stream to be read as the first character
+   on the next read.  At least one character of push-back is allowed.
+   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
+   fail if c is -1, and may fail if a character has been pushed but not read
+   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
+   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
+   The pushed character will be discarded if the stream is repositioned with
+   gzseek() or gzrewind().
 */
 
-ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
 /*
-     Flushes all pending output into the compressed file. The parameter
-   flush is as in the deflate() function. The return value is the zlib
-   error number (see function gzerror below). gzflush returns Z_OK if
-   the flush parameter is Z_FINISH and all output could be flushed.
-     gzflush should be called only when strictly necessary because it can
-   degrade compression.
+     Flushes all pending output into the compressed file.  The parameter flush
+   is as in the deflate() function.  The return value is the zlib error number
+   (see function gzerror below).  gzflush is only permitted when writing.
+
+     If the flush parameter is Z_FINISH, the remaining data is written and the
+   gzip stream is completed in the output.  If gzwrite() is called again, a new
+   gzip stream will be started in the output.  gzread() is able to read such
+   concatented gzip streams.
+
+     gzflush should be called only when strictly necessary because it will
+   degrade compression if called too often.
 */
 
-ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
-                                      z_off_t offset, int whence));
 /*
-      Sets the starting position for the next gzread or gzwrite on the
-   given compressed file. The offset represents a number of bytes in the
-   uncompressed data stream. The whence parameter is defined as in lseek(2);
+ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
+                                   z_off_t offset, int whence));
+
+     Sets the starting position for the next gzread or gzwrite on the given
+   compressed file.  The offset represents a number of bytes in the
+   uncompressed data stream.  The whence parameter is defined as in lseek(2);
    the value SEEK_END is not supported.
+
      If the file is opened for reading, this function is emulated but can be
-   extremely slow. If the file is opened for writing, only forward seeks are
+   extremely slow.  If the file is opened for writing, only forward seeks are
    supported; gzseek then compresses a sequence of zeroes up to the new
    starting position.
 
-      gzseek returns the resulting offset location as measured in bytes from
+     gzseek returns the resulting offset location as measured in bytes from
    the beginning of the uncompressed stream, or -1 in case of error, in
    particular if the file is opened for writing and the new starting position
    would be before the current position.
 */
 
 ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
 /*
      Rewinds the given file. This function is supported only for reading.
 
-   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
 */
 
+/*
 ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+
+     Returns the starting position for the next gzread or gzwrite on the given
+   compressed file.  This position represents a number of bytes in the
+   uncompressed data stream, and is zero when starting, even if appending or
+   reading a gzip stream from the middle of a file using gzdopen().
+
+     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
 /*
-     Returns the starting position for the next gzread or gzwrite on the
-   given compressed file. This position represents a number of bytes in the
-   uncompressed data stream.
+ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
 
-   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+     Returns the current offset in the file being read or written.  This offset
+   includes the count of bytes that precede the gzip stream, for example when
+   appending or when using gzdopen() for reading.  When reading, the offset
+   does not include as yet unused buffered input.  This information can be used
+   for a progress indicator.  On error, gzoffset() returns -1.
 */
 
 ZEXTERN int ZEXPORT gzeof OF((gzFile file));
 /*
-     Returns 1 when EOF has previously been detected reading the given
-   input stream, otherwise zero.
+     Returns true (1) if the end-of-file indicator has been set while reading,
+   false (0) otherwise.  Note that the end-of-file indicator is set only if the
+   read tried to go past the end of the input, but came up short.  Therefore,
+   just like feof(), gzeof() may return false even if there is no more data to
+   read, in the event that the last read request was for the exact number of
+   bytes remaining in the input file.  This will happen if the input file size
+   is an exact multiple of the buffer size.
+
+     If gzeof() returns true, then the read functions will return no more data,
+   unless the end-of-file indicator is reset by gzclearerr() and the input file
+   has grown since the previous end of file was detected.
 */
 
 ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
 /*
-     Returns 1 if file is being read directly without decompression, otherwise
-   zero.
+     Returns true (1) if file is being copied directly while reading, or false
+   (0) if file is a gzip stream being decompressed.
+
+     If the input file is empty, gzdirect() will return true, since the input
+   does not contain a gzip stream.
+
+     If gzdirect() is used immediately after gzopen() or gzdopen() it will
+   cause buffers to be allocated to allow reading the file to determine if it
+   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
+   gzdirect().
+
+     When writing, gzdirect() returns true (1) if transparent writing was
+   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
+   gzdirect() is not needed when writing.  Transparent writing must be
+   explicitly requested, so the application already knows the answer.  When
+   linking statically, using gzdirect() will include all of the zlib code for
+   gzip file reading and decompression, which may not be desired.)
 */
 
 ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
 /*
-     Flushes all pending output if necessary, closes the compressed file
-   and deallocates all the (de)compression state. The return value is the zlib
-   error number (see function gzerror below).
+     Flushes all pending output if necessary, closes the compressed file and
+   deallocates the (de)compression state.  Note that once file is closed, you
+   cannot call gzerror with file, since its structures have been deallocated.
+   gzclose must not be called more than once on the same file, just as free
+   must not be called more than once on the same allocation.
+
+     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
+   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
+   last read ended in the middle of a gzip stream, or Z_OK on success.
+*/
+
+ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
+ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
+/*
+     Same as gzclose(), but gzclose_r() is only for use when reading, and
+   gzclose_w() is only for use when writing or appending.  The advantage to
+   using these instead of gzclose() is that they avoid linking in zlib
+   compression or decompression code that is not used when only reading or only
+   writing respectively.  If gzclose() is used, then both compression and
+   decompression code will be included the application when linking to a static
+   zlib library.
 */
 
 ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
 /*
-     Returns the error message for the last error which occurred on the
-   given compressed file. errnum is set to zlib error number. If an
-   error occurred in the file system and not in the compression library,
-   errnum is set to Z_ERRNO and the application may consult errno
-   to get the exact error code.
+     Returns the error message for the last error which occurred on the given
+   compressed file.  errnum is set to zlib error number.  If an error occurred
+   in the file system and not in the compression library, errnum is set to
+   Z_ERRNO and the application may consult errno to get the exact error code.
+
+     The application must not modify the returned string.  Future calls to
+   this function may invalidate the previously returned string.  If file is
+   closed, then the string previously returned by gzerror will no longer be
+   available.
+
+     gzerror() should be used to distinguish errors from end-of-file for those
+   functions above that do not distinguish those cases in their return values.
 */
 
 ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
 /*
-     Clears the error and end-of-file flags for file. This is analogous to the
-   clearerr() function in stdio. This is useful for continuing to read a gzip
+     Clears the error and end-of-file flags for file.  This is analogous to the
+   clearerr() function in stdio.  This is useful for continuing to read a gzip
    file that is being written concurrently.
 */
 
+#endif /* !Z_SOLO */
+
                         /* checksum functions */
 
 /*
      These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the
-   compression library.
+   anyway because they might be useful in applications using the compression
+   library.
 */
 
 ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
 /*
      Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. If buf is NULL, this function returns
-   the required initial value for the checksum.
-   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster. Usage example:
+   return the updated checksum.  If buf is Z_NULL, this function returns the
+   required initial value for the checksum.
+
+     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster.
+
+   Usage example:
 
      uLong adler = adler32(0L, Z_NULL, 0);
 
      while (read_buffer(buffer, length) != EOF) {
        adler = adler32(adler, buffer, length);
      }
      if (adler != original_adler) error();
 */
 
+/*
 ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
                                           z_off_t len2));
-/*
+
      Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
    and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
    each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
+   that the z_off_t type (like off_t) is a signed integer.  If len2 is
+   negative, the result has no meaning or utility.
 */
 
 ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
 /*
      Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32. If buf is NULL, this function returns the required initial
-   value for the for the crc. Pre- and post-conditioning (one's complement) is
+   updated CRC-32.  If buf is Z_NULL, this function returns the required
+   initial value for the crc.  Pre- and post-conditioning (one's complement) is
    performed within this function so it shouldn't be done by the application.
+
    Usage example:
 
      uLong crc = crc32(0L, Z_NULL, 0);
 
      while (read_buffer(buffer, length) != EOF) {
        crc = crc32(crc, buffer, length);
@@ -1296,15 +1612,15 @@
      while (read_buffer(buffer, length) != EOF) {
        crc = crc32(crc, buffer, length);
      }
      if (crc != original_crc) error();
 */
 
+/*
 ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
 
-/*
      Combine two CRC-32 check values into one.  For two sequences of bytes,
    seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
    calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
    check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
    len2.
 */
@@ -1327,32 +1643,127 @@
                                       const char *version, int stream_size));
 ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
                                          unsigned char FAR *window,
                                          const char *version,
                                          int stream_size));
 #define deflateInit(strm, level) \
-        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+        deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
 #define inflateInit(strm) \
-        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+        inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
 #define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
         deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+                      (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
 #define inflateInit2(strm, windowBits) \
-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
+                      (int)sizeof(z_stream))
 #define inflateBackInit(strm, windowBits, window) \
         inflateBackInit_((strm), (windowBits), (window), \
-        ZLIB_VERSION, sizeof(z_stream))
+                      ZLIB_VERSION, (int)sizeof(z_stream))
+
+#ifndef Z_SOLO
+
+/* gzgetc() macro and its supporting function and exposed data structure.  Note
+ * that the real internal state is much larger than the exposed structure.
+ * This abbreviated structure exposes just enough for the gzgetc() macro.  The
+ * user should not mess with these exposed elements, since their names or
+ * behavior could change in the future, perhaps even capriciously.  They can
+ * only be used by the gzgetc() macro.  You have been warned.
+ */
+struct gzFile_s {
+    unsigned have;
+    unsigned char *next;
+    z_off64_t pos;
+};
+ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
+#ifdef Z_PREFIX_SET
+#  undef z_gzgetc
+#  define z_gzgetc(g) \
+          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
+#else
+#  define gzgetc(g) \
+          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
+#endif
 
+/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
+ * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
+ * both are true, the application gets the *64 functions, and the regular
+ * functions are changed to 64 bits) -- in case these are set on systems
+ * without large file support, _LFS64_LARGEFILE must also be true
+ */
+#ifdef Z_LARGE64
+   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
+   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
+   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
+   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
+   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
+   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
+#endif
+
+#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
+#  ifdef Z_PREFIX_SET
+#    define z_gzopen z_gzopen64
+#    define z_gzseek z_gzseek64
+#    define z_gztell z_gztell64
+#    define z_gzoffset z_gzoffset64
+#    define z_adler32_combine z_adler32_combine64
+#    define z_crc32_combine z_crc32_combine64
+#  else
+#    define gzopen gzopen64
+#    define gzseek gzseek64
+#    define gztell gztell64
+#    define gzoffset gzoffset64
+#    define adler32_combine adler32_combine64
+#    define crc32_combine crc32_combine64
+#  endif
+#  ifndef Z_LARGE64
+     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
+     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
+     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
+     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
+     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
+     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
+#  endif
+#else
+   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
+   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
+   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
+   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
+   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
+   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
+#endif
+
+#else /* Z_SOLO */
 
+   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
+   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
+
+#endif /* !Z_SOLO */
+
+/* hack for buggy compilers */
 #if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;}; /* hack for buggy compilers */
+    struct internal_state {int dummy;};
 #endif
 
+/* undocumented functions */
 ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
+ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
+ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
+ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
+ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
+#if defined(_WIN32) && !defined(Z_SOLO)
+ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
+                                            const char *mode));
+#endif
+#if defined(STDC) || defined(Z_HAVE_STDARG_H)
+#  ifndef Z_SOLO
+ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
+                                                  const char *format,
+                                                  va_list va));
+#  endif
+#endif
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* ZLIB_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/zutil.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/zutil.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/zutil.c	2007-05-22 07:45:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/zutil.c	2013-06-10 13:27:33.000000000 +0800
@@ -1,20 +1,23 @@
 /* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * Copyright (C) 1995-2005, 2010, 2011, 2012 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* @(#) $Id$ */
 
 #include "zutil.h"
+#ifndef Z_SOLO
+#  include "gzguts.h"
+#endif
 
 #ifndef NO_DUMMY_DECL
 struct internal_state      {int dummy;}; /* for buggy compilers */
 #endif
 
-const char * const z_errmsg[10] = {
+z_const char * const z_errmsg[10] = {
 "need dictionary",     /* Z_NEED_DICT       2  */
 "stream end",          /* Z_STREAM_END      1  */
 "",                    /* Z_OK              0  */
 "file error",          /* Z_ERRNO         (-1) */
 "stream error",        /* Z_STREAM_ERROR  (-2) */
 "data error",          /* Z_DATA_ERROR    (-3) */
@@ -31,31 +34,31 @@
 
 uLong ZEXPORT zlibCompileFlags()
 {
     uLong flags;
 
     flags = 0;
-    switch (sizeof(uInt)) {
+    switch ((int)(sizeof(uInt))) {
     case 2:     break;				/* CONSTANT CONDITION */
     case 4:     flags += 1;     break;		/* CONSTANT CONDITION */
     case 8:     flags += 2;     break;		/* CONSTANT CONDITION */
     default:    flags += 3;
     }
-    switch (sizeof(uLong)) {
+    switch ((int)(sizeof(uLong))) {
     case 2:     break;				/* CONSTANT CONDITION */
     case 4:     flags += 1 << 2;        break;	/* CONSTANT CONDITION */
     case 8:     flags += 2 << 2;        break;	/* CONSTANT CONDITION */
     default:    flags += 3 << 2;
     }
-    switch (sizeof(voidpf)) {
+    switch ((int)(sizeof(voidpf))) {
     case 2:     break;				/* CONSTANT CONDITION */
     case 4:     flags += 1 << 4;        break;	/* CONSTANT CONDITION */
     case 8:     flags += 2 << 4;        break;	/* CONSTANT CONDITION */
     default:    flags += 3 << 4;
     }
-    switch (sizeof(z_off_t)) {
+    switch ((int)(sizeof(z_off_t))) {
     case 2:     break;				/* CONSTANT CONDITION */
     case 4:     flags += 1 << 6;        break;	/* CONSTANT CONDITION */
     case 8:     flags += 2 << 6;        break;	/* CONSTANT CONDITION */
     default:    flags += 3 << 6;
     }
 #ifdef DEBUG
@@ -82,47 +85,47 @@
 #ifdef PKZIP_BUG_WORKAROUND
     flags += 1L << 20;
 #endif
 #ifdef FASTEST
     flags += 1L << 21;
 #endif
-#ifdef STDC
+#if defined(STDC) || defined(Z_HAVE_STDARG_H)
 #  ifdef NO_vsnprintf
-        flags += 1L << 25;
+    flags += 1L << 25;
 #    ifdef HAS_vsprintf_void
-        flags += 1L << 26;
+    flags += 1L << 26;
 #    endif
 #  else
 #    ifdef HAS_vsnprintf_void
-        flags += 1L << 26;
+    flags += 1L << 26;
 #    endif
 #  endif
 #else
-        flags += 1L << 24;
+    flags += 1L << 24;
 #  ifdef NO_snprintf
-        flags += 1L << 25;
+    flags += 1L << 25;
 #    ifdef HAS_sprintf_void
-        flags += 1L << 26;
+    flags += 1L << 26;
 #    endif
 #  else
 #    ifdef HAS_snprintf_void
-        flags += 1L << 26;
+    flags += 1L << 26;
 #    endif
 #  endif
 #endif
     return flags;
 }
 
 #ifdef DEBUG
 
 #  ifndef verbose
 #    define verbose 0
 #  endif
-int z_verbose = verbose;
+int ZLIB_INTERNAL z_verbose = verbose;
 
-void z_error (m)
+void ZLIB_INTERNAL z_error (m)
     char *m;
 {
     fprintf(stderr, "%s\n", m);
     exit(1);
 }
 #endif
@@ -143,47 +146,48 @@
      */
     int errno = 0;
 #endif
 
 #ifndef HAVE_MEMCPY
 
-void zmemcpy(dest, source, len)
+void ZLIB_INTERNAL zmemcpy(dest, source, len)
     Bytef* dest;
     const Bytef* source;
     uInt  len;
 {
     if (len == 0) return;
     do {
         *dest++ = *source++; /* ??? to be unrolled */
     } while (--len != 0);
 }
 
-int zmemcmp(s1, s2, len)
+int ZLIB_INTERNAL zmemcmp(s1, s2, len)
     const Bytef* s1;
     const Bytef* s2;
     uInt  len;
 {
     uInt j;
 
     for (j = 0; j < len; j++) {
         if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
     }
     return 0;
 }
 
-void zmemzero(dest, len)
+void ZLIB_INTERNAL zmemzero(dest, len)
     Bytef* dest;
     uInt  len;
 {
     if (len == 0) return;
     do {
         *dest++ = 0;  /* ??? to be unrolled */
     } while (--len != 0);
 }
 #endif
 
+#ifndef Z_SOLO
 
 #ifdef SYS16BIT
 
 #ifdef __TURBOC__
 /* Turbo C in 16-bit mode */
 
@@ -210,13 +214,13 @@
  * to large buffers (64K). Such pointers are normalized with a zero offset.
  * Since MSDOS is not a preemptive multitasking OS, this table is not
  * protected from concurrent access. This hack doesn't work anyway on
  * a protected system like OS/2. Use Microsoft C instead.
  */
 
-voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
 {
     voidpf buf = opaque; /* just to make some compilers happy */
     ulg bsize = (ulg)items*size;
 
     /* If we allocate less than 65520 bytes, we assume that farmalloc
      * will return a usable pointer which doesn't have to be normalized.
@@ -234,13 +238,13 @@
     *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
     *(ush*)&buf = 0;
     table[next_ptr++].new_ptr = buf;
     return buf;
 }
 
-void  zcfree (voidpf opaque, voidpf ptr)
+void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
 {
     int n;
     if (*(ush*)&ptr != 0) { /* object < 64K */
         farfree(ptr);
         return;
     }
@@ -269,19 +273,19 @@
 
 #if (!defined(_MSC_VER) || (_MSC_VER <= 600))
 #  define _halloc  halloc
 #  define _hfree   hfree
 #endif
 
-voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
 {
     if (opaque) opaque = 0; /* to make compiler happy */
     return _halloc((long)items, size);
 }
 
-void  zcfree (voidpf opaque, voidpf ptr)
+void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
 {
     if (opaque) opaque = 0; /* to make compiler happy */
     _hfree(ptr);
 }
 
 #endif /* M_I86 */
@@ -294,25 +298,27 @@
 #ifndef STDC
 extern voidp  malloc OF((uInt size));
 extern voidp  calloc OF((uInt items, uInt size));
 extern void   free   OF((voidpf ptr));
 #endif
 
-voidpf zcalloc (opaque, items, size)
+voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
     voidpf opaque;
     unsigned items;
     unsigned size;
 {
     if (opaque) items += size - size; /* make compiler happy */
     return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
                               (voidpf)calloc(items, size);
 }
 
-void  zcfree (opaque, ptr)
+void ZLIB_INTERNAL zcfree (opaque, ptr)
     voidpf opaque;
     voidpf ptr;
 {
     free(ptr);
     if (opaque) return; /* make compiler happy */
 }
 
 #endif /* MY_ZCALLOC */
+
+#endif /* !Z_SOLO */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/zutil.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/zutil.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.9/zlib/zutil.h	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.1.0/zlib/zutil.h	2013-06-10 13:27:33.000000000 +0800
@@ -1,8 +1,8 @@
 /* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * Copyright (C) 1995-2013 Jean-loup Gailly.
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
 /* WARNING: this file should *not* be used by applications. It is
    part of the implementation of the compression library and is
    subject to change. Applications should only use zlib.h.
@@ -15,34 +15,23 @@
 
 #define ZLIB_INTERNAL
 #include "../rsync.h"
 #include "zlib.h"
 
 #if 0
-#ifdef STDC
-#  ifndef _WIN32_WCE
+#if defined(STDC) && !defined(Z_SOLO)
+#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
 #    include <stddef.h>
 #  endif
 #  include <string.h>
 #  include <stdlib.h>
 #endif
-#ifdef NO_ERRNO_H
-#   ifdef _WIN32_WCE
-      /* The Microsoft C Run-Time Library for Windows CE doesn't have
-       * errno.  We define it as a global variable to simplify porting.
-       * Its value is always 0 and should not be used.  We rename it to
-       * avoid conflict with other libraries that use the same workaround.
-       */
-#     define errno z_errno
-#   endif
-    extern int errno;
-#else
-#  ifndef _WIN32_WCE
-#    include <errno.h>
-#  endif
 #endif
+
+#ifdef Z_SOLO
+   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
 #endif
 
 #ifndef local
 #  define local static
 #endif
 /* compile with -Dlocal if your debugger can't find static symbols */
@@ -50,19 +39,19 @@
 typedef unsigned char  uch;
 typedef uch FAR uchf;
 typedef unsigned short ush;
 typedef ush FAR ushf;
 typedef unsigned long  ulg;
 
-extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
+extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
 /* (size given to avoid silly warnings with Visual C++) */
 
 #define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
 
 #define ERR_RETURN(strm,err) \
-  return (strm->msg = (char*)ERR_MSG(err), (err))
+  return (strm->msg = ERR_MSG(err), (err))
 /* To be used only when the state is known to be valid */
 
         /* common constants */
 
 #ifndef DEF_WBITS
 #  define DEF_WBITS MAX_WBITS
@@ -88,22 +77,24 @@
 #define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
 
         /* target dependencies */
 
 #if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
 #  define OS_CODE  0x00
-#  if defined(__TURBOC__) || defined(__BORLANDC__)
-#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
-       /* Allow compilation with ANSI keywords only enabled */
-       void _Cdecl farfree( void *block );
-       void *_Cdecl farmalloc( unsigned long nbytes );
-#    else
-#      include <alloc.h>
+#  ifndef Z_SOLO
+#    if defined(__TURBOC__) || defined(__BORLANDC__)
+#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
+         /* Allow compilation with ANSI keywords only enabled */
+         void _Cdecl farfree( void *block );
+         void *_Cdecl farmalloc( unsigned long nbytes );
+#      else
+#        include <alloc.h>
+#      endif
+#    else /* MSC or DJGPP */
+#      include <malloc.h>
 #    endif
-#  else /* MSC or DJGPP */
-#    include <malloc.h>
 #  endif
 #endif
 
 #ifdef AMIGA
 #  define OS_CODE  0x01
 #endif
@@ -117,24 +108,26 @@
 #if defined(ATARI) || defined(atarist)
 #  define OS_CODE  0x05
 #endif
 
 #ifdef OS2
 #  define OS_CODE  0x06
-#  ifdef M_I86
-     #include <malloc.h>
+#  if defined(M_I86) && !defined(Z_SOLO)
+#    include <malloc.h>
 #  endif
 #endif
 
 #if defined(MACOS) || defined(TARGET_OS_MAC)
 #  define OS_CODE  0x07
-#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#    include <unix.h> /* for fdopen */
-#  else
-#    ifndef fdopen
-#      define fdopen(fd,mode) NULL /* No fdopen() */
+#  ifndef Z_SOLO
+#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
+#      include <unix.h> /* for fdopen */
+#    else
+#      ifndef fdopen
+#        define fdopen(fd,mode) NULL /* No fdopen() */
+#      endif
 #    endif
 #  endif
 #endif
 
 #ifdef TOPS20
 #  define OS_CODE  0x0a
@@ -151,70 +144,50 @@
 #endif
 
 #if defined(_BEOS_) || defined(RISCOS)
 #  define fdopen(fd,mode) NULL /* No fdopen() */
 #endif
 
-#if (defined(_MSC_VER) && (_MSC_VER > 600))
+#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
 #  if defined(_WIN32_WCE)
 #    define fdopen(fd,mode) NULL /* No fdopen() */
 #    ifndef _PTRDIFF_T_DEFINED
        typedef int ptrdiff_t;
 #      define _PTRDIFF_T_DEFINED
 #    endif
 #  else
 #    define fdopen(fd,type)  _fdopen(fd,type)
 #  endif
 #endif
 
+#if defined(__BORLANDC__) && !defined(MSDOS)
+  #pragma warn -8004
+  #pragma warn -8008
+  #pragma warn -8066
+#endif
+
+/* provide prototypes for these when building zlib without LFS */
+#if !defined(_WIN32) && \
+    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
+    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
+    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
+#endif
+
         /* common defaults */
 
 #ifndef OS_CODE
 #  define OS_CODE  0x03  /* assume Unix */
 #endif
 
 #ifndef F_OPEN
 #  define F_OPEN(name, mode) fopen((name), (mode))
 #endif
 
          /* functions */
 
-#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-#if defined(__CYGWIN__)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-#ifndef HAVE_VSNPRINTF
-#  ifdef MSDOS
-     /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
-        but for now we just assume it doesn't. */
-#    define NO_vsnprintf
-#  endif
-#  ifdef __TURBOC__
-#    define NO_vsnprintf
-#  endif
-#  ifdef WIN32
-     /* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
-#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
-#      define vsnprintf _vsnprintf
-#    endif
-#  endif
-#  ifdef __SASC
-#    define NO_vsnprintf
-#  endif
-#endif
-#ifdef VMS
-#  define NO_vsnprintf
-#endif
-
-#if defined(pyr)
+#if defined(pyr) || defined(Z_SOLO)
 #  define NO_MEMCPY
 #endif
 #if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
  /* Use our own functions for small and medium model with MSC <= 5.0.
   * You may have to use the same strategy for Borland C (untested).
   * The __SC__ check is for Symantec.
@@ -232,22 +205,22 @@
 #  else
 #    define zmemcpy memcpy
 #    define zmemcmp memcmp
 #    define zmemzero(dest, len) memset(dest, 0, len)
 #  endif
 #else
-   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
-   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
-   extern void zmemzero OF((Bytef* dest, uInt len));
+   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
+   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
+   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
 #endif
 
 /* Diagnostic functions */
 #ifdef DEBUG
 #  include <stdio.h>
-   extern int z_verbose;
-   extern void z_error    OF((char *m));
+   extern int ZLIB_INTERNAL z_verbose;
+   extern void ZLIB_INTERNAL z_error OF((char *m));
 #  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
 #  define Trace(x) {if (z_verbose>=0) fprintf x ;}
 #  define Tracev(x) {if (z_verbose>0) fprintf x ;}
 #  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
 #  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
 #  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
@@ -257,16 +230,22 @@
 #  define Tracev(x)
 #  define Tracevv(x)
 #  define Tracec(c,x)
 #  define Tracecv(c,x)
 #endif
 
-
-voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
-void   zcfree  OF((voidpf opaque, voidpf ptr));
+#ifndef Z_SOLO
+   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
+                                    unsigned size));
+   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
+#endif
 
 #define ZALLOC(strm, items, size) \
            (*((strm)->zalloc))((strm)->opaque, (items), (size))
 #define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
 #define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
 
+/* Reverse the bytes in a 32-bit value */
+#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
+                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
+
 #endif /* ZUTIL_H */
