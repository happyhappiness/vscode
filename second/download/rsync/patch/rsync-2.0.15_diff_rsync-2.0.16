diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/cvs.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/cvs.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/cvs.log	1998-05-30 10:10:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/cvs.log	1998-06-01 21:49:20.000000000 +0800
@@ -5322,6 +5322,99 @@
 
 Modified Files:
 	rsync.spec 
 Log Message:
 preparing for release of 2.0.15
 
+
+****************************************
+Date:	Monday June 1, 1998 @ 13:42
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4722
+
+Modified Files:
+	flist.c io.c main.c match.c options.c rsync.1 rsync.c rsync.h 
+Log Message:
+added --stats option for verbose stats on the file transfer
+
+
+
+****************************************
+Date:	Monday June 1, 1998 @ 20:38
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv15388
+
+Modified Files:
+	options.c rsync.yo 
+Log Message:
+updated the usage info 
+
+
+
+
+****************************************
+Date:	Monday June 1, 1998 @ 23:39
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv19030
+
+Modified Files:
+	flist.c proto.h util.c 
+Log Message:
+replace calls to strcmp() with a u_strcmp() function that uses only
+unsigned comparisons. Transferring files between two machines that
+treated strcmp() differently led to the files being given the wrong
+name at the destination if the filenames had characters > 128 (such as
+Kanji characters) and the source and destination machines treated
+strcmp() differently (ie. one treated strings as signed and the other
+as unsigned).
+
+We now treat all string comparisons for file list sorting as unsigned.
+
+
+
+
+
+****************************************
+Date:	Monday June 1, 1998 @ 23:44
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv19712
+
+Modified Files:
+	test.sh 
+Log Message:
+added some notes to test.sh
+
+
+
+****************************************
+Date:	Monday June 1, 1998 @ 23:49
+Author:	rsync-bu
+
+Update of /data/cvs/rsync
+In directory samba:/data/people/rsync-bugs/rsync
+
+Modified Files:
+	version.h 
+Log Message:
+preparing for release of 2.0.16
+
+
+****************************************
+Date:	Monday June 1, 1998 @ 23:49
+Author:	rsync-bu
+
+Update of /data/cvs/rsync/packaging/redhat/5.0
+In directory samba:/data/people/rsync-bugs/rsync/packaging/redhat/5.0
+
+Modified Files:
+	rsync.spec 
+Log Message:
+preparing for release of 2.0.16
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/flist.c	1998-05-30 10:08:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/flist.c	1998-06-01 21:47:37.000000000 +0800
@@ -18,18 +18,19 @@
 */
 
 /* generate and receive file lists */
 
 #include "rsync.h"
 
+extern struct stats stats;
+
 extern int csum_length;
 
 extern int verbose;
 extern int am_server;
 extern int always_checksum;
-extern int64 total_size;
 
 extern int cvs_exclude;
 
 extern int recurse;
 
 extern int one_file_system;
@@ -418,13 +419,13 @@
 		}
 	} else {
 		file->basedir = NULL;
 	}
 
 	if (!S_ISDIR(st.st_mode))
-		total_size += st.st_size;
+		stats.total_size += st.st_size;
 
 	return file;
 }
 
 
 
@@ -522,18 +523,21 @@
 {
 	int i,l;
 	STRUCT_STAT st;
 	char *p,*dir;
 	char lastpath[MAXPATHLEN]="";
 	struct file_list *flist;
+	int64 start_write;
 
 	if (verbose && recurse && !am_server && f != -1) {
 		rprintf(FINFO,"building file list ... ");
 		rflush(FINFO);
 	}
 
+	start_write = stats.total_written;
+
 	flist = (struct file_list *)malloc(sizeof(flist[0]));
 	if (!flist) out_of_memory("send_file_list");
 
 	flist->count=0;
 	flist->malloced = 1000;
 	flist->files = (struct file_struct **)malloc(sizeof(flist->files[0])*
@@ -648,12 +652,14 @@
 	if (f != -1 && remote_version >= 17) {
 		write_int(f, io_error);
 	}
 
 	if (f != -1) {
 		io_end_buffering(f);
+		stats.flist_size = stats.total_written - start_write;
+		stats.num_files = flist->count;
 	}
 
 	if (verbose > 2)
 		rprintf(FINFO,"send_file_list done\n");
 
 	return flist;
@@ -661,18 +667,21 @@
 
 
 struct file_list *recv_file_list(int f)
 {
   struct file_list *flist;
   unsigned char flags;
+  int64 start_read;
 
   if (verbose && recurse && !am_server) {
     rprintf(FINFO,"receiving file list ... ");
     rflush(FINFO);
   }
 
+  start_read = stats.total_read;
+
   flist = (struct file_list *)malloc(sizeof(flist[0]));
   if (!flist)
     goto oom;
 
   flist->count=0;
   flist->malloced=1000;
@@ -697,13 +706,13 @@
 		  goto oom;
     }
 
     receive_file_entry(&flist->files[i],flags,f);
 
     if (S_ISREG(flist->files[i]->mode))
-      total_size += flist->files[i]->length;
+	    stats.total_size += flist->files[i]->length;
 
     flist->count++;
 
     if (verbose > 2)
       rprintf(FINFO,"recv_file_name(%s)\n",f_name(flist->files[i]));
   }
@@ -728,12 +737,15 @@
 	  io_error |= read_int(f);
   }
 
   if (verbose > 2)
     rprintf(FINFO,"recv_file_list done\n");
 
+  stats.flist_size = stats.total_read - start_read;
+  stats.num_files = flist->count;
+
   return flist;
 
 oom:
     out_of_memory("recv_file_list");
     return NULL; /* not reached */
 }
@@ -742,14 +754,14 @@
 int file_compare(struct file_struct **f1,struct file_struct **f2)
 {
 	if (!(*f1)->basename && !(*f2)->basename) return 0;
 	if (!(*f1)->basename) return -1;
 	if (!(*f2)->basename) return 1;
 	if ((*f1)->dirname == (*f2)->dirname)
-		return strcmp((*f1)->basename, (*f2)->basename);
-	return strcmp(f_name(*f1),f_name(*f2));
+		return u_strcmp((*f1)->basename, (*f2)->basename);
+	return u_strcmp(f_name(*f1),f_name(*f2));
 }
 
 
 int flist_find(struct file_list *flist,struct file_struct *f)
 {
 	int low=0,high=flist->count-1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/io.c	1998-05-30 10:08:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/io.c	1998-06-01 21:47:37.000000000 +0800
@@ -21,34 +21,21 @@
   Utilities used in rsync 
 
   tridge, June 1996
   */
 #include "rsync.h"
 
-static int64 total_written;
-static int64 total_read;
-
 static int io_multiplexing_out;
 static int io_multiplexing_in;
 static int multiplex_in_fd;
 static int multiplex_out_fd;
 static time_t last_io;
 static int eof_error=1;
 extern int verbose;
 extern int io_timeout;
-
-
-int64 write_total(void)
-{
-	return total_written;
-}
-
-int64 read_total(void)
-{
-	return total_read;
-}
+extern struct stats stats;
 
 static int buffer_f_in = -1;
 
 void setup_readbuffer(int f_in)
 {
 	buffer_f_in = f_in;
@@ -105,12 +92,13 @@
 			continue;
 		}
 
 		n = read(fd, buf, len);
 
 		if (n > 0) {
+			stats.total_read += n;
 			buf += n;
 			len -= n;
 			ret += n;
 			if (io_timeout)
 				last_io = time(NULL);
 			continue;
@@ -264,13 +252,12 @@
 
 
 int32 read_int(int f)
 {
 	char b[4];
 	readfd(f,b,4);
-	total_read += 4;
 	return IVAL(b,0);
 }
 
 int64 read_longint(int f)
 {
 	extern int remote_version;
@@ -283,24 +270,22 @@
 #ifdef NO_INT64
 	rprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
 	exit_cleanup(1);
 #else
 	if (remote_version >= 16) {
 		readfd(f,b,8);
-		total_read += 8;
 		ret = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
 	}
 #endif
 
 	return ret;
 }
 
 void read_buf(int f,char *buf,int len)
 {
 	readfd(f,buf,len);
-	total_read += len;
 }
 
 void read_sbuf(int f,char *buf,int len)
 {
 	read_buf(f,buf,len);
 	buf[len] = 0;
@@ -365,12 +350,14 @@
 			if (ret <= 0) {
 				rprintf(FERROR,"erroring writing %d bytes - exiting\n", len);
 				exit_cleanup(1);
 			}
 
 			total += ret;
+			stats.total_written += ret;
+
 			if (io_timeout)
 				last_io = time(NULL);
 			continue;
 		}
 
 		if (reading && FD_ISSET(buffer_f_in, &r_fds)) {
@@ -443,13 +430,12 @@
 
 void write_int(int f,int32 x)
 {
 	char b[4];
 	SIVAL(b,0,x);
 	writefd(f,b,4);
-	total_written += 4;
 }
 
 void write_longint(int f, int64 x)
 {
 	extern int remote_version;
 	char b[8];
@@ -461,19 +447,17 @@
 
 	write_int(f, -1);
 	SIVAL(b,0,(x&0xFFFFFFFF));
 	SIVAL(b,4,((x>>32)&0xFFFFFFFF));
 
 	writefd(f,b,8);
-	total_written += 8;
 }
 
 void write_buf(int f,char *buf,int len)
 {
 	writefd(f,buf,len);
-	total_written += len;
 }
 
 /* write a string to the connection */
 void write_sbuf(int f,char *buf)
 {
 	write_buf(f, buf, strlen(buf));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/main.c	1998-05-30 10:08:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/main.c	1998-06-01 21:47:37.000000000 +0800
@@ -17,58 +17,80 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
 time_t starttime = 0;
-int64 total_size = 0;
+
+struct stats stats;
 
 extern int csum_length;
 
 extern int verbose;
 
 static void report(int f)
 {
-	int64 in,out,tsize;
 	time_t t = time(NULL);
 	extern int am_server;
 	extern int am_sender;
 	extern int am_daemon;
+	extern int do_stats;
 
 	if (am_daemon) {
 		syslog(LOG_INFO,"wrote %.0f bytes  read %.0f bytes  total size %.0f\n",
-		       (double)write_total(),(double)read_total(),
-		       (double)total_size);
+		       (double)stats.total_written,
+		       (double)stats.total_read,
+		       (double)stats.total_size);
 		if (f == -1 || !am_sender) return;
 	}
 
 	if (!verbose) return;
 
 	if (am_server && !am_sender) return;
 
 	if (am_server && am_sender) {
-		write_longint(f,read_total());
-		write_longint(f,write_total());
-		write_longint(f,total_size);
+		write_longint(f,stats.total_read);
+		write_longint(f,stats.total_written);
+		write_longint(f,stats.total_size);
 		return;
 	}
     
-	if (am_sender) {
-		in = read_total();
-		out = write_total();
-		tsize = total_size;
-	} else {
-		out = read_longint(f);
-		in = read_longint(f);
-		tsize = read_longint(f);
+	if (!am_sender) {
+		int64 r;
+		stats.total_written = read_longint(f);
+		r = read_longint(f);
+		stats.total_size = read_longint(f);
+		stats.total_read = r;
+	}
+
+	if (do_stats) {
+		printf("\nNumber of files: %d\n", stats.num_files);
+		printf("Number of files transferred: %d\n", 
+		       stats.num_transferred_files);
+		printf("Total file size: %.0f bytes\n", 
+		       (double)stats.total_size);
+		printf("Total transferred file size: %.0f bytes\n", 
+		       (double)stats.total_transferred_size);
+		printf("Literal data: %.0f bytes\n", 
+		       (double)stats.literal_data);
+		printf("Matched data: %.0f bytes\n", 
+		       (double)stats.matched_data);
+		printf("File list size: %d\n", stats.flist_size);
+		printf("Total bytes written: %.0f\n", 
+		       (double)stats.total_written);
+		printf("Total bytes read: %.0f\n\n", 
+		       (double)stats.total_read);
 	}
 	
 	printf("wrote %.0f bytes  read %.0f bytes  %.2f bytes/sec\n",
-	       (double)out,(double)in,(in+out)/(0.5 + (t-starttime)));
+	       (double)stats.total_written,
+	       (double)stats.total_read,
+	       (stats.total_written+stats.total_read)/(0.5 + (t-starttime)));
 	printf("total size is %.0f  speedup is %.2f\n",
-	       (double)tsize,(1.0*tsize)/(in+out));
+	       (double)stats.total_size,
+	       (1.0*stats.total_size)/(stats.total_written+stats.total_read));
 }
 
 
 static int do_cmd(char *cmd,char *machine,char *user,char *path,int *f_in,int *f_out)
 {
 	char *args[100];
@@ -495,12 +517,14 @@
 
 	signal(SIGUSR1, sigusr1_handler);
 
 	starttime = time(NULL);
 	am_root = (getuid() == 0);
 
+	memset(&stats, 0, sizeof(stats));
+
 	if (argc < 2) {
 		usage(FERROR);
 		exit_cleanup(1);
 	}
 
 	/* we set a 0 umask so that correct file permissions can be
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/match.c	1998-05-27 21:54:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/match.c	1998-06-01 21:47:38.000000000 +0800
@@ -31,19 +31,19 @@
 #define TABLESIZE (1<<16)
 #define NULL_TAG ((tag)-1)
 
 static int false_alarms;
 static int tag_hits;
 static int matches;
-static int data_transfer;
+static int64 data_transfer;
 
 static int total_false_alarms;
 static int total_tag_hits;
 static int total_matches;
-static int64 total_data_transfer;
 
+extern struct stats stats;
 
 struct target {
   tag t;
   int i;
 };
 
@@ -100,14 +100,16 @@
 		rprintf(FINFO,"match at %d last_match=%d j=%d len=%d n=%d\n",
 			(int)offset,(int)last_match,i,(int)s->sums[i].len,(int)n);
 
 	send_token(f,i,buf,last_match,n,i<0?0:s->sums[i].len);
 	data_transfer += n;
 
-	if (i >= 0)
+	if (i >= 0) {
+		stats.matched_data += s->sums[i].len;
 		n += s->sums[i].len;
+	}
   
 	for (j=0;j<n;j+=CHUNK_SIZE) {
 		int n1 = MIN(CHUNK_SIZE,n-j);
 		sum_update(map_ptr(buf,last_match+j,n1),n1);
 	}
 
@@ -270,19 +272,20 @@
 		rprintf(FINFO, "false_alarms=%d tag_hits=%d matches=%d\n",
 			false_alarms, tag_hits, matches);
 	
 	total_tag_hits += tag_hits;
 	total_false_alarms += false_alarms;
 	total_matches += matches;
-	total_data_transfer += data_transfer;
+	stats.literal_data += data_transfer;
 }
 
 void match_report(void)
 {
 	if (verbose <= 1)
 		return;
 
 	rprintf(FINFO,
-		"total: matches=%d  tag_hits=%d  false_alarms=%d  data=%ld\n",
+		"total: matches=%d  tag_hits=%d  false_alarms=%d data=%.0f\n",
 		total_matches,total_tag_hits,
-		total_false_alarms,(long)total_data_transfer);
+		total_false_alarms,
+		(double)stats.literal_data);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/options.c	1998-05-30 10:08:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/options.c	1998-06-01 21:47:38.000000000 +0800
@@ -52,12 +52,13 @@
 int module_id = -1;
 int am_server = 0;
 int am_sender=0;
 int recurse = 0;
 int am_daemon=0;
 int am_client=0;
+int do_stats=0;
 
 int block_size=BLOCK_SIZE;
 
 char *backup_suffix = BACKUP_SUFFIX;
 char *tmpdir = NULL;
 char *config_file = RSYNCD_CONF;
@@ -71,15 +72,18 @@
 
 
 void usage(int F)
 {
   rprintf(F,"rsync version %s Copyright Andrew Tridgell and Paul Mackerras\n\n",
 	  VERSION);
-  rprintf(F,"Usage:\t%s [options] src user@host:dest\nOR",RSYNC_NAME);
-  rprintf(F,"\t%s [options] user@host:src dest\n\n",RSYNC_NAME);
-  rprintf(F,"Options:\n");
+  rprintf(F,"Usage:\t%s [options] src user@host:dest\n",RSYNC_NAME);
+  rprintf(F,"OR\t%s [options] user@host:src dest\n",RSYNC_NAME);
+  rprintf(F,"OR\t%s [options] src dest\n",RSYNC_NAME);
+  rprintf(F,"OR\t%s [options] user@host::src dest\n",RSYNC_NAME);
+  rprintf(F,"OR\t%s [options] src user@host::dest\n",RSYNC_NAME);
+  rprintf(F,"\nOptions:\n");
   rprintf(F,"-v, --verbose            increase verbosity\n");
   rprintf(F,"-c, --checksum           always checksum\n");
   rprintf(F,"-a, --archive            archive mode\n");
   rprintf(F,"-r, --recursive          recurse into directories\n");
   rprintf(F,"-R, --relative           use relative path names\n");
   rprintf(F,"-b, --backup             make backups (default ~ extension)\n");
@@ -112,23 +116,27 @@
   rprintf(F,"    --include FILE       don't exclude file FILE\n");
   rprintf(F,"    --include-from FILE  don't exclude files listed in FILE\n");
   rprintf(F,"    --suffix SUFFIX      override backup suffix\n");  
   rprintf(F,"    --version            print version number\n");  
   rprintf(F,"    --daemon             run as a rsync daemon\n");  
   rprintf(F,"    --config FILE        specify alternate rsyncd.conf file\n");  
-  rprintf(F,"    --port PORT          specify alternate rsyncd port number\n");  
+  rprintf(F,"    --port PORT          specify alternate rsyncd port number\n");
+  rprintf(F,"    --stats              give some file transfer stats\n");  
 
   rprintf(F,"\n");
   rprintf(F,"the backup suffix defaults to %s\n",BACKUP_SUFFIX);
   rprintf(F,"the block size defaults to %d\n",BLOCK_SIZE);  
+
+  rprintf(F,"\nPlease see the rsync(1) and rsyncd.conf(5) man pages for full documentation\n");
+  rprintf(F,"See http://samba.anu.edu.au/rsync/ for updates and bug reports\n");
 }
 
 enum {OPT_VERSION,OPT_SUFFIX,OPT_SENDER,OPT_SERVER,OPT_EXCLUDE,
       OPT_EXCLUDE_FROM,OPT_DELETE,OPT_NUMERIC_IDS,OPT_RSYNC_PATH,
       OPT_FORCE,OPT_TIMEOUT,OPT_DAEMON,OPT_CONFIG,OPT_PORT,
-      OPT_INCLUDE, OPT_INCLUDE_FROM};
+      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_STATS};
 
 static char *short_options = "oblLWHpguDCtcahvrRIxnSe:B:T:z";
 
 static struct option long_options[] = {
   {"version",     0,     0,    OPT_VERSION},
   {"server",      0,     0,    OPT_SERVER},
@@ -167,12 +175,13 @@
   {"suffix",      1,     0,    OPT_SUFFIX},
   {"block-size",  1,     0,    'B'},
   {"timeout",     1,     0,    OPT_TIMEOUT},
   {"temp-dir",    1,     0,    'T'},
   {"compress",	  0,	 0,    'z'},
   {"daemon",      0,     0,    OPT_DAEMON},
+  {"stats",       0,     0,    OPT_STATS},
   {"config",      1,     0,    OPT_CONFIG},
   {"port",        1,     0,    OPT_PORT},
   {0,0,0,0}};
 
 void parse_arguments(int argc, char *argv[])
 {
@@ -361,12 +370,16 @@
 	  break;
 
 	case OPT_DAEMON:
 		am_daemon = 1;
 		break;
 
+	case OPT_STATS:
+		do_stats = 1;
+		break;
+
 	case OPT_CONFIG:
 		config_file = optarg;
 		break;
 
 	case OPT_PORT:
 		rsync_port = atoi(optarg);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/packaging/redhat/5.0/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/packaging/redhat/5.0/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/packaging/redhat/5.0/rsync.spec	1998-05-30 10:10:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/packaging/redhat/5.0/rsync.spec	1998-06-01 21:49:11.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.0.15
+Version: 2.0.16
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.0.15.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.0.16.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/proto.h	1998-05-30 10:08:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/proto.h	1998-06-01 21:47:38.000000000 +0800
@@ -41,14 +41,12 @@
 void flist_free(struct file_list *flist);
 void clean_flist(struct file_list *flist);
 char *f_name(struct file_struct *f);
 void init_hard_links(struct file_list *flist);
 int check_hard_link(struct file_struct *file);
 void do_hard_links(struct file_list *flist);
-int64 write_total(void);
-int64 read_total(void);
 void setup_readbuffer(int f_in);
 int32 read_int(int f);
 int64 read_longint(int f);
 void read_buf(int f,char *buf,int len);
 void read_sbuf(int f,char *buf,int len);
 unsigned char read_byte(int f);
@@ -165,6 +163,7 @@
 int vslprintf(char *str, int n, const char *format, va_list ap);
 int slprintf(char *str, int n, char *format, ...);
 void *Realloc(void *p, int size);
 void clean_fname(char *name);
 char *push_dir(char *dir, int save);
 int pop_dir(char *dir);
+int u_strcmp(const char *cs1, const char *cs2);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/rsync.1	1998-05-27 21:54:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/rsync.1	1998-06-01 21:47:38.000000000 +0800
@@ -241,15 +241,18 @@
 a 128-bit MD4 checksum before transfer\&. The checksum is then
 explicitly checked on the receiver and any files of the same name
 which already exist and have the same checksum and size on the
 receiver are skipped\&.  This option can be quite slow\&.
 .IP 
 .IP "\fB-a, --archive\fP" 
-This is equivalent to -rlptDog\&. It is a quick way
+This is equivalent to -rlptDg\&. It is a quick way
 of saying I want recursion and want to preserve everything\&.
 .IP 
+Note: if the user launching rsync is root then the -o option (preserve
+uid) is also implied\&.
+.IP 
 .IP "\fB-r, --recursive\fP" 
 This tells rsync to copy directories recursively
 .IP 
 .IP "\fB-R, --relative\fP" 
 Use relative paths\&. This means that the full path
 names specified on the command line are sent to the server rather than
@@ -514,12 +517,17 @@
 specified\&. 
 .IP 
 .IP "\fB--port PORT\fP" 
 This specifies an alternate TCP port number to use
 rather than the default port 873\&. 
 .IP 
+.IP "\fB--stats\fP" 
+This tells rsync to print a verbose set of statistics
+on the file transfer, allowing you to tell how effective the rsync
+algorithm is for your data\&.
+.IP 
 .PP 
 .SH "EXCLUDE PATTERNS" 
 .PP 
 The exclude and include patterns specified to rsync allow for flexible
 selection of what files to transfer and what files to skip\&.
 .PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/rsync.c	1998-05-30 10:08:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/rsync.c	1998-06-01 21:47:38.000000000 +0800
@@ -48,12 +48,13 @@
 extern int delete_mode;
 extern int cvs_exclude;
 extern int am_root;
 extern int relative_paths;
 extern int io_timeout;
 extern int io_error;
+extern struct stats stats;
 
 /*
   free a sums struct
   */
 static void free_sums(struct sum_struct *s)
 {
@@ -556,12 +557,13 @@
 
   for (i=recv_token(f_in,&data); i != 0; i=recv_token(f_in,&data)) {
     if (i > 0) {
       if (verbose > 3)
 	rprintf(FINFO,"data recv %d at %d\n",i,(int)offset);
 
+      stats.literal_data += i;
       sum_update(data,i);
 
       if (fd != -1 && write_file(fd,data,i) != i) {
 	rprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
 	exit_cleanup(1);
       }
@@ -570,12 +572,14 @@
       i = -(i+1);
       offset2 = i*n;
       len = n;
       if (i == count-1 && remainder != 0)
 	len = remainder;
 
+      stats.matched_data += len;
+
       if (verbose > 3)
 	rprintf(FINFO,"chunk[%d] of size %d at %d offset=%d\n",
 		i,len,(int)offset2,(int)offset);
 
       map = map_ptr(buf,offset2,len);
 
@@ -736,221 +740,243 @@
 void sig_int(void)
 {
   exit_cleanup(1);
 }
 
 
-int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen)
-{  
-  int fd1,fd2;
-  STRUCT_STAT st;
-  char *fname;
-  char fnametmp[MAXPATHLEN];
-  struct map_struct *buf;
-  int i;
-  struct file_struct *file;
-  int phase=0;
-  int recv_ok;
 
-  if (verbose > 2) {
-    rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
-  }
 
-  if (recurse && delete_mode && !local_name && flist->count>0) {
-    delete_files(flist);
-  }
+static int get_tmpname(char *fnametmp, char *fname)
+{
+	char *f;
 
-  while (1) 
-    {      
-      i = read_int(f_in);
-      if (i == -1) {
-	if (phase==0 && remote_version >= 13) {
-	  phase++;
-	  csum_length = SUM_LENGTH;
-	  if (verbose > 2)
-	    rprintf(FINFO,"recv_files phase=%d\n",phase);
-	  write_int(f_gen,-1);
-	  continue;
+	/* open tmp file */
+	if (tmpdir) {
+		f = strrchr(fname,'/');
+		if (f == NULL) 
+			f = fname;
+		else 
+			f++;
+		if (strlen(tmpdir)+strlen(f)+10 > MAXPATHLEN) {
+			rprintf(FERROR,"filename too long\n");
+			return 0;
+		}
+		slprintf(fnametmp,MAXPATHLEN-1, "%s/.%s.XXXXXX",tmpdir,f);
+		return 1;
+	} 
+
+	f = strrchr(fname,'/');
+
+	if (strlen(fname)+9 > MAXPATHLEN) {
+		rprintf(FERROR,"filename too long\n");
+		return 0;
 	}
-	break;
-      }
 
-      file = flist->files[i];
-      fname = f_name(file);
+	if (f) {
+		*f = 0;
+		slprintf(fnametmp,MAXPATHLEN-1,"%s/.%s.XXXXXX",
+			 fname,f+1);
+		*f = '/';
+	} else {
+		slprintf(fnametmp,MAXPATHLEN-1,".%s.XXXXXX",fname);
+	}
 
-      if (local_name)
-	fname = local_name;
+	return 1;
+}
 
-      if (dry_run) {
-	if (!am_server && verbose)
-	  printf("%s\n",fname);
-	continue;
-      }
+int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen)
+{  
+	int fd1,fd2;
+	STRUCT_STAT st;
+	char *fname;
+	char fnametmp[MAXPATHLEN];
+	struct map_struct *buf;
+	int i;
+	struct file_struct *file;
+	int phase=0;
+	int recv_ok;
+	
+	if (verbose > 2) {
+		rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
+	}
 
-      if (verbose > 2)
-	rprintf(FINFO,"recv_files(%s)\n",fname);
+	if (recurse && delete_mode && !local_name && flist->count>0) {
+		delete_files(flist);
+	}
 
-      /* open the file */  
-      fd1 = open(fname,O_RDONLY);
+	while (1) {      
+		i = read_int(f_in);
+		if (i == -1) {
+			if (phase==0 && remote_version >= 13) {
+				phase++;
+				csum_length = SUM_LENGTH;
+				if (verbose > 2)
+					rprintf(FINFO,"recv_files phase=%d\n",phase);
+				write_int(f_gen,-1);
+				continue;
+			}
+			break;
+		}
 
-      if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
-	rprintf(FERROR,"fstat %s : %s\n",fname,strerror(errno));
-	receive_data(f_in,NULL,-1,NULL);
-	close(fd1);
-	continue;
-      }
+		if (i < 0 || i >= flist->count) {
+			rprintf(FERROR,"Invalid file index %d in recv_files (count=%d)\n", 
+				i, flist->count);
+			exit_cleanup(1);
+		}
 
-      if (fd1 != -1 && !S_ISREG(st.st_mode)) {
-	rprintf(FERROR,"%s : not a regular file (recv_files)\n",fname);
-	receive_data(f_in,NULL,-1,NULL);
-	close(fd1);
-	continue;
-      }
+		file = flist->files[i];
+		fname = f_name(file);
 
-      if (fd1 != -1 && st.st_size > 0) {
-	buf = map_file(fd1,st.st_size);
-	if (verbose > 2)
-	  rprintf(FINFO,"recv mapped %s of size %d\n",fname,(int)st.st_size);
-      } else {
-	buf = NULL;
-      }
+		stats.num_transferred_files++;
+		stats.total_transferred_size += file->length;
 
-      /* open tmp file */
-      if (tmpdir) {
-	      char *f;
-	      f = strrchr(fname,'/');
-	      if (f == NULL) 
-		      f = fname;
-	      else 
-		      f++;
-	      if (strlen(tmpdir)+strlen(f)+10 > MAXPATHLEN) {
-		      rprintf(FERROR,"filename too long\n");
-		      if (buf) unmap_file(buf);
-		      close(fd1);
-		      continue;
-	      }
-	      slprintf(fnametmp,sizeof(fnametmp)-1, "%s/.%s.XXXXXX",tmpdir,f);
-      } else {
-	      char *f = strrchr(fname,'/');
+		if (local_name)
+			fname = local_name;
 
-	      if (strlen(fname)+9 > MAXPATHLEN) {
-		      rprintf(FERROR,"filename too long\n");
-		      if (buf) unmap_file(buf);
-		      close(fd1);
-		      continue;
-	      }
-
-	      if (f) {
-		      *f = 0;
-		      slprintf(fnametmp,sizeof(fnametmp)-1,"%s/.%s.XXXXXX",fname,f+1);
-		      *f = '/';
-	      } else {
-		      slprintf(fnametmp,sizeof(fnametmp)-1,".%s.XXXXXX",fname);
-	      }
-      }
-      if (NULL == do_mktemp(fnametmp)) {
-	rprintf(FERROR,"mktemp %s failed\n",fnametmp);
-	receive_data(f_in,buf,-1,NULL);
-	if (buf) unmap_file(buf);
-	close(fd1);
-	continue;
-      }
-      fd2 = do_open(fnametmp,O_WRONLY|O_CREAT|O_EXCL,file->mode);
-      if (fd2 == -1 && relative_paths && errno == ENOENT && 
-	  create_directory_path(fnametmp) == 0) {
-	      fd2 = do_open(fnametmp,O_WRONLY|O_CREAT|O_EXCL,file->mode);
-      }
-      if (fd2 == -1) {
-	rprintf(FERROR,"open %s : %s\n",fnametmp,strerror(errno));
-	receive_data(f_in,buf,-1,NULL);
-	if (buf) unmap_file(buf);
-	close(fd1);
-	continue;
-      }
-      
-      cleanup_fname = fnametmp;
+		if (dry_run) {
+			if (!am_server && verbose)
+				printf("%s\n",fname);
+			continue;
+		}
 
-      if (!am_server && verbose)
-	printf("%s\n",fname);
+		if (verbose > 2)
+			rprintf(FINFO,"recv_files(%s)\n",fname);
 
-      /* recv file data */
-      recv_ok = receive_data(f_in,buf,fd2,fname);
+		/* open the file */  
+		fd1 = open(fname,O_RDONLY);
 
-      if (buf) unmap_file(buf);
-      if (fd1 != -1) {
-	close(fd1);
-      }
-      close(fd2);
+		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
+			rprintf(FERROR,"fstat %s : %s\n",fname,strerror(errno));
+			receive_data(f_in,NULL,-1,NULL);
+			close(fd1);
+			continue;
+		}
 
-      if (verbose > 2)
-	rprintf(FINFO,"renaming %s to %s\n",fnametmp,fname);
+		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
+			rprintf(FERROR,"%s : not a regular file (recv_files)\n",fname);
+			receive_data(f_in,NULL,-1,NULL);
+			close(fd1);
+			continue;
+		}
 
-      if (make_backups) {
-	char fnamebak[MAXPATHLEN];
-	if (strlen(fname) + strlen(backup_suffix) > (MAXPATHLEN-1)) {
-		rprintf(FERROR,"backup filename too long\n");
-		continue;
-	}
-	slprintf(fnamebak,sizeof(fnamebak)-1,"%s%s",fname,backup_suffix);
-	if (do_rename(fname,fnamebak) != 0 && errno != ENOENT) {
-	  rprintf(FERROR,"rename %s %s : %s\n",fname,fnamebak,strerror(errno));
-	  continue;
-	}
-      }
+		if (fd1 != -1 && st.st_size > 0) {
+			buf = map_file(fd1,st.st_size);
+			if (verbose > 2)
+				rprintf(FINFO,"recv mapped %s of size %d\n",fname,(int)st.st_size);
+		} else {
+			buf = NULL;
+		}
 
-      /* move tmp file over real file */
-      if (do_rename(fnametmp,fname) != 0) {
-	      if (errno == EXDEV) {
-		      /* rename failed on cross-filesystem link.  
-			 Copy the file instead. */
-		      if (copy_file(fnametmp,fname, file->mode)) {
-			      rprintf(FERROR,"copy %s -> %s : %s\n",
-				      fnametmp,fname,strerror(errno));
-		      } else {
-			      set_perms(fname,file,NULL,0);
-		      }
-		      do_unlink(fnametmp);
-	      } else {
-		      rprintf(FERROR,"rename %s -> %s : %s\n",
-			      fnametmp,fname,strerror(errno));
-		      do_unlink(fnametmp);
-	      }
-      } else {
-	      set_perms(fname,file,NULL,0);
-      }
+		if (!get_tmpname(fnametmp,fname)) {
+			if (buf) unmap_file(buf);
+			close(fd1);
+			continue;
+		}
 
-      cleanup_fname = NULL;
+		if (NULL == do_mktemp(fnametmp)) {
+			rprintf(FERROR,"mktemp %s failed\n",fnametmp);
+			receive_data(f_in,buf,-1,NULL);
+			if (buf) unmap_file(buf);
+			close(fd1);
+			continue;
+		}
 
+		fd2 = do_open(fnametmp,O_WRONLY|O_CREAT|O_EXCL,file->mode);
+		if (fd2 == -1 && relative_paths && errno == ENOENT && 
+		    create_directory_path(fnametmp) == 0) {
+			fd2 = do_open(fnametmp,O_WRONLY|O_CREAT|O_EXCL,file->mode);
+		}
+		if (fd2 == -1) {
+			rprintf(FERROR,"open %s : %s\n",fnametmp,strerror(errno));
+			receive_data(f_in,buf,-1,NULL);
+			if (buf) unmap_file(buf);
+			close(fd1);
+			continue;
+		}
+      
+		cleanup_fname = fnametmp;
 
-      if (!recv_ok) {
-	      if (csum_length == SUM_LENGTH) {
-		      rprintf(FERROR,"ERROR: file corruption in %s. File changed during transfer?\n",
-			      fname);
-	      } else {
-		      if (verbose > 1)
-			      rprintf(FINFO,"redoing %s(%d)\n",fname,i);
-		      write_int(f_gen,i);
-	      }
-      }
-    }
+		if (!am_server && verbose)
+			printf("%s\n",fname);
+		
+		/* recv file data */
+		recv_ok = receive_data(f_in,buf,fd2,fname);
+		
+		if (buf) unmap_file(buf);
+		if (fd1 != -1) {
+			close(fd1);
+		}
+		close(fd2);
+		
+		if (verbose > 2)
+			rprintf(FINFO,"renaming %s to %s\n",fnametmp,fname);
+		
+		if (make_backups) {
+			char fnamebak[MAXPATHLEN];
+			if (strlen(fname) + strlen(backup_suffix) > (MAXPATHLEN-1)) {
+				rprintf(FERROR,"backup filename too long\n");
+				continue;
+			}
+			slprintf(fnamebak,sizeof(fnamebak)-1,"%s%s",fname,backup_suffix);
+			if (do_rename(fname,fnamebak) != 0 && errno != ENOENT) {
+				rprintf(FERROR,"rename %s %s : %s\n",fname,fnamebak,strerror(errno));
+				continue;
+			}
+		}
 
-  if (preserve_hard_links)
-	  do_hard_links(flist);
+		/* move tmp file over real file */
+		if (do_rename(fnametmp,fname) != 0) {
+			if (errno == EXDEV) {
+				/* rename failed on cross-filesystem link.  
+				   Copy the file instead. */
+				if (copy_file(fnametmp,fname, file->mode)) {
+					rprintf(FERROR,"copy %s -> %s : %s\n",
+						fnametmp,fname,strerror(errno));
+				} else {
+					set_perms(fname,file,NULL,0);
+				}
+				do_unlink(fnametmp);
+			} else {
+				rprintf(FERROR,"rename %s -> %s : %s\n",
+					fnametmp,fname,strerror(errno));
+				do_unlink(fnametmp);
+			}
+		} else {
+			set_perms(fname,file,NULL,0);
+		}
 
-  /* now we need to fix any directory permissions that were 
-     modified during the transfer */
-  for (i = 0; i < flist->count; i++) {
-	  file = flist->files[i];
-	  if (!file->basename || !S_ISDIR(file->mode)) continue;
-	  recv_generator(f_name(file),flist,i,-1);
-  }
+		cleanup_fname = NULL;
 
-  if (verbose > 2)
-    rprintf(FINFO,"recv_files finished\n");
-  
-  return 0;
+		
+		if (!recv_ok) {
+			if (csum_length == SUM_LENGTH) {
+				rprintf(FERROR,"ERROR: file corruption in %s. File changed during transfer?\n",
+					fname);
+			} else {
+				if (verbose > 1)
+					rprintf(FINFO,"redoing %s(%d)\n",fname,i);
+				write_int(f_gen,i);
+			}
+		}
+	}
+
+	if (preserve_hard_links)
+		do_hard_links(flist);
+
+	/* now we need to fix any directory permissions that were 
+	   modified during the transfer */
+	for (i = 0; i < flist->count; i++) {
+		file = flist->files[i];
+		if (!file->basename || !S_ISDIR(file->mode)) continue;
+		recv_generator(f_name(file),flist,i,-1);
+	}
+
+	if (verbose > 2)
+		rprintf(FINFO,"recv_files finished\n");
+	
+	return 0;
 }
 
 
 
 void send_files(struct file_list *flist,int f_out,int f_in)
 { 
@@ -981,14 +1007,23 @@
 				  rprintf(FINFO,"send_files phase=%d\n",phase);
 			  continue;
 		  }
 		  break;
 	  }
 
+	  if (i < 0 || i >= flist->count) {
+		  rprintf(FERROR,"Invalid file index %d (count=%d)\n", 
+			  i, flist->count);
+		  exit_cleanup(1);
+	  }
+
 	  file = flist->files[i];
 
+	  stats.num_transferred_files++;
+	  stats.total_transferred_size += file->length;
+
 	  fname[0] = 0;
 	  if (file->basedir) {
 		  strlcpy(fname,file->basedir,MAXPATHLEN-1);
 		  if (strlen(fname) == MAXPATHLEN-1) {
 			  io_error = 1;
 			  rprintf(FERROR, "send_files failed on long-named directory %s\n",
@@ -1130,13 +1165,9 @@
     phase++;
     if (verbose > 2)
       rprintf(FINFO,"generate_files phase=%d\n",phase);
 
     write_int(f,-1);
   }
-
-
-  if (verbose > 2)
-    rprintf(FINFO,"generator wrote %ld\n",(long)write_total());
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/rsync.h	1998-05-27 21:54:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/rsync.h	1998-06-01 21:47:38.000000000 +0800
@@ -277,15 +277,15 @@
 	char *basedir;
 	char *link;
 	char *sum;
 };
 
 struct file_list {
-  int count;
-  int malloced;
-  struct file_struct **files;
+	int count;
+	int malloced;
+	struct file_struct **files;
 };
 
 struct sum_buf {
   OFF_T offset;			/* offset in file of this chunk */
   int len;			/* length of chunk of file */
   int i;			/* index of this chunk */
@@ -313,12 +313,24 @@
 	int regular_exp;
 	int include;
 	int directory;
 	int local;
 };
 
+struct stats {
+	int64 total_size;
+	int64 total_transferred_size;
+	int64 total_written;
+	int64 total_read;
+	int64 literal_data;
+	int64 matched_data;
+	int flist_size;
+	int num_files;
+	int num_transferred_files;
+};
+
 
 /* we need this function because of the silly way in which duplicate
    entries are handled in the file lists - we can't change this
    without breaking existing versions */
 static inline int flist_up(struct file_list *flist, int i)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/rsync.yo	1998-05-30 10:08:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/rsync.yo	1998-06-01 21:47:38.000000000 +0800
@@ -441,12 +441,16 @@
 the default /etc/rsyncd.conf. This is only relevant when --daemon is
 specified. 
 
 dit(bf(--port PORT)) This specifies an alternate TCP port number to use
 rather than the default port 873. 
 
+dit(bf(--stats)) This tells rsync to print a verbose set of statistics
+on the file transfer, allowing you to tell how effective the rsync
+algorithm is for your data.
+
 enddit()
 
 manpagesection(EXCLUDE PATTERNS)
 
 The exclude and include patterns specified to rsync allow for flexible
 selection of what files to transfer and what files to skip.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/test.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/test.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/test.sh	1998-05-27 21:54:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/test.sh	1998-06-01 21:47:38.000000000 +0800
@@ -7,12 +7,20 @@
 #
 # This is a simple test script that tests a few rsync
 # features to make sure I haven't broken them before a release.
 #
 #
 
+cat <<EOF
+
+This set of tests is not completely portable. It is intended for developers
+not for end users. You may experience failures on some platforms that
+do not indicate a problem with rsync.
+
+EOF
+
 export PATH=.:$PATH
 TMP=/tmp/rsync-test.$$
 FROM=${TMP}/from
 TO=${TMP}/to
 F1=text1
 LOG=${TMP}/log
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/util.c	1998-05-30 10:08:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/util.c	1998-06-01 21:47:38.000000000 +0800
@@ -650,6 +650,20 @@
 	strlcpy(curr_dir, dir, sizeof(curr_dir)-1);
 
 	free(dir);
 
 	return 0;
 }
+
+/* we need to supply our own strcmp function for file list comparisons
+   to ensure that signed/unsigned usage is consistent between machines. */
+int u_strcmp(const char *cs1, const char *cs2)
+{
+	const uchar *s1 = (uchar *)cs1;
+	const uchar *s2 = (uchar *)cs2;
+
+	while (*s1 && *s2 && (*s1 == *s2)) {
+		s1++; s2++;
+	}
+	
+	return (int)*s1 - (int)*s2;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.15/version.h	1998-05-30 10:10:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.16/version.h	1998-06-01 21:49:10.000000000 +0800
@@ -1 +1 @@
-#define VERSION "2.0.15"
+#define VERSION "2.0.16"
