diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/access.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/access.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/access.c	2003-07-30 14:12:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/access.c	2004-09-25 00:50:07.000000000 +0800
@@ -85,34 +85,39 @@
 	else
 		len = strlen(tok);
 
 	/* Fail quietly if tok is a hostname (not an address) */
 	if (strspn(tok, ".0123456789") != len
 #ifdef INET6
-	 && !strchr(tok, ':')
+	    && strchr(tok, ':') == NULL
 #endif
-		) return 0;
+	) {
+		if (p)
+			*p = '/';
+		return 0;
+	}
 
 	memset(&hints, 0, sizeof(hints));
 	hints.ai_family = PF_UNSPEC;
 	hints.ai_socktype = SOCK_STREAM;
 #ifdef AI_NUMERICHOST
 	hints.ai_flags = AI_NUMERICHOST;
 #endif
 
-	gai = getaddrinfo(addr, NULL, &hints, &resa);
-	if (gai) return 0;
+	if (getaddrinfo(addr, NULL, &hints, &resa) != 0) {
+		if (p)
+			*p = '/';
+		return 0;
+	}
 
 	gai = getaddrinfo(tok, NULL, &hints, &rest);
 	if (p)
 		*p++ = '/';
-	if (gai) {
-		rprintf(FERROR,
-			"error matching address %s: %s\n",
-			tok,
-			gai_strerror(gai));
+	if (gai != 0) {
+		rprintf(FLOG, "error matching address %s: %s\n",
+			tok, gai_strerror(gai));
 		freeaddrinfo(resa);
 		return 0;
 	}
 
 	if (rest->ai_family != resa->ai_family) {
 		ret = 0;
@@ -149,13 +154,13 @@
 #endif
 
 		break;
 	    }
 #endif
 	default:
-	    rprintf(FERROR,"unknown family %u\n", rest->ai_family);
+	    rprintf(FLOG, "unknown family %u\n", rest->ai_family);
 	    ret = 0;
 	    goto out;
 	}
 
 	bits = -1;
 	if (p) {
@@ -166,32 +171,32 @@
 			unsigned char *pp;
 #endif
 
 #ifdef HAVE_STRTOL
 			bits = strtol(p, &ep, 10);
 			if (!*p || *ep) {
-				rprintf(FERROR,"malformed mask in %s\n", tok);
+				rprintf(FLOG, "malformed mask in %s\n", tok);
 				ret = 0;
 				goto out;
 			}
 #else
 			for (pp = (unsigned char *)p; *pp; pp++) {
 				if (!isascii(*pp) || !isdigit(*pp)) {
-					rprintf(FERROR,"malformed mask in %s\n", tok);
+					rprintf(FLOG, "malformed mask in %s\n", tok);
 					ret = 0;
 					goto out;
 				}
 			}
 			bits = atoi(p);
 #endif
 			if (bits == 0) {
 				ret = 1;
 				goto out;
 			}
 			if (bits < 0 || bits > (addrlen << 3)) {
-				rprintf(FERROR,"malformed mask in %s\n", tok);
+				rprintf(FLOG, "malformed mask in %s\n", tok);
 				ret = 0;
 				goto out;
 			}
 		}
 	} else {
 		bits = 128;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/authenticate.c	2004-04-02 02:05:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/authenticate.c	2004-09-25 01:04:05.000000000 +0800
@@ -1,28 +1,31 @@
 /* -*- c-file-style: "linux"; -*-
-   
-   Copyright (C) 1998-2000 by Andrew Tridgell 
-   
+
+   Copyright (C) 1998-2000 by Andrew Tridgell
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /* support rsync authentication */
 #include "rsync.h"
 
+extern char *password_file;
+extern int am_root;
+
 /***************************************************************************
 encode a buffer using base64 - simple and slow algorithm. null terminates
 the result.
   ***************************************************************************/
 void base64_encode(char *buf, int len, char *out)
 {
@@ -51,161 +54,168 @@
 /* create a 16 byte challenge buffer */
 static void gen_challenge(char *addr, char *challenge)
 {
 	char input[32];
 	struct timeval tv;
 
-	memset(input, 0, sizeof(input));
+	memset(input, 0, sizeof input);
 
 	strlcpy((char *)input, addr, 17);
 	sys_gettimeofday(&tv);
 	SIVAL(input, 16, tv.tv_sec);
 	SIVAL(input, 20, tv.tv_usec);
 	SIVAL(input, 24, getpid());
 
-	sum_init();
-	sum_update(input, sizeof(input));
+	sum_init(0);
+	sum_update(input, sizeof input);
 	sum_end(challenge);
 }
 
 
-/* return the secret for a user from the sercret file. maximum length
-   is len. null terminate it */
+/* Return the secret for a user from the secret file, null terminated.
+ * Maximum length is len (not counting the null). */
 static int get_secret(int module, char *user, char *secret, int len)
 {
 	char *fname = lp_secrets_file(module);
-	int fd, found=0;
-	char line[MAXPATHLEN];
-	char *p, *pass=NULL;
 	STRUCT_STAT st;
-	int ok = 1;
-	extern int am_root;
+	int fd, ok = 1;
+	char ch, *p;
 
-	if (!fname || !*fname) return 0;
+	if (!fname || !*fname)
+		return 0;
 
-	fd = open(fname,O_RDONLY);
-	if (fd == -1) return 0;
+	if ((fd = open(fname, O_RDONLY)) < 0)
+		return 0;
 
 	if (do_stat(fname, &st) == -1) {
-		rsyserr(FERROR, errno, "stat(%s)", fname);
+		rsyserr(FLOG, errno, "stat(%s)", fname);
 		ok = 0;
 	} else if (lp_strict_modes(module)) {
 		if ((st.st_mode & 06) != 0) {
-			rprintf(FERROR,"secrets file must not be other-accessible (see strict modes option)\n");
+			rprintf(FLOG, "secrets file must not be other-accessible (see strict modes option)\n");
 			ok = 0;
 		} else if (am_root && (st.st_uid != 0)) {
-			rprintf(FERROR,"secrets file must be owned by root when running as root (see strict modes)\n");
+			rprintf(FLOG, "secrets file must be owned by root when running as root (see strict modes)\n");
 			ok = 0;
 		}
 	}
 	if (!ok) {
-		rprintf(FERROR,"continuing without secrets file\n");
+		rprintf(FLOG, "continuing without secrets file\n");
 		close(fd);
 		return 0;
 	}
 
-	while (!found) {
-		int i = 0;
-		memset(line, 0, sizeof line);
-		while ((size_t) i < (sizeof(line)-1)) {
-			if (read(fd, &line[i], 1) != 1) {
-				memset(line, 0, sizeof(line));
-				close(fd);
-				return 0;
-			}
-			if (line[i] == '\r') continue;
-			if (line[i] == '\n') break;
-			i++;
+	if (*user == '#') {
+		/* Reject attempt to match a comment. */
+		close(fd);
+		return 0;
+	}
+
+	/* Try to find a line that starts with the user name and a ':'. */
+	p = user;
+	while (1) {
+		if (read(fd, &ch, 1) != 1) {
+			close(fd);
+			return 0;
+		}
+		if (ch == '\n')
+			p = user;
+		else if (p) {
+			if (*p == ch)
+				p++;
+			else if (!*p && ch == ':')
+				break;
+			else
+				p = NULL;
 		}
-		line[i] = 0;
-		if (line[0] == '#') continue;
-		p = strchr(line,':');
-		if (!p) continue;
-		*p = 0;
-		if (strcmp(user, line)) continue;
-		pass = p+1;
-		found = 1;
 	}
 
+	/* Slurp the secret into the "secret" buffer. */
+	p = secret;
+	while (len > 0) {
+		if (read(fd, p, 1) != 1 || *p == '\n')
+			break;
+		if (*p == '\r')
+			continue;
+		p++;
+		len--;
+	}
+	*p = '\0';
 	close(fd);
-	if (!found) return 0;
 
-	strlcpy(secret, pass, len);
 	return 1;
 }
 
 static char *getpassf(char *filename)
 {
-	char buffer[100];
-	int fd=0;
 	STRUCT_STAT st;
-	int ok = 1;
-	extern int am_root;
-	char *envpw=getenv("RSYNC_PASSWORD");
+	char buffer[512], *p;
+	int fd, n, ok = 1;
+	char *envpw = getenv("RSYNC_PASSWORD");
 
-	if (!filename) return NULL;
+	if (!filename)
+		return NULL;
 
-	if ( (fd=open(filename,O_RDONLY)) == -1) {
+	if ((fd = open(filename,O_RDONLY)) < 0) {
 		rsyserr(FERROR, errno, "could not open password file \"%s\"",filename);
-		if (envpw) rprintf(FERROR,"falling back to RSYNC_PASSWORD environment variable.\n");	
+		if (envpw)
+			rprintf(FERROR, "falling back to RSYNC_PASSWORD environment variable.\n");
 		return NULL;
 	}
-	
+
 	if (do_stat(filename, &st) == -1) {
 		rsyserr(FERROR, errno, "stat(%s)", filename);
 		ok = 0;
 	} else if ((st.st_mode & 06) != 0) {
 		rprintf(FERROR,"password file must not be other-accessible\n");
 		ok = 0;
-	} else if (am_root && (st.st_uid != 0)) {
+	} else if (am_root && st.st_uid != 0) {
 		rprintf(FERROR,"password file must be owned by root when running as root\n");
 		ok = 0;
 	}
 	if (!ok) {
 		rprintf(FERROR,"continuing without password file\n");
-		if (envpw) rprintf(FERROR,"using RSYNC_PASSWORD environment variable.\n");
+		if (envpw)
+			rprintf(FERROR, "using RSYNC_PASSWORD environment variable.\n");
 		close(fd);
 		return NULL;
 	}
 
-	if (envpw) rprintf(FERROR,"RSYNC_PASSWORD environment variable ignored\n");
+	if (envpw)
+		rprintf(FERROR, "RSYNC_PASSWORD environment variable ignored\n");
 
-	buffer[sizeof(buffer)-1]='\0';
-	if (read(fd,buffer,sizeof(buffer)-1) > 0)
-	{
-		char *p = strtok(buffer,"\n\r");
-		close(fd);
-		if (p) p = strdup(p);
-		return p;
-	}	
+	n = read(fd, buffer, sizeof buffer - 1);
+	close(fd);
+	if (n > 0) {
+		buffer[n] = '\0';
+		if ((p = strtok(buffer, "\n\r")) != NULL)
+			return strdup(p);
+	}
 
 	return NULL;
 }
 
 /* generate a 16 byte hash from a password and challenge */
 static void generate_hash(char *in, char *challenge, char *out)
 {
 	char buf[16];
 
-	sum_init();
+	sum_init(0);
 	sum_update(in, strlen(in));
 	sum_update(challenge, strlen(challenge));
 	sum_end(buf);
 
 	base64_encode(buf, 16, out);
 }
 
-/* possible negotiate authentication with the client. Use "leader" to
-   start off the auth if necessary 
-
-   return NULL if authentication failed
-
-   return "" if anonymous access
-
-   otherwise return username
-*/
+/* Possibly negotiate authentication with the client.  Use "leader" to
+ * start off the auth if necessary.
+ *
+ * Return NULL if authentication failed.  Return "" if anonymous access.
+ * Otherwise return username.
+ */
 char *auth_server(int f_in, int f_out, int module, char *addr, char *leader)
 {
 	char *users = lp_auth_users(module);
 	char challenge[16];
 	char b64_challenge[30];
 	char line[MAXPATHLEN];
@@ -213,84 +223,83 @@
 	char secret[100];
 	char pass[30];
 	char pass2[30];
 	char *tok;
 
 	/* if no auth list then allow anyone in! */
-	if (!users || !*users) return "";
+	if (!users || !*users)
+		return "";
 
 	gen_challenge(addr, challenge);
-	
+
 	base64_encode(challenge, 16, b64_challenge);
 
 	io_printf(f_out, "%s%s\n", leader, b64_challenge);
 
-	if (!read_line(f_in, line, sizeof(line)-1)) {
+	if (!read_line(f_in, line, sizeof line - 1))
 		return NULL;
-	}
 
-	memset(user, 0, sizeof(user));
-	memset(pass, 0, sizeof(pass));
+	memset(user, 0, sizeof user);
+	memset(pass, 0, sizeof pass);
 
-	if (sscanf(line,"%99s %29s", user, pass) != 2) {
+	if (sscanf(line,"%99s %29s", user, pass) != 2)
 		return NULL;
-	}
-	
+
 	users = strdup(users);
-	if (!users) return NULL;
+	if (!users)
+		return NULL;
 
 	for (tok=strtok(users," ,\t"); tok; tok = strtok(NULL," ,\t")) {
-		if (wildmatch(tok, user)) break;
+		if (wildmatch(tok, user))
+			break;
 	}
 	free(users);
 
-	if (!tok) {
+	if (!tok)
 		return NULL;
-	}
-	
-	memset(secret, 0, sizeof(secret));
-	if (!get_secret(module, user, secret, sizeof(secret)-1)) {
-		memset(secret, 0, sizeof(secret));
+
+	memset(secret, 0, sizeof secret);
+	if (!get_secret(module, user, secret, sizeof secret - 1)) {
+		memset(secret, 0, sizeof secret);
 		return NULL;
 	}
 
 	generate_hash(secret, b64_challenge, pass2);
-	memset(secret, 0, sizeof(secret));
-	
+	memset(secret, 0, sizeof secret);
+
 	if (strcmp(pass, pass2) == 0)
 		return user;
 
 	return NULL;
 }
 
 
 void auth_client(int fd, char *user, char *challenge)
 {
 	char *pass;
 	char pass2[30];
-	extern char *password_file;
 
 	if (!user || !*user)
 		user = "nobody";
 
-	if (!(pass=getpassf(password_file)) && !(pass=getenv("RSYNC_PASSWORD"))) {
+	if (!(pass = getpassf(password_file))
+	 && !(pass = getenv("RSYNC_PASSWORD"))) {
 		/* XXX: cyeoh says that getpass is deprecated, because
 		 * it may return a truncated password on some systems,
 		 * and it is not in the LSB.
                  *
                  * Andrew Klein says that getpassphrase() is present
                  * on Solaris and reads up to 256 characters.
                  *
                  * OpenBSD has a readpassphrase() that might be more suitable.
                  */
 		pass = getpass("Password: ");
 	}
 
-	if (!pass || !*pass) {
+	if (!pass)
 		pass = "";
-	}
 
 	generate_hash(pass, challenge, pass2);
 	io_printf(fd, "%s %s\n", user, pass2);
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/backup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/backup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/backup.c	2004-03-14 04:18:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/backup.c	2004-09-21 03:46:45.000000000 +0800
@@ -30,28 +30,44 @@
 
 extern int am_root;
 extern int preserve_devices;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int orig_umask;
+extern int safe_symlinks;
+
+/* make a complete pathname for backup file */
+char *get_backup_name(char *fname)
+{
+	if (backup_dir) {
+		if (stringjoin(backup_dir_buf + backup_dir_len, backup_dir_remainder,
+			       fname, backup_suffix, NULL) < backup_dir_remainder)
+			return backup_dir_buf;
+	} else {
+		if (stringjoin(backup_dir_buf, MAXPATHLEN,
+			       fname, backup_suffix, NULL) < MAXPATHLEN)
+			return backup_dir_buf;
+	}
+
+	rprintf(FERROR, "backup filename too long\n");
+	return NULL;
+}
 
 /* simple backup creates a backup with a suffix in the same directory */
 static int make_simple_backup(char *fname)
 {
-	char fnamebak[MAXPATHLEN];
+	char *fnamebak = get_backup_name(fname);
 
-	if (stringjoin(fnamebak, sizeof fnamebak, fname, backup_suffix, NULL)
-	    >= sizeof fnamebak) {
-		rprintf(FERROR, "backup filename too long\n");
+	if (!fnamebak)
 		return 0;
-	}
 
 	if (do_rename(fname, fnamebak) != 0) {
 		/* cygwin (at least version b19) reports EINVAL */
 		if (errno != ENOENT && errno != EINVAL) {
-			rsyserr(FERROR, errno, "rename %s to backup %s", fname, fnamebak);
+			rsyserr(FERROR, errno,
+				"rename %s to backup %s", fname, fnamebak);
 			return 0;
 		}
 	} else if (verbose > 1) {
 		rprintf(FINFO, "backed up %s to %s\n", fname, fnamebak);
 	}
 	return 1;
@@ -80,43 +96,41 @@
 		}
 		if (*p == '/') {
 			*p = '\0';
 			if (do_mkdir(fullpath, 0777 & ~orig_umask) == 0)
 				break;
 			if (errno != ENOENT) {
-				rprintf(FERROR,
-				    "make_bak_dir mkdir %s failed: %s\n",
-				    full_fname(fullpath), strerror(errno));
+				rsyserr(FERROR, errno,
+					"make_bak_dir mkdir %s failed",
+					full_fname(fullpath));
 				goto failure;
 			}
 		}
 	}
 
 	/* Make all the dirs that we didn't find on the way here. */
 	while (1) {
 		if (p >= rel) {
 			/* Try to transfer the directory settings of the
 			 * actual dir that the files are coming from. */
-			if (do_lstat(rel, &st) != 0) {
-				rprintf(FERROR,
-				    "make_bak_dir stat %s failed: %s\n",
-				    full_fname(rel), strerror(errno));
+			if (do_stat(rel, &st) < 0) {
+				rsyserr(FERROR, errno,
+					"make_bak_dir stat %s failed",
+					full_fname(rel));
 			} else {
-				set_modtime(fullpath, st.st_mtime);
 				do_lchown(fullpath, st.st_uid, st.st_gid);
 				do_chmod(fullpath, st.st_mode);
 			}
 		}
 		*p = '/';
 		p += strlen(p);
 		if (p == end)
 			break;
 		if (do_mkdir(fullpath, 0777 & ~orig_umask) < 0) {
-			rprintf(FERROR,
-			    "make_bak_dir mkdir %s failed: %s\n",
-			    full_fname(fullpath), strerror(errno));
+			rsyserr(FERROR, errno, "make_bak_dir mkdir %s failed",
+				full_fname(fullpath));
 			goto failure;
 		}
 	}
 	return 0;
 
 failure:
@@ -140,42 +154,40 @@
 /* If we have a --backup-dir, then we get here from make_backup().
  * We will move the file to be deleted into a parallel directory tree. */
 static int keep_backup(char *fname)
 {
 	STRUCT_STAT st;
 	struct file_struct *file;
+	char *buf;
 	int kept = 0;
 	int ret_code;
 
 	/* return if no file to keep */
 #if SUPPORT_LINKS
-	if (do_lstat(fname, &st)) return 1;
+	ret_code = do_lstat(fname, &st);
 #else
-	if (do_stat(fname, &st)) return 1;
+	ret_code = do_stat(fname, &st);
 #endif
+	if (ret_code < 0)
+		return 1;
 
-	file = make_file(fname, NULL, NO_EXCLUDES);
+	if (!(file = make_file(fname, NULL, NO_EXCLUDES)))
+		return 1; /* the file could have disappeared */
 
-	/* the file could have disappeared */
-	if (!file) return 1;
-
-	/* make a complete pathname for backup file */
-	if (stringjoin(backup_dir_buf + backup_dir_len, backup_dir_remainder,
-	    fname, backup_suffix, NULL) >= backup_dir_remainder) {
-		rprintf(FERROR, "keep_backup filename too long\n");
+	if (!(buf = get_backup_name(fname)))
 		return 0;
-	}
 
 #ifdef HAVE_MKNOD
 	/* Check to see if this is a device file, or link */
 	if (IS_DEVICE(file->mode)) {
 		if (am_root && preserve_devices) {
-			make_bak_dir(backup_dir_buf);
-			if (do_mknod(backup_dir_buf, file->mode, file->u.rdev) != 0) {
-				rprintf(FERROR, "mknod %s failed: %s\n",
-					full_fname(backup_dir_buf), strerror(errno));
+			if (do_mknod(buf, file->mode, file->u.rdev) < 0
+			    && (errno != ENOENT || make_bak_dir(buf) < 0
+			     || do_mknod(buf, file->mode, file->u.rdev) < 0)) {
+				rsyserr(FERROR, errno, "mknod %s failed",
+					full_fname(buf));
 			} else if (verbose > 2) {
 				rprintf(FINFO,
 					"make_backup: DEVICE %s successful.\n",
 					fname);
 			}
 		}
@@ -183,60 +195,69 @@
 		do_unlink(fname);
 	}
 #endif
 
 	if (!kept && S_ISDIR(file->mode)) {
 		/* make an empty directory */
-		make_bak_dir(backup_dir_buf);
-		do_mkdir(backup_dir_buf, file->mode);
-		ret_code = do_rmdir(fname);
+		if (do_mkdir(buf, file->mode) < 0
+		    && (errno != ENOENT || make_bak_dir(buf) < 0
+		     || do_mkdir(buf, file->mode) < 0)) {
+			rsyserr(FINFO, errno, "mkdir %s failed",
+				full_fname(buf));
+		}
 
+		ret_code = do_rmdir(fname);
 		if (verbose > 2) {
 			rprintf(FINFO, "make_backup: RMDIR %s returns %i\n",
 				full_fname(fname), ret_code);
 		}
 		kept = 1;
 	}
 
 #if SUPPORT_LINKS
 	if (!kept && preserve_links && S_ISLNK(file->mode)) {
-		extern int safe_symlinks;
-		if (safe_symlinks && unsafe_symlink(file->u.link, backup_dir_buf)) {
+		if (safe_symlinks && unsafe_symlink(file->u.link, buf)) {
 			if (verbose) {
 				rprintf(FINFO, "ignoring unsafe symlink %s -> %s\n",
-					full_fname(backup_dir_buf), file->u.link);
+					full_fname(buf), file->u.link);
 			}
 			kept = 1;
 		}
-		make_bak_dir(backup_dir_buf);
-		if (do_symlink(file->u.link, backup_dir_buf) != 0) {
-			rprintf(FERROR, "link %s -> %s : %s\n",
-				full_fname(backup_dir_buf), file->u.link, strerror(errno));
+		if (do_symlink(file->u.link, buf) < 0
+		    && (errno != ENOENT || make_bak_dir(buf) < 0
+		     || do_symlink(file->u.link, buf) < 0)) {
+			rsyserr(FERROR, errno, "link %s -> \"%s\"",
+				full_fname(buf), file->u.link);
 		}
 		do_unlink(fname);
 		kept = 1;
 	}
 #endif
 
 	if (!kept && !S_ISREG(file->mode)) {
 		rprintf(FINFO, "make_bak: skipping non-regular file %s\n",
 			fname);
+		return 1;
 	}
 
 	/* move to keep tree if a file */
 	if (!kept) {
-		if (robust_move(fname, backup_dir_buf) != 0) {
-			rprintf(FERROR, "keep_backup failed: %s -> \"%s\": %s\n",
-				full_fname(fname), backup_dir_buf, strerror(errno));
+		if (robust_move(fname, buf) != 0) {
+			rsyserr(FERROR, errno, "keep_backup failed: %s -> \"%s\"",
+				full_fname(fname), buf);
+		} else if (st.st_nlink > 1) {
+			/* If someone has hard-linked the file into the backup
+			 * dir, rename() might return success but do nothing! */
+			robust_unlink(fname); /* Just in case... */
 		}
 	}
-	set_perms(backup_dir_buf, file, NULL, 0);
+	set_perms(buf, file, NULL, 0);
 	free(file);
 
 	if (verbose > 1)
-		rprintf(FINFO, "keep_backup %s -> %s\n", fname, backup_dir_buf);
+		rprintf(FINFO, "backed up %s to %s\n", fname, buf);
 	return 1;
 }
 
 
 /* main backup switch routine */
 int make_backup(char *fname)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/batch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/batch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/batch.c	2004-03-06 15:45:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/batch.c	2004-08-02 12:50:33.000000000 +0800
@@ -5,335 +5,177 @@
 
 */
 
 #include "rsync.h"
 #include <time.h>
 
-extern char *batch_prefix;
-extern int csum_length;
-extern int protocol_version;
-extern struct stats stats;
-
-struct file_list *batch_flist;
-
-static char rsync_flist_file[] = ".rsync_flist";
-static char rsync_csums_file[] = ".rsync_csums";
-static char rsync_delta_file[] = ".rsync_delta";
-static char rsync_argvs_file[] = ".rsync_argvs";
+extern char *batch_name;
+extern int eol_nulls;
+extern int recurse;
+extern int preserve_links;
+extern int preserve_hard_links;
+extern int preserve_devices;
+extern int preserve_uid;
+extern int preserve_gid;
+extern int always_checksum;
 
-static int f_csums = -1;
-static int f_delta = -1;
+extern struct exclude_list_struct exclude_list;
 
-void write_batch_flist_info(int flist_count, struct file_struct **files)
-{
-	char filename[MAXPATHLEN];
-	int i, f, save_pv;
-	int64 save_written;
-
-	stringjoin(filename, sizeof filename,
-	    batch_prefix, rsync_flist_file, NULL);
+static int *flag_ptr[] = {
+	&recurse,
+	&preserve_uid,
+	&preserve_gid,
+	&preserve_links,
+	&preserve_devices,
+	&preserve_hard_links,
+	&always_checksum,
+	NULL
+};
 
-	f = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
-	if (f < 0) {
-		rprintf(FERROR, "Batch file %s open error: %s\n",
-		    filename, strerror(errno));
-		exit_cleanup(1);
-	}
+static char *flag_name[] = {
+	"--recurse (-r)",
+	"--owner (-o)",
+	"--group (-g)",
+	"--links (-l)",
+	"--devices (-D)",
+	"--hard-links (-H)",
+	"--checksum (-c)",
+	NULL
+};
 
-	save_written = stats.total_written;
-	save_pv = protocol_version;
-	protocol_version = PROTOCOL_VERSION;
-	write_int(f, protocol_version);
-	write_int(f, flist_count);
-
-	for (i = 0; i < flist_count; i++) {
-		send_file_entry(files[i], f,
-		    files[i]->flags & FLAG_TOP_DIR ?  XMIT_TOP_DIR : 0);
-	}
-	send_file_entry(NULL, f, 0);
-
-	protocol_version = save_pv;
-	stats.total_written = save_written;
-
-	close(f);
-}
-
-
-void write_batch_argvs_file(int argc, char *argv[])
+void write_stream_flags(int fd)
 {
-	int f;
-	int i;
-	char buff[256]; /* XXX */
-	char buff2[MAXPATHLEN + 6];
-	char filename[MAXPATHLEN];
-
-	stringjoin(filename, sizeof filename,
-	    batch_prefix, rsync_argvs_file, NULL);
+	int i, flags;
 
-	f = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-	    S_IRUSR | S_IWUSR | S_IEXEC);
-	if (f < 0) {
-		rprintf(FERROR, "Batch file %s open error: %s\n",
-		    filename, strerror(errno));
-		exit_cleanup(1);
+	/* Start the batch file with a bitmap of data-stream-affecting
+	 * flags. */
+	for (i = 0, flags = 0; flag_ptr[i]; i++) {
+		if (*flag_ptr[i])
+			flags |= 1 << i;
 	}
-	buff[0] = '\0';
-
-	/* Write argvs info to batch file */
-
-	for (i = 0; i < argc; ++i) {
-		if (i == argc - 2) /* Skip source directory on cmdline */
-			continue;
-		/*
-		 * FIXME:
-		 * I think directly manipulating argv[] is probably bogus
-		 */
-		if (!strncmp(argv[i], "--write-batch",
-		    strlen("--write-batch"))) {
-			/* Safer to change it here than script */
-			/*
-			 * Change to --read-batch=prefix
-			 * to get ready for remote
-			 */
-			strlcat(buff, "--read-batch=", sizeof buff);
-			strlcat(buff, batch_prefix, sizeof buff);
-		} else
-		if (i == argc - 1) {
-			snprintf(buff2, sizeof buff2, "${1:-%s}", argv[i]);
-			strlcat(buff, buff2, sizeof buff);
-		}
-		else {
-			strlcat(buff, argv[i], sizeof buff);
-		}
-
-		if (i < (argc - 1)) {
-			strlcat(buff, " ", sizeof buff);
-		}
-	}
-	strlcat(buff, "\n", sizeof buff);
-	if (!write(f, buff, strlen(buff))) {
-		rprintf(FERROR, "Batch file %s write error: %s\n",
-		    filename, strerror(errno));
-		close(f);
-		exit_cleanup(1);
-	}
-	close(f);
+	write_int(fd, flags);
 }
 
-struct file_list *create_flist_from_batch(void)
+void read_stream_flags(int fd)
 {
-	char filename[MAXPATHLEN];
-	unsigned short flags;
-	int i, f, save_pv;
-	int64 save_read;
-
-	stringjoin(filename, sizeof filename,
-	    batch_prefix, rsync_flist_file, NULL);
-
-	f = do_open(filename, O_RDONLY, 0);
-	if (f < 0) {
-		rprintf(FERROR, "Batch file %s open error: %s\n",
-		    filename, strerror(errno));
-		exit_cleanup(1);
-	}
-
-	batch_flist = flist_new(WITH_HLINK, "create_flist_from_batch");
-
-	save_read = stats.total_read;
-	save_pv = protocol_version;
-	protocol_version = read_int(f);
-
-	batch_flist->count = read_int(f);
-	flist_expand(batch_flist);
-
-	for (i = 0; (flags = read_byte(f)) != 0; i++) {
-		if (protocol_version >= 28 && (flags & XMIT_EXTENDED_FLAGS))
-			flags |= read_byte(f) << 8;
-		receive_file_entry(&batch_flist->files[i], flags, batch_flist, f);
-	}
-	receive_file_entry(NULL, 0, NULL, 0); /* Signal that we're done. */
+	int i, flags;
 
-	protocol_version = save_pv;
-	stats.total_read = save_read;
-
-	return batch_flist;
-}
-
-void write_batch_csums_file(void *buff, int bytes_to_write)
-{
-	if (write(f_csums, buff, bytes_to_write) < 0) {
-		rprintf(FERROR, "Batch file write error: %s\n",
-		    strerror(errno));
-		close(f_csums);
-		exit_cleanup(1);
+	for (i = 0, flags = read_int(fd); flag_ptr[i]; i++) {
+		int set = flags & (1 << i) ? 1 : 0;
+		if (*flag_ptr[i] != set) {
+			if (verbose) {
+				rprintf(FINFO,
+					"%sing the %s option to match the batchfile.\n",
+					set ? "Sett" : "Clear", flag_name[i]);
+			}
+			*flag_ptr[i] = set;
+		}
 	}
 }
 
-void close_batch_csums_file(void)
+static void write_arg(int fd, char *arg)
 {
-	close(f_csums);
-	f_csums = -1;
-}
+	char *x, *s;
 
-
-/**
- * Write csum info to batch file
- *
- * @todo This will break if s->count is ever larger than maxint.  The
- * batch code should probably be changed to consistently use the
- * variable-length integer routines, which is probably a compatible
- * change.
- **/
-void write_batch_csum_info(int *flist_entry, struct sum_struct *s)
-{
-	size_t i;
-	int int_count;
-	char filename[MAXPATHLEN];
-
-	if (f_csums < 0) {
-		stringjoin(filename, sizeof filename,
-		    batch_prefix, rsync_csums_file, NULL);
-
-		f_csums = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-		    S_IRUSR | S_IWUSR);
-		if (f_csums < 0) {
-			rprintf(FERROR, "Batch file %s open error: %s\n",
-			    filename, strerror(errno));
-			close(f_csums);
-			exit_cleanup(1);
-		}
+	if (*arg == '-' && (x = strchr(arg, '=')) != NULL) {
+		write(fd, arg, x - arg + 1);
+		arg += x - arg + 1;
 	}
 
-	write_batch_csums_file(flist_entry, sizeof (int));
-	int_count = s ? (int) s->count : 0;
-	write_batch_csums_file(&int_count, sizeof int_count);
-
-	if (s) {
-		for (i = 0; i < s->count; i++) {
-			write_batch_csums_file(&s->sums[i].sum1,
-			    sizeof (uint32));
-			write_batch_csums_file(s->sums[i].sum2, csum_length);
+	if (strpbrk(arg, " \"'&;|[]()$#!*?^\\") != NULL) {
+		write(fd, "'", 1);
+		for (s = arg; (x = strchr(s, '\'')) != NULL; s = x + 1) {
+			write(fd, s, x - s + 1);
+			write(fd, "'", 1);
 		}
+		write(fd, s, strlen(s));
+		write(fd, "'", 1);
+		return;
 	}
-}
-
-int read_batch_csums_file(char *buff, int len)
-{
-	int bytes_read;
 
-	if ((bytes_read = read(f_csums, buff, len)) < 0) {
-		rprintf(FERROR, "Batch file read error: %s\n", strerror(errno));
-		close(f_csums);
-		exit_cleanup(1);
-	}
-	return bytes_read;
+	write(fd, arg, strlen(arg));
 }
 
-void read_batch_csum_info(int flist_entry, struct sum_struct *s,
-			  int *checksums_match)
+static void write_excludes(int fd)
 {
-	int i;
-	int file_flist_entry;
-	int file_chunk_ct;
-	uint32 file_sum1;
-	char file_sum2[SUM_LENGTH];
-	char filename[MAXPATHLEN];
-
-	if (f_csums < 0) {
-		stringjoin(filename, sizeof filename,
-		    batch_prefix, rsync_csums_file, NULL);
-
-		f_csums = do_open(filename, O_RDONLY, 0);
-		if (f_csums < 0) {
-			rprintf(FERROR, "Batch file %s open error: %s\n",
-			    filename, strerror(errno));
-			close(f_csums);
-			exit_cleanup(1);
-		}
-	}
+	struct exclude_struct *ent;
 
-	read_batch_csums_file((char *) &file_flist_entry, sizeof (int));
-	if (file_flist_entry != flist_entry) {
-		rprintf(FINFO, "file_flist_entry (%d) != flist_entry (%d)\n",
-		    file_flist_entry, flist_entry);
-		close(f_csums);
-		exit_cleanup(1);
-
-	} else {
-		read_batch_csums_file((char *) &file_chunk_ct, sizeof (int));
-		*checksums_match = 1;
-		for (i = 0; i < file_chunk_ct; i++) {
-			read_batch_csums_file((char *) &file_sum1,
-			    sizeof (uint32));
-			read_batch_csums_file(file_sum2, csum_length);
-
-			if ((s->sums[i].sum1 != file_sum1)
-			    || memcmp(s->sums[i].sum2, file_sum2, csum_length))
-				*checksums_match = 0;
-		}		/*  end for  */
+	write_sbuf(fd, " <<'#E#'\n");
+	for (ent = exclude_list.head; ent; ent = ent->next) {
+		char *p = ent->pattern;
+		if (ent->match_flags & MATCHFLG_INCLUDE)
+			write_buf(fd, "+ ", 2);
+		else if (((*p == '-' || *p == '+') && p[1] == ' ')
+		    || *p == '#' || *p == ';')
+			write_buf(fd, "- ", 2);
+		write_sbuf(fd, p);
+		if (ent->match_flags & MATCHFLG_DIRECTORY)
+			write_byte(fd, '/');
+		write_byte(fd, eol_nulls ? 0 : '\n');
 	}
+	if (eol_nulls)
+		write_sbuf(fd, ";\n");
+	write_sbuf(fd, "#E#");
 }
 
-void write_batch_delta_file(char *buff, int bytes_to_write)
+/* This routine tries to write out an equivalent --read-batch command
+ * given the user's --write-batch args.  However, it doesn't really
+ * understand most of the options, so it uses some overly simple
+ * heuristics to munge the command line into something that will
+ * (hopefully) work. */
+void write_batch_shell_file(int argc, char *argv[], int file_arg_cnt)
 {
-	char filename[MAXPATHLEN];
-
-	if (f_delta < 0) {
-		stringjoin(filename, sizeof filename,
-		    batch_prefix, rsync_delta_file, NULL);
-
-		f_delta = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-				  S_IRUSR | S_IWUSR);
-		if (f_delta < 0) {
-			rprintf(FERROR, "Batch file %s open error: %s\n",
-				filename, strerror(errno));
-			exit_cleanup(1);
-		}
-	}
+	int fd, i;
+	char *p, filename[MAXPATHLEN];
 
-	if (write(f_delta, buff, bytes_to_write) < 0) {
-		rprintf(FERROR, "Batch file %s write error: %s\n",
-		    filename, strerror(errno));
-		close(f_delta);
+	stringjoin(filename, sizeof filename,
+		   batch_name, ".sh", NULL);
+	fd = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
+		     S_IRUSR | S_IWUSR | S_IEXEC);
+	if (fd < 0) {
+		rsyserr(FERROR, errno, "Batch file %s open error", filename);
 		exit_cleanup(1);
 	}
-}
-
-void close_batch_delta_file(void)
-{
-	close(f_delta);
-	f_delta = -1;
-}
-
-int read_batch_delta_file(char *buff, int len)
-{
-	int bytes_read;
-	char filename[MAXPATHLEN];
 
-	if (f_delta < 0) {
-		stringjoin(filename, sizeof filename,
-		    batch_prefix, rsync_delta_file, NULL);
-
-		f_delta = do_open(filename, O_RDONLY, 0);
-		if (f_delta < 0) {
-			rprintf(FERROR, "Batch file %s open error: %s\n",
-			    filename, strerror(errno));
-			close(f_delta);
-			exit_cleanup(1);
+	/* Write argvs info to BATCH.sh file */
+	write_arg(fd, argv[0]);
+	if (exclude_list.head)
+		write_sbuf(fd, " --exclude-from=-");
+	for (i = 1; i < argc - file_arg_cnt; i++) {
+		p = argv[i];
+		if (strncmp(p, "--files-from", 12) == 0
+		    || strncmp(p, "--include", 9) == 0
+		    || strncmp(p, "--exclude", 9) == 0) {
+			if (strchr(p, '=') == NULL)
+				i++;
+			continue;
 		}
+		write(fd, " ", 1);
+		if (strncmp(p, "--write-batch", 13) == 0) {
+			write(fd, "--read-batch", 12);
+			if (p[13] == '=') {
+				write(fd, "=", 1);
+				write_arg(fd, p + 14);
+			}
+		} else
+			write_arg(fd, p);
 	}
-
-	bytes_read = read(f_delta, buff, len);
-	if (bytes_read < 0) {
-		rprintf(FERROR, "Batch file %s read error: %s\n",
-		    filename, strerror(errno));
-		close(f_delta);
+	if ((p = find_colon(argv[argc - 1])) != NULL) {
+		if (*++p == ':')
+			p++;
+	} else
+		p = argv[argc - 1];
+	write(fd, " ${1:-", 6);
+	write_arg(fd, p);
+	write_byte(fd, '}');
+	if (exclude_list.head)
+		write_excludes(fd);
+	if (write(fd, "\n", 1) != 1 || close(fd) < 0) {
+		rsyserr(FERROR, errno, "Batch file %s write error", filename);
 		exit_cleanup(1);
 	}
-
-	return bytes_read;
 }
 
 void show_flist(int index, struct file_struct **fptr)
 {
 	/*  for debugging    show_flist(flist->count, flist->files * */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/checksum.c	2004-02-10 02:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/checksum.c	2004-08-03 23:37:54.000000000 +0800
@@ -1,20 +1,20 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1996
    Copyright (C) Paul Mackerras 1996
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
@@ -35,15 +35,15 @@
     int i;
     uint32 s1, s2;
     schar *buf = (schar *)buf1;
 
     s1 = s2 = 0;
     for (i = 0; i < (len-4); i+=4) {
-	s2 += 4*(s1 + buf[i]) + 3*buf[i+1] + 2*buf[i+2] + buf[i+3] + 
+	s2 += 4*(s1 + buf[i]) + 3*buf[i+1] + 2*buf[i+2] + buf[i+3] +
 	  10*CHAR_OFFSET;
-	s1 += (buf[i+0] + buf[i+1] + buf[i+2] + buf[i+3] + 4*CHAR_OFFSET); 
+	s1 += (buf[i+0] + buf[i+1] + buf[i+2] + buf[i+3] + 4*CHAR_OFFSET);
     }
     for (; i < len; i++) {
 	s1 += (buf[i]+CHAR_OFFSET); s2 += s1;
     }
     return (s1 & 0xffff) + (s2 << 16);
 }
@@ -59,92 +59,86 @@
 	if (len > len1) {
 		if (buf1) free(buf1);
 		buf1 = new_array(char, len+4);
 		len1 = len;
 		if (!buf1) out_of_memory("get_checksum2");
 	}
-	
+
 	mdfour_begin(&m);
-	
+
 	memcpy(buf1,buf,len);
 	if (checksum_seed) {
 		SIVAL(buf1,len,checksum_seed);
 		len += 4;
 	}
-	
+
 	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
 		mdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);
 	}
 	/*
 	 * Prior to version 27 an incorrect MD4 checksum was computed
 	 * by failing to call mdfour_tail() for block sizes that
 	 * are multiples of 64.  This is fixed by calling mdfour_update()
 	 * even when there are no more bytes.
 	 */
 	if (len - i > 0 || protocol_version >= 27) {
 		mdfour_update(&m, (uchar *)(buf1+i), (len-i));
 	}
-	
+
 	mdfour_result(&m, (uchar *)sum);
 }
 
 
 void file_checksum(char *fname,char *sum,OFF_T size)
 {
 	OFF_T i;
 	struct map_struct *buf;
 	int fd;
 	OFF_T len = size;
-	char tmpchunk[CSUM_CHUNK];
 	struct mdfour m;
-	
+
 	memset(sum,0,MD4_SUM_LENGTH);
-	
+
 	fd = do_open(fname, O_RDONLY, 0);
-	if (fd == -1) return;
-	
-	buf = map_file(fd,size);
-	
+	if (fd == -1)
+		return;
+
+	buf = map_file(fd, size, MAX_MAP_SIZE, CSUM_CHUNK);
+
 	mdfour_begin(&m);
 
 	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
-		memcpy(tmpchunk, map_ptr(buf,i,CSUM_CHUNK), CSUM_CHUNK);
-		mdfour_update(&m, (uchar *)tmpchunk, CSUM_CHUNK);
+		mdfour_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK),
+			      CSUM_CHUNK);
 	}
 
-	/*
-	 * Prior to version 27 an incorrect MD4 checksum was computed
+	/* Prior to version 27 an incorrect MD4 checksum was computed
 	 * by failing to call mdfour_tail() for block sizes that
 	 * are multiples of 64.  This is fixed by calling mdfour_update()
-	 * even when there are no more bytes.
-	 */
-	if (len - i > 0) {
-		memcpy(tmpchunk, map_ptr(buf,i,len-i), len-i);
-	}
-	if (len - i > 0 || protocol_version >= 27) {
-		mdfour_update(&m, (uchar *)tmpchunk, (len-i));
-	}
+	 * even when there are no more bytes. */
+	if (len - i > 0 || protocol_version >= 27)
+		mdfour_update(&m, (uchar *)map_ptr(buf, i, len-i), len-i);
 
 	mdfour_result(&m, (uchar *)sum);
 
 	close(fd);
 	unmap_file(buf);
 }
 
 
 static int sumresidue;
 static char sumrbuf[CSUM_CHUNK];
 static struct mdfour md;
 
-void sum_init(void)
+void sum_init(int seed)
 {
 	char s[4];
 	mdfour_begin(&md);
-	sumresidue=0;
-	SIVAL(s,0,checksum_seed);
-	sum_update(s,4);
+	sumresidue = 0;
+	SIVAL(s, 0, seed);
+	sum_update(s, 4);
 }
 
 /**
  * Feed data into an MD4 accumulator, md.  The results may be
  * retrieved using sum_end().  md is used for different purposes at
  * different points during execution.
@@ -175,13 +169,13 @@
 	}
 
 	if (len - i > 0) {
 		sumresidue = len-i;
 		memcpy(sumrbuf,p+i,sumresidue);
 	} else {
-		sumresidue = 0;    
+		sumresidue = 0;
 	}
 }
 
 void sum_end(char *sum)
 {
 	if (sumresidue || protocol_version >= 27) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/cleanup.c	2004-01-27 16:14:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/cleanup.c	2004-07-30 00:06:38.000000000 +0800
@@ -1,29 +1,33 @@
 /* -*- c-file-style: "linux" -*-
-   
+
    Copyright (C) 1996-2000 by Andrew Tridgell
    Copyright (C) Paul Mackerras 1996
    Copyright (C) 2002 by Martin Pool
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
+extern int io_error;
+extern int keep_partial;
+extern int log_got_error;
+
 /**
  * Close all open sockets and files, allowing a (somewhat) graceful
  * shutdown() of socket connections.  This eliminates the abortive
  * TCP RST sent by a Winsock-based system when the close() occurs.
  **/
 void close_all(void)
@@ -35,15 +39,14 @@
 	struct stat st;
 
 	max_fd = sysconf(_SC_OPEN_MAX) - 1;
 	for (fd = max_fd; fd >= 0; fd--) {
 		ret = fstat(fd,&st);
 		if (fstat(fd,&st) == 0) {
-			if (is_a_socket(fd)) {
+			if (is_a_socket(fd))
 				ret = shutdown(fd, 2);
-			}
 			ret = close(fd);
 		}
 	}
 #endif
 }
 
@@ -62,90 +65,90 @@
  * current file. (????)
  *
  * Handling the cleanup when a transfer is interrupted is tricky when
  * --partial is selected.  We need to ensure that the partial file is
  * kept if any real data has been transferred.
  **/
-int cleanup_got_literal=0;
+int cleanup_got_literal = 0;
 
 static char *cleanup_fname;
 static char *cleanup_new_fname;
 static struct file_struct *cleanup_file;
-static int cleanup_fd1, cleanup_fd2;
-static struct map_struct *cleanup_buf;
+static int cleanup_fd_r, cleanup_fd_w;
 static pid_t cleanup_pid = 0;
-extern int io_error;
 
 pid_t cleanup_child_pid = -1;
 
 /**
  * Eventually calls exit(), passing @p code, therefore does not return.
  *
  * @param code one of the RERR_* codes from errcode.h.
  **/
 void _exit_cleanup(int code, const char *file, int line)
 {
 	int ocode = code;
-	extern int keep_partial;
-	extern int log_got_error;
 	static int inside_cleanup = 0;
 
 	if (inside_cleanup > 10) {
 		/* prevent the occasional infinite recursion */
 		return;
 	}
 	inside_cleanup++;
 
 	signal(SIGUSR1, SIG_IGN);
 	signal(SIGUSR2, SIG_IGN);
 
-	if (verbose > 3)
-		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): entered\n", 
+	if (verbose > 3) {
+		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): entered\n",
 			code, file, line);
+	}
 
 	if (cleanup_child_pid != -1) {
 		int status;
 		if (waitpid(cleanup_child_pid, &status, WNOHANG) == cleanup_child_pid) {
 			status = WEXITSTATUS(status);
-			if (status > code) code = status;
+			if (status > code)
+				code = status;
 		}
 	}
 
-	if (cleanup_got_literal && cleanup_fname && keep_partial) {
+	if (cleanup_got_literal && cleanup_fname && keep_partial
+	    && handle_partial_dir(cleanup_new_fname, PDIR_CREATE)) {
 		char *fname = cleanup_fname;
 		cleanup_fname = NULL;
-		if (cleanup_buf) unmap_file(cleanup_buf);
-		if (cleanup_fd1 != -1) close(cleanup_fd1);
-		if (cleanup_fd2 != -1) close(cleanup_fd2);
-		finish_transfer(cleanup_new_fname, fname, cleanup_file);
+		if (cleanup_fd_r != -1)
+			close(cleanup_fd_r);
+		if (cleanup_fd_w != -1)
+			close(cleanup_fd_w);
+		finish_transfer(cleanup_new_fname, fname, cleanup_file, 0);
 	}
 	io_flush(FULL_FLUSH);
 	if (cleanup_fname)
 		do_unlink(cleanup_fname);
-	if (code) {
+	if (code)
 		kill_all(SIGUSR1);
-	}
 	if (cleanup_pid && cleanup_pid == getpid()) {
 		char *pidf = lp_pid_file();
-		if (pidf && *pidf) {
+		if (pidf && *pidf)
 			unlink(lp_pid_file());
-		}
 	}
 
 	if (code == 0) {
 		if ((io_error & ~IOERR_VANISHED) || log_got_error)
 			code = RERR_PARTIAL;
 		else if (io_error)
 			code = RERR_VANISHED;
 	}
 
-	if (code) log_exit(code, file, line);
+	if (code)
+		log_exit(code, file, line);
 
-	if (verbose > 2)
-		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n", 
+	if (verbose > 2) {
+		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n",
 			ocode, file, line, code);
+	}
 
 	close_all();
 	exit(code);
 }
 
 void cleanup_disable(void)
@@ -153,20 +156,19 @@
 	cleanup_fname = NULL;
 	cleanup_got_literal = 0;
 }
 
 
 void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
-		 struct map_struct *buf, int fd1, int fd2)
+		 int fd_r, int fd_w)
 {
 	cleanup_fname = fnametmp;
 	cleanup_new_fname = fname;
 	cleanup_file = file;
-	cleanup_buf = buf;
-	cleanup_fd1 = fd1;
-	cleanup_fd2 = fd2;
+	cleanup_fd_r = fd_r;
+	cleanup_fd_w = fd_w;
 }
 
 void cleanup_set_pid(pid_t pid)
 {
 	cleanup_pid = pid;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/clientname.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/clientname.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/clientname.c	2004-05-01 00:10:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/clientname.c	2004-09-25 00:39:41.000000000 +0800
@@ -40,34 +40,32 @@
 
 /**
  * Return the IP addr of the client as a string
  **/
 char *client_addr(int fd)
 {
-	struct sockaddr_storage ss;
-	socklen_t length = sizeof ss;
-	char *ssh_client, *p;
-	int len;
 	static char addr_buf[100];
 	static int initialised;
+	struct sockaddr_storage ss;
+	socklen_t length = sizeof ss;
+	char *ssh_info, *p;
 
 	if (initialised)
 		return addr_buf;
 
 	initialised = 1;
 
 	if (am_server) {	/* daemon over --rsh mode */
 		strcpy(addr_buf, "0.0.0.0");
-		if ((ssh_client = getenv("SSH_CLIENT")) != NULL) {
-			/* truncate SSH_CLIENT to just IP address */
-			if ((p = strchr(ssh_client, ' ')) != NULL) {
-				len = MIN((unsigned int) (p - ssh_client),
-				    sizeof addr_buf - 1);
-				strncpy(addr_buf, ssh_client, len);
-				*(addr_buf + len) = '\0';
-			}
+		if ((ssh_info = getenv("SSH_CONNECTION")) != NULL
+		    || (ssh_info = getenv("SSH_CLIENT")) != NULL
+		    || (ssh_info = getenv("SSH2_CLIENT")) != NULL) {
+			strlcpy(addr_buf, ssh_info, sizeof addr_buf);
+			/* Truncate the value to just the IP address. */
+			if ((p = strchr(addr_buf, ' ')) != NULL)
+				*p = '\0';
 		}
 	} else {
 		client_sockaddr(fd, &ss, &length);
 		getnameinfo((struct sockaddr *)&ss, length,
 			    addr_buf, sizeof addr_buf, NULL, 0, NI_NUMERICHOST);
 	}
@@ -121,13 +119,13 @@
 #ifdef AI_NUMERICHOST
 		hint.ai_flags = AI_NUMERICHOST;
 #endif
 		hint.ai_socktype = SOCK_STREAM;
 
 		if ((err = getaddrinfo(addr, NULL, &hint, &answer)) != 0) {
-			rprintf(FERROR, RSYNC_NAME ": malformed address %s: %s\n",
+			rprintf(FLOG, "malformed address %s: %s\n",
 			        addr, gai_strerror(err));
 			return name_buf;
 		}
 
 		switch (answer->ai_family) {
 		case AF_INET:
@@ -144,14 +142,14 @@
 		freeaddrinfo(answer);
 	} else {
 		ss_len = sizeof ss;
 		client_sockaddr(fd, &ss, &ss_len);
 	}
 
-	if (!lookup_name(fd, &ss, ss_len, name_buf, sizeof name_buf,
-			port_buf, sizeof port_buf))
+	if (lookup_name(fd, &ss, ss_len, name_buf, sizeof name_buf,
+			port_buf, sizeof port_buf) == 0)
 		check_name(fd, &ss, name_buf);
 
 	return name_buf;
 }
 
 
@@ -167,14 +165,13 @@
 		     socklen_t *ss_len)
 {
 	memset(ss, 0, sizeof *ss);
 
 	if (getpeername(fd, (struct sockaddr *) ss, ss_len)) {
 		/* FIXME: Can we really not continue? */
-		rprintf(FERROR, RSYNC_NAME ": getpeername on fd%d failed: %s\n",
-			fd, strerror(errno));
+		rsyserr(FLOG, errno, "getpeername on fd%d failed", fd);
 		exit_cleanup(RERR_SOCKETIO);
 	}
 
 #ifdef INET6
 	if (get_sockaddr_family(ss) == AF_INET6 &&
 	    IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)ss)->sin6_addr)) {
@@ -223,15 +220,14 @@
 	name_err = getnameinfo((struct sockaddr *) ss, ss_len,
 			       name_buf, name_buf_len,
 			       port_buf, port_buf_len,
 			       NI_NAMEREQD | NI_NUMERICSERV);
 	if (name_err != 0) {
 		strcpy(name_buf, default_name);
-		rprintf(FERROR, RSYNC_NAME ": name lookup failed for %s: %s\n",
-			client_addr(fd),
-			gai_strerror(name_err));
+		rprintf(FLOG, "name lookup failed for %s: %s\n",
+			client_addr(fd), gai_strerror(name_err));
 		return name_err;
 	}
 
 	return 0;
 }
 
@@ -246,14 +242,13 @@
 			      const struct sockaddr_storage *ss)
 {
 	int ss_family = get_sockaddr_family(ss);
 	const char fn[] = "compare_addrinfo_sockaddr";
 
 	if (ai->ai_family != ss_family) {
-		rprintf(FERROR,
-			"%s: response family %d != %d\n",
+		rprintf(FLOG, "%s: response family %d != %d\n",
 			fn, ai->ai_family, ss_family);
 		return 1;
 	}
 
 	/* The comparison method depends on the particular AF. */
 	if (ss_family == AF_INET) {
@@ -271,14 +266,13 @@
 		const struct sockaddr_in6 *sin1, *sin2;
 
 		sin1 = (const struct sockaddr_in6 *) ss;
 		sin2 = (const struct sockaddr_in6 *) ai->ai_addr;
 
 		if (ai->ai_addrlen < sizeof (struct sockaddr_in6)) {
-			rprintf(FERROR,
-				"%s: too short sockaddr_in6; length=%d\n",
+			rprintf(FLOG, "%s: too short sockaddr_in6; length=%d\n",
 				fn, ai->ai_addrlen);
 			return 1;
 		}
 
 		if (memcmp(&sin1->sin6_addr, &sin2->sin6_addr,
 			   sizeof sin1->sin6_addr))
@@ -318,14 +312,13 @@
 	memset(&hints, 0, sizeof hints);
 	hints.ai_family = ss_family;
 	hints.ai_flags = AI_CANONNAME;
 	hints.ai_socktype = SOCK_STREAM;
 	error = getaddrinfo(name_buf, NULL, &hints, &res0);
 	if (error) {
-		rprintf(FERROR,
-			RSYNC_NAME ": forward name lookup for %s failed: %s\n",
+		rprintf(FLOG, "forward name lookup for %s failed: %s\n",
 			name_buf, gai_strerror(error));
 		strcpy(name_buf, default_name);
 		return error;
 	}
 
 
@@ -336,25 +329,20 @@
 			break;	/* OK, identical */
 	}
 
 	if (!res0) {
 		/* We hit the end of the list without finding an
 		 * address that was the same as ss. */
-		rprintf(FERROR, RSYNC_NAME
-			": no known address for \"%s\": "
-			"spoofed address?\n",
-			name_buf);
+		rprintf(FLOG, "no known address for \"%s\": "
+			"spoofed address?\n", name_buf);
 		strcpy(name_buf, default_name);
 	} else if (res == NULL) {
 		/* We hit the end of the list without finding an
 		 * address that was the same as ss. */
-		rprintf(FERROR, RSYNC_NAME
-			": %s is not a known address for \"%s\": "
-			"spoofed address?\n",
-			client_addr(fd),
-			name_buf);
+		rprintf(FLOG, "%s is not a known address for \"%s\": "
+			"spoofed address?\n", client_addr(fd), name_buf);
 		strcpy(name_buf, default_name);
 	}
 
 	freeaddrinfo(res0);
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/clientserver.c	2004-04-15 07:33:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/clientserver.c	2004-08-01 03:55:42.000000000 +0800
@@ -47,12 +47,13 @@
 extern int no_detach;
 extern int default_af_hint;
 extern char *bind_address;
 extern struct exclude_list_struct server_exclude_list;
 extern char *exclude_path_prefix;
 extern char *config_file;
+extern char *files_from;
 
 char *auth_user;
 
 /**
  * Run a client connected to an rsyncd.  The alternative to this
  * function for remote-shell connections is do_cmd().
@@ -67,57 +68,61 @@
  * @return -1 for error in startup, or the result of client_run().
  * Either way, it eventually gets passed to exit_cleanup().
  **/
 int start_socket_client(char *host, char *path, int argc, char *argv[])
 {
 	int fd, ret;
-	char *p, *user=NULL;
+	char *p, *user = NULL;
 
-	/* this is redundant with code in start_inband_exchange(), but
-	 * this short-circuits a problem before we open a socket, and
-	 * the extra check won't hurt */
+	/* This is redundant with code in start_inband_exchange(), but this
+	 * short-circuits a problem in the client before we open a socket,
+	 * and the extra check won't hurt. */
 	if (*path == '/') {
-		rprintf(FERROR,"ERROR: The remote path must start with a module name not a /\n");
+		rprintf(FERROR,
+			"ERROR: The remote path must start with a module name not a /\n");
 		return -1;
 	}
 
-	p = strchr(host, '@');
-	if (p) {
+	if ((p = strchr(host, '@')) != NULL) {
 		user = host;
 		host = p+1;
-		*p = 0;
+		*p = '\0';
 	}
 
 	fd = open_socket_out_wrapped(host, rsync_port, bind_address,
 				     default_af_hint);
 	if (fd == -1)
 		exit_cleanup(RERR_SOCKETIO);
 
 	ret = start_inband_exchange(user, path, fd, fd, argc);
 
 	return ret < 0? ret : client_run(fd, fd, -1, argc, argv);
 }
 
-int start_inband_exchange(char *user, char *path, int f_in, int f_out, int argc)
+int start_inband_exchange(char *user, char *path, int f_in, int f_out, 
+			  int argc)
 {
 	int i;
 	char *sargs[MAX_ARGS];
 	int sargc = 0;
 	char line[MAXPATHLEN];
 	char *p;
 
 	if (argc == 0 && !am_sender)
 		list_only = 1;
 
 	if (*path == '/') {
-		rprintf(FERROR, "ERROR: The remote path must start with a module name\n");
+		rprintf(FERROR,
+			"ERROR: The remote path must start with a module name\n");
 		return -1;
 	}
 
-	if (!user) user = getenv("USER");
-	if (!user) user = getenv("LOGNAME");
+	if (!user)
+		user = getenv("USER");
+	if (!user)
+		user = getenv("LOGNAME");
 
 	/* set daemon_over_rsh to false since we need to build the
 	 * true set of args passed through the rsh/ssh connection;
 	 * this is a no-op for direct-socket-connection mode */
 	daemon_over_rsh = 0;
 	server_options(sargs, &sargc);
@@ -128,13 +133,13 @@
 		sargs[sargc++] = path;
 
 	sargs[sargc] = NULL;
 
 	io_printf(f_out, "@RSYNCD: %d\n", protocol_version);
 
-	if (!read_line(f_in, line, sizeof(line)-1)) {
+	if (!read_line(f_in, line, sizeof line - 1)) {
 		rprintf(FERROR, "rsync: did not see server greeting\n");
 		return -1;
 	}
 
 	if (sscanf(line,"@RSYNCD: %d", &remote_protocol) != 1) {
 		/* note that read_line strips of \n or \r */
@@ -152,34 +157,35 @@
 
 	/* Old servers may just drop the connection here,
 	 rather than sending a proper EXIT command.  Yuck. */
 	kludge_around_eof = list_only && (protocol_version < 25);
 
 	while (1) {
-		if (!read_line(f_in, line, sizeof(line)-1)) {
+		if (!read_line(f_in, line, sizeof line - 1)) {
 			rprintf(FERROR, "rsync: didn't get server startup line\n");
 			return -1;
 		}
 
 		if (strncmp(line,"@RSYNCD: AUTHREQD ",18) == 0) {
 			auth_client(f_out, user, line+18);
 			continue;
 		}
 
-		if (strcmp(line,"@RSYNCD: OK") == 0) break;
+		if (strcmp(line,"@RSYNCD: OK") == 0)
+			break;
 
 		if (strcmp(line,"@RSYNCD: EXIT") == 0) {
 			/* This is sent by recent versions of the
 			 * server to terminate the listing of modules.
 			 * We don't want to go on and transfer
 			 * anything; just exit. */
 			exit(0);
 		}
 
 		if (strncmp(line, "@ERROR", 6) == 0) {
-			rprintf(FERROR,"%s\n", line);
+			rprintf(FERROR, "%s\n", line);
 			/* This is always fatal; the server will now
 			 * close the socket. */
 			return RERR_STARTCLIENT;
 		} else {
 			rprintf(FINFO,"%s\n", line);
 		}
@@ -190,58 +196,64 @@
 		io_printf(f_out, "%s\n", sargs[i]);
 	}
 	io_printf(f_out, "\n");
 
 	if (protocol_version < 23) {
 		if (protocol_version == 22 || !am_sender)
-			io_start_multiplex_in(f_in);
+			io_start_multiplex_in();
 	}
 
 	return 0;
 }
 
 
 
 static int rsync_module(int f_in, int f_out, int i)
 {
-	int argc=0;
-	char *argv[MAX_ARGS];
+	int argc = 0;
+	int maxargs;
+	char **argv;
 	char **argp;
 	char line[MAXPATHLEN];
 	uid_t uid = (uid_t)-2;  /* canonically "nobody" */
 	gid_t gid = (gid_t)-2;
 	char *p;
 	char *addr = client_addr(f_in);
 	char *host = client_name(f_in);
 	char *name = lp_name(i);
 	int use_chroot = lp_use_chroot(i);
-	int start_glob=0;
+	int start_glob = 0;
 	int ret;
-	char *request=NULL;
+	char *request = NULL;
 
 	if (!allow_access(addr, host, lp_hosts_allow(i), lp_hosts_deny(i))) {
-		rprintf(FERROR,"rsync denied on module %s from %s (%s)\n",
+		rprintf(FLOG, "rsync denied on module %s from %s (%s)\n",
 			name, host, addr);
-		io_printf(f_out, "@ERROR: access denied to %s from %s (%s)\n",
-			  name, host, addr);
+		if (!lp_list(i))
+			io_printf(f_out, "@ERROR: Unknown module '%s'\n", name);
+		else {
+			io_printf(f_out,
+				  "@ERROR: access denied to %s from %s (%s)\n",
+				  name, host, addr);
+		}
 		return -1;
 	}
 
 	if (am_daemon && am_server) {
-		rprintf(FINFO, "rsync allowed access on module %s from %s (%s)\n",
+		rprintf(FLOG, "rsync allowed access on module %s from %s (%s)\n",
 			name, host, addr);
 	}
 
 	if (!claim_connection(lp_lock_file(i), lp_max_connections(i))) {
 		if (errno) {
-			rprintf(FERROR,"failed to open lock file %s : %s\n",
-				lp_lock_file(i), strerror(errno));
-			io_printf(f_out, "@ERROR: failed to open lock file %s : %s\n",
-				  lp_lock_file(i), strerror(errno));
+			rsyserr(FLOG, errno, "failed to open lock file %s",
+				lp_lock_file(i));
+			io_printf(f_out, "@ERROR: failed to open lock file %s\n",
+				  lp_lock_file(i));
 		} else {
-			rprintf(FERROR,"max connections (%d) reached\n",
+			rprintf(FLOG, "max connections (%d) reached\n",
 				lp_max_connections(i));
 			io_printf(f_out, "@ERROR: max connections (%d) reached - try again later\n",
 				lp_max_connections(i));
 		}
 		return -1;
 	}
@@ -243,41 +255,40 @@
 			io_printf(f_out, "@ERROR: max connections (%d) reached - try again later\n",
 				lp_max_connections(i));
 		}
 		return -1;
 	}
 
-
 	auth_user = auth_server(f_in, f_out, i, addr, "@RSYNCD: AUTHREQD ");
 
 	if (!auth_user) {
-		rprintf(FERROR,"auth failed on module %s from %s (%s)\n",
+		rprintf(FLOG, "auth failed on module %s from %s (%s)\n",
 			name, host, addr);
 		io_printf(f_out, "@ERROR: auth failed on module %s\n", name);
 		return -1;
 	}
 
 	module_id = i;
 
 	am_root = (MY_UID() == 0);
 
 	if (am_root) {
 		p = lp_uid(i);
 		if (!name_to_uid(p, &uid)) {
-			if (!isdigit(* (unsigned char *) p)) {
-				rprintf(FERROR,"Invalid uid %s\n", p);
+			if (!isdigit(*(unsigned char *)p)) {
+				rprintf(FLOG, "Invalid uid %s\n", p);
 				io_printf(f_out, "@ERROR: invalid uid %s\n", p);
 				return -1;
 			}
 			uid = atoi(p);
 		}
 
 		p = lp_gid(i);
 		if (!name_to_gid(p, &gid)) {
-			if (!isdigit(* (unsigned char *) p)) {
-				rprintf(FERROR,"Invalid gid %s\n", p);
+			if (!isdigit(*(unsigned char *)p)) {
+				rprintf(FLOG, "Invalid gid %s\n", p);
 				io_printf(f_out, "@ERROR: invalid gid %s\n", p);
 				return -1;
 			}
 			gid = atoi(p);
 		}
 	}
@@ -323,26 +334,26 @@
 		 *
 		 * So, perhaps if we can't chroot we should just issue
 		 * a warning, unless a "require chroot" flag is set,
 		 * in which case we fail.
 		 */
 		if (chroot(lp_path(i))) {
-			rsyserr(FERROR, errno, "chroot %s failed", lp_path(i));
+			rsyserr(FLOG, errno, "chroot %s failed", lp_path(i));
 			io_printf(f_out, "@ERROR: chroot failed\n");
 			return -1;
 		}
 
 		if (!push_dir("/")) {
-			rsyserr(FERROR, errno, "chdir %s failed\n", lp_path(i));
+			rsyserr(FLOG, errno, "chdir %s failed\n", lp_path(i));
 			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 
 	} else {
 		if (!push_dir(lp_path(i))) {
-			rsyserr(FERROR, errno, "chdir %s failed\n", lp_path(i));
+			rsyserr(FLOG, errno, "chdir %s failed\n", lp_path(i));
 			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 		sanitize_paths = 1;
 	}
 
@@ -355,118 +366,118 @@
 
 		/* TODO: Perhaps we need to document that if rsyncd is
 		 * started by somebody other than root it will inherit
 		 * all their supplementary groups. */
 
 		if (setgid(gid)) {
-			rsyserr(FERROR, errno, "setgid %d failed", (int) gid);
+			rsyserr(FLOG, errno, "setgid %d failed", (int)gid);
 			io_printf(f_out, "@ERROR: setgid failed\n");
 			return -1;
 		}
 #ifdef HAVE_SETGROUPS
 		/* Get rid of any supplementary groups this process
 		 * might have inheristed. */
 		if (setgroups(1, &gid)) {
-			rsyserr(FERROR, errno, "setgroups failed");
+			rsyserr(FLOG, errno, "setgroups failed");
 			io_printf(f_out, "@ERROR: setgroups failed\n");
 			return -1;
 		}
 #endif
 
 		if (setuid(uid)) {
-			rsyserr(FERROR, errno, "setuid %d failed", (int) uid);
+			rsyserr(FLOG, errno, "setuid %d failed", (int)uid);
 			io_printf(f_out, "@ERROR: setuid failed\n");
 			return -1;
 		}
 
 		am_root = (MY_UID() == 0);
 	}
 
 	io_printf(f_out, "@RSYNCD: OK\n");
 
+	maxargs = MAX_ARGS;
+	if (!(argv = new_array(char *, maxargs)))
+		out_of_memory("rsync_module");
 	argv[argc++] = "rsyncd";
 
 	while (1) {
-		if (!read_line(f_in, line, sizeof(line)-1)) {
+		if (!read_line(f_in, line, sizeof line - 1))
 			return -1;
-		}
 
-		if (!*line) break;
+		if (!*line)
+			break;
 
 		p = line;
 
-		argv[argc] = strdup(p);
-		if (!argv[argc]) {
-			return -1;
+		if (argc == maxargs) {
+			maxargs += MAX_ARGS;
+			if (!(argv = realloc_array(argv, char *, maxargs)))
+				out_of_memory("rsync_module");
 		}
+		if (!(argv[argc] = strdup(p)))
+			out_of_memory("rsync_module");
 
 		if (start_glob) {
 			if (start_glob == 1) {
 				request = strdup(p);
 				start_glob++;
 			}
-			glob_expand(name, argv, &argc, MAX_ARGS);
-		} else {
+			glob_expand(name, &argv, &argc, &maxargs);
+		} else
 			argc++;
-		}
 
-		if (strcmp(line,".") == 0) {
+		if (strcmp(line, ".") == 0)
 			start_glob = 1;
-		}
-
-		if (argc == MAX_ARGS) {
-			return -1;
-		}
 	}
 
 	argp = argv;
 	ret = parse_arguments(&argc, (const char ***) &argp, 0);
 
 	if (filesfrom_fd == 0)
 		filesfrom_fd = f_in;
 
 	if (request) {
 		if (*auth_user) {
-			rprintf(FINFO,"rsync %s %s from %s@%s (%s)\n",
-				am_sender?"on":"to",
+			rprintf(FLOG, "rsync %s %s from %s@%s (%s)\n",
+				am_sender ? "on" : "to",
 				request, auth_user, host, addr);
 		} else {
-			rprintf(FINFO,"rsync %s %s from %s (%s)\n",
-				am_sender?"on":"to",
+			rprintf(FLOG, "rsync %s %s from %s (%s)\n",
+				am_sender ? "on" : "to",
 				request, host, addr);
 		}
 		free(request);
 	}
 
 #ifndef DEBUG
 	/* don't allow the logs to be flooded too fast */
 	if (verbose > lp_max_verbosity())
 		verbose = lp_max_verbosity();
 #endif
 
-	if (protocol_version < 23) {
-		if (protocol_version == 22 || am_sender)
-			io_start_multiplex_out(f_out);
+	if (protocol_version < 23
+	    && (protocol_version == 22 || am_sender))
+		io_start_multiplex_out();
+	else if (!ret) {
+		/* We have to get I/O multiplexing started so that we can
+		 * get the error back to the client.  This means getting
+		 * the protocol setup finished first in later versions. */
+		setup_protocol(f_out, f_in);
+		if (files_from && !am_sender && strcmp(files_from, "-") != 0)
+			write_byte(f_out, 0);
+		io_start_multiplex_out();
 	}
 
-	/* For later protocol versions, we don't start multiplexing
-	 * until we've configured nonblocking in start_server.  That
-	 * means we're in a sticky situation now: there's no way to
-	 * convey errors to the client. */
-
-	/* FIXME: Hold off on reporting option processing errors until
-	 * we've set up nonblocking and multiplexed IO and can get the
-	 * message back to them. */
 	if (!ret) {
 		option_error();
+		msleep(400);
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
 
-	if (lp_timeout(i)) {
+	if (lp_timeout(i))
 		io_timeout = lp_timeout(i);
-	}
 
 	start_server(f_in, f_out, argc, argp);
 
 	return 0;
 }
 
@@ -474,32 +485,34 @@
    with "list = False". */
 static void send_listing(int fd)
 {
 	int n = lp_numservices();
 	int i;
 
-	for (i=0;i<n;i++)
+	for (i = 0; i < n; i++) {
 		if (lp_list(i))
 			io_printf(fd, "%-15s\t%s\n", lp_name(i), lp_comment(i));
+	}
 
 	if (protocol_version >= 25)
 		io_printf(fd,"@RSYNCD: EXIT\n");
 }
 
 /* this is called when a connection is established to a client
    and we want to start talking. The setup of the system is done from
    here */
 int start_daemon(int f_in, int f_out)
 {
 	char line[200];
 	char *motd;
-	int i = -1;
+	int i;
 
-	if (!lp_load(config_file, 0)) {
+	io_set_sock_fds(f_in, f_out);
+
+	if (!lp_load(config_file, 0))
 		exit_cleanup(RERR_SYNTAX);
-	}
 
 	log_init();
 
 	if (!am_server) {
 		set_socket_options(f_in, "SO_KEEPALIVE");
 		set_socket_options(f_in, lp_socket_options());
@@ -509,55 +522,55 @@
 	io_printf(f_out, "@RSYNCD: %d\n", protocol_version);
 
 	motd = lp_motd_file();
 	if (motd && *motd) {
 		FILE *f = fopen(motd,"r");
 		while (f && !feof(f)) {
-			int len = fread(line, 1, sizeof(line)-1, f);
+			int len = fread(line, 1, sizeof line - 1, f);
 			if (len > 0) {
 				line[len] = 0;
 				io_printf(f_out, "%s", line);
 			}
 		}
-		if (f) fclose(f);
+		if (f)
+			fclose(f);
 		io_printf(f_out, "\n");
 	}
 
-	if (!read_line(f_in, line, sizeof(line)-1)) {
+	if (!read_line(f_in, line, sizeof line - 1))
 		return -1;
-	}
 
 	if (sscanf(line,"@RSYNCD: %d", &remote_protocol) != 1) {
 		io_printf(f_out, "@ERROR: protocol startup error\n");
 		return -1;
 	}
 	if (protocol_version > remote_protocol)
 		protocol_version = remote_protocol;
 
-	while (i == -1) {
-		line[0] = 0;
-		if (!read_line(f_in, line, sizeof(line)-1)) {
-			return -1;
-		}
+	line[0] = 0;
+	if (!read_line(f_in, line, sizeof line - 1))
+		return -1;
 
-		if (!*line || strcmp(line,"#list")==0) {
-			send_listing(f_out);
-			return -1;
-		}
+	if (!*line || strcmp(line, "#list") == 0) {
+		send_listing(f_out);
+		return -1;
+	}
 
-		if (*line == '#') {
-			/* it's some sort of command that I don't understand */
-			io_printf(f_out, "@ERROR: Unknown command '%s'\n", line);
-			return -1;
-		}
+	if (*line == '#') {
+		/* it's some sort of command that I don't understand */
+		io_printf(f_out, "@ERROR: Unknown command '%s'\n", line);
+		return -1;
+	}
 
-		i = lp_number(line);
-		if (i == -1) {
-			io_printf(f_out, "@ERROR: Unknown module '%s'\n", line);
-			return -1;
-		}
+	if ((i = lp_number(line)) < 0) {
+		char *addr = client_addr(f_in);
+		char *host = client_name(f_in);
+		rprintf(FLOG, "unknown module '%s' tried from %s (%s)\n",
+			line, host, addr);
+		io_printf(f_out, "@ERROR: Unknown module '%s'\n", line);
+		return -1;
 	}
 
 	return rsync_module(f_in, f_out, i);
 }
 
 
@@ -568,30 +581,29 @@
 	if (is_a_socket(STDIN_FILENO)) {
 		int i;
 
 		/* we are running via inetd - close off stdout and
 		 * stderr so that library functions (and getopt) don't
 		 * try to use them. Redirect them to /dev/null */
-		for (i=1;i<3;i++) {
+		for (i = 1; i < 3; i++) {
 			close(i);
 			open("/dev/null", O_RDWR);
 		}
 
 		return start_daemon(STDIN_FILENO, STDIN_FILENO);
 	}
 
 	if (!no_detach)
 		become_daemon();
 
-	if (!lp_load(config_file, 1)) {
+	if (!lp_load(config_file, 1))
 		exit_cleanup(RERR_SYNTAX);
-	}
 
 	log_init();
 
-	rprintf(FINFO, "rsyncd version %s starting, listening on port %d\n",
+	rprintf(FLOG, "rsyncd version %s starting, listening on port %d\n",
 		RSYNC_VERSION, rsync_port);
 	/* TODO: If listening on a particular address, then show that
 	 * address too.  In fact, why not just do inet_ntop on the
 	 * local address??? */
 
 	if (((pid_file = lp_pid_file()) != NULL) && (*pid_file != '\0')) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/compat.c	2004-02-10 02:32:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/compat.c	2004-07-22 07:59:22.000000000 +0800
@@ -24,42 +24,33 @@
  **/
 
 #include "rsync.h"
 
 int remote_protocol = 0;
 
+extern int verbose;
 extern int am_server;
-
-extern int preserve_links;
-extern int preserve_perms;
-extern int preserve_devices;
-extern int preserve_uid;
-extern int preserve_gid;
-extern int preserve_times;
-extern int always_checksum;
+extern int am_sender;
+extern int read_batch;
 extern int checksum_seed;
-
 extern int protocol_version;
-extern int verbose;
-
-extern int read_batch;
-extern int write_batch;
 
 void setup_protocol(int f_out,int f_in)
 {
 	if (remote_protocol == 0) {
-		if (am_server) {
-			remote_protocol = read_int(f_in);
+		if (!read_batch)
 			write_int(f_out, protocol_version);
-		} else {
-			write_int(f_out, protocol_version);
-			remote_protocol = read_int(f_in);
-		}
+		remote_protocol = read_int(f_in);
 		if (protocol_version > remote_protocol)
 			protocol_version = remote_protocol;
 	}
+	if (read_batch && remote_protocol > protocol_version) {
+	        rprintf(FERROR, "The protocol version in the batch file is too new (%d > %d).\n",
+			remote_protocol, protocol_version);
+		exit_cleanup(RERR_PROTOCOL);
+	}
 
 	if (verbose > 3) {
 		rprintf(FINFO, "(%s) Protocol versions: remote=%d, negotiated=%d\n",
 			am_server? "Server" : "Client", remote_protocol, protocol_version);
 	}
 	if (remote_protocol < MIN_PROTOCOL_VERSION
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/config.h.in	2004-04-30 03:40:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/config.h.in	2004-08-03 05:54:49.000000000 +0800
@@ -65,12 +65,15 @@
 /* Define to 1 if you have the <float.h> header file. */
 #undef HAVE_FLOAT_H
 
 /* Define to 1 if you have the `fstat' function. */
 #undef HAVE_FSTAT
 
+/* Define to 1 if you have the `ftruncate' function. */
+#undef HAVE_FTRUNCATE
+
 /* Define if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
 /* Define to 1 if you have the `getcwd' function. */
 #undef HAVE_GETCWD
 
@@ -152,24 +155,30 @@
 /* Define to 1 if you have the `mkfifo' function. */
 #undef HAVE_MKFIFO
 
 /* Define to 1 if you have the `mknod' function. */
 #undef HAVE_MKNOD
 
+/* Define to 1 if you have the `mkstemp64' function. */
+#undef HAVE_MKSTEMP64
+
 /* Define to 1 if you have the `mtrace' function. */
 #undef HAVE_MTRACE
 
 /* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
 #undef HAVE_NDIR_H
 
 /* Define to 1 if you have the <netdb.h> header file. */
 #undef HAVE_NETDB_H
 
 /* */
 #undef HAVE_OFF64_T
 
+/* Define to 1 if you have the `open64' function. */
+#undef HAVE_OPEN64
+
 /* Define to 1 if you have the `readlink' function. */
 #undef HAVE_READLINK
 
 /* remote shell is remsh not rsh */
 #undef HAVE_REMSH
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/configure	2004-05-01 02:02:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/configure	2004-10-01 00:35:56.000000000 +0800
@@ -1311,13 +1311,13 @@
 
 
           ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=2.6.2
+RSYNC_VERSION=2.6.3
 
 { echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
 echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -9328,16 +9328,20 @@
 
 
 
 
 
 
+
+
+
 for ac_func in waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo \
-    fchmod fstat strchr readlink link utime utimes strftime mtrace \
+    fchmod fstat strchr readlink link utime utimes strftime mtrace ftruncate \
     memmove lchown vsnprintf snprintf asprintf setsid glob strpbrk \
-    strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid
+    strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
+    open64 mkstemp64
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -9956,13 +9960,13 @@
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_GETTIMEOFDAY_TZ" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_GETTIMEOFDAY_TZ" >&6
-if test x"$rsync_cv_HAVE_GETTIMEOFDAY_TZ" = x"yes"; then
+if test x"$rsync_cv_HAVE_GETTIMEOFDAY_TZ" != x"no"; then
 
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_GETTIMEOFDAY_TZ 1
 _ACEOF
 
 fi
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/configure.in	2004-05-01 02:02:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/configure.in	2004-10-01 00:35:56.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.52)
 
-RSYNC_VERSION=2.6.2
+RSYNC_VERSION=2.6.3
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -439,15 +439,16 @@
 dnl every platform has a memcmp that can do at least that.
 dnl AC_FUNC_MEMCMP
 
 AC_FUNC_UTIME_NULL
 AC_FUNC_ALLOCA
 AC_CHECK_FUNCS(waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo \
-    fchmod fstat strchr readlink link utime utimes strftime mtrace \
+    fchmod fstat strchr readlink link utime utimes strftime mtrace ftruncate \
     memmove lchown vsnprintf snprintf asprintf setsid glob strpbrk \
-    strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid)
+    strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
+    open64 mkstemp64)
 
 AC_CACHE_CHECK([for working socketpair],rsync_cv_HAVE_SOCKETPAIR,[
 AC_TRY_RUN([
 #include <sys/types.h>
 #include <sys/socket.h>
 
@@ -539,13 +540,13 @@
 AC_CACHE_CHECK([if gettimeofday takes tz argument],rsync_cv_HAVE_GETTIMEOFDAY_TZ,[
 AC_TRY_RUN([
 #include <sys/time.h>
 #include <unistd.h>
 main() { struct timeval tv; exit(gettimeofday(&tv, NULL));}],
            rsync_cv_HAVE_GETTIMEOFDAY_TZ=yes,rsync_cv_HAVE_GETTIMEOFDAY_TZ=no,rsync_cv_HAVE_GETTIMEOFDAY_TZ=cross)])
-if test x"$rsync_cv_HAVE_GETTIMEOFDAY_TZ" = x"yes"; then
+if test x"$rsync_cv_HAVE_GETTIMEOFDAY_TZ" != x"no"; then
     AC_DEFINE(HAVE_GETTIMEOFDAY_TZ, 1, [ ])
 fi
 
 AC_CACHE_CHECK([for C99 vsnprintf],rsync_cv_HAVE_C99_VSNPRINTF,[
 AC_TRY_RUN([
 #include <sys/types.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/exclude.c	2004-04-27 09:36:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/exclude.c	2004-09-22 12:11:15.000000000 +0800
@@ -35,59 +35,60 @@
 
 struct exclude_list_struct exclude_list = { 0, 0, "" };
 struct exclude_list_struct local_exclude_list = { 0, 0, "per-dir .cvsignore " };
 struct exclude_list_struct server_exclude_list = { 0, 0, "server " };
 char *exclude_path_prefix = NULL;
 
-/** Build an exclude structure given a exclude pattern */
-static void make_exclude(struct exclude_list_struct *listp, const char *pattern,
-			 int pat_len, int include)
+/** Build an exclude structure given an exclude pattern. */
+static void make_exclude(struct exclude_list_struct *listp, const char *pat,
+			 unsigned int pat_len, unsigned int mflags)
 {
 	struct exclude_struct *ret;
 	const char *cp;
-	int ex_len;
+	unsigned int ex_len;
 
 	ret = new(struct exclude_struct);
 	if (!ret)
 		out_of_memory("make_exclude");
 
 	memset(ret, 0, sizeof ret[0]);
-	ret->include = include;
 
 	if (exclude_path_prefix)
-		ret->match_flags |= MATCHFLG_ABS_PATH;
-	if (exclude_path_prefix && *pattern == '/')
+		mflags |= MATCHFLG_ABS_PATH;
+	if (exclude_path_prefix && *pat == '/')
 		ex_len = strlen(exclude_path_prefix);
 	else
 		ex_len = 0;
 	ret->pattern = new_array(char, ex_len + pat_len + 1);
 	if (!ret->pattern)
 		out_of_memory("make_exclude");
 	if (ex_len)
 		memcpy(ret->pattern, exclude_path_prefix, ex_len);
-	strlcpy(ret->pattern + ex_len, pattern, pat_len + 1);
+	strlcpy(ret->pattern + ex_len, pat, pat_len + 1);
 	pat_len += ex_len;
 
 	if (strpbrk(ret->pattern, "*[?")) {
-		ret->match_flags |= MATCHFLG_WILD;
+		mflags |= MATCHFLG_WILD;
 		if ((cp = strstr(ret->pattern, "**")) != NULL) {
-			ret->match_flags |= MATCHFLG_WILD2;
+			mflags |= MATCHFLG_WILD2;
 			/* If the pattern starts with **, note that. */
 			if (cp == ret->pattern)
-				ret->match_flags |= MATCHFLG_WILD2_PREFIX;
+				mflags |= MATCHFLG_WILD2_PREFIX;
 		}
 	}
 
 	if (pat_len > 1 && ret->pattern[pat_len-1] == '/') {
 		ret->pattern[pat_len-1] = 0;
-		ret->directory = 1;
+		mflags |= MATCHFLG_DIRECTORY;
 	}
 
 	for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
 		ret->slash_cnt++;
 
+	ret->match_flags = mflags;
+
 	if (!listp->tail)
 		listp->head = listp->tail = ret;
 	else {
 		listp->tail->next = ret;
 		listp->tail = ret;
 	}
@@ -96,66 +97,62 @@
 static void free_exclude(struct exclude_struct *ex)
 {
 	free(ex->pattern);
 	free(ex);
 }
 
-void free_exclude_list(struct exclude_list_struct *listp)
+void clear_exclude_list(struct exclude_list_struct *listp)
 {
 	struct exclude_struct *ent, *next;
 
-	if (verbose > 2) {
-		rprintf(FINFO, "[%s] clearing %sexclude list\n",
-			who_am_i(), listp->debug_type);
-	}
-
 	for (ent = listp->head; ent; ent = next) {
 		next = ent->next;
 		free_exclude(ent);
 	}
 
 	listp->head = listp->tail = NULL;
 }
 
 static int check_one_exclude(char *name, struct exclude_struct *ex,
                              int name_is_dir)
 {
-	char *p;
+	char *p, full_name[MAXPATHLEN];
 	int match_start = 0;
 	char *pattern = ex->pattern;
 
+	if (!*name)
+		return 0;
+
 	/* If the pattern does not have any slashes AND it does not have
 	 * a "**" (which could match a slash), then we just match the
 	 * name portion of the path. */
 	if (!ex->slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
 		if ((p = strrchr(name,'/')) != NULL)
 			name = p+1;
 	}
-	else if ((ex->match_flags & MATCHFLG_ABS_PATH) && *name != '/') {
-		static char full_name[MAXPATHLEN];
-		int plus = curr_dir[1] == '\0'? 1 : 0;
-		pathjoin(full_name, sizeof full_name, curr_dir+plus, name);
+	else if (ex->match_flags & MATCHFLG_ABS_PATH && *name != '/'
+	    && curr_dir[1]) {
+		pathjoin(full_name, sizeof full_name, curr_dir + 1, name);
 		name = full_name;
 	}
 
-	if (!name[0]) return 0;
-
-	if (ex->directory && !name_is_dir) return 0;
+	if (ex->match_flags & MATCHFLG_DIRECTORY && !name_is_dir)
+		return 0;
 
 	if (*pattern == '/') {
 		match_start = 1;
 		pattern++;
 		if (*name == '/')
 			name++;
 	}
 
 	if (ex->match_flags & MATCHFLG_WILD) {
 		/* A non-anchored match with an infix slash and no "**"
 		 * needs to match the last slash_cnt+1 name elements. */
-		if (!match_start && ex->slash_cnt &&
-		    !(ex->match_flags & MATCHFLG_WILD2)) {
+		if (!match_start && ex->slash_cnt
+		    && !(ex->match_flags & MATCHFLG_WILD2)) {
 			int cnt = ex->slash_cnt + 1;
 			for (p = name + strlen(name) - 1; p >= name; p--) {
 				if (*p == '/' && !--cnt)
 					break;
 			}
 			name = p+1;
@@ -203,15 +200,17 @@
 	/* If a trailing slash is present to match only directories,
 	 * then it is stripped out by make_exclude.  So as a special
 	 * case we add it back in here. */
 
 	if (verbose >= 2) {
 		rprintf(FINFO, "[%s] %scluding %s %s because of %spattern %s%s\n",
-			who_am_i(), ent->include ? "in" : "ex",
+			who_am_i(),
+			ent->match_flags & MATCHFLG_INCLUDE ? "in" : "ex",
 			name_is_dir ? "directory" : "file", name, type,
-			ent->pattern, ent->directory ? "/" : "");
+			ent->pattern,
+			ent->match_flags & MATCHFLG_DIRECTORY ? "/" : "");
 	}
 }
 
 
 /*
  * Return -1 if file "name" is defined to be excluded by the specified
@@ -222,105 +221,113 @@
 	struct exclude_struct *ent;
 
 	for (ent = listp->head; ent; ent = ent->next) {
 		if (check_one_exclude(name, ent, name_is_dir)) {
 			report_exclude_result(name, ent, name_is_dir,
 					      listp->debug_type);
-			return ent->include ? 1 : -1;
+			return ent->match_flags & MATCHFLG_INCLUDE ? 1 : -1;
 		}
 	}
 
 	return 0;
 }
 
 
 /* Get the next include/exclude arg from the string.  The token will not
  * be '\0' terminated, so use the returned length to limit the string.
  * Also, be sure to add this length to the returned pointer before passing
- * it back to ask for the next token.  This routine will not parse the +/-
- * prefixes or the "!" token when xflags contains XFLG_WORDS_ONLY.  The
- * *incl_ptr value will be 1 for an include, 0 for an exclude, and -1 for
- * the list-clearing "!" token.
+ * it back to ask for the next token.  This routine parses the +/- prefixes
+ * and the "!" token unless xflags contains XFLG_WORDS_ONLY.  The *flag_ptr
+ * value will also be set to the MATCHFLG_* bits for the current token.
  */
-static const char *get_exclude_tok(const char *p, int *len_ptr, int *incl_ptr,
-				   int xflags)
+static const char *get_exclude_tok(const char *p, unsigned int *len_ptr,
+				   unsigned int *flag_ptr, int xflags)
 {
 	const unsigned char *s = (const unsigned char *)p;
-	int len;
+	unsigned int len, mflags = 0;
 
 	if (xflags & XFLG_WORD_SPLIT) {
 		/* Skip over any initial whitespace. */
 		while (isspace(*s))
 			s++;
 		/* Update for "!" check. */
 		p = (const char *)s;
 	}
 
 	/* Is this a '+' or '-' followed by a space (not whitespace)? */
 	if (!(xflags & XFLG_WORDS_ONLY)
 	    && (*s == '-' || *s == '+') && s[1] == ' ') {
-		*incl_ptr = *s == '+';
+		if (*s == '+')
+			mflags |= MATCHFLG_INCLUDE;
 		s += 2;
-	} else
-		*incl_ptr = xflags & XFLG_DEF_INCLUDE;
+	} else if (xflags & XFLG_DEF_INCLUDE)
+		mflags |= MATCHFLG_INCLUDE;
+	if (xflags & XFLG_DIRECTORY)
+		mflags |= MATCHFLG_DIRECTORY;
 
 	if (xflags & XFLG_WORD_SPLIT) {
 		const unsigned char *cp = s;
 		/* Token ends at whitespace or the end of the string. */
 		while (!isspace(*cp) && *cp != '\0')
 			cp++;
 		len = cp - s;
 	} else
 		len = strlen(s);
 
 	if (*p == '!' && len == 1 && !(xflags & XFLG_WORDS_ONLY))
-		*incl_ptr = -1;
+		mflags |= MATCHFLG_CLEAR_LIST;
 
 	*len_ptr = len;
+	*flag_ptr = mflags;
 	return (const char *)s;
 }
 
 
 void add_exclude(struct exclude_list_struct *listp, const char *pattern,
 		 int xflags)
 {
-	int pat_len, incl;
+	unsigned int pat_len, mflags;
 	const char *cp;
 
 	if (!pattern)
 		return;
 
 	cp = pattern;
 	pat_len = 0;
 	while (1) {
-		cp = get_exclude_tok(cp + pat_len, &pat_len, &incl, xflags);
+		cp = get_exclude_tok(cp + pat_len, &pat_len, &mflags, xflags);
 		if (!pat_len)
 			break;
-		/* If we got the special "!" token, clear the list. */
-		if (incl < 0)
-			free_exclude_list(listp);
-		else {
-			make_exclude(listp, cp, pat_len, incl);
 
+		if (mflags & MATCHFLG_CLEAR_LIST) {
 			if (verbose > 2) {
-				rprintf(FINFO, "[%s] add_exclude(%.*s, %s%s)\n",
-					who_am_i(), pat_len, cp,
-					listp->debug_type,
-					incl ? "include" : "exclude");
+				rprintf(FINFO,
+					"[%s] clearing %sexclude list\n",
+					who_am_i(), listp->debug_type);
 			}
+			clear_exclude_list(listp);
+			continue;
+		}
+
+		make_exclude(listp, cp, pat_len, mflags);
+
+		if (verbose > 2) {
+			rprintf(FINFO, "[%s] add_exclude(%.*s, %s%sclude)\n",
+				who_am_i(), (int)pat_len, cp, listp->debug_type,
+				mflags & MATCHFLG_INCLUDE ? "in" : "ex");
 		}
 	}
 }
 
 
 void add_exclude_file(struct exclude_list_struct *listp, const char *fname,
 		      int xflags)
 {
 	FILE *fp;
-	char line[MAXPATHLEN];
-	char *eob = line + MAXPATHLEN - 1;
+	char line[MAXPATHLEN+3]; /* Room for "x " prefix and trailing slash. */
+	char *eob = line + sizeof line - 1;
 	int word_split = xflags & XFLG_WORD_SPLIT;
 
 	if (!fname || !*fname)
 		return;
 
 	if (*fname != '-' || fname[1])
@@ -337,25 +344,31 @@
 		}
 		return;
 	}
 
 	while (1) {
 		char *s = line;
-		int ch;
+		int ch, overflow = 0;
 		while (1) {
 			if ((ch = getc(fp)) == EOF) {
 				if (ferror(fp) && errno == EINTR)
 					continue;
 				break;
 			}
 			if (word_split && isspace(ch))
 				break;
 			if (eol_nulls? !ch : (ch == '\n' || ch == '\r'))
 				break;
 			if (s < eob)
 				*s++ = ch;
+			else
+				overflow = 1;
+		}
+		if (overflow) {
+			rprintf(FERROR, "discarding over-long exclude: %s...\n", line);
+			s = line;
 		}
 		*s = '\0';
 		/* Skip an empty token and (when line parsing) comments. */
 		if (*line && (word_split || (*line != ';' && *line != '#')))
 			add_exclude(listp, line, xflags);
 		if (ch == EOF)
@@ -380,18 +393,18 @@
 		unsigned int l;
 		char p[MAXPATHLEN+1];
 
 		l = strlcpy(p, ent->pattern, sizeof p);
 		if (l == 0 || l >= MAXPATHLEN)
 			continue;
-		if (ent->directory) {
+		if (ent->match_flags & MATCHFLG_DIRECTORY) {
 			p[l++] = '/';
 			p[l] = '\0';
 		}
 
-		if (ent->include) {
+		if (ent->match_flags & MATCHFLG_INCLUDE) {
 			write_int(f, l + 2);
 			write_buf(f, "+ ", 2);
 		} else if ((*p == '-' || *p == '+') && p[1] == ' ') {
 			write_int(f, l + 2);
 			write_buf(f, "- ", 2);
 		} else
@@ -402,13 +415,13 @@
 	write_int(f, 0);
 }
 
 
 void recv_exclude_list(int f)
 {
-	char line[MAXPATHLEN+1]; /* Allows a trailing slash on a max-len dir */
+	char line[MAXPATHLEN+3]; /* Room for "x " prefix and trailing slash. */
 	unsigned int l;
 
 	while ((l = read_int(f)) != 0) {
 		if (l >= sizeof line)
 			overflow("recv_exclude_list");
 		read_sbuf(f, line, l);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/fileio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/fileio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/fileio.c	2004-01-05 11:57:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/fileio.c	2004-08-03 16:05:29.000000000 +0800
@@ -19,15 +19,16 @@
 
 /*
   File IO utilities used in rsync
   */
 #include "rsync.h"
 
+extern int sparse_files;
+
 static char last_byte;
 static int last_sparse;
-extern int sparse_files;
 
 int sparse_end(int f)
 {
 	if (last_sparse) {
 		do_lseek(f,-1,SEEK_CUR);
 		return (write(f,&last_byte,1) == 1 ? 0 : -1);
@@ -103,15 +105,15 @@
 		int r1;
 		if (sparse_files) {
 			int len1 = MIN(len, SPARSE_WRITE_SIZE);
 			r1 = write_sparse(f, buf, len1);
 		} else {
 			if (!wf_writeBuf) {
-				wf_writeBufSize = MAX_MAP_SIZE;
+				wf_writeBufSize = WRITE_SIZE * 8;
 				wf_writeBufCnt  = 0;
-				wf_writeBuf = new_array(char, MAX_MAP_SIZE);
+				wf_writeBuf = new_array(char, wf_writeBufSize);
 				if (!wf_writeBuf)
 					out_of_memory("write_file");
 			}
 			r1 = MIN(len, wf_writeBufSize - wf_writeBufCnt);
 			if (r1) {
 				memcpy(wf_writeBuf + wf_writeBufCnt, buf, r1);
@@ -122,46 +124,48 @@
 					return -1;
 				if (!r1 && len)
 					continue;
 			}
 		}
 		if (r1 <= 0) {
-			if (ret > 0) return ret;
+			if (ret > 0)
+				return ret;
 			return r1;
 		}
 		len -= r1;
 		buf += r1;
 		ret += r1;
 	}
 	return ret;
 }
 
 
-
-/* this provides functionality somewhat similar to mmap() but using
-   read(). It gives sliding window access to a file. mmap() is not
-   used because of the possibility of another program (such as a
-   mailer) truncating the file thus giving us a SIGBUS */
-struct map_struct *map_file(int fd,OFF_T len)
+/* This provides functionality somewhat similar to mmap() but using read().
+ * It gives sliding window access to a file.  mmap() is not used because of
+ * the possibility of another program (such as a mailer) truncating the
+ * file thus giving us a SIGBUS. */
+struct map_struct *map_file(int fd, OFF_T len, OFF_T map_size,
+			    size_t block_size)
 {
 	struct map_struct *map;
-	map = new(struct map_struct);
-	if (!map) out_of_memory("map_file");
 
+	if (!(map = new(struct map_struct)))
+		out_of_memory("map_file");
+
+	if (block_size && (map_size % block_size))
+		map_size += block_size - (map_size % block_size);
+
+	memset(map, 0, sizeof map[0]);
 	map->fd = fd;
 	map->file_size = len;
-	map->p = NULL;
-	map->p_size = 0;
-	map->p_offset = 0;
-	map->p_fd_offset = 0;
-	map->p_len = 0;
-	map->status = 0;
+	map->def_window_size = map_size;
 
 	return map;
 }
 
+
 /* slide the read window in the file */
 char *map_ptr(struct map_struct *map,OFF_T offset,int len)
 {
 	int nread;
 	OFF_T window_start, read_start;
 	int window_size, read_size, read_offset;
@@ -163,15 +167,14 @@
 char *map_ptr(struct map_struct *map,OFF_T offset,int len)
 {
 	int nread;
 	OFF_T window_start, read_start;
 	int window_size, read_size, read_offset;
 
-	if (len == 0) {
+	if (len == 0)
 		return NULL;
-	}
 
 	/* can't go beyond the end of file */
 	if (len > (map->file_size - offset)) {
 		len = map->file_size - offset;
 	}
 
@@ -178,32 +181,27 @@
 	/* in most cases the region will already be available */
 	if (offset >= map->p_offset &&
 	    offset+len <= map->p_offset+map->p_len) {
 		return (map->p + (offset - map->p_offset));
 	}
 
-
 	/* nope, we are going to have to do a read. Work out our desired window */
-	if (offset > 2*CHUNK_SIZE) {
-		window_start = offset - 2*CHUNK_SIZE;
-		window_start &= ~((OFF_T)(CHUNK_SIZE-1)); /* assumes power of 2 */
-	} else {
-		window_start = 0;
-	}
-	window_size = MAX_MAP_SIZE;
+	window_start = offset;
+	window_size = map->def_window_size;
 	if (window_start + window_size > map->file_size) {
 		window_size = map->file_size - window_start;
 	}
 	if (offset + len > window_start + window_size) {
 		window_size = (offset+len) - window_start;
 	}
 
 	/* make sure we have allocated enough memory for the window */
 	if (window_size > map->p_size) {
 		map->p = realloc_array(map->p, char, window_size);
-		if (!map->p) out_of_memory("map_ptr");
+		if (!map->p)
+			out_of_memory("map_ptr");
 		map->p_size = window_size;
 	}
 
 	/* now try to avoid re-reading any bytes by reusing any bytes from the previous
 	   buffer. */
 	if (window_start >= map->p_offset &&
@@ -256,12 +254,11 @@
 
 	if (map->p) {
 		free(map->p);
 		map->p = NULL;
 	}
 	ret = map->status;
-	memset(map, 0, sizeof(*map));
+	memset(map, 0, sizeof map[0]);
 	free(map);
 
 	return ret;
 }
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/flist.c	2004-04-30 03:37:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/flist.c	2004-09-21 17:24:02.000000000 +0800
@@ -31,12 +31,13 @@
 
 extern int verbose;
 extern int do_progress;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
+extern int am_sender;
 extern int always_checksum;
 extern int module_id;
 extern int ignore_errors;
 extern int numeric_ids;
 
 extern int cvs_exclude;
@@ -44,37 +45,38 @@
 extern int recurse;
 extern char curr_dir[MAXPATHLEN];
 extern char *files_from;
 extern int filesfrom_fd;
 
 extern int one_file_system;
+extern int keep_dirlinks;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_perms;
 extern int preserve_devices;
 extern int preserve_uid;
 extern int preserve_gid;
-extern int preserve_times;
 extern int relative_paths;
 extern int implied_dirs;
 extern int copy_links;
 extern int copy_unsafe_links;
 extern int protocol_version;
 extern int sanitize_paths;
-
-extern int read_batch;
-extern int write_batch;
+extern int delete_excluded;
+extern int orig_umask;
+extern int list_only;
 
 extern struct exclude_list_struct exclude_list;
 extern struct exclude_list_struct server_exclude_list;
 extern struct exclude_list_struct local_exclude_list;
 
 int io_error;
 
 static char empty_sum[MD4_SUM_LENGTH];
 static unsigned int file_struct_len;
+static struct file_list *received_flist;
 
 static void clean_flist(struct file_list *flist, int strip_root, int no_dups);
 static void output_flist(struct file_list *flist);
 
 void init_flist(void)
 {
@@ -90,13 +92,13 @@
 	return verbose && (recurse || files_from) && !am_server;
 }
 
 static void start_filelist_progress(char *kind)
 {
 	rprintf(FINFO, "%s ... ", kind);
-	if ((verbose > 1) || do_progress)
+	if (verbose > 1 || do_progress)
 		rprintf(FINFO, "\n");
 	rflush(FINFO);
 }
 
 
 static void emit_filelist_progress(const struct file_list *flist)
@@ -104,13 +106,13 @@
 	rprintf(FINFO, " %d files...\r", flist->count);
 }
 
 
 static void maybe_emit_filelist_progress(const struct file_list *flist)
 {
-	if (do_progress && show_filelist_p() && ((flist->count % 100) == 0))
+	if (do_progress && show_filelist_p() && (flist->count % 100) == 0)
 		emit_filelist_progress(flist);
 }
 
 
 static void finish_filelist_progress(const struct file_list *flist)
 {
@@ -129,30 +131,33 @@
 
 
 static void list_file_entry(struct file_struct *f)
 {
 	char perms[11];
 
-	if (!f->basename)
+	if (!f->basename) {
 		/* this can happen if duplicate names were removed */
 		return;
+	}
 
 	permstring(perms, f->mode);
 
 #if SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(f->mode)) {
 		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
 			perms,
-			(double) f->length, timestring(f->modtime),
+			(double)f->length, timestring(f->modtime),
 			f_name(f), f->u.link);
 	} else
 #endif
+	{
 		rprintf(FINFO, "%s %11.0f %s %s\n",
 			perms,
-			(double) f->length, timestring(f->modtime),
+			(double)f->length, timestring(f->modtime),
 			f_name(f));
+	}
 }
 
 
 /**
  * Stat either a symlink or its referent, depending on the settings of
  * copy_links, copy_unsafe_links, etc.
@@ -164,21 +169,21 @@
  * @post If @p path is a symlink, then @p linkbuf (of size @c
  * MAXPATHLEN) contains the symlink target.
  *
  * @post @p buffer contains information about the link or the
  * referrent as appropriate, if they exist.
  **/
-int readlink_stat(const char *path, STRUCT_STAT *buffer, char *linkbuf)
+static int readlink_stat(const char *path, STRUCT_STAT *buffer, char *linkbuf)
 {
 #if SUPPORT_LINKS
 	if (copy_links)
 		return do_stat(path, buffer);
-	if (do_lstat(path, buffer) == -1)
+	if (link_stat(path, buffer, 0) < 0)
 		return -1;
 	if (S_ISLNK(buffer->st_mode)) {
-		int l = readlink((char *) path, linkbuf, MAXPATHLEN - 1);
+		int l = readlink((char *)path, linkbuf, MAXPATHLEN - 1);
 		if (l == -1)
 			return -1;
 		linkbuf[l] = 0;
 		if (copy_unsafe_links && unsafe_symlink(linkbuf, path)) {
 			if (verbose > 1) {
 				rprintf(FINFO,"copying unsafe symlink \"%s\" -> \"%s\"\n",
@@ -190,18 +195,25 @@
 	return 0;
 #else
 	return do_stat(path, buffer);
 #endif
 }
 
-int link_stat(const char *path, STRUCT_STAT * buffer)
+int link_stat(const char *path, STRUCT_STAT *buffer, int follow_dirlinks)
 {
 #if SUPPORT_LINKS
 	if (copy_links)
 		return do_stat(path, buffer);
-	return do_lstat(path, buffer);
+	if (do_lstat(path, buffer) < 0)
+		return -1;
+	if (follow_dirlinks && S_ISLNK(buffer->st_mode)) {
+		STRUCT_STAT st;
+		if (do_stat(path, &st) == 0 && S_ISDIR(st.st_mode))
+			*buffer = st;
+	}
+	return 0;
 #else
 	return do_stat(path, buffer);
 #endif
 }
 
 /*
@@ -245,32 +257,32 @@
 /* used by the one_file_system code */
 static dev_t filesystem_dev;
 
 static void set_filesystem(char *fname)
 {
 	STRUCT_STAT st;
-	if (link_stat(fname, &st) != 0)
+	if (do_stat(fname, &st) != 0)
 		return;
 	filesystem_dev = st.st_dev;
 }
 
 
 static int to_wire_mode(mode_t mode)
 {
 #if SUPPORT_LINKS
 	if (S_ISLNK(mode) && (_S_IFLNK != 0120000))
 		return (mode & ~(_S_IFMT)) | 0120000;
 #endif
-	return (int) mode;
+	return (int)mode;
 }
 
 static mode_t from_wire_mode(int mode)
 {
 	if ((mode & (_S_IFMT)) == 0120000 && (_S_IFLNK != 0120000))
 		return (mode & ~(_S_IFMT)) | _S_IFLNK;
-	return (mode_t) mode;
+	return (mode_t)mode;
 }
 
 
 static void send_directory(int f, struct file_list *flist, char *dir);
 
 static char *flist_dir;
@@ -280,13 +292,13 @@
 /**
  * Make sure @p flist is big enough to hold at least @p flist->count
  * entries.
  **/
 void flist_expand(struct file_list *flist)
 {
-	void *new_ptr;
+	struct file_struct **new_ptr;
 
 	if (flist->count < flist->malloced)
 		return;
 
 	if (flist->malloced < FLIST_START)
 		flist->malloced = FLIST_START;
@@ -299,27 +311,23 @@
 	 * In case count jumped or we are starting the list
 	 * with a known size just set it.
 	 */
 	if (flist->malloced < flist->count)
 		flist->malloced = flist->count;
 
-	if (flist->files) {
-		new_ptr = realloc_array(flist->files,
-		    struct file_struct *, flist->malloced);
-	} else {
-		new_ptr = new_array(struct file_struct *, flist->malloced);
-	}
+	new_ptr = realloc_array(flist->files, struct file_struct *,
+				flist->malloced);
 
 	if (verbose >= 2) {
 		rprintf(FINFO, "[%s] expand file_list to %.0f bytes, did%s move\n",
 		    who_am_i(),
-		    (double) sizeof flist->files[0] * flist->malloced,
+		    (double)sizeof flist->files[0] * flist->malloced,
 		    (new_ptr == flist->files) ? " not" : "");
 	}
 
-	flist->files = (struct file_struct **) new_ptr;
+	flist->files = new_ptr;
 
 	if (!flist->files)
 		out_of_memory("flist_expand");
 }
 
 void send_file_entry(struct file_struct *file, int f, unsigned short base_flags)
@@ -330,13 +338,13 @@
 	static uint64 dev;
 	static dev_t rdev;
 	static uint32 rdev_major;
 	static uid_t uid;
 	static gid_t gid;
 	static char lastname[MAXPATHLEN];
-	char *fname, fbuf[MAXPATHLEN];
+	char fname[MAXPATHLEN];
 	int l1, l2;
 
 	if (f == -1)
 		return;
 
 	if (!file) {
@@ -348,13 +356,13 @@
 		*lastname = '\0';
 		return;
 	}
 
 	io_write_phase = "send_file_entry";
 
-	fname = f_name_to(file, fbuf);
+	f_name_to(file, fname);
 
 	flags = base_flags;
 
 	if (file->mode == mode)
 		flags |= XMIT_SAME_MODE;
 	else
@@ -512,23 +520,23 @@
 	io_write_phase = "unknown";
 }
 
 
 
 void receive_file_entry(struct file_struct **fptr, unsigned short flags,
-    struct file_list *flist, int f)
+			struct file_list *flist, int f)
 {
 	static time_t modtime;
 	static mode_t mode;
 	static uint64 dev;
 	static dev_t rdev;
 	static uint32 rdev_major;
 	static uid_t uid;
 	static gid_t gid;
 	static char lastname[MAXPATHLEN], *lastdir;
-	static int lastdir_len = -1;
+	static int lastdir_depth, lastdir_len = -1;
 	char thisname[MAXPATHLEN];
 	unsigned int l1 = 0, l2 = 0;
 	int alloc_len, basename_len, dirname_len, linkname_len, sum_len;
 	OFF_T file_length;
 	char *basename, *dirname, *bp;
 	struct file_struct *file;
@@ -536,12 +544,13 @@
 	if (!fptr) {
 		modtime = 0, mode = 0;
 		dev = 0, rdev = makedev(0, 0);
 		rdev_major = 0;
 		uid = 0, gid = 0;
 		*lastname = '\0';
+		lastdir_len = -1;
 		return;
 	}
 
 	if (flags & XMIT_SAME_NAME)
 		l1 = read_byte(f);
 
@@ -560,16 +569,16 @@
 	strlcpy(thisname, lastname, l1 + 1);
 	read_sbuf(f, &thisname[l1], l2);
 	thisname[l1 + l2] = 0;
 
 	strlcpy(lastname, thisname, MAXPATHLEN);
 
-	clean_fname(thisname);
+	clean_fname(thisname, 0);
 
 	if (sanitize_paths)
-		sanitize_path(thisname, NULL);
+		sanitize_path(thisname, thisname, "", 0);
 
 	if ((basename = strrchr(thisname, '/')) != NULL) {
 		dirname_len = ++basename - thisname; /* counts future '\0' */
 		if (lastdir_len == dirname_len - 1
 		    && strncmp(thisname, lastdir, lastdir_len) == 0) {
 			dirname = lastdir;
@@ -646,12 +655,14 @@
 	if (dirname_len) {
 		file->dirname = lastdir = bp;
 		lastdir_len = dirname_len - 1;
 		memcpy(bp, dirname, dirname_len - 1);
 		bp += dirname_len;
 		bp[-1] = '\0';
+		if (sanitize_paths)
+			lastdir_depth = count_dir_elements(lastdir);
 	} else if (dirname)
 		file->dirname = dirname;
 
 	file->basename = bp;
 	memcpy(bp, basename, basename_len);
 	bp += basename_len;
@@ -661,13 +672,13 @@
 
 #if SUPPORT_LINKS
 	if (linkname_len) {
 		file->u.link = bp;
 		read_sbuf(f, bp, linkname_len - 1);
 		if (sanitize_paths)
-			sanitize_path(bp, lastdir);
+			sanitize_path(bp, bp, "", lastdir_depth);
 		bp += linkname_len;
 	}
 #endif
 
 #if SUPPORT_HARD_LINKS
 	if (preserve_hard_links && protocol_version < 28 && S_ISREG(mode))
@@ -705,13 +716,12 @@
 			read_buf(f, sum,
 			    protocol_version < 21 ? 2 : MD4_SUM_LENGTH);
 		}
 	}
 
 	if (!preserve_perms) {
-		extern int orig_umask;
 		/* set an appropriate set of permissions based on original
 		 * permissions and umask. This emulates what GNU cp does */
 		file->mode &= ~orig_umask;
 	}
 }
 
@@ -728,61 +738,67 @@
  * stat()ing the file in some circumstances, which has a certain cost.
  * We are called immediately after doing readdir(), and so we may
  * already know the d_type of the file.  We could for example avoid
  * statting directories if we're not recursing, but this is not a very
  * important case.  Some systems may not have d_type.
  **/
-struct file_struct *make_file(char *fname,
-    struct file_list *flist, int exclude_level)
+struct file_struct *make_file(char *fname, struct file_list *flist,
+			      int exclude_level)
 {
 	static char *lastdir;
 	static int lastdir_len = -1;
 	struct file_struct *file;
 	STRUCT_STAT st;
 	char sum[SUM_LENGTH];
 	char thisname[MAXPATHLEN];
 	char linkname[MAXPATHLEN];
 	int alloc_len, basename_len, dirname_len, linkname_len, sum_len;
 	char *basename, *dirname, *bp;
 	unsigned short flags = 0;
 
-	if (!flist)	/* lastdir isn't valid if flist is NULL */
+	if (!flist || !flist->count)	/* Ignore lastdir when invalid. */
 		lastdir_len = -1;
 
 	if (strlcpy(thisname, fname, sizeof thisname)
 	    >= sizeof thisname - flist_dir_len) {
 		rprintf(FINFO, "skipping overly long name: %s\n", fname);
 		return NULL;
 	}
-	clean_fname(thisname);
+	clean_fname(thisname, 0);
 	if (sanitize_paths)
-		sanitize_path(thisname, NULL);
+		sanitize_path(thisname, thisname, "", 0);
 
 	memset(sum, 0, SUM_LENGTH);
 
 	if (readlink_stat(thisname, &st, linkname) != 0) {
 		int save_errno = errno;
-		if (errno == ENOENT) {
-			enum logcode c = am_daemon && protocol_version < 28
-			    ? FERROR : FINFO;
-			/* either symlink pointing nowhere or file that
-			 * was removed during rsync run; see if excluded
-			 * before reporting an error */
-			if (exclude_level != NO_EXCLUDES
-			    && check_exclude_file(thisname, 0, exclude_level)) {
-				/* file is excluded anyway, ignore silently */
-				return NULL;
+		/* See if file is excluded before reporting an error. */
+		if (exclude_level != NO_EXCLUDES
+		    && check_exclude_file(thisname, 0, exclude_level))
+			return NULL;
+		if (save_errno == ENOENT) {
+#if SUPPORT_LINKS
+			/* Avoid "vanished" error if symlink points nowhere. */
+			if (copy_links && do_lstat(thisname, &st) == 0
+			    && S_ISLNK(st.st_mode)) {
+				io_error |= IOERR_GENERAL;
+				rprintf(FERROR, "symlink has no referent: %s\n",
+					full_fname(thisname));
+			} else
+#endif
+			{
+				enum logcode c = am_daemon && protocol_version < 28
+				    ? FERROR : FINFO;
+				io_error |= IOERR_VANISHED;
+				rprintf(c, "file has vanished: %s\n",
+					full_fname(thisname));
 			}
-			io_error |= IOERR_VANISHED;
-			rprintf(c, "file has vanished: %s\n",
-			    full_fname(thisname));
-		}
-		else {
+		} else {
 			io_error |= IOERR_GENERAL;
-			rprintf(FERROR, "readlink %s failed: %s\n",
-			    full_fname(thisname), strerror(save_errno));
+			rsyserr(FERROR, save_errno, "readlink %s failed",
+				full_fname(thisname));
 		}
 		return NULL;
 	}
 
 	/* backup.c calls us with exclude_level set to NO_EXCLUDES. */
 	if (exclude_level == NO_EXCLUDES)
@@ -908,51 +924,71 @@
 		file_checksum(thisname, bp, st.st_size);
 		/*bp += sum_len;*/
 	}
 
 	file->basedir = flist_dir;
 
+	/* This code is only used by the receiver when it is building
+	 * a list of files for a delete pass. */
+	if (keep_dirlinks && linkname_len && flist) {
+		STRUCT_STAT st2;
+		int i = flist_find(received_flist, file);
+		if (i >= 0 && S_ISDIR(received_flist->files[i]->mode)
+		    && do_stat(thisname, &st2) == 0 && S_ISDIR(st2.st_mode)) {
+			file->modtime = st2.st_mtime;
+			file->length = st2.st_size;
+			file->mode = st2.st_mode;
+			file->uid = st2.st_uid;
+			file->gid = st2.st_gid;
+			file->u.link = NULL;
+			if (file->link_u.idev) {
+				pool_free(flist->hlink_pool, 0, file->link_u.idev);
+				file->link_u.idev = NULL;
+			}
+		}
+	}
+
 	if (!S_ISDIR(st.st_mode))
 		stats.total_size += st.st_size;
 
 	return file;
 }
 
 
 void send_file_name(int f, struct file_list *flist, char *fname,
 		    int recursive, unsigned short base_flags)
 {
 	struct file_struct *file;
 	char fbuf[MAXPATHLEN];
-	extern int delete_excluded;
 
 	/* f is set to -1 when calculating deletion file list */
 	file = make_file(fname, flist,
 	    f == -1 && delete_excluded? SERVER_EXCLUDES : ALL_EXCLUDES);
 
 	if (!file)
 		return;
 
 	maybe_emit_filelist_progress(flist);
 
 	flist_expand(flist);
 
-	if (write_batch)
-		file->flags |= FLAG_TOP_DIR;
-
 	if (file->basename[0]) {
 		flist->files[flist->count++] = file;
 		send_file_entry(file, f, base_flags);
 	}
 
 	if (recursive && S_ISDIR(file->mode)
 	    && !(file->flags & FLAG_MOUNT_POINT)) {
 		struct exclude_list_struct last_list = local_exclude_list;
 		local_exclude_list.head = local_exclude_list.tail = NULL;
 		send_directory(f, flist, f_name_to(file, fbuf));
-		free_exclude_list(&local_exclude_list);
+		if (verbose > 2) {
+			rprintf(FINFO, "[%s] popping %sexclude list\n",
+				who_am_i(), local_exclude_list.debug_type);
+		}
+		clear_exclude_list(&local_exclude_list);
 		local_exclude_list = last_list;
 	}
 }
 
 
 static void send_directory(int f, struct file_list *flist, char *dir)
@@ -963,14 +999,13 @@
 	unsigned int offset;
 	char *p;
 
 	d = opendir(dir);
 	if (!d) {
 		io_error |= IOERR_GENERAL;
-		rprintf(FERROR, "opendir %s failed: %s\n",
-			full_fname(dir), strerror(errno));
+		rsyserr(FERROR, errno, "opendir %s failed", full_fname(dir));
 		return;
 	}
 
 	offset = strlcpy(fname, dir, MAXPATHLEN);
 	p = fname + offset;
 	if (offset >= MAXPATHLEN || p[-1] != '/') {
@@ -1011,21 +1046,22 @@
 				"cannot send long-named file %s\n",
 				full_fname(fname));
 		}
 	}
 	if (errno) {
 		io_error |= IOERR_GENERAL;
-		rprintf(FERROR, "readdir(%s): (%d) %s\n",
-			dir, errno, strerror(errno));
+		rsyserr(FERROR, errno, "readdir(%s)", dir);
 	}
 
 	closedir(d);
 }
 
 
 /**
+ * This function is normally called by the sender, but the receiver also
+ * uses it to construct its own file list if --delete has been specified.
  * The delete_files() function in receiver.c sets f to -1 so that we just
  * construct the file list in memory without sending it over the wire.  It
  * also has the side-effect of ignoring user-excludes if delete_excluded
  * is set (so that the delete list includes user-excluded files).
  **/
 struct file_list *send_file_list(int f, int argc, char *argv[])
@@ -1044,17 +1080,17 @@
 	start_write = stats.total_written;
 
 	flist = flist_new(f == -1 ? WITHOUT_HLINK : WITH_HLINK,
 	    "send_file_list");
 
 	if (f != -1) {
-		io_start_buffering_out(f);
+		io_start_buffering_out();
 		if (filesfrom_fd >= 0) {
 			if (argv[0] && !push_dir(argv[0])) {
-				rprintf(FERROR, "push_dir %s failed: %s\n",
-					full_fname(argv[0]), strerror(errno));
+				rsyserr(FERROR, errno, "push_dir %s failed",
+					full_fname(argv[0]));
 				exit_cleanup(RERR_FILESELECT);
 			}
 			use_ff_fd = 1;
 		}
 	}
 
@@ -1062,19 +1098,19 @@
 		char fname2[MAXPATHLEN];
 		char *fname = fname2;
 
 		if (use_ff_fd) {
 			if (read_filesfrom_line(filesfrom_fd, fname) == 0)
 				break;
-			sanitize_path(fname, NULL);
+			sanitize_path(fname, fname, "", 0);
 		} else {
 			if (argc-- == 0)
 				break;
 			strlcpy(fname, *argv++, MAXPATHLEN);
 			if (sanitize_paths)
-				sanitize_path(fname, NULL);
+				sanitize_path(fname, fname, "", 0);
 		}
 
 		l = strlen(fname);
 		if (fname[l - 1] == '/') {
 			if (l == 2 && fname[0] == '.') {
 				/* Turn "./" into just "." rather than "./." */
@@ -1082,17 +1118,17 @@
 			} else if (l < MAXPATHLEN) {
 				fname[l++] = '.';
 				fname[l] = '\0';
 			}
 		}
 
-		if (link_stat(fname, &st) != 0) {
+		if (link_stat(fname, &st, keep_dirlinks) != 0) {
 			if (f != -1) {
 				io_error |= IOERR_GENERAL;
-				rprintf(FERROR, "link_stat %s failed: %s\n",
-					full_fname(fname), strerror(errno));
+				rsyserr(FERROR, errno, "link_stat %s failed",
+					full_fname(fname));
 			}
 			continue;
 		}
 
 		if (S_ISDIR(st.st_mode) && !recurse && !files_from) {
 			rprintf(FINFO, "skipping directory %s\n", fname);
@@ -1155,14 +1191,14 @@
 			static int lastdir_len;
 
 			strcpy(olddir, curr_dir); /* can't overflow */
 
 			if (!push_dir(dir)) {
 				io_error |= IOERR_GENERAL;
-				rprintf(FERROR, "push_dir %s failed: %s\n",
-					full_fname(dir), strerror(errno));
+				rsyserr(FERROR, errno, "push_dir %s failed",
+					full_fname(dir));
 				continue;
 			}
 
 			if (lastdir && strcmp(lastdir, dir) == 0) {
 				flist_dir = lastdir;
 				flist_dir_len = lastdir_len;
@@ -1178,14 +1214,14 @@
 		send_file_name(f, flist, fname, recurse, XMIT_TOP_DIR);
 
 		if (olddir[0]) {
 			flist_dir = NULL;
 			flist_dir_len = 0;
 			if (!pop_dir(olddir)) {
-				rprintf(FERROR, "pop_dir %s failed: %s\n",
-					full_fname(dir), strerror(errno));
+				rsyserr(FERROR, errno, "pop_dir %s failed",
+					full_fname(dir));
 				exit_cleanup(RERR_FILESELECT);
 			}
 		}
 	}
 
 	if (f != -1) {
@@ -1210,14 +1246,12 @@
 		/* send the io_error flag */
 		write_int(f, lp_ignore_errors(module_id) ? 0 : io_error);
 
 		io_end_buffering();
 		stats.flist_size = stats.total_written - start_write;
 		stats.num_files = flist->count;
-		if (write_batch)
-			write_batch_flist_info(flist->count, flist->files);
 	}
 
 	if (verbose > 3)
 		output_flist(flist);
 
 	if (verbose > 2)
@@ -1229,20 +1263,20 @@
 
 struct file_list *recv_file_list(int f)
 {
 	struct file_list *flist;
 	unsigned short flags;
 	int64 start_read;
-	extern int list_only;
 
 	if (show_filelist_p())
 		start_filelist_progress("receiving file list");
 
 	start_read = stats.total_read;
 
 	flist = flist_new(WITH_HLINK, "recv_file_list");
+	received_flist = flist;
 
 	flist->count = 0;
 	flist->malloced = 1000;
 	flist->files = new_array(struct file_struct *, flist->malloced);
 	if (!flist->files)
 		goto oom;
@@ -1281,19 +1315,17 @@
 
 	if (f != -1) {
 		/* Now send the uid/gid list. This was introduced in
 		 * protocol version 15 */
 		recv_uid_list(f, flist);
 
-		if (!read_batch) {
-			/* Recv the io_error flag */
-			if (lp_ignore_errors(module_id) || ignore_errors)
-				read_int(f);
-			else
-				io_error |= read_int(f);
-		}
+		/* Recv the io_error flag */
+		if (lp_ignore_errors(module_id) || ignore_errors)
+			read_int(f);
+		else
+			io_error |= read_int(f);
 	}
 
 	if (verbose > 3)
 		output_flist(flist);
 
 	if (list_only) {
@@ -1419,13 +1451,13 @@
 	int i, prev_i = 0;
 
 	if (!flist || flist->count == 0)
 		return;
 
 	qsort(flist->files, flist->count,
-	    sizeof flist->files[0], (int (*)()) file_compare);
+	    sizeof flist->files[0], (int (*)())file_compare);
 
 	for (i = no_dups? 0 : flist->count; i < flist->count; i++) {
 		if (flist->files[i]->basename) {
 			prev_i = i;
 			break;
 		}
@@ -1475,24 +1507,24 @@
 	char uidbuf[16], gidbuf[16];
 	struct file_struct *file;
 	int i;
 
 	for (i = 0; i < flist->count; i++) {
 		file = flist->files[i];
-		if (am_root && preserve_uid)
+		if ((am_root || am_sender) && preserve_uid)
 			sprintf(uidbuf, " uid=%ld", (long)file->uid);
 		else
 			*uidbuf = '\0';
 		if (preserve_gid && file->gid != GID_NONE)
 			sprintf(gidbuf, " gid=%ld", (long)file->gid);
 		else
 			*gidbuf = '\0';
 		rprintf(FINFO, "[%s] i=%d %s %s %s mode=0%o len=%.0f%s%s\n",
 			who_am_i(), i, NS(file->basedir), NS(file->dirname),
-			NS(file->basename), (int) file->mode,
-			(double) file->length, uidbuf, gidbuf);
+			NS(file->basename), (int)file->mode,
+			(double)file->length, uidbuf, gidbuf);
 	}
 }
 
 
 enum fnc_state { fnc_DIR, fnc_SLASH, fnc_BASE };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/generator.c	2004-04-16 00:55:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/generator.c	2004-09-21 03:47:59.000000000 +0800
@@ -23,44 +23,50 @@
 
 #include "rsync.h"
 
 extern int verbose;
 extern int dry_run;
 extern int relative_paths;
+extern int keep_dirlinks;
 extern int preserve_links;
 extern int am_root;
 extern int preserve_devices;
 extern int preserve_hard_links;
 extern int preserve_perms;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int update_only;
 extern int opt_ignore_existing;
+extern int inplace;
+extern int make_backups;
 extern int csum_length;
 extern int ignore_times;
 extern int size_only;
 extern int io_timeout;
 extern int protocol_version;
 extern int always_checksum;
+extern char *partial_dir;
 extern char *compare_dest;
 extern int link_dest;
 extern int whole_file;
 extern int local_server;
-extern int write_batch;
 extern int list_only;
+extern int read_batch;
 extern int only_existing;
 extern int orig_umask;
 extern int safe_symlinks;
+extern unsigned int block_size;
+
+extern struct exclude_list_struct server_exclude_list;
 
 
 /* choose whether to skip a particular file */
 static int skip_file(char *fname, struct file_struct *file, STRUCT_STAT *st)
 {
-	if (st->st_size != file->length) {
+	if (st->st_size != file->length)
 		return 0;
-	}
 	if (link_dest) {
 		if (preserve_perms
 		    && (st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS))
 			return 0;
 
 		if (am_root && preserve_uid && st->st_uid != file->uid)
@@ -72,35 +78,24 @@
 	}
 
 	/* if always checksum is set then we use the checksum instead
 	   of the file time to determine whether to sync */
 	if (always_checksum && S_ISREG(st->st_mode)) {
 		char sum[MD4_SUM_LENGTH];
-		char fnamecmpdest[MAXPATHLEN];
-
-		if (compare_dest != NULL) {
-			if (access(fname, 0) != 0) {
-				pathjoin(fnamecmpdest, sizeof fnamecmpdest,
-					 compare_dest, fname);
-				fname = fnamecmpdest;
-			}
-		}
 		file_checksum(fname,sum,st->st_size);
 		return memcmp(sum, file->u.sum, protocol_version < 21 ? 2
 							: MD4_SUM_LENGTH) == 0;
 	}
 
-	if (size_only) {
+	if (size_only)
 		return 1;
-	}
 
-	if (ignore_times) {
+	if (ignore_times)
 		return 0;
-	}
 
-	return (cmp_modtime(st->st_mtime,file->modtime) == 0);
+	return cmp_modtime(st->st_mtime, file->modtime) == 0;
 }
 
 
 /*
  * NULL sum_struct means we have no checksums
  */
@@ -115,17 +110,17 @@
 	write_int(f, sum->blength);
 	if (protocol_version >= 27)
 		write_int(f, sum->s2length);
 	write_int(f, sum->remainder);
 }
 
-/* 
+/*
  * set (initialize) the size entries in the per-file sum_struct
- * calulating dynamic block ans checksum sizes.
+ * calculating dynamic block and checksum sizes.
  *
- * This is only called from generate_and_send_sums() but is a seperate
+ * This is only called from generate_and_send_sums() but is a separate
  * function to encapsulate the logic.
  *
  * The block size is a rounded square root of file length.
  *
  * The checksum size is determined according to:
  *     blocksum_bits = BLOCKSUM_EXP + 2*log2(file_len) - log2(block_len)
@@ -135,13 +130,12 @@
  *
  * This might be made one of several selectable heuristics.
  */
 
 static void sum_sizes_sqroot(struct sum_struct *sum, uint64 len)
 {
-	extern unsigned int block_size;
 	unsigned int blength;
 	int s2length;
 	uint32 c;
 	uint64 l;
 
 	if (block_size) {
@@ -197,52 +191,43 @@
 		rprintf(FINFO, "count=%.0f rem=%u blength=%u s2length=%d flength=%.0f\n",
 			(double)sum->count, sum->remainder, sum->blength,
 			sum->s2length, (double)sum->flength);
 	}
 }
 
-/**
- * Perhaps we want to just send an empty checksum set for this file,
- * which will force the whole thing to be literally transferred.
- *
- * When do we do this?  If the user's explicitly said they
- * want the whole thing, or if { they haven't explicitly
- * requested a delta, and it's local but not batch mode.}
- *
- * Whew. */
-static BOOL disable_deltas_p(void)
-{
-	if (whole_file > 0)
-		return True;
-	if (whole_file == 0 || write_batch)
-		return False;
-	return local_server;
-}
-
 
 /*
  * Generate and send a stream of signatures/checksums that describe a buffer
  *
  * Generate approximately one checksum every block_len bytes.
  */
-static void generate_and_send_sums(struct map_struct *buf, size_t len, int f_out)
+static void generate_and_send_sums(int fd, OFF_T len, int f_out, int f_copy)
 {
 	size_t i;
+	struct map_struct *mapbuf;
 	struct sum_struct sum;
 	OFF_T offset = 0;
 
 	sum_sizes_sqroot(&sum, len);
 
+	if (len > 0)
+		mapbuf = map_file(fd, len, MAX_MAP_SIZE, sum.blength);
+	else
+		mapbuf = NULL;
+
 	write_sum_head(f_out, &sum);
 
 	for (i = 0; i < sum.count; i++) {
 		unsigned int n1 = MIN(len, sum.blength);
-		char *map = map_ptr(buf, offset, n1);
+		char *map = map_ptr(mapbuf, offset, n1);
 		uint32 sum1 = get_checksum1(map, n1);
 		char sum2[SUM_LENGTH];
 
+		if (f_copy >= 0)
+			full_write(f_copy, map, n1);
+
 		get_checksum2(map, n1, sum2);
 
 		if (verbose > 3) {
 			rprintf(FINFO,
 				"chunk[%.0f] offset=%.0f len=%u sum1=%08lx\n",
 				(double)i, (double)offset, n1,
@@ -250,50 +235,73 @@
 		}
 		write_int(f_out, sum1);
 		write_buf(f_out, sum2, sum.s2length);
 		len -= n1;
 		offset += n1;
 	}
+
+	if (mapbuf)
+		unmap_file(mapbuf);
 }
 
 
 
-/**
+/*
  * Acts on file number @p i from @p flist, whose name is @p fname.
  *
  * First fixes up permissions, then generates checksums for the file.
  *
  * @note This comment was added later by mbp who was trying to work it
  * out.  It might be wrong.
- **/
-void recv_generator(char *fname, struct file_struct *file, int i, int f_out)
+ */
+static void recv_generator(char *fname, struct file_struct *file, int i,
+			   int f_out)
 {
-	int fd;
-	STRUCT_STAT st;
-	struct map_struct *mapbuf;
-	int statret;
-	char *fnamecmp;
+	int fd, f_copy;
+	STRUCT_STAT st, partial_st;
+	struct file_struct *back_file;
+	int statret, stat_errno;
+	char *fnamecmp, *partialptr, *backupptr;
 	char fnamecmpbuf[MAXPATHLEN];
 
 	if (list_only)
 		return;
 
 	if (verbose > 2)
-		rprintf(FINFO,"recv_generator(%s,%d)\n",fname,i);
+		rprintf(FINFO, "recv_generator(%s,%d)\n", safe_fname(fname), i);
+
+	if (server_exclude_list.head
+	    && check_exclude(&server_exclude_list, fname,
+			     S_ISDIR(file->mode)) < 0) {
+		if (verbose) {
+			rprintf(FINFO, "skipping server-excluded file \"%s\"\n",
+				safe_fname(fname));
+		}
+		return;
+	}
 
-	statret = link_stat(fname,&st);
+	if (dry_run > 1) {
+		statret = -1;
+		stat_errno = ENOENT;
+	} else {
+		statret = link_stat(fname, &st,
+				    keep_dirlinks && S_ISDIR(file->mode));
+		stat_errno = errno;
+	}
 
-	if (only_existing && statret == -1 && errno == ENOENT) {
+	if (only_existing && statret == -1 && stat_errno == ENOENT) {
 		/* we only want to update existing files */
-		if (verbose > 1) rprintf(FINFO, "not creating new file \"%s\"\n",fname);
+		if (verbose > 1) {
+			rprintf(FINFO, "not creating new file \"%s\"\n",
+				safe_fname(fname));
+		}
 		return;
 	}
 
-	if (statret == 0 &&
-	    !preserve_perms &&
-	    (S_ISDIR(st.st_mode) == S_ISDIR(file->mode))) {
+	if (statret == 0 && !preserve_perms
+	    && S_ISDIR(st.st_mode) == S_ISDIR(file->mode)) {
 		/* if the file exists already and we aren't perserving
 		 * permissions then act as though the remote end sent
 		 * us the file permissions we already have */
 		file->mode = (file->mode & ~CHMOD_BITS)
 			   | (st.st_mode & CHMOD_BITS);
 	}
@@ -302,34 +310,37 @@
 		/* The file to be received is a directory, so we need
 		 * to prepare appropriately.  If there is already a
 		 * file of that name and it is *not* a directory, then
 		 * we need to delete it.  If it doesn't exist, then
 		 * recursively create it. */
 
-		if (dry_run) return; /* XXXX -- might cause inaccuracies?? -- mbp */
+		if (dry_run)
+			return; /* TODO: causes inaccuracies -- fix */
 		if (statret == 0 && !S_ISDIR(st.st_mode)) {
 			if (robust_unlink(fname) != 0) {
-				rprintf(FERROR,
-					"recv_generator: unlink %s to make room for directory: %s\n",
-					full_fname(fname), strerror(errno));
+				rsyserr(FERROR, errno,
+					"recv_generator: unlink %s to make room for directory",
+					full_fname(fname));
 				return;
 			}
 			statret = -1;
 		}
 		if (statret != 0 && do_mkdir(fname,file->mode) != 0 && errno != EEXIST) {
-			if (!(relative_paths && errno==ENOENT &&
-			      create_directory_path(fname, orig_umask)==0 &&
-			      do_mkdir(fname,file->mode)==0)) {
-				rprintf(FERROR, "recv_generator: mkdir %s failed: %s\n",
-					full_fname(fname), strerror(errno));
+			if (!(relative_paths && errno == ENOENT
+			    && create_directory_path(fname, orig_umask) == 0
+			    && do_mkdir(fname, file->mode) == 0)) {
+				rsyserr(FERROR, errno,
+					"recv_generator: mkdir %s failed",
+					full_fname(fname));
 			}
 		}
-		/* f_out is set to -1 when doing final directory
-		   permission and modification time repair */
-		if (set_perms(fname,file,NULL,0) && verbose && (f_out != -1))
-			rprintf(FINFO,"%s/\n",fname);
+		/* f_out is set to -1 when doing final directory-permission
+		 * and modification-time repair. */
+		if (set_perms(fname, file, statret ? NULL : &st, 0)
+		    && verbose && f_out != -1)
+			rprintf(FINFO, "%s/\n", safe_fname(fname));
 		return;
 	}
 
 	if (preserve_links && S_ISLNK(file->mode)) {
 #if SUPPORT_LINKS
 		char lnk[MAXPATHLEN];
@@ -347,198 +358,246 @@
 			if (l > 0) {
 				lnk[l] = 0;
 				/* A link already pointing to the
 				 * right place -- no further action
 				 * required. */
 				if (strcmp(lnk,file->u.link) == 0) {
-					set_perms(fname,file,&st,1);
+					set_perms(fname, file, &st,
+						  PERMS_REPORT);
 					return;
 				}
 			}
 			/* Not a symlink, so delete whatever's
 			 * already there and put a new symlink
 			 * in place. */
 			delete_file(fname);
 		}
 		if (do_symlink(file->u.link,fname) != 0) {
-			rprintf(FERROR, "symlink %s -> \"%s\" failed: %s\n",
-				full_fname(fname), file->u.link, strerror(errno));
+			rsyserr(FERROR, errno, "symlink %s -> \"%s\" failed",
+				full_fname(fname), safe_fname(file->u.link));
 		} else {
 			set_perms(fname,file,NULL,0);
 			if (verbose) {
-				rprintf(FINFO,"%s -> %s\n", fname,file->u.link);
+				rprintf(FINFO, "%s -> %s\n", safe_fname(fname),
+					safe_fname(file->u.link));
 			}
 		}
 #endif
 		return;
 	}
 
 #ifdef HAVE_MKNOD
 	if (am_root && preserve_devices && IS_DEVICE(file->mode)) {
 		if (statret != 0 ||
 		    st.st_mode != file->mode ||
 		    st.st_rdev != file->u.rdev) {
 			delete_file(fname);
-			if (verbose > 2)
+			if (verbose > 2) {
 				rprintf(FINFO,"mknod(%s,0%o,0x%x)\n",
-					fname,(int)file->mode,(int)file->u.rdev);
+					safe_fname(fname),
+					(int)file->mode, (int)file->u.rdev);
+			}
 			if (do_mknod(fname,file->mode,file->u.rdev) != 0) {
-				rprintf(FERROR, "mknod %s failed: %s\n",
-					full_fname(fname), strerror(errno));
+				rsyserr(FERROR, errno, "mknod %s failed",
+					full_fname(fname));
 			} else {
 				set_perms(fname,file,NULL,0);
-				if (verbose)
-					rprintf(FINFO,"%s\n",fname);
+				if (verbose) {
+					rprintf(FINFO, "%s\n",
+						safe_fname(fname));
+				}
 			}
 		} else {
-			set_perms(fname,file,&st,1);
+			set_perms(fname, file, &st, PERMS_REPORT);
 		}
 		return;
 	}
 #endif
 
 	if (preserve_hard_links && hard_link_check(file, HL_CHECK_MASTER))
 		return;
 
 	if (!S_ISREG(file->mode)) {
-		rprintf(FINFO, "skipping non-regular file \"%s\"\n",fname);
+		rprintf(FINFO, "skipping non-regular file \"%s\"\n",
+			safe_fname(fname));
 		return;
 	}
 
 	fnamecmp = fname;
 
 	if (statret == -1 && compare_dest != NULL) {
 		/* try the file at compare_dest instead */
-		int saveerrno = errno;
 		pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, compare_dest, fname);
-		statret = link_stat(fnamecmpbuf,&st);
-		if (!S_ISREG(st.st_mode))
-			statret = -1;
-		if (statret == -1)
-			errno = saveerrno;
+		if (link_stat(fnamecmpbuf, &st, 0) == 0
+		    && S_ISREG(st.st_mode)) {
 #if HAVE_LINK
-		else if (link_dest && !dry_run) {
-			if (do_link(fnamecmpbuf, fname) != 0) {
-				if (verbose > 0) {
-					rprintf(FINFO,"link %s => %s : %s\n",
-						fnamecmpbuf, fname,
-						strerror(errno));
+			if (link_dest && !dry_run) {
+				if (do_link(fnamecmpbuf, fname) < 0) {
+					if (verbose) {
+						rsyserr(FINFO, errno,
+							"link %s => %s",
+							fnamecmpbuf,
+							safe_fname(fname));
+					}
+					fnamecmp = fnamecmpbuf;
 				}
-			}
-			fnamecmp = fnamecmpbuf;
-		}
+			} else
 #endif
-		else
-			fnamecmp = fnamecmpbuf;
+				fnamecmp = fnamecmpbuf;
+			statret = 0;
+		}
 	}
 
-	if (statret == -1) {
-		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
+	if (statret == 0 && !S_ISREG(st.st_mode)) {
+		if (delete_file(fname) != 0)
 			return;
-		if (errno == ENOENT) {
-			write_int(f_out,i);
-			if (!dry_run) write_sum_head(f_out, NULL);
-		} else if (verbose > 1) {
-			rprintf(FERROR,
-				"recv_generator: failed to open %s: %s\n",
-				full_fname(fname), strerror(errno));
-		}
-		return;
+		statret = -1;
+		stat_errno = ENOENT;
 	}
 
-	if (!S_ISREG(st.st_mode)) {
-		if (delete_file(fname) != 0) {
-			return;
-		}
+	if (partial_dir && (partialptr = partial_dir_fname(fname))
+	    && link_stat(partialptr, &partial_st, 0) == 0
+	    && S_ISREG(partial_st.st_mode)) {
+		if (statret == -1)
+			goto prepare_to_open;
+	} else
+		partialptr = NULL;
 
-		/* now pretend the file didn't exist */
+	if (statret == -1) {
 		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
 			return;
-		write_int(f_out,i);
-		if (!dry_run) write_sum_head(f_out, NULL);
+		if (stat_errno == ENOENT) {
+			write_int(f_out,i);
+			if (!dry_run && !read_batch)
+				write_sum_head(f_out, NULL);
+		} else if (verbose > 1) {
+			rsyserr(FERROR, stat_errno,
+				"recv_generator: failed to stat %s",
+				full_fname(fname));
+		}
 		return;
 	}
 
 	if (opt_ignore_existing && fnamecmp == fname) {
 		if (verbose > 1)
-			rprintf(FINFO,"%s exists\n",fname);
+			rprintf(FINFO, "%s exists\n", safe_fname(fname));
 		return;
 	}
 
-	if (update_only && cmp_modtime(st.st_mtime,file->modtime)>0 && fnamecmp == fname) {
+	if (update_only && fnamecmp == fname
+	    && cmp_modtime(st.st_mtime, file->modtime) > 0) {
 		if (verbose > 1)
-			rprintf(FINFO,"%s is newer\n",fname);
+			rprintf(FINFO, "%s is newer\n", safe_fname(fname));
 		return;
 	}
 
-	if (skip_file(fname, file, &st)) {
+	if (skip_file(fnamecmp, file, &st)) {
 		if (fnamecmp == fname)
-			set_perms(fname,file,&st,1);
+			set_perms(fname, file, &st, PERMS_REPORT);
 		return;
 	}
 
-	if (dry_run) {
+prepare_to_open:
+	if (dry_run || read_batch) {
 		write_int(f_out,i);
 		return;
 	}
 
-	if (disable_deltas_p()) {
+	if (whole_file > 0) {
 		write_int(f_out,i);
 		write_sum_head(f_out, NULL);
 		return;
 	}
 
+	if (partialptr) {
+		st = partial_st;
+		fnamecmp = partialptr;
+	}
+
 	/* open the file */
 	fd = do_open(fnamecmp, O_RDONLY, 0);
 
 	if (fd == -1) {
-		rprintf(FERROR, "failed to open %s, continuing: %s\n",
-			full_fname(fnamecmp), strerror(errno));
+		rsyserr(FERROR, errno, "failed to open %s, continuing",
+			full_fname(fnamecmp));
+	    pretend_missing:
 		/* pretend the file didn't exist */
 		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
 			return;
 		write_int(f_out,i);
 		write_sum_head(f_out, NULL);
 		return;
 	}
 
-	if (st.st_size > 0)
-		mapbuf = map_file(fd,st.st_size);
-	else
-		mapbuf = NULL;
+	if (inplace && make_backups) {
+		if (!(backupptr = get_backup_name(fname))) {
+			close(fd);
+			return;
+		}
+		if (!(back_file = make_file(fname, NULL, NO_EXCLUDES))) {
+			close(fd);
+			goto pretend_missing;
+		}
+		if (robust_unlink(backupptr) && errno != ENOENT) {
+			rsyserr(FERROR, errno, "unlink %s",
+				full_fname(backupptr));
+			free(back_file);
+			close(fd);
+			return;
+		}
+		if ((f_copy = do_open(backupptr,
+		    O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0600)) < 0) {
+			rsyserr(FERROR, errno, "open %s",
+				full_fname(backupptr));
+			free(back_file);
+			close(fd);
+			return;
+		}
+	} else {
+		backupptr = NULL;
+		back_file = NULL;
+		f_copy = -1;
+	}
 
 	if (verbose > 3) {
-		rprintf(FINFO,"gen mapped %s of size %.0f\n", fnamecmp,
-			(double)st.st_size);
+		rprintf(FINFO, "gen mapped %s of size %.0f\n",
+			safe_fname(fnamecmp), (double)st.st_size);
 	}
 
 	if (verbose > 2)
 		rprintf(FINFO, "generating and sending sums for %d\n", i);
 
 	write_int(f_out,i);
-	generate_and_send_sums(mapbuf, st.st_size, f_out);
+	generate_and_send_sums(fd, st.st_size, f_out, f_copy);
+
+	if (f_copy >= 0) {
+		close(f_copy);
+		set_perms(backupptr, back_file, NULL, 0);
+		if (verbose > 1)
+			rprintf(FINFO, "backed up %s to %s\n", fname, backupptr);
+		free(back_file);
+	}
 
 	close(fd);
-	if (mapbuf) unmap_file(mapbuf);
 }
 
 
-void generate_files(int f, struct file_list *flist, char *local_name)
+void generate_files(int f_out, struct file_list *flist, char *local_name)
 {
 	int i;
-	int phase=0;
+	int phase = 0;
 	char fbuf[MAXPATHLEN];
 
 	if (verbose > 2) {
 		rprintf(FINFO, "generator starting pid=%ld count=%d\n",
 			(long)getpid(), flist->count);
 	}
 
 	if (verbose >= 2) {
 		rprintf(FINFO,
-			disable_deltas_p()
+			whole_file > 0
 			? "delta-transmission disabled for local transfer or --whole-file\n"
 			: "delta transmission enabled\n");
 	}
 
 	/* we expect to just sit around now, so don't exit on a
 	   timeout. If we really get a timeout then the other process should
@@ -560,46 +619,47 @@
 			 * handling of permissions is strange? */
 			copy.mode |= S_IWUSR; /* user write */
 			file = &copy;
 		}
 
 		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
-			       file, i, f);
+			       file, i, f_out);
 	}
 
 	phase++;
 	csum_length = SUM_LENGTH;
-	ignore_times=1;
+	ignore_times = 1;
 
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
-	write_int(f,-1);
+	write_int(f_out, -1);
 
 	/* files can cycle through the system more than once
 	 * to catch initial checksum errors */
 	while ((i = get_redo_num()) != -1) {
 		struct file_struct *file = flist->files[i];
 		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
-			       file, i, f);
+			       file, i, f_out);
 	}
 
 	phase++;
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
-	write_int(f,-1);
+	write_int(f_out, -1);
 
 	if (preserve_hard_links)
 		do_hard_links();
 
 	/* now we need to fix any directory permissions that were
 	 * modified during the transfer */
 	for (i = 0; i < flist->count; i++) {
 		struct file_struct *file = flist->files[i];
-		if (!file->basename || !S_ISDIR(file->mode)) continue;
+		if (!file->basename || !S_ISDIR(file->mode))
+			continue;
 		recv_generator(local_name ? local_name : f_name(file),
 			       file, i, -1);
 	}
 
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files finished\n");
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3: getfsdev.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/hlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/hlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/hlink.c	2004-03-27 00:46:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/hlink.c	2004-07-12 15:03:28.000000000 +0800
@@ -132,33 +132,35 @@
 		link_idev_data(flist);
 #endif
 }
 
 int hard_link_check(struct file_struct *file, int skip)
 {
+#if SUPPORT_HARD_LINKS
 	if (!hlink_list || !file->link_u.links)
 		return 0;
 	if (skip && !(file->flags & FLAG_HLINK_EOL))
 		hlink_list[file->F_HLINDEX] = file->F_NEXT;
 	if (hlink_list[file->F_HLINDEX] != file) {
 		if (verbose > 1) {
 			rprintf(FINFO, "\"%s\" is a hard link\n",
 			    f_name(file));
 		}
 		return 1;
 	}
+#endif
 	return 0;
 }
 
 #if SUPPORT_HARD_LINKS
 static void hard_link_one(char *hlink1, char *hlink2)
 {
 	if (do_link(hlink1, hlink2)) {
 		if (verbose) {
-			rprintf(FINFO, "link %s => %s failed: %s\n",
-			    hlink2, hlink1, strerror(errno));
+			rsyserr(FINFO, errno, "link %s => %s failed",
+				hlink2, hlink1);
 		}
 	}
 	else if (verbose)
 		rprintf(FINFO, "%s => %s\n", hlink2, hlink1);
 }
 #endif
@@ -180,29 +182,28 @@
 
 	if (!hlink_list)
 		return;
 
 	for (i = 0; i < hlink_count; i++) {
 		first = file = hlink_list[i];
-		if (link_stat(f_name_to(first, hlink1), &st1) != 0)
+		if (link_stat(f_name_to(first, hlink1), &st1, 0) < 0)
 			continue;
 		while ((file = file->F_NEXT) != first) {
 			hlink2 = f_name(file);
-			if (link_stat(hlink2, &st2) == 0) {
+			if (link_stat(hlink2, &st2, 0) == 0) {
 				if (st2.st_dev == st1.st_dev
 				    && st2.st_ino == st1.st_ino)
 					continue;
 				if (make_backups) {
 					if (!make_backup(hlink2))
 						continue;
 				} else if (robust_unlink(hlink2)) {
 					if (verbose > 0) {
-						rprintf(FINFO,
-						    "unlink %s failed: %s\n",
-						    full_fname(hlink2), 
-						    strerror(errno));
+						rsyserr(FINFO, errno,
+							"unlink %s failed",
+							full_fname(hlink2));
 					}
 					continue;
 				}
 			}
 			hard_link_one(hlink1, hlink2);
 		}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/io.c	2004-01-17 00:31:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/io.c	2004-08-02 10:43:54.000000000 +0800
@@ -1,31 +1,31 @@
 /* -*- c-file-style: "linux" -*-
- * 
- * Copyright (C) 1996-2001 by Andrew Tridgell 
+ *
+ * Copyright (C) 1996-2001 by Andrew Tridgell
  * Copyright (C) Paul Mackerras 1996
  * Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /**
  * @file io.c
  *
- * Socket and pipe IO utilities used in rsync.
+ * Socket and pipe I/O utilities used in rsync.
  *
  * rsync provides its own multiplexing system, which is used to send
  * stderr and stdout over a single socket.  We need this because
  * stdout normally carries the binary data stream, and stderr all our
  * error messages.
  *
@@ -36,39 +36,39 @@
 
 #include "rsync.h"
 
 /** If no timeout is specified then use a 60 second select timeout */
 #define SELECT_TIMEOUT 60
 
-static int io_multiplexing_out;
-static int io_multiplexing_in;
-static int multiplex_in_fd = -1;
-static int multiplex_out_fd = -1;
-static time_t last_io;
-static int no_flush;
-
 extern int bwlimit;
+extern size_t bwlimit_writemax;
 extern int verbose;
 extern int io_timeout;
 extern int am_server;
 extern int am_daemon;
 extern int am_sender;
+extern int eol_nulls;
+extern int checksum_seed;
+extern int protocol_version;
+extern char *remote_filesfrom_file;
 extern struct stats stats;
 
-
 const char phase_unknown[] = "unknown";
+int select_timeout = SELECT_TIMEOUT;
+int batch_fd = -1;
+int batch_gen_fd = -1;
 
 /**
  * The connection might be dropped at some point; perhaps because the
  * remote instance crashed.  Just giving the offset on the stream is
  * not very helpful.  So instead we try to make io_phase_name point to
  * something useful.
  *
- * For buffered/multiplexed IO these names will be somewhat
+ * For buffered/multiplexed I/O these names will be somewhat
  * approximate; perhaps for ease of support we would rather make the
- * buffer always flush when a single application-level IO finishes.
+ * buffer always flush when a single application-level I/O finishes.
  *
  * @todo Perhaps we want some simple stack functionality, but there's
  * no need to overdo it.
  **/
 const char *io_write_phase = phase_unknown;
 const char *io_read_phase = phase_unknown;
@@ -77,12 +77,22 @@
     version is 24 or less. */
 int kludge_around_eof = False;
 
 int msg_fd_in = -1;
 int msg_fd_out = -1;
 
+static int io_multiplexing_out;
+static int io_multiplexing_in;
+static int sock_f_in = -1;
+static int sock_f_out = -1;
+static time_t last_io;
+static int no_flush;
+
+static int write_batch_monitor_in = -1;
+static int write_batch_monitor_out = -1;
+
 static int io_filesfrom_f_in = -1;
 static int io_filesfrom_f_out = -1;
 static char io_filesfrom_buf[2048];
 static char *io_filesfrom_bp;
 static char io_filesfrom_lastchar;
 static int io_filesfrom_buflen;
@@ -132,32 +142,40 @@
 		last_io = time(NULL);
 		return;
 	}
 
 	t = time(NULL);
 
-	if (last_io && io_timeout && (t-last_io) >= io_timeout) {
+	if (t - last_io >= io_timeout) {
 		if (!am_server && !am_daemon) {
-			rprintf(FERROR,"io timeout after %d seconds - exiting\n", 
+			rprintf(FERROR, "io timeout after %d seconds - exiting\n",
 				(int)(t-last_io));
 		}
 		exit_cleanup(RERR_TIMEOUT);
 	}
 }
 
+/* Note the fds used for the main socket (which might really be a pipe
+ * for a local transfer, but we can ignore that). */
+void io_set_sock_fds(int f_in, int f_out)
+{
+	sock_f_in = f_in;
+	sock_f_out = f_out;
+}
+
 /** Setup the fd used to receive MSG_* messages.  Only needed when
  * we're the generator because the sender and receiver both use the
- * multiplexed IO setup. */
+ * multiplexed I/O setup. */
 void set_msg_fd_in(int fd)
 {
 	msg_fd_in = fd;
 }
 
 /** Setup the fd used to send our MSG_* messages.  Only needed when
  * we're the receiver because the generator and the sender both use
- * the multiplexed IO setup. */
+ * the multiplexed I/O setup. */
 void set_msg_fd_out(int fd)
 {
 	msg_fd_out = fd;
 	set_nonblocking(msg_fd_out);
 }
 
@@ -188,19 +206,19 @@
 }
 
 /** Read a message from the MSG_* fd and dispatch it.  This is only
  * called by the generator. */
 static void read_msg_fd(void)
 {
-	char buf[200];
+	char buf[2048];
 	size_t n;
 	int fd = msg_fd_in;
 	int tag, len;
 
-	/* Temporarily disable msg_fd_in.  This is needed because we
-	 * may call a write routine that could try to call us back. */
+	/* Temporarily disable msg_fd_in.  This is needed to avoid looping back
+	 * to this routine from read_timeout() and writefd_unbuffered(). */
 	msg_fd_in = -1;
 
 	read_loop(fd, buf, 4);
 	tag = IVAL(buf, 0);
 
 	len = tag & 0xFFFFFF;
@@ -241,13 +259,13 @@
 
 	msg_fd_in = fd;
 }
 
 /* Try to push messages off the list onto the wire.  If we leave with more
  * to do, return 0.  On error, return -1.  If everything flushed, return 1.
- * This is only called by the receiver. */
+ * This is only active in the receiver. */
 int msg_list_push(int flush_it_all)
 {
 	static int written = 0;
 	struct timeval tv;
 	fd_set fds;
 
@@ -263,13 +281,13 @@
 			if (errno != EWOULDBLOCK && errno != EAGAIN)
 				return -1;
 			if (!flush_it_all)
 				return 0;
 			FD_ZERO(&fds);
 			FD_SET(msg_fd_out, &fds);
-			tv.tv_sec = io_timeout ? io_timeout : SELECT_TIMEOUT;
+			tv.tv_sec = select_timeout;
 			tv.tv_usec = 0;
 			if (!select(msg_fd_out+1, NULL, &fds, NULL, &tv))
 				check_timeout();
 		} else if ((written += n) == ml->len) {
 			free(ml->buf);
 			msg_list_head = ml->next;
@@ -326,111 +344,97 @@
  * However, there is one unfortunate cases where it is not, which is
  * rsync <2.4.6 sending a list of modules on a server, since the list
  * is terminated by closing the socket. So, for the section of the
  * program where that is a problem (start_socket_client),
  * kludge_around_eof is True and we just exit.
  */
-static void whine_about_eof(void)
+static void whine_about_eof(int fd)
 {
-	if (kludge_around_eof)
+	if (kludge_around_eof && fd == sock_f_in)
 		exit_cleanup(0);
-	else {
-		rprintf(FERROR,
-			"%s: connection unexpectedly closed "
-			"(%.0f bytes read so far)\n",
-			RSYNC_NAME, (double)stats.total_read);
 
-		exit_cleanup(RERR_STREAMIO);
-	}
-}
+	rprintf(FERROR, RSYNC_NAME ": connection unexpectedly closed "
+		"(%.0f bytes received so far) [%s]\n",
+		(double)stats.total_read, who_am_i());
 
-
-static void die_from_readerr(int err)
-{
-	/* this prevents us trying to write errors on a dead socket */
-	io_multiplexing_close();
-
-	rprintf(FERROR, "%s: read error: %s\n",
-		RSYNC_NAME, strerror(err));
 	exit_cleanup(RERR_STREAMIO);
 }
 
 
 /**
- * Read from a socket with IO timeout. return the number of bytes
+ * Read from a socket with I/O timeout. return the number of bytes
  * read. If no bytes can be read then exit, never return a number <= 0.
  *
  * TODO: If the remote shell connection fails, then current versions
  * actually report an "unexpected EOF" error here.  Since it's a
  * fairly common mistake to try to use rsh when ssh is required, we
  * should trap that: if we fail to read any data at all, we should
  * give a better explanation.  We can tell whether the connection has
  * started by looking e.g. at whether the remote version is known yet.
  */
 static int read_timeout(int fd, char *buf, size_t len)
 {
-	int n, ret=0;
+	int n, ret = 0;
 
 	io_flush(NORMAL_FLUSH);
 
 	while (ret == 0) {
 		/* until we manage to read *something* */
 		fd_set r_fds, w_fds;
 		struct timeval tv;
-		int fd_count = fd+1;
+		int maxfd = fd;
 		int count;
 
 		FD_ZERO(&r_fds);
+		FD_ZERO(&w_fds);
 		FD_SET(fd, &r_fds);
 		if (msg_fd_in >= 0) {
 			FD_SET(msg_fd_in, &r_fds);
-			if (msg_fd_in >= fd_count)
-				fd_count = msg_fd_in+1;
+			if (msg_fd_in > maxfd)
+				maxfd = msg_fd_in;
+		} else if (msg_list_head) {
+			FD_SET(msg_fd_out, &w_fds);
+			if (msg_fd_out > maxfd)
+				maxfd = msg_fd_out;
 		}
 		if (io_filesfrom_f_out >= 0) {
 			int new_fd;
 			if (io_filesfrom_buflen == 0) {
 				if (io_filesfrom_f_in >= 0) {
 					FD_SET(io_filesfrom_f_in, &r_fds);
 					new_fd = io_filesfrom_f_in;
 				} else {
 					io_filesfrom_f_out = -1;
 					new_fd = -1;
 				}
 			} else {
-				FD_ZERO(&w_fds);
 				FD_SET(io_filesfrom_f_out, &w_fds);
 				new_fd = io_filesfrom_f_out;
 			}
-			if (new_fd >= fd_count)
-				fd_count = new_fd+1;
+			if (new_fd > maxfd)
+				maxfd = new_fd;
 		}
 
-		tv.tv_sec = io_timeout?io_timeout:SELECT_TIMEOUT;
+		tv.tv_sec = select_timeout;
 		tv.tv_usec = 0;
 
 		errno = 0;
 
-		count = select(fd_count, &r_fds,
-			       io_filesfrom_buflen? &w_fds : NULL,
-			       NULL, &tv);
-
-		if (count == 0) {
-			msg_list_push(NORMAL_FLUSH);
-			check_timeout();
-		}
+		count = select(maxfd + 1, &r_fds, &w_fds, NULL, &tv);
 
 		if (count <= 0) {
-			if (errno == EBADF) {
+			if (errno == EBADF)
 				exit_cleanup(RERR_SOCKETIO);
-			}
+			check_timeout();
 			continue;
 		}
 
 		if (msg_fd_in >= 0 && FD_ISSET(msg_fd_in, &r_fds))
 			read_msg_fd();
+		else if (msg_list_head && FD_ISSET(msg_fd_out, &w_fds))
+			msg_list_push(NORMAL_FLUSH);
 
 		if (io_filesfrom_f_out >= 0) {
 			if (io_filesfrom_buflen) {
 				if (FD_ISSET(io_filesfrom_f_out, &w_fds)) {
 					int l = write(io_filesfrom_f_out,
 						      io_filesfrom_bp,
@@ -454,13 +458,12 @@
 						/* Send end-of-file marker */
 						io_filesfrom_buf[0] = '\0';
 						io_filesfrom_buf[1] = '\0';
 						io_filesfrom_buflen = io_filesfrom_lastchar? 2 : 1;
 						io_filesfrom_f_in = -1;
 					} else {
-						extern int eol_nulls;
 						if (!eol_nulls) {
 							char *s = io_filesfrom_buf + l;
 							/* Transform CR and/or LF into '\0' */
 							while (s-- > io_filesfrom_buf) {
 								if (*s == '\n' || *s == '\r')
 									*s = '\0';
@@ -490,32 +493,37 @@
 						io_filesfrom_buflen = l;
 					}
 				}
 			}
 		}
 
-		if (!FD_ISSET(fd, &r_fds)) continue;
+		if (!FD_ISSET(fd, &r_fds))
+			continue;
 
 		n = read(fd, buf, len);
 
-		if (n > 0) {
-			buf += n;
-			len -= n;
-			ret += n;
-			if (io_timeout)
-				last_io = time(NULL);
-			continue;
-		} else if (n == 0) {
-			whine_about_eof();
-			return -1; /* doesn't return */
-		} else if (n < 0) {
-			if (errno == EINTR || errno == EWOULDBLOCK ||
-			    errno == EAGAIN) 
+		if (n <= 0) {
+			if (n == 0)
+				whine_about_eof(fd); /* Doesn't return. */
+			if (errno == EINTR || errno == EWOULDBLOCK
+			    || errno == EAGAIN)
 				continue;
-			die_from_readerr(errno);
+
+			/* Don't write errors on a dead socket. */
+			if (fd == sock_f_in)
+				close_multiplexing_out();
+			rsyserr(FERROR, errno, "read error");
+			exit_cleanup(RERR_STREAMIO);
 		}
+
+		buf += n;
+		len -= n;
+		ret += n;
+
+		if (io_timeout && fd == sock_f_in)
+			last_io = time(NULL);
 	}
 
 	return ret;
 }
 
 /**
@@ -523,15 +531,12 @@
  * characters long).
  */
 int read_filesfrom_line(int fd, char *fname)
 {
 	char ch, *s, *eob = fname + MAXPATHLEN - 1;
 	int cnt;
-	extern int io_timeout;
-	extern int eol_nulls;
-	extern char *remote_filesfrom_file;
 	int reading_remotely = remote_filesfrom_file != NULL;
 	int nulls = eol_nulls || reading_remotely;
 
   start:
 	s = fname;
 	while (1) {
@@ -539,13 +544,13 @@
 		if (cnt < 0 && (errno == EWOULDBLOCK
 		  || errno == EINTR || errno == EAGAIN)) {
 			struct timeval tv;
 			fd_set fds;
 			FD_ZERO(&fds);
 			FD_SET(fd, &fds);
-			tv.tv_sec = io_timeout? io_timeout : SELECT_TIMEOUT;
+			tv.tv_sec = select_timeout;
 			tv.tv_usec = 0;
 			if (!select(fd+1, &fds, NULL, NULL, &tv))
 				check_timeout();
 			continue;
 		}
 		if (cnt != 1)
@@ -566,12 +571,48 @@
 		goto start;
 
 	return s - fname;
 }
 
 
+static char *iobuf_out;
+static int iobuf_out_cnt;
+
+void io_start_buffering_out(void)
+{
+	if (iobuf_out)
+		return;
+	if (!(iobuf_out = new_array(char, IO_BUFFER_SIZE)))
+		out_of_memory("io_start_buffering_out");
+	iobuf_out_cnt = 0;
+}
+
+
+static char *iobuf_in;
+static size_t iobuf_in_siz;
+
+void io_start_buffering_in(void)
+{
+	if (iobuf_in)
+		return;
+	iobuf_in_siz = 2 * IO_BUFFER_SIZE;
+	if (!(iobuf_in = new_array(char, iobuf_in_siz)))
+		out_of_memory("io_start_buffering_in");
+}
+
+
+void io_end_buffering(void)
+{
+	io_flush(NORMAL_FLUSH);
+	if (!io_multiplexing_out) {
+		free(iobuf_out);
+		iobuf_out = NULL;
+	}
+}
+
+
 /**
  * Continue trying to read len bytes - don't return until len has been
  * read.
  **/
 static void read_loop(int fd, char *buf, size_t len)
 {
@@ -584,42 +625,35 @@
 }
 
 
 /**
  * Read from the file descriptor handling multiplexing - return number
  * of bytes read.
- * 
- * Never returns <= 0. 
+ *
+ * Never returns <= 0.
  */
-static int read_unbuffered(int fd, char *buf, size_t len)
+static int readfd_unbuffered(int fd, char *buf, size_t len)
 {
 	static size_t remaining;
+	static size_t iobuf_in_ndx;
 	int tag, ret = 0;
 	char line[1024];
-	static char *buffer;
-	static size_t bufferIdx = 0;
-	static size_t bufferSz;
 
-	if (fd != multiplex_in_fd)
+	if (!iobuf_in || fd != sock_f_in)
 		return read_timeout(fd, buf, len);
 
 	if (!io_multiplexing_in && remaining == 0) {
-		if (!buffer) {
-			bufferSz = 2 * IO_BUFFER_SIZE;
-			buffer   = new_array(char, bufferSz);
-			if (!buffer) out_of_memory("read_unbuffered");
-		}
-		remaining = read_timeout(fd, buffer, bufferSz);
-		bufferIdx = 0;
+		remaining = read_timeout(fd, iobuf_in, iobuf_in_siz);
+		iobuf_in_ndx = 0;
 	}
 
 	while (ret == 0) {
 		if (remaining) {
 			len = MIN(len, remaining);
-			memcpy(buf, buffer + bufferIdx, len);
-			bufferIdx += len;
+			memcpy(buf, iobuf_in + iobuf_in_ndx, len);
+			iobuf_in_ndx += len;
 			remaining -= len;
 			ret = len;
 			break;
 		}
 
 		read_loop(fd, line, 4);
@@ -627,19 +661,20 @@
 
 		remaining = tag & 0xFFFFFF;
 		tag = (tag >> 24) - MPLEX_BASE;
 
 		switch (tag) {
 		case MSG_DATA:
-			if (!buffer || remaining > bufferSz) {
-				buffer = realloc_array(buffer, char, remaining);
-				if (!buffer) out_of_memory("read_unbuffered");
-				bufferSz = remaining;
+			if (remaining > iobuf_in_siz) {
+				if (!(iobuf_in = realloc_array(iobuf_in, char,
+							       remaining)))
+					out_of_memory("readfd_unbuffered");
+				iobuf_in_siz = remaining;
 			}
-			read_loop(fd, buffer, remaining);
-			bufferIdx = 0;
+			read_loop(fd, iobuf_in, remaining);
+			iobuf_in_ndx = 0;
 			break;
 		case MSG_INFO:
 		case MSG_ERROR:
 			if (remaining >= sizeof line) {
 				rprintf(FERROR, "multiplexing overflow %d:%ld\n\n",
 					tag, (long)remaining);
@@ -668,281 +703,298 @@
  * have been read.  If all @p n can't be read then exit with an
  * error.
  **/
 static void readfd(int fd, char *buffer, size_t N)
 {
 	int  ret;
-	size_t total=0;  
+	size_t total = 0;
 
 	while (total < N) {
-		ret = read_unbuffered(fd, buffer + total, N-total);
+		ret = readfd_unbuffered(fd, buffer + total, N-total);
 		total += ret;
 	}
 
-	stats.total_read += total;
+	if (fd == write_batch_monitor_in) {
+		if ((size_t)write(batch_fd, buffer, total) != total)
+			exit_cleanup(RERR_FILEIO);
+	}
+
+	if (fd == sock_f_in)
+		stats.total_read += total;
 }
 
 
 int32 read_int(int f)
 {
 	char b[4];
 	int32 ret;
 
 	readfd(f,b,4);
 	ret = IVAL(b,0);
-	if (ret == (int32)0xffffffff) return -1;
+	if (ret == (int32)0xffffffff)
+		return -1;
 	return ret;
 }
 
 int64 read_longint(int f)
 {
 	int64 ret;
 	char b[8];
 	ret = read_int(f);
 
-	if ((int32)ret != (int32)0xffffffff) {
+	if ((int32)ret != (int32)0xffffffff)
 		return ret;
-	}
 
-#ifdef NO_INT64
-	rprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
-	exit_cleanup(RERR_UNSUPPORTED);
-#else
+#ifdef INT64_IS_OFF_T
+	if (sizeof (int64) < 8) {
+		rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
+		exit_cleanup(RERR_UNSUPPORTED);
+	}
+#endif
 	readfd(f,b,8);
 	ret = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
-#endif
 
 	return ret;
 }
 
 void read_buf(int f,char *buf,size_t len)
 {
 	readfd(f,buf,len);
 }
 
 void read_sbuf(int f,char *buf,size_t len)
 {
-	read_buf(f,buf,len);
+	readfd(f, buf, len);
 	buf[len] = 0;
 }
 
 unsigned char read_byte(int f)
 {
 	unsigned char c;
-	read_buf(f, (char *)&c, 1);
+	readfd(f, (char *)&c, 1);
 	return c;
 }
 
 
 /**
  * Sleep after writing to limit I/O bandwidth usage.
  *
  * @todo Rather than sleeping after each write, it might be better to
  * use some kind of averaging.  The current algorithm seems to always
  * use a bit less bandwidth than specified, because it doesn't make up
  * for slow periods.  But arguably this is a feature.  In addition, we
  * ought to take the time used to write the data into account.
+ *
+ * During some phases of big transfers (file FOO is uptodate) this is
+ * called with a small bytes_written every time.  As the kernel has to
+ * round small waits up to guarantee that we actually wait at least the
+ * requested number of microseconds, this can become grossly inaccurate.
+ * We therefore keep track of the bytes we've written over time and only
+ * sleep when the accumulated delay is at least 1 tenth of a second.
  **/
 static void sleep_for_bwlimit(int bytes_written)
 {
-	struct timeval tv;
+	static struct timeval prior_tv;
+	static long total_written = 0; 
+	struct timeval tv, start_tv;
+	long elapsed_usec, sleep_usec;
+
+#define ONE_SEC	1000000L /* # of microseconds in a second */
 
 	if (!bwlimit)
 		return;
 
-	assert(bytes_written > 0);
-	assert(bwlimit > 0);
+	total_written += bytes_written; 
+
+	gettimeofday(&start_tv, NULL);
+	if (prior_tv.tv_sec) {
+		elapsed_usec = (start_tv.tv_sec - prior_tv.tv_sec) * ONE_SEC
+			     + (start_tv.tv_usec - prior_tv.tv_usec);
+		total_written -= elapsed_usec * bwlimit / (ONE_SEC/1024);
+		if (total_written < 0)
+			total_written = 0;
+	}
 
-	tv.tv_usec = bytes_written * 1000 / bwlimit;
-	tv.tv_sec  = tv.tv_usec / 1000000;
-	tv.tv_usec = tv.tv_usec % 1000000;
+	sleep_usec = total_written * (ONE_SEC/1024) / bwlimit;
+	if (sleep_usec < ONE_SEC / 10) {
+		prior_tv = start_tv;
+		return;
+	}
 
+	tv.tv_sec  = sleep_usec / ONE_SEC;
+	tv.tv_usec = sleep_usec % ONE_SEC;
 	select(0, NULL, NULL, NULL, &tv);
+
+	gettimeofday(&prior_tv, NULL);
+	elapsed_usec = (prior_tv.tv_sec - start_tv.tv_sec) * ONE_SEC
+		     + (prior_tv.tv_usec - start_tv.tv_usec);
+	total_written = (sleep_usec - elapsed_usec) * bwlimit / (ONE_SEC/1024);
 }
 
 
-/**
- * Write len bytes to the file descriptor @p fd.
+/* Write len bytes to the file descriptor fd, looping as necessary to get
+ * the job done and also (in the generator) reading any data on msg_fd_in
+ * (to avoid deadlock).
  *
  * This function underlies the multiplexing system.  The body of the
- * application never calls this function directly.
- **/
+ * application never calls this function directly. */
 static void writefd_unbuffered(int fd,char *buf,size_t len)
 {
-	size_t total = 0;
+	size_t n, total = 0;
 	fd_set w_fds, r_fds;
-	int fd_count, count;
+	int maxfd, count, ret;
 	struct timeval tv;
 
-	msg_list_push(NORMAL_FLUSH);
-
 	no_flush++;
 
 	while (total < len) {
 		FD_ZERO(&w_fds);
 		FD_SET(fd,&w_fds);
-		fd_count = fd;
+		maxfd = fd;
 
 		if (msg_fd_in >= 0) {
 			FD_ZERO(&r_fds);
 			FD_SET(msg_fd_in,&r_fds);
-			if (msg_fd_in > fd_count) 
-				fd_count = msg_fd_in;
+			if (msg_fd_in > maxfd)
+				maxfd = msg_fd_in;
 		}
 
-		tv.tv_sec = io_timeout?io_timeout:SELECT_TIMEOUT;
+		tv.tv_sec = select_timeout;
 		tv.tv_usec = 0;
 
 		errno = 0;
-		count = select(fd_count+1, msg_fd_in >= 0 ? &r_fds : NULL,
+		count = select(maxfd + 1, msg_fd_in >= 0 ? &r_fds : NULL,
 			       &w_fds, NULL, &tv);
 
-		if (count == 0) {
-			msg_list_push(NORMAL_FLUSH);
-			check_timeout();
-		}
-
 		if (count <= 0) {
-			if (errno == EBADF) {
+			if (count < 0 && errno == EBADF)
 				exit_cleanup(RERR_SOCKETIO);
-			}
+			check_timeout();
 			continue;
 		}
 
 		if (msg_fd_in >= 0 && FD_ISSET(msg_fd_in, &r_fds))
 			read_msg_fd();
 
-		if (FD_ISSET(fd, &w_fds)) {
-			int ret;
-			size_t n = len-total;
-			ret = write(fd,buf+total,n);
+		if (!FD_ISSET(fd, &w_fds))
+			continue;
 
+		n = len - total;
+		if (bwlimit && n > bwlimit_writemax)
+			n = bwlimit_writemax;
+		ret = write(fd, buf + total, n);
+
+		if (ret <= 0) {
 			if (ret < 0) {
 				if (errno == EINTR)
 					continue;
 				if (errno == EWOULDBLOCK || errno == EAGAIN) {
 					msleep(1);
 					continue;
 				}
 			}
 
-			if (ret <= 0) {
-				/* Don't try to write errors back
-				 * across the stream */
-				io_multiplexing_close();
-				rprintf(FERROR, RSYNC_NAME
-					": writefd_unbuffered failed to write %ld bytes: phase \"%s\": %s\n",
-					(long) len, io_write_phase, 
-					strerror(errno));
-				exit_cleanup(RERR_STREAMIO);
+			/* Don't try to write errors back across the stream. */
+			if (fd == sock_f_out)
+				close_multiplexing_out();
+			rsyserr(FERROR, errno,
+				"writefd_unbuffered failed to write %ld bytes: phase \"%s\" [%s]",
+				(long)len, io_write_phase, who_am_i());
+			/* If the other side is sending us error messages, try
+			 * to grab any messages they sent before they died. */
+			while (fd == sock_f_out && io_multiplexing_in) {
+				io_timeout = 30;
+				readfd_unbuffered(sock_f_in, io_filesfrom_buf,
+						  sizeof io_filesfrom_buf);
 			}
+			exit_cleanup(RERR_STREAMIO);
+		}
 
-			sleep_for_bwlimit(ret);
- 
-			total += ret;
+		total += ret;
 
+		if (fd == sock_f_out) {
 			if (io_timeout)
 				last_io = time(NULL);
+			sleep_for_bwlimit(ret);
 		}
 	}
 
 	no_flush--;
 }
 
 
-static char *io_buffer;
-static int io_buffer_count;
-
-void io_start_buffering_out(int fd)
-{
-	if (io_buffer) return;
-	multiplex_out_fd = fd;
-	io_buffer = new_array(char, IO_BUFFER_SIZE);
-	if (!io_buffer) out_of_memory("writefd");
-	io_buffer_count = 0;
-}
-
-void io_start_buffering_in(int fd)
-{
-	multiplex_in_fd = fd;
-}
-
 /**
  * Write an message to a multiplexed stream. If this fails then rsync
  * exits.
  **/
-static void mplex_write(int fd, enum msgcode code, char *buf, size_t len)
+static void mplex_write(enum msgcode code, char *buf, size_t len)
 {
 	char buffer[4096];
 	size_t n = len;
 
 	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
 
-	if (n > (sizeof buffer - 4)) {
+	if (n > sizeof buffer - 4)
 		n = sizeof buffer - 4;
-	}
 
 	memcpy(&buffer[4], buf, n);
-	writefd_unbuffered(fd, buffer, n+4);
+	writefd_unbuffered(sock_f_out, buffer, n+4);
 
 	len -= n;
 	buf += n;
 
-	if (len) {
-		writefd_unbuffered(fd, buf, len);
-	}
+	if (len)
+		writefd_unbuffered(sock_f_out, buf, len);
 }
 
 
 void io_flush(int flush_it_all)
 {
-	int fd = multiplex_out_fd;
-	
 	msg_list_push(flush_it_all);
 
-	if (!io_buffer_count || no_flush)
+	if (!iobuf_out_cnt || no_flush)
 		return;
 
 	if (io_multiplexing_out)
-		mplex_write(fd, MSG_DATA, io_buffer, io_buffer_count);
+		mplex_write(MSG_DATA, iobuf_out, iobuf_out_cnt);
 	else
-		writefd_unbuffered(fd, io_buffer, io_buffer_count);
-	io_buffer_count = 0;
+		writefd_unbuffered(sock_f_out, iobuf_out, iobuf_out_cnt);
+	iobuf_out_cnt = 0;
 }
 
 
-void io_end_buffering(void)
+static void writefd(int fd,char *buf,size_t len)
 {
-	io_flush(NORMAL_FLUSH);
-	if (!io_multiplexing_out) {
-		free(io_buffer);
-		io_buffer = NULL;
+	if (fd == msg_fd_out) {
+		rprintf(FERROR, "Internal error: wrong write used in receiver.\n");
+		exit_cleanup(RERR_PROTOCOL);
 	}
-}
 
-static void writefd(int fd,char *buf,size_t len)
-{
-	stats.total_written += len;
+	if (fd == sock_f_out)
+		stats.total_written += len;
 
-	msg_list_push(NORMAL_FLUSH);
+	if (fd == write_batch_monitor_out) {
+		if ((size_t)write(batch_fd, buf, len) != len)
+			exit_cleanup(RERR_FILEIO);
+	}
 
-	if (!io_buffer || fd != multiplex_out_fd) {
+	if (!iobuf_out || fd != sock_f_out) {
 		writefd_unbuffered(fd, buf, len);
 		return;
 	}
 
 	while (len) {
-		int n = MIN((int) len, IO_BUFFER_SIZE-io_buffer_count);
+		int n = MIN((int)len, IO_BUFFER_SIZE - iobuf_out_cnt);
 		if (n > 0) {
-			memcpy(io_buffer+io_buffer_count, buf, n);
+			memcpy(iobuf_out+iobuf_out_cnt, buf, n);
 			buf += n;
 			len -= n;
-			io_buffer_count += n;
+			iobuf_out_cnt += n;
 		}
 
-		if (io_buffer_count == IO_BUFFER_SIZE)
+		if (iobuf_out_cnt == IO_BUFFER_SIZE)
 			io_flush(NORMAL_FLUSH);
 	}
 }
 
 
 void write_int(int f,int32 x)
@@ -971,118 +1023,143 @@
 
 	if (x <= 0x7FFFFFFF) {
 		write_int(f, (int)x);
 		return;
 	}
 
-#ifdef NO_INT64
-	rprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
-	exit_cleanup(RERR_UNSUPPORTED);
-#else
+#ifdef INT64_IS_OFF_T
+	if (sizeof (int64) < 8) {
+		rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
+		exit_cleanup(RERR_UNSUPPORTED);
+	}
+#endif
+
 	write_int(f, (int32)0xFFFFFFFF);
 	SIVAL(b,0,(x&0xFFFFFFFF));
 	SIVAL(b,4,((x>>32)&0xFFFFFFFF));
 
 	writefd(f,b,8);
-#endif
 }
 
 void write_buf(int f,char *buf,size_t len)
 {
 	writefd(f,buf,len);
 }
 
 /** Write a string to the connection */
-static void write_sbuf(int f,char *buf)
+void write_sbuf(int f, char *buf)
 {
-	write_buf(f, buf, strlen(buf));
+	writefd(f, buf, strlen(buf));
 }
 
-
 void write_byte(int f,unsigned char c)
 {
-	write_buf(f,(char *)&c,1);
+	writefd(f, (char *)&c, 1);
 }
 
 
 
 /**
- * Read a line of up to @p maxlen characters into @p buf.  Does not
- * contain a trailing newline or carriage return.
+ * Read a line of up to @p maxlen characters into @p buf (not counting
+ * the trailing null).  Strips the (required) trailing newline and all
+ * carriage returns.
  *
- * @return 1 for success; 0 for io error or truncation.
+ * @return 1 for success; 0 for I/O error or truncation.
  **/
 int read_line(int f, char *buf, size_t maxlen)
 {
 	while (maxlen) {
 		buf[0] = 0;
 		read_buf(f, buf, 1);
 		if (buf[0] == 0)
 			return 0;
-		if (buf[0] == '\n') {
-			buf[0] = 0;
+		if (buf[0] == '\n')
 			break;
-		}
 		if (buf[0] != '\r') {
 			buf++;
 			maxlen--;
 		}
 	}
-	if (maxlen == 0) {
-		*buf = 0;
-		return 0;
-	}
-
-	return 1;
+	*buf = '\0';
+	return maxlen > 0;
 }
 
 
 void io_printf(int fd, const char *format, ...)
 {
-	va_list ap;  
+	va_list ap;
 	char buf[1024];
 	int len;
 
 	va_start(ap, format);
 	len = vsnprintf(buf, sizeof buf, format, ap);
 	va_end(ap);
 
-	if (len < 0) exit_cleanup(RERR_STREAMIO);
+	if (len < 0)
+		exit_cleanup(RERR_STREAMIO);
 
 	write_sbuf(fd, buf);
 }
 
 
 /** Setup for multiplexing a MSG_* stream with the data stream. */
-void io_start_multiplex_out(int fd)
+void io_start_multiplex_out(void)
 {
-	multiplex_out_fd = fd;
 	io_flush(NORMAL_FLUSH);
-	io_start_buffering_out(fd);
+	io_start_buffering_out();
 	io_multiplexing_out = 1;
 }
 
 /** Setup for multiplexing a MSG_* stream with the data stream. */
-void io_start_multiplex_in(int fd)
+void io_start_multiplex_in(void)
 {
-	multiplex_in_fd = fd;
 	io_flush(NORMAL_FLUSH);
+	io_start_buffering_in();
 	io_multiplexing_in = 1;
 }
 
 /** Write an message to the multiplexed data stream. */
 int io_multiplex_write(enum msgcode code, char *buf, size_t len)
 {
-	if (!io_multiplexing_out) return 0;
+	if (!io_multiplexing_out)
+		return 0;
 
 	io_flush(NORMAL_FLUSH);
 	stats.total_written += (len+4);
-	mplex_write(multiplex_out_fd, code, buf, len);
+	mplex_write(code, buf, len);
 	return 1;
 }
 
+void close_multiplexing_in(void)
+{
+	io_multiplexing_in = 0;
+}
+
 /** Stop output multiplexing. */
-void io_multiplexing_close(void)
+void close_multiplexing_out(void)
 {
 	io_multiplexing_out = 0;
 }
 
+void start_write_batch(int fd)
+{
+	write_stream_flags(batch_fd);
+
+	/* Some communication has already taken place, but we don't
+	 * enable batch writing until here so that we can write a
+	 * canonical record of the communication even though the
+	 * actual communication so far depends on whether a daemon
+	 * is involved. */
+	write_int(batch_fd, protocol_version);
+	write_int(batch_fd, checksum_seed);
+
+	if (am_sender)
+		write_batch_monitor_out = fd;
+	else
+		write_batch_monitor_in = fd;
+}
+
+void stop_write_batch(void)
+{
+	write_batch_monitor_out = -1;
+	write_batch_monitor_in = -1;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/loadparm.c	2004-02-04 15:31:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/loadparm.c	2004-07-31 04:05:37.000000000 +0800
@@ -116,12 +116,13 @@
 {
 	char *name;
 	char *path;
 	char *comment;
 	char *lock_file;
 	BOOL read_only;
+	BOOL write_only;
 	BOOL list;
 	BOOL use_chroot;
 	BOOL transfer_logging;
 	BOOL ignore_errors;
 	char *uid;
 	char *gid;
@@ -148,12 +149,13 @@
 {
 	NULL,    /* name */
 	NULL,    /* path */
 	NULL,    /* comment */
 	DEFAULT_LOCK_FILE,    /* lock file */
 	True,    /* read only */
+	False,   /* write only */
 	True,    /* list */
 	True,    /* use chroot */
 	False,   /* transfer logging */
 	False,   /* ignore errors */
 	"nobody",/* uid */
 
@@ -274,12 +276,13 @@
   {"max connections",  P_INTEGER, P_LOCAL,  &sDefault.max_connections,NULL, 0},
   {"name",             P_STRING,  P_LOCAL,  &sDefault.name,        NULL,   0},
   {"comment",          P_STRING,  P_LOCAL,  &sDefault.comment,     NULL,   0},
   {"lock file",        P_STRING,  P_LOCAL,  &sDefault.lock_file,   NULL,   0},
   {"path",             P_PATH,    P_LOCAL,  &sDefault.path,        NULL,   0},
   {"read only",        P_BOOL,    P_LOCAL,  &sDefault.read_only,   NULL,   0},
+  {"write only",       P_BOOL,    P_LOCAL,  &sDefault.write_only,  NULL,   0},
   {"list",             P_BOOL,    P_LOCAL,  &sDefault.list,        NULL,   0},
   {"use chroot",       P_BOOL,    P_LOCAL,  &sDefault.use_chroot,  NULL,   0},
   {"ignore nonreadable",P_BOOL,   P_LOCAL,  &sDefault.ignore_nonreadable,  NULL,   0},
   {"uid",              P_STRING,  P_LOCAL,  &sDefault.uid,         NULL,   0},
   {"gid",              P_STRING,  P_LOCAL,  &sDefault.gid,         NULL,   0},
   {"hosts allow",      P_STRING,  P_LOCAL,  &sDefault.hosts_allow, NULL,   0},
@@ -353,12 +356,13 @@
 
 FN_LOCAL_STRING(lp_name, name)
 FN_LOCAL_STRING(lp_comment, comment)
 FN_LOCAL_STRING(lp_path, path)
 FN_LOCAL_STRING(lp_lock_file, lock_file)
 FN_LOCAL_BOOL(lp_read_only, read_only)
+FN_LOCAL_BOOL(lp_write_only, write_only)
 FN_LOCAL_BOOL(lp_list, list)
 FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
 FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
 FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
 FN_LOCAL_BOOL(lp_ignore_nonreadable, ignore_nonreadable)
 FN_LOCAL_STRING(lp_uid, uid)
@@ -804,12 +808,12 @@
 ***************************************************************************/
 int lp_number(char *name)
 {
    int iService;
 
    for (iService = iNumServices - 1; iService >= 0; iService--)
-      if (strequal(lp_name(iService), name))
+      if (strcmp(lp_name(iService), name) == 0)
          break;
 
    return (iService);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/log.c	2004-04-30 03:34:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/log.c	2004-09-06 05:30:00.000000000 +0800
@@ -38,13 +38,13 @@
 
 static int log_initialised;
 static char *logfname;
 static FILE *logfile;
 struct stats stats;
 
-int log_got_error=0;
+int log_got_error = 0;
 
 struct {
         int code;
         char const *name;
 } const rerr_names[] = {
 	{ RERR_SYNTAX     , "syntax or usage error" },
@@ -58,13 +58,13 @@
 	{ RERR_MESSAGEIO  , "errors with program diagnostics" },
 	{ RERR_IPC        , "error in IPC code" },
 	{ RERR_SIGNAL     , "received SIGUSR1 or SIGINT" },
 	{ RERR_WAITCHILD  , "some error returned by waitpid()" },
 	{ RERR_MALLOC     , "error allocating core memory buffers" },
 	{ RERR_PARTIAL    , "some files could not be transferred" },
-	{ RERR_VANISHED   , "some files vanished before they could be transfered" },
+	{ RERR_VANISHED   , "some files vanished before they could be transferred" },
 	{ RERR_TIMEOUT    , "timeout in data send/receive" },
 	{ RERR_CMD_FAILED , "remote shell failed" },
 	{ RERR_CMD_KILLED , "remote shell killed" },
 	{ RERR_CMD_RUN,     "remote command could not be run" },
 	{ RERR_CMD_NOTFOUND, "remote command not found" },
 	{ 0, NULL }
@@ -101,13 +101,14 @@
 
 void log_init(void)
 {
 	int options = LOG_PID;
 	time_t t;
 
-	if (log_initialised) return;
+	if (log_initialised)
+		return;
 	log_initialised = 1;
 
 	/* this looks pointless, but it is needed in order for the
 	 * C library on some systems to fetch the timezone info
 	 * before the chroot */
 	t = time(NULL);
@@ -157,101 +158,93 @@
 }
 
 /* this is the underlying (unformatted) rsync debugging function. Call
  * it with FINFO, FERROR or FLOG */
 void rwrite(enum logcode code, char *buf, int len)
 {
-	FILE *f=NULL;
+	FILE *f = NULL;
 	/* recursion can happen with certain fatal conditions */
 
 	if (quiet && code == FINFO)
 		return;
 
 	if (len < 0)
 		exit_cleanup(RERR_MESSAGEIO);
 
 	buf[len] = 0;
 
-	if (code == FLOG) {
-		if (am_daemon) logit(LOG_INFO, buf);
+	if (am_server && msg_fd_out >= 0) {
+		/* Pass the message to our sibling. */
+		send_msg((enum msgcode)code, buf, len);
 		return;
 	}
 
-	if (am_server) {
-		/* Pass it to non-server side, perhaps through our sibling. */
-		if (msg_fd_out >= 0) {
-			send_msg((enum msgcode)code, buf, len);
-			return;
-		}
-		if (!am_daemon
-		    && io_multiplex_write((enum msgcode)code, buf, len))
-			return;
-	}
-
-	/* otherwise, if in daemon mode and either we are not a server
-	 *  (that is, we are not running --daemon over a remote shell) or
-	 *  the log has already been initialised, log the message on this
-	 *  side because we don't want the client to see most errors for
-	 *  security reasons.  We do want early messages when running daemon
-	 *  mode over a remote shell to go to the remote side; those will
-	 *  fall through to the next case.
-	 * Note that this is only for the time before multiplexing is enabled.
-	 */
-	if (am_daemon && (!am_server || log_initialised)) {
-		static int depth;
-		int priority = LOG_INFO;
-		if (code == FERROR) priority = LOG_WARNING;
-
-		if (depth) return;
-
-		depth++;
+	if (am_daemon) {
+		static int in_block;
+		char msg[2048];
+		int priority = code == FERROR ? LOG_WARNING : LOG_INFO;
 
-		log_init();
-		logit(priority, buf);
+		if (in_block)
+			return;
+		in_block = 1;
+		if (!log_initialised)
+			log_init();
+		strlcpy(msg, buf, MIN((int)sizeof msg, len + 1));
+		logit(priority, msg);
+		in_block = 0;
 
-		depth--;
+		if (code == FLOG || !am_server)
+			return;
+	} else if (code == FLOG)
 		return;
+
+	if (am_server) {
+		/* Pass the message to the non-server side. */
+		if (io_multiplex_write((enum msgcode)code, buf, len))
+			return;
+		if (am_daemon) {
+			/* TODO: can we send the error to the user somehow? */
+			return;
+		}
 	}
 
 	if (code == FERROR) {
 		log_got_error = 1;
 		f = stderr;
 	}
 
-	if (code == FINFO) {
-		if (am_server)
-			f = stderr;
-		else
-			f = stdout;
-	}
+	if (code == FINFO)
+		f = am_server ? stderr : stdout;
 
-	if (!f) exit_cleanup(RERR_MESSAGEIO);
+	if (!f)
+		exit_cleanup(RERR_MESSAGEIO);
 
-	if (fwrite(buf, len, 1, f) != 1) exit_cleanup(RERR_MESSAGEIO);
+	if (fwrite(buf, len, 1, f) != 1)
+		exit_cleanup(RERR_MESSAGEIO);
 
-	if (buf[len-1] == '\r' || buf[len-1] == '\n') fflush(f);
+	if (buf[len-1] == '\r' || buf[len-1] == '\n')
+		fflush(f);
 }
 		
 
 /* This is the rsync debugging function. Call it with FINFO, FERROR or
  * FLOG. */
 void rprintf(enum logcode code, const char *format, ...)
 {
 	va_list ap;
-	char buf[1024];
-	int len;
+	char buf[MAXPATHLEN+512];
+	size_t len;
 
 	va_start(ap, format);
-	/* Note: might return -1 */
 	len = vsnprintf(buf, sizeof(buf), format, ap);
 	va_end(ap);
 
 	/* Deal with buffer overruns.  Instead of panicking, just
-	 * truncate the resulting string.  Note that some vsnprintf()s
-	 * return -1 on truncation, e.g., glibc 2.0.6 and earlier. */
-	if ((size_t) len > sizeof(buf)-1  ||  len < 0) {
+	 * truncate the resulting string.  (Note that configure ensures
+	 * that we have a vsnprintf() that doesn't ever return -1.) */
+	if (len > sizeof buf - 1) {
 		const char ellipsis[] = "[...]";
 
 		/* Reset length, and zero-terminate the end of our buffer */
 		len = sizeof(buf)-1;
 		buf[len] = '\0';
 
@@ -283,39 +276,29 @@
  *
  * Note that since strerror might involve dynamically loading a
  * message catalog we need to call it once before chroot-ing. */
 void rsyserr(enum logcode code, int errcode, const char *format, ...)
 {
 	va_list ap;
-	char buf[1024];
-	int len;
-	size_t sys_len;
-	char *sysmsg;
+	char buf[MAXPATHLEN+512];
+	size_t len;
+
+	strcpy(buf, RSYNC_NAME ": ");
+	len = (sizeof RSYNC_NAME ": ") - 1;
 
 	va_start(ap, format);
-	/* Note: might return <0 */
-	len = vsnprintf(buf, sizeof(buf), format, ap);
+	len += vsnprintf(buf + len, sizeof buf - len, format, ap);
 	va_end(ap);
 
-	/* TODO: Put in RSYNC_NAME at the start. */
-
-	if ((size_t) len > sizeof(buf)-1)
-		exit_cleanup(RERR_MESSAGEIO);
-
-	sysmsg = strerror(errcode);
-	sys_len = strlen(sysmsg);
-	if ((size_t) len + 3 + sys_len > sizeof(buf) - 1)
+	if (len < sizeof buf) {
+		len += snprintf(buf + len, sizeof buf - len,
+				": %s (%d)\n", strerror(errcode), errcode);
+	}
+	if (len >= sizeof buf)
 		exit_cleanup(RERR_MESSAGEIO);
 
-	strcpy(buf + len, ": ");
-	len += 2;
-	strcpy(buf + len, sysmsg);
-	len += sys_len;
-	strcpy(buf + len, "\n");
-	len++;
-
 	rwrite(code, buf, len);
 }
 
 
 
 void rflush(enum logcode code)
@@ -361,14 +344,15 @@
 
 	/* We expand % codes one by one in place in buf.  We don't
 	 * copy in the terminating nul of the inserted strings, but
 	 * rather keep going until we reach the nul of the format.
 	 * Just to make sure we don't clobber that nul and therefore
 	 * accidentally keep going, we zero the buffer now. */
-	memset(buf, 0, sizeof buf);
-	strlcpy(buf, format, sizeof(buf));
+	l = strlcpy(buf, format, sizeof buf);
+	if (l < sizeof buf)
+		memset(buf + l, 0, sizeof buf - l);
 	
 	for (s = &buf[0]; s && (p = strchr(s,'%')); ) {
 		n = NULL;
 		s = p + 1;
 
 		switch (p[1]) {
@@ -386,13 +370,13 @@
 			break;
 		case 'o': n = op; break;
 		case 'f':
 			pathjoin(buf2, sizeof buf2,
 				 file->basedir ? file->basedir : "",
 				 f_name(file));
-			clean_fname(buf2);
+			clean_fname(buf2, 0);
 			n = buf2;
 			if (*n == '/') n++;
 			break;
 		case 'm': n = lp_name(module_id); break;
 		case 't': n = timestring(time(NULL)); break;
 		case 'P': n = lp_path(module_id); break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/main.c	2004-02-10 11:54:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/main.c	2004-09-30 01:58:07.000000000 +0800
@@ -40,26 +40,31 @@
 extern int dry_run;
 extern int list_only;
 extern int local_server;
 extern int log_got_error;
 extern int module_id;
 extern int orig_umask;
+extern int copy_links;
+extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int protocol_version;
 extern int recurse;
 extern int relative_paths;
 extern int rsync_port;
+extern int whole_file;
 extern int read_batch;
 extern int write_batch;
+extern int batch_fd;
+extern int batch_gen_fd;
 extern int filesfrom_fd;
 extern pid_t cleanup_child_pid;
 extern char *files_from;
 extern char *remote_filesfrom_file;
 extern char *rsync_path;
 extern char *shell_cmd;
-extern struct file_list *batch_flist;
+extern char *batch_name;
 
 
 /* there's probably never more than at most 2 outstanding child processes,
  * but set it higher just in case.
  */
 #define MAXCHILDPROCS 5
@@ -81,13 +86,13 @@
 
 	while ((waited_pid = waitpid(pid, status, WNOHANG)) == 0) {
 		msleep(20);
 		io_flush(FULL_FLUSH);
 	}
 
-	if ((waited_pid == -1) && (errno == ECHILD)) {
+	if (waited_pid == -1 && errno == ECHILD) {
 		/* status of requested child no longer available.
 		 * check to see if it was processed by the sigchld_handler.
 		 */
 		for (cnt = 0;  cnt < MAXCHILDPROCS; cnt++) {
 			if (pid == pid_stat_table[cnt].pid) {
 				*status = pid_stat_table[cnt].status;
@@ -102,14 +107,25 @@
 	 * message describing the purpose of the child.  Also indicate
 	 * this to the caller so that thhey know something went
 	 * wrong.  */
 	*status = WEXITSTATUS(*status);
 }
 
+/* This function gets called from all 3 processes.  We want the client side
+ * to actually output the text, but the sender is the only process that has
+ * all the stats we need.  So, if we're a client sender, we do the report.
+ * If we're a server sender, we write the stats on the supplied fd.  If
+ * we're the client receiver we read the stats from the supplied fd and do
+ * the report.  All processes might also generate a set of debug stats, if
+ * the verbose level is high enough (this is the only thing that the
+ * generator process and the server receiver ever do here). */
 static void report(int f)
 {
+	/* Cache two stats because the read/write code can change it. */
+	int64 total_read = stats.total_read;
+	int64 total_written = stats.total_written;
 	time_t t = time(NULL);
 
 	if (do_stats && verbose > 1) {
 		/* These come out from every process */
 		show_malloc_stats();
 		show_flist_stats();
@@ -117,37 +133,39 @@
 
 	if (am_generator)
 		return;
 
 	if (am_daemon) {
 		log_exit(0, __FILE__, __LINE__);
-		if (f == -1 || !am_sender) return;
+		if (f == -1 || !am_sender)
+			return;
 	}
 
 	if (am_server) {
 		if (am_sender) {
-			int64 w;
-			/* store total_written in a temporary
-			 * because write_longint changes it */
-			w = stats.total_written;
-			write_longint(f,stats.total_read);
-			write_longint(f,w);
-			write_longint(f,stats.total_size);
+			write_longint(f, total_read);
+			write_longint(f, total_written);
+			write_longint(f, stats.total_size);
 		}
 		return;
 	}
 
 	/* this is the client */
 
 	if (!am_sender) {
-		int64 r;
-		stats.total_written = read_longint(f);
-		/* store total_read in a temporary, read_longint changes it */
-		r = read_longint(f);
+		/* Read the first two in opposite order because the meaning of
+		 * read/write swaps when switching from sender to receiver. */
+		total_written = read_longint(f);
+		total_read = read_longint(f);
 		stats.total_size = read_longint(f);
-		stats.total_read = r;
+	} else if (write_batch) {
+		/* The --read-batch process is going to be a client
+		 * receiver, so we need to give it the stats. */
+		write_longint(batch_fd, total_read);
+		write_longint(batch_fd, total_written);
+		write_longint(batch_fd, stats.total_size);
 	}
 
 	if (do_stats) {
 		rprintf(FINFO,"\nNumber of files: %d\n", stats.num_files);
 		rprintf(FINFO,"Number of files transferred: %d\n",
 			stats.num_transferred_files);
@@ -157,26 +175,26 @@
 			(double)stats.total_transferred_size);
 		rprintf(FINFO,"Literal data: %.0f bytes\n",
 			(double)stats.literal_data);
 		rprintf(FINFO,"Matched data: %.0f bytes\n",
 			(double)stats.matched_data);
 		rprintf(FINFO,"File list size: %d\n", stats.flist_size);
-		rprintf(FINFO,"Total bytes written: %.0f\n",
-			(double)stats.total_written);
-		rprintf(FINFO,"Total bytes read: %.0f\n",
-			(double)stats.total_read);
+		rprintf(FINFO,"Total bytes sent: %.0f\n",
+			(double)total_written);
+		rprintf(FINFO,"Total bytes received: %.0f\n",
+			(double)total_read);
 	}
 
 	if (verbose || do_stats) {
-		rprintf(FINFO,"\nwrote %.0f bytes  read %.0f bytes  %.2f bytes/sec\n",
-			(double)stats.total_written,
-			(double)stats.total_read,
-			(stats.total_written+stats.total_read)/(0.5 + (t-starttime)));
-		rprintf(FINFO,"total size is %.0f  speedup is %.2f\n",
+		rprintf(FINFO,
+			"\nsent %.0f bytes  received %.0f bytes  %.2f bytes/sec\n",
+			(double)total_written, (double)total_read,
+			(total_written + total_read)/(0.5 + (t - starttime)));
+		rprintf(FINFO, "total size is %.0f  speedup is %.2f\n",
 			(double)stats.total_size,
-			(1.0*stats.total_size)/(stats.total_written+stats.total_read));
+			(double)stats.total_size / (total_written+total_read));
 	}
 
 	fflush(stdout);
 	fflush(stderr);
 }
 
@@ -214,13 +232,13 @@
 
 /* Start the remote shell.   cmd may be NULL to use the default. */
 static pid_t do_cmd(char *cmd, char *machine, char *user, char *path,
 		    int *f_in, int *f_out)
 {
 	int i, argc = 0;
-	char *args[100];
+	char *args[MAX_ARGS];
 	pid_t ret;
 	char *tok, *dir = NULL;
 	int dash_l_set = 0;
 
 	if (!read_batch && !local_server) {
 		char *rsh_env = getenv(RSYNC_RSH_ENV);
@@ -229,14 +247,20 @@
 		if (!cmd)
 			cmd = RSYNC_RSH;
 		cmd = strdup(cmd);
 		if (!cmd)
 			goto oom;
 
-		for (tok = strtok(cmd, " "); tok; tok = strtok(NULL, " "))
+		for (tok = strtok(cmd, " "); tok; tok = strtok(NULL, " ")) {
+			/* Comparison leaves rooms for server_options(). */
+			if (argc >= MAX_ARGS - 100) {
+				rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
+				exit_cleanup(RERR_SYNTAX);
+			}
 			args[argc++] = tok;
+		}
 
 		/* check to see if we've already been given '-l user' in
 		 * the remote-shell command */
 		for (i = 0; i < argc-1; i++) {
 			if (!strcmp(args[i], "-l") && args[i+1][0] != '-')
 				dash_l_set = 1;
@@ -267,42 +291,54 @@
 				cp = cmd;
 			if (strcmp(cp, "rsh") == 0 || strcmp(cp, "remsh") == 0)
 				blocking_io = 1;
 		}
 
 		server_options(args,&argc);
+
+		if (argc >= MAX_ARGS - 2) {
+			rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
+			exit_cleanup(RERR_SYNTAX);
+		}
 	}
 
 	args[argc++] = ".";
 
 	if (!daemon_over_rsh && path && *path)
 		args[argc++] = path;
 
-	if (argc >= (int)(sizeof args / sizeof args[0])) {
-		rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
-		exit_cleanup(RERR_MALLOC); /* XXX Need better RERR? */
-	}
-
 	args[argc] = NULL;
 
 	if (verbose > 3) {
 		rprintf(FINFO,"cmd=");
-		for (i=0;i<argc;i++)
+		for (i = 0; i < argc; i++)
 			rprintf(FINFO,"%s ",args[i]);
 		rprintf(FINFO,"\n");
 	}
 
-	if (local_server) {
-		if (read_batch)
-			create_flist_from_batch(); /* sets batch_flist */
+	if (read_batch) {
+		int from_gen_pipe[2];
+		if (fd_pair(from_gen_pipe) < 0) {
+			rsyserr(FERROR, errno, "pipe");
+			exit_cleanup(RERR_IPC);
+		}
+		batch_gen_fd = from_gen_pipe[0];
+		*f_out = from_gen_pipe[1];
+		*f_in = batch_fd;
+		ret = -1; /* no child pid */
+	} else if (local_server) {
+		/* If the user didn't request --[no-]whole-file, force
+		 * it on, but only if we're not batch processing. */
+		if (whole_file < 0 && !write_batch)
+			whole_file = 1;
 		ret = local_child(argc, args, f_in, f_out, child_main);
-	} else {
+	} else
 		ret = piped_child(args,f_in,f_out);
-	}
 
-	if (dir) free(dir);
+	if (dir)
+		free(dir);
 
 	return ret;
 
 oom:
 	out_of_memory("do_cmd");
 	return 0; /* not reached */
@@ -321,14 +357,14 @@
 	if (!name)
 		return NULL;
 
 	if (do_stat(name,&st) == 0) {
 		if (S_ISDIR(st.st_mode)) {
 			if (!push_dir(name)) {
-				rprintf(FERROR, "push_dir %s failed: %s (1)\n",
-					full_fname(name), strerror(errno));
+				rsyserr(FERROR, errno, "push_dir#1 %s failed",
+					full_fname(name));
 				exit_cleanup(RERR_FILESELECT);
 			}
 			return NULL;
 		}
 		if (flist->count > 1) {
 			rprintf(FERROR,"ERROR: destination must be a directory when copying more than 1 file\n");
@@ -338,23 +374,26 @@
 	}
 
 	if (flist->count <= 1 && ((e = strlen(name)) <= 1 || name[e-1] != '/'))
 		return name;
 
 	if (do_mkdir(name,0777 & ~orig_umask) != 0) {
-		rprintf(FERROR, "mkdir %s failed: %s\n",
-			full_fname(name), strerror(errno));
+		rsyserr(FERROR, errno, "mkdir %s failed", full_fname(name));
 		exit_cleanup(RERR_FILEIO);
-	} else {
-		if (verbose > 0)
-			rprintf(FINFO,"created directory %s\n",name);
+	}
+	if (verbose > 0)
+		rprintf(FINFO, "created directory %s\n", name);
+
+	if (dry_run) {
+		dry_run++;
+		return NULL;
 	}
 
 	if (!push_dir(name)) {
-		rprintf(FERROR, "push_dir %s failed: %s (2)\n",
-			full_fname(name), strerror(errno));
+		rsyserr(FERROR, errno, "push_dir#2 %s failed",
+			full_fname(name));
 		exit_cleanup(RERR_FILESELECT);
 	}
 
 	return NULL;
 }
 
@@ -367,41 +406,48 @@
 
 	if (verbose > 2) {
 		rprintf(FINFO, "server_sender starting pid=%ld\n",
 			(long)getpid());
 	}
 
+	if (am_daemon && lp_write_only(module_id)) {
+		rprintf(FERROR, "ERROR: module is write only\n");
+		exit_cleanup(RERR_SYNTAX);
+		return;
+	}
+
 	if (!relative_paths && !push_dir(dir)) {
-		rprintf(FERROR, "push_dir %s failed: %s (3)\n",
-			full_fname(dir), strerror(errno));
+		rsyserr(FERROR, errno, "push_dir#3 %s failed",
+			full_fname(dir));
 		exit_cleanup(RERR_FILESELECT);
 	}
 	argc--;
 	argv++;
 
 	if (strcmp(dir,".")) {
 		int l = strlen(dir);
 		if (strcmp(dir,"/") == 0)
 			l = 0;
-		for (i=0;i<argc;i++)
+		for (i = 0; i < argc; i++)
 			argv[i] += l+1;
 	}
 
 	if (argc == 0 && recurse) {
-		argc=1;
+		argc = 1;
 		argv--;
 		argv[0] = ".";
 	}
 
 	flist = send_file_list(f_out,argc,argv);
 	if (!flist || flist->count == 0) {
 		exit_cleanup(0);
 	}
 
-	io_start_buffering_in(f_in);
-	io_start_buffering_out(f_out);
+	io_start_buffering_in();
+	io_start_buffering_out();
+
 	send_files(flist,f_out,f_in);
 	io_flush(FULL_FLUSH);
 	report(f_out);
 	if (protocol_version >= 24) {
 		/* final goodbye message */
 		read_int(f_in);
@@ -411,38 +457,42 @@
 }
 
 
 static int do_recv(int f_in,int f_out,struct file_list *flist,char *local_name)
 {
 	int pid;
-	int status=0;
+	int status = 0;
 	int error_pipe[2];
 
+	/* The receiving side mustn't obey this, or an existing symlink that
+	 * points to an identical file won't be replaced by the referent. */
+	copy_links = 0;
+
 	if (preserve_hard_links)
 		init_hard_links(flist);
 
 	if (!delete_after) {
 		/* I moved this here from recv_files() to prevent a race condition */
-		if (recurse && delete_mode && !local_name && flist->count>0) {
+		if (recurse && delete_mode && !local_name && flist->count > 0)
 			delete_files(flist);
-		}
 	}
 
 	if (fd_pair(error_pipe) < 0) {
 		rprintf(FERROR,"error pipe failed in do_recv\n");
 		exit_cleanup(RERR_SOCKETIO);
 	}
 
 	io_flush(NORMAL_FLUSH);
 
-	if ((pid=do_fork()) == 0) {
+	if ((pid = do_fork()) == 0) {
 		close(error_pipe[0]);
-		if (f_in != f_out) close(f_out);
+		if (f_in != f_out)
+			close(f_out);
 
 		/* we can't let two processes write to the socket at one time */
-		io_multiplexing_close();
+		close_multiplexing_out();
 
 		/* set place to send errors */
 		set_msg_fd_out(error_pipe[1]);
 
 		recv_files(f_in,flist,local_name);
 		io_flush(FULL_FLUSH);
@@ -455,17 +505,21 @@
 		 * some OSes a signal won't interrupt a sleep! */
 		while (1)
 			msleep(20);
 	}
 
 	am_generator = 1;
+	close_multiplexing_in();
+	if (write_batch)
+		stop_write_batch();
 
 	close(error_pipe[1]);
-	if (f_in != f_out) close(f_in);
+	if (f_in != f_out)
+		close(f_in);
 
-	io_start_buffering_out(f_out);
+	io_start_buffering_out();
 
 	set_msg_fd_in(error_pipe[0]);
 
 	generate_files(f_out, flist, local_name);
 
 	get_redo_num(); /* Read final MSG_DONE and any prior messages. */
@@ -493,56 +547,54 @@
 
 	if (verbose > 2) {
 		rprintf(FINFO, "server_recv(%d) starting pid=%ld\n",
 			argc, (long)getpid());
 	}
 
-	if (am_daemon && lp_read_only(module_id) && !am_sender) {
+	if (am_daemon && lp_read_only(module_id)) {
 		rprintf(FERROR,"ERROR: module is read only\n");
 		exit_cleanup(RERR_SYNTAX);
 		return;
 	}
 
 
 	if (argc > 0) {
 		dir = argv[0];
 		argc--;
 		argv++;
 		if (!am_daemon && !push_dir(dir)) {
-			rprintf(FERROR, "push_dir %s failed: %s (4)\n",
-				full_fname(dir), strerror(errno));
+			rsyserr(FERROR, errno, "push_dir#4 %s failed",
+				full_fname(dir));
 			exit_cleanup(RERR_FILESELECT);
 		}
 	}
 
-	io_start_buffering_in(f_in);
+	io_start_buffering_in();
 	if (delete_mode && !delete_excluded)
 		recv_exclude_list(f_in);
 
 	if (filesfrom_fd >= 0) {
 		/* We're receiving the file info from the sender, so we need
 		 * the IO routines to automatically write out the names onto
 		 * our f_out socket as we read the list info from the sender.
 		 * This avoids both deadlock and extra delays/buffers. */
 		io_set_filesfrom_fds(filesfrom_fd, f_out);
 		filesfrom_fd = -1;
 	}
 
-	if (read_batch)
-		flist = batch_flist;
-	else
-		flist = recv_file_list(f_in);
+	flist = recv_file_list(f_in);
 	if (!flist) {
 		rprintf(FERROR,"server_recv: recv_file_list error\n");
 		exit_cleanup(RERR_FILESELECT);
 	}
 
 	if (argc > 0) {
 		if (strcmp(dir,".")) {
 			argv[0] += strlen(dir);
-			if (argv[0][0] == '/') argv[0]++;
+			if (argv[0][0] == '/')
+				argv[0]++;
 		}
 		local_name = get_local_name(flist,argv[0]);
 	}
 
 	status = do_recv(f_in,f_out,flist,local_name);
 	exit_cleanup(status);
@@ -555,26 +607,27 @@
 	return 0;
 }
 
 
 void start_server(int f_in, int f_out, int argc, char *argv[])
 {
-	setup_protocol(f_out, f_in);
-
 	set_nonblocking(f_in);
 	set_nonblocking(f_out);
 
+	io_set_sock_fds(f_in, f_out);
+	setup_protocol(f_out, f_in);
+
 	if (protocol_version >= 23)
-		io_start_multiplex_out(f_out);
+		io_start_multiplex_out();
 
 	if (am_sender) {
-		if (!read_batch) {
-			recv_exclude_list(f_in);
-			if (cvs_exclude)
-				add_cvs_excludes();
-		}
+		keep_dirlinks = 0; /* Must be disabled on the sender. */
+
+		recv_exclude_list(f_in);
+		if (cvs_exclude)
+			add_cvs_excludes();
 		do_server_sender(f_in, f_out, argc, argv);
 	} else {
 		do_server_recv(f_in, f_out, argc, argv);
 	}
 	exit_cleanup(0);
 }
@@ -588,31 +641,47 @@
 {
 	struct file_list *flist = NULL;
 	int status = 0, status2 = 0;
 	char *local_name = NULL;
 
 	cleanup_child_pid = pid;
-	if (read_batch)
-		flist = batch_flist;
-
-	set_nonblocking(f_in);
-	set_nonblocking(f_out);
+	if (read_batch) {
+		assert(am_sender == 0);
+	} else {
+		set_nonblocking(f_in);
+		set_nonblocking(f_out);
+	}
 
+	io_set_sock_fds(f_in, f_out);
 	setup_protocol(f_out,f_in);
 
-	if (protocol_version >= 23)
-		io_start_multiplex_in(f_in);
+	if (protocol_version >= 23 && !read_batch)
+		io_start_multiplex_in();
+
+	/* We set our stderr file handle to blocking because ssh might have
+	 * set it to non-blocking.  This can be particularly troublesome if
+	 * stderr is a clone of stdout, because ssh would have set our stdout
+	 * to non-blocking at the same time (which can easily cause us to lose
+	 * output from our print statements).  This kluge shouldn't cause ssh
+	 * any problems for how we use it.  Note also that we delayed setting
+	 * this until after the above protocol setup so that we know for sure
+	 * that ssh is done twiddling its file descriptors.  */
+	set_blocking(STDERR_FILENO);
 
 	if (am_sender) {
-		io_start_buffering_out(f_out);
+		keep_dirlinks = 0; /* Must be disabled on the sender. */
+		io_start_buffering_out();
 		if (cvs_exclude)
 			add_cvs_excludes();
 		if (delete_mode && !delete_excluded)
 			send_exclude_list(f_out);
 		if (remote_filesfrom_file)
 			filesfrom_fd = f_in;
+
+		if (write_batch)
+			start_write_batch(f_out);
 		if (!read_batch) /* don't write to pipe */
 			flist = send_file_list(f_out,argc,argv);
 		if (verbose > 3)
 			rprintf(FINFO,"file list sent\n");
 
 		io_flush(NORMAL_FLUSH);
@@ -630,24 +699,25 @@
 		}
 		report(-1);
 		io_flush(FULL_FLUSH);
 		exit_cleanup(status);
 	}
 
-	if (argc == 0) {
+	if (argc == 0)
 		list_only = 1;
-	}
 
-	if (!write_batch)
+	if (!read_batch)
 		send_exclude_list(f_out);
 
 	if (filesfrom_fd >= 0) {
 		io_set_filesfrom_fds(filesfrom_fd, f_out);
 		filesfrom_fd = -1;
 	}
 
+	if (write_batch)
+		start_write_batch(f_in);
 	flist = recv_file_list(f_in);
 	if (!flist || flist->count == 0) {
 		rprintf(FINFO, "client: nothing to do: "
 			"perhaps you need to specify some filenames or "
 			"the --recursive option?\n");
 		exit_cleanup(0);
@@ -705,98 +775,108 @@
 	/* Don't clobber argv[] so that ps(1) can still show the right
 	 * command line. */
 	if ((rc = copy_argv(argv)))
 		return rc;
 
 	/* rsync:// always uses rsync server over direct socket connection */
-	if (strncasecmp(URL_PREFIX, argv[0], strlen(URL_PREFIX)) == 0) {
+	if (strncasecmp(URL_PREFIX, argv[0], strlen(URL_PREFIX)) == 0
+	    && !read_batch) {
 		char *host, *path;
 
 		host = argv[0] + strlen(URL_PREFIX);
 		p = strchr(host,'/');
 		if (p) {
-			*p = 0;
+			*p = '\0';
 			path = p+1;
-		} else {
+		} else
 			path = "";
-		}
-		p = strchr(host,':');
+		if (*host == '[' && (p = strchr(host, ']')) != NULL) {
+			host++;
+			*p++ = '\0';
+			if (*p != ':')
+				p = NULL;
+		} else
+			p = strchr(host, ':');
 		if (p) {
 			rsync_port = atoi(p+1);
-			*p = 0;
+			*p = '\0';
 		}
 		return start_socket_client(host, path, argc-1, argv+1);
 	}
 
-	if (!read_batch) {
+	if (!read_batch) { /* for read_batch, NO source is specified */
 		p = find_colon(argv[0]);
-		if (p) {
+		if (p) { /* source is remote */
 			if (remote_filesfrom_file
 			 && remote_filesfrom_file != files_from + 1
 			 && strncmp(files_from, argv[0], p-argv[0]+1) != 0) {
 				rprintf(FERROR,
-					"--files-from hostname is not transfer hostname\n");
+					"--files-from hostname is not the same as the transfer hostname\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
 			if (p[1] == ':') { /* double colon */
 				*p = 0;
 				if (!shell_cmd) {
 					return start_socket_client(argv[0], p+2,
 								   argc-1, argv+1);
 				}
 				p++;
 				daemon_over_rsh = 1;
 			}
 
-			if (argc < 1) {
+			if (argc < 1) { /* destination required */
 				usage(FERROR);
 				exit_cleanup(RERR_SYNTAX);
 			}
 
 			am_sender = 0;
 			*p = 0;
 			shell_machine = argv[0];
 			shell_path = p+1;
-			argc--;
 			argv++;
-		} else {
+		} else { /* source is local */
 			am_sender = 1;
 
 			/* rsync:// destination uses rsync server over direct socket */
 			if (strncasecmp(URL_PREFIX, argv[argc-1], strlen(URL_PREFIX)) == 0) {
 				char *host, *path;
 
 				host = argv[argc-1] + strlen(URL_PREFIX);
 				p = strchr(host,'/');
 				if (p) {
-					*p = 0;
+					*p = '\0';
 					path = p+1;
-				} else {
+				} else
 					path = "";
-				}
-				p = strchr(host,':');
+				if (*host == '[' && (p = strchr(host, ']')) != NULL) {
+					host++;
+					*p++ = '\0';
+					if (*p != ':')
+						p = NULL;
+				} else
+					p = strchr(host, ':');
 				if (p) {
 					rsync_port = atoi(p+1);
-					*p = 0;
+					*p = '\0';
 				}
 				return start_socket_client(host, path, argc-1, argv);
 			}
 
-			p = find_colon(argv[argc-1]);
+			p = find_colon(argv[argc-1]); /* look in dest arg */
 			if (p && remote_filesfrom_file
 			 && remote_filesfrom_file != files_from + 1
 			 && strncmp(files_from, argv[argc-1], p-argv[argc-1]+1) != 0) {
 				rprintf(FERROR,
-					"--files-from hostname is not transfer hostname\n");
+					"--files-from hostname is not the same as the transfer hostname\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
-			if (!p) {
+			if (!p) { /* no colon found, so src & dest are local */
 				local_server = 1;
 				if (remote_filesfrom_file) {
 					rprintf(FERROR,
-						"--files-from is remote but transfer is local\n");
+						"--files-from cannot be remote when the transfer is local\n");
 					exit_cleanup(RERR_SYNTAX);
 				}
 			} else if (p[1] == ':') { /* double colon */
 				*p = 0;
 				if (!shell_cmd) {
 					return start_socket_client(argv[argc-1], p+2,
@@ -816,18 +896,21 @@
 				shell_path = argv[argc-1];
 			} else {
 				*p = 0;
 				shell_machine = argv[argc-1];
 				shell_path = p+1;
 			}
-			argc--;
 		}
-	} else {
-		am_sender = 1;
+		argc--;
+	} else {  /* read_batch */
 		local_server = 1;
 		shell_path = argv[argc-1];
+		if (find_colon(shell_path)) {
+			rprintf(FERROR, "remote destination is not allowed with --read-batch\n");
+			exit_cleanup(RERR_SYNTAX);
+		}
 	}
 
 	if (shell_machine) {
 		p = strrchr(shell_machine,'@');
 		if (p) {
 			*p = 0;
@@ -841,18 +924,20 @@
 			shell_cmd?shell_cmd:"",
 			shell_machine?shell_machine:"",
 			shell_user?shell_user:"",
 			shell_path?shell_path:"");
 	}
 
+	/* for remote source, only single dest arg can remain ... */
 	if (!am_sender && argc > 1) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
-	if (argc == 0 && !am_sender) {
+	/* ... or no dest at all */
+	if (!am_sender && argc == 0) {
 		list_only = 1;
 	}
 
 	pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,
 		     &f_in,&f_out);
 
@@ -962,17 +1047,14 @@
 #endif
 
 
 int main(int argc,char *argv[])
 {
 	int ret;
-	int orig_argc;
-	char **orig_argv;
-
-	orig_argc = argc;
-	orig_argv = argv;
+	int orig_argc = argc;
+	char **orig_argv = argv;
 
 	signal(SIGUSR1, sigusr1_handler);
 	signal(SIGUSR2, sigusr2_handler);
 	signal(SIGCHLD, sigchld_handler);
 #ifdef MAINTAINER_MODE
 	signal(SIGSEGV, rsync_panic_handler);
@@ -1015,14 +1097,30 @@
 	 * work when there are other child processes.  Also, on all systems
 	 * that implement getcwd that way "pwd" can't be found after chroot. */
 	push_dir(NULL);
 
 	init_flist();
 
-	if (write_batch && !am_server) {
-		write_batch_argvs_file(orig_argc, orig_argv);
+	if (write_batch || read_batch) {
+		if (write_batch)
+			write_batch_shell_file(orig_argc, orig_argv, argc);
+
+		if (read_batch && strcmp(batch_name, "-") == 0)
+			batch_fd = STDIN_FILENO;
+		else {
+			batch_fd = do_open(batch_name,
+				   write_batch ? O_WRONLY | O_CREAT | O_TRUNC
+				   : O_RDONLY, S_IRUSR | S_IWUSR);
+		}
+		if (batch_fd < 0) {
+			rsyserr(FERROR, errno, "Batch file %s open error",
+				batch_name);
+			exit_cleanup(RERR_FILEIO);
+		}
+		if (read_batch)
+			read_stream_flags(batch_fd);
 	}
 
 	if (am_daemon && !am_server)
 		return daemon_main();
 
 	if (argc < 1) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/Makefile.in	2004-02-11 01:06:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/Makefile.in	2004-08-13 02:59:03.000000000 +0800
@@ -41,78 +41,82 @@
 	popt/popthelp.o popt/poptparse.o
 OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
 
 TLS_OBJ = tls.o syscall.o lib/permstring.o
 
 # Programs we must have to run the test cases
-CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) \
+CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) getfsdev$(EXEEXT) \
 	trimslash$(EXEEXT) t_unsafe$(EXEEXT) wildtest$(EXEEXT)
 
 # Objects for CHECK_PROGS to clean
-CHECK_OBJS=getgroups.o t_stub.o t_unsafe.o trimslash.o wildtest.o
+CHECK_OBJS=getgroups.o getfsdev.o t_stub.o t_unsafe.o trimslash.o wildtest.o
 
 # note that the -I. is needed to handle config.h when using VPATH
 .c.o:
 @OBJ_SAVE@
 	$(CC) -I. -I$(srcdir) $(CFLAGS) $(CPPFLAGS) -c $< @CC_SHOBJ_FLAG@
 @OBJ_RESTORE@
 
 all: rsync$(EXEEXT)
 
-man: rsync.1 rsyncd.conf.5
-
 install: all
 	-mkdir -p ${DESTDIR}${bindir}
-	${INSTALLCMD} ${STRIP} -m 755 rsync$(EXEEXT) ${DESTDIR}${bindir}
+	${INSTALLCMD} ${INSTALL_STRIP} -m 755 rsync$(EXEEXT) ${DESTDIR}${bindir}
 	-mkdir -p ${DESTDIR}${mandir}/man1
 	-mkdir -p ${DESTDIR}${mandir}/man5
 	${INSTALLMAN} -m 644 $(srcdir)/rsync.1 ${DESTDIR}${mandir}/man1
 	${INSTALLMAN} -m 644 $(srcdir)/rsyncd.conf.5 ${DESTDIR}${mandir}/man5
 
 install-strip:
-	$(MAKE) STRIP='-s' install
+	$(MAKE) INSTALL_STRIP='-s' install
 
 rsync$(EXEEXT): $(OBJS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
 
 $(OBJS): $(HEADERS)
 
 tls$(EXEEXT): $(TLS_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TLS_OBJ) $(LIBS)
 
 getgroups$(EXEEXT): getgroups.o
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getgroups.o $(LIBS)
 
+getfsdev$(EXEEXT): getfsdev.o
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getfsdev.o $(LIBS)
+
 TRIMSLASH_OBJ = trimslash.o syscall.o
 trimslash$(EXEEXT): $(TRIMSLASH_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
 
 T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o t_stub.o lib/compat.o lib/snprintf.o
 t_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(T_UNSAFE_OBJ) $(LIBS)
 
-# I don't like these rules because CVS can skew the timestamps and
-# produce spurious warnings, and also make "make install" fail if the
-# source directory can no longer be found.  Since we don't rebuild
-# automatically they're kind of lame anyhow.
-
-#Makefile: Makefile.in configure config.status
-#	echo "WARNING: You need to run ./config.status --recheck"
-
-# don't actually run autoconf, just issue a warning
-#configure: configure.in
-#	echo "WARNING: you need to rerun autoconf"
+gen: $(srcdir)/configure $(srcdir)/config.h.in proto man
+
+man: $(srcdir)/rsync.1 $(srcdir)/rsyncd.conf.5
+
+$(srcdir)/configure: $(srcdir)/configure.in $(srcdir)/aclocal.m4
+	cd $(srcdir); autoconf
+
+$(srcdir)/config.h.in: $(srcdir)/configure.in $(srcdir)/aclocal.m4
+	cd $(srcdir); autoheader
 
 $(srcdir)/rsync.1: $(srcdir)/rsync.yo
 	yodl2man -o $(srcdir)/rsync.1 $(srcdir)/rsync.yo
 
 $(srcdir)/rsyncd.conf.5: $(srcdir)/rsyncd.conf.yo
 	yodl2man -o $(srcdir)/rsyncd.conf.5 $(srcdir)/rsyncd.conf.yo
 
 proto:
-	cat $(srcdir)/*.c $(srcdir)/lib/compat.c | awk -f $(srcdir)/mkproto.awk > $(srcdir)/proto.h
+	cat $(srcdir)/*.c $(srcdir)/lib/compat.c | awk -f $(srcdir)/mkproto.awk >$(srcdir)/proto.h.new
+	if diff $(srcdir)/proto.h $(srcdir)/proto.h.new >/dev/null; then \
+	  rm $(srcdir)/proto.h.new; \
+	else \
+	  mv $(srcdir)/proto.h.new $(srcdir)/proto.h; \
+	fi
 
 clean: cleantests
 	rm -f *~ $(OBJS) $(TLS_OBJ) $(CHECK_PROGS) $(CHECK_OBJS)
 
 cleantests:
 	rm -rf ./testtmp*
@@ -143,15 +147,12 @@
 test: check
 
 
 # There seems to be no standard way to specify some variables as
 # exported from a Makefile apart from listing them like this.
 
-# TODO: Tests that depend on built test aide programs like tls need to
-# know where the build directory is.
-
 # This depends on building rsync; if we need any helper programs it
 # should depend on them too.
 
 # We try to run the scripts with POSIX mode on, in the hope that will
 # catch Bash-isms earlier even if we're running on GNU.  Of course, we
 # might lose in the future where POSIX diverges from old sh.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/match.c	2004-01-04 03:28:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/match.c	2004-09-08 05:45:19.000000000 +0800
@@ -19,12 +19,15 @@
 
 #include "rsync.h"
 
 extern int verbose;
 extern int am_server;
 extern int do_progress;
+extern int checksum_seed;
+extern int inplace;
+extern int make_backups;
 
 typedef unsigned short tag;
 
 #define TABLESIZE (1<<16)
 #define NULL_TAG ((size_t)-1)
 
@@ -136,22 +139,23 @@
 }
 
 
 static void hash_search(int f,struct sum_struct *s,
 			struct map_struct *buf, OFF_T len)
 {
-	OFF_T offset, end;
+	OFF_T offset, end, backup;
 	unsigned int k;
-	size_t last_i;
+	size_t want_i;
 	char sum2[SUM_LENGTH];
 	uint32 s1, s2, sum;
+	int more;
 	schar *map;
 
-	/* last_i is used to encourage adjacent matches, allowing the RLL coding of the
-	   output to work more efficiently */
-	last_i = (size_t)-1;
+	/* want_i is used to encourage adjacent matches, allowing the RLL
+	 * coding of the output to work more efficiently. */
+	want_i = 0;
 
 	if (verbose > 2) {
 		rprintf(FINFO,"hash search b=%u len=%.0f\n",
 			s->blength, (double)len);
 	}
 
@@ -184,24 +188,30 @@
 
 		if (j == NULL_TAG)
 			goto null_tag;
 
 		sum = (s1 & 0xffff) | (s2 << 16);
 		tag_hits++;
-		for (; j < s->count && targets[j].t == t; j++) {
+		do {
 			unsigned int l;
 			size_t i = targets[j].i;
 
 			if (sum != s->sums[i].sum1)
 				continue;
 
 			/* also make sure the two blocks are the same length */
 			l = MIN((OFF_T)s->blength, len-offset);
 			if (l != s->sums[i].len)
 				continue;
 
+			/* inplace: ensure chunk's offset is either >= our
+			 * offset or that the data didn't move. */
+			if (inplace && !make_backups && s->sums[i].offset < offset
+			    && !(s->sums[i].flags & SUMFLG_SAME_OFFSET))
+				continue;
+
 			if (verbose > 3)
 				rprintf(FINFO,"potential match at %.0f target=%.0f %.0f sum=%08x\n",
 					(double)offset,(double)j,(double)i,sum);
 
 			if (!done_csum2) {
 				map = (schar *)map_ptr(buf,offset,l);
@@ -211,63 +221,88 @@
 
 			if (memcmp(sum2,s->sums[i].sum2,s->s2length) != 0) {
 				false_alarms++;
 				continue;
 			}
 
-			/* we've found a match, but now check to see
-			 * if last_i can hint at a better match */
-			for (j++; j < s->count && targets[j].t == t; j++) {
-				size_t i2 = targets[j].i;
-				if (i2 == last_i + 1) {
-					if (sum != s->sums[i2].sum1)
-						break;
-					if (memcmp(sum2,s->sums[i2].sum2,s->s2length) != 0)
-						break;
-					/* we've found an adjacent match - the RLL coder
-					 * will be happy */
-					i = i2;
-					break;
-				}
+			/* If inplace is enabled, the best possible match is
+			 * one with an identical offset, so we prefer that over
+			 * the following want_i optimization. */
+			if (inplace && !make_backups) {
+				do {
+					size_t i2 = targets[j].i;
+					if (s->sums[i2].offset != offset)
+						continue;
+					if (i2 != i) {
+						if (sum != s->sums[i2].sum1)
+							break;
+						if (memcmp(sum2, s->sums[i2].sum2,
+							   s->s2length) != 0)
+							break;
+						i = i2;
+					}
+					/* This chunk was at the same offset on
+					 * both the sender and the receiver. */
+					s->sums[i].flags |= SUMFLG_SAME_OFFSET;
+					goto set_want_i;
+				} while (++j < s->count && targets[j].t == t);
 			}
 
-			last_i = i;
+			/* we've found a match, but now check to see
+			 * if want_i can hint at a better match. */
+			if (i != want_i && want_i < s->count
+			    && (!inplace || make_backups || s->sums[want_i].offset >= offset
+			     || s->sums[want_i].flags & SUMFLG_SAME_OFFSET)
+			    && sum == s->sums[want_i].sum1
+			    && memcmp(sum2, s->sums[want_i].sum2, s->s2length) == 0) {
+				/* we've found an adjacent match - the RLL coder
+				 * will be happy */
+				i = want_i;
+			}
+		    set_want_i:
+			want_i = i + 1;
 
 			matched(f,s,buf,offset,i);
 			offset += s->sums[i].len - 1;
 			k = MIN(s->blength, len-offset);
 			map = (schar *)map_ptr(buf, offset, k);
 			sum = get_checksum1((char *)map, k);
 			s1 = sum & 0xFFFF;
 			s2 = sum >> 16;
 			matches++;
 			break;
-		}
+		} while (++j < s->count && targets[j].t == t);
 
 	null_tag:
+		backup = offset - last_match;
+		/* We sometimes read 1 byte prior to last_match... */
+		if (backup < 0)
+			backup = 0;
+
 		/* Trim off the first byte from the checksum */
-		map = (schar *)map_ptr(buf, offset, k+1);
+		more = offset + k < len;
+		map = (schar *)map_ptr(buf, offset - backup, k + more + backup)
+		    + backup;
 		s1 -= map[0] + CHAR_OFFSET;
 		s2 -= k * (map[0]+CHAR_OFFSET);
 
 		/* Add on the next byte (if there is one) to the checksum */
-		if (k < (len-offset)) {
-			s1 += (map[k]+CHAR_OFFSET);
+		if (more) {
+			s1 += map[k] + CHAR_OFFSET;
 			s2 += s1;
 		} else
 			--k;
 
 		/* By matching early we avoid re-reading the
 		   data 3 times in the case where a token
 		   match comes a long way after last
 		   match. The 3 reads are caused by the
 		   running match, the checksum update and the
 		   literal send. */
-		if (offset > last_match
-		 && offset-last_match >= CHUNK_SIZE+s->blength
-		 && end-offset > CHUNK_SIZE) {
+		if (backup >= CHUNK_SIZE + s->blength
+		    && end - offset > CHUNK_SIZE) {
 			matched(f,s,buf,offset - s->blength, -2);
 		}
 	} while (++offset < end);
 
 	matched(f,s,buf,len,-1);
 	map_ptr(buf,len-1,1);
@@ -288,21 +323,20 @@
  *
  * @param len Length of the file to send.
  **/
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len)
 {
 	char file_sum[MD4_SUM_LENGTH];
-	extern int write_batch;
 
 	last_match = 0;
 	false_alarms = 0;
 	tag_hits = 0;
 	matches = 0;
 	data_transfer = 0;
 
-	sum_init();
+	sum_init(checksum_seed);
 
 	if (len > 0 && s->count>0) {
 		build_hash_table(s);
 
 		if (verbose > 2)
 			rprintf(FINFO,"built hash table\n");
@@ -319,18 +353,19 @@
 			matched(f,s,buf,j+n1,-2);
 		}
 		matched(f,s,buf,len,-1);
 	}
 
 	sum_end(file_sum);
+	/* If we had a read error, send a bad checksum. */
+	if (buf && buf->status != 0)
+		file_sum[0]++;
 
 	if (verbose > 2)
 		rprintf(FINFO,"sending file_sum\n");
 	write_buf(f,file_sum,MD4_SUM_LENGTH);
-	if (write_batch)
-		write_batch_delta_file(file_sum, MD4_SUM_LENGTH);
 
 	if (targets) {
 		free(targets);
 		targets=NULL;
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/NEWS	2004-05-01 01:53:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/NEWS	2004-09-30 18:46:43.000000000 +0800
@@ -1,229 +1,252 @@
-NEWS for rsync 2.6.2 (30 Apr 2004)
+NEWS for rsync 2.6.3 (30 Sep 2004)
 Protocol: 28 (unchanged)
-Changes since 2.6.1:
+Changes since 2.6.2:
+
+  SECURITY FIXES:
+
+    - A bug in the sanitize_path routine (which affects a non-chrooted
+      rsync daemon) could allow a user to craft a pathname that would get
+      transformed into an absolute path for certain options (but not for
+      file-transfer names).  If you're running an rsync daemon with chroot
+      disabled, *please upgrade*, ESPECIALLY if the user privs you run
+      rsync under is anything above "nobody".
+
+  OUTPUT CHANGES (ATTN: those using a script to parse the verbose output):
+
+    - Please note that the 2-line footer (output when verbose) now uses the
+      term "sent" instead of "wrote" and "received" instead of "read".  If
+      you are not parsing the numeric values out of this footer, a script
+      would be better off using the empty line prior to the footer as the
+      indicator that the verbose output is over.
+      
+    - The output from the --stats option was similarly affected to change
+      "written" to "sent" and "read" to "received".
+
+    - Rsync ensures that a filename that contains a newline gets mentioned
+      with each newline transformed into a question mark (which prevents a
+      filename from causing an empty line to be output).
+
+    - The "backed up ..." message that is output when at least 2 --verbose
+      options are specified is now the same both with and without the
+      --backup-dir option.
 
   BUG FIXES:
 
-    - Fixed a major bug in the sorting of the filenames when --relative
-      is used for some sources (probably just "/", but don't depend on
-      that).  This fix ensures that we ask for the right file-list item
-      when requesting changes from the sender.
-
-    - Rsync now checks the return value of the close() function to
-      better report disk-full problems on an NFS file system.
-
-    - Restored the old daemon-server behavior of logging error messages
-      rather than returning them to the user.  (A better long-term fix
-      will be sought in the future.)
-
-    - An obscure uninitialized-variable bug was fixed in the uid/gid
-      code.  (This bug probably had no ill effects.)
-
-    - Got rid of the configure check for sys/sysctl.h (it wasn't used
-      and was causing a problem on some systems).  Also improved the
-      broken-largefile-locking test to try to avoid failure due to an
-      NFS build-dir.
+    - Fixed a crash bug that might appear when --delete was used and
+      multiple source directories were specified.
+
+    - Fixed a 32-bit truncation of the file length when generating the
+      checksums.
+
+    - The --backup code no longer attempts to create some directories
+      over and over again (generating warnings along the way).
+
+    - Fixed a bug in the reading of the secrets file (by the daemon) and
+      the password file (by the client):  the files no longer need to be
+      terminated by a newline for their content to be read in.
+
+    - If a file has a read error on the sending side or the reconstructed
+      data doesn't match the expected checksum (perhaps due to the basis
+      file changing during the transfer), the receiver will no longer
+      retain the resulting file unless the --partial option was specified.
+      (Note: for the read-error detection to work, neither side can be
+      older than 2.6.3 -- older receivers will always retain the file, and
+      older senders don't tell the receiver that the file had a read
+      error.)
+
+    - If a file gets resent in a single transfer and the --backup option
+      is enabled, rsync no longer performs a duplicate backup (it used to
+      overwrite the original file in the backup area).
+
+    - Files specified in the daemon's "exclude" or "exclude from" config
+      items are now excluded from being uploaded (assuming that the module
+      allows uploading at all) in addition to the old download exclusion.
+
+    - Got rid of a potential hang in the receiver when near the end of a
+      phase.
+
+    - When using --backup without a --backup-dir, rsync no longer preserves
+      the modify time on directories.  This avoids confusing NFS.
+
+    - When --copy-links (-L) is specified, we now output a separate error
+      for a symlink that has no referent instead of claiming that a file
+      "vanished".
+
+    - The --copy-links (-L) option no longer has the side-effect of telling
+      the receiving side to follow symlinks.  See the --keep-dirlinks
+      option (mentioned below) for a way to specify that behavior.
+
+    - Error messages from the daemon server's option-parsing (such as
+      refused options) are now successfully transferred back to the client
+      (the server used to fail to send the message because the socket
+      wasn't in the right state for the message to get through).
+
+    - Most transfer errors that occur during a daemon transfer are now
+      returned to the user in addition to being logged (some messages are
+      intended to be daemon-only and are not affected by this).
+
+    - Fixed a bug in the daemon authentication code when using one of the
+      batch-processing options.
+
+    - We try to work around some buggy IPv6 implementations that fail to
+      implement IPV6_V6ONLY.  This should fix the "address in use" error
+      that some daemons get when running on an OS with a buggy IPv6
+      implementation.  Also, if the new code gets this error, we might
+      suggest that the user specify --ipv4 or --ipv6 (if we think it will
+      help).
+
+    - When the remote rsync dies, make a better effort to recover any error
+      messages it may have sent before dying (the local rsync used to just
+      die with a socket-write error).
+
+    - When using --delete and a --backup-dir that contains files that are
+      hard-linked to their destination equivalents, rsync now makes sure
+      that removed files really get removed (avoids a really weird rename()
+      behavior).
+
+    - Avoid a bogus run-time complaint about a lack of 64-bit integers when
+      the int64 type is defined as an off_t and it actually has 64-bits.
+
+    - Added a configure check for open64() without mkstemp64() so that we
+      can avoid using mkstemp() when such a combination is encountered.
+      This bypasses a problem writing out large temp files on OSes such as
+      AIX and HP-UX.
+
+    - Fixed an age-old crash problem with --read-batch on a local copy
+      (rsync was improperly assuming --whole-file for the local copy).
+
+    - When --dry-run (-n) is used and the destination directory does not
+      exist, rsync now produces a correct report of files that would be
+      sent instead of dying with a chdir() error.
+
+    - Fixed a bug that could cause a slow-to-connect rsync daemon to die
+      with an error instead of waiting for the connection to finish.
+
+    - Fixed an ssh interaction that could cause output to be lost when the
+      user chose to combine the output of rsync's stdout and stderr (e.g.
+      using the "2>&1").
+
+  ENHANCEMENTS:
+
+    - Added the --partial-dir=DIR option that lets you specify where to
+      (temporarily) put a partially transferred file (instead of over-
+      writing the destination file).  E.g.  --partial-dir=.rsync-partial
+      Also added support for the RSYNC_PARTIAL_DIR environment variable
+      that, when found, transforms a regular --partial option (such as
+      the convenient -P option) into one that also specifies a directory.
+
+    - Added --keep-dirlinks (-K), which allows you to symlink a directory
+      onto another partition on the receiving side and have rsync treat it
+      as matching a normal directory from the sender.
+
+    - Added the --inplace option that tells rsync to write each destination
+      file without using a temporary file.  The matching of existing data
+      in the destination file can be severely limited by this, but there
+      are also cases where this is more efficient (such as appending data).
+      Use only when needed (see the man page for more details).
 
-    - Fixed a compile problem on systems that don't define
-      AI_NUMERICHOST.
+    - Added the "write only" option for the daemon's config file.
 
-    - Fixed a compile problem in the popt source for compilers that
-      don't support __attribute__.
+    - Added long-option names for -4 and -6 (namely --ipv4 and --ipv6)
+      and documented all these options in the man page.
+
+    - Improved the handling of the --bwlimit option so that it's less
+      bursty, more accurate, and works properly over a larger range of
+      values.
+
+    - The rsync daemon-over-ssh code now looks for SSH_CONNECTION and
+      SSH2_CLIENT in addition to SSH_CLIENT to figure out the IP address.
+
+    - Added the --checksum-seed=N option for advanced users.
+
+    - Batch writing/reading has a brand-new implementation that is simpler,
+      fixes a few weird problems with the old code (such as no longer
+      sprinkling the batch files into different dirs or even onto different
+      systems), and is much less intrusive into the code (making it easier
+      to maintain for the future).  The new code generates just one data
+      file instead of three, which makes it possible to read the batch on
+      stdin via a remote shell.  Also, the old requirement of forcing the
+      same fixed checksum-seed for all batch processing has been removed.
+
+    - If an rsync daemon has a module set with "list = no" (which hides its
+      presence in the list of available modules), a user that fails to
+      authenticate gets the same "unknown module" error that they would get
+      if the module were actually unknown (while still logging the real
+      error to the daemon's log file).  This prevents fishing for module
+      names.
+
+    - The daemon's "refuse options" config item now allows you to match
+      option names using wildcards and/or the single-letter option names.
+
+    - Each transferred file now gets its permissions and modified-time
+      updated before the temp-file gets moved into place.  Previously, the
+      finished file would have a very brief window where its permissions
+      disallowed all group and world access.
+
+    - Added the ability to parse a literal IPv6 address in an "rsync:" URL
+      (e.g. rsync://[2001:638:500:101::21]:873/module/dir).
+
+    - The daemon's wildcard expanding code can now handle more than 1000
+      filenames (it's now limited by memory instead of having a hard-wired
+      limit).
 
   INTERNAL:
 
-    - Improved the testsuite's "merge" test to work on OSF1.
+    - Some cleanup in the exclude code has saved some per-exclude memory
+      and made the code easier to maintain.
 
-    - Two new diffs were added to the patches dir.
+    - Improved the argv-overflow checking for a remote command that has a
+      lot of args.
 
-
-NEWS for rsync 2.6.1 (26 Apr 2004)
-Protocol: 28 (changed)
-Changes since 2.6.0:
+    - Use rsyserr() in the various places that were still calling rprintf()
+      with strerror() as an arg.
 
-  SECURITY FIXES:
+    - If an rsync daemon is listening on multiple sockets (to handle both
+      IPv4 and IPv6 to a single port), we now close all the unneeded file
+      handles after we accept a connection (we used to close just one of
+      them).
 
-    - Paths sent to an rsync daemon are more thoroughly sanitized when
-      chroot is not used.  If you're running a non-read-only rsync
-      daemon with chroot disabled, *please upgrade*, ESPECIALLY if the
-      user privs you run rsync under is anything above "nobody".
+    - Optimized the handling of larger block sizes (rsync used to slow to a
+      crawl if the block size got too large).
 
-  ENHANCEMENTS:
+    - Optimized away a loop in hash_search().
 
-    - Lower memory use, more optimal transfer of data over the socket,
-      and lower CPU usage (see the INTERNAL section for details).
+    - Some improvements to the sanitize_path() and clean_fname() functions
+      makes them more efficient and produce better results (while still
+      being compatible with the file-name cleaning that gets done on both
+      sides when sending the file-list).
 
-    - The RSYNC_PROXY environment variable can now contain a
-      "USER:PASS@" prefix before the "HOST:PORT" information.
-      (Bardur Arantsson)
-
-    - The --progress output now mentions how far along in the transfer
-      we are, including both a count of files transferred and a
-      percentage of the total file-count that we've processed.  It also
-      shows better current-rate-of-transfer and remaining-transfer-time
-      values.
+    - Got rid of alloc_sanitize_path() after adding a destination-buffer
+      arg to sanitize_path() made it possible to put all the former's
+      functionality into the latter.
 
-    - The configure script now accepts --with-rsyncd-conf=PATH to
-      override the default value of the /etc/rsyncd.conf file.
+    - The file-list that is output when at least 4 verbose options are
+      specified reports the uid value on the sender even when rsync is
+      not running as root (since we might be sending to a root receiver).
 
-    - Added a couple extra diffs in the "patches" dir, removed the ones
-      that got applied, and rebuilt the rest.
+  BUILD CHANGES:
 
-    - Documentation changes now attempt to describe some often mis-
-      understood features more clearly.
+    - Added a "gen" target to rebuild most of the generated files,
+      including configure, config.h.in, the man pages, and proto.h.
 
-  BUG FIXES:
+    - If "make proto" doesn't find some changes in the prototypes, the
+      proto.h file is left untouched (its time-stamp used to always be
+      updated).
 
-    - When -x (--one-file-system) is combined with -L (--copy-links) or
-      --copy-unsafe-links, no symlinked files are skipped, even if the
-      referent file is on a different filesystem.
-
-    - The --link-dest code now works properly for a non-root user when
-      (1) the UIDs of the source and destination differ and -o was
-      specified, or (2) when the group of the source can't be used on
-      the destination and -g was specified.
-
-    - Fixed a bug in the handling of -H (hard-links) that might cause
-      the expanded PATH/NAME value of the current item to get
-      overwritten (due to an expanded-name caching bug).
-      
-    - We now reset the "new data has been sent" flag at the start of
-      each file we send.  This makes sure that an interrupted transfer
-      with the --partial option set doesn't keep a shorter temp file
-      than the current basis file when no new data has been transfered
-      over the wire for that file.
-
-    - Fixed a byte-order problem in --batch-mode on big-endian machines.
-      (Jay Fenlason)
-
-    - Fixed configure bug when running "./configure --disable-ipv6".
-
-    - Fixed "make test" bug when build dir is not the source dir.
-
-    - When using --cvs-exclude, the exclude items we get from a
-      per-directory's .cvsignore file once again only affect that one
-      directory (not all following directories too).  The items are also
-      now properly word-split and parsed without any +/- prefix parsing.
-
-    - When specifying the USER@HOST: prefix for a file, the USER part
-      can now contain an '@', if needed (i.e. the last '@' is used to
-      find the HOST, not the first).
-
-    - Fixed some bugs in the handling of group IDs for non-root users:
-      (1) It properly handles a group that the sender didn't have a name
-      for (it would previously skip changing the group on any files in
-      that group).  (2) If --numeric-ids is used, rsync no longer
-      attempts to set groups that the user doesn't have the permission
-      to set.
-
-    - Fixed the "refuse options" setting in the rsyncd.conf file.
-
-    - Improved the -x (--one-file-system) flag's handling of any mount-
-      point directories we encounter.  It is both more optimal (in that
-      it no longer does a useless scan of the contents of the mount-
-      point dirs) and also fixes a bug where a remapped mount of the
-      original filesystem could get discovered in a subdir we should be
-      ignoring.
-
-    - Rsync no longer discards a double-slash at the start of a filename
-      when trying to open the file.  It also no longer constructs names
-      that start with a double slash (unless the user supplied them).
-
-    - Path-specifying options to a daemon should now work the same with
-      or without chroot turned on.  Previously, such a option (such as
-      --link-dest) would get its absolute path munged into a relative
-      one if chroot was not on, making that setting fairly useless.
-      Rsync now transforms the path into one that is based on the
-      module's base dir when chroot is not enabled.
-
-    - Fixed compilation problem on Tru64 Unix (having to do with
-      sockaddr.sa_len and sockaddr.sin_len).
-
-    - Fixed a compatibility problem interacting with older rsync
-      versions that might send us an empty --suffix value without
-      telling us that --backup-dir was specified.
-
-    - The "hosts allow" option for a daemon-over-remote-shell process
-      now has improved support for IPv6 addresses and a fix for systems
-      that have a length field in their socket structs.
+    - The variable $STRIP (that is optionally set by the install-strip
+      target's rule) was changed to $INSTALL_STRIP because some systems
+      have $STRIP already set in the environment.
 
-    - Fixed the ability to request an empty backup --suffix when sending
-      files to an rsync daemon.
+    - Fixed a build problem when SUPPORT_HARD_LINKS isn't defined.
 
-  INTERNAL:
+    - When cross-compiling, the gettimeofday() function is now assumed to
+      be a modern version that takes two-args (since we can't test it).
 
-    - Most of the I/O is now buffered, which results in a pretty large
-      speedup when running under MS Windows.  (Craig Barratt)
+  DEVELOPER RELATED:
 
-    - Optimizations to the name-handling/comparing code have made some
-      significant reductions in user-CPU time for large file sets.
+    - The scripts in the testsuite dir were cleaned up a bit and a few
+      new tests added.
 
-    - Some cleanup of the variable types make the code more consistent.
+    - Some new diffs were added to the patches dir, and some accepted
+      ones were removed.
 
-    - Reduced memory requirements of hard link preservation.
-      (J.W. Schultz)
-
-    - Implemented a new algorithm for hard-link handling that speeds up
-      the code significantly.  (J.W. Schultz and Wayne Davison)
-
-    - The --hard-link option now uses the first existing file in the
-      group of linked files as the basis for the transfer.  This
-      prevents the sub-optimal transfer of a file's data when a new
-      hardlink is added on the sending side and it sorts alphabetically
-      earlier in the list than the files that are already present on the
-      receiving side.
-
-    - Dropped support for protocol versions less than 20 (2.3.0 released
-      15 Mar 1999) and activated warnings for protocols less than 25
-      (2.5.0 released 23 Aug 2001). (Wayne Davison and J.W. Schultz,
-      severally)
-
-    - More optimal data transmission for --hard-links (protocol 28).
-
-    - More optimal data transmission for --checksum (protocol 28).
-
-    - Less memory is used when --checksum is specified.
-
-    - Less memory is used in the file list (a per-file savings).
-
-    - The generator is now better about not modifying the file list
-      during the transfer in order to avoid a copy-on-write memory
-      bifurcation (on systems where fork() uses shared memory).
-      Previously, rsync's shared memory would slowly become unshared,
-      resulting in real memory usage nearly doubling on the receiving
-      side by the end of the transfer.  Now, as long as permissions
-      are being preserved, the shared memory should remain that way
-      for the entire transfer.
-
-    - Changed hardlink info and file_struct + strings to use allocation
-      pools.  This reduces memory use for large file-sets and permits
-      freeing memory to the OS.  (J.W. Schultz) 
-
-    - The 2 pipes used between the receiver and generator processes
-      (which are forked on the same machine) were reduced to 1 pipe and
-      the protocol improved so that (1) it is now impossible to have the
-      "redo" pipe fill up and hang rsync, and (2) trailing messages from
-      the receiver don't get lost on their way through the generator
-      over to the sender (which mainly affected hard-link messages and
-      verbose --stats output).
-
-    - Improved the internal uid/gid code to be more portable and a
-      little more optimized.
-
-    - The device numbers sent when using --devices are now sent as
-      separate major/minor values with 32-bit accuracy (protocol 28).
-      Previously, the copied devices were sent as a single 32-bit
-      number.  This will make inter-operation of 64-bit binaries more
-      compatible with their 32-bit brethren (with both ends of the
-      connection are using protocol 28).  Note that optimizations in the
-      binary protocol for sending the device numbers often results in
-      fewer bytes being used than before, even though more precision is
-      now available.
-
-    - Some cleanup of the exclude/include structures and its code made
-      things clearer (internally), simpler, and more efficient.
-
-    - The reading & writing of the file-list in batch-mode is now
-      handled by the same code that sends & receives the list over the
-      wire.  This makes it much easier to maintain.  (Note that the
-      batch code is still considered to be experimental.)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/OLDNEWS	2004-03-05 03:35:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/OLDNEWS	2004-09-30 17:36:29.000000000 +0800
@@ -1,6 +1,243 @@
+NEWS for rsync 2.6.2 (30 Apr 2004)
+Protocol: 28 (unchanged)
+Changes since 2.6.1:
+
+  BUG FIXES:
+
+    - Fixed a major bug in the sorting of the filenames when --relative
+      is used for some sources (just sources such as "/" and "/*" were
+      affected).  This fix ensures that we ask for the right file-list
+      item when requesting changes from the sender.
+
+    - Rsync now checks the return value of the close() function to
+      better report disk-full problems on an NFS file system.
+
+    - Restored the old daemon-server behavior of logging error messages
+      rather than returning them to the user.  (A better long-term fix
+      will be sought in the future.)
+
+    - An obscure uninitialized-variable bug was fixed in the uid/gid
+      code.  (This bug probably had no ill effects.)
+
+  BUILD CHANGES:
+
+    - Got rid of the configure check for sys/sysctl.h (it wasn't used
+      and was causing a problem on some systems).  Also improved the
+      broken-largefile-locking test to try to avoid failure due to an
+      NFS build-dir.
+
+    - Fixed a compile problem on systems that don't define
+      AI_NUMERICHOST.
+
+    - Fixed a compile problem in the popt source for compilers that
+      don't support __attribute__.
+
+  DEVELOPER RELATED:
+
+    - Improved the testsuite's "merge" test to work on OSF1.
+
+    - Two new diffs were added to the patches dir.
+
+
+NEWS for rsync 2.6.1 (26 Apr 2004)
+Protocol: 28 (changed)
+Changes since 2.6.0:
+
+  SECURITY FIXES:
+
+    - Paths sent to an rsync daemon are more thoroughly sanitized when
+      chroot is not used.  If you're running a non-read-only rsync
+      daemon with chroot disabled, *please upgrade*, ESPECIALLY if the
+      user privs you run rsync under is anything above "nobody".
+
+  ENHANCEMENTS:
+
+    - Lower memory use, more optimal transfer of data over the socket,
+      and lower CPU usage (see the INTERNAL section for details).
+
+    - The RSYNC_PROXY environment variable can now contain a
+      "USER:PASS@" prefix before the "HOST:PORT" information.
+      (Bardur Arantsson)
+
+    - The --progress output now mentions how far along in the transfer
+      we are, including both a count of files transferred and a
+      percentage of the total file-count that we've processed.  It also
+      shows better current-rate-of-transfer and remaining-transfer-time
+      values.
+
+    - Documentation changes now attempt to describe some often mis-
+      understood features more clearly.
+
+  BUG FIXES:
+
+    - When -x (--one-file-system) is combined with -L (--copy-links) or
+      --copy-unsafe-links, no symlinked files are skipped, even if the
+      referent file is on a different filesystem.
+
+    - The --link-dest code now works properly for a non-root user when
+      (1) the UIDs of the source and destination differ and -o was
+      specified, or (2) when the group of the source can't be used on
+      the destination and -g was specified.
+
+    - Fixed a bug in the handling of -H (hard-links) that might cause
+      the expanded PATH/NAME value of the current item to get
+      overwritten (due to an expanded-name caching bug).
+      
+    - We now reset the "new data has been sent" flag at the start of
+      each file we send.  This makes sure that an interrupted transfer
+      with the --partial option set doesn't keep a shorter temp file
+      than the current basis file when no new data has been transfered
+      over the wire for that file.
+
+    - Fixed a byte-order problem in --batch-mode on big-endian machines.
+      (Jay Fenlason)
+
+    - When using --cvs-exclude, the exclude items we get from a
+      per-directory's .cvsignore file once again only affect that one
+      directory (not all following directories too).  The items are also
+      now properly word-split and parsed without any +/- prefix parsing.
+
+    - When specifying the USER@HOST: prefix for a file, the USER part
+      can now contain an '@', if needed (i.e. the last '@' is used to
+      find the HOST, not the first).
+
+    - Fixed some bugs in the handling of group IDs for non-root users:
+      (1) It properly handles a group that the sender didn't have a name
+      for (it would previously skip changing the group on any files in
+      that group).  (2) If --numeric-ids is used, rsync no longer
+      attempts to set groups that the user doesn't have the permission
+      to set.
+
+    - Fixed the "refuse options" setting in the rsyncd.conf file.
+
+    - Improved the -x (--one-file-system) flag's handling of any mount-
+      point directories we encounter.  It is both more optimal (in that
+      it no longer does a useless scan of the contents of the mount-
+      point dirs) and also fixes a bug where a remapped mount of the
+      original filesystem could get discovered in a subdir we should be
+      ignoring.
+
+    - Rsync no longer discards a double-slash at the start of a filename
+      when trying to open the file.  It also no longer constructs names
+      that start with a double slash (unless the user supplied them).
+
+    - Path-specifying options to a daemon should now work the same with
+      or without chroot turned on.  Previously, such a option (such as
+      --link-dest) would get its absolute path munged into a relative
+      one if chroot was not on, making that setting fairly useless.
+      Rsync now transforms the path into one that is based on the
+      module's base dir when chroot is not enabled.
+
+    - Fixed a compatibility problem interacting with older rsync
+      versions that might send us an empty --suffix value without
+      telling us that --backup-dir was specified.
+
+    - The "hosts allow" option for a daemon-over-remote-shell process
+      now has improved support for IPv6 addresses and a fix for systems
+      that have a length field in their socket structs.
+
+    - Fixed the ability to request an empty backup --suffix when sending
+      files to an rsync daemon.
+
+  INTERNAL:
+
+    - Most of the I/O is now buffered, which results in a pretty large
+      speedup when running under MS Windows.  (Craig Barratt)
+
+    - Optimizations to the name-handling/comparing code have made some
+      significant reductions in user-CPU time for large file sets.
+
+    - Some cleanup of the variable types make the code more consistent.
+
+    - Reduced memory requirements of hard link preservation.
+      (J.W. Schultz)
+
+    - Implemented a new algorithm for hard-link handling that speeds up
+      the code significantly.  (J.W. Schultz and Wayne Davison)
+
+    - The --hard-link option now uses the first existing file in the
+      group of linked files as the basis for the transfer.  This
+      prevents the sub-optimal transfer of a file's data when a new
+      hardlink is added on the sending side and it sorts alphabetically
+      earlier in the list than the files that are already present on the
+      receiving side.
+
+    - Dropped support for protocol versions less than 20 (2.3.0 released
+      15 Mar 1999) and activated warnings for protocols less than 25
+      (2.5.0 released 23 Aug 2001). (Wayne Davison and J.W. Schultz,
+      severally)
+
+    - More optimal data transmission for --hard-links (protocol 28).
+
+    - More optimal data transmission for --checksum (protocol 28).
+
+    - Less memory is used when --checksum is specified.
+
+    - Less memory is used in the file list (a per-file savings).
+
+    - The generator is now better about not modifying the file list
+      during the transfer in order to avoid a copy-on-write memory
+      bifurcation (on systems where fork() uses shared memory).
+      Previously, rsync's shared memory would slowly become unshared,
+      resulting in real memory usage nearly doubling on the receiving
+      side by the end of the transfer.  Now, as long as permissions
+      are being preserved, the shared memory should remain that way
+      for the entire transfer.
+
+    - Changed hardlink info and file_struct + strings to use allocation
+      pools.  This reduces memory use for large file-sets and permits
+      freeing memory to the OS.  (J.W. Schultz) 
+
+    - The 2 pipes used between the receiver and generator processes
+      (which are forked on the same machine) were reduced to 1 pipe and
+      the protocol improved so that (1) it is now impossible to have the
+      "redo" pipe fill up and hang rsync, and (2) trailing messages from
+      the receiver don't get lost on their way through the generator
+      over to the sender (which mainly affected hard-link messages and
+      verbose --stats output).
+
+    - Improved the internal uid/gid code to be more portable and a
+      little more optimized.
+
+    - The device numbers sent when using --devices are now sent as
+      separate major/minor values with 32-bit accuracy (protocol 28).
+      Previously, the copied devices were sent as a single 32-bit
+      number.  This will make inter-operation of 64-bit binaries more
+      compatible with their 32-bit brethren (with both ends of the
+      connection are using protocol 28).  Note that optimizations in the
+      binary protocol for sending the device numbers often results in
+      fewer bytes being used than before, even though more precision is
+      now available.
+
+    - Some cleanup of the exclude/include structures and its code made
+      things clearer (internally), simpler, and more efficient.
+
+    - The reading & writing of the file-list in batch-mode is now
+      handled by the same code that sends & receives the list over the
+      wire.  This makes it much easier to maintain.  (Note that the
+      batch code is still considered to be experimental.)
+
+  BUILD CHANGES:
+
+    - The configure script now accepts --with-rsyncd-conf=PATH to
+      override the default value of the /etc/rsyncd.conf file.
+
+    - Fixed configure bug when running "./configure --disable-ipv6".
+
+    - Fixed compilation problem on Tru64 Unix (having to do with
+      sockaddr.sa_len and sockaddr.sin_len).
+
+  DEVELOPER RELATED:
+
+    - Fixed "make test" bug when build dir is not the source dir.
+
+    - Added a couple extra diffs in the "patches" dir, removed the ones
+      that got applied, and rebuilt the rest.
+
+
 NEWS for rsync 2.6.0 (1 Jan 2004)
 Protocol: 27 (changed)
 Changes since 2.5.7:
 
   ENHANCEMENTS:
 
@@ -550,12 +787,15 @@
     * The existing test.sh script by Phil Hands has been merged into a
       test framework that works from both "make check" and the Samba
       build farm.
 
 Partial Protocol History
 	RELEASE DATE	VER.	DATE OF COMMIT	PROTOCOL
+	30 Sep 2004	2.6.3			28
+	30 Apr 2004	2.6.2			28
+	26 Apr 2004	2.6.1	08 Jan 2004	28
 	01 Jan 2004	2.6.0	10 Apr 2003	27 (MAX=40)
 	04 Dec 2003	2.5.7			26
 	26 Jan 2003	2.5.6			26
 	02 Apr 2002	2.5.5			26
 	13 Mar 2002	2.5.4			26
 	11 Mar 2002	2.5.3			26
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/options.c	2004-04-18 01:07:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/options.c	2004-09-24 01:39:05.000000000 +0800
@@ -19,14 +19,15 @@
  */
 
 #include "rsync.h"
 #include "popt.h"
 
 extern int sanitize_paths;
-extern char curr_dir[MAXPATHLEN];
+extern int select_timeout;
 extern struct exclude_list_struct exclude_list;
+extern struct exclude_list_struct server_exclude_list;
 
 int make_backups = 0;
 
 /**
  * If 1, send the whole file as literal data rather than trying to
  * create an incremental diff.
@@ -35,12 +36,13 @@
  *
  * @sa disable_deltas_p()
  **/
 int whole_file = -1;
 
 int archive_mode = 0;
+int keep_dirlinks = 0;
 int copy_links = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
 int preserve_perms = 0;
 int preserve_devices = 0;
 int preserve_uid = 0;
@@ -80,20 +82,22 @@
 int do_progress = 0;
 int keep_partial = 0;
 int safe_symlinks = 0;
 int copy_unsafe_links = 0;
 int size_only = 0;
 int bwlimit = 0;
+size_t bwlimit_writemax = 0;
 int delete_after = 0;
 int only_existing = 0;
 int opt_ignore_existing = 0;
 int max_delete = 0;
 int ignore_errors = 0;
 int modify_window = 0;
 int blocking_io = -1;
 int checksum_seed = 0;
+int inplace = 0;
 unsigned int block_size = 0;
 
 
 /** Network address family. **/
 #ifdef INET6
 int default_af_hint = 0;	/* Any protocol */
@@ -111,12 +115,13 @@
 int backup_dir_len = 0;
 int backup_suffix_len;
 unsigned int backup_dir_remainder;
 
 char *backup_suffix = NULL;
 char *tmpdir = NULL;
+char *partial_dir = NULL;
 char *compare_dest = NULL;
 char *config_file = NULL;
 char *shell_cmd = NULL;
 char *log_format = NULL;
 char *password_file = NULL;
 char *rsync_path = RSYNC_PATH;
@@ -127,37 +132,41 @@
 
 int verbose = 0;
 int quiet = 0;
 int always_checksum = 0;
 int list_only = 0;
 
-#define FIXED_CHECKSUM_SEED 32761
-#define MAX_BATCH_PREFIX_LEN 256	/* Must be less than MAXPATHLEN-13 */
-char *batch_prefix = NULL;
+#define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
+char *batch_name = NULL;
 
 static int daemon_opt;   /* sets am_daemon after option error-reporting */
 static int modify_window_set;
 
 /** Local address to bind.  As a character string because it's
- * interpreted by the IPv6 layer: should be a numeric IP4 or ip6
+ * interpreted by the IPv6 layer: should be a numeric IP4 or IP6
  * address, or a hostname. **/
 char *bind_address;
 
 
 static void print_rsync_version(enum logcode f)
 {
 	char const *got_socketpair = "no ";
+	char const *have_inplace = "no ";
 	char const *hardlinks = "no ";
 	char const *links = "no ";
 	char const *ipv6 = "no ";
 	STRUCT_STAT *dumstat;
 
 #ifdef HAVE_SOCKETPAIR
 	got_socketpair = "";
 #endif
 
+#if HAVE_FTRUNCATE
+	have_inplace = "";
+#endif
+
 #if SUPPORT_HARD_LINKS
 	hardlinks = "";
 #endif
 
 #if SUPPORT_LINKS
 	links = "";
@@ -177,23 +186,24 @@
 		(int) (sizeof (OFF_T) * 8),
 		got_socketpair, hardlinks, links);
 
 	/* Note that this field may not have type ino_t.  It depends
 	 * on the complicated interaction between largefile feature
 	 * macros. */
-	rprintf(f, "              %sIPv6, %d-bit system inums, %d-bit internal inums\n",
-		ipv6,
+	rprintf(f, "              %sinplace, %sIPv6, %d-bit system inums, %d-bit internal inums\n",
+		have_inplace, ipv6,
 		(int) (sizeof dumstat->st_ino * 8),
 		(int) (sizeof (uint64) * 8));
 #ifdef MAINTAINER_MODE
 	rprintf(f, "              panic action: \"%s\"\n",
 		get_panic_action());
 #endif
 
-#ifdef NO_INT64
-	rprintf(f, "WARNING: no 64-bit integers on this platform!\n");
+#ifdef INT64_IS_OFF_T
+	if (sizeof (int64) < 8)
+		rprintf(f, "WARNING: no 64-bit integers on this platform!\n");
 #endif
 
 	rprintf(f,
 "\n"
 "rsync comes with ABSOLUTELY NO WARRANTY.  This is free software, and you\n"
 "are welcome to redistribute it under certain conditions.  See the GNU\n"
@@ -228,12 +238,14 @@
   rprintf(F,"     --no-relative           turn off --relative\n");
   rprintf(F,"     --no-implied-dirs       don't send implied dirs with -R\n");
   rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
   rprintf(F,"     --backup-dir            make backups into this directory\n");
   rprintf(F,"     --suffix=SUFFIX         backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
   rprintf(F," -u, --update                update only (don't overwrite newer files)\n");
+  rprintf(F,"     --inplace               update destination files inplace (SEE MAN PAGE)\n");
+  rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
   rprintf(F," -l, --links                 copy symlinks as symlinks\n");
   rprintf(F," -L, --copy-links            copy the referent of all symlinks\n");
   rprintf(F,"     --copy-unsafe-links     copy the referent of \"unsafe\" symlinks\n");
   rprintf(F,"     --safe-links            ignore \"unsafe\" symlinks\n");
   rprintf(F," -H, --hard-links            preserve hard links\n");
   rprintf(F," -p, --perms                 preserve permissions\n");
@@ -243,41 +255,42 @@
   rprintf(F," -t, --times                 preserve times\n");
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
   rprintf(F," -n, --dry-run               show what would have been transferred\n");
   rprintf(F," -W, --whole-file            copy whole files, no incremental checks\n");
   rprintf(F,"     --no-whole-file         turn off --whole-file\n");
   rprintf(F," -x, --one-file-system       don't cross filesystem boundaries\n");
-  rprintf(F," -B, --block-size=SIZE       checksum blocking size (default %d)\n",BLOCK_SIZE);
+  rprintf(F," -B, --block-size=SIZE       force a fixed checksum block-size\n");
   rprintf(F," -e, --rsh=COMMAND           specify the remote shell\n");
   rprintf(F,"     --rsync-path=PATH       specify path to rsync on the remote machine\n");
   rprintf(F,"     --existing              only update files that already exist\n");
   rprintf(F,"     --ignore-existing       ignore files that already exist on receiving side\n");
   rprintf(F,"     --delete                delete files that don't exist on the sending side\n");
   rprintf(F,"     --delete-excluded       also delete excluded files on the receiving side\n");
   rprintf(F,"     --delete-after          receiver deletes after transferring, not before\n");
   rprintf(F,"     --ignore-errors         delete even if there are I/O errors\n");
   rprintf(F,"     --max-delete=NUM        don't delete more than NUM files\n");
   rprintf(F,"     --partial               keep partially transferred files\n");
+  rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
   rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
   rprintf(F," -I, --ignore-times          turn off mod time & file size quick check\n");
   rprintf(F,"     --size-only             ignore mod time for quick check (use size)\n");
   rprintf(F,"     --modify-window=NUM     compare mod times with reduced accuracy\n");
-  rprintf(F," -T  --temp-dir=DIR          create temporary files in directory DIR\n");
+  rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F,"     --link-dest=DIR         create hardlinks to DIR for unchanged files\n");
   rprintf(F," -P                          equivalent to --partial --progress\n");
   rprintf(F," -z, --compress              compress file data\n");
   rprintf(F," -C, --cvs-exclude           auto ignore files in the same way CVS does\n");
   rprintf(F,"     --exclude=PATTERN       exclude files matching PATTERN\n");
   rprintf(F,"     --exclude-from=FILE     exclude patterns listed in FILE\n");
   rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
   rprintf(F,"     --include-from=FILE     don't exclude patterns listed in FILE\n");
   rprintf(F,"     --files-from=FILE       read FILE for list of source-file names\n");
-  rprintf(F," -0  --from0                 all *-from file lists are delimited by nulls\n");
+  rprintf(F," -0, --from0                 all *-from file lists are delimited by nulls\n");
   rprintf(F,"     --version               print version number\n");
   rprintf(F,"     --daemon                run as an rsync daemon\n");
   rprintf(F,"     --no-detach             do not detach from the parent\n");
   rprintf(F,"     --address=ADDRESS       bind to the specified address\n");
   rprintf(F,"     --config=FILE           specify alternate rsyncd.conf file\n");
   rprintf(F,"     --port=PORT             specify alternate rsyncd port number\n");
@@ -285,38 +298,39 @@
   rprintf(F,"     --no-blocking-io        turn off --blocking-io\n");
   rprintf(F,"     --stats                 give some file transfer stats\n");
   rprintf(F,"     --progress              show progress during transfer\n");
   rprintf(F,"     --log-format=FORMAT     log file transfers using specified format\n");
   rprintf(F,"     --password-file=FILE    get password from FILE\n");
   rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth, KBytes per second\n");
-  rprintf(F,"     --write-batch=PREFIX    write batch fileset starting with PREFIX\n");
-  rprintf(F,"     --read-batch=PREFIX     read batch fileset starting with PREFIX\n");
-  rprintf(F," -h, --help                  show this help screen\n");
+  rprintf(F,"     --write-batch=FILE      write a batch to FILE\n");
+  rprintf(F,"     --read-batch=FILE       read a batch from FILE\n");
+  rprintf(F,"     --checksum-seed=NUM     set block/file checksum seed\n");
 #ifdef INET6
-  rprintf(F," -4                          prefer IPv4\n");
-  rprintf(F," -6                          prefer IPv6\n");
+  rprintf(F," -4, --ipv4                  prefer IPv4\n");
+  rprintf(F," -6, --ipv6                  prefer IPv6\n");
 #endif
+  rprintf(F," -h, --help                  show this help screen\n");
 
   rprintf(F,"\n");
 
   rprintf(F,"\nPlease see the rsync(1) and rsyncd.conf(5) man pages for full documentation\n");
   rprintf(F,"See http://rsync.samba.org/ for updates, bug reports, and answers\n");
 }
 
 enum {OPT_VERSION = 1000, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
       OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_LINK_DEST,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
-      OPT_READ_BATCH, OPT_WRITE_BATCH,
+      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT,
       OPT_REFUSED_BASE = 9000};
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"version",          0,  POPT_ARG_NONE,   0,              OPT_VERSION, 0, 0},
   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
-  {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path,	0, 0, 0 },
-  {"password-file",    0,  POPT_ARG_STRING, &password_file,	0, 0, 0 },
+  {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
+  {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
   {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
   {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
   {"one-file-system", 'x', POPT_ARG_NONE,   &one_file_system, 0, 0, 0 },
   {"delete",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },
   {"existing",         0,  POPT_ARG_NONE,   &only_existing, 0, 0, 0 },
@@ -333,12 +347,14 @@
   {"help",            'h', POPT_ARG_NONE,   0,              'h', 0, 0 },
   {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
   {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
   {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
   {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
   {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
+  {"inplace",          0,  POPT_ARG_NONE,   &inplace, 0, 0, 0 },
+  {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
   {"links",           'l', POPT_ARG_NONE,   &preserve_links, 0, 0, 0 },
   {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
   {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
   {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
   {"copy-unsafe-links", 0, POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
   {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
@@ -355,94 +371,108 @@
   {"recursive",       'r', POPT_ARG_NONE,   &recurse, 0, 0, 0 },
   {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
   {"no-relative",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_INT,    &block_size, 0, 0, 0 },
   {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
-  {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
+  {"timeout",          0,  POPT_ARG_INT,    &io_timeout, OPT_TIMEOUT, 0, 0 },
   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, &compare_dest, 0, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, &compare_dest,  OPT_LINK_DEST, 0, 0 },
   /* TODO: Should this take an optional int giving the compression level? */
   {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
   {"daemon",           0,  POPT_ARG_NONE,   &daemon_opt, 0, 0, 0 },
   {"no-detach",        0,  POPT_ARG_NONE,   &no_detach, 0, 0, 0 },
   {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
   {"progress",         0,  POPT_ARG_NONE,   &do_progress, 0, 0, 0 },
   {"partial",          0,  POPT_ARG_NONE,   &keep_partial, 0, 0, 0 },
+  {"partial-dir",      0,  POPT_ARG_STRING, &partial_dir, 0, 0, 0 },
   {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
   {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
   {0,                 'P', POPT_ARG_NONE,   0,              'P', 0, 0 },
   {"config",           0,  POPT_ARG_STRING, &config_file, 0, 0, 0 },
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
   {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
   {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
   {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
   {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
   {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
-  {"read-batch",       0,  POPT_ARG_STRING, &batch_prefix,  OPT_READ_BATCH, 0, 0 },
-  {"write-batch",      0,  POPT_ARG_STRING, &batch_prefix,  OPT_WRITE_BATCH, 0, 0 },
+  {"read-batch",       0,  POPT_ARG_STRING, &batch_name,  OPT_READ_BATCH, 0, 0 },
+  {"write-batch",      0,  POPT_ARG_STRING, &batch_name,  OPT_WRITE_BATCH, 0, 0 },
   {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
   {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
   {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
   {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
+  {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
 #ifdef INET6
-  {0,		      '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
-  {0,		      '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
+  {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
+  {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
 #endif
   {0,0,0,0, 0, 0, 0}
 };
 
 
-static char err_buf[100];
+static char err_buf[200];
 
 
 /**
  * Store the option error message, if any, so that we can log the
  * connection attempt (which requires parsing the options), and then
  * show the error later on.
  **/
 void option_error(void)
 {
-	if (err_buf[0]) {
-		rprintf(FLOG, "%s", err_buf);
-		rprintf(FERROR, RSYNC_NAME ": %s", err_buf);
-	} else {
-		rprintf (FERROR, "Error parsing options: "
-			 "option may be supported on client but not on server?\n");
-		rprintf (FERROR, RSYNC_NAME ": Error parsing options: "
-			 "option may be supported on client but not on server?\n");
+	if (!err_buf[0]) {
+		strcpy(err_buf, "Error parsing options: "
+		    "option may be supported on client but not on server?\n");
 	}
+
+	rprintf(FERROR, RSYNC_NAME ": %s", err_buf);
 }
 
 
 /**
  * Tweak the option table to disable all options that the rsyncd.conf
  * file has told us to refuse.
  **/
 static void set_refuse_options(char *bp)
 {
 	struct poptOption *op;
-	char *cp;
+	char *cp, shortname[2];
+	int is_wild, found_match;
+
+	shortname[1] = '\0';
 
 	while (1) {
+		while (*bp == ' ') bp++;
+		if (!*bp)
+			break;
 		if ((cp = strchr(bp, ' ')) != NULL)
 			*cp= '\0';
+		/* If they specify "delete", reject all delete options. */
+		if (strcmp(bp, "delete") == 0)
+			bp = "delete*";
+		is_wild = strpbrk(bp, "*?[") != NULL;
+		found_match = 0;
 		for (op = long_options; ; op++) {
-			if (!op->longName) {
-				rprintf(FLOG,
-				    "Unknown option %s in \"refuse options\" setting\n",
-				    bp);
-				break;
-			}
-			if (strcmp(bp, op->longName) == 0) {
-				op->val = (op - long_options)+OPT_REFUSED_BASE;
+			*shortname = op->shortName;
+			if (!op->longName && !*shortname)
 				break;
+			if ((op->longName && wildmatch(bp, op->longName))
+			    || (*shortname && wildmatch(bp, shortname))) {
+				op->val = (op - long_options) + OPT_REFUSED_BASE;
+				found_match = 1;
+				if (!is_wild)
+					break;
 			}
 		}
+		if (!found_match) {
+			rprintf(FLOG, "No match for refuse-options string \"%s\"\n",
+				bp);
+		}
 		if (!cp)
 			break;
 		*cp = ' ';
 		bp = cp + 1;
 	}
 }
@@ -516,25 +546,25 @@
 		case OPT_INCLUDE:
 			add_exclude(&exclude_list, poptGetOptArg(pc),
 				    XFLG_DEF_INCLUDE);
 			break;
 
 		case OPT_EXCLUDE_FROM:
-			arg = poptGetOptArg(pc);
-			if (sanitize_paths)
-				arg = alloc_sanitize_path(arg, curr_dir);
-			add_exclude_file(&exclude_list, arg,
-					 XFLG_FATAL_ERRORS);
-			break;
-
 		case OPT_INCLUDE_FROM:
 			arg = poptGetOptArg(pc);
 			if (sanitize_paths)
-				arg = alloc_sanitize_path(arg, curr_dir);
-			add_exclude_file(&exclude_list, arg,
-					 XFLG_FATAL_ERRORS | XFLG_DEF_INCLUDE);
+				arg = sanitize_path(NULL, arg, NULL, 0);
+			if (server_exclude_list.head) {
+				char *cp = (char *)arg;
+				clean_fname(cp, 1);
+				if (check_exclude(&server_exclude_list, cp, 0) < 0)
+					goto options_rejected;
+			}
+			add_exclude_file(&exclude_list, arg, XFLG_FATAL_ERRORS
+					 | (opt == OPT_INCLUDE_FROM
+					  ? XFLG_DEF_INCLUDE : 0));
 			break;
 
 		case 'h':
 			usage(FINFO);
 			exit_cleanup(0);
 
@@ -558,43 +588,45 @@
 		case 'P':
 			do_progress = 1;
 			keep_partial = 1;
 			break;
 
 		case OPT_WRITE_BATCH:
-			/* popt stores the filename in batch_prefix for us */
+			/* batch_name is already set */
 			write_batch = 1;
-			checksum_seed = FIXED_CHECKSUM_SEED;
 			break;
 
 		case OPT_READ_BATCH:
-			/* popt stores the filename in batch_prefix for us */
+			/* batch_name is already set */
 			read_batch = 1;
-			checksum_seed = FIXED_CHECKSUM_SEED;
+			break;
+
+		case OPT_TIMEOUT:
+			if (io_timeout && io_timeout < select_timeout)
+				select_timeout = io_timeout;
 			break;
 
 		case OPT_LINK_DEST:
 #if HAVE_LINK
 			link_dest = 1;
 			break;
 #else
 			snprintf(err_buf, sizeof err_buf,
 				 "hard links are not supported on this %s\n",
 				 am_server ? "server" : "client");
-			rprintf(FERROR, "ERROR: %s", err_buf);
 			return 0;
 #endif
 
 		default:
 			/* A large opt value means that set_refuse_options()
 			 * turned this option off (opt-BASE is its index). */
 			if (opt >= OPT_REFUSED_BASE) {
 				struct poptOption *op =
 				    &long_options[opt-OPT_REFUSED_BASE];
 				int n = snprintf(err_buf, sizeof err_buf,
-				    "This server does not support --%s\n",
+				    "The server is configured to refuse --%s\n",
 				    op->longName) - 1;
 				if (op->shortName) {
 					snprintf(err_buf+n, sizeof err_buf-n,
 					    " (-%c)\n", op->shortName);
 				}
 			} else {
@@ -610,48 +642,64 @@
 
 #if !SUPPORT_LINKS
 	if (preserve_links && !am_sender) {
 		snprintf(err_buf, sizeof err_buf,
 			 "symlinks are not supported on this %s\n",
 			 am_server ? "server" : "client");
-		rprintf(FERROR, "ERROR: %s", err_buf);
 		return 0;
 	}
 #endif
 
 #if !SUPPORT_HARD_LINKS
 	if (preserve_hard_links) {
 		snprintf(err_buf, sizeof err_buf,
 			 "hard links are not supported on this %s\n",
 			 am_server ? "server" : "client");
-		rprintf(FERROR, "ERROR: %s", err_buf);
 		return 0;
 	}
 #endif
 
 	if (write_batch && read_batch) {
-		rprintf(FERROR,
-			"write-batch and read-batch can not be used together\n");
-		exit_cleanup(RERR_SYNTAX);
-	}
-	if (batch_prefix && strlen(batch_prefix) > MAX_BATCH_PREFIX_LEN) {
-		rprintf(FERROR,
-			"the batch-file prefix must be %d characters or less.\n",
-			MAX_BATCH_PREFIX_LEN);
-		exit_cleanup(RERR_SYNTAX);
+		snprintf(err_buf, sizeof err_buf,
+			"--write-batch and --read-batch can not be used together\n");
+		return 0;
 	}
-
-	if (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {
-		rprintf(FERROR, "the --temp-dir path is WAY too long.\n");
-		exit_cleanup(RERR_SYNTAX);
+	if (write_batch || read_batch) {
+		if (dry_run) {
+			snprintf(err_buf, sizeof err_buf,
+				"--%s-batch cannot be used with --dry_run (-n)\n",
+				write_batch ? "write" : "read");
+			return 0;
+		}
+		if (am_server) {
+			rprintf(FINFO,
+				"ignoring --%s-batch option sent to server\n",
+				write_batch ? "write" : "read");
+			/* We don't actually exit_cleanup(), so that we can
+			 * still service older version clients that still send
+			 * batch args to server. */
+			read_batch = write_batch = 0;
+			batch_name = NULL;
+		}
+	}
+	if (read_batch && files_from) {
+		snprintf(err_buf, sizeof err_buf,
+			"--read-batch cannot be used with --files-from\n");
+		return 0;
+	}
+	if (batch_name && strlen(batch_name) > MAX_BATCH_NAME_LEN) {
+		snprintf(err_buf, sizeof err_buf,
+			"the batch-file name must be %d characters or less.\n",
+			MAX_BATCH_NAME_LEN);
+		return 0;
 	}
 
-	if (do_compression && (write_batch || read_batch)) {
-		rprintf(FERROR,
-			"compress can not be used with write-batch or read-batch\n");
-		exit_cleanup(RERR_SYNTAX);
+	if (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {
+		snprintf(err_buf, sizeof err_buf,
+			 "the --temp-dir path is WAY too long.\n");
+		return 0;
 	}
 
 	if (archive_mode) {
 		if (!files_from)
 			recurse = 1;
 #if SUPPORT_LINKS
@@ -673,62 +721,138 @@
 	else
 		*argc = 0;
 
 	if (sanitize_paths) {
 		int i;
 		for (i = *argc; i-- > 0; )
-			(*argv)[i] = alloc_sanitize_path((*argv)[i], NULL);
+			(*argv)[i] = sanitize_path(NULL, (*argv)[i], "", 0);
 		if (tmpdir)
-			tmpdir = alloc_sanitize_path(tmpdir, curr_dir);
+			tmpdir = sanitize_path(NULL, tmpdir, NULL, 0);
+		if (partial_dir)
+			partial_dir = sanitize_path(NULL, partial_dir, NULL, 0);
 		if (compare_dest)
-			compare_dest = alloc_sanitize_path(compare_dest, curr_dir);
+			compare_dest = sanitize_path(NULL, compare_dest, NULL, 0);
 		if (backup_dir)
-			backup_dir = alloc_sanitize_path(backup_dir, curr_dir);
+			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0);
 		if (files_from)
-			files_from = alloc_sanitize_path(files_from, curr_dir);
+			files_from = sanitize_path(NULL, files_from, NULL, 0);
+	}
+	if (server_exclude_list.head && !am_sender) {
+		struct exclude_list_struct *elp = &server_exclude_list;
+		if (tmpdir) {
+			clean_fname(tmpdir, 1);
+			if (check_exclude(elp, tmpdir, 1) < 0)
+				goto options_rejected;
+		}
+		if (partial_dir) {
+			clean_fname(partial_dir, 1);
+			if (check_exclude(elp, partial_dir, 1) < 0)
+				goto options_rejected;
+		}
+		if (compare_dest) {
+			clean_fname(compare_dest, 1);
+			if (check_exclude(elp, compare_dest, 1) < 0)
+				goto options_rejected;
+		}
+		if (backup_dir) {
+			clean_fname(backup_dir, 1);
+			if (check_exclude(elp, backup_dir, 1) < 0)
+				goto options_rejected;
+		}
+	}
+	if (server_exclude_list.head && files_from) {
+		clean_fname(files_from, 1);
+		if (check_exclude(&server_exclude_list, files_from, 0) < 0) {
+		    options_rejected:
+			snprintf(err_buf, sizeof err_buf,
+			    "Your options have been rejected by the server.\n");
+			return 0;
+		}
 	}
 
 	if (daemon_opt) {
 		daemon_opt = 0;
 		am_daemon = 1;
 		return 1;
 	}
 
 	if (!backup_suffix)
 		backup_suffix = backup_dir ? "" : BACKUP_SUFFIX;
 	backup_suffix_len = strlen(backup_suffix);
 	if (strchr(backup_suffix, '/') != NULL) {
-		rprintf(FERROR, "--suffix cannot contain slashes: %s\n",
+		snprintf(err_buf, sizeof err_buf,
+			"--suffix cannot contain slashes: %s\n",
 			backup_suffix);
-		exit_cleanup(RERR_SYNTAX);
+		return 0;
 	}
 	if (backup_dir) {
 		backup_dir_len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
 		backup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;
 		if (backup_dir_remainder < 32) {
-			rprintf(FERROR, "the --backup-dir path is WAY too long.\n");
-			exit_cleanup(RERR_SYNTAX);
+			snprintf(err_buf, sizeof err_buf,
+				"the --backup-dir path is WAY too long.\n");
+			return 0;
 		}
 		if (backup_dir_buf[backup_dir_len - 1] != '/') {
 			backup_dir_buf[backup_dir_len++] = '/';
 			backup_dir_buf[backup_dir_len] = '\0';
 		}
 		if (verbose > 1 && !am_sender)
 			rprintf(FINFO, "backup_dir is %s\n", backup_dir_buf);
 	} else if (!backup_suffix_len && (!am_server || !am_sender)) {
-		rprintf(FERROR,
+		snprintf(err_buf, sizeof err_buf,
 			"--suffix cannot be a null string without --backup-dir\n");
-		exit_cleanup(RERR_SYNTAX);
+		return 0;
 	}
 
 	if (do_progress && !verbose)
 		verbose = 1;
 
+	if (bwlimit) {
+		bwlimit_writemax = (size_t)bwlimit * 128;
+		if (bwlimit_writemax < 512)
+			bwlimit_writemax = 512;
+	}
+
+	if (inplace) {
+#if HAVE_FTRUNCATE
+		if (partial_dir) {
+			snprintf(err_buf, sizeof err_buf,
+				 "--inplace cannot be used with --partial-dir\n");
+			return 0;
+		}
+		keep_partial = 0;
+#else
+		snprintf(err_buf, sizeof err_buf,
+			 "--inplace is not supported on this %s\n",
+			 am_server ? "server" : "client");
+		return 0;
+#endif
+		if (compare_dest) {
+			snprintf(err_buf, sizeof err_buf,
+				 "--inplace does not yet work with %s\n",
+				 link_dest ? "--link-dest" : "--compare-dest");
+			return 0;
+		}
+	} else {
+		if (keep_partial && !partial_dir)
+			partial_dir = getenv("RSYNC_PARTIAL_DIR");
+		if (partial_dir) {
+			if (!*partial_dir || strcmp(partial_dir, ".") == 0)
+				partial_dir = NULL;
+			else if (*partial_dir != '/') {
+				add_exclude(&exclude_list, partial_dir,
+					    XFLG_DIRECTORY);
+			}
+			keep_partial = 1;
+		}
+	}
+
 	if (files_from) {
 		char *colon;
-		if (*argc != 2 && !(am_server && am_sender && *argc == 1)) {
+		if (*argc > 2 || (!am_daemon && *argc == 1)) {
 			usage(FERROR);
 			exit_cleanup(RERR_SYNTAX);
 		}
 		if (strcmp(files_from, "-") == 0) {
 			filesfrom_fd = 0;
 			if (am_server)
@@ -738,22 +862,23 @@
 			if (am_server) {
 				usage(FERROR);
 				exit_cleanup(RERR_SYNTAX);
 			}
 			remote_filesfrom_file = colon+1 + (colon[1] == ':');
 			if (strcmp(remote_filesfrom_file, "-") == 0) {
-				rprintf(FERROR, "Invalid --files-from remote filename\n");
-				exit_cleanup(RERR_SYNTAX);
+				snprintf(err_buf, sizeof err_buf,
+					"Invalid --files-from remote filename\n");
+				return 0;
 			}
 		} else {
 			filesfrom_fd = open(files_from, O_RDONLY|O_BINARY);
 			if (filesfrom_fd < 0) {
-				rsyserr(FERROR, errno,
-					"failed to open files-from file %s",
-					files_from);
-				exit_cleanup(RERR_FILEIO);
+				snprintf(err_buf, sizeof err_buf,
+					"failed to open files-from file %s: %s\n",
+					files_from, strerror(errno));
+				return 0;
 			}
 		}
 	}
 
 	return 1;
 }
@@ -803,12 +928,14 @@
 	if (dry_run)
 		argstr[x++] = 'n';
 	if (preserve_links)
 		argstr[x++] = 'l';
 	if (copy_links)
 		argstr[x++] = 'L';
+	if (keep_dirlinks && am_sender)
+		argstr[x++] = 'K';
 
 	if (whole_file > 0)
 		argstr[x++] = 'W';
 	/* We don't need to send --no-whole-file, because it's the
 	 * default for remote transfers, and in any case old versions
 	 * of rsync will not understand it. */
@@ -863,19 +990,12 @@
 	if (max_delete && am_sender) {
 		if (asprintf(&arg, "--max-delete=%d", max_delete) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
-	if (batch_prefix) {
-		char *r_or_w = write_batch ? "write" : "read";
-		if (asprintf(&arg, "--%s-batch=%s", r_or_w, batch_prefix) < 0)
-			goto oom;
-		args[ac++] = arg;
-	}
-
 	if (io_timeout) {
 		if (asprintf(&arg, "--timeout=%d", io_timeout) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
@@ -895,34 +1015,45 @@
 		/* We use the following syntax to avoid weirdness with '~'. */
 		if (asprintf(&arg, "--suffix=%s", backup_suffix) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
-	if (delete_excluded)
-		args[ac++] = "--delete-excluded";
-	else if (delete_mode)
-		args[ac++] = "--delete";
+	if (am_sender) {
+		if (delete_excluded)
+			args[ac++] = "--delete-excluded";
+		else if (delete_mode)
+			args[ac++] = "--delete";
+
+		if (delete_after)
+			args[ac++] = "--delete-after";
+
+		if (force_delete)
+			args[ac++] = "--force";
+	}
 
 	if (size_only)
 		args[ac++] = "--size-only";
 
 	if (modify_window_set) {
 		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
-	if (keep_partial)
-		args[ac++] = "--partial";
-
-	if (force_delete)
-		args[ac++] = "--force";
+	if (checksum_seed) {
+		if (asprintf(&arg, "--checksum-seed=%d", checksum_seed) < 0)
+			goto oom;
+		args[ac++] = arg;
+	}
 
-	if (delete_after)
-		args[ac++] = "--delete-after";
+	if (partial_dir && am_sender) {
+		args[ac++] = "--partial-dir";
+		args[ac++] = partial_dir;
+	} else if (keep_partial)
+		args[ac++] = "--partial";
 
 	if (ignore_errors)
 		args[ac++] = "--ignore-errors";
 
 	if (copy_unsafe_links)
 		args[ac++] = "--copy-unsafe-links";
@@ -936,12 +1067,15 @@
 	if (only_existing && am_sender)
 		args[ac++] = "--existing";
 
 	if (opt_ignore_existing && am_sender)
 		args[ac++] = "--ignore-existing";
 
+	if (inplace)
+		args[ac++] = "--inplace";
+
 	if (tmpdir) {
 		args[ac++] = "--temp-dir";
 		args[ac++] = tmpdir;
 	}
 
 	if (compare_dest && am_sender) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/packaging/lsb/rsync.spec	2004-05-01 02:02:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/packaging/lsb/rsync.spec	2004-10-01 00:35:56.000000000 +0800
@@ -1,9 +1,9 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.6.2
+Version: 2.6.3
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
 Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-%{version}.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/params.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/params.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/params.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/params.c	2004-05-16 03:31:10.000000000 +0800
@@ -488,14 +488,14 @@
     return( NULL );
     }
 
   OpenedFile = fopen( FileName, "r" );
   if( NULL == OpenedFile )
     {
-    rprintf(FERROR,"rsync: unable to open configuration file \"%s\": %s\n",
-	    FileName, strerror(errno));
+    rsyserr(FERROR, errno, "rsync: unable to open configuration file \"%s\"",
+	    FileName);
     }
 
   return( OpenedFile );
   } /* OpenConfFile */
 
 BOOL pm_process( char *FileName,
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: acl.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/chmod-option.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/chmod-option.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/chmod-option.diff	2004-04-25 02:55:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/chmod-option.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,19 +1,25 @@
---- Makefile.in	10 Feb 2004 17:06:11 -0000	1.98
-+++ Makefile.in	22 Apr 2004 23:39:42 -0000
+After applying this patch and running configure, you MUST run this
+command before "make":
+
+    make proto
+
+
+--- orig/Makefile.in	2004-08-13 07:18:58
++++ Makefile.in	2004-07-03 20:13:41
 @@ -34,7 +34,7 @@ ZLIBOBJ=zlib/deflate.o zlib/infblock.o z
  OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
  	main.o checksum.o match.o syscall.o log.o backup.o
  OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
 -	fileio.o batch.o clientname.o
 +	fileio.o batch.o clientname.o chmod.o
  OBJS3=progress.o pipe.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
---- /dev/null	1 Jan 1970 00:00:00 -0000
-+++ chmod.c	22 Apr 2004 23:39:43 -0000
+--- orig/chmod.c	2004-06-18 17:22:08
++++ chmod.c	2004-06-18 17:22:08
 @@ -0,0 +1,184 @@
 +#include "rsync.h"
 +
 +#define FLAG_X_KEEP (1<<0)
 +#define FLAG_DIRS_ONLY (1<<1)
 +#define FLAG_FILES_ONLY (1<<2)
@@ -193,143 +199,123 @@
 +		next = chmod_modes->next;
 +		free(chmod_modes);
 +		chmod_modes = next;
 +	}
 +	return 0;
 +}
---- flist.c	22 Apr 2004 22:17:15 -0000	1.216
-+++ flist.c	22 Apr 2004 23:39:43 -0000
-@@ -33,6 +33,7 @@ extern int verbose;
- extern int do_progress;
- extern int am_root;
- extern int am_server;
-+extern int am_sender;
- extern int am_daemon;
- extern int always_checksum;
- extern int module_id;
-@@ -64,6 +65,8 @@ extern int sanitize_paths;
- extern int read_batch;
- extern int write_batch;
+--- orig/flist.c	2004-09-21 09:40:27
++++ flist.c	2004-09-18 01:51:11
+@@ -65,6 +65,8 @@ extern int delete_excluded;
+ extern int orig_umask;
+ extern int list_only;
  
 +extern struct chmod_mode_struct *chmod_modes;
 +
  extern struct exclude_list_struct exclude_list;
  extern struct exclude_list_struct server_exclude_list;
  extern struct exclude_list_struct local_exclude_list;
-@@ -853,7 +856,10 @@ skip_excludes:
+@@ -869,7 +871,10 @@ skip_excludes:
  	file->flags = flags;
  	file->modtime = st.st_mtime;
  	file->length = st.st_size;
 -	file->mode = st.st_mode;
 +	if (chmod_modes && am_sender && (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode)))
 +		file->mode = tweak_mode(st.st_mode, chmod_modes);
 +	else
 +		file->mode = st.st_mode;
  	file->uid = st.st_uid;
  	file->gid = st.st_gid;
  
---- options.c	17 Apr 2004 17:07:23 -0000	1.147
-+++ options.c	22 Apr 2004 23:39:43 -0000
-@@ -121,6 +121,7 @@ char *log_format = NULL;
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-07-03 20:13:41
+@@ -126,6 +126,7 @@ char *log_format = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
 +char *chmod_mode = NULL;
  char backup_dir_buf[MAXPATHLEN];
  int rsync_port = RSYNC_PORT;
  int link_dest = 0;
-@@ -134,6 +135,8 @@ int list_only = 0;
- #define MAX_BATCH_PREFIX_LEN 256	/* Must be less than MAXPATHLEN-13 */
- char *batch_prefix = NULL;
+@@ -138,6 +139,8 @@ int list_only = 0;
+ #define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
+ char *batch_name = NULL;
  
 +struct chmod_mode_struct *chmod_modes = NULL;
 +
  static int daemon_opt;   /* sets am_daemon after option error-reporting */
  static int modify_window_set;
  
-@@ -241,6 +244,7 @@ void usage(enum logcode F)
+@@ -253,6 +256,7 @@ void usage(enum logcode F)
    rprintf(F," -g, --group                 preserve group\n");
    rprintf(F," -D, --devices               preserve devices (root only)\n");
    rprintf(F," -t, --times                 preserve times\n");
 +  rprintf(F,"     --chmod=CHMOD           change destination permissions\n");
    rprintf(F," -S, --sparse                handle sparse files efficiently\n");
    rprintf(F," -n, --dry-run               show what would have been transferred\n");
    rprintf(F," -W, --whole-file            copy whole files, no incremental checks\n");
-@@ -344,6 +348,7 @@ static struct poptOption long_options[] 
+@@ -360,6 +364,7 @@ static struct poptOption long_options[] 
    {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
    {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
    {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
 +  {"chmod",            0,  POPT_ARG_STRING, &chmod_mode, 0, 0, 0 },
    {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
    {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
    {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
-@@ -720,6 +725,13 @@ int parse_arguments(int *argc, const cha
- 		exit_cleanup(RERR_SYNTAX);
+@@ -804,6 +809,13 @@ int parse_arguments(int *argc, const cha
+ 		return 0;
  	}
  
 +	if (chmod_mode && !(chmod_modes = parse_chmod(chmod_mode))) {
 +		snprintf(err_buf, sizeof err_buf,
 +		    "Invalid argument passed to chmod\n");
 +		rprintf(FERROR, "ERROR: %s", err_buf);
 +		return 0;
 +	}
 +
  	if (do_progress && !verbose)
  		verbose = 1;
  
-@@ -951,6 +963,11 @@ void server_options(char **args,int *arg
- 		 */
- 		args[ac++] = link_dest ? "--link-dest" : "--compare-dest";
+@@ -1087,6 +1099,11 @@ void server_options(char **args,int *arg
  		args[ac++] = compare_dest;
-+	}
-+
+ 	}
+ 
 +	if (chmod_mode && !am_sender) {
 +		args[ac++] = "--chmod";
 +		args[ac++] = chmod_mode;
- 	}
- 
++	}
++
  	if (files_from && (!am_sender || remote_filesfrom_file)) {
---- proto.h	22 Apr 2004 09:58:09 -0000	1.189
-+++ proto.h	22 Apr 2004 23:39:43 -0000
-@@ -25,6 +25,9 @@ void file_checksum(char *fname,char *sum
- void sum_init(void);
- void sum_update(char *p, int len);
- void sum_end(char *sum);
-+struct chmod_mode_struct *parse_chmod(char *modestr);
-+int tweak_mode(int mode, struct chmod_mode_struct *chmod_modes);
-+int free_chmod_mode(struct chmod_mode_struct *chmod_modes);
- void close_all(void);
- void _exit_cleanup(int code, const char *file, int line);
- void cleanup_disable(void);
---- rsync.yo	24 Apr 2004 06:16:04 -0000	1.164
-+++ rsync.yo	24 Apr 2004 07:32:05 -0000
-@@ -299,6 +299,7 @@ verb(
+ 		if (remote_filesfrom_file) {
+ 			args[ac++] = "--files-from";
+--- orig/rsync.yo	2004-09-24 16:42:30
++++ rsync.yo	2004-07-03 20:13:41
+@@ -330,6 +330,7 @@ verb(
   -g, --group                 preserve group
   -D, --devices               preserve devices (root only)
   -t, --times                 preserve times
 +     --chmod=CHMOD           change destination permissions
   -S, --sparse                handle sparse files efficiently
   -n, --dry-run               show what would have been transferred
   -W, --whole-file            copy whole files, no incremental checks
-@@ -543,6 +544,14 @@ modified cannot be effective; in other w
- cause the next transfer to behave as if it used -I, and all files will have
- their checksums compared and show up in log messages even if they haven't
- changed.
-+
+@@ -610,6 +611,14 @@ cause the next transfer to behave as if 
+ updated (though the rsync algorithm will make the update fairly efficient
+ if the files haven't actually changed, you're much better off using -t).
+ 
 +dit(bf(--chmod)) This options tells rsync to apply the listed "chmod" pattern
 +to the permission of the files on the destination.  In addition to the normal
 +parsing rules specified in the chmod manpage, you can specify an item that
 +should only apply to a directory by prefixing it with a 'D', or specify an
 +item that should only apply to a file by prefixing it with a 'F'.  For example:
 +
 +quote(--chmod=Dg+s,ug+w,Fo-w,+X)
- 
++
  dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
  instead it will just report the actions it would have taken.
---- /dev/null	1 Jan 1970 00:00:00 -0000
-+++ testsuite/chmod.test	22 Apr 2004 23:39:44 -0000
+ 
+--- orig/testsuite/chmod-option.test	2004-06-18 17:22:09
++++ testsuite/chmod-option.test	2004-06-18 17:22:09
 @@ -0,0 +1,43 @@
 +#! /bin/sh
 +
 +# Copyright (C) 2002 by Martin Pool <mbp@samba.org>
 +
 +# This program is distributable under the terms of the GNU GPL (see
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: compare-dest.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/copy-atimes.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/copy-atimes.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/copy-atimes.diff	2004-04-25 02:55:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/copy-atimes.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,300 +1,356 @@
---- backup.c	13 Mar 2004 20:18:03 -0000	1.28
-+++ backup.c	20 Apr 2004 23:44:16 -0000
-@@ -101,7 +101,7 @@ static int make_bak_dir(char *fullpath)
- 				    "make_bak_dir stat %s failed: %s\n",
- 				    full_fname(rel), strerror(errno));
- 			} else {
--				set_modtime(fullpath, st.st_mtime);
-+				set_times(fullpath, st.st_mtime, time(NULL));
- 				do_lchown(fullpath, st.st_uid, st.st_gid);
- 				do_chmod(fullpath, st.st_mode);
- 			}
---- batch.c	6 Mar 2004 07:45:52 -0000	1.31
-+++ batch.c	20 Apr 2004 23:44:16 -0000
-@@ -342,6 +342,8 @@ void show_flist(int index, struct file_s
+After applying this patch and running configure, you MUST run this
+command before "make":
+
+    make proto
+
+
+--- orig/batch.c	2004-08-02 05:02:24
++++ batch.c	2004-07-03 20:15:41
+@@ -184,6 +184,8 @@ void show_flist(int index, struct file_s
  		rprintf(FINFO, "flist->flags=%#x\n", fptr[i]->flags);
  		rprintf(FINFO, "flist->modtime=%#lx\n",
  			(long unsigned) fptr[i]->modtime);
 +		rprintf(FINFO, "flist->atime=%#lx\n",
 +			(long unsigned) fptr[i]->atime);
  		rprintf(FINFO, "flist->length=%.0f\n",
  			(double) fptr[i]->length);
  		rprintf(FINFO, "flist->mode=%#o\n", (int) fptr[i]->mode);
---- flist.c	22 Apr 2004 22:17:15 -0000	1.216
-+++ flist.c	20 Apr 2004 23:44:17 -0000
-@@ -58,6 +58,7 @@ extern int relative_paths;
+--- orig/flist.c	2004-09-21 09:40:27
++++ flist.c	2004-07-03 20:15:41
+@@ -59,6 +59,7 @@ extern int relative_paths;
  extern int implied_dirs;
  extern int copy_links;
  extern int copy_unsafe_links;
 +extern int copy_atimes;
  extern int protocol_version;
  extern int sanitize_paths;
- 
-@@ -140,16 +141,16 @@ static void list_file_entry(struct file_
+ extern int delete_excluded;
+@@ -143,17 +144,17 @@ static void list_file_entry(struct file_
  
  #if SUPPORT_LINKS
  	if (preserve_links && S_ISLNK(f->mode)) {
 -		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
 +		rprintf(FINFO, "%s %11.0f %s %s %s -> %s\n",
  			perms,
- 			(double) f->length, timestring(f->modtime),
+ 			(double)f->length, timestring(f->modtime),
 -			f_name(f), f->u.link);
 +			timestring(f->atime), f_name(f), f->u.link);
  	} else
  #endif
+ 	{
 -		rprintf(FINFO, "%s %11.0f %s %s\n",
 +		rprintf(FINFO, "%s %11.0f %s %s %s\n",
  			perms,
- 			(double) f->length, timestring(f->modtime),
+ 			(double)f->length, timestring(f->modtime),
 -			f_name(f));
 +			timestring(f->atime), f_name(f));
+ 	}
  }
  
- 
-@@ -326,6 +327,7 @@ void send_file_entry(struct file_struct 
+@@ -334,6 +335,7 @@ void send_file_entry(struct file_struct 
  {
  	unsigned short flags;
  	static time_t modtime;
 +	static time_t atime;
  	static mode_t mode;
  	static uint64 dev;
  	static dev_t rdev;
-@@ -341,7 +343,7 @@ void send_file_entry(struct file_struct 
+@@ -349,7 +351,7 @@ void send_file_entry(struct file_struct 
  
  	if (!file) {
  		write_byte(f, 0);
 -		modtime = 0, mode = 0;
 +		modtime = 0, atime = 0, mode = 0;
  		dev = 0, rdev = makedev(0, 0);
  		rdev_major = 0;
  		uid = 0, gid = 0;
-@@ -390,6 +392,12 @@ void send_file_entry(struct file_struct 
+@@ -398,6 +400,12 @@ void send_file_entry(struct file_struct 
  		flags |= XMIT_SAME_TIME;
  	else
  		modtime = file->modtime;
 +	if (copy_atimes && !S_ISDIR(mode)) {
 +		if (file->atime == atime)
 +			flags |= XMIT_SAME_ATIME;
 +		else
 +			atime = file->atime;
 +	}
  
  #if SUPPORT_HARD_LINKS
  	if (file->link_u.idev) {
-@@ -445,6 +453,8 @@ void send_file_entry(struct file_struct 
+@@ -453,6 +461,8 @@ void send_file_entry(struct file_struct 
  		write_int(f, modtime);
  	if (!(flags & XMIT_SAME_MODE))
  		write_int(f, to_wire_mode(mode));
 +	if (copy_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
 +		write_int(f, atime);
  	if (preserve_uid && !(flags & XMIT_SAME_UID)) {
  		if (!numeric_ids)
  			add_uid(uid);
-@@ -518,6 +528,7 @@ void receive_file_entry(struct file_stru
-     struct file_list *flist, int f)
+@@ -526,6 +536,7 @@ void receive_file_entry(struct file_stru
+ 			struct file_list *flist, int f)
  {
  	static time_t modtime;
 +	static time_t atime;
  	static mode_t mode;
  	static uint64 dev;
  	static dev_t rdev;
-@@ -534,7 +545,7 @@ void receive_file_entry(struct file_stru
+@@ -542,7 +553,7 @@ void receive_file_entry(struct file_stru
  	struct file_struct *file;
  
  	if (!fptr) {
 -		modtime = 0, mode = 0;
 +		modtime = 0, atime = 0, mode = 0;
  		dev = 0, rdev = makedev(0, 0);
  		rdev_major = 0;
  		uid = 0, gid = 0;
-@@ -588,6 +599,8 @@ void receive_file_entry(struct file_stru
+@@ -597,6 +608,8 @@ void receive_file_entry(struct file_stru
  		modtime = (time_t)read_int(f);
  	if (!(flags & XMIT_SAME_MODE))
  		mode = from_wire_mode(read_int(f));
 +	if (copy_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
 +		atime = (time_t)read_int(f);
  
  	if (preserve_uid && !(flags & XMIT_SAME_UID))
  		uid = (uid_t)read_int(f);
-@@ -638,6 +651,7 @@ void receive_file_entry(struct file_stru
+@@ -647,6 +660,7 @@ void receive_file_entry(struct file_stru
  
  	file->flags = flags & XMIT_TOP_DIR ? FLAG_TOP_DIR : 0;
  	file->modtime = modtime;
 +	file->atime = atime;
  	file->length = file_length;
  	file->mode = mode;
  	file->uid = uid;
-@@ -852,6 +866,7 @@ skip_excludes:
+@@ -868,6 +882,7 @@ skip_excludes:
  
  	file->flags = flags;
  	file->modtime = st.st_mtime;
 +	file->atime = st.st_atime;
  	file->length = st.st_size;
  	file->mode = st.st_mode;
  	file->uid = st.st_uid;
---- generator.c	15 Apr 2004 16:55:23 -0000	1.79
-+++ generator.c	20 Apr 2004 23:44:17 -0000
-@@ -97,7 +97,7 @@ static int skip_file(char *fname, struct
+--- orig/generator.c	2004-09-20 19:50:13
++++ generator.c	2004-07-03 20:15:41
+@@ -92,7 +92,7 @@ static int skip_file(char *fname, struct
+ 	if (ignore_times)
  		return 0;
- 	}
  
--	return (cmp_modtime(st->st_mtime,file->modtime) == 0);
-+	return cmp_time(st->st_mtime,file->modtime) == 0;
+-	return cmp_modtime(st->st_mtime, file->modtime) == 0;
++	return cmp_time(st->st_mtime, file->modtime) == 0;
  }
  
  
-@@ -464,7 +464,7 @@ void recv_generator(char *fname, struct 
- 		return;
+@@ -484,7 +484,7 @@ static void recv_generator(char *fname, 
  	}
  
--	if (update_only && cmp_modtime(st.st_mtime,file->modtime)>0 && fnamecmp == fname) {
-+	if (update_only && cmp_time(st.st_mtime,file->modtime)>0 && fnamecmp == fname) {
+ 	if (update_only && fnamecmp == fname
+-	    && cmp_modtime(st.st_mtime, file->modtime) > 0) {
++	    && cmp_time(st.st_mtime, file->modtime) > 0) {
  		if (verbose > 1)
- 			rprintf(FINFO,"%s is newer\n",fname);
+ 			rprintf(FINFO, "%s is newer\n", safe_fname(fname));
  		return;
---- options.c	17 Apr 2004 17:07:23 -0000	1.147
-+++ options.c	20 Apr 2004 23:44:17 -0000
-@@ -46,6 +46,7 @@ int preserve_devices = 0;
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-07-03 20:15:41
+@@ -48,6 +48,7 @@ int preserve_devices = 0;
  int preserve_uid = 0;
  int preserve_gid = 0;
  int preserve_times = 0;
 +int copy_atimes = 0;
  int update_only = 0;
  int cvs_exclude = 0;
  int dry_run = 0;
-@@ -241,6 +242,7 @@ void usage(enum logcode F)
+@@ -253,6 +254,7 @@ void usage(enum logcode F)
    rprintf(F," -g, --group                 preserve group\n");
    rprintf(F," -D, --devices               preserve devices (root only)\n");
    rprintf(F," -t, --times                 preserve times\n");
 +  rprintf(F," -A, --copy-atimes           copy access times\n");
    rprintf(F," -S, --sparse                handle sparse files efficiently\n");
    rprintf(F," -n, --dry-run               show what would have been transferred\n");
    rprintf(F," -W, --whole-file            copy whole files, no incremental checks\n");
-@@ -346,6 +348,7 @@ static struct poptOption long_options[] 
+@@ -362,6 +364,7 @@ static struct poptOption long_options[] 
    {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
    {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
    {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
 +  {"copy-atimes",     'A', POPT_ARG_NONE,   &copy_atimes, 0, 0, 0 },
    {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
    {"verbose",         'v', POPT_ARG_NONE,   0,               'v', 0, 0 },
    {"quiet",           'q', POPT_ARG_NONE,   0,               'q', 0, 0 },
-@@ -823,6 +826,8 @@ void server_options(char **args,int *arg
+@@ -950,6 +953,8 @@ void server_options(char **args,int *arg
  		argstr[x++] = 'D';
  	if (preserve_times)
  		argstr[x++] = 't';
 +	if (copy_atimes)
 +		argstr[x++] = 'A';
  	if (preserve_perms)
  		argstr[x++] = 'p';
  	if (recurse)
---- proto.h	22 Apr 2004 09:58:09 -0000	1.189
-+++ proto.h	20 Apr 2004 23:44:17 -0000
-@@ -242,7 +242,7 @@ int fd_pair(int fd[2]);
- void print_child_argv(char **cmd);
- void out_of_memory(char *str);
- void overflow(char *str);
--int set_modtime(char *fname, time_t modtime);
-+int set_times(char *fname, time_t modtime, time_t atime);
- int create_directory_path(char *fname, int base_umask);
- int copy_file(char *source, char *dest, mode_t mode);
- int robust_unlink(char *fname);
-@@ -266,7 +266,7 @@ int u_strcmp(const char *cs1, const char
- int unsafe_symlink(const char *dest, const char *src);
- char *timestring(time_t t);
- int msleep(int t);
--int cmp_modtime(time_t file1, time_t file2);
-+int cmp_time(time_t file1, time_t file2);
- int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6);
- void *_new_array(unsigned int size, unsigned long num);
- void *_realloc_array(void *ptr, unsigned int size, unsigned long num);
---- rsync.c	23 Mar 2004 16:16:15 -0000	1.135
-+++ rsync.c	20 Apr 2004 23:44:17 -0000
+--- orig/rsync.c	2004-09-07 21:45:30
++++ rsync.c	2004-08-13 08:17:28
 @@ -25,6 +25,7 @@
  extern int verbose;
  extern int dry_run;
  extern int preserve_times;
 +extern int copy_atimes;
  extern int am_root;
- extern int am_server;
  extern int am_sender;
-@@ -140,17 +141,28 @@ int set_perms(char *fname,struct file_st
- 		st = &st2;
- 	}
- 
--	if (preserve_times && !S_ISLNK(st->st_mode) &&
--	    cmp_modtime(st->st_mtime, file->modtime) != 0) {
-+	if (!S_ISLNK(st->st_mode) && (preserve_times || copy_atimes)) {
+ extern int am_generator;
+@@ -145,17 +146,32 @@ int set_perms(char *fname,struct file_st
+ 	if (!preserve_times || S_ISLNK(st->st_mode)
+ 	    || (make_backups && !backup_dir && S_ISDIR(st->st_mode)))
+ 		flags |= PERMS_SKIP_MTIME;
+-	if (!(flags & PERMS_SKIP_MTIME)
+-	    && cmp_modtime(st->st_mtime, file->modtime) != 0) {
++	if (!copy_atimes || S_ISLNK(st->st_mode) || S_ISDIR(st->st_mode))
++		flags |= PERMS_SKIP_ATIME;
++	if ((flags & (PERMS_SKIP_MTIME|PERMS_SKIP_ATIME))
++	    != (PERMS_SKIP_MTIME|PERMS_SKIP_ATIME)) {
 +		time_t atime, mtime;
 +
-+		if (copy_atimes && !S_ISDIR(st->st_mode)
++		if (!(flags & PERMS_SKIP_ATIME)
 +		    && cmp_time(st->st_atime, file->atime) != 0) {
 +			atime = file->atime;
 +			updated = 1;
 +		} else
 +			atime = st->st_atime;
-+		if (preserve_times && cmp_time(st->st_mtime, file->modtime) != 0) {
++		if (!(flags & PERMS_SKIP_MTIME)
++		    && cmp_time(st->st_mtime, file->modtime) != 0) {
 +			mtime = file->modtime;
 +			updated = 1;
 +		} else
 +			mtime = st->st_mtime;
  		/* don't complain about not setting times on directories
  		 * because some filesystems can't do it */
 -		if (set_modtime(fname,file->modtime) != 0 &&
 +		if (updated && set_times(fname, mtime, atime) != 0 &&
  		    !S_ISDIR(st->st_mode)) {
- 			rprintf(FERROR, "failed to set times on %s: %s\n",
- 				full_fname(fname), strerror(errno));
+ 			rsyserr(FERROR, errno, "failed to set times on %s",
+ 				full_fname(fname));
  			return 0;
  		}
 -		updated = 1;
  	}
  
  	change_uid = am_root && preserve_uid && st->st_uid != file->uid;
---- rsync.h	22 Apr 2004 09:58:24 -0000	1.198
-+++ rsync.h	20 Apr 2004 23:44:18 -0000
+--- orig/rsync.h	2004-09-22 08:47:31
++++ rsync.h	2004-07-03 20:15:41
 @@ -54,6 +54,7 @@
  #define XMIT_HAS_IDEV_DATA (1<<9)
  #define XMIT_SAME_DEV (1<<10)
  #define XMIT_RDEV_MINOR_IS_SMALL (1<<11)
 +#define XMIT_SAME_ATIME (1<<12)
  
  /* These flags are used in the live flist data. */
  
-@@ -419,6 +420,7 @@ struct file_struct {
+@@ -112,6 +113,7 @@
+ 
+ #define PERMS_REPORT		(1<<0)
+ #define PERMS_SKIP_MTIME	(1<<1)
++#define PERMS_SKIP_ATIME	(1<<2)
+ 
+ #define FULL_FLUSH	1
+ #define NORMAL_FLUSH	0
+@@ -426,6 +428,7 @@ struct file_struct {
  		struct hlink *links;
  	} link_u;
  	time_t modtime;
 +	time_t atime;
  	uid_t uid;
  	gid_t gid;
  	mode_t mode;
---- rsync.yo	24 Apr 2004 06:16:04 -0000	1.164
-+++ rsync.yo	24 Apr 2004 07:33:19 -0000
-@@ -299,6 +299,7 @@ verb(
+--- orig/rsync.yo	2004-09-24 16:42:30
++++ rsync.yo	2004-07-03 20:15:41
+@@ -330,6 +330,7 @@ verb(
   -g, --group                 preserve group
   -D, --devices               preserve devices (root only)
   -t, --times                 preserve times
 + -A, --copy-atimes           copy access times
   -S, --sparse                handle sparse files efficiently
   -n, --dry-run               show what would have been transferred
   -W, --whole-file            copy whole files, no incremental checks
-@@ -543,6 +544,11 @@ modified cannot be effective; in other w
- cause the next transfer to behave as if it used -I, and all files will have
- their checksums compared and show up in log messages even if they haven't
- changed.
-+
+@@ -610,6 +611,11 @@ cause the next transfer to behave as if 
+ updated (though the rsync algorithm will make the update fairly efficient
+ if the files haven't actually changed, you're much better off using -t).
+ 
 +dit(bf(-A, --copy-atimes)) This tells rsync to transfer access times
 +along with the files and update them on the remote system.  Note that
 +reading the source file may update the atime and hence repeated rsync
 +copies with --copy-atimes may copy files unnecessarily.
- 
++
  dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
  instead it will just report the actions it would have taken.
---- tls.c	9 Apr 2004 20:22:44 -0000	1.19
-+++ tls.c	20 Apr 2004 23:44:18 -0000
+ 
+--- orig/testsuite/copy-atimes.test	2004-06-30 00:06:23
++++ testsuite/copy-atimes.test	2004-06-30 00:06:23
+@@ -0,0 +1,19 @@
++#! /bin/sh
++
++# Test rsync copying atimes
++
++. "$suitedir/rsync.fns"
++
++set -x
++
++mkdir "$fromdir"
++
++touch "$fromdir/foo"
++touch -a -t 200102031717.42 "$fromdir/foo"
++
++TLS_ARGS=--atime
++
++checkit "$RSYNC -rtAgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
++
++# The script would have aborted on error, so getting here means we've won.
++exit 0
+--- orig/testsuite/rsync.fns	2004-09-18 01:49:34
++++ testsuite/rsync.fns	2004-07-03 20:15:41
+@@ -50,7 +50,7 @@ printmsg() {
+ 
+ 
+ rsync_ls_lR() {
+-    find "$@" -print | sort | xargs "$TOOLDIR/tls"
++    find "$@" -print | sort | xargs "$TOOLDIR/tls" $TLS_ARGS
+ }
+ 
+ rsync_getgroups() { 
+@@ -158,6 +158,8 @@ checkit() {
+     # We can just write everything to stdout/stderr, because the
+     # wrapper hides it unless there is a problem.
+ 
++    ( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
++
+     echo "Running: \"$1\""  
+     eval "$1" 
+     status=$?
+@@ -166,6 +168,12 @@ checkit() {
+     fi
+ 
+     echo "-------------"
++    echo "check how the directory listings compare with diff:"
++    echo ""
++    ( cd "$3" && rsync_ls_lR . ) > "$tmpdir/ls-to"
++    diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to" || failed=YES
++
++    echo "-------------"
+     echo "check how the files compare with diff:"
+     echo ""
+     for f in `cd "$2"; find . -type f -print `
+@@ -173,12 +181,6 @@ checkit() {
+         diff $diffopt "$2"/"$f" "$3"/"$f" || failed=YES
+     done
+ 
+-    echo "-------------"
+-    echo "check how the directory listings compare with diff:"
+-    echo ""
+-    ( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
+-    ( cd "$3" && rsync_ls_lR . ) > "$tmpdir/ls-to"
+-    diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to" || failed=YES
+     if [ -z "$failed" ] ; then
+ 	return 0
+     else
+--- orig/tls.c	2004-09-23 05:45:24
++++ tls.c	2004-07-03 20:15:41
 @@ -39,6 +39,7 @@
  
  
  #include "rsync.h"
 +#include "popt.h"
  
@@ -303,16 +359,16 @@
 @@ -48,6 +49,7 @@ int read_only = 1;
  int list_only = 0;
  int preserve_perms = 0;
  
 +static int display_atime = 0;
  
- static void failed (char const *what,
- 		    char const *where)
-@@ -57,14 +59,29 @@ static void failed (char const *what,
- 	exit (1);
+ static void failed(char const *what, char const *where)
+ {
+@@ -56,14 +58,29 @@ static void failed(char const *what, cha
+ 	exit(1);
  }
  
 +static void storetime(char *dest, time_t t)
 +{
 +	if (t) {
 +		struct tm *mt = gmtime(&t);
@@ -326,24 +382,24 @@
 +			mt->tm_sec);
 +	} else {
 +		strcpy(dest, "                    ");
 +	}
 +}	
  
- static void list_file (const char *fname)
+ static void list_file(const char *fname)
  {
  	STRUCT_STAT buf;
  	char permbuf[PERMSTRING_SIZE];
 -	struct tm *mt;
 -	char datebuf[50];
 +	char mtimebuf[50];
 +	char atimebuf[50];
  	char linkbuf[4096];
  
  	if (do_lstat(fname, &buf) == -1)
-@@ -97,19 +114,8 @@ static void list_file (const char *fname
+@@ -96,19 +113,8 @@ static void list_file(const char *fname)
  
  	permstring(permbuf, buf.st_mode);
  
 -	if (buf.st_mtime) {
 -		mt = gmtime(&buf.st_mtime);
 -
@@ -359,13 +415,13 @@
 -	}
 +	storetime(mtimebuf, buf.st_mtime);
 +	storetime(atimebuf, buf.st_atime);
  
  	/* TODO: Perhaps escape special characters in fname? */
  
-@@ -120,24 +126,55 @@ static void list_file (const char *fname
+@@ -119,24 +125,55 @@ static void list_file(const char *fname)
  		    (long)minor(buf.st_rdev));
  	} else /* NB: use double for size since it might not fit in a long. */
  		printf("%12.0f", (double)buf.st_size);
 -	printf(" %6ld.%-6ld %6ld %s %s%s\n",
 +	printf(" %6ld.%-6ld %6ld %s%s%s%s\n",
  	       (long)buf.st_uid, (long)buf.st_gid, (long)buf.st_nlink,
@@ -389,14 +445,14 @@
 +}
  
  int
  main(int argc, char *argv[])
  {
 -	if (argc < 2) {
--		fprintf (stderr, "usage: " PROGRAM " DIR ...\n"
--			 "Trivial file listing program for portably checking rsync\n");
+-		fprintf(stderr, "usage: " PROGRAM " DIR ...\n"
+-			"Trivial file listing program for portably checking rsync\n");
 -		return 1;
 +	poptContext pc;
 +	const char **extra_args;
 +	int opt;
 +
 +	pc = poptGetContext(PROGRAM, argc, (const char **)argv,
@@ -412,51 +468,50 @@
 +				poptStrerror(opt));
 +			tls_usage(1);
 +		}
  	}
  
 -	for (argv++; *argv; argv++) {
--		list_file (*argv);
+-		list_file(*argv);
 -	}
 +	extra_args = poptGetArgs(pc);
 +	if (*extra_args == NULL)
 +		tls_usage(1);
 +
 +	for (; *extra_args; extra_args++)
 +		list_file(*extra_args);
 +	poptFreeContext(pc);
  
  	return 0;
  }
---- util.c	22 Apr 2004 22:17:15 -0000	1.138
-+++ util.c	20 Apr 2004 23:44:19 -0000
-@@ -124,32 +124,40 @@ void overflow(char *str)
+--- orig/util.c	2004-09-07 21:45:30
++++ util.c	2004-07-03 20:15:41
+@@ -128,31 +128,39 @@ void overflow(char *str)
  
  
  
 -int set_modtime(char *fname, time_t modtime)
 +int set_times(char *fname, time_t modtime, time_t atime)
  {
- 	extern int dry_run;
  	if (dry_run)
  		return 0;
  
  	if (verbose > 2) {
 -		rprintf(FINFO, "set modtime of %s to (%ld) %s",
 +		char mtimebuf[200];
 +		char atimebuf[200];
 +
-+		strlcpy(mtimebuf, timestring(modtime), sizeof(mtimebuf));
-+		strlcpy(atimebuf, timestring(atime), sizeof(atimebuf));
++		strlcpy(mtimebuf, timestring(modtime), sizeof mtimebuf);
++		strlcpy(atimebuf, timestring(atime), sizeof atimebuf);
 +
 +		rprintf(FINFO,
 +			"set modtime, atime of %s to (%ld) %s, (%ld) %s\n",
- 			fname, (long) modtime,
+ 			fname, (long)modtime,
 -			asctime(localtime(&modtime)));
 +			mtimebuf,
-+			(long) atime, atimebuf);
++			(long)atime, atimebuf);
  	}
  
  	{
  #ifdef HAVE_UTIMBUF
  		struct utimbuf tbuf;
 -		tbuf.actime = time(NULL);
@@ -473,97 +528,26 @@
  		struct timeval t[2];
 -		t[0].tv_sec = time(NULL);
 +		t[0].tv_sec = atime;
  		t[0].tv_usec = 0;
  		t[1].tv_sec = modtime;
  		t[1].tv_usec = 0;
-@@ -1051,8 +1059,8 @@ int msleep(int t)
+@@ -1142,8 +1150,8 @@ int msleep(int t)
  
  
  /**
 - * Determine if two file modification times are equivalent (either
 - * exact or in the modification timestamp window established by
 + * Determine if two file  times are equivalent (either
 + * exact or in the timestamp window established by
   * --modify-window).
   *
   * @retval 0 if the times should be treated as the same
-@@ -1061,7 +1069,7 @@ int msleep(int t)
+@@ -1152,7 +1160,7 @@ int msleep(int t)
   *
   * @retval -1 if the 2nd is later
   **/
 -int cmp_modtime(time_t file1, time_t file2)
 +int cmp_time(time_t file1, time_t file2)
  {
- 	extern int modify_window;
- 
---- /dev/null	1 Jan 1970 00:00:00 -0000
-+++ testsuite/copy-atimes.test	20 Apr 2004 23:44:19 -0000
-@@ -0,0 +1,22 @@
-+#! /bin/sh
-+
-+# Test rsync copying atimes
-+
-+. $srcdir/testsuite/rsync.fns
-+
-+set -x
-+
-+fromdir="$scratchdir/from"
-+todir="$scratchdir/to"
-+
-+mkdir "$fromdir"
-+
-+touch "$fromdir/foo"
-+touch -a -t 200102031717.42 "$fromdir/foo"
-+
-+TLS_ARGS=--atime
-+
-+checkit "$RSYNC -rtAgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
-+
-+# The script would have aborted on error, so getting here means we've won.
-+exit 0
---- testsuite/rsync.fns	4 Feb 2004 07:32:48 -0000	1.59
-+++ testsuite/rsync.fns	20 Apr 2004 23:44:19 -0000
-@@ -51,7 +51,7 @@ printmsg() {
- 
- 
- rsync_ls_lR() {
--    find "$@" -print | sort | xargs "$TOOLDIR/tls"
-+    find "$@" -print | sort | xargs "$TOOLDIR/tls" $TLS_ARGS
- }
- 
- rsync_getgroups() { 
-@@ -151,6 +151,8 @@ checkit() {
-     # We can just write everything to stdout/stderr, because the
-     # wrapper hides it unless there is a problem.
- 
-+    ( cd "$2" && rsync_ls_lR . ) > ${TMP}/ls-from 
-+
-     echo "Running: \"$1\""  
-     eval "$1" 
-     status=$?
-@@ -159,6 +161,12 @@ checkit() {
-     fi
- 
-     echo "-------------"
-+    echo "check how the directory listings compare with diff:"
-+    echo ""
-+    ( cd "$3" && rsync_ls_lR . ) > ${TMP}/ls-to 
-+    diff $diffopt ${TMP}/ls-from ${TMP}/ls-to || failed=YES
-+
-+    echo "-------------"
-     echo "check how the files compare with diff:"
-     echo ""
-     for f in `cd "$2"; find . -type f -print `
-@@ -166,12 +174,6 @@ checkit() {
-         diff $diffopt "$2"/"$f" "$3"/"$f" || failed=YES
-     done
- 
--    echo "-------------"
--    echo "check how the directory listings compare with diff:"
--    echo ""
--    ( cd "$2" && rsync_ls_lR . ) > ${TMP}/ls-from 
--    ( cd "$3" && rsync_ls_lR . ) > ${TMP}/ls-to 
--    diff $diffopt ${TMP}/ls-from ${TMP}/ls-to || failed=YES
-     if [ -z "${failed}" ] ; then
- 	return 0
-     else
+ 	if (file2 > file1) {
+ 		if (file2 - file1 <= modify_window)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/date-only.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/date-only.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/date-only.diff	2004-04-16 03:31:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/date-only.diff	2004-10-01 00:32:37.000000000 +0800
@@ -12,82 +12,84 @@
 
 Best Regards,
 Jeremy Bornstein
 
 [Patched update to have context and apply to latest CVS source.]
 
---- generator.c	15 Apr 2004 16:55:23 -0000	1.79
-+++ generator.c	15 Apr 2004 19:06:13 -0000
-@@ -50,11 +50,14 @@ extern int list_only;
- extern int only_existing;
- extern int orig_umask;
- extern int safe_symlinks;
+--- orig/generator.c	2004-09-20 19:50:13
++++ generator.c	2004-07-03 20:16:51
+@@ -41,6 +41,7 @@ extern int make_backups;
+ extern int csum_length;
+ extern int ignore_times;
+ extern int size_only;
 +extern int date_only;
- 
- 
+ extern int io_timeout;
+ extern int protocol_version;
+ extern int always_checksum;
+@@ -62,6 +63,8 @@ extern struct exclude_list_struct server
  /* choose whether to skip a particular file */
  static int skip_file(char *fname, struct file_struct *file, STRUCT_STAT *st)
  {
 +	if (date_only)
-+		return cmp_modtime(st->st_mtime,file->modtime) == 0;
- 	if (st->st_size != file->length) {
++		return cmp_modtime(st->st_mtime, file->modtime) == 0;
+ 	if (st->st_size != file->length)
  		return 0;
- 	}
---- options.c	14 Apr 2004 23:33:34 -0000	1.146
-+++ options.c	15 Apr 2004 19:06:13 -0000
-@@ -82,6 +82,7 @@ int keep_partial = 0;
+ 	if (link_dest) {
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-07-03 20:16:51
+@@ -84,6 +84,7 @@ int keep_partial = 0;
  int safe_symlinks = 0;
  int copy_unsafe_links = 0;
  int size_only = 0;
 +int date_only = 0;
  int bwlimit = 0;
+ size_t bwlimit_writemax = 0;
  int delete_after = 0;
- int only_existing = 0;
-@@ -262,6 +263,7 @@ void usage(enum logcode F)
+@@ -275,6 +276,7 @@ void usage(enum logcode F)
    rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
    rprintf(F," -I, --ignore-times          turn off mod time & file size quick check\n");
    rprintf(F,"     --size-only             ignore mod time for quick check (use size)\n");
 +  rprintf(F,"     --date-only             ignore size for quick check (use mod time)\n");
    rprintf(F,"     --modify-window=NUM     compare mod times with reduced accuracy\n");
-   rprintf(F," -T  --temp-dir=DIR          create temporary files in directory DIR\n");
+   rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
    rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
-@@ -316,6 +318,7 @@ static struct poptOption long_options[] 
-   {"password-file",    0,  POPT_ARG_STRING, &password_file,	0, 0, 0 },
+@@ -330,6 +332,7 @@ static struct poptOption long_options[] 
+   {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
    {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
    {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
 +  {"date-only",        0,  POPT_ARG_NONE,   &date_only, 0, 0, 0 },
    {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
    {"one-file-system", 'x', POPT_ARG_NONE,   &one_file_system, 0, 0, 0 },
    {"delete",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },
-@@ -905,6 +908,9 @@ void server_options(char **args,int *arg
- 
+@@ -1034,6 +1037,9 @@ void server_options(char **args,int *arg
  	if (size_only)
  		args[ac++] = "--size-only";
-+
+ 
 +	if (date_only)
 +		args[ac++] = "--date-only";
- 
++
  	if (modify_window_set) {
  		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
---- rsync.yo	15 Apr 2004 18:32:24 -0000	1.157
-+++ rsync.yo	15 Apr 2004 19:06:15 -0000
-@@ -320,6 +320,7 @@
+ 			goto oom;
+--- orig/rsync.yo	2004-09-24 16:42:30
++++ rsync.yo	2004-07-03 20:16:51
+@@ -352,6 +352,7 @@ verb(
       --timeout=TIME          set I/O timeout in seconds
   -I, --ignore-times          turn off mod time & file size quick check
       --size-only             ignore mod time for quick check (use size)
 +     --date-only             ignore size for quick check (use mod time)
       --modify-window=NUM     compare mod times with reduced accuracy
   -T  --temp-dir=DIR          create temporary files in directory DIR
       --compare-dest=DIR      also compare received files relative to DIR
-@@ -390,6 +391,12 @@
- regardless of timestamp. This is useful when starting to use rsync
+@@ -426,6 +427,12 @@ regardless of timestamp. This is useful 
  after using another mirroring system which may not preserve timestamps
  exactly.
-+
+ 
 +dit(bf(--date-only)) Normally rsync will skip any files that are
 +already the same size and have the same modification time-stamp. With the
 +--date-only option, files will be skipped if they have the same
 +timestamp, regardless of size. This may be useful when the remote
 +files have passed through a size-changing filter, e.g. for encryption.
- 
++
  dit(bf(--modify-window)) When comparing two timestamps rsync treats
  the timestamps as being equal if they are within the value of
+ modify_window. This is normally zero, but you may find it useful to
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: delete-dir-and-suffix.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/delete-sent-files.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/delete-sent-files.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/delete-sent-files.diff	2004-04-25 02:55:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/delete-sent-files.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,9 +1,15 @@
---- io.c	16 Jan 2004 16:31:47 -0000	1.119
-+++ io.c	24 Apr 2004 07:35:03 -0000
-@@ -222,6 +222,14 @@ static void read_msg_fd(void)
+After applying this patch and running configure, you MUST run this
+command before "make":
+
+    make proto
+
+
+--- orig/io.c	2004-08-02 02:44:26
++++ io.c	2004-07-03 20:17:10
+@@ -240,6 +240,14 @@ static void read_msg_fd(void)
  		read_loop(fd, buf, 4);
  		redo_list_add(IVAL(buf,0));
  		break;
 +	case MSG_SUCCESS:
 +		if (len != 4) {
 +			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
@@ -12,230 +18,216 @@
 +		read_loop(fd, buf, len);
 +		io_multiplex_write(MSG_SUCCESS, buf, len);
 +		break;
  	case MSG_INFO:
  	case MSG_ERROR:
  	case MSG_LOG:
-@@ -637,6 +645,16 @@ static int read_unbuffered(int fd, char 
- 			}
- 			read_loop(fd, buffer, remaining);
- 			bufferIdx = 0;
-+			break;
+@@ -673,6 +681,16 @@ static int readfd_unbuffered(int fd, cha
+ 			read_loop(fd, iobuf_in, remaining);
+ 			iobuf_in_ndx = 0;
+ 			break;
 +		case MSG_SUCCESS:
 +			if (remaining != 4) {
 +				rprintf(FERROR, "invalid multi-message %d:%ld\n",
 +					tag, (long)remaining);
 +				exit_cleanup(RERR_STREAMIO);
 +			}
 +			read_loop(fd, line, remaining);
 +			successful_send(IVAL(line, 0));
 +			remaining = 0;
- 			break;
++			break;
  		case MSG_INFO:
  		case MSG_ERROR:
---- main.c	10 Feb 2004 03:54:47 -0000	1.192
-+++ main.c	24 Apr 2004 07:35:04 -0000
+ 			if (remaining >= sizeof line) {
+--- orig/main.c	2004-09-29 17:58:26
++++ main.c	2004-08-13 08:24:23
 @@ -42,6 +42,7 @@ extern int list_only;
  extern int local_server;
  extern int log_got_error;
  extern int module_id;
 +extern int need_messages_from_generator;
  extern int orig_umask;
- extern int preserve_hard_links;
- extern int protocol_version;
-@@ -567,6 +568,8 @@ void start_server(int f_in, int f_out, i
- 		io_start_multiplex_out(f_out);
+ extern int copy_links;
+ extern int keep_dirlinks;
+@@ -621,6 +622,8 @@ void start_server(int f_in, int f_out, i
  
  	if (am_sender) {
+ 		keep_dirlinks = 0; /* Must be disabled on the sender. */
 +		if (need_messages_from_generator)
-+			io_start_multiplex_in(f_in);
- 		if (!read_batch) {
- 			recv_exclude_list(f_in);
- 			if (cvs_exclude)
-@@ -632,6 +635,9 @@ int client_run(int f_in, int f_out, pid_
- 		io_flush(FULL_FLUSH);
++			io_start_multiplex_in();
+ 
+ 		recv_exclude_list(f_in);
+ 		if (cvs_exclude)
+@@ -702,6 +705,9 @@ int client_run(int f_in, int f_out, pid_
  		exit_cleanup(status);
  	}
-+
-+	if (need_messages_from_generator)
-+		io_start_multiplex_out(f_out);
  
- 	if (argc == 0) {
++	if (need_messages_from_generator && !read_batch)
++		io_start_multiplex_out();
++
+ 	if (argc == 0)
  		list_only = 1;
---- options.c	17 Apr 2004 17:07:23 -0000	1.147
-+++ options.c	24 Apr 2004 07:35:04 -0000
-@@ -84,6 +84,7 @@ int copy_unsafe_links = 0;
- int size_only = 0;
+ 
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-07-16 20:09:54
+@@ -87,8 +87,10 @@ int size_only = 0;
  int bwlimit = 0;
+ size_t bwlimit_writemax = 0;
  int delete_after = 0;
 +int delete_sent_files = 0;
  int only_existing = 0;
  int opt_ignore_existing = 0;
++int need_messages_from_generator = 0;
  int max_delete = 0;
-@@ -91,6 +92,7 @@ int ignore_errors = 0;
+ int ignore_errors = 0;
  int modify_window = 0;
- int blocking_io = -1;
- int checksum_seed = 0;
-+int need_messages_from_generator = 0;
- unsigned int block_size = 0;
- 
- 
-@@ -254,6 +256,7 @@ void usage(enum logcode F)
+@@ -266,6 +268,7 @@ void usage(enum logcode F)
    rprintf(F,"     --delete                delete files that don't exist on the sending side\n");
    rprintf(F,"     --delete-excluded       also delete excluded files on the receiving side\n");
    rprintf(F,"     --delete-after          receiver deletes after transferring, not before\n");
 +  rprintf(F,"     --delete-sent-files     updated/sent files are removed from sending side\n");
    rprintf(F,"     --ignore-errors         delete even if there are I/O errors\n");
    rprintf(F,"     --max-delete=NUM        don't delete more than NUM files\n");
    rprintf(F,"     --partial               keep partially transferred files\n");
-@@ -303,8 +306,8 @@ void usage(enum logcode F)
+@@ -317,8 +320,8 @@ void usage(enum logcode F)
  }
  
  enum {OPT_VERSION = 1000, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
 -      OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_LINK_DEST,
 -      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
 +      OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_DELETE_SENT_FILES,
 +      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_LINK_DEST, OPT_MODIFY_WINDOW,
-       OPT_READ_BATCH, OPT_WRITE_BATCH,
+       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT,
        OPT_REFUSED_BASE = 9000};
  
-@@ -323,6 +326,7 @@ static struct poptOption long_options[] 
+@@ -337,6 +340,7 @@ static struct poptOption long_options[] 
    {"ignore-existing",  0,  POPT_ARG_NONE,   &opt_ignore_existing, 0, 0, 0 },
    {"delete-after",     0,  POPT_ARG_NONE,   0,              OPT_DELETE_AFTER, 0, 0 },
    {"delete-excluded",  0,  POPT_ARG_NONE,   0,              OPT_DELETE_EXCLUDED, 0, 0 },
 +  {"delete-sent-files",0,  POPT_ARG_NONE,   0,              OPT_DELETE_SENT_FILES, 0, 0 },
    {"force",            0,  POPT_ARG_NONE,   &force_delete, 0, 0, 0 },
    {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
    {"exclude",          0,  POPT_ARG_STRING, 0,              OPT_EXCLUDE, 0, 0 },
-@@ -509,6 +513,11 @@ int parse_arguments(int *argc, const cha
+@@ -539,6 +543,11 @@ int parse_arguments(int *argc, const cha
  			delete_mode = 1;
  			break;
  
 +		case OPT_DELETE_SENT_FILES:
 +			delete_sent_files = 1;
 +			need_messages_from_generator = 1;
 +			break;
 +
  		case OPT_EXCLUDE:
  			add_exclude(&exclude_list, poptGetOptArg(pc), 0);
  			break;
-@@ -964,6 +973,9 @@ void server_options(char **args,int *arg
- 			args[ac++] = "--from0";
+@@ -1099,6 +1108,9 @@ void server_options(char **args,int *arg
  		}
  	}
-+
+ 
 +	if (delete_sent_files)
 +		args[ac++] = "--delete-sent-files";
- 
++
  	*argc = ac;
  	return;
---- proto.h	22 Apr 2004 09:58:09 -0000	1.189
-+++ proto.h	24 Apr 2004 07:35:04 -0000
-@@ -197,6 +197,7 @@ void sig_int(void);
- void finish_transfer(char *fname, char *fnametmp, struct file_struct *file);
- const char *who_am_i(void);
- void read_sum_head(int f, struct sum_struct *sum);
-+void successful_send(int i);
- void send_files(struct file_list *flist, int f_out, int f_in);
- int try_bind_local(int s, int ai_family, int ai_socktype,
- 		   const char *bind_address);
---- receiver.c	23 Mar 2004 16:50:40 -0000	1.75
-+++ receiver.c	24 Apr 2004 07:35:04 -0000
-@@ -45,6 +45,7 @@ extern int cleanup_got_literal;
+ 
+--- orig/receiver.c	2004-09-21 09:40:27
++++ receiver.c	2004-08-13 08:38:51
+@@ -45,6 +45,7 @@ extern char *backup_dir;
+ extern char *backup_suffix;
+ extern int backup_suffix_len;
+ extern int cleanup_got_literal;
++extern int delete_sent_files;
  extern int module_id;
  extern int ignore_errors;
  extern int orig_umask;
-+extern int delete_sent_files;
- 
- static void delete_one(char *fn, int is_dir)
- {
-@@ -292,7 +293,7 @@ int recv_files(int f_in,struct file_list
+@@ -337,7 +338,7 @@ int recv_files(int f_in, struct file_lis
  	char *fname, fbuf[MAXPATHLEN];
  	char template[MAXPATHLEN];
  	char fnametmp[MAXPATHLEN];
--	char *fnamecmp;
-+	char *fnamecmp, numbuf[4];
+-	char *fnamecmp, *partialptr;
++	char *fnamecmp, *partialptr, numbuf[4];
  	char fnamecmpbuf[MAXPATHLEN];
- 	struct map_struct *mapbuf;
- 	int i;
-@@ -467,16 +468,20 @@ int recv_files(int f_in,struct file_list
+ 	struct file_struct *file;
+ 	struct stats initial_stats;
+@@ -572,7 +573,12 @@ int recv_files(int f_in, struct file_lis
  
  		cleanup_disable();
  
 -		if (!recv_ok) {
 +		if (recv_ok) {
 +			if (delete_sent_files) {
 +				SIVAL(numbuf, 0, i);
 +				send_msg(MSG_SUCCESS, numbuf, 4);
 +			}
 +		} else {
- 			if (csum_length == SUM_LENGTH) {
- 				rprintf(FERROR,"ERROR: file corruption in %s. File changed during transfer?\n",
- 					full_fname(fname));
- 			} else {
+ 			int msgtype = csum_length == SUM_LENGTH || read_batch ?
+ 				FERROR : FINFO;
+ 			if (msgtype == FERROR || verbose) {
+@@ -596,9 +602,8 @@ int recv_files(int f_in, struct file_lis
+ 					keptstr, redostr);
+ 			}
+ 			if (csum_length != SUM_LENGTH) {
 -				char buf[4];
- 				if (verbose > 1)
- 					rprintf(FINFO,"redoing %s(%d)\n",fname,i);
 -				SIVAL(buf, 0, i);
 -				send_msg(MSG_REDO, buf, 4);
 +				SIVAL(numbuf, 0, i);
 +				send_msg(MSG_REDO, numbuf, 4);
  			}
  		}
  	}
---- rsync.h	22 Apr 2004 09:58:24 -0000	1.198
-+++ rsync.h	24 Apr 2004 07:35:04 -0000
+--- orig/rsync.h	2004-09-22 08:47:31
++++ rsync.h	2004-07-03 20:17:10
 @@ -60,6 +60,7 @@
  #define FLAG_TOP_DIR (1<<0)
  #define FLAG_HLINK_EOL (1<<1)	/* generator only */
  #define FLAG_MOUNT_POINT (1<<2)	/* sender only */
 +#define FLAG_SENT (1<<7)	/* sender only */
  
  /* update this if you make incompatible changes */
  #define PROTOCOL_VERSION 28
-@@ -124,6 +125,7 @@ enum msgcode {
- 	MSG_ERROR=FERROR, MSG_INFO=FINFO, MSG_LOG=FLOG, /* remote logging */
- 	MSG_REDO=4,	/* reprocess indicated flist index */
- 	MSG_DONE=5,	/* current phase is done */
+@@ -127,6 +128,7 @@ enum logcode { FERROR=1, FINFO=2, FLOG=3
+ /* Messages types that are sent over the message channel.  The logcode
+  * values must all be present here with identical numbers. */
+ enum msgcode {
 +	MSG_SUCCESS=6,	/* successfully updated indicated flist index */
- };
- 
- #include "errcode.h"
---- rsync.yo	24 Apr 2004 06:16:04 -0000	1.164
-+++ rsync.yo	24 Apr 2004 07:35:05 -0000
-@@ -312,6 +312,7 @@ verb(
+ 	MSG_DONE=5,	/* current phase is done */
+ 	MSG_REDO=4,	/* reprocess indicated flist index */
+ 	MSG_ERROR=FERROR, MSG_INFO=FINFO, MSG_LOG=FLOG, /* remote logging */
+--- orig/rsync.yo	2004-09-24 16:42:30
++++ rsync.yo	2004-07-03 20:17:10
+@@ -343,6 +343,7 @@ verb(
       --delete                delete files that don't exist on sender
       --delete-excluded       also delete excluded files on receiver
       --delete-after          receiver deletes after transfer, not before
 +     --delete-sent-files     updated/sent files are removed from sender
       --ignore-errors         delete even if there are I/O errors
       --max-delete=NUM        don't delete more than NUM files
       --partial               keep partially transferred files
-@@ -594,6 +595,11 @@ dit(bf(--delete-after)) By default rsync
- receiving side before transferring files to try to ensure that there is
+@@ -661,6 +662,11 @@ receiving side before transferring files
  sufficient space on the receiving filesystem. If you want to delete
  after transferring, use the --delete-after switch. Implies --delete.
-+
+ 
 +dit(bf(--delete-sent-files)) This tells rsync to remove the source files
 +on the sending side that are successfully transferred to the receiving
 +side.  Directories are not removed, nor are files that are identical on
 +both systems.
- 
++
  dit(bf(--ignore-errors)) Tells --delete to go ahead and delete files
  even when there are I/O errors.
---- sender.c	17 Feb 2004 21:57:44 -0000	1.38
-+++ sender.c	24 Apr 2004 07:35:05 -0000
-@@ -27,6 +27,7 @@ extern int dry_run;
+ 
+--- orig/sender.c	2004-09-20 05:10:48
++++ sender.c	2004-07-26 16:49:19
+@@ -26,6 +26,7 @@ extern int io_error;
+ extern int dry_run;
  extern int am_server;
  extern int am_daemon;
- extern int protocol_version;
 +extern int delete_sent_files;
- 
- 
- /**
-@@ -104,7 +105,29 @@ static struct sum_struct *receive_sums(i
+ extern int protocol_version;
+ extern int make_backups;
+ extern struct stats stats;
+@@ -108,7 +109,29 @@ static struct sum_struct *receive_sums(i
  	return s;
  }
  
 +static struct file_list *the_flist;
  
 +void successful_send(int i)
@@ -259,25 +251,25 @@
 +	if (delete_sent_files && do_unlink(fname) == 0 && verbose > 0)
 +		rprintf(FINFO, "sender removed %s\n", fname + offset);
 +}
  
  void send_files(struct file_list *flist, int f_out, int f_in)
  {
-@@ -129,6 +152,8 @@ void send_files(struct file_list *flist,
+@@ -127,6 +150,8 @@ void send_files(struct file_list *flist,
  	if (verbose > 2)
  		rprintf(FINFO, "send_files starting\n");
  
 +	the_flist = flist;
 +
  	while (1) {
  		unsigned int offset;
  
-@@ -302,6 +327,9 @@ void send_files(struct file_list *flist,
- 
- 		if (verbose > 2)
- 			rprintf(FINFO, "sender finished %s\n", fname);
+@@ -257,6 +282,9 @@ void send_files(struct file_list *flist,
+ 			rprintf(FINFO, "sender finished %s\n",
+ 				safe_fname(fname));
+ 		}
 +
 +		/* Flag that we actually sent this entry. */
 +		file->flags |= FLAG_SENT;
  	}
+ 	make_backups = save_make_backups;
  
- 	if (verbose > 2)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: dir-times.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches: early-chmod.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: flist_stats.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: fname-convert.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/fsync.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/fsync.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/fsync.diff	2004-04-28 04:06:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/fsync.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,85 +1,85 @@
 This patch from Sami Farin lets you specify --fsync if you want fsync()
 to be called on every file we write.
 
---- options.c	17 Apr 2004 17:07:23 -0000	1.147
-+++ options.c	27 Apr 2004 20:05:03 -0000
-@@ -37,6 +37,7 @@ int make_backups = 0;
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-07-03 20:18:13
+@@ -38,6 +38,7 @@ int make_backups = 0;
   **/
  int whole_file = -1;
  
 +int do_fsync = 0;
  int archive_mode = 0;
+ int keep_dirlinks = 0;
  int copy_links = 0;
- int preserve_links = 0;
-@@ -230,6 +231,7 @@ void usage(enum logcode F)
+@@ -240,6 +241,7 @@ void usage(enum logcode F)
    rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
    rprintf(F,"     --backup-dir            make backups into this directory\n");
    rprintf(F,"     --suffix=SUFFIX         backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
 +  rprintf(F,"     --fsync                 fsync every written file\n");
    rprintf(F," -u, --update                update only (don't overwrite newer files)\n");
-   rprintf(F," -l, --links                 copy symlinks as symlinks\n");
-   rprintf(F," -L, --copy-links            copy the referent of all symlinks\n");
-@@ -332,6 +334,7 @@ static struct poptOption long_options[] 
+   rprintf(F,"     --inplace               update destination files inplace (SEE MAN PAGE)\n");
+   rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
+@@ -346,6 +348,7 @@ static struct poptOption long_options[] 
    {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
    {"help",            'h', POPT_ARG_NONE,   0,              'h', 0, 0 },
    {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
 +  {"fsync",            0,  POPT_ARG_NONE,   &do_fsync, 0, 0, 0 },
    {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
    {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
    {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
-@@ -943,6 +946,9 @@ void server_options(char **args,int *arg
- 		args[ac++] = "--temp-dir";
+@@ -1078,6 +1081,9 @@ void server_options(char **args,int *arg
  		args[ac++] = tmpdir;
  	}
-+
+ 
 +	if (do_fsync && am_sender)
 +		args[ac++] = "--fsync";
- 
++
  	if (compare_dest && am_sender) {
  		/* the server only needs this option if it is not the sender,
---- receiver.c	27 Apr 2004 19:51:33 -0000	1.76
-+++ receiver.c	27 Apr 2004 20:05:03 -0000
-@@ -45,6 +45,7 @@ extern int cleanup_got_literal;
- extern int module_id;
- extern int ignore_errors;
- extern int orig_umask;
+ 		 *   and it may be an older version that doesn't know this
+--- orig/receiver.c	2004-09-21 09:40:27
++++ receiver.c	2004-07-16 20:13:31
+@@ -36,6 +36,7 @@ extern int preserve_hard_links;
+ extern int preserve_perms;
+ extern int cvs_exclude;
+ extern int io_error;
 +extern int do_fsync;
+ extern char *tmpdir;
+ extern char *partial_dir;
+ extern char *compare_dest;
+@@ -305,6 +306,12 @@ static int receive_data(int f_in, char *
+ 		exit_cleanup(RERR_FILEIO);
+ 	}
  
- static void delete_one(char *fn, int is_dir)
- {
-@@ -264,6 +265,12 @@ static int receive_data(int f_in,struct 
- 
- 	if (fd != -1 && offset > 0 && sparse_end(fd) != 0) {
- 		rprintf(FERROR, "write failed on %s: %s\n",
-+			full_fname(fname), strerror(errno));
++	if (do_fsync && fd != -1 && fsync(fd) != 0) {
++		rsyserr(FERROR, errno, "fsync failed on %s",
++			full_fname(fname));
 +		exit_cleanup(RERR_FILEIO);
 +	}
 +
-+	if (do_fsync && (fd != -1) && (fsync(fd) != 0)) {
-+		rprintf(FERROR, "fsync failed on %s: %s\n",
- 			full_fname(fname), strerror(errno));
- 		exit_cleanup(RERR_FILEIO);
- 	}
---- util.c	27 Apr 2004 19:59:37 -0000	1.141
-+++ util.c	27 Apr 2004 20:05:04 -0000
-@@ -29,6 +29,7 @@
+ 	sum_end(file_sum1);
  
- extern int verbose;
+ 	if (mapbuf)
+--- orig/util.c	2004-09-07 21:45:30
++++ util.c	2004-07-03 20:18:13
+@@ -33,6 +33,7 @@ extern int module_id;
+ extern int modify_window;
+ extern char *partial_dir;
  extern struct exclude_list_struct server_exclude_list;
 +extern int do_fsync;
  
  int sanitize_paths = 0;
  
-@@ -296,6 +297,12 @@ int copy_file(char *source, char *dest, 
+@@ -298,6 +299,12 @@ int copy_file(char *source, char *dest, 
+ 		return -1;
+ 	}
  
- 	if (close(ofd) < 0) {
- 		rprintf(FERROR, "close failed on %s: %s\n",
-+			full_fname(dest), strerror(errno));
++	if (do_fsync && fsync(ofd) < 0) {
++		rsyserr(FERROR, errno, "fsync failed on %s",
++			full_fname(dest));
 +		return -1;
 +	}
 +
-+	if (do_fsync && fsync(ofd) < 0) {
-+		rprintf(FERROR, "fsync failed on %s: %s\n",
- 			full_fname(dest), strerror(errno));
- 		return -1;
- 	}
+ 	return 0;
+ }
+ 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: fuzzy.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: g2r-basis-filename.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/ignore-case.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/ignore-case.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/ignore-case.diff	2004-04-23 07:56:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/ignore-case.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,120 +1,129 @@
-From: David Bolen <db3l@fitlinxx.com>
-To: Peter Tattam <peter@jazz-1.trumpet.com.au>
-Cc: rsync@lists.samba.org
-Subject: RE: mixed case file systems.
-Date: Thu, 18 Apr 2002 23:04:06 -0400
+This adds the --ignore-case option, which makes rsync compare filenames
+in a case-insensitive manner.
 
-Peter Tattam [peter@jazz-1.trumpet.com.au] writes:
-
-> I believe a suitable workaround would be to ignore case for file names
-> when the rsync process is undertaken.  Is this facility available or
-> planned in the near future?
-
-I've attached a context diff for some changes I made to our local copy
-a while back to add an "--ignore-case" option just for this purpose.
-In our case it came up in the context of disting between NTFS and FAT
-remote systems.  I think we ended up not needing it, but it does make
-rsync match filenames in a case insensitive manner, so it might at
-least be worth trying to see if it resolves your issue.
-
-A few caveats - both ends have to support the option - I couldn't make
-it backwards compatible because both ends exchange information about a
-sorted file list that has to sort the same way on either side (which
-very subtly bit me when I first did this).  I also didn't bump the
-protocol in this patch (wasn't quite sure it was appropriate just for an
-incompatible command line option) since it was for local use.
-
-NOTE: patch updated for latest CVS source by Wayne Davison, but UNTESTED!
-
--- David
-
-/-----------------------------------------------------------------------\
- \               David Bolen            \   E-mail: db3l@fitlinxx.com  /
-  |             FitLinxx, Inc.            \  Phone: (203) 708-5192    |
- /  860 Canal Street, Stamford, CT  06902   \  Fax: (203) 316-5150     \
-\-----------------------------------------------------------------------/
-
-	  - - - - - - - - - - - - - - - - - - - - - - - - -
-
---- options.c	17 Apr 2004 17:07:23 -0000	1.147
-+++ options.c	22 Apr 2004 23:44:15 -0000
-@@ -89,6 +89,7 @@ int opt_ignore_existing = 0;
+--- orig/lib/wildmatch.c	2003-07-14 15:12:59
++++ lib/wildmatch.c	2004-08-13 16:43:27
+@@ -53,6 +53,8 @@
+ #define ISUPPER(c) (ISASCII(c) && isupper(c))
+ #define ISXDIGIT(c) (ISASCII(c) && isxdigit(c))
+ 
++extern int ignore_case;
++
+ #ifdef WILD_TEST_ITERATIONS
+ int wildmatch_iteration_count;
+ #endif
+@@ -76,9 +78,19 @@ static int domatch(const unsigned char *
+ 	    ch = *++p;
+ 	    /* FALLTHROUGH */
+ 	  default:
+-	    if (*text != ch)
+-		return FALSE;
+-	    continue;
++	    if (*text == ch)
++		continue;
++	    if (ignore_case) {
++		if (ISUPPER(*text)) {
++		    if (tolower(*text) == ch)
++			continue;
++		}
++		else if (ISUPPER(ch)) {
++		    if (*text == tolower(ch))
++			continue;
++		}
++	    }
++	    return FALSE;
+ 	  case '?':
+ 	    /* Match anything but '/'. */
+ 	    if (*text == '/')
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-07-29 16:13:45
+@@ -92,6 +92,7 @@ int opt_ignore_existing = 0;
  int max_delete = 0;
  int ignore_errors = 0;
  int modify_window = 0;
 +int ignore_case = 0;
  int blocking_io = -1;
  int checksum_seed = 0;
- unsigned int block_size = 0;
-@@ -275,6 +276,7 @@ void usage(enum logcode F)
+ int inplace = 0;
+@@ -288,6 +289,7 @@ void usage(enum logcode F)
    rprintf(F,"     --include-from=FILE     don't exclude patterns listed in FILE\n");
    rprintf(F,"     --files-from=FILE       read FILE for list of source-file names\n");
-   rprintf(F," -0  --from0                 all *-from file lists are delimited by nulls\n");
+   rprintf(F," -0, --from0                 all *-from file lists are delimited by nulls\n");
 +  rprintf(F,"     --ignore-case           ignore case when comparing filenames\n");
    rprintf(F,"     --version               print version number\n");
    rprintf(F,"     --daemon                run as an rsync daemon\n");
    rprintf(F,"     --no-detach             do not detach from the parent\n");
-@@ -329,6 +331,7 @@ static struct poptOption long_options[] 
+@@ -343,6 +345,7 @@ static struct poptOption long_options[] 
    {"include",          0,  POPT_ARG_STRING, 0,              OPT_INCLUDE, 0, 0 },
    {"exclude-from",     0,  POPT_ARG_STRING, 0,              OPT_EXCLUDE_FROM, 0, 0 },
    {"include-from",     0,  POPT_ARG_STRING, 0,              OPT_INCLUDE_FROM, 0, 0 },
 +  {"ignore-case",      0,  POPT_ARG_NONE,   &ignore_case, 0, 0, 0 },
    {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
    {"help",            'h', POPT_ARG_NONE,   0,              'h', 0, 0 },
    {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
-@@ -911,6 +914,9 @@ void server_options(char **args,int *arg
- 			goto oom;
+@@ -1046,6 +1049,9 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
-+
+ 
 +	if (ignore_case)
 +		args[ac++] = "--ignore-case";
++
+ 	if (partial_dir && am_sender) {
+ 		args[ac++] = "--partial-dir";
+ 		args[ac++] = partial_dir;
+--- orig/t_stub.c	2004-07-29 16:08:04
++++ t_stub.c	2004-08-13 17:19:56
+@@ -28,6 +28,7 @@
+ 
+ int modify_window = 0;
+ int module_id = -1;
++int ignore_case = 0;
+ char *partial_dir;
+ struct exclude_list_struct server_exclude_list;
+ 
+--- orig/util.c	2004-09-07 21:45:30
++++ util.c	2004-08-13 16:40:34
+@@ -31,6 +31,7 @@ extern int verbose;
+ extern int dry_run;
+ extern int module_id;
+ extern int modify_window;
++extern int ignore_case;
+ extern char *partial_dir;
+ extern struct exclude_list_struct server_exclude_list;
  
- 	if (keep_partial)
- 		args[ac++] = "--partial";
---- util.c	22 Apr 2004 22:17:15 -0000	1.138
-+++ util.c	22 Apr 2004 23:44:15 -0000
-@@ -924,6 +924,19 @@ int u_strcmp(const char *cs1, const char
+@@ -1015,11 +1016,23 @@ int u_strcmp(const char *cs1, const char
  {
  	const uchar *s1 = (const uchar *)cs1;
  	const uchar *s2 = (const uchar *)cs2;
-+	extern int ignore_case;
 + 	
 +	if (ignore_case) {
-+		while (*s1 && *s2) {
-+			uchar c1 = islower(*s1) ? toupper(*s1) : *s1;
-+			uchar c2 = islower(*s2) ? toupper(*s2) : *s2;
-+			if (c1 != c2)
-+				return (int)c1 - (int)c2;
-+			s1++; s2++;
++		uchar c1, c2;
++		while (1) {
++			c1 = islower(*s1) ? toupper(*s1) : *s1;
++			c2 = islower(*s2) ? toupper(*s2) : *s2;
++			if (!c1 || c1 != c2)
++				break;
++			s1++, s2++;
 +		}
+ 
+-	while (*s1 && *s2 && (*s1 == *s2)) {
+-		s1++; s2++;
++		return (int)c1 - (int)c2;
+ 	}
+ 
++	while (*s1 && *s1 == *s2)
++		s1++, s2++;
 +
-+		return (int)*s1 - (int)*s2;
-+	}
+ 	return (int)*s1 - (int)*s2;
+ }
+ 
+--- orig/wildtest.c	2004-02-07 18:40:52
++++ wildtest.c	2004-08-13 17:19:34
+@@ -16,6 +16,7 @@ int fnmatch_errors = 0;
+ #endif
+ 
+ int wildmatch_errors = 0;
++int ignore_case = 0;
+ 
+ typedef char bool;
  
- 	while (*s1 && *s2 && (*s1 == *s2)) {
- 		s1++; s2++;
---- lib/wildmatch.c	14 Jul 2003 15:12:59 -0000	1.12
-+++ lib/wildmatch.c	22 Apr 2004 23:44:15 -0000
-@@ -76,8 +76,20 @@ static int domatch(const unsigned char *
- 	    ch = *++p;
- 	    /* FALLTHROUGH */
- 	  default:
--	    if (*text != ch)
-+	    if (*text != ch) {
-+		extern int ignore_case;
-+		if (ignore_case) {
-+		    if (ISUPPER(*text)) {
-+			if (tolower(*text) == ch)
-+			    continue;
-+		    }
-+		    else if (ISUPPER(ch)) {
-+			if (*text == tolower(ch))
-+			    continue;
-+		    }
-+		}
- 		return FALSE;
-+	    }
- 	    continue;
- 	  case '?':
- 	    /* Match anything but '/'. */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches: inplace.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/link-by-hash.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/link-by-hash.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/link-by-hash.diff	2004-04-23 00:43:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/link-by-hash.diff	2004-09-28 02:52:51.000000000 +0800
@@ -1,47 +1,33 @@
-To: rsync@lists.samba.org
-From: "Jason M. Felice" <jfelice@cronosys.com>
-Subject: [patch] Add `--link-by-hash' option (rev 5).
-Date: Mon, 23 Feb 2004 13:29:08 -0500
+After applying this patch and running configure, you MUST run this
+command before "make":
+
+    make proto
+
+Jason M. Felice writes:
 
 This patch adds the --link-by-hash=DIR option, which hard links received
 files in a link farm arranged by MD4 file hash.  The result is that the system
 will only store one copy of the unique contents of each file, regardless of
 the file's name.
 
-(rev 5)
-* Fixed silly logic error.
-
-(rev 4)
-* Updated for committed robust_rename() patch, other changes in CVS.
-
-(rev 3)
-* Don't link empty files.
-* Roll over to new file when filesystem maximum link count is reached.
-* If link fails for another reason, leave non-linked file there.
-* Depends on rsync-rename.diff
-
-(rev 2)
-* This revision is actually against CVS HEAD (I didn't realize I was working
-  from a stale rsync'd CVS).
-* Apply permissions after linking (permissions were lost if we already had
-  a copy of the file in the link farm).
-
-Patch Summary:
 
-    -1   +1    Makefile.in
-    -0   +351  hashlink.c (new)
-    -1   +22   options.c
-    -0   +6    proto.h
-    -6   +21   receiver.c
-    -2   +8    rsync.c
-    -0   +8    rsync.h
-
---- hashlink.c	1969-12-31 19:00:00.000000000 -0500
-+++ hashlink.c	2004-02-23 10:30:45.000000000 -0500
-@@ -0,0 +1,351 @@
+--- orig/Makefile.in	2004-08-13 07:18:58
++++ Makefile.in	2004-07-03 20:20:15
+@@ -35,7 +35,7 @@ OBJS1=rsync.o generator.o receiver.o cle
+ 	main.o checksum.o match.o syscall.o log.o backup.o
+ OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
+ 	fileio.o batch.o clientname.o
+-OBJS3=progress.o pipe.o
++OBJS3=progress.o pipe.o hashlink.o
+ DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
+ popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
+ 	popt/popthelp.o popt/poptparse.o
+--- orig/hashlink.c	2004-09-24 16:44:25
++++ hashlink.c	2004-09-24 16:44:25
+@@ -0,0 +1,340 @@
 +/*
 +   Copyright (C) Cronosys, LLC 2004
 +
 +   This program is free software; you can redistribute it and/or modify
 +   it under the terms of the GNU General Public License as published by
 +   the Free Software Foundation; either version 2 of the License, or
@@ -122,18 +108,17 @@
 +	struct dirent *di;
 +	struct hashfile_struct *hashfiles = NULL, *hashfile;
 +	STRUCT_STAT st;
 +	long this_fnbr;
 +
 +	*fnbr = 0;
-+	
++
 +	/* Build a list of potential candidates and open
 +	 * them. */
 +	if ((d = opendir(hashname)) == NULL) {
-+		rprintf(FERROR,"opendir \"%s\": %s\n",
-+			hashname, strerror(errno));
++		rsyserr(FERROR, errno, "opendir failed: \"%s\"", hashname);
 +		free(hashname);
 +		return NULL;
 +	}
 +	while ((di = readdir(d)) != NULL) {
 +		if (!strcmp(di->d_name,".") || !strcmp(di->d_name,"..")) {
 +			continue;
@@ -146,26 +131,24 @@
 +			*fnbr = this_fnbr;
 +
 +		hashfile = (struct hashfile_struct*)malloc(sizeof(struct hashfile_struct));
 +		asprintf(&hashfile->name,"%s/%s",hashname,
 +			 di->d_name);
 +		if (do_stat(hashfile->name,&st) == -1) {
-+			rprintf(FERROR,"%s: %s", hashfile->name,
-+				strerror(errno));
++			rsyserr(FERROR, errno, "stat failed: %s", hashfile->name);
 +			kill_hashfile(hashfile);
 +			continue;
 +		}
 +		if (st.st_size != size) {
 +			kill_hashfile(hashfile);
 +			continue;
 +		}
 +		hashfile->nlink = st.st_nlink;
 +		hashfile->fd = open(hashfile->name,O_RDONLY|O_BINARY);
 +		if (hashfile->fd == -1) {
-+			rprintf(FERROR,"%s: %s\n", hashfile->name,
-+				strerror(errno));
++			rsyserr(FERROR, errno, "open failed: %s", hashfile->name);
 +			kill_hashfile(hashfile);
 +			continue;
 +		}
 +		if (hashfiles == NULL)
 +			hashfiles = hashfile->next = hashfile->prev = hashfile;
 +		else {
@@ -224,17 +207,16 @@
 +		} while (iter != files);
 +
 +		if (iter == NULL && files == NULL) {
 +			/* There are no matches. */
 +			return NULL;
 +		}
-+		
 +	}
 +
 +	if (amt == -1) {
-+		rprintf(FERROR,"%s",strerror(errno));
++		rsyserr(FERROR, errno, "read failed in compare_hashfiles()");
 +		kill_hashfiles(files);
 +		return NULL;
 +	}
 +
 +	/* If we only have one file left, use it. */
 +	if (files == files->next) {
@@ -264,13 +246,13 @@
 +}
 +
 +
 +int link_by_hash(char *fnametmp,char *fname,struct file_struct *file)
 +{
 +	STRUCT_STAT st;
-+	char *hashname = make_hash_name(file);		
++	char *hashname = make_hash_name(file);
 +	int first = 0, rc;
 +	char *linkname;
 +	long last_fnbr;
 +
 +	if (file->length == 0) {
 +		return robust_rename(fnametmp,fname,0644);
@@ -280,56 +262,52 @@
 +		char *dirname;
 +
 +		/* Directory does not exist. */
 +		dirname = strdup(hashname);
 +		*strrchr(dirname,'/') = 0;
 +		if (do_mkdir(dirname, 0755) == -1 && errno != EEXIST) {
-+			rprintf(FERROR, "mkdir %s: %s\n", dirname,
-+				strerror(errno));
++			rsyserr(FERROR, errno, "mkdir failed: %s", dirname);
 +			free(hashname);
 +			free(dirname);
 +			return robust_rename(fnametmp,fname,0644);
 +		}
 +		free(dirname);
 +
 +		if (do_mkdir(hashname, 0755) == -1 && errno != EEXIST) {
-+			rprintf(FERROR, "mkdir %s: %s\n", hashname,
-+				strerror(errno));
++			rsyserr(FERROR, errno, "mkdir failed: %s", hashname);
 +			free(hashname);
 +			return robust_rename(fnametmp,fname,0644);
 +		}
 +
 +		first = 1;
 +		asprintf(&linkname,"%s/0",hashname);
 +		rprintf(FINFO, "(1) linkname = %s\n", linkname);
-+			
 +	} else {
 +		struct hashfile_struct *hashfiles, *hashfile;
-+		int fd;
 +
 +		if (do_stat(fnametmp,&st) == -1) {
-+			rprintf(FERROR,"%s: %s\n",fname,strerror(errno));
++			rsyserr(FERROR, errno, "stat failed: %s", fname);
 +			return -1;
 +		}
 +		hashfiles = find_hashfiles(hashname, st.st_size, &last_fnbr);
 +
 +		if (hashfiles == NULL) {
 +			first = 1;
 +			asprintf(&linkname,"%s/0",hashname);
 +			rprintf(FINFO, "(2) linkname = %s\n", linkname);
 +		} else {
-+			
++			int fd;
 +			/* Search for one identical to us. */
 +			if ((fd = open(fnametmp,O_RDONLY|O_BINARY)) == -1) {
-+				rprintf(FERROR,"%s: %s\n",fnametmp,
-+					strerror(errno));
++				rsyserr(FERROR, errno, "open failed: %s", fnametmp);
 +				kill_hashfiles(hashfiles);
 +				return -1;
 +			}
 +			hashfile = compare_hashfiles(fd, hashfiles);
 +			hashfiles = NULL;
++			close(fd);
 +
 +			if (hashfile) {
 +				first = 0;
 +				linkname = strdup(hashfile->name);
 +				rprintf(FINFO, "(3) linkname = %s\n", linkname);
 +				kill_hashfile(hashfile);
@@ -342,26 +320,25 @@
 +		}
 +	}
 +
 +	if (!first) {
 +		rprintf(FINFO, "link-by-hash (existing): \"%s\" -> %s\n",
 +				linkname, full_fname(fname));
++		robust_unlink(fname);
 +		rc = do_link(linkname, fname);
 +		if (rc == -1) {
 +			if (errno == EMLINK) {
 +				first = 1;
 +				free(linkname);
 +				asprintf(&linkname,"%s/%ld",hashname,
 +					 last_fnbr + 1);
 +				rprintf(FINFO, "(5) linkname = %s\n", linkname);
 +				rprintf(FINFO,"link-by-hash: max link count exceeded, starting new file \"%s\".\n", linkname);
 +			} else {
-+				rprintf(FERROR,"link \"%s\" -> %s: %s\n",
-+					linkname,full_fname(fname),
-+					strerror(errno));
-+				robust_unlink(fname);
++				rsyserr(FERROR, errno, "link \"%s\" -> \"%s\"",
++					linkname, full_fname(fname));
 +				rc = robust_rename(fnametmp,fname,0644);
 +			}
 +		} else {
 +			do_unlink(fnametmp);
 +		}
 +	}
@@ -369,253 +346,209 @@
 +	if (first) {
 +		rprintf(FINFO, "link-by-hash (new): %s -> \"%s\"\n",
 +				full_fname(fname),linkname);
 +
 +		rc = robust_rename(fnametmp,fname,0644);
 +		if (rc != 0) {
-+			rprintf(FERROR,"rename \"%s\" -> \"%s\": %s\n",
-+				full_fname(fnametmp),full_fname(fname),
-+				strerror(errno));
++			rsyserr(FERROR, errno, "rename \"%s\" -> \"%s\"",
++				full_fname(fnametmp), full_fname(fname));
 +		}
 +		rc = do_link(fname,linkname);
 +		if (rc != 0) {
-+			rprintf(FERROR,"link \"%s\" -> \"%s\": %s\n",
-+				full_fname(fname),linkname,
-+				strerror(errno));
++			rsyserr(FERROR, errno, "link \"%s\" -> \"%s\"",
++				full_fname(fname), linkname);
 +		}
 +	}
 +
 +	free(linkname);
 +	free(hashname);
 +	return rc;
 +}
 +
 +#endif
---- Makefile.in	10 Feb 2004 17:06:11 -0000	1.98
-+++ Makefile.in	15 Apr 2004 19:18:59 -0000
-@@ -35,7 +35,7 @@ OBJS1=rsync.o generator.o receiver.o cle
- 	main.o checksum.o match.o syscall.o log.o backup.o
- OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
- 	fileio.o batch.o clientname.o
--OBJS3=progress.o pipe.o
-+OBJS3=progress.o pipe.o hashlink.o
- DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
- popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
- 	popt/popthelp.o popt/poptparse.o
---- options.c	14 Apr 2004 23:33:34 -0000	1.146
-+++ options.c	15 Apr 2004 19:19:00 -0000
-@@ -121,6 +121,7 @@ char *log_format = NULL;
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-08-13 18:13:18
+@@ -126,6 +126,7 @@ char *log_format = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
 +char *link_by_hash_dir = NULL;
  char backup_dir_buf[MAXPATHLEN];
  int rsync_port = RSYNC_PORT;
  int link_dest = 0;
-@@ -266,6 +267,7 @@ void usage(enum logcode F)
-   rprintf(F," -T  --temp-dir=DIR          create temporary files in directory DIR\n");
+@@ -279,6 +280,7 @@ void usage(enum logcode F)
+   rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
    rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
    rprintf(F,"     --link-dest=DIR         create hardlinks to DIR for unchanged files\n");
 +  rprintf(F,"     --link-by-hash=DIR      create hardlinks by hash to DIR for regular files\n");
    rprintf(F," -P                          equivalent to --partial --progress\n");
    rprintf(F," -z, --compress              compress file data\n");
    rprintf(F," -C, --cvs-exclude           auto ignore files in the same way CVS does\n");
-@@ -305,7 +307,7 @@ void usage(enum logcode F)
+@@ -319,7 +321,7 @@ void usage(enum logcode F)
  enum {OPT_VERSION = 1000, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
        OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_LINK_DEST,
        OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
--      OPT_READ_BATCH, OPT_WRITE_BATCH,
-+      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_LINK_BY_HASH,
+-      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT,
++      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT, OPT_LINK_BY_HASH,
        OPT_REFUSED_BASE = 9000};
  
  static struct poptOption long_options[] = {
-@@ -362,6 +364,7 @@ static struct poptOption long_options[] 
+@@ -378,6 +380,7 @@ static struct poptOption long_options[] 
    {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
    {"compare-dest",     0,  POPT_ARG_STRING, &compare_dest, 0, 0, 0 },
    {"link-dest",        0,  POPT_ARG_STRING, &compare_dest,  OPT_LINK_DEST, 0, 0 },
 +  {"link-by-hash",     0,  POPT_ARG_STRING, 0,              OPT_LINK_BY_HASH, 0, 0},
    /* TODO: Should this take an optional int giving the compression level? */
    {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
    {"daemon",           0,  POPT_ARG_NONE,   &daemon_opt, 0, 0, 0 },
-@@ -584,6 +587,19 @@ int parse_arguments(int *argc, const cha
+@@ -616,6 +619,21 @@ int parse_arguments(int *argc, const cha
  			return 0;
  #endif
  
 +                case OPT_LINK_BY_HASH:
 +#if HAVE_LINK
-+			link_by_hash_dir = (char *)poptGetOptArg(pc);
-+			checksum_seed = FIXED_CHECKSUM_SEED;
++			arg = poptGetOptArg(pc);
++			if (sanitize_paths)
++				arg = sanitize_path(NULL, arg, NULL, 0);
++			link_by_hash_dir = (char *)arg;
 +			break;
 +#else
 +			snprintf(err_buf, sizeof err_buf,
 +				 "hard links are not supported on this %s\n",
 +				 am_server ? "server" : "client");
 +			rprintf(FERROR, "ERROR: %s", err_buf);
 +			return 0;
 +#endif
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off (opt-BASE is its index). */
-@@ -951,6 +967,11 @@ void server_options(char **args,int *arg
- 		 */
- 		args[ac++] = link_dest ? "--link-dest" : "--compare-dest";
+@@ -1087,6 +1105,11 @@ void server_options(char **args,int *arg
  		args[ac++] = compare_dest;
-+	}
-+
+ 	}
+ 
 +	if (link_by_hash_dir && am_sender) {
 +		args[ac++] = "--link-by-hash";
 +		args[ac++] = link_by_hash_dir;
- 	}
- 
++	}
++
  	if (files_from && (!am_sender || remote_filesfrom_file)) {
---- proto.h	14 Apr 2004 23:33:30 -0000	1.188
-+++ proto.h	15 Apr 2004 19:19:00 -0000
-@@ -91,6 +91,12 @@ char *f_name(struct file_struct *f);
- void write_sum_head(int f, struct sum_struct *sum);
- void recv_generator(char *fname, struct file_struct *file, int i, int f_out);
- void generate_files(int f, struct file_list *flist, char *local_name);
-+char* make_hash_name(struct file_struct *file);
-+void kill_hashfile(struct hashfile_struct *hashfile);
-+void kill_hashfiles(struct hashfile_struct *hashfiles);
-+struct hashfile_struct *find_hashfiles(char *hashname, int64 size, long *fnbr);
-+struct hashfile_struct *compare_hashfiles(int fd,struct hashfile_struct *files);
-+int link_by_hash(char *fnametmp,char *fname,struct file_struct *file);
- void init_hard_links(struct file_list *flist);
- int hard_link_check(struct file_struct *file, int skip);
- void do_hard_links(void);
---- receiver.c	23 Mar 2004 16:50:40 -0000	1.75
-+++ receiver.c	15 Apr 2004 19:19:00 -0000
-@@ -45,6 +45,7 @@ extern int cleanup_got_literal;
- extern int module_id;
- extern int ignore_errors;
- extern int orig_umask;
+ 		if (remote_filesfrom_file) {
+ 			args[ac++] = "--files-from";
+--- orig/receiver.c	2004-09-21 09:40:27
++++ receiver.c	2004-07-20 21:44:05
+@@ -39,6 +39,7 @@ extern int io_error;
+ extern char *tmpdir;
+ extern char *partial_dir;
+ extern char *compare_dest;
 +extern char *link_by_hash_dir;
- 
- static void delete_one(char *fn, int is_dir)
- {
-@@ -190,10 +191,11 @@ static int get_tmpname(char *fnametmp, c
+ extern int make_backups;
+ extern int do_progress;
+ extern char *backup_dir;
+@@ -202,12 +203,13 @@ static int get_tmpname(char *fnametmp, c
  
  
- static int receive_data(int f_in,struct map_struct *mapbuf,int fd,char *fname,
--			OFF_T total_size)
-+			OFF_T total_size,char *md4)
+ static int receive_data(int f_in, char *fname_r, int fd_r, OFF_T size_r,
+-			char *fname, int fd, OFF_T total_size)
++			char *fname, int fd, OFF_T total_size, char *md4)
  {
- 	int i;
+ 	static char file_sum1[MD4_SUM_LENGTH];
+ 	static char file_sum2[MD4_SUM_LENGTH];
+ 	struct map_struct *mapbuf;
  	struct sum_struct sum;
 +	struct mdfour mdfour_data;
  	unsigned int len;
  	OFF_T offset = 0;
  	OFF_T offset2;
-@@ -203,7 +205,9 @@ static int receive_data(int f_in,struct 
- 	char *map=NULL;
+@@ -227,6 +229,9 @@ static int receive_data(int f_in, char *
+ 	} else
+ 		mapbuf = NULL;
  
- 	read_sum_head(f_in, &sum);
--
 +	if (md4)
 +		mdfour_begin(&mdfour_data);
-+	
- 	sum_init();
++
+ 	sum_init(checksum_seed);
  
  	while ((i = recv_token(f_in, &data)) != 0) {
-@@ -220,6 +224,8 @@ static int receive_data(int f_in,struct 
+@@ -243,6 +248,8 @@ static int receive_data(int f_in, char *
  			cleanup_got_literal = 1;
  
  			sum_update(data,i);
 +			if (md4)
 +				mdfour_update(&mdfour_data,data,i);
  
- 			if (fd != -1 && write_file(fd,data,i) != i) {
- 				rprintf(FERROR, "write failed on %s: %s\n",
-@@ -247,6 +253,8 @@ static int receive_data(int f_in,struct 
+ 			if (fd != -1 && write_file(fd,data,i) != i)
+ 				goto report_write_error;
+@@ -267,6 +274,8 @@ static int receive_data(int f_in, char *
  
  			see_token(map, len);
  			sum_update(map,len);
 +			if (md4)
 +				mdfour_update(&mdfour_data,map,len);
  		}
  
- 		if (fd != -1 && write_file(fd,map,len) != (int) len) {
-@@ -269,6 +277,8 @@ static int receive_data(int f_in,struct 
+ 		if (inplace) {
+@@ -306,6 +315,8 @@ static int receive_data(int f_in, char *
  	}
  
  	sum_end(file_sum1);
 +	if (md4)
 +		mdfour_result(&mdfour_data, (unsigned char*)md4);
  
- 	read_buf(f_in,file_sum2,MD4_SUM_LENGTH);
- 	if (verbose > 2) {
-@@ -372,7 +382,7 @@ int recv_files(int f_in,struct file_list
- 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
- 			rprintf(FERROR, "fstat %s failed: %s\n",
- 				full_fname(fnamecmp), strerror(errno));
--			receive_data(f_in,NULL,-1,NULL,file->length);
-+			receive_data(f_in,NULL,-1,NULL,file->length,NULL);
- 			close(fd1);
- 			continue;
- 		}
-@@ -385,7 +395,7 @@ int recv_files(int f_in,struct file_list
- 			 */
- 			rprintf(FERROR,"recv_files: %s is a directory\n",
- 				full_fname(fnamecmp));
--			receive_data(f_in, NULL, -1, NULL, file->length);
-+			receive_data(f_in,NULL,-1,NULL,file->length,NULL);
- 			close(fd1);
- 			continue;
- 		}
-@@ -437,7 +447,7 @@ int recv_files(int f_in,struct file_list
- 		if (fd2 == -1) {
- 			rprintf(FERROR, "mkstemp %s failed: %s\n",
- 				full_fname(fnametmp), strerror(errno));
--			receive_data(f_in,mapbuf,-1,NULL,file->length);
-+			receive_data(f_in,mapbuf,-1,NULL,file->length,NULL);
- 			if (mapbuf) unmap_file(mapbuf);
- 			if (fd1 != -1) close(fd1);
- 			continue;
-@@ -450,7 +460,12 @@ int recv_files(int f_in,struct file_list
- 		}
+ 	if (mapbuf)
+ 		unmap_file(mapbuf);
+@@ -321,7 +332,7 @@ static int receive_data(int f_in, char *
+ 
+ static void discard_receive_data(int f_in, OFF_T length)
+ {
+-	receive_data(f_in, NULL, -1, 0, NULL, -1, length);
++	receive_data(f_in, NULL, -1, 0, NULL, -1, length, NULL);
+ }
+ 
+ 
+@@ -542,8 +553,12 @@ int recv_files(int f_in, struct file_lis
+ 			rprintf(FINFO, "%s\n", safe_fname(fname));
  
  		/* recv file data */
--		recv_ok = receive_data(f_in,mapbuf,fd2,fname,file->length);
 +#ifdef HAVE_LINK
-+		if (link_by_hash_dir) {
-+			file->u.sum = (char*)malloc (MD4_SUM_LENGTH);
-+		}
++		if (link_by_hash_dir)
++			file->u.sum = (char*)malloc(MD4_SUM_LENGTH);
 +#endif
-+		recv_ok = receive_data(f_in,mapbuf,fd2,fname,file->length,file->u.sum);
+ 		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
+-				       fname, fd2, file->length);
++				       fname, fd2, file->length, file->u.sum);
  
  		log_recv(file, &initial_stats);
  
---- rsync.c	23 Mar 2004 16:16:15 -0000	1.135
-+++ rsync.c	15 Apr 2004 19:19:00 -0000
-@@ -33,6 +33,7 @@ extern int preserve_uid;
- extern int preserve_gid;
- extern int preserve_perms;
+--- orig/rsync.c	2004-09-07 21:45:30
++++ rsync.c	2004-08-13 18:14:34
+@@ -34,6 +34,7 @@ extern int force_delete;
+ extern int recurse;
+ extern int keep_dirlinks;
  extern int make_backups;
 +extern char *link_by_hash_dir;
+ extern char *backup_dir;
+ extern int inplace;
  
- 
- /*
-@@ -235,8 +236,12 @@ void finish_transfer(char *fname, char *
- 	if (make_backups && !make_backup(fname))
- 		return;
- 
--	/* move tmp file over real file */
+@@ -254,7 +255,12 @@ void finish_transfer(char *fname, char *
+ 	/* move tmp file over real file */
+ 	if (verbose > 2)
+ 		rprintf(FINFO, "renaming %s to %s\n", fnametmp, fname);
 -	ret = robust_rename(fnametmp, fname, file->mode & INITACCESSPERMS);
 +#ifdef HAVE_LINK
 +	if (link_by_hash_dir)
-+		ret = link_by_hash(fnametmp,fname,file);
++		ret = link_by_hash(fnametmp, fname, file);
 +	else
 +#endif
 +		ret = robust_rename(fnametmp, fname, file->mode & INITACCESSPERMS);
  	if (ret < 0) {
- 		rprintf(FERROR, "%s %s -> \"%s\": %s\n",
+ 		rsyserr(FERROR, errno, "%s %s -> \"%s\"",
  		    ret == -2 ? "copy" : "rename",
---- rsync.h	14 Apr 2004 23:33:37 -0000	1.196
-+++ rsync.h	15 Apr 2004 19:19:00 -0000
-@@ -518,6 +518,14 @@ struct stats {
+--- orig/rsync.h	2004-09-22 08:47:31
++++ rsync.h	2004-07-03 20:20:15
+@@ -526,6 +526,14 @@ struct stats {
  	int current_file_index;
  };
  
 +struct hashfile_struct {
 +	struct hashfile_struct *next;
 +	struct hashfile_struct *prev;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: links-depth.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: max-size.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/merge-exclude-file.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/merge-exclude-file.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/merge-exclude-file.diff	2004-04-27 11:05:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/merge-exclude-file.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,522 +1,815 @@
+After applying this patch and running configure, you MUST run this
+command before "make":
+
+    make proto
+
 This patch adds the ability to merge rules into your excludes/includes
-using a ". FILE" idiom.  If you specify a name without slashes, that
-filename will be looked for in every subdirectory that rsync visits,
-and its rules will affect the current directory and its subdirectories.
+using a ". FILE" idiom.  If you specify a name with a preceding -p
+option, that filename will be looked for in every subdirectory that
+rsync visits, and the rules found in that subdirectory's file will
+affect that dir and its subdirs.
 
 For example:
 
-  rsync -av --exclude='. .excl' from/ to
+  rsync -av --exclude='. -p .excl' from/ to
 
 The above will look for a file named ".excl" in every directory of the
 hierarchy that rsync visits, and it will exclude (by default) names
 based on the rules found therein.  If one of the .excl files contains
 this:
 
   + *.c
-  . .excl2
-  . ./.excl3
+  . -p .excl2
+  . .excl3
   *.o
+  /foobar
 
-Then the file ".excl2" will also be read in the current dir, and all
-subdirs of the current dir.  The file ".excl3" would just be read in
-for the current dir because its name contained a slash.
+Then the file ".excl2" will also be read in from the current dir and all
+its subdirs (due to the -p option).  The file ".excl3" would just be
+read in from the current dir.   The exclusion of "foobar" will only
+happen in that .excl file's directory because the rule is anchored (so
+that's how you can make rules local instead of inherited).
 
 ..wayne..
 
---- exclude.c	27 Apr 2004 01:36:06 -0000	1.75
-+++ exclude.c	27 Apr 2004 01:44:51 -0000
-@@ -30,32 +30,65 @@ extern int verbose;
+--- orig/clientserver.c	2004-08-02 02:29:16
++++ clientserver.c	2004-08-10 15:44:15
+@@ -48,12 +48,14 @@ extern int no_detach;
+ extern int default_af_hint;
+ extern char *bind_address;
+ extern struct exclude_list_struct server_exclude_list;
+-extern char *exclude_path_prefix;
+ extern char *config_file;
+ extern char *files_from;
+ 
+ char *auth_user;
+ 
++/* Length of lp_path() string when in daemon mode & not chrooted, else 0. */
++unsigned int module_dirlen = 0;
++
+ /**
+  * Run a client connected to an rsyncd.  The alternative to this
+  * function for remote-shell connections is do_cmd().
+@@ -300,26 +302,28 @@ static int rsync_module(int f_in, int f_
+ 	/* TODO: Perhaps take a list of gids, and make them into the
+ 	 * supplementary groups. */
+ 
+-	exclude_path_prefix = use_chroot? "" : lp_path(i);
+-	if (*exclude_path_prefix == '/' && !exclude_path_prefix[1])
+-		exclude_path_prefix = "";
++	if (use_chroot) {
++		module_dirlen = 0;
++		set_excludes_dir("/", 1);
++	} else {
++		module_dirlen = strlen(lp_path(i));
++		set_excludes_dir(lp_path(i), module_dirlen);
++	}
+ 
+ 	p = lp_include_from(i);
+ 	add_exclude_file(&server_exclude_list, p,
+-			 XFLG_FATAL_ERRORS | XFLG_DEF_INCLUDE);
++			 XFLG_FATAL_ERRORS | XFLG_DEF_INCLUDE | XFLG_ABS_PATH);
+ 
+ 	p = lp_include(i);
+ 	add_exclude(&server_exclude_list, p,
+-		    XFLG_WORD_SPLIT | XFLG_DEF_INCLUDE);
++		    XFLG_WORD_SPLIT | XFLG_DEF_INCLUDE | XFLG_ABS_PATH);
+ 
+ 	p = lp_exclude_from(i);
+ 	add_exclude_file(&server_exclude_list, p,
+-			 XFLG_FATAL_ERRORS);
++			 XFLG_FATAL_ERRORS | XFLG_ABS_PATH);
+ 
+ 	p = lp_exclude(i);
+-	add_exclude(&server_exclude_list, p, XFLG_WORD_SPLIT);
+-
+-	exclude_path_prefix = NULL;
++	add_exclude(&server_exclude_list, p, XFLG_WORD_SPLIT | XFLG_ABS_PATH);
+ 
+ 	log_init();
+ 
+--- orig/exclude.c	2004-09-22 08:47:31
++++ exclude.c	2004-08-13 07:40:08
+@@ -30,13 +30,69 @@ extern int verbose;
  extern int eol_nulls;
  extern int list_only;
  extern int recurse;
 +extern int io_error;
 +extern int sanitize_paths;
  
  extern char curr_dir[];
++extern unsigned int curr_dir_len;
++extern unsigned int module_dirlen;
  
--struct exclude_list_struct exclude_list = { 0, 0, "" };
+ struct exclude_list_struct exclude_list = { 0, 0, "" };
 -struct exclude_list_struct local_exclude_list = { 0, 0, "per-dir .cvsignore " };
--struct exclude_list_struct server_exclude_list = { 0, 0, "server " };
-+struct exclude_list_struct exclude_list = { 0, 0, 0, 0, "" };
-+struct exclude_list_struct server_exclude_list = { 0, 0, 0, 0, "server " };
- char *exclude_path_prefix = NULL;
- 
-+struct exclude_list_root {
-+    struct exclude_list_struct *head;
-+    int cnt;
-+} local_lists;
-+
-+static char dirbuf[MAXPATHLEN];
-+static unsigned int dirbuf_offset = 0;
-+
-+static void clear_exclude_list(struct exclude_list_struct *listp,
-+			struct exclude_struct *extra)
-+{
-+	listp->head = listp->extra = extra;
-+	listp->tail = NULL;
-+}
+ struct exclude_list_struct server_exclude_list = { 0, 0, "server " };
+-char *exclude_path_prefix = NULL;
 +
- /** Build an exclude structure given a exclude pattern */
--static void make_exclude(struct exclude_list_struct *listp, const char *pattern,
--			 int pat_len, int include)
-+static void make_exclude(struct exclude_list_struct *listp, const char *pat,
-+			 unsigned int pat_len, int mflags)
- {
- 	struct exclude_struct *ret;
++struct mergelist_save_struct {
++    struct exclude_list_struct *array;
++    int count;
++};
++
++/* The dirbuf is set by push_local_excludes() to the current subdirectory
++ * relative to curr_dir that is being processed.  The path always has a
++ * trailing slash appended, and the variable dirbuf_len contains the length
++ * of this path prefix.  The path is always absolute. */
++static char dirbuf[MAXPATHLEN+1];
++static unsigned int dirbuf_len = 0;
++static int dirbuf_depth;
++
++/* This is True when we're scanning parent dirs for per-dir merge-files. */
++static BOOL parent_dirscan = False;
++
++/* This array contains a list of all the currently active per-dir merge
++ * files.  This makes it easier to save the appropriate values when we
++ * "push" down into each subdirectory. */
++static struct exclude_struct **mergelist_parents;
++static int mergelist_cnt = 0;
++static int mergelist_size = 0;
++
++/* Each exclude_list_struct describes a singly-linked list by keeping track
++ * of both the head and tail pointers.  The list is slightly unusual in that
++ * a parent-dir's content can be appended to the end of the local list in a
++ * special way:  the last item in the local list has its "next" pointer set
++ * to point to the inherited list, but the local list's tail pointer points
++ * at the end of the local list.  Thus, if the local list is empty, the head
++ * will be pointing at the inherited content but the tail will be NULL.  To
++ * help you visualize this, here are the possible list arrangements:
++ *
++ * Completely Empty                     Local Content Only
++ * ==================================   ====================================
++ * head -> NULL                         head -> Local1 -> Local2 -> NULL
++ * tail -> NULL                         tail -------------^
++ *
++ * Inherited Content Only               Both Local and Inherited Content
++ * ==================================   ====================================
++ * head -> Parent1 -> Parent2 -> NULL   head -> L1 -> L2 -> P1 -> P2 -> NULL
++ * tail -> NULL                         tail ---------^
++ *
++ * This means that anyone wanting to traverse the whole list to USE it just
++ * needs to start at the head and use the "next" pointers until it goes
++ * NULL.  To add new local content, we insert the item after the tail item
++ * and update the tail (obviously, if "tail" was NULL, we insert it at the
++ * head).  To clear the local list, WE MUST NOT FREE THE INHERITED CONTENT
++ * because it is shared between the current list and our parent list(s).
++ * The easiest way to handle this is to simply truncate the list after the
++ * tail item and then free the local list from the head.  When inheriting
++ * the list for a new local dir, we just save off the exclude_list_struct
++ * values (so we can pop back to them later) and set the tail to NULL.
++ */
+ 
+ /** Build an exclude structure given an exclude pattern. */
+ static void make_exclude(struct exclude_list_struct *listp, const char *pat,
+@@ -46,23 +102,50 @@ static void make_exclude(struct exclude_
  	const char *cp;
--	int ex_len;
-+	unsigned int ex_len;
+ 	unsigned int ex_len;
+ 
++	if (verbose > 2) {
++		rprintf(FINFO, "[%s] add_exclude(%.*s, %s%s%sclude)\n",
++			who_am_i(), (int)pat_len, pat, listp->debug_type,
++			mflags & MATCHFLG_MERGE_FILE ? "FILE " : "",
++			mflags & MATCHFLG_INCLUDE ? "in" : "ex");
++	}
 +
 +	if (mflags & MATCHFLG_MERGE_FILE) {
-+		struct exclude_struct *ex;
++		int i;
 +		/* If the local include file was already mentioned, don't
 +		 * add it again. */
-+		for (ex = listp->head; ex; ex = ex->next) {
-+			if ((ex->match_flags & MATCHFLG_MERGE_FILE)
-+			    && strlen(ex->pattern) == pat_len
-+			    && strncmp(ex->pattern, pat, pat_len) == 0)
++		for (i = 0; i < mergelist_cnt; i++) {
++			struct exclude_struct *ex = mergelist_parents[i];
++			if (strlen(ex->pattern) == pat_len
++			    && memcmp(ex->pattern, pat, pat_len) == 0)
 +				return;
 +		}
 +		if ((pat_len == 10 || (pat_len > 10 && pat[pat_len-11] == '/'))
 +		    && strncmp(pat+pat_len-10, ".cvsignore", 10) == 0) {
 +			mflags |= MATCHFLG_CVSIGNORE;
 +			mflags &= ~MATCHFLG_INCLUDE;
 +		} else
 +			mflags &= ~MATCHFLG_CVSIGNORE;
 +	}
- 
++
  	ret = new(struct exclude_struct);
  	if (!ret)
  		out_of_memory("make_exclude");
  
  	memset(ret, 0, sizeof ret[0]);
--	ret->include = include;
  
- 	if (exclude_path_prefix)
--		ret->match_flags |= MATCHFLG_ABS_PATH;
--	if (exclude_path_prefix && *pattern == '/')
-+		mflags |= MATCHFLG_ABS_PATH;
-+	if (exclude_path_prefix && *pat == '/')
- 		ex_len = strlen(exclude_path_prefix);
- 	else
+-	if (exclude_path_prefix)
+-		mflags |= MATCHFLG_ABS_PATH;
+-	if (exclude_path_prefix && *pat == '/')
+-		ex_len = strlen(exclude_path_prefix);
+-	else
++	if (mflags & MATCHFLG_ABS_PATH) {
++		if (*pat != '/') {
++			mflags &= ~MATCHFLG_ABS_PATH;
++			ex_len = 0;
++		} else
++			ex_len = dirbuf_len - module_dirlen - 1;
++	} else
  		ex_len = 0;
-@@ -64,33 +97,52 @@ static void make_exclude(struct exclude_
+ 	ret->pattern = new_array(char, ex_len + pat_len + 1);
+ 	if (!ret->pattern)
  		out_of_memory("make_exclude");
  	if (ex_len)
- 		memcpy(ret->pattern, exclude_path_prefix, ex_len);
--	strlcpy(ret->pattern + ex_len, pattern, pat_len + 1);
-+	strlcpy(ret->pattern + ex_len, pat, pat_len + 1);
+-		memcpy(ret->pattern, exclude_path_prefix, ex_len);
++		memcpy(ret->pattern, dirbuf + module_dirlen, ex_len);
+ 	strlcpy(ret->pattern + ex_len, pat, pat_len + 1);
  	pat_len += ex_len;
  
- 	if (strpbrk(ret->pattern, "*[?")) {
--		ret->match_flags |= MATCHFLG_WILD;
-+		mflags |= MATCHFLG_WILD;
- 		if ((cp = strstr(ret->pattern, "**")) != NULL) {
--			ret->match_flags |= MATCHFLG_WILD2;
-+			mflags |= MATCHFLG_WILD2;
- 			/* If the pattern starts with **, note that. */
- 			if (cp == ret->pattern)
--				ret->match_flags |= MATCHFLG_WILD2_PREFIX;
-+				mflags |= MATCHFLG_WILD2_PREFIX;
- 		}
+@@ -81,14 +164,40 @@ static void make_exclude(struct exclude_
+ 		mflags |= MATCHFLG_DIRECTORY;
  	}
  
- 	if (pat_len > 1 && ret->pattern[pat_len-1] == '/') {
- 		ret->pattern[pat_len-1] = 0;
--		ret->directory = 1;
-+		mflags |= MATCHFLG_DIRECTORY;
- 	}
+-	for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
+-		ret->slash_cnt++;
++	if (mflags & MATCHFLG_MERGE_FILE) {
++		struct exclude_list_struct *lp
++		    = new_array(struct exclude_list_struct, 1);
++		if (!lp)
++			out_of_memory("make_exclude");
++		lp->head = lp->tail = NULL;
++		if ((cp = strrchr(ret->pattern, '/')) != NULL)
++			cp++;
++		else
++			cp = ret->pattern;
++		if (asprintf(&lp->debug_type, "per-dir %s ", cp) < 0)
++			out_of_memory("make_exclude");
++		ret->u.mergelist = lp;
++		if (mergelist_cnt == mergelist_size) {
++			mergelist_size += 5;
++			mergelist_parents = realloc_array(mergelist_parents,
++						struct exclude_struct *,
++						mergelist_size);
++			if (!mergelist_parents)
++				out_of_memory("make_exclude");
++		}
++		mergelist_parents[mergelist_cnt++] = ret;
++	} else {
++		for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
++			ret->u.slash_cnt++;
++	}
  
- 	for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
- 		ret->slash_cnt++;
+ 	ret->match_flags = mflags;
  
-+	ret->next = listp->extra;
-+
- 	if (!listp->tail)
+-	if (!listp->tail)
++	if (!listp->tail) {
++		ret->next = listp->head;
  		listp->head = listp->tail = ret;
- 	else {
+-	else {
++	} else {
++		ret->next = listp->tail->next;
  		listp->tail->next = ret;
  		listp->tail = ret;
  	}
-+
-+	if (mflags & MATCHFLG_MERGE_FILE) {
-+		struct exclude_list_struct *lp;
-+		int ndx = local_lists.cnt++;
-+		local_lists.head = realloc_array(local_lists.head,
-+		    struct exclude_list_struct, local_lists.cnt);
-+		if (!local_lists.head)
-+			out_of_memory("make_exclude");
-+		lp = &local_lists.head[ndx];
-+		clear_exclude_list(lp, NULL);
-+		if (asprintf(&lp->debug_type, "per-dir %s ", ret->pattern) < 0)
-+			out_of_memory("make_exclude");
-+		lp->parent = ret;
-+		ret->slash_cnt = ndx;
-+	}
-+
-+	ret->match_flags = mflags;
- }
+@@ -96,22 +205,267 @@ static void make_exclude(struct exclude_
  
  static void free_exclude(struct exclude_struct *ex)
-@@ -99,13 +151,15 @@ static void free_exclude(struct exclude_
+ {
++	if (ex->match_flags & MATCHFLG_MERGE_FILE) {
++		free(ex->u.mergelist->debug_type);
++		free(ex->u.mergelist);
++	}
+ 	free(ex->pattern);
  	free(ex);
  }
  
--void free_exclude_list(struct exclude_list_struct *listp)
-+static void free_exclude_list(struct exclude_list_struct *listp)
+-void clear_exclude_list(struct exclude_list_struct *listp)
++static void clear_exclude_list(struct exclude_list_struct *listp)
  {
- 	struct exclude_struct *ent, *next;
- 
--	if (verbose > 2) {
--		rprintf(FINFO, "[%s] clearing %sexclude list\n",
--			who_am_i(), listp->debug_type);
-+	if (listp->extra) {
-+		if (listp->tail)
-+			listp->tail->next = NULL;
-+		else
-+			listp->head = NULL;
+-	struct exclude_struct *ent, *next;
+-
+-	for (ent = listp->head; ent; ent = next) {
+-		next = ent->next;
+-		free_exclude(ent);
++	if (listp->tail) {
++		struct exclude_struct *ent, *next;
++		/* Truncate any inherited items from the local list. */
++		listp->tail->next = NULL;
++		/* Now free everything that is left. */
++		for (ent = listp->head; ent; ent = next) {
++			next = ent->next;
++			free_exclude(ent);
++		}
  	}
  
- 	for (ent = listp->head; ent; ent = next) {
-@@ -113,7 +167,78 @@ void free_exclude_list(struct exclude_li
- 		free_exclude(ent);
- 	}
+ 	listp->head = listp->tail = NULL;
+ }
  
--	listp->head = listp->tail = NULL;
-+	clear_exclude_list(listp, NULL);
++/* This returns an expanded (absolute) filename for the merge-file name if
++ * the name has any slashes in it OR if the parent_dirscan var is True;
++ * otherwise it returns the original merge_file name.  If the len_ptr value
++ * is non-NULL the merge_file name is limited by the referenced length
++ * value and will be updated with the length of the resulting name.  We
++ * always return a name that is null terminated, even if the merge_file
++ * name was not. */
++static char *parse_merge_name(const char *merge_file, unsigned int *len_ptr,
++			      unsigned int prefix_skip)
++{
++	static char buf[MAXPATHLEN];
++	char *fn, tmpbuf[MAXPATHLEN];
++	unsigned int fn_len;
++
++	if (!parent_dirscan && *merge_file != '/') {
++		/* Return the name unchanged it doesn't have any slashes. */
++		if (len_ptr) {
++			const char *p = merge_file + *len_ptr;
++			while (--p > merge_file && *p != '/') {}
++			if (p == merge_file) {
++				strlcpy(buf, merge_file, *len_ptr + 1);
++				return buf;
++			}
++		} else if (strchr(merge_file, '/') == NULL)
++			return (char *)merge_file;
++	}
++
++	fn = *merge_file == '/' ? buf : tmpbuf;
++	if (sanitize_paths) {
++		const char *r = prefix_skip ? "/" : NULL;
++		/* null-terminate the name if it isn't already */
++		if (len_ptr && merge_file[*len_ptr]) {
++			char *to = fn == buf ? tmpbuf : buf;
++			strlcpy(to, merge_file, *len_ptr + 1);
++			merge_file = to;
++		}
++		if (!sanitize_path(fn, merge_file, r, dirbuf_depth)) {
++			rprintf(FERROR, "merge-file name overflows: %s\n",
++				merge_file);
++			return NULL;
++		}
++	} else {
++		strlcpy(fn, merge_file, len_ptr ? *len_ptr + 1 : MAXPATHLEN);
++		clean_fname(fn, 1);
++	}
++	
++	fn_len = strlen(fn);
++	if (fn == buf)
++		goto done;
++
++	if (dirbuf_len + fn_len >= MAXPATHLEN) {
++		rprintf(FERROR, "merge-file name overflows: %s\n", fn);
++		return NULL;
++	}
++	memcpy(buf, dirbuf + prefix_skip, dirbuf_len - prefix_skip);
++	memcpy(buf + dirbuf_len - prefix_skip, fn, fn_len + 1);
++	fn_len = clean_fname(buf, 1);
++
++    done:
++	if (len_ptr)
++		*len_ptr = fn_len;
++	return buf;
++}
++
++/* Sets the dirbuf and dirbuf_len values. */
++void set_excludes_dir(const char *dir, unsigned int dirlen)
++{
++	unsigned int len;
++	if (*dir != '/') {
++		memcpy(dirbuf, curr_dir, curr_dir_len);
++		dirbuf[curr_dir_len] = '/';
++		len = curr_dir_len + 1;
++		if (len + dirlen >= MAXPATHLEN)
++			dirlen = 0;
++	} else
++		len = 0;
++	memcpy(dirbuf + len, dir, dirlen);
++	dirbuf[dirlen + len] = '\0';
++	dirbuf_len = clean_fname(dirbuf, 1);
++	if (dirbuf_len > 1 && dirbuf[dirbuf_len-1] == '.'
++	    && dirbuf[dirbuf_len-2] == '/')
++		dirbuf_len -= 2;
++	dirbuf[dirbuf_len++] = '/';
++	dirbuf[dirbuf_len] = '\0';
++	if (sanitize_paths)
++		dirbuf_depth = count_dir_elements(dirbuf + module_dirlen);
 +}
 +
-+void *push_local_excludes(char *fname, unsigned int offset)
++/* This routine takes a per-dir merge-file entry and finishes its setup.
++ * If the name has a path portion then we check to see if it refers to a
++ * parent directory of the first transfer dir.  If it does, we scan all the
++ * dirs from that point through the parent dir of the transfer dir looking
++ * for the per-dir merge-file in each one. */
++static BOOL setup_merge_file(struct exclude_struct *ex,
++			     struct exclude_list_struct *lp, int flags)
 +{
++	char buf[MAXPATHLEN];
++	char *x, *y, *pat = ex->pattern;
++	unsigned int len;
++
++	if (!(x = parse_merge_name(pat, NULL, 0)) || *x != '/')
++		return 0;
++
++	y = strrchr(x, '/');
++	*y = '\0';
++	ex->pattern = strdup(y+1);
++	if (!*x)
++		x = "/";
++	if (*x == '/')
++		strlcpy(buf, x, MAXPATHLEN);
++	else
++		pathjoin(buf, MAXPATHLEN, dirbuf, x);
++
++	len = clean_fname(buf, 1);
++	if (len != 1 && len < MAXPATHLEN-1) {
++		buf[len++] = '/';
++		buf[len] = '\0';
++	}
++	/* This ensures that the specified dir is a parent of the transfer. */
++	for (x = buf, y = dirbuf; *x && *x == *y; x++, y++) {}
++	if (*x)
++		y += strlen(y); /* nope -- skip the scan */
++
++	parent_dirscan = True;
++	while (*y) {
++		char save[MAXPATHLEN];
++		strlcpy(save, y, MAXPATHLEN);
++		*y = '\0';
++		dirbuf_len = y - dirbuf;
++		strlcpy(x, ex->pattern, MAXPATHLEN - (x - buf));
++		add_exclude_file(lp, buf, flags | XFLG_ABS_PATH);
++		if (ex->match_flags & MATCHFLG_CVSIGNORE)
++			lp->head = NULL; /* CVS doesn't inherit rules. */
++		lp->tail = NULL;
++		strlcpy(y, save, MAXPATHLEN);
++		while ((*x++ = *y++) != '/') {}
++	}
++	parent_dirscan = False;
++	free(pat);
++	return 1;
++}
++
++/* Each time rsync changes to a new directory it call this function to
++ * handle all the per-dir merge-files.  The "dir" value is the current path
++ * relative to curr_dir (which might not be null-terminated).  We copy it
++ * into dirbuf so that we can easily append a file name on the end. */
++void *push_local_excludes(const char *dir, unsigned int dirlen)
++{
++	struct mergelist_save_struct *push;
++	struct exclude_list_struct *ap;
 +	int i;
-+	struct exclude_list_root *push = new_array(struct exclude_list_root, 1);
 +
-+	if (!push)
++	set_excludes_dir(dir, dirlen);
++
++	if (!(push = new_array(struct mergelist_save_struct, 1)))
 +		out_of_memory("push_local_excludes");
 +
-+	push->cnt = local_lists.cnt;
-+	push->head = new_array(struct exclude_list_struct, local_lists.cnt);
-+	if (!push->head)
++	push->count = mergelist_cnt;
++	push->array = new_array(struct exclude_list_struct, mergelist_cnt);
++	if (!push->array)
 +		out_of_memory("push_local_excludes");
 +
-+	memcpy(push->head, local_lists.head,
-+	    sizeof (struct exclude_list_struct) * local_lists.cnt);
++	for (i = 0, ap = push->array; i < mergelist_cnt; i++) {
++		memcpy(ap++, mergelist_parents[i]->u.mergelist,
++		       sizeof (struct exclude_list_struct));
++	}
 +
-+	/* Make it easy to construct the full path for a merge that has
-+	 * a relative path by saving it off. */
-+	memcpy(dirbuf, fname, offset);
-+	dirbuf_offset = offset;
-+
-+	for (i = 0; i < local_lists.cnt; i++) {
-+		struct exclude_list_struct *listp = &local_lists.head[i];
-+		struct exclude_struct *extra;
-+		char *file = listp->parent->pattern;
++	/* Note: add_exclude_file() might increase mergelist_cnt, so keep
++	 * this loop separate from the above loop. */
++	for (i = 0; i < mergelist_cnt; i++) {
++		struct exclude_struct *ex = mergelist_parents[i];
++		struct exclude_list_struct *lp = ex->u.mergelist;
 +		int flags;
 +
 +		if (verbose > 2) {
 +			rprintf(FINFO, "[%s] pushing %sexclude list\n",
-+				who_am_i(), listp->debug_type);
++				who_am_i(), lp->debug_type);
 +		}
-+		if (listp->parent->match_flags & MATCHFLG_CVSIGNORE) {
++
++		if (ex->match_flags & MATCHFLG_CVSIGNORE) {
++			lp->head = NULL; /* CVS doesn't inherit rules. */
 +			flags = XFLG_WORD_SPLIT | XFLG_WORDS_ONLY;
-+			extra = NULL;
 +		} else {
-+			flags = listp->parent->match_flags & MATCHFLG_INCLUDE
++			flags = ex->match_flags & MATCHFLG_INCLUDE
 +			    ? XFLG_DEF_INCLUDE : 0;
-+			extra = listp->head; /* Subdirs inherit our rules. */
 +		}
-+		clear_exclude_list(listp, extra);
-+		if (strlcpy(fname +  offset, file, MAXPATHLEN - offset)
-+		    < MAXPATHLEN - offset)
-+			add_exclude_file(listp, fname, flags);
++		lp->tail = NULL; /* Switch any local rules to inherited. */
++
++		if (ex->match_flags & MATCHFLG_FINISH_SETUP) {
++			ex->match_flags &= ~MATCHFLG_FINISH_SETUP;
++			if (setup_merge_file(ex, lp, flags))
++				set_excludes_dir(dir, dirlen);
++		}
++
++		if (strlcpy(dirbuf + dirbuf_len, ex->pattern,
++		    MAXPATHLEN - dirbuf_len) < MAXPATHLEN - dirbuf_len)
++			add_exclude_file(lp, dirbuf, flags | XFLG_ABS_PATH);
 +		else {
 +			io_error |= IOERR_GENERAL;
 +			rprintf(FINFO,
 +			    "cannot add local excludes in long-named directory %s\n",
-+			    full_fname(fname));
++			    full_fname(dirbuf));
 +		}
++		dirbuf[dirbuf_len] = '\0';
 +	}
 +
 +	return (void*)push;
 +}
 +
 +void pop_local_excludes(void *mem)
 +{
++	struct mergelist_save_struct *pop = (struct mergelist_save_struct*)mem;
++	struct exclude_list_struct *ap;
 +	int i;
 +
-+	for (i = 0; i < local_lists.cnt; i++) {
-+		struct exclude_list_struct *listp = &local_lists.head[i];
++	for (i = mergelist_cnt; i-- > 0; ) {
++		struct exclude_struct *ex = mergelist_parents[i];
++		struct exclude_list_struct *lp = ex->u.mergelist;
++
 +		if (verbose > 2) {
 +			rprintf(FINFO, "[%s] popping %sexclude list\n",
-+				who_am_i(), listp->debug_type);
++				who_am_i(), lp->debug_type);
 +		}
-+		free_exclude_list(listp);
++
++		clear_exclude_list(lp);
 +	}
-+	free(local_lists.head);
-+	local_lists = *(struct exclude_list_root*)mem;
-+	free(mem);
- }
- 
++
++	mergelist_cnt = pop->count;
++	for (i = 0, ap = pop->array; i < mergelist_cnt; i++) {
++		memcpy(mergelist_parents[i]->u.mergelist, ap++,
++		       sizeof (struct exclude_list_struct));
++	}
++
++	free(pop->array);
++	free(pop);
++}
++
  static int check_one_exclude(char *name, struct exclude_struct *ex,
-@@ -139,7 +264,8 @@ static int check_one_exclude(char *name,
- 
- 	if (!name[0]) return 0;
- 
--	if (ex->directory && !name_is_dir) return 0;
-+	if ((ex->match_flags & MATCHFLG_DIRECTORY) && !name_is_dir)
-+		return 0;
- 
- 	if (*pattern == '/') {
- 		match_start = 1;
-@@ -206,9 +332,11 @@ static void report_exclude_result(char c
- 
- 	if (verbose >= 2) {
- 		rprintf(FINFO, "[%s] %scluding %s %s because of %spattern %s%s\n",
--			who_am_i(), ent->include ? "in" : "ex",
-+			who_am_i(),
-+			ent->match_flags & MATCHFLG_INCLUDE ? "in" : "ex",
- 			name_is_dir ? "directory" : "file", name, type,
--			ent->pattern, ent->directory ? "/" : "");
-+			ent->pattern,
-+			ent->match_flags & MATCHFLG_DIRECTORY ? "/" : "");
+                              int name_is_dir)
+ {
+@@ -125,13 +479,14 @@ static int check_one_exclude(char *name,
+ 	/* If the pattern does not have any slashes AND it does not have
+ 	 * a "**" (which could match a slash), then we just match the
+ 	 * name portion of the path. */
+-	if (!ex->slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
++	if (!ex->u.slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
+ 		if ((p = strrchr(name,'/')) != NULL)
+ 			name = p+1;
+ 	}
+ 	else if (ex->match_flags & MATCHFLG_ABS_PATH && *name != '/'
+-	    && curr_dir[1]) {
+-		pathjoin(full_name, sizeof full_name, curr_dir + 1, name);
++	    && curr_dir_len > module_dirlen + 1) {
++		pathjoin(full_name, sizeof full_name,
++			 curr_dir + module_dirlen + 1, name);
+ 		name = full_name;
  	}
- }
  
-@@ -222,10 +350,18 @@ int check_exclude(struct exclude_list_st
+@@ -148,9 +503,9 @@ static int check_one_exclude(char *name,
+ 	if (ex->match_flags & MATCHFLG_WILD) {
+ 		/* A non-anchored match with an infix slash and no "**"
+ 		 * needs to match the last slash_cnt+1 name elements. */
+-		if (!match_start && ex->slash_cnt
++		if (!match_start && ex->u.slash_cnt
+ 		    && !(ex->match_flags & MATCHFLG_WILD2)) {
+-			int cnt = ex->slash_cnt + 1;
++			int cnt = ex->u.slash_cnt + 1;
+ 			for (p = name + strlen(name) - 1; p >= name; p--) {
+ 				if (*p == '/' && !--cnt)
+ 					break;
+@@ -221,6 +576,13 @@ int check_exclude(struct exclude_list_st
  	struct exclude_struct *ent;
  
  	for (ent = listp->head; ent; ent = ent->next) {
 +		if (ent->match_flags & MATCHFLG_MERGE_FILE) {
-+			struct exclude_list_struct *lp
-+			    = &local_lists.head[ent->slash_cnt];
-+			int rc = check_exclude(lp, name, name_is_dir);
++			int rc = check_exclude(ent->u.mergelist, name,
++					       name_is_dir);
 +			if (rc)
 +				return rc;
 +			continue;
 +		}
  		if (check_one_exclude(name, ent, name_is_dir)) {
  			report_exclude_result(name, ent, name_is_dir,
  					      listp->debug_type);
--			return ent->include ? 1 : -1;
-+			return (ent->match_flags & MATCHFLG_INCLUDE) ? 1 : -1;
- 		}
- 	}
- 
-@@ -241,11 +377,11 @@ int check_exclude(struct exclude_list_st
-  * *incl_ptr value will be 1 for an include, 0 for an exclude, and -1 for
-  * the list-clearing "!" token.
-  */
--static const char *get_exclude_tok(const char *p, int *len_ptr, int *incl_ptr,
-+static const char *get_exclude_tok(const char *p, int *len_ptr, int *flag_ptr,
- 				   int xflags)
- {
- 	const unsigned char *s = (const unsigned char *)p;
--	int len;
-+	int len, mflags = 0;
- 
- 	if (xflags & XFLG_WORD_SPLIT) {
- 		/* Skip over any initial whitespace. */
-@@ -255,13 +391,19 @@ static const char *get_exclude_tok(const
+@@ -253,11 +615,36 @@ static const char *get_exclude_tok(const
  		p = (const char *)s;
  	}
  
 -	/* Is this a '+' or '-' followed by a space (not whitespace)? */
-+	/* Is this a +/-/. followed by a space (not whitespace)? */
++	/* Check for a +/-/. followed by a space (not whitespace). */
  	if (!(xflags & XFLG_WORDS_ONLY)
 -	    && (*s == '-' || *s == '+') && s[1] == ' ') {
--		*incl_ptr = *s == '+';
 +	    && (*s == '-' || *s == '+' || *s == '.') && s[1] == ' ') {
-+		if (*s == '+')
-+			mflags |= MATCHFLG_INCLUDE;
+ 		if (*s == '+')
+ 			mflags |= MATCHFLG_INCLUDE;
 +		else if (*s == '.') {
 +			mflags |= MATCHFLG_MERGE_FILE;
 +			if (xflags & XFLG_DEF_INCLUDE)
 +				mflags |= MATCHFLG_INCLUDE;
++			while (s[2] == '-') {
++				s += 2;
++				do {
++					switch (*++s) {
++					case 'p':
++						mflags |= MATCHFLG_PERDIR_MERGE
++							| MATCHFLG_FINISH_SETUP;
++						break;
++					case '-':
++						if (s[1] == ' ')
++							goto done;
++					default:
++						rprintf(FERROR,
++						    "invalid merge options: %s\n",
++						    p);
++						exit_cleanup(RERR_SYNTAX);
++					}
++				} while (s[1] != ' ');
++			}
 +		}
++	    done:
  		s += 2;
--	} else
--		*incl_ptr = xflags & XFLG_DEF_INCLUDE;
-+	} else if (xflags & XFLG_DEF_INCLUDE)
-+		mflags |= MATCHFLG_INCLUDE;
- 
- 	if (xflags & XFLG_WORD_SPLIT) {
- 		const unsigned char *cp = s;
-@@ -273,9 +415,10 @@ static const char *get_exclude_tok(const
- 		len = strlen(s);
+ 	} else if (xflags & XFLG_DEF_INCLUDE)
+ 		mflags |= MATCHFLG_INCLUDE;
+@@ -275,6 +662,8 @@ static const char *get_exclude_tok(const
  
  	if (*p == '!' && len == 1 && !(xflags & XFLG_WORDS_ONLY))
--		*incl_ptr = -1;
-+		mflags |= MATCHFLG_CLEAR_LIST;
+ 		mflags |= MATCHFLG_CLEAR_LIST;
++	if (xflags & XFLG_ABS_PATH)
++		mflags |= MATCHFLG_ABS_PATH;
  
  	*len_ptr = len;
-+	*flag_ptr = mflags;
- 	return (const char *)s;
- }
- 
-@@ -283,7 +426,7 @@ static const char *get_exclude_tok(const
- void add_exclude(struct exclude_list_struct *listp, const char *pattern,
+ 	*flag_ptr = mflags;
+@@ -286,7 +675,7 @@ void add_exclude(struct exclude_list_str
  		 int xflags)
  {
--	int pat_len, incl;
-+	int pat_len, mflags;
- 	const char *cp;
+ 	unsigned int pat_len, mflags;
+-	const char *cp;
++	const char *cp, *p;
  
  	if (!pattern)
-@@ -292,22 +435,48 @@ void add_exclude(struct exclude_list_str
+ 		return;
+@@ -294,9 +683,15 @@ void add_exclude(struct exclude_list_str
  	cp = pattern;
  	pat_len = 0;
  	while (1) {
--		cp = get_exclude_tok(cp + pat_len, &pat_len, &incl, xflags);
-+		cp = get_exclude_tok(cp + pat_len, &pat_len, &mflags, xflags);
++		/* Remember that the returned string is NOT '\0' terminated! */
+ 		cp = get_exclude_tok(cp + pat_len, &pat_len, &mflags, xflags);
  		if (!pat_len)
  			break;
--		/* If we got the special "!" token, clear the list. */
--		if (incl < 0)
--			free_exclude_list(listp);
--		else {
--			make_exclude(listp, cp, pat_len, incl);
--
-+		if (mflags & MATCHFLG_CLEAR_LIST) {
- 			if (verbose > 2) {
--				rprintf(FINFO, "[%s] add_exclude(%.*s, %s%s)\n",
--					who_am_i(), pat_len, cp,
--					listp->debug_type,
--					incl ? "include" : "exclude");
-+				rprintf(FINFO, "[%s] clearing %sexclude list\n",
-+					who_am_i(), listp->debug_type);
-+			}
-+			free_exclude_list(listp);
++		if (pat_len >= MAXPATHLEN) {
++			rprintf(FERROR, "discarding over-long exclude: %s\n",
++				cp);
 +			continue;
 +		}
+ 
+ 		if (mflags & MATCHFLG_CLEAR_LIST) {
+ 			if (verbose > 2) {
+@@ -308,13 +703,24 @@ void add_exclude(struct exclude_list_str
+ 			continue;
+ 		}
+ 
+-		make_exclude(listp, cp, pat_len, mflags);
+-
+-		if (verbose > 2) {
+-			rprintf(FINFO, "[%s] add_exclude(%.*s, %s%sclude)\n",
+-				who_am_i(), (int)pat_len, cp, listp->debug_type,
+-				mflags & MATCHFLG_INCLUDE ? "in" : "ex");
 +		if (mflags & MATCHFLG_MERGE_FILE) {
-+			char name[MAXPATHLEN];
-+			if ((unsigned) pat_len >= sizeof name)
-+				continue; /* XXX complain? */
-+			strlcpy(name, cp, pat_len+1);
-+			if (strchr(name, '/') != NULL) {
-+				if (sanitize_paths)
-+					sanitize_path(name, curr_dir);
-+				if (*name == '/')
-+					cp = name;
-+				else {
-+					if (strlcpy(dirbuf + dirbuf_offset,
-+					    name, MAXPATHLEN - dirbuf_offset)
-+					    >= MAXPATHLEN - dirbuf_offset)
-+						continue; /* XXX complain? */
-+					cp = dirbuf;
++			unsigned int len = pat_len;
++			if (mflags & MATCHFLG_PERDIR_MERGE) {
++				if (parent_dirscan) {
++					if (!(p = parse_merge_name(cp, &len, module_dirlen)))
++						continue;
++					make_exclude(listp, p, len, mflags);
++					continue;
 +				}
-+				add_exclude_file(listp, cp,
-+				    xflags | XFLG_FATAL_ERRORS);
++			} else {
++				if (!(p = parse_merge_name(cp, &len, 0)))
++					continue;
++				add_exclude_file(listp, p, xflags | XFLG_FATAL_ERRORS);
 +				continue;
- 			}
++			}
  		}
 +
 +		make_exclude(listp, cp, pat_len, mflags);
-+
-+		if (verbose > 2) {
-+			rprintf(FINFO, "[%s] add_exclude(%.*s, %s%s%sclude)\n",
-+				who_am_i(), pat_len, cp, listp->debug_type,
-+				mflags & MATCHFLG_MERGE_FILE ? "FILE " : "",
-+				mflags & MATCHFLG_INCLUDE ? "in" : "ex");
-+		}
  	}
  }
  
-@@ -383,15 +552,19 @@ void send_exclude_list(int f)
- 		l = strlcpy(p, ent->pattern, sizeof p);
- 		if (l == 0 || l >= MAXPATHLEN)
- 			continue;
--		if (ent->directory) {
-+		if (ent->match_flags & MATCHFLG_DIRECTORY) {
- 			p[l++] = '/';
- 			p[l] = '\0';
+@@ -323,7 +729,7 @@ void add_exclude_file(struct exclude_lis
+ 		      int xflags)
+ {
+ 	FILE *fp;
+-	char line[MAXPATHLEN+3]; /* Room for "x " prefix and trailing slash. */
++	char line[MAXPATHLEN+7]; /* Room for prefix chars and trailing slash. */
+ 	char *eob = line + sizeof line - 1;
+ 	int word_split = xflags & XFLG_WORD_SPLIT;
+ 
+@@ -344,6 +750,12 @@ void add_exclude_file(struct exclude_lis
  		}
+ 		return;
+ 	}
++	dirbuf[dirbuf_len] = '\0';
++
++	if (verbose > 2) {
++		rprintf(FINFO, "[%s] add_exclude_file(%s,%d)\n",
++			who_am_i(), fname, xflags);
++	}
  
--		if (ent->include) {
-+		if (ent->match_flags & MATCHFLG_INCLUDE) {
+ 	while (1) {
+ 		char *s = line;
+@@ -404,7 +816,21 @@ void send_exclude_list(int f)
+ 		if (ent->match_flags & MATCHFLG_INCLUDE) {
  			write_int(f, l + 2);
  			write_buf(f, "+ ", 2);
 -		} else if ((*p == '-' || *p == '+') && p[1] == ' ') {
 +		} else if (ent->match_flags & MATCHFLG_MERGE_FILE) {
-+			write_int(f, l + 2);
-+			write_buf(f, ". ", 2);
++			char buf[32], *op = buf;
++			*op++ = '.';
++			*op++ = ' ';
++			if (ent->match_flags & MATCHFLG_PERDIR_MERGE) {
++				*op++ = '-';
++				*op++ = 'p';
++				if (*p == '-')
++					*op++ = '-';
++				*op++ = ' ';
++			}
++			write_int(f, l + (op - buf));
++			write_buf(f, buf, op - buf);
 +		} else if ((*p == '-' || *p == '+' || *p == '.')
 +		    && p[1] == ' ') {
  			write_int(f, l + 2);
  			write_buf(f, "- ", 2);
  		} else
-@@ -432,6 +605,7 @@ void add_cvs_excludes(void)
+@@ -445,6 +871,7 @@ void add_cvs_excludes(void)
  	char fname[MAXPATHLEN];
  	char *p;
  
-+	add_exclude(&exclude_list, ". .cvsignore", 0);
++	add_exclude(&exclude_list, ". -p .cvsignore", 0);
  	add_exclude(&exclude_list, default_cvsignore,
  		    XFLG_WORD_SPLIT | XFLG_WORDS_ONLY);
  
---- flist.c	27 Apr 2004 01:36:10 -0000	1.217
-+++ flist.c	27 Apr 2004 01:44:52 -0000
-@@ -39,8 +39,6 @@ extern int module_id;
+--- orig/flist.c	2004-09-21 09:40:27
++++ flist.c	2004-08-12 18:59:28
+@@ -40,10 +40,9 @@ extern int module_id;
  extern int ignore_errors;
  extern int numeric_ids;
  
 -extern int cvs_exclude;
 -
  extern int recurse;
  extern char curr_dir[MAXPATHLEN];
++extern unsigned int curr_dir_len;
  extern char *files_from;
-@@ -66,7 +64,6 @@ extern int write_batch;
+ extern int filesfrom_fd;
+ 
+@@ -67,7 +66,6 @@ extern int list_only;
  
  extern struct exclude_list_struct exclude_list;
  extern struct exclude_list_struct server_exclude_list;
 -extern struct exclude_list_struct local_exclude_list;
  
  int io_error;
  
-@@ -211,8 +208,6 @@ int link_stat(const char *path, STRUCT_S
+@@ -223,8 +221,6 @@ int link_stat(const char *path, STRUCT_S
   */
  static int check_exclude_file(char *fname, int is_dir, int exclude_level)
  {
 -	int rc;
 -
  #if 0 /* This currently never happens, so avoid a useless compare. */
  	if (exclude_level == NO_EXCLUDES)
  		return 0;
-@@ -234,10 +229,7 @@ static int check_exclude_file(char *fnam
+@@ -246,10 +242,7 @@ static int check_exclude_file(char *fnam
  	if (exclude_level != ALL_EXCLUDES)
  		return 0;
  	if (exclude_list.head
 -	    && (rc = check_exclude(&exclude_list, fname, is_dir)) != 0)
 -		return rc < 0;
 -	if (local_exclude_list.head
 -	    && check_exclude(&local_exclude_list, fname, is_dir) < 0)
 +	    && check_exclude(&exclude_list, fname, is_dir) < 0)
  		return 1;
  	return 0;
  }
-@@ -946,11 +938,7 @@ void send_file_name(int f, struct file_l
+@@ -978,15 +971,7 @@ void send_file_name(int f, struct file_l
  
  	if (recursive && S_ISDIR(file->mode)
  	    && !(file->flags & FLAG_MOUNT_POINT)) {
 -		struct exclude_list_struct last_list = local_exclude_list;
 -		local_exclude_list.head = local_exclude_list.tail = NULL;
  		send_directory(f, flist, f_name_to(file, fbuf));
--		free_exclude_list(&local_exclude_list);
+-		if (verbose > 2) {
+-			rprintf(FINFO, "[%s] popping %sexclude list\n",
+-				who_am_i(), local_exclude_list.debug_type);
+-		}
+-		clear_exclude_list(&local_exclude_list);
 -		local_exclude_list = last_list;
  	}
  }
  
-@@ -961,6 +949,7 @@ static void send_directory(int f, struct
+@@ -997,6 +982,7 @@ static void send_directory(int f, struct
  	struct dirent *di;
  	char fname[MAXPATHLEN];
  	unsigned int offset;
 +	void *save_excludes;
  	char *p;
  
  	d = opendir(dir);
-@@ -985,18 +974,7 @@ static void send_directory(int f, struct
+@@ -1020,18 +1006,7 @@ static void send_directory(int f, struct
  		offset++;
  	}
  
 -	if (cvs_exclude) {
 -		if (strlcpy(p, ".cvsignore", MAXPATHLEN - offset)
 -		    < MAXPATHLEN - offset) {
@@ -530,130 +823,474 @@
 -		}
 -	}
 +	save_excludes = push_local_excludes(fname, offset);
  
  	for (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {
  		char *dname = d_name(di);
-@@ -1017,6 +995,8 @@ static void send_directory(int f, struct
- 		rprintf(FERROR, "readdir(%s): (%d) %s\n",
- 			dir, errno, strerror(errno));
+@@ -1052,6 +1027,8 @@ static void send_directory(int f, struct
+ 		rsyserr(FERROR, errno, "readdir(%s)", dir);
  	}
-+
-+	pop_local_excludes(save_excludes);
  
++	pop_local_excludes(save_excludes);
++
  	closedir(d);
  }
---- proto.h	22 Apr 2004 09:58:09 -0000	1.189
-+++ proto.h	27 Apr 2004 01:44:52 -0000
-@@ -51,7 +51,8 @@ int start_daemon(int f_in, int f_out);
- int daemon_main(void);
- void setup_protocol(int f_out,int f_in);
- int claim_connection(char *fname,int max_connections);
--void free_exclude_list(struct exclude_list_struct *listp);
-+void *push_local_excludes(char *fname, unsigned int offset);
-+void pop_local_excludes(void *mem);
- int check_exclude(struct exclude_list_struct *listp, char *name, int name_is_dir);
- void add_exclude(struct exclude_list_struct *listp, const char *pattern,
- 		 int xflags);
---- rsync.h	27 Apr 2004 01:36:16 -0000	1.199
-+++ rsync.h	27 Apr 2004 01:44:52 -0000
-@@ -490,18 +490,21 @@ struct map_struct {
- #define MATCHFLG_WILD2		(1<<1) /* pattern has '**' */
- #define MATCHFLG_WILD2_PREFIX	(1<<2) /* pattern starts with '**' */
- #define MATCHFLG_ABS_PATH	(1<<3) /* path-match on absolute path */
-+#define MATCHFLG_INCLUDE	(1<<4) /* this is an include, not an exclude */
-+#define MATCHFLG_CLEAR_LIST 	(1<<5) /* this item is the "!" token */
-+#define MATCHFLG_DIRECTORY	(1<<6) /* this matches only directories */
+ 
+@@ -1071,6 +1048,7 @@ struct file_list *send_file_list(int f, 
+ 	char *p, *dir, olddir[sizeof curr_dir];
+ 	char lastpath[MAXPATHLEN] = "";
+ 	struct file_list *flist;
++	BOOL need_first_push = True;
+ 	int64 start_write;
+ 	int use_ff_fd = 0;
+ 
+@@ -1091,6 +1069,10 @@ struct file_list *send_file_list(int f, 
+ 				exit_cleanup(RERR_FILESELECT);
+ 			}
+ 			use_ff_fd = 1;
++			if (curr_dir_len < MAXPATHLEN - 1) {
++				push_local_excludes(curr_dir, curr_dir_len);
++				need_first_push = False;
++			}
+ 		}
+ 	}
+ 
+@@ -1121,6 +1103,15 @@ struct file_list *send_file_list(int f, 
+ 			}
+ 		}
+ 
++		if (need_first_push) {
++			if ((p = strrchr(fname, '/')) != NULL) {
++				if (*++p && strcmp(p, ".") != 0)
++					push_local_excludes(fname, p - fname);
++			} else if (strcmp(fname, ".") != 0)
++				push_local_excludes(fname, 0);
++			need_first_push = False;
++		}
++
+ 		if (link_stat(fname, &st, keep_dirlinks) != 0) {
+ 			if (f != -1) {
+ 				io_error |= IOERR_GENERAL;
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-08-12 18:59:28
+@@ -287,6 +287,7 @@ void usage(enum logcode F)
+   rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
+   rprintf(F,"     --include-from=FILE     don't exclude patterns listed in FILE\n");
+   rprintf(F,"     --files-from=FILE       read FILE for list of source-file names\n");
++  rprintf(F," -E                          same as --exclude='. -p /.rsync-excludes'\n");
+   rprintf(F," -0, --from0                 all *-from file lists are delimited by nulls\n");
+   rprintf(F,"     --version               print version number\n");
+   rprintf(F,"     --daemon                run as an rsync daemon\n");
+@@ -389,6 +390,7 @@ static struct poptOption long_options[] 
+   {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
+   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
+   {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
++  {0,                 'E', POPT_ARG_NONE,   0,              'E', 0, 0 },
+   {0,                 'P', POPT_ARG_NONE,   0,              'P', 0, 0 },
+   {"config",           0,  POPT_ARG_STRING, &config_file, 0, 0, 0 },
+   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
+@@ -585,6 +587,11 @@ int parse_arguments(int *argc, const cha
+ 			am_sender = 1;
+ 			break;
+ 
++		case 'E':
++			add_exclude(&exclude_list,
++				    ". -p /.rsync-excludes", 0);
++			break;
++
+ 		case 'P':
+ 			do_progress = 1;
+ 			keep_partial = 1;
+--- orig/rsync.h	2004-09-22 08:47:31
++++ rsync.h	2004-09-22 08:48:53
+@@ -109,6 +109,7 @@
+ #define XFLG_WORDS_ONLY 	(1<<2)
+ #define XFLG_WORD_SPLIT 	(1<<3)
+ #define XFLG_DIRECTORY	 	(1<<4)
++#define XFLG_ABS_PATH	 	(1<<5)
+ 
+ #define PERMS_REPORT		(1<<0)
+ #define PERMS_SKIP_MTIME	(1<<1)
+@@ -500,11 +501,18 @@ struct map_struct {
+ #define MATCHFLG_INCLUDE	(1<<4) /* this is an include, not an exclude */
+ #define MATCHFLG_DIRECTORY	(1<<5) /* this matches only directories */
+ #define MATCHFLG_CLEAR_LIST 	(1<<6) /* this item is the "!" token */
 +#define MATCHFLG_MERGE_FILE	(1<<7) /* specifies a file to merge */
 +#define MATCHFLG_CVSIGNORE	(1<<8) /* parse this as a .cvsignore file */
++#define MATCHFLG_PERDIR_MERGE	(1<<9) /* merge-file is searched per-dir */
++#define MATCHFLG_FINISH_SETUP	(1<<10)/* per-dir merge file needs setup */
  struct exclude_struct {
  	struct exclude_struct *next;
  	char *pattern;
- 	int match_flags;
--	int include;
--	int directory;
- 	int slash_cnt;
+ 	unsigned int match_flags;
+-	int slash_cnt;
++	union {
++		int slash_cnt;
++		struct exclude_list_struct *mergelist;
++	} u;
  };
  
  struct exclude_list_struct {
--	struct exclude_struct *head;
--	struct exclude_struct *tail;
-+	struct exclude_struct *head, *tail;
-+	struct exclude_struct *extra, *parent;
- 	char *debug_type;
- };
- 
---- rsync.yo	24 Apr 2004 06:16:04 -0000	1.164
-+++ rsync.yo	27 Apr 2004 01:44:53 -0000
-@@ -1064,6 +1064,72 @@ itemize(
-   it would be excluded by the "*")
+--- orig/rsync.yo	2004-09-24 16:42:30
++++ rsync.yo	2004-08-13 00:43:31
+@@ -364,6 +364,7 @@ verb(
+      --include=PATTERN       don't exclude files matching PATTERN
+      --include-from=FILE     don't exclude patterns listed in FILE
+      --files-from=FILE       read FILE for list of source-file names
++ -E                          same as --exclude='. -p /.rsync-excludes'
+  -0  --from0                 all file lists are delimited by nulls
+      --version               print version number
+      --daemon                run as an rsync daemon
+@@ -1037,24 +1038,32 @@ The exclude and include patterns specifi
+ selection of which files to transfer and which files to skip.
+ 
+ Rsync builds an ordered list of include/exclude options as specified on
+-the command line. Rsync checks each file and directory 
+-name against each exclude/include pattern in turn. The first matching
++the command line.
++It can also be told to check for include/exclude options in each
++directory that rsync visits during the transfer (see the section on
++MERGED EXCLUDE FILES for the details on these per-directory exclude
++files).
++
++As the list of files/directories to transfer is built, rsync checks each
++name against every exclude/include pattern in turn. The first matching
+ pattern is acted on. If it is an exclude pattern, then that file is
+ skipped. If it is an include pattern then that filename is not
+ skipped. If no matching include/exclude pattern is found then the
+ filename is not skipped.
+ 
+-The filenames matched against the exclude/include patterns are relative
+-to the "root of the transfer".  If you think of the transfer as a
+-subtree of names that are being sent from sender to receiver, the root
+-is where the tree starts to be duplicated in the destination directory.
+-This root governs where patterns that start with a / match (see below).
++The global include/exclude rules are anchored at the "root of the
++transfer" (as opposed to per-directory rules, which are anchored at
++the merge-file's directory).  If you think of the transfer as a
++subtree of names that are being sent from sender to receiver, the
++transfer-root is where the tree starts to be duplicated in the
++destination directory.  This root governs where patterns that start
++with a / match (as described in the list on pattern forms below).
+ 
+ Because the matching is relative to the transfer-root, changing the
+ trailing slash on a source path or changing your use of the --relative
+ option affects the path you need to use in your matching (in addition to
+ changing how much of the file tree is duplicated on the destination
+-system).  The following examples demonstrate this.
++host).  The following examples demonstrate this.
+ 
+ Let's say that we want to match two source files, one with an absolute
+ path of "/home/me/foo/bar", and one with a path of "/home/you/bar/baz".
+@@ -1101,23 +1110,27 @@ because rsync did not descend through th
+ hierarchy.
+ 
+ Note also that the --include and --exclude options take one pattern
+-each. To add multiple patterns use the --include-from and
+---exclude-from options or multiple --include and --exclude options. 
++each. To add multiple patterns use the --include-from and --exclude-from
++options or multiple --include and --exclude options.
+ 
+-The patterns can take several forms. The rules are:
++The include/exclude patterns can take several forms. The rules are:
+ 
+ itemize(
+ 
+-  it() if the pattern starts with a / then it is matched against the
+-  start of the filename, otherwise it is matched against the end of
+-  the filename.
+-  This is the equivalent of a leading ^ in regular expressions.
+-  Thus "/foo" would match a file called "foo" at the transfer-root
+-  (see above for how this is different from the filesystem-root).
+-  On the other hand, "foo" would match any file called "foo"
++  it() if the pattern starts with a / then it is anchored to a
++  particular spot in the hierarchy of files, otherwise it is matched
++  against the end of the pathname.  This is similar to a leading ^ in
++  regular expressions.
++  Thus "/foo" would match a file called "foo" at either the "root of the
++  transfer" (for a global rule) or in the merge-file's directory (for a
++  per-directory rule).
++  An unqualified "foo" would match any file or directory named "foo"
+   anywhere in the tree because the algorithm is applied recursively from
++  the
+   top down; it behaves as if each path component gets a turn at being the
+-  end of the file name.
++  end of the file name.  Even the unanchored "sub/foo" would match at
++  any point in the hierarchy where a "foo" was found within a directory
++  named "sub".
+ 
+   it() if the pattern ends with a / then it will only match a
+   directory, not a file, link, or device.
+@@ -1130,22 +1143,31 @@ itemize(
+   single asterisk pattern "*" will stop at slashes.
+ 
+   it() if the pattern contains a / (not counting a trailing /) or a "**"
+-  then it is matched against the full filename, including any leading
+-  directory. If the pattern doesn't contain a / or a "**", then it is
++  then it is matched against the full pathname, including any leading
++  directories. If the pattern doesn't contain a / or a "**", then it is
+   matched only against the final component of the filename.  Again,
+   remember that the algorithm is applied recursively so "full filename" can
+   actually be any portion of a path below the starting directory.
+ 
+   it() if the pattern starts with "+ " (a plus followed by a space)
+   then it is always considered an include pattern, even if specified as
+-  part of an exclude option. The prefix is discarded before matching.
++  part of an exclude option. (The prefix is discarded before matching.)
+ 
+   it() if the pattern starts with "- " (a minus followed by a space)
+   then it is always considered an exclude pattern, even if specified as
+-  part of an include option. The prefix is discarded before matching.
++  part of an include option. (The prefix is discarded before matching.)
++
++  it() if the pattern starts with ". " (a dot followed by a space) then its
++  pattern is taken to be a merge-file that is read in to supplement the
++  current rules.  See the section on MERGED EXCLUDE FILES for more
++  information.
+ 
+   it() if the pattern is a single exclamation mark ! then the current
+   include/exclude list is reset, removing all previously defined patterns.
++  The "current" list is either the global list of rules (which are
++  specified via options) or a set of per-directory rules (which are
++  inherited in their own sub-list, so a subdirectory can use this to
++  clear out the parent's rules).
  )
  
-+manpagesection(MERGING EXCLUDE FILES)
-+
-+You can merge whole files into an exclude file using a rule that starts
-+with a ". " (a dot followed by a space) and has a filename in place of the
-+pattern.  There are two types of merge rules, single-instance and
-+per-directory:
-+
-+itemize(
-+  it() If the filename has no slashes in it, it is a per-directory merge;
-+  rsync scans every directory that is traversed and merges the named file's
-+  contents (when it exists), putting the contents of each subdirectory's
-+  file at the start of this per-directory sub-list (so subdirectories
-+  inherit the contents of their parent directories by default, but each
-+  subdirectory's rules have precedence over the parent's rules).
-+
-+  it() If a filename has a slash in it, it is a single-instance merge; the
-+  named file's contents will be merged into the current exclude file,
-+  replacing the merge rule.  Thus, you should use the name ./foo instead of
-+  foo if you don't want to scan for "foo" in all the subdirectories of the
-+  current directory.
+ The +/- rules are most useful in a list that was read from a file, allowing
+@@ -1192,8 +1214,160 @@ itemize(
+   it() --include "*/" --include "*.c" --exclude "*" would include all 
+   directories and C source files
+   it() --include "foo/" --include "foo/bar.c" --exclude "*" would include
+-  only foo/bar.c (the foo/ directory must be explicitly included or
+-  it would be excluded by the "*")
++  only the foo directory and foo/bar.c (the foo directory must be
++  explicitly included or it would be excluded by the "*")
 +)
 +
-+Note also that you can eliminate all the inherited rules for the current
-+per-directory ruleset by putting the list-clearing token (!) in the file.
-+This clears only the rules of the current per-directory sub-list (up
-+through the token) and only for the current directory and its
-+subdirectories.
++manpagesection(MERGED EXCLUDE FILES)
 +
-+Here's an example. Specify the file that holds this set of rules via a
-+normal --exclude-from option:
++You can merge whole files into an exclude file by specifying a rule that
++starts with a ". " (a dot followed by a space) and putting a filename in
++place of the pattern.  There are two kinds of merged exclude files --
++single-instance and per-directory.  The choice is made via an option
++placed prior to the merge-file name:
++
++startdit()
++
++dit(bf(-p)) Make the file a per-directory merge-file.  Rsync will scan
++every directory that it traverses for the named file, merging its contents
++when the file exists.  These exclude files must exist on the sending side
++because it is the sending side that is being scanned for available files
++to send.  The files may also need to be transferred to the receiving side
++if you want them to affect what files don't get deleted (see PER-DIRECTORY
++EXCLUDES AND DELETE below).
++
++dit(bf(--)) End the scanning of options.  Useful if you want to specify a
++filename that begins with a dash.
++
++enddit()
++
++Per-directory rules are inherited in all subdirectories of the directory
++where the merge-file was found.  Each subdirectory's rules are prefixed
++to the inherited rules from the parent directories, which gives the
++newest rules a higher priority than the inherited rules.  The entire set
++of per-dir rules is grouped together in the spot where the merge-file was
++specified, so it is possible to override per-dir rules via a rule that
++got specified earlier in the list of global rules.
++
++If you don't want a per-dir rule to be inherited, anchor it with a leading
++slash.  Anchored rules in a per-directory merge-file are relative to the
++merge-file's directory, so a rule "/foo" would only exclude the file "foo"
++in the directory where the per-dir exclude file was found.
++
++Here's an example exclude file which you'd specify via the normal
++--exclude-from=FILE option:
 +
 +verb(
 +    . /home/user/.global_excludes
-+    - *.gz
-+    . .excl
++    *.gz
++    . -p .excl
 +    + *.[ch]
-+    - *.o
++    *.o
 +)
 +
 +This will merge the contents of the /home/user/.global_excludes file at the
 +start of the list and also turns the ".excl" filename into a per-directory
-+exclude file whose local contents will be merged into the list in place of
-+the .excl line.
++exclude file.  All the merged rules default to being exclude rules because
++an exclude statement was used to specify them.  Rules read in from the
++.global_excludes file are anchored just like all other global rules.
++
++If a per-directory merge-file is specified with a path that is a parent
++directory of the first transfer directory, rsync will scan all the parent
++dirs from that starting point to the transfer directory for the indicated
++per-directory file.  For instance, the -E option is an abbreviation for
++this command:
++
++verb(
++  --exclude='. -p /.rsync-excludes'
++)
++
++That exclude tells rsync to scan for the file .rsync-excludes in all
++directories from the root down through the source of the transfer.  (For
++an rsync daemon, the "root dir" is always the module's "path" setting.)
++
++Some examples of this pre-scanning for per-directory files:
++
++verb(
++  rsync -avE /src/path/ /dest/dir
++  rsync -av --exclude='. -p ../../.rsync-excludes' /src/path/ /dest/dir
++  rsync -av --exclude='. -p .rsync-excludes' /src/path/ /dest/dir
++)
++
++The first two commands above will look for ".rsync-excludes" in "/" and
++"/src" before the normal scan begins looking for the file in "/src/path"
++and its subdirectories.  The last command avoids the parent-dir scan
++and only looks for the ".rsync-excludes" files in each directory that is
++a part of the transfer.
++
++Finally, note that the parsing of any merge-file named ".cvsignore" is
++always done in a CVS-compatible manner, even if -C wasn't specified.  This
++means that its rules are always excludes (even if an include option
++specified the file), patterns are split on whitespace, the rules are never
++inherited, and no special characters are honored (e.g. no comments, no "!",
++etc.).
 +
 +Additionally, you can affect where the --cvs-exclude (-C) option's
-+inclusion of a per-directory .cvsignore file gets placed into your rules by
-+adding an explicit a merge rule for ".cvsignore".  For instance, specifying
-+this:
++inclusion of the per-directory .cvsignore file gets placed into your rules
++by adding your own explicit per-directory merge rule for ".cvsignore".
++Without this, rsync would add its this rule at the end of all your other
++rules (giving it a lower priority than your command-line rules).  For
++example:
 +
 +verb(
-+  rsync -avC --exclude='. .cvsignore' --exclude-from=foo a/ b
++  rsync -avC --exclude='. -p .cvsignore' --exclude-from=foo a/ b
 +)
 +
-+will merge all the per-directory .cvsignore rules at the start of your list
-+rather than at the end.  This allows their dir-specific rules to supersede
-+your rules instead of being subservient to them.  (The global rules taken
-+from the $HOME/.cvsignore file and from $CVSIGNORE are not affected by
-+this.)
-+
-+Note also that the parsing of any merge-file named ".cvsignore" is always
-+done in a CVS-compatible manner (even if -C wasn't specified) -- i.e. the
-+rules are always exclude rules (even when specified by an include option),
-+they are split on whitespace, no special prefixes or list-clearing tokens
-+are honored, and (for per-directory files) subdirectories don't inherit the
-+parent directory's rules.
++The above will merge all the per-directory .cvsignore rules at the start of
++your list rather than at the end.  This allows their dir-specific rules to
++supersede your rules instead of being subservient to them.  (The global
++rules taken from the $HOME/.cvsignore file and from $CVSIGNORE are not
++repositioned by this.)
++
++manpagesection(PER-DIRECTORY EXCLUDES AND DELETE)
++
++Without a delete option, per-directory excludes are only relevant on the
++sending side, so you can feel free to exclude the merge files themselves
++without affecting the transfer:
 +
- manpagesection(BATCH MODE)
++verb(
++  rsync -av --exclude='. -p .excl' --exclude=.excl host:src/dir /dest
++)
++
++However, if you want to do a delete on the receiving side AND you want some
++files to be excluded from being deleted, you'll need to be sure that the
++receiving side knows what files to exclude.  The easiest way is to include
++the per-directory merge files in the transfer and use --delete-after
++because this ensures that the receiving side gets all the same exclude
++rules as the sending side before it tries to delete anything:
++
++verb(
++  rsync -avE --delete-after host:src/dir /dest
++)
++
++However, if you the merge files are not a part of the transfer, you'll need
++to either use a global exclude rule (i.e. specified on the command line),
++or you'll need to maintain your own per-directory merge files on the
++receiving side.  An example of the first is this (assume that the remote
++.ctrl files exclude themselves):
++
++verb(
++  rsync -av --exclude='. -p .ctrl' --exclude-from=/my/extra.rules
++    --delete host:src/dir /dest
++)
++
++In the above example the extra.rules file can affect both sides of the
++transfer, but the rules are subservient to the rules merged from the .ctrl
++files because they were specified after the per-directory merge rule.
++
++In the final example, the remote side is excluding the .rsync-excludes
++files from the transfer, but we want to use our own .rsync-excludes files
++to control what gets deleted on the receiving side.  To do this we must
++specifically exclude the per-directory merge files (so that they don't get
++deleted) and then put rules into the local files to control what else
++should not get deleted.  Like this:
++
++verb(
++  rsync -avE --exclude=.rsync-excludes --delete host:src/dir /dest
+ )
  
- bf(Note:) Batch mode should be considered experimental in this version
+ manpagesection(BATCH MODE)
+--- orig/testsuite/exclude.test	2004-05-29 21:25:45
++++ testsuite/exclude.test	2004-08-08 06:35:15
+@@ -23,19 +23,47 @@ export HOME CVSIGNORE
+ makepath "$fromdir/foo/down/to/you"
+ makepath "$fromdir/bar/down/to/foo/too"
+ makepath "$fromdir/mid/for/foo/and/that/is/who"
++cat >"$fromdir/.excl" <<EOF
++.excl
++*.bak
++*.old
++*.junk
++EOF
+ echo kept >"$fromdir/foo/file1"
+ echo removed >"$fromdir/foo/file2"
+ echo cvsout >"$fromdir/foo/file2.old"
++cat >"$fromdir/foo/.excl" <<EOF
+++ .excl
++- file1
++EOF
++cat >"$fromdir/bar/.excl" <<EOF
++home-cvs-exclude
++. -p .excl2
+++ to
++EOF
+ echo cvsout >"$fromdir/bar/down/to/home-cvs-exclude"
++cat >"$fromdir/bar/down/to/.excl2" <<EOF
++.excl2
++EOF
+ echo keeper >"$fromdir/bar/down/to/foo/file1"
+ echo cvsout >"$fromdir/bar/down/to/foo/file1.bak"
+ echo gone >"$fromdir/bar/down/to/foo/file3"
+ echo lost >"$fromdir/bar/down/to/foo/file4"
+ echo cvsout >"$fromdir/bar/down/to/foo/file4.junk"
+ echo smashed >"$fromdir/bar/down/to/foo/to"
++cat >"$fromdir/bar/down/to/foo/.excl2" <<EOF
+++ *.junk
++EOF
++# This one should be ineffectual
++cat >"$fromdir/mid/.excl2" <<EOF
++extra
++EOF
+ echo cvsout >"$fromdir/mid/one-in-one-out"
+ echo one-in-one-out >"$fromdir/mid/.cvsignore"
+ echo cvsin >"$fromdir/mid/one-for-all"
++cat >"$fromdir/mid/.excl" <<EOF
++. -p .cvsignore
++EOF
+ echo cvsin >"$fromdir/mid/for/one-in-one-out"
+ echo expunged >"$fromdir/mid/for/foo/extra"
+ echo retained >"$fromdir/mid/for/foo/keep"
+@@ -100,5 +128,24 @@ $RSYNC -av --existing --include='*/' --e
+ checkit "$RSYNC -avvC --exclude-from=\"$excl\" \
+     --delete-excluded \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+ 
++# Modify the chk dir for our merge-exclude test and then tweak the dir times.
++
++rm "$chkdir"/.excl
++rm "$chkdir"/foo/file1
++rm "$chkdir"/bar/.excl
++rm "$chkdir"/bar/down/to/.excl2
++rm "$chkdir"/bar/down/to/foo/.excl2
++rm "$chkdir"/mid/.excl
++cp -p "$fromdir"/bar/down/to/foo/*.junk "$chkdir"/bar/down/to/foo
++cp -p "$fromdir"/bar/down/to/foo/to "$chkdir"/bar/down/to/foo
++
++$RSYNC -av --existing --include='*/' --exclude='*' "$fromdir/" "$chkdir/"
++
++# Now, test if rsync excludes the same files, this time with a merge-exclude
++# file.
++
++checkit "$RSYNC -avv --exclude='. -p .excl' --exclude-from=\"$excl\" \
++    --delete-excluded \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
++
+ # The script would have aborted on error, so getting here means we've won.
+ exit 0
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: mkfifo.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/netgroup-auth.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/netgroup-auth.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/netgroup-auth.diff	2004-04-26 01:37:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/netgroup-auth.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,13 +1,13 @@
 This allows you to use the samba style @netgroup names in hosts allow
 and hosts deny.
 
 This patch still needs autoconf support for portability.
 
---- access.c	30 Jul 2003 06:12:27 -0000	1.13
-+++ access.c	25 Apr 2004 17:20:47 -0000
+--- orig/access.c	2004-09-25 16:57:35
++++ access.c	2004-04-25 17:20:47
 @@ -22,11 +22,14 @@
    */
  
  #include "rsync.h"
 +#include <netdb.h>
  
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/ODBC-dblog.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/ODBC-dblog.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/ODBC-dblog.diff	2004-04-25 02:55:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/ODBC-dblog.diff	2004-10-01 00:32:36.000000000 +0800
@@ -1,180 +1,173 @@
 Add support for logging daemon messages to an SQL database.
 
-After applying this patch you'll need to run autoconf and autoheader to
-generate updated versions of "configure" and "config.h.in".
+After applying this patch, run these commands for a successful build:
 
-You'll need to run configure with the --with-ODBC option in order for the
-extended features to be active.
+    autoconf
+    autoheader
+    ./configure --with-ODBC
+    make proto
+    make
 
-Patch provided by Steve Sether.
+Steve Sether writes:
 
-(Tweaked by Wayne Davison for rsync-style purposes but not compiled, so if the
-dblog.c file has a compile problem, it's probably my fault...)
+This patch adds the following options:
 
+"database logging"
+    If set to True, rsync will attempt to connect to
+    the specified datasource and write to the named tables.
+    Defaults to False.
 
---- Makefile.in	10 Feb 2004 17:06:11 -0000	1.98
-+++ Makefile.in	24 Apr 2004 08:14:37 -0000
+"database datasource"
+    Specifies the name of the ODBC data source to use.
+
+"database username"
+    The username to use when connecting to the database.
+
+"database password"
+    The password to use when connecting to the database.
+
+"transfer table name"
+    The name of the transfer table to log to.  This table contains individual
+    filenames, file sizes, bytes transferred, checksum bytes transferred,
+    operation (send or receive), and a timestamp.
+
+"session table name"
+    The name of the session table to log to.  This table contains the username,
+    module name, module path, ip address, process ID, and a timestamp.
+
+"exit table name"
+
+    The name of the exit table to log to.  This table contains the total bytes
+    read, total bytes written, total size of all files, error code, line the
+    error occured at, file the error occured at and the text of the error.
+    (most of which will be blank if the program exited normally).
+
+"unique id method"
+    Different databases use different methods to get a unique identifier.
+    Some databases support sequence objects, and use various forms of the
+    nextval command to retrieve a unique identifier from it.  Other databases
+    support an autonumber field, and support different methds of retrieving
+    the ID used in the last insert.  Valid values for this option are:
+
+	nextval-postgres
+	    uses the syntax of nextval for PostgreSQL databases
+
+	nextval-oracle
+	    uses the syntax of nextval for Oracle databases
+
+	nextval-db2
+	    uses the syntax of nextval for DB2 databases
+
+	last_insert_id
+	    uses the last_insert_id() command for the MySQL databases
+
+	@@IDENTITY
+	    uses the @@IDENTITY command for Sybase databases
+
+	custom
+	    Define your own method to get a unique identifier.  See the
+	    "custom unique id select", and the "get custom id before select"
+	    parameters.
+
+"sequence name"
+    If your database supports sequences, list the name of the sequence to use
+    for the session unique identifier.
+
+"custom unique id select"
+    Only used if you specify the custom method in "unique id method".  This is
+    a SQL statement to be executed to get a unique ID.  This SQL statement must
+    return one column with the unique ID to use for the session ID.  Should be
+    used in concert with the "get custom id before select" parameter.
+
+"get custom id before insert"
+    This parameter is ignored unless the "unique id method" is set to custom.
+    If set to true, the "custom unique id select" statement will be executed
+    BEFORE the session row is inserted into the database.  (as is done when a
+    sequence is used for unique IDs).  If False the statement will be executed
+    after the session row is inserted (as is done when the session ID is
+    automatically generates unique IDs).  Defaults to True.
+
+
+--- orig/Makefile.in	2004-08-13 07:18:58
++++ Makefile.in	2004-07-03 20:22:18
 @@ -32,7 +32,7 @@ ZLIBOBJ=zlib/deflate.o zlib/infblock.o z
  	zlib/inflate.o zlib/inftrees.o zlib/infutil.o zlib/trees.o \
  	zlib/zutil.o zlib/adler32.o
  OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
 -	main.o checksum.o match.o syscall.o log.o backup.o
 +	main.o checksum.o match.o syscall.o log.o backup.o @EXTRA_OBJECT@
  OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
  	fileio.o batch.o clientname.o
  OBJS3=progress.o pipe.o
---- /dev/null	1 Jan 1970 00:00:00 -0000
-+++ README-ODBC	24 Apr 2004 08:14:37 -0000
-@@ -0,0 +1,80 @@
-+This patch adds the following options:
-+
-+"database logging"
-+If set to True, rsync will attempt to connect to
-+the specified datasource and write to the named tables.
-+Defaults to False.
-+
-+
-+"database datasource"
-+Specifies the name of the ODBC data source to use.
-+
-+"database username"
-+The username to use when connecting to the database.
-+
-+"database password"
-+The password to use when connecting to the database.
-+
-+"transfer table name"
-+The name of the transfer table to log to.
-+This table contains individual filenames, file sizes, bytes transferred, checksum bytes transferred, operation (send or receive), and a timestamp.
-+
-+"session table name"
-+The name of the session table to log to.
-+This table contains the username, module name, module path, ip address, process ID, and a timestamp.
-+
-+"exit table name"
-+The name of the exit table to log to.
-+This table contains the total bytes read, total bytes written, total size
-+of all files, error code, line the error occured at, file the error occured at
-+and the text of the error. (most of which will be blank if the program exited normally).
-+
-+
-+"unique id method"
-+Different databases use different methods to get a unique identifier.
-+Some databases support sequence objects, and use various forms of the
-+nextval command to retrieve a unique identifier from it.  Other databases
-+support an autonumber field, and support different methds of retrieving
-+the ID used in the last insert.  Valid values for this option are:
-+
-+	nextval-postgres
-+	uses the syntax of nextval for PostgreSQL databases
-+
-+	nextval-oracle
-+	uses the syntax of nextval for Oracle databases
-+
-+	nextval-db2
-+	uses the syntax of nextval for  DB2 databases
-+
-+	last_insert_id
-+	uses the last_insert_id() command for the MySQL databases
-+
-+	@@IDENTITY
-+	uses the @@IDENTITY command for Sybase databases
-+
-+	custom
-+	Define your own method to get a unique identifier.  See the
-+	"custom unique id select", and the "get custom id before select"
-+	parameters.
-+
-+
-+"sequence name"
-+If your database supports sequences, list the name of the sequence to use
-+for the session unique identifier.
-+
-+"custom unique id select"
-+Only used if you specify the custom method in "unique id method".  This
-+is a SQL statement to be executed to get a unique ID.  This SQL
-+statement must return one column with the unique ID to use for
-+the session ID.  Should be used in concert with the "get custom
-+id before select" parameter.
-+
-+"get custom id before insert"
-+This parameter is ignored unless the "unique id method" is set to custom.
-+If set to true, the "custom unique id select" statement will
-+be executed BEFORE the session row is inserted into the database.
-+(as is done when a sequence is used for unique IDs).
-+If False the statement will be executed after the session
-+row is inserted (as is done when the session ID is automatically generates
-+unique IDs).
-+Defaults to True.
---- cleanup.c	27 Jan 2004 08:14:33 -0000	1.21
-+++ cleanup.c	24 Apr 2004 08:14:37 -0000
-@@ -138,7 +138,12 @@ void _exit_cleanup(int code, const char 
+--- orig/cleanup.c	2004-07-29 16:08:03
++++ cleanup.c	2004-07-03 20:22:18
+@@ -139,8 +139,12 @@ void _exit_cleanup(int code, const char 
  			code = RERR_VANISHED;
  	}
  
--	if (code) log_exit(code, file, line);
+-	if (code)
 +	if (code) {
-+		log_exit(code, file, line);
+ 		log_exit(code, file, line);
 +#ifdef HAVE_LIBODBC
 +		db_log_exit(code,file,line);
 +#endif
 +	}
  
- 	if (verbose > 2)
- 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n", 
---- clientserver.c	14 Apr 2004 23:33:34 -0000	1.121
-+++ clientserver.c	24 Apr 2004 08:14:37 -0000
-@@ -311,6 +311,9 @@ static int rsync_module(int f_in, int f_
+ 	if (verbose > 2) {
+ 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n",
+--- orig/clientserver.c	2004-08-02 02:29:16
++++ clientserver.c	2004-07-03 20:22:18
+@@ -322,6 +322,9 @@ static int rsync_module(int f_in, int f_
  	exclude_path_prefix = NULL;
  
  	log_init();
 +#ifdef HAVE_LIBODBC
 +	db_log_open();
 +#endif
  
  	if (use_chroot) {
  		/*
-@@ -429,6 +432,9 @@ static int rsync_module(int f_in, int f_
- 			rprintf(FINFO,"rsync %s %s from %s@%s (%s)\n",
- 				am_sender?"on":"to",
+@@ -440,6 +443,9 @@ static int rsync_module(int f_in, int f_
+ 			rprintf(FLOG, "rsync %s %s from %s@%s (%s)\n",
+ 				am_sender ? "on" : "to",
  				request, auth_user, host, addr);
 +#ifdef HAVE_LIBODBC
 +			db_log_session();
 +#endif
  		} else {
- 			rprintf(FINFO,"rsync %s %s from %s (%s)\n",
- 				am_sender?"on":"to",
---- configure.in	17 Apr 2004 18:40:16 -0000	1.191
-+++ configure.in	24 Apr 2004 08:14:38 -0000
+ 			rprintf(FLOG, "rsync %s %s from %s (%s)\n",
+ 				am_sender ? "on" : "to",
+--- orig/configure.in	2004-09-23 17:42:07
++++ configure.in	2004-07-03 20:22:18
 @@ -94,6 +94,8 @@ AC_ARG_WITH(rsync-path,
  	[  --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)],
  	[ RSYNC_PATH="$with_rsync_path" ],
  	[ RSYNC_PATH="rsync" ])
 +AC_ARG_WITH(ODBC,
 +	[  --with-ODBC             compile in support for ODBC database logging])
  
  AC_DEFINE_UNQUOTED(RSYNC_PATH, "$RSYNC_PATH", [location of rsync on remote machine])
  
-@@ -458,6 +460,14 @@ fi
- if test x"$with_included_popt" != x"yes"
- then
+@@ -466,6 +468,14 @@ then
      AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])
-+fi
-+
+ fi
+ 
 +if test x"$with_ODBC" = x"yes"
 +then
 +    AC_CHECK_HEADERS(sql.h sqlext.h sqltypes.h)
 +    AC_CHECK_LIB(odbc,SQLExecDirect)
 +    EXTRA_OBJECT="$EXTRA_OBJECT dblog.o"
 +    AC_SUBST(EXTRA_OBJECT)
- fi
- 
++fi
++
  AC_MSG_CHECKING([whether to use included libpopt])
---- /dev/null	1 Jan 1970 00:00:00 -0000
-+++ dblog-tables-mysql.sql	24 Apr 2004 08:14:38 -0000
+ if test x"$with_included_popt" = x"yes"
+ then
+--- orig/dblog-tables-mysql.sql	2004-07-02 21:35:58
++++ dblog-tables-mysql.sql	2004-07-02 21:35:58
 @@ -0,0 +1,43 @@
 +drop table transfer;
 +drop table exit;
 +drop table session;
 +
 +CREATE TABLE session (
@@ -213,14 +206,14 @@
 +	error_code		int NOT NULL,
 +	error_file		varchar(64) NOT NULL,
 +	error_line		int NOT NULL,
 +	Primary Key (id),
 +	foreign key (session_id) references session (id)
 +);
---- /dev/null	1 Jan 1970 00:00:00 -0000
-+++ dblog-tables-postgresql.sql	24 Apr 2004 08:14:38 -0000
+--- orig/dblog-tables-postgresql.sql	2004-07-02 21:35:58
++++ dblog-tables-postgresql.sql	2004-07-02 21:35:58
 @@ -0,0 +1,45 @@
 +drop table transfer;
 +drop table exit;
 +drop table session;
 +drop sequence session_id_seq;
 +create sequence session_id_seq;
@@ -261,14 +254,14 @@
 +	"error_code"		int NOT NULL,
 +	"error_file"		varchar(64) NOT NULL,
 +	"error_line"		int NOT NULL,
 +	Primary Key (id),
 +	foreign key (session_id) references session (id)
 +);
---- /dev/null	1 Jan 1970 00:00:00 -0000
-+++ dblog.c	24 Apr 2004 08:14:38 -0000
+--- orig/dblog.c	2004-07-02 21:35:58
++++ dblog.c	2004-07-02 21:35:58
 @@ -0,0 +1,352 @@
 +/*
 + *  ODBC Database logging functions
 + *
 + *  Written by Steve Sether, April 2004
 + *  steve@vellmont.com
@@ -616,15 +609,15 @@
 +			}
 +		}
 +	} else {
 +		rprintf(FERROR,"Error at db_log_exit: Not connected to database!\n");
 +	}
 +}
---- loadparm.c	4 Feb 2004 07:31:29 -0000	1.50
-+++ loadparm.c	24 Apr 2004 08:14:38 -0000
-@@ -122,6 +122,17 @@ typedef struct
+--- orig/loadparm.c	2004-07-31 16:41:04
++++ loadparm.c	2004-07-03 20:22:18
+@@ -123,6 +123,17 @@ typedef struct
  	BOOL list;
  	BOOL use_chroot;
  	BOOL transfer_logging;
 +	BOOL database_logging;
 +	char *database_datasource;
 +	char *database_username;
@@ -636,13 +629,13 @@
 +	char *unique_id_method;
 +	char *custom_unique_id_select;
 +	BOOL get_custom_id_before_insert;
  	BOOL ignore_errors;
  	char *uid;
  	char *gid;
-@@ -154,6 +165,17 @@ static service sDefault =
+@@ -156,6 +167,17 @@ static service sDefault =
  	True,    /* list */
  	True,    /* use chroot */
  	False,   /* transfer logging */
 +	False,   /* Database Logging */
 +	NULL,    /* Database datasource */
 +	NULL,    /* Database username */
@@ -654,13 +647,13 @@
 +	NULL,    /* unique method */
 +	NULL,    /* custom unique id select*/
 +	True,    /* get custom id before insert */
  	False,   /* ignore errors */
  	"nobody",/* uid */
  
-@@ -292,6 +314,17 @@ static struct parm_struct parm_table[] =
+@@ -295,6 +317,17 @@ static struct parm_struct parm_table[] =
    {"include",          P_STRING,  P_LOCAL,  &sDefault.include,     NULL,   0},
    {"include from",     P_STRING,  P_LOCAL,  &sDefault.include_from,NULL,   0},
    {"transfer logging", P_BOOL,    P_LOCAL,  &sDefault.transfer_logging,NULL,0},
 +  {"database logging", P_BOOL,    P_LOCAL,  &sDefault.database_logging,NULL,0},
 +  {"database datasource",P_STRING,P_LOCAL,  &sDefault.database_datasource,NULL,0},
 +  {"database username",P_STRING,  P_LOCAL,  &sDefault.database_username,NULL,0},
@@ -672,13 +665,13 @@
 +  {"unique id method", P_STRING,  P_LOCAL,  &sDefault.unique_id_method,NULL,0},
 +  {"custom unique id select",P_STRING,P_LOCAL,&sDefault.custom_unique_id_select,NULL,0},
 +  {"get custom id before insert",P_BOOL,P_LOCAL,&sDefault.get_custom_id_before_insert,NULL,0},
    {"ignore errors",    P_BOOL,    P_LOCAL,  &sDefault.ignore_errors,NULL,0},
    {"log format",       P_STRING,  P_LOCAL,  &sDefault.log_format,  NULL,   0},
    {"refuse options",   P_STRING,  P_LOCAL,  &sDefault.refuse_options,NULL, 0},
-@@ -359,6 +392,17 @@ FN_LOCAL_BOOL(lp_read_only, read_only)
+@@ -363,6 +396,17 @@ FN_LOCAL_BOOL(lp_write_only, write_only)
  FN_LOCAL_BOOL(lp_list, list)
  FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
  FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
 +FN_LOCAL_BOOL(lp_database_logging, database_logging)
 +FN_LOCAL_STRING(lp_database_datasource, database_datasource)
 +FN_LOCAL_STRING(lp_database_username, database_username)
@@ -690,95 +683,53 @@
 +FN_LOCAL_STRING(lp_unique_id_method,unique_id_method)
 +FN_LOCAL_STRING(lp_custom_unique_id_select,custom_unique_id_select)
 +FN_LOCAL_BOOL(lp_get_custom_id_before_insert,get_custom_id_before_insert)
  FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
  FN_LOCAL_BOOL(lp_ignore_nonreadable, ignore_nonreadable)
  FN_LOCAL_STRING(lp_uid, uid)
---- log.c	20 Jan 2004 05:15:14 -0000	1.71
-+++ log.c	24 Apr 2004 08:14:38 -0000
+--- orig/log.c	2004-09-07 19:54:51
++++ log.c	2004-07-03 20:22:18
 @@ -75,7 +75,7 @@ struct {
  /*
   * Map from rsync error code to name, or return NULL.
   */
 -static char const *rerr_name(int code)
 +char const *rerr_name(int code)
  {
  	int i;
  	for (i = 0; rerr_names[i].name; i++) {
---- main.c	10 Feb 2004 03:54:47 -0000	1.192
-+++ main.c	24 Apr 2004 08:14:38 -0000
-@@ -120,6 +120,9 @@ static void report(int f)
+--- orig/main.c	2004-09-29 17:58:26
++++ main.c	2004-07-03 20:22:18
+@@ -136,6 +136,9 @@ static void report(int f)
  
  	if (am_daemon) {
  		log_exit(0, __FILE__, __LINE__);
 +#ifdef HAVE_LIBODBC
 +		db_log_exit(0,__FILE__,__LINE__);
 +#endif
- 		if (f == -1 || !am_sender) return;
+ 		if (f == -1 || !am_sender)
+ 			return;
  	}
- 
---- proto.h	22 Apr 2004 09:58:09 -0000	1.189
-+++ proto.h	24 Apr 2004 08:14:38 -0000
-@@ -51,6 +51,12 @@ int start_daemon(int f_in, int f_out);
- int daemon_main(void);
- void setup_protocol(int f_out,int f_in);
- int claim_connection(char *fname,int max_connections);
-+char *sanitizeSql(const char *input);
-+void db_log_open(void);
-+void db_log_close();
-+void db_log_session();
-+void db_log_transfer(struct file_struct *file,struct stats *initial_stats,char *operation);
-+void db_log_exit(int code, const char *file, int line);
- void free_exclude_list(struct exclude_list_struct *listp);
- int check_exclude(struct exclude_list_struct *listp, char *name, int name_is_dir);
- void add_exclude(struct exclude_list_struct *listp, const char *pattern,
-@@ -135,6 +141,17 @@ BOOL lp_read_only(int );
- BOOL lp_list(int );
- BOOL lp_use_chroot(int );
- BOOL lp_transfer_logging(int );
-+BOOL lp_database_logging(int );
-+char *lp_database_datasource(int );
-+char *lp_database_username(int );
-+char *lp_database_password(int );
-+char *lp_transfer_table_name(int );
-+char *lp_exit_table_name(int );
-+char *lp_session_table_name(int );
-+char *lp_sequence_name(int );
-+char *lp_unique_id_method(int );
-+char *lp_custom_unique_id_select(int );
-+BOOL lp_get_custom_id_before_insert(int );
- BOOL lp_ignore_errors(int );
- BOOL lp_ignore_nonreadable(int );
- char *lp_uid(int );
-@@ -156,6 +173,7 @@ int lp_max_connections(int );
- BOOL lp_load(char *pszFname, int globals_only);
- int lp_numservices(void);
- int lp_number(char *name);
-+char const *rerr_name(int code);
- void log_init(void);
- void log_open(void);
- void log_close(void);
---- receiver.c	23 Mar 2004 16:50:40 -0000	1.75
-+++ receiver.c	24 Apr 2004 08:14:39 -0000
-@@ -453,7 +453,9 @@ int recv_files(int f_in,struct file_list
- 		recv_ok = receive_data(f_in,mapbuf,fd2,fname,file->length);
+--- orig/receiver.c	2004-09-21 09:40:27
++++ receiver.c	2004-07-20 21:47:47
+@@ -546,6 +546,9 @@ int recv_files(int f_in, struct file_lis
+ 				       fname, fd2, file->length);
  
  		log_recv(file, &initial_stats);
--
 +#ifdef HAVE_LIBODBC
-+		db_log_transfer(file, &initial_stats,"receive");
++		db_log_transfer(file, &initial_stats, "receive");
 +#endif
- 		if (mapbuf) unmap_file(mapbuf);
- 		if (fd1 != -1) {
+ 
+ 		if (fd1 != -1)
  			close(fd1);
---- sender.c	17 Feb 2004 21:57:44 -0000	1.38
-+++ sender.c	24 Apr 2004 08:14:39 -0000
-@@ -283,6 +283,9 @@ void send_files(struct file_list *flist,
- 		} else  {
- 			match_sums(f_out, s, buf, st.st_size);
- 			log_send(file, &initial_stats);
+--- orig/sender.c	2004-09-20 05:10:48
++++ sender.c	2004-07-15 02:37:48
+@@ -239,6 +239,9 @@ void send_files(struct file_list *flist,
+ 
+ 		match_sums(f_out, s, mbuf, st.st_size);
+ 		log_send(file, &initial_stats);
 +#ifdef HAVE_LIBODBC
-+			db_log_transfer(file, &initial_stats,"send");
++		db_log_transfer(file, &initial_stats,"send");
 +#endif
- 		}
  
- 		if (!read_batch) {
+ 		if (mbuf) {
+ 			j = unmap_file(mbuf);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/openssl-support.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/openssl-support.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/openssl-support.diff	2004-04-26 02:39:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/openssl-support.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,10 +1,15 @@
------BEGIN PGP SIGNED MESSAGE-----
-Hash: SHA1
+After applying this patch, run these commands for a successful build:
 
-Hi.
+    autoconf
+    autoheader
+    ./configure
+    make proto
+    make
+
+Casey Marshall writes:
 
 I've been hacking together a way to use rsync with OpenSSL, and have
 attached my current patch against a recent CVS tree. The details of
 this implementation are:
 
   1. The SSL code is added as a "layer" that is forked into its own
@@ -28,76 +33,61 @@
 
   4. There are a number of details not implemented.
 
 All warnings apply; I don't do C programming all that often, so I
 can't say if I've left any cleanup/compatibility errors in the code.
 
-Also: <http://rsync.samba.org/lists.html> refers to the (now gone)
-smart-questions document on tuxedo.org, which should now be catb.org.
-
-Cheers,
-
-- -- 
-Casey Marshall || rsdio@metastatic.org
------BEGIN PGP SIGNATURE-----
-Version: GnuPG v1.2.1 (GNU/Linux)
-Comment: Processed by Mailcrypt 3.5.7 <http://mailcrypt.sourceforge.net/>
-
-iD8DBQE/ih9xgAuWMgRGsWsRAp8RAJ0XyONLiOSDgHHAOBRNO6sZ/P2dRwCeKfu8
-LEvhhkUglOm3xMyrdJT4u9Q=
-=aT/N
------END PGP SIGNATURE-----
 
---- Makefile.in	10 Feb 2004 17:06:11 -0000	1.98
-+++ Makefile.in	25 Apr 2004 18:37:22 -0000
+--- orig/Makefile.in	2004-08-13 07:18:58
++++ Makefile.in	2004-07-03 20:22:28
 @@ -39,7 +39,7 @@ OBJS3=progress.o pipe.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
  	popt/popthelp.o popt/poptparse.o
 -OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
 +OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@ @SSL_OBJS@
  
  TLS_OBJ = tls.o syscall.o lib/permstring.o
  
---- cleanup.c	27 Jan 2004 08:14:33 -0000	1.21
-+++ cleanup.c	25 Apr 2004 18:37:22 -0000
-@@ -87,6 +87,9 @@ void _exit_cleanup(int code, const char 
- 	int ocode = code;
- 	extern int keep_partial;
- 	extern int log_got_error;
+--- orig/cleanup.c	2004-07-29 16:08:03
++++ cleanup.c	2004-07-03 20:22:28
+@@ -24,6 +24,9 @@
+ extern int io_error;
+ extern int keep_partial;
+ extern int log_got_error;
 +#ifdef HAVE_OPENSSL
-+	extern int use_ssl;
++extern int use_ssl;
 +#endif
- 	static int inside_cleanup = 0;
  
- 	if (inside_cleanup > 10) {
+ /**
+  * Close all open sockets and files, allowing a (somewhat) graceful
 @@ -97,6 +100,11 @@ void _exit_cleanup(int code, const char 
- 
  	signal(SIGUSR1, SIG_IGN);
  	signal(SIGUSR2, SIG_IGN);
-+
+ 
 +#ifdef HAVE_OPENSSL
 +	if (use_ssl)
 +		end_tls();
 +#endif
- 
- 	if (verbose > 3)
- 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): entered\n", 
---- clientserver.c	14 Apr 2004 23:33:34 -0000	1.121
-+++ clientserver.c	25 Apr 2004 18:37:23 -0000
++
+ 	if (verbose > 3) {
+ 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): entered\n",
+ 			code, file, line);
+--- orig/clientserver.c	2004-08-02 02:29:16
++++ clientserver.c	2004-07-03 20:22:28
 @@ -46,6 +46,9 @@ extern int io_timeout;
  extern int orig_umask;
  extern int no_detach;
  extern int default_af_hint;
 +#ifdef HAVE_OPENSSL
 +extern int use_ssl;
 +#endif
  extern char *bind_address;
  extern struct exclude_list_struct server_exclude_list;
  extern char *exclude_path_prefix;
-@@ -93,8 +96,18 @@ int start_socket_client(char *host, char
+@@ -94,8 +97,18 @@ int start_socket_client(char *host, char
  		exit_cleanup(RERR_SOCKETIO);
  
  	ret = start_inband_exchange(user, path, fd, fd, argc);
 +	if (ret < 0)
 +		return ret;
 +
@@ -110,14 +100,14 @@
 +#endif
  
 -	return ret < 0? ret : client_run(fd, fd, -1, argc, argv);
 +	return client_run(fd, fd, -1, argc, argv);
  }
  
- int start_inband_exchange(char *user, char *path, int f_in, int f_out, int argc)
-@@ -145,6 +158,33 @@ int start_inband_exchange(char *user, ch
+ int start_inband_exchange(char *user, char *path, int f_in, int f_out, 
+@@ -150,6 +163,33 @@ int start_inband_exchange(char *user, ch
  	if (protocol_version > remote_protocol)
  		protocol_version = remote_protocol;
  
 +#ifdef HAVE_OPENSSL
 +	if (use_ssl) {
 +		io_printf(f_out, "#starttls\n");
@@ -145,78 +135,66 @@
 +	}
 +#endif
 +
  	p = strchr(path,'/');
  	if (p) *p = 0;
  	io_printf(f_out, "%s\n", path);
-@@ -172,6 +212,10 @@ int start_inband_exchange(char *user, ch
+@@ -178,6 +218,10 @@ int start_inband_exchange(char *user, ch
  			 * server to terminate the listing of modules.
  			 * We don't want to go on and transfer
  			 * anything; just exit. */
 +#ifdef HAVE_OPENSSL
 +			if (use_ssl)
 +				end_tls();
 +#endif
  			exit(0);
  		}
  
-@@ -179,6 +223,10 @@ int start_inband_exchange(char *user, ch
- 			rprintf(FERROR,"%s\n", line);
+@@ -185,6 +229,10 @@ int start_inband_exchange(char *user, ch
+ 			rprintf(FERROR, "%s\n", line);
  			/* This is always fatal; the server will now
  			 * close the socket. */
 +#ifdef HAVE_OPENSSL
 +			if (use_ssl)
 +				end_tls();
 +#endif
  			return RERR_STARTCLIENT;
  		} else {
  			rprintf(FINFO,"%s\n", line);
-@@ -485,6 +533,7 @@ static void send_listing(int fd)
+@@ -497,6 +545,7 @@ static void send_listing(int fd)
  		io_printf(fd,"@RSYNCD: EXIT\n");
  }
  
 +
  /* this is called when a connection is established to a client
     and we want to start talking. The setup of the system is done from
     here */
-@@ -543,6 +592,20 @@ int start_daemon(int f_in, int f_out)
- 			send_listing(f_out);
- 			return -1;
- 		}
-+
+@@ -555,6 +604,20 @@ int start_daemon(int f_in, int f_out)
+ 		return -1;
+ 	}
+ 
 +#if HAVE_OPENSSL
-+		if (use_ssl && strcmp(line, "#starttls") == 0) {
-+			io_printf(f_out, "@RSYNCD: starttls\n");
-+			if (start_tls(f_in, f_out)) {
-+				rprintf(FLOG, "SSL connection failed: %s\n",
-+					get_ssl_error());
-+				return -1;
-+			}
-+			f_in = get_tls_rfd();
-+			f_out = get_tls_wfd();
-+			continue;
++	if (use_ssl && strcmp(line, "#starttls") == 0) {
++		io_printf(f_out, "@RSYNCD: starttls\n");
++		if (start_tls(f_in, f_out)) {
++			rprintf(FLOG, "SSL connection failed: %s\n",
++				get_ssl_error());
++			return -1;
 +		}
++		f_in = get_tls_rfd();
++		f_out = get_tls_wfd();
++		continue;
++	}
 +#endif
- 
- 		if (*line == '#') {
- 			/* it's some sort of command that I don't understand */
---- config.h.in	9 Apr 2004 18:09:30 -0000	1.89
-+++ config.h.in	25 Apr 2004 18:37:23 -0000
-@@ -167,6 +167,9 @@
- /* */
- #undef HAVE_OFF64_T
- 
-+/* true if you want to use SSL. */
-+#undef HAVE_OPENSSL
-+
- /* Define to 1 if you have the `readlink' function. */
- #undef HAVE_READLINK
- 
---- configure.in	17 Apr 2004 18:40:16 -0000	1.191
-+++ configure.in	25 Apr 2004 18:37:23 -0000
-@@ -266,6 +266,21 @@ yes
++
+ 	if (*line == '#') {
+ 		/* it's some sort of command that I don't understand */
+ 		io_printf(f_out, "@ERROR: Unknown command '%s'\n", line);
+--- orig/configure.in	2004-09-23 17:42:07
++++ configure.in	2004-07-03 20:22:28
+@@ -271,6 +271,21 @@ yes
  	AC_SEARCH_LIBS(getaddrinfo, inet6)
  fi
  
 +AC_ARG_ENABLE(openssl,
 +              AC_HELP_STRING([--enable-openssl], [compile SSL support with OpenSSL.]))
 +
@@ -232,36 +210,36 @@
 +	fi
 +fi
 +
  AC_MSG_CHECKING([whether to call shutdown on all sockets])
  case $host_os in
  	*cygwin* ) AC_MSG_RESULT(yes)
---- main.c	10 Feb 2004 03:54:47 -0000	1.192
-+++ main.c	25 Apr 2004 18:37:23 -0000
-@@ -51,6 +51,9 @@ extern int rsync_port;
- extern int read_batch;
- extern int write_batch;
+--- orig/main.c	2004-09-29 17:58:26
++++ main.c	2004-07-15 02:40:51
+@@ -56,6 +56,9 @@ extern int write_batch;
+ extern int batch_fd;
+ extern int batch_gen_fd;
  extern int filesfrom_fd;
 +#ifdef HAVE_OPENSSL
 +extern int use_ssl;
 +#endif
  extern pid_t cleanup_child_pid;
  extern char *files_from;
  extern char *remote_filesfrom_file;
-@@ -701,17 +704,32 @@ static int start_client(int argc, char *
+@@ -771,18 +774,32 @@ static int start_client(int argc, char *
  	pid_t pid;
  	int f_in,f_out;
  	int rc;
 +	int url_prefix = strlen(URL_PREFIX);
  
  	/* Don't clobber argv[] so that ps(1) can still show the right
  	 * command line. */
  	if ((rc = copy_argv(argv)))
  		return rc;
  
-+	if (strncasecmp(URL_PREFIX, argv[0], url_prefix) != 0) {
++	if (strncasecmp(URL_PREFIX, argv[0], url_prefix) != 0 && !read_batch) {
 +#ifdef HAVE_OPENSSL
 +		url_prefix = strlen(SSL_URL_PREFIX);
 +		if (strncasecmp(SSL_URL_PREFIX, argv[0], url_prefix) != 0)
 +			url_prefix = 0;
 +		else {
 +			if (!use_ssl)
@@ -270,24 +248,25 @@
 +		}
 +#else
 +		url_prefix = 0;
 +#endif
 +	}
  	/* rsync:// always uses rsync server over direct socket connection */
--	if (strncasecmp(URL_PREFIX, argv[0], strlen(URL_PREFIX)) == 0) {
+-	if (strncasecmp(URL_PREFIX, argv[0], strlen(URL_PREFIX)) == 0
+-	    && !read_batch) {
 +	if (url_prefix) {
  		char *host, *path;
  
 -		host = argv[0] + strlen(URL_PREFIX);
 +		host = argv[0] + url_prefix;
  		p = strchr(host,'/');
  		if (p) {
- 			*p = 0;
-@@ -760,12 +778,27 @@ static int start_client(int argc, char *
+ 			*p = '\0';
+@@ -835,12 +852,27 @@ static int start_client(int argc, char *
  			argv++;
- 		} else {
+ 		} else { /* source is local */
  			am_sender = 1;
 +			url_prefix = strlen(URL_PREFIX);
 +			if (strncasecmp(URL_PREFIX, argv[0], url_prefix) != 0) {
 +#ifdef HAVE_OPENSSL
 +				url_prefix = strlen(SSL_URL_PREFIX);
 +				if (strncasecmp(SSL_URL_PREFIX, argv[0], url_prefix) != 0)
@@ -308,176 +287,154 @@
  				char *host, *path;
  
 -				host = argv[argc-1] + strlen(URL_PREFIX);
 +				host = argv[argc-1] + url_prefix;
  				p = strchr(host,'/');
  				if (p) {
- 					*p = 0;
---- options.c	17 Apr 2004 17:07:23 -0000	1.147
-+++ options.c	25 Apr 2004 18:37:24 -0000
-@@ -130,6 +130,14 @@ int quiet = 0;
+ 					*p = '\0';
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-07-16 20:19:50
+@@ -135,6 +135,14 @@ int quiet = 0;
  int always_checksum = 0;
  int list_only = 0;
  
 +#ifdef HAVE_OPENSSL
 +int use_ssl = 0;
 +char *ssl_cert_path = NULL;
 +char *ssl_key_path = NULL;
 +char *ssl_key_passwd = NULL;
 +char *ssl_ca_path = NULL;
 +#endif
 +
- #define FIXED_CHECKSUM_SEED 32761
- #define MAX_BATCH_PREFIX_LEN 256	/* Must be less than MAXPATHLEN-13 */
- char *batch_prefix = NULL;
-@@ -142,13 +150,13 @@ static int modify_window_set;
-  * address, or a hostname. **/
- char *bind_address;
- 
--
- static void print_rsync_version(enum logcode f)
- {
- 	char const *got_socketpair = "no ";
+ #define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
+ char *batch_name = NULL;
+ 
+@@ -154,6 +162,7 @@ static void print_rsync_version(enum log
  	char const *hardlinks = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
 +	char const *ssl = "no ";
  	STRUCT_STAT *dumstat;
  
  #ifdef HAVE_SOCKETPAIR
-@@ -167,6 +175,10 @@ static void print_rsync_version(enum log
+@@ -176,6 +185,10 @@ static void print_rsync_version(enum log
  	ipv6 = "";
  #endif
  
 +#ifdef HAVE_OPENSSL
 +	ssl = "";
 +#endif
 +
  	rprintf(f, "%s  version %s  protocol version %d\n",
  		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
  	rprintf(f,
-@@ -180,10 +192,10 @@ static void print_rsync_version(enum log
+@@ -189,10 +202,10 @@ static void print_rsync_version(enum log
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
  	 * macros. */
--	rprintf(f, "              %sIPv6, %d-bit system inums, %d-bit internal inums\n",
-+	rprintf(f, "              %sIPv6, %d-bit system inums, %d-bit internal inums, %sssl\n",
- 		ipv6,
+-	rprintf(f, "              %sinplace, %sIPv6, %d-bit system inums, %d-bit internal inums\n",
++	rprintf(f, "              %sinplace, %sIPv6, %d-bit system inums, %d-bit internal inums, %sssl\n",
+ 		have_inplace, ipv6,
  		(int) (sizeof dumstat->st_ino * 8),
 -		(int) (sizeof (uint64) * 8));
 +		(int) (sizeof (uint64) * 8), ssl);
  #ifdef MAINTAINER_MODE
  	rprintf(f, "              panic action: \"%s\"\n",
  		get_panic_action());
-@@ -295,6 +307,13 @@ void usage(enum logcode F)
-   rprintf(F," -4                          prefer IPv4\n");
-   rprintf(F," -6                          prefer IPv6\n");
+@@ -308,6 +321,13 @@ void usage(enum logcode F)
+   rprintf(F," -4, --ipv4                  prefer IPv4\n");
+   rprintf(F," -6, --ipv6                  prefer IPv6\n");
  #endif
 +#ifdef HAVE_OPENSSL
 +  rprintf(F,"     --ssl                   allow socket connections to use SSL\n");
 +  rprintf(F,"     --ssl-cert=FILE         path to server's SSL certificate\n");
 +  rprintf(F,"     --ssl-key=FILE          path to server's SSL private key\n");
 +  rprintf(F,"     --ssl-key-passwd=PASS   password for PEM-encoded private key\n");
 +  rprintf(F,"     --ssl-ca-certs=FILE     path to trusted CA certificates\n");
 +#endif
+   rprintf(F," -h, --help                  show this help screen\n");
  
    rprintf(F,"\n");
- 
-@@ -305,7 +324,7 @@ void usage(enum logcode F)
+@@ -319,7 +339,7 @@ void usage(enum logcode F)
  enum {OPT_VERSION = 1000, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
        OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_LINK_DEST,
        OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
--      OPT_READ_BATCH, OPT_WRITE_BATCH,
-+      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_USE_SSL,
+-      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT,
++      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT, OPT_USE_SSL,
        OPT_REFUSED_BASE = 9000};
  
  static struct poptOption long_options[] = {
-@@ -390,6 +409,13 @@ static struct poptOption long_options[] 
-   {0,		      '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
-   {0,		      '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
+@@ -408,6 +428,13 @@ static struct poptOption long_options[] 
+   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
+   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
  #endif
 +#ifdef HAVE_OPENSSL
 +  {"ssl",              0,  POPT_ARG_NONE,   0,               OPT_USE_SSL, 0, 0},
 +  {"ssl-cert",         0,  POPT_ARG_STRING, &ssl_cert_path,  OPT_USE_SSL, 0, 0},
 +  {"ssl-key",          0,  POPT_ARG_STRING, &ssl_key_path,   OPT_USE_SSL, 0, 0},
 +  {"ssl-key-passwd",   0,  POPT_ARG_STRING, &ssl_key_passwd, OPT_USE_SSL, 0, 0},
 +  {"ssl-ca-certs",     0,  POPT_ARG_STRING, &ssl_ca_path,    OPT_USE_SSL, 0, 0},
 +#endif
    {0,0,0,0, 0, 0, 0}
  };
  
-@@ -584,6 +610,12 @@ int parse_arguments(int *argc, const cha
+@@ -616,6 +643,12 @@ int parse_arguments(int *argc, const cha
  			return 0;
  #endif
  
 +		case OPT_USE_SSL:
 +#ifdef HAVE_OPENSSL
 +			use_ssl = 1;
 +#endif
 +			break;
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off (opt-BASE is its index). */
-@@ -722,6 +754,17 @@ int parse_arguments(int *argc, const cha
- 
+@@ -807,6 +840,17 @@ int parse_arguments(int *argc, const cha
  	if (do_progress && !verbose)
  		verbose = 1;
-+
+ 
 +#ifdef HAVE_OPENSSL
 +	if (use_ssl) {
 +		if (init_tls()) {
 +			snprintf(err_buf, sizeof(err_buf),
 +				 "Openssl error: %s\n",
 +				 get_ssl_error());
 +			return 0;
 +		}
 +	}
 +#endif
- 
- 	if (files_from) {
- 		char *colon;
---- proto.h	22 Apr 2004 09:58:09 -0000	1.189
-+++ proto.h	25 Apr 2004 18:37:24 -0000
-@@ -209,6 +209,12 @@ void start_accept_loop(int port, int (*f
- void set_socket_options(int fd, char *options);
- void become_daemon(void);
- int sock_exec(const char *prog);
-+int init_tls(void);
-+char *get_ssl_error(void);
-+int get_tls_rfd(void);
-+int get_tls_wfd(void);
-+int start_tls(int f_in, int f_out);
-+void end_tls(void);
- int do_unlink(char *fname);
- int do_symlink(char *fname1, char *fname2);
- int do_link(char *fname1, char *fname2);
---- rsync.h	22 Apr 2004 09:58:24 -0000	1.198
-+++ rsync.h	25 Apr 2004 18:37:24 -0000
++
+ 	if (bwlimit) {
+ 		bwlimit_writemax = (size_t)bwlimit * 128;
+ 		if (bwlimit_writemax < 512)
+--- orig/rsync.h	2004-09-22 08:47:31
++++ rsync.h	2004-07-03 20:22:28
 @@ -32,6 +32,7 @@
  
  #define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
  #define URL_PREFIX "rsync://"
 +#define SSL_URL_PREFIX "rsyncs://"
  
  #define BACKUP_SUFFIX "~"
  
-@@ -321,6 +322,11 @@ enum msgcode {
- #else
- /* As long as it gets... */
+@@ -330,6 +331,11 @@ enum msgcode {
  #define uint64 unsigned off_t
-+#endif
-+
+ #endif
+ 
 +#if HAVE_OPENSSL
 +#include <openssl/ssl.h>
 +#include <openssl/err.h>
- #endif
- 
++#endif
++
  /* Starting from protocol version 26, we always use 64-bit
---- /dev/null	1 Jan 1970 00:00:00 -0000
-+++ ssl.c	25 Apr 2004 18:37:24 -0000
+  * ino_t and dev_t internally, even if this platform does not
+  * allow files to have 64-bit inums.  That's because the
+--- orig/ssl.c	2004-07-02 21:44:19
++++ ssl.c	2004-07-02 21:44:19
 @@ -0,0 +1,366 @@
 +/* -*- c-file-style: "linux" -*-
 + * ssl.c: operations for negotiating SSL rsync connections. 
 + *
 + * Copyright (C) 2003  Casey Marshall <rsdio@metastatic.org>
 + *
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: owner-group-mod.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches: param-port.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches: rusty-fuzzy.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/soften-links.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/soften-links.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/soften-links.diff	2004-04-23 07:56:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/soften-links.diff	2004-08-12 08:09:18.000000000 +0800
@@ -6,14 +6,14 @@
 I run one of the debian mirrors, and I had to write this patch because
 my archive is split between more than one disk. Would you accept a more
 polished version of this patch for inclusion in rsync?
 
 [Updated to latest CVS source by Wayne Davison.]
 
---- syscall.c	18 Feb 2004 22:33:21 -0000	1.30
-+++ syscall.c	22 Apr 2004 23:48:45 -0000
+--- orig/syscall.c	2004-08-02 21:56:59
++++ syscall.c	2004-04-22 23:48:45
 @@ -58,9 +58,14 @@ int do_symlink(char *fname1, char *fname
  #if HAVE_LINK
  int do_link(char *fname1, char *fname2)
  {
 +	int st;
 +
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/time-limit.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/time-limit.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/time-limit.diff	2004-04-27 11:04:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/time-limit.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,22 +1,22 @@
 John Taylor's patch for implementing --time-limit and --stop-at, reworked
 to be simpler and more efficient by Wayne Davison.
 
-Do we need configure support for mktime() and strptime()?
+Do we need configure support for mktime()?
 
---- io.c	16 Jan 2004 16:31:47 -0000	1.119
-+++ io.c	27 Apr 2004 02:56:33 -0000
-@@ -44,6 +44,7 @@ static int io_multiplexing_in;
- static int multiplex_in_fd = -1;
- static int multiplex_out_fd = -1;
- static time_t last_io;
+--- orig/io.c	2004-08-02 02:44:26
++++ io.c	2004-07-17 15:28:36
+@@ -49,6 +49,7 @@ extern int am_sender;
+ extern int eol_nulls;
+ extern int checksum_seed;
+ extern int protocol_version;
 +extern time_t stop_at_utime;
- static int no_flush;
+ extern char *remote_filesfrom_file;
+ extern struct stats stats;
  
- extern int bwlimit;
-@@ -125,15 +126,20 @@ static void check_timeout(void)
+@@ -135,17 +136,22 @@ static void check_timeout(void)
  {
  	time_t t;
  
 -	if (!io_timeout)
 +	if (!io_timeout && !stop_at_utime)
  		return;
@@ -30,76 +30,69 @@
 +
  	if (!last_io) {
 -		last_io = time(NULL);
 +		last_io = t;
  		return;
  	}
--
--	t = time(NULL);
  
- 	if (last_io && io_timeout && (t-last_io) >= io_timeout) {
+-	t = time(NULL);
+-
+-	if (t - last_io >= io_timeout) {
++	if (io_timeout && t - last_io >= io_timeout) {
  		if (!am_server && !am_daemon) {
---- options.c	17 Apr 2004 17:07:23 -0000	1.147
-+++ options.c	27 Apr 2004 02:56:33 -0000
-@@ -92,6 +92,7 @@ int modify_window = 0;
- int blocking_io = -1;
+ 			rprintf(FERROR, "io timeout after %d seconds - exiting\n",
+ 				(int)(t-last_io));
+--- orig/options.c	2004-09-23 17:42:07
++++ options.c	2004-07-15 17:06:09
+@@ -96,6 +96,7 @@ int blocking_io = -1;
  int checksum_seed = 0;
+ int inplace = 0;
  unsigned int block_size = 0;
 +time_t stop_at_utime = 0;
  
  
  /** Network address family. **/
-@@ -288,6 +289,8 @@ void usage(enum logcode F)
+@@ -301,6 +302,8 @@ void usage(enum logcode F)
    rprintf(F,"     --log-format=FORMAT     log file transfers using specified format\n");
    rprintf(F,"     --password-file=FILE    get password from FILE\n");
    rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth, KBytes per second\n");
-+  rprintf(F,"     --stop-at=YY-MM-DD@HH:MM Stop rsync at year-month-day@hour:minute\n");
-+  rprintf(F,"     --time-limit=TIME       Stop rsync after TIME minutes have elapsed\n");
-   rprintf(F,"     --write-batch=PREFIX    write batch fileset starting with PREFIX\n");
-   rprintf(F,"     --read-batch=PREFIX     read batch fileset starting with PREFIX\n");
-   rprintf(F," -h, --help                  show this help screen\n");
-@@ -305,7 +308,7 @@ void usage(enum logcode F)
- enum {OPT_VERSION = 1000, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
++  rprintf(F,"     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute\n");
++  rprintf(F,"     --time-limit=MINS       Stop rsync after MINS minutes have elapsed\n");
+   rprintf(F,"     --write-batch=FILE      write a batch to FILE\n");
+   rprintf(F,"     --read-batch=FILE       read a batch from FILE\n");
+   rprintf(F,"     --checksum-seed=NUM     set block/file checksum seed\n");
+@@ -320,6 +323,7 @@ enum {OPT_VERSION = 1000, OPT_SENDER, OP
        OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_LINK_DEST,
        OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
--      OPT_READ_BATCH, OPT_WRITE_BATCH,
-+      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_STOP_AT, OPT_TIME_LIMIT,
+       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT,
++      OPT_STOP_AT, OPT_TIME_LIMIT,
        OPT_REFUSED_BASE = 9000};
  
  static struct poptOption long_options[] = {
-@@ -377,6 +380,8 @@ static struct poptOption long_options[] 
+@@ -394,6 +398,8 @@ static struct poptOption long_options[] 
    {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
    {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
    {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
 +  {"stop-at",          0,  POPT_ARG_STRING, 0, OPT_STOP_AT, 0, 0 },
 +  {"time-limit",       0,  POPT_ARG_STRING, 0, OPT_TIME_LIMIT, 0, 0 },
    {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
    {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
    {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
-@@ -471,6 +476,7 @@ int parse_arguments(int *argc, const cha
- {
- 	int opt;
- 	char *ref = lp_refuse_options(module_id);
-+	struct tm stop_at_tm;
- 	const char *arg;
- 	poptContext pc;
- 
-@@ -584,6 +590,37 @@ int parse_arguments(int *argc, const cha
+@@ -616,6 +622,36 @@ int parse_arguments(int *argc, const cha
  			return 0;
  #endif
  
 +		case OPT_STOP_AT:
 +			arg = poptGetOptArg(pc);
-+			if (!strptime(arg, "%y-%m-%d@%H:%M", &stop_at_tm)) {
++			if ((stop_at_utime = parse_time(arg)) == (time_t)-1) {
 +				snprintf(err_buf, sizeof err_buf,
 +				    "invalid --stop-at format: %s\n",
 +				    arg);
 +				rprintf(FERROR, "ERROR: %s", err_buf);
 +				return 0;
 +			}
-+			stop_at_utime = mktime(&stop_at_tm);
 +			if (stop_at_utime < time(NULL)) {
 +				snprintf(err_buf, sizeof err_buf,
 +				    "--stop-at time is in the past: %s\n",
 +				    arg);
 +				rprintf(FERROR, "ERROR: %s", err_buf);
 +				return 0;
@@ -118,47 +111,188 @@
 +			stop_at_utime += time(NULL);
 +			break;
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off (opt-BASE is its index). */
-@@ -881,6 +918,15 @@ void server_options(char **args,int *arg
+@@ -1005,6 +1041,15 @@ void server_options(char **args,int *arg
+ 		args[ac++] = arg;
+ 	}
  
- 	if (bwlimit) {
- 		if (asprintf(&arg, "--bwlimit=%d", bwlimit) < 0)
-+			goto oom;
-+		args[ac++] = arg;
-+	}
-+
 +	if (stop_at_utime) {
 +		long mins = (stop_at_utime - time(NULL)) / 60;
 +		if (mins <= 0)
 +			mins = 1;
 +		if (asprintf(&arg, "--time-limit=%ld", mins) < 0)
- 			goto oom;
- 		args[ac++] = arg;
- 	}
---- rsync.yo	24 Apr 2004 06:16:04 -0000	1.164
-+++ rsync.yo	27 Apr 2004 02:56:35 -0000
-@@ -346,6 +346,8 @@ verb(
++			goto oom;
++		args[ac++] = arg;
++	}
++
+ 	if (backup_dir) {
+ 		args[ac++] = "--backup-dir";
+ 		args[ac++] = backup_dir;
+--- orig/rsync.yo	2004-09-24 16:42:30
++++ rsync.yo	2004-07-15 02:44:40
+@@ -378,6 +378,8 @@ verb(
       --log-format=FORMAT     log file transfers using specified format
       --password-file=FILE    get password from FILE
       --bwlimit=KBPS          limit I/O bandwidth, KBytes per second
-+     --stop-at=YY-MM-DD@HH:MM Stop rsync at year-month-day@hour:minute
-+     --time-limit=TIME       Stop rsync after TIME minutes have elapsed
-      --write-batch=PREFIX    write batch fileset starting with PREFIX
-      --read-batch=PREFIX     read batch fileset starting with PREFIX
-  -h, --help                  show this help screen
-@@ -888,6 +890,13 @@ of rsync transfers, blocks of data are s
- transfer was too fast, it will wait before sending the next data block. The
++     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute
++     --time-limit=MINS       Stop rsync after MINS minutes have elapsed
+      --write-batch=FILE      write a batch to FILE 
+      --read-batch=FILE       read a batch from FILE
+      --checksum-seed=NUM     set block/file checksum seed
+@@ -1001,6 +1003,19 @@ transfer was too fast, it will wait befo
  result is an average transfer rate equaling the specified limit. A value
  of zero specifies no limit.
+ 
++dit(bf(--stop-at=y-m-dTh:m)) This option allows you to specify at what
++time to stop rsync, in year-month-dayThour:minute numeric format (e.g.
++2004-12-31T23:59).  You can specify a 2 or 4-digit year.  You can also
++leave off various items and the result will be the next possible time
++that matches the specified data.  For example, "1-30" specifies the next
++January 30th (at midnight), "04:00" specifies the next 4am, "1"
++specifies the next 1st of the month at midnight, and ":59" specifies the
++next 59th minute after the hour.  If you prefer, you may separate the
++date numbers using slashes instead of dashes.
 +
-+dit(bf(--stop-at=YY-MM-DD@HH:MM)) This option allows you to specify at what
-+time to stop rsync, in year-month-day@hour:minute numeric format (e.g.
-+04-12-3l@23:59).
-+
-+dit(bf(--time-limit=TIME)) This option allows you to specify the maximum
++dit(bf(--time-limit=MINS)) This option allows you to specify the maximum
 +number of minutes rsync will run for.
++
+ dit(bf(--write-batch=FILE)) Record a file that can later be applied to
+ another identical destination with --read-batch. See the "BATCH MODE"
+ section for details.
+--- orig/util.c	2004-09-07 21:45:30
++++ util.c	2004-07-03 20:23:22
+@@ -126,6 +126,132 @@ void overflow(char *str)
+ 	exit_cleanup(RERR_MALLOC);
+ }
+ 
++/* Allow the user to specify a time in the format yyyy-mm-ddThh:mm while
++ * also allowing abbreviated data.  For instance, if the time is omitted,
++ * it defaults to midnight.  If the date is omitted, it defaults to the
++ * next possible date in the future with the specified time.  Even the
++ * year or year-month can be omitted, again defaulting to the next date
++ * in the future that matches the specified information.  A 2-digit year
++ * is also OK, as is using '/' instead of '-'. */
++time_t parse_time(const char *arg)
++{
++	const char *cp;
++	time_t val, now = time(NULL);
++	struct tm t, *today = localtime(&now);
++	int in_date, n;
++
++	memset(&t, 0, sizeof t);
++	t.tm_year = t.tm_mon = t.tm_mday = -1;
++	t.tm_hour = t.tm_min = t.tm_isdst = -1;
++	cp = arg;
++	if (*cp == 'T' || *cp == 't' || *cp == ':') {
++		cp++;
++		in_date = 0;
++	} else
++		in_date = 1;
++	for ( ; ; cp++) {
++		if (!isdigit(*cp))
++			return -1;
++
++		n = 0;
++		do {
++			n = n * 10 + *cp++ - '0';
++		} while (isdigit(*cp));
++
++		if (*cp == ':')
++			in_date = 0;
++		if (in_date) {
++			if (t.tm_year != -1)
++				return -1;
++			t.tm_year = t.tm_mon;
++			t.tm_mon = t.tm_mday;
++			t.tm_mday = n;
++			if (!*cp)
++				break;
++			if (*cp == 'T' || *cp == 't') {
++				if (!cp[1])
++					break;
++				in_date = 0;
++			} else if (*cp != '-' && *cp != '/')
++				return -1;
++			continue;
++		}
++		if (t.tm_hour != -1)
++			return -1;
++		t.tm_hour = t.tm_min;
++		t.tm_min = n;
++		if (!*cp)
++			break;
++		if (*cp != ':')
++			return -1;
++	}
++
++	in_date = 0;
++	if (t.tm_year < 0) {
++		t.tm_year = today->tm_year;
++		in_date = 1;
++	} else if (t.tm_year < 100) {
++		while (t.tm_year < today->tm_year)
++			t.tm_year += 100;
++	} else
++		t.tm_year -= 1900;
++	if (t.tm_mon < 0) {
++		t.tm_mon = today->tm_mon;
++		in_date = 2;
++	} else
++		t.tm_mon--;
++	if (t.tm_mday < 0) {
++		t.tm_mday = today->tm_mday;
++		in_date = 3;
++	}
++
++	n = 0;
++	if (t.tm_min < 0) {
++		t.tm_hour = t.tm_min = 0;
++	} else if (t.tm_hour < 0) {
++		if (in_date != 3)
++			return -1;
++		in_date = 0;
++		t.tm_hour = today->tm_hour;
++		n = 60*60;
++	}
++
++	if (t.tm_hour > 23 || t.tm_min > 59
++	    || t.tm_mon < 0 || t.tm_mon >= 12
++	    || t.tm_mday < 1 || t.tm_mday > 31
++	    || (val = mktime(&t)) == (time_t)-1)
++		return -1;
++
++	if (val <= now && in_date) {
++	    tweak_date:
++		switch (in_date) {
++		case 3:
++			t.tm_mday++;
++			break;
++		case 2:
++			if (++t.tm_mon == 12)
++				t.tm_mon = 0;
++			else
++				break;
++		case 1:
++			t.tm_year++;
++			break;
++		}
++		if ((val = mktime(&t)) == (time_t)-1) {
++			if (in_date == 3 && t.tm_mday > 28) {
++				t.tm_mday = 1;
++				in_date = 2;
++				goto tweak_date;
++			}
++			return -1;
++		}
++	}
++	if (n) {
++		while (val <= now)
++			val += n;
++	}
++	return val;
++}
+ 
  
- dit(bf(--write-batch=PREFIX)) Generate a set of files that can be
- transferred as a batch update. Each filename in the set starts with
+ int set_modtime(char *fname, time_t modtime)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/tru64.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/tru64.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/tru64.diff	2004-02-24 03:02:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/tru64.diff	2004-10-01 00:32:37.000000000 +0800
@@ -1,56 +1,12 @@
+Depends-On-Patch: mkfifo.diff
+
 This is an adapted version of the original by Zoong Pham.
 
---- rsync.h	11 Feb 2004 08:01:21 -0000	1.186
-+++ rsync.h	23 Feb 2004 18:56:02 -0000
-@@ -156,6 +156,11 @@ enum msgcode {
- #include <sys/socket.h>
- #endif
- 
-+#ifdef HAVE_SYS_UN_H
-+#define _SOCKADDR_LEN
-+#include <sys/un.h>
-+#endif
-+
- #ifdef HAVE_STRING_H
- #include <string.h>
- #endif
---- syscall.c	18 Feb 2004 22:33:21 -0000	1.30
-+++ syscall.c	23 Feb 2004 18:56:02 -0000
-@@ -76,6 +76,29 @@ int do_mknod(char *pathname, mode_t mode
- {
- 	if (dry_run) return 0;
- 	RETURN_ERROR_IF_RO_OR_LO;
-+# if HAVE_MKFIFO
-+	if (S_ISFIFO(mode))
-+		return mkfifo(pathname, mode);
-+# endif
-+# if HAVE_SYS_UN_H
-+	if (S_ISSOCK(mode)) {
-+		int sock;
-+		struct sockaddr_un saddr;
-+		int len = strlen(pathname) + 1; /* include null */
-+
-+		saddr.sun_family = AF_UNIX;
-+		strncpy(saddr.sun_path, pathname, sizeof saddr.sun_path);
-+		saddr.sun_len = len > sizeof saddr.sun_path ? sizeof saddr.sun_path: len;
-+
-+		if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0)
-+			return -1;
-+		unlink(pathname);
-+		if ((bind(sock, (struct sockaddr*)&saddr, sizeof saddr)) < 0)
-+			return -1;
-+		close(sock);
-+		return do_chmod(pathname, mode);
-+	}
-+# endif
- 	return mknod(pathname, mode, dev);
- }
- #endif
---- lib/getaddrinfo.c	10 Jan 2003 22:38:25 -0000	1.17
-+++ lib/getaddrinfo.c	23 Feb 2004 18:56:02 -0000
+--- orig/lib/getaddrinfo.c	2004-03-16 01:26:36
++++ lib/getaddrinfo.c	2004-06-18 17:38:35
 @@ -41,6 +41,20 @@
  
  #include <rsync.h>
  
 +/****** Start Zoong added here */
 +
@@ -66,6 +22,16 @@
 +/****** End Zoong added here */
 +
 +
  #if defined(__KAME__) && defined(INET6)
  # define FAITH
  #endif
+--- orig/syscall.c	2004-09-23 05:46:46
++++ syscall.c	2004-09-23 18:11:06
+@@ -27,6 +27,7 @@
+ #include "rsync.h"
+ 
+ #if HAVE_SYS_UN_H
++#define _SOCKADDR_LEN
+ #include <sys/un.h>
+ #endif
+ 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/verify-patches /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/verify-patches
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches/verify-patches	2004-04-25 04:14:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/patches/verify-patches	2004-09-24 02:09:39.000000000 +0800
@@ -1,98 +1,246 @@
-#!/bin/sh
+#!/usr/bin/perl
 
-[ -d patches ] && cd patches
+use strict;
 
-if [ ! -f verify-patches ]; then
-    echo "Please run this script from the root of the rsync dir"
-    echo "or from inside the patches subdir."
-    exit 1
-fi
-
-root=`cat ../CVS/Root`
-tmpdir=,tmp-for-patch-tests
-
-[ -d $tmpdir ] || mkdir $tmpdir
-cd $tmpdir || exit 1
-
-[ -d workdir ] || mkdir workdir
-echo "Using CVS to update the $tmpdir/cvsdir copy of the source."
-cvs -d "$root" co -d cvsdir rsync
-
-cd workdir || exit 1
-
-if [ -z "$1" ]; then
-    set -- ../../*.diff
-fi
-
-for xx in "${@}"; do
-    case "$xx" in
-    *gzip-rsyncable.diff) continue ;;
-    patches/*) xx=`echo $xx | sed 's:patches:../..:'` ;;
-    */*.diff) ;;
-    *.diff) xx=../../$xx ;;
-    *) continue ;;
-    esac
-    apply=y
-    while : ; do
-	echo -e "\n----------- $xx ------------"
-	if [ $apply = y ]; then
-	    rsync -a --delete ../cvsdir/ .
-	    patch -p0 <$xx | tee ,patch.output
-	    new=''
-	    for nn in `sed -n 's/^patching file //p' ,patch.output`; do
-		[ -f ../cvsdir/$nn ] || new="$new $nn"
-	    done
-	    if grep "^Hunk #[0-9]* FAILED" ,patch.output >/dev/null; then
-		default=F
-	    elif grep "^Hunk #[0-9]* succeeded" ,patch.output >/dev/null; then
-		default=E
-	    else
-		default=N
-	    fi
-	    apply=n
-	fi
-	echo -e "\nFix rejects, Make proto, Edit both diffs, Update patch,"
-	echo -n "Apply patch again, Next, Quit: [$default] "
-	read ans
-	[ -z "$ans" ] && ans=$default
-	case "$ans" in
-	[Ee]*)
-	    [ ! -z "$new" ] && cvs add $new
-	    new=''
-	    rm -f *.rej *.orig
-	    sed '/^--- /,$ d' $xx >,new.patch
-	    cvs diff -N | egrep -v '^(diff -|===============|RCS file: |retrieving revision |Index: )' >>,new.patch
-	    vim -d $xx ,new.patch
-	    default=U
-	    ;;
-	[Ff]*)
-	    vim *.rej
-	    default=E
-	    ;;
-	[Mm]*)
-	    cat *.c lib/compat.c | awk -f mkproto.awk >proto.h
-	    echo -e "\nRegenerated proto.h"
-	    default=E
-	    ;;
-	[Uu]*)
-	    if [ -f ,new.patch ]; then
-		cp -p ,new.patch $xx
-		echo -e "\nCopied ,new.patch to $xx"
-		default=A
-	    else
-		echo -e "\n*** Edit the diffs first. ***"
-		default=E
-	    fi
-	    ;;
-	[Aa]*)
-	    apply=y
-	    ;;
-	[Nn]*)
-	    break
-	    ;;
-	[Qq]*)
-	    exit 0
-	    ;;
-	esac
-    done
-done
+chdir('patches') if -d 'patches';
+
+if (!-f 'verify-patches') {
+    die <<EOT;
+Please run this script from the root of the rsync dir or
+from inside the patches subdir.
+EOT
+}
+
+$| = 1;
+$ENV{'TZ'} = 'UTC';
+my $CONF_OPTS = '-C';
+
+my($has_dependencies, @new, @rejects);
+
+END {
+    &restore_cvsdir;
+    system "rsync -a --delete cvsdir/ workdir/" if -d 'cvsdir';
+};
+
+my $root;
+open(IN, '../CVS/Root') or die $!;
+chomp($root = <IN>);
+close IN;
+
+mkdir('tmp', 0777) unless -d 'tmp';
+chdir('tmp') or die "Unable to chdir to 'tmp'";
+
+mkdir('workdir') unless -d 'workdir';
+open(OUT, '>exclude') or die $!;
+print OUT <<EOT;
+CVS
+proto.h
+configure
+config.h.in
+rsync.1
+rsyncd.conf.5
+EOT
+close OUT;
+
+print "Using CVS to update the tmp/cvsdir copy of the source.\n";
+system qq|cvs -d "$root" co -d cvsdir rsync|;
+
+@ARGV = glob('../*.diff') unless @ARGV;
+
+DIFF:
+foreach my $diff (@ARGV) {
+    next unless $diff =~ /\.diff$/;
+    next if $diff =~ /gzip-rsyncable\.diff$/;
+    $diff =~ s#^(patches|\.\.)/##;
+
+    open(IN, "../$diff") or die $!;
+    while (<IN>) {
+	last if /^--- /;
+	if (/^Depends-On-Patch: (\S+.diff)$/) {
+	    my $dep = $1;
+	    $has_dependencies = 1;
+	    print "\nApplying dependency patch $dep...\n";
+	    if (system("patch -d cvsdir -p0 -b -Vt -Zf <../$dep") != 0) {
+		print "Unable to cleanly apply dependency patch -- skipping $diff\n";
+		system "rm -f cvsdir/*.rej cvsdir/*/*.rej";
+		&restore_cvsdir;
+		next DIFF;
+	    }
+	}
+    }
+    close IN;
+
+    my $default = apply_patch($diff);
+    if ($default =~ s/^D,// || $default eq 'N') {
+	my $def = generate_new_patch($diff);
+	$default = 'U,N' if $default eq 'N' && $def eq 'E';
+    }
+
+    PROMPT:
+    while (1) {
+	print "\n----------- $diff ------------\n",
+	    "\nFix rejects, Diff create, Edit both diffs, Update patch,\n",
+	    "Apply patch again, !(CMD), Build rsync, Next, Quit: [$default] ";
+	my $ans = <STDIN>;
+	chomp $ans;
+	$ans = $default if $ans eq '';
+	while ($ans =~ s/^\s*(!|\w)((?<!!)[^;,]*|[^;]*)[;,]?//) {
+	    my $cmd = "\U$1\E";
+	    if ($cmd eq '!') {
+		$cmd = $2 || $ENV{'SHELL'};
+		chdir('workdir') or die $!;
+		system $cmd;
+		chdir('..') or die $!;
+		$default = 'D';
+		next;
+	    }
+	    if ($cmd eq 'A') {
+		$default = apply_patch($diff);
+		next;
+	    }
+	    if ($cmd eq 'B') {
+		if (!-f 'workdir/Makefile') {
+		    open(IN, '../../Makefile') or die $!;
+		    open(OUT, '>workdir/Makefile') or die $!;
+		    print OUT "srcdir=.\n\n";
+		    while (<IN>) {
+			last if /^gen:/;
+		    }
+		    print OUT $_;
+		    while (<IN>) {
+			last if /^clean:/;
+			print OUT $_;
+		    }
+		    close IN;
+		    close OUT;
+		}
+		chdir('workdir') or die $!;
+		system "make gen; ./configure $CONF_OPTS; make";
+		chdir('..') or die $!;
+		$default = '!make test';
+		next;
+	    }
+	    if ($cmd eq 'D') {
+		$default = generate_new_patch($diff);
+		next;
+	    }
+	    if ($cmd eq 'E') {
+		chdir('workdir') or die $!;
+		system "vim -d ../../$diff ../new.patch";
+		chdir('..') or die $!;
+		$default = 'U,A,D';
+		next;
+	    }
+	    if ($cmd eq 'F') {
+		chdir('workdir') or die $!;
+		system "vim @rejects";
+		chdir('..') or die $!;
+		$default = 'D,E';
+		next;
+	    }
+	    if ($cmd eq 'N') {
+		last PROMPT;
+	    }
+	    if ($cmd eq 'Q') {
+		exit;
+	    }
+	    if ($cmd eq 'U') {
+		system "cp -p new.patch ../$diff";
+		print "\nUpdated $diff from new.patch\n";
+		$default = 'A';
+		next;
+	    }
+	}
+    }
+
+    &restore_cvsdir;
+}
+
+exit;
+
+
+sub apply_patch
+{
+    my($diff) = @_;
+
+    undef @new;
+    system "rsync -a --delete --exclude='*~' cvsdir/ workdir/";
+    print "\nApplying patch $diff...\n";
+    undef @rejects;
+    my($saw_failure, $saw_offset, $saw_fuzz);
+    open(IN, "patch -d workdir -p0 --no-backup-if-mismatch -Zf <../$diff |") or die $!;
+    while (<IN>) {
+	print $_;
+	chomp;
+	if (s/^patching file //) {
+	    push(@new, $_) unless -f "cvsdir/$_";
+	} elsif (s/.* saving rejects to file //) {
+	    push(@rejects, $_);
+	} elsif (/^Hunk #\d+ FAILED/) {
+	    $saw_failure = 1;
+	} elsif (/^Hunk #\d+ succeeded at \d+( with fuzz )?/) {
+	    $saw_fuzz ||= defined $1;
+	    $saw_offset = 1;
+	}
+    }
+    close IN;
+    return 'F,D,E' if $saw_failure;
+    return 'D,E' if $saw_fuzz;
+    return 'D,U,N' if $saw_offset;
+    'N';
+}
+
+sub generate_new_patch
+{
+    my($diff) = @_;
+
+    foreach (@new) {
+	system "touch -r workdir/$_ cvsdir/$_";
+    }
+    open(IN, "../$diff") or die $!;
+    open(OUT, '>new.patch') or die $!;
+    while (<IN>) {
+	last if /^--- /;
+	print OUT $_;
+    }
+    close IN;
+    open(IN, 'diff --exclude-from=exclude -upr cvsdir workdir |') or die $!;
+    while (<IN>) {
+	next if /^(diff -|Index: |Only in )/;
+	s#^\Q--- cvsdir/\E#--- orig/#;
+	s#^\Q+++ workdir/\E#+++ #;
+	s#(\.000000000)? \+0000$##;
+	print OUT $_;
+    }
+    close IN;
+    close OUT;
+    foreach (@new) {
+	unlink("cvsdir/$_");
+    }
+    print "\nDiffing... ";
+    if (system("diff ../$diff new.patch >/dev/null") == 0) {
+	print "new patch is identical to old.\n";
+	return 'N';
+    }
+    print "New patch DIFFERS from old.\n";
+    'E';
+}
+
+sub restore_cvsdir
+{
+    return unless $has_dependencies;
+    $has_dependencies = 0;
+
+    foreach (glob('*.~[1-9]~'), glob('*/*.~[1-9]~')) {
+	my $fn;
+	($fn = $_) =~ s/\.~1~$//;
+	if ($fn eq $_) {
+	    unlink($_);
+	} elsif (-r $fn) {
+	    rename($_,  $fn);
+	} else {
+	    unlink($_);
+	    unlink($fn);
+	}
+    }
+}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/patches: write-only.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/pipe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/pipe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/pipe.c	2004-01-28 06:35:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/pipe.c	2004-08-12 08:52:58.000000000 +0800
@@ -1,41 +1,41 @@
 /*  -*- c-file-style: "linux" -*-
- * 
- * Copyright (C) 1996-2000 by Andrew Tridgell 
+ *
+ * Copyright (C) 1996-2000 by Andrew Tridgell
  * Copyright (C) Paul Mackerras 1996
  * Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "rsync.h"
 
 extern int am_sender;
 extern int am_server;
 extern int blocking_io;
 extern int orig_umask;
-extern int read_batch;
+extern int write_batch;
 extern int filesfrom_fd;
 
 /**
  * Create a child connected to use on stdin/stdout.
  *
- * This is derived from CVS code 
- * 
+ * This is derived from CVS code
+ *
  * Note that in the child STDIN is set to blocking and STDOUT
  * is set to non-blocking. This is necessary as rsh relies on stdin being blocking
  *  and ssh relies on stdout being non-blocking
  *
  * If blocking_io is set then use blocking io on both fds. That can be
  * used to cope with badly broken rsh implementations like the one on
@@ -43,110 +43,122 @@
  **/
 pid_t piped_child(char **command, int *f_in, int *f_out)
 {
 	pid_t pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
-	
+
 	if (verbose >= 2) {
 		print_child_argv(command);
 	}
 
 	if (fd_pair(to_child_pipe) < 0 || fd_pair(from_child_pipe) < 0) {
-		rprintf(FERROR, "pipe: %s\n", strerror(errno));
+		rsyserr(FERROR, errno, "pipe");
 		exit_cleanup(RERR_IPC);
 	}
 
-
 	pid = do_fork();
 	if (pid == -1) {
-		rprintf(FERROR, "fork: %s\n", strerror(errno));
+		rsyserr(FERROR, errno, "fork");
 		exit_cleanup(RERR_IPC);
 	}
 
 	if (pid == 0) {
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
-			rprintf(FERROR, "Failed to dup/close : %s\n",
-				strerror(errno));
+			rsyserr(FERROR, errno, "Failed to dup/close");
 			exit_cleanup(RERR_IPC);
 		}
 		if (to_child_pipe[0] != STDIN_FILENO)
 			close(to_child_pipe[0]);
 		if (from_child_pipe[1] != STDOUT_FILENO)
 			close(from_child_pipe[1]);
 		umask(orig_umask);
 		set_blocking(STDIN_FILENO);
 		if (blocking_io > 0)
 			set_blocking(STDOUT_FILENO);
 		execvp(command[0], command);
-		rprintf(FERROR, "Failed to exec %s : %s\n",
-			command[0], strerror(errno));
+		rsyserr(FERROR, errno, "Failed to exec %s", command[0]);
 		exit_cleanup(RERR_IPC);
 	}
 
 	if (close(from_child_pipe[1]) < 0 || close(to_child_pipe[0]) < 0) {
-		rprintf(FERROR, "Failed to close : %s\n", strerror(errno));
+		rsyserr(FERROR, errno, "Failed to close");
 		exit_cleanup(RERR_IPC);
 	}
 
 	*f_in = from_child_pipe[0];
 	*f_out = to_child_pipe[1];
 
 	return pid;
 }
 
-pid_t local_child(int argc, char **argv,int *f_in,int *f_out,
+/* This function forks a child which calls child_main().  First,
+ * however, it has to establish communication paths to and from the
+ * newborn child.  It creates two socket pairs -- one for writing to
+ * the child (from the parent) and one for reading from the child
+ * (writing to the parent).  Since that's four socket ends, each
+ * process has to close the two ends it doesn't need.  The remaining
+ * two socket ends are retained for reading and writing.  In the
+ * child, the STDIN and STDOUT file descriptors refer to these
+ * sockets.  In the parent, the function arguments f_in and f_out are
+ * set to refer to these sockets. */
+pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
 		  int (*child_main)(int, char*[]))
 {
 	pid_t pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
 
 	if (fd_pair(to_child_pipe) < 0 ||
 	    fd_pair(from_child_pipe) < 0) {
-		rprintf(FERROR,"pipe: %s\n",strerror(errno));
+		rsyserr(FERROR, errno, "pipe");
 		exit_cleanup(RERR_IPC);
 	}
 
-
 	pid = do_fork();
 	if (pid == -1) {
-		rprintf(FERROR,"fork: %s\n",strerror(errno));
+		rsyserr(FERROR, errno, "fork");
 		exit_cleanup(RERR_IPC);
 	}
 
 	if (pid == 0) {
-		am_sender = read_batch ? 0 : !am_sender;
-		am_server = 1;		
+		am_sender = !am_sender;
+		am_server = 1;
+
+		/* The server side never writes the batch, even if it
+		 * is local (it makes the logic easier elsewhere). */
+		write_batch = 0;
 
 		if (!am_sender)
 			filesfrom_fd = -1;
 
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
-			rprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
+			rsyserr(FERROR, errno, "Failed to dup/close");
 			exit_cleanup(RERR_IPC);
 		}
-		if (to_child_pipe[0] != STDIN_FILENO) close(to_child_pipe[0]);
-		if (from_child_pipe[1] != STDOUT_FILENO) close(from_child_pipe[1]);
+		if (to_child_pipe[0] != STDIN_FILENO)
+			close(to_child_pipe[0]);
+		if (from_child_pipe[1] != STDOUT_FILENO)
+			close(from_child_pipe[1]);
 		child_main(argc, argv);
 	}
 
 	if (!am_sender)
 		filesfrom_fd = -1;
 
 	if (close(from_child_pipe[1]) < 0 ||
 	    close(to_child_pipe[0]) < 0) {
-		rprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
+		rsyserr(FERROR, errno, "Failed to close");
 		exit_cleanup(RERR_IPC);
 	}
 
 	*f_in = from_child_pipe[0];
 	*f_out = to_child_pipe[1];
-  
+
 	return pid;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/popt/popthelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/popt/popthelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/popt/popthelp.c	2004-01-28 00:27:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/popt/popthelp.c	2004-06-10 05:41:21.000000000 +0800
@@ -60,13 +60,13 @@
 } ;
 /*@=castfcnptr@*/
 
 /**
  * @param table		option(s)
  */
-/*@observer@*/ /*@null@*/ static const char *const
+/*@observer@*/ /*@null@*/ static const char *
 getTableTranslationDomain(/*@null@*/ const struct poptOption *table)
 	/*@*/
 {
     const struct poptOption *opt;
 
     if (table != NULL)
@@ -78,16 +78,16 @@
 }
 
 /**
  * @param opt		option(s)
  * @param translation_domain	translation domain
  */
-/*@observer@*/ /*@null@*/ static const char *const
+/*@observer@*/ /*@null@*/ static const char *
 getArgDescrip(const struct poptOption * opt,
 		/*@-paramuse@*/		/* FIX: wazzup? */
-		/*@null@*/ UNUSED(const char * translation_domain))
+		/*@null@*/ const char * translation_domain)
 		/*@=paramuse@*/
 	/*@*/
 {
     if (!(opt->argInfo & POPT_ARG_MASK)) return NULL;
 
     if (opt == (poptHelpOptions + 1) || opt == (poptHelpOptions + 2))
@@ -112,13 +112,13 @@
  * @param translation_domain	translation domain
  */
 static /*@only@*/ /*@null@*/ char *
 singleOptionDefaultValue(int lineLength,
 		const struct poptOption * opt,
 		/*@-paramuse@*/	/* FIX: i18n macros disable with lclint */
-		/*@null@*/ UNUSED(const char * translation_domain))
+		/*@null@*/ const char * translation_domain)
 		/*@=paramuse@*/
 	/*@*/
 {
     const char * defstr = D_(translation_domain, "default");
     char * le = malloc(4*lineLength + 1);
     char * l = le;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/proto.h	2004-04-22 17:58:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/proto.h	2004-09-21 17:15:56.000000000 +0800
@@ -1,38 +1,30 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
 int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
 void base64_encode(char *buf, int len, char *out);
 char *auth_server(int f_in, int f_out, int module, char *addr, char *leader);
 void auth_client(int fd, char *user, char *challenge);
+char *get_backup_name(char *fname);
 int make_backup(char *fname);
-void write_batch_flist_info(int flist_count, struct file_struct **files);
-void write_batch_argvs_file(int argc, char *argv[]);
-struct file_list *create_flist_from_batch(void);
-void write_batch_csums_file(void *buff, int bytes_to_write);
-void close_batch_csums_file(void);
-void write_batch_csum_info(int *flist_entry, struct sum_struct *s);
-int read_batch_csums_file(char *buff, int len);
-void read_batch_csum_info(int flist_entry, struct sum_struct *s,
-			  int *checksums_match);
-void write_batch_delta_file(char *buff, int bytes_to_write);
-void close_batch_delta_file(void);
-int read_batch_delta_file(char *buff, int len);
+void write_stream_flags(int fd);
+void read_stream_flags(int fd);
+void write_batch_shell_file(int argc, char *argv[], int file_arg_cnt);
 void show_flist(int index, struct file_struct **fptr);
 void show_argvs(int argc, char *argv[]);
 uint32 get_checksum1(char *buf1,int len);
 void get_checksum2(char *buf,int len,char *sum);
 void file_checksum(char *fname,char *sum,OFF_T size);
-void sum_init(void);
+void sum_init(int seed);
 void sum_update(char *p, int len);
 void sum_end(char *sum);
 void close_all(void);
 void _exit_cleanup(int code, const char *file, int line);
 void cleanup_disable(void);
 void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
-		 struct map_struct *buf, int fd1, int fd2);
+		 int fd_r, int fd_w);
 void cleanup_set_pid(pid_t pid);
 char *client_addr(int fd);
 char *client_name(int fd);
 void client_sockaddr(int fd,
 		     struct sockaddr_storage *ss,
 		     socklen_t *ss_len);
@@ -43,42 +35,43 @@
 int compare_addrinfo_sockaddr(const struct addrinfo *ai,
 			      const struct sockaddr_storage *ss);
 int check_name(int fd,
 	       const struct sockaddr_storage *ss,
 	       char *name_buf);
 int start_socket_client(char *host, char *path, int argc, char *argv[]);
-int start_inband_exchange(char *user, char *path, int f_in, int f_out, int argc);
+int start_inband_exchange(char *user, char *path, int f_in, int f_out, 
+			  int argc);
 int start_daemon(int f_in, int f_out);
 int daemon_main(void);
 void setup_protocol(int f_out,int f_in);
 int claim_connection(char *fname,int max_connections);
-void free_exclude_list(struct exclude_list_struct *listp);
+void clear_exclude_list(struct exclude_list_struct *listp);
 int check_exclude(struct exclude_list_struct *listp, char *name, int name_is_dir);
 void add_exclude(struct exclude_list_struct *listp, const char *pattern,
 		 int xflags);
 void add_exclude_file(struct exclude_list_struct *listp, const char *fname,
 		      int xflags);
 void send_exclude_list(int f);
 void recv_exclude_list(int f);
 void add_cvs_excludes(void);
 int sparse_end(int f);
 int flush_write_file(int f);
 int write_file(int f,char *buf,size_t len);
-struct map_struct *map_file(int fd,OFF_T len);
+struct map_struct *map_file(int fd, OFF_T len, OFF_T map_size,
+			    size_t block_size);
 char *map_ptr(struct map_struct *map,OFF_T offset,int len);
 int unmap_file(struct map_struct *map);
 void init_flist(void);
 void show_flist_stats(void);
-int readlink_stat(const char *path, STRUCT_STAT *buffer, char *linkbuf);
-int link_stat(const char *path, STRUCT_STAT * buffer);
+int link_stat(const char *path, STRUCT_STAT *buffer, int follow_dirlinks);
 void flist_expand(struct file_list *flist);
 void send_file_entry(struct file_struct *file, int f, unsigned short base_flags);
 void receive_file_entry(struct file_struct **fptr, unsigned short flags,
-    struct file_list *flist, int f);
-struct file_struct *make_file(char *fname,
-    struct file_list *flist, int exclude_level);
+			struct file_list *flist, int f);
+struct file_struct *make_file(char *fname, struct file_list *flist,
+			      int exclude_level);
 void send_file_name(int f, struct file_list *flist, char *fname,
 		    int recursive, unsigned short base_flags);
 struct file_list *send_file_list(int f, int argc, char *argv[]);
 struct file_list *recv_file_list(int f);
 int file_compare(struct file_struct **file1, struct file_struct **file2);
 int flist_find(struct file_list *flist, struct file_struct *f);
@@ -86,55 +79,60 @@
 struct file_list *flist_new(int with_hlink, char *msg);
 void flist_free(struct file_list *flist);
 int f_name_cmp(struct file_struct *f1, struct file_struct *f2);
 char *f_name_to(struct file_struct *f, char *fbuf);
 char *f_name(struct file_struct *f);
 void write_sum_head(int f, struct sum_struct *sum);
-void recv_generator(char *fname, struct file_struct *file, int i, int f_out);
-void generate_files(int f, struct file_list *flist, char *local_name);
+void generate_files(int f_out, struct file_list *flist, char *local_name);
 void init_hard_links(struct file_list *flist);
 int hard_link_check(struct file_struct *file, int skip);
 void do_hard_links(void);
+void io_set_sock_fds(int f_in, int f_out);
 void set_msg_fd_in(int fd);
 void set_msg_fd_out(int fd);
 void send_msg(enum msgcode code, char *buf, int len);
 int msg_list_push(int flush_it_all);
 int get_redo_num(void);
 void io_set_filesfrom_fds(int f_in, int f_out);
 int read_filesfrom_line(int fd, char *fname);
+void io_start_buffering_out(void);
+void io_start_buffering_in(void);
+void io_end_buffering(void);
 int32 read_int(int f);
 int64 read_longint(int f);
 void read_buf(int f,char *buf,size_t len);
 void read_sbuf(int f,char *buf,size_t len);
 unsigned char read_byte(int f);
-void io_start_buffering_out(int fd);
-void io_start_buffering_in(int fd);
 void io_flush(int flush_it_all);
-void io_end_buffering(void);
 void write_int(int f,int32 x);
 void write_int_named(int f, int32 x, const char *phase);
 void write_longint(int f, int64 x);
 void write_buf(int f,char *buf,size_t len);
+void write_sbuf(int f, char *buf);
 void write_byte(int f,unsigned char c);
 int read_line(int f, char *buf, size_t maxlen);
 void io_printf(int fd, const char *format, ...);
-void io_start_multiplex_out(int fd);
-void io_start_multiplex_in(int fd);
+void io_start_multiplex_out(void);
+void io_start_multiplex_in(void);
 int io_multiplex_write(enum msgcode code, char *buf, size_t len);
-void io_multiplexing_close(void);
+void close_multiplexing_in(void);
+void close_multiplexing_out(void);
+void start_write_batch(int fd);
+void stop_write_batch(void);
 char *lp_motd_file(void);
 char *lp_log_file(void);
 char *lp_pid_file(void);
 char *lp_socket_options(void);
 int lp_syslog_facility(void);
 int lp_max_verbosity(void);
 char *lp_name(int );
 char *lp_comment(int );
 char *lp_path(int );
 char *lp_lock_file(int );
 BOOL lp_read_only(int );
+BOOL lp_write_only(int );
 BOOL lp_list(int );
 BOOL lp_use_chroot(int );
 BOOL lp_transfer_logging(int );
 BOOL lp_ignore_errors(int );
 BOOL lp_ignore_nonreadable(int );
 char *lp_uid(int );
@@ -180,24 +178,25 @@
 void server_options(char **args,int *argc);
 char *find_colon(char *s);
 BOOL pm_process( char *FileName,
                  BOOL (*sfunc)(char *),
                  BOOL (*pfunc)(char *, char *) );
 pid_t piped_child(char **command, int *f_in, int *f_out);
-pid_t local_child(int argc, char **argv,int *f_in,int *f_out,
+pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
 		  int (*child_main)(int, char*[]));
 void end_progress(OFF_T size);
 void show_progress(OFF_T ofs, OFF_T size);
 void delete_files(struct file_list *flist);
-int recv_files(int f_in,struct file_list *flist,char *local_name);
+int recv_files(int f_in, struct file_list *flist, char *local_name);
 void free_sums(struct sum_struct *s);
 int delete_file(char *fname);
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
-		int report);
+	      int flags);
 void sig_int(void);
-void finish_transfer(char *fname, char *fnametmp, struct file_struct *file);
+void finish_transfer(char *fname, char *fnametmp, struct file_struct *file,
+		     int ok_to_set_time);
 const char *who_am_i(void);
 void read_sum_head(int f, struct sum_struct *sum);
 void send_files(struct file_list *flist, int f_out, int f_in);
 int try_bind_local(int s, int ai_family, int ai_socktype,
 		   const char *bind_address);
 int open_socket_out(char *host, int port, const char *bind_address,
@@ -241,30 +240,34 @@
 int fd_pair(int fd[2]);
 void print_child_argv(char **cmd);
 void out_of_memory(char *str);
 void overflow(char *str);
 int set_modtime(char *fname, time_t modtime);
 int create_directory_path(char *fname, int base_umask);
+int full_write(int desc, char *ptr, size_t len);
 int copy_file(char *source, char *dest, mode_t mode);
 int robust_unlink(char *fname);
 int robust_rename(char *from, char *to, int mode);
 pid_t do_fork(void);
 void kill_all(int sig);
 int name_to_uid(char *name, uid_t *uid);
 int name_to_gid(char *name, gid_t *gid);
 int lock_range(int fd, int offset, int len);
-void glob_expand(char *base1, char **argv, int *argc, int maxargs);
+void glob_expand(char *base1, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr);
 void strlower(char *s);
 size_t pathjoin(char *dest, size_t destsize, const char *p1, const char *p2);
 size_t stringjoin(char *dest, size_t destsize, ...);
-void clean_fname(char *name);
-void sanitize_path(char *p, char *reldir);
-char *alloc_sanitize_path(const char *path, const char *rootdir);
+int count_dir_elements(const char *p);
+unsigned int clean_fname(char *name, BOOL collapse_dot_dot);
+char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth);
 int push_dir(char *dir);
 int pop_dir(char *dir);
-char *full_fname(char *fn);
+const char *safe_fname(const char *fname);
+char *full_fname(const char *fn);
+char *partial_dir_fname(const char *fname);
+int handle_partial_dir(const char *fname, int create);
 int u_strcmp(const char *cs1, const char *cs2);
 int unsafe_symlink(const char *dest, const char *src);
 char *timestring(time_t t);
 int msleep(int t);
 int cmp_modtime(time_t file1, time_t file2);
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/README	2002-05-14 02:34:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/README	2004-06-07 04:36:56.000000000 +0800
@@ -26,15 +26,15 @@
 and see the manual for more information.
 
 
 SETUP
 -----
 
-Rsync normally uses rsh or ssh for communication.  It does not need to
+Rsync normally uses ssh or rsh for communication.  It does not need to
 be setuid and requires no special privileges for installation.  You
-must, however, have a working rsh or ssh system. Using ssh is
+must, however, have a working ssh or rsh system. Using ssh is
 recommended for its security features.
 
 Alternatively, rsync can run in `daemon' mode, listening on a socket.
 This is generally used for public file distribution, although
 authentication and access control are available.
 
@@ -74,24 +74,23 @@
 
 BUG REPORTS
 -----------
 
 If you have web access then please look at
 
-  http://rsync.samba.org
+  http://rsync.samba.org/
 
 That page contains links to the current bug list, and information on
 how to report a bug well.  You might also like to try searching the
 internet for the error message you've received, or looking in the
 mailing list archives at
 
   http://mail-archive.com/rsync@lists.samba.org/
 
-Please send bug reports to 
-
-  rsync@lists.samba.org
+To send a bug report, follow the instructions on the bug-tracking
+page of the web site.
 
 
 CVS TREE
 --------
 
 If you want to get the very latest version of rsync direct from the
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/receiver.c	2004-04-28 03:51:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/receiver.c	2004-09-21 17:24:06.000000000 +0800
@@ -19,53 +19,63 @@
 */
 
 #include "rsync.h"
 
 extern int verbose;
 extern int recurse;
-extern int delete_mode;
 extern int delete_after;
 extern int max_delete;
 extern int csum_length;
 extern struct stats stats;
 extern int dry_run;
+extern int read_batch;
+extern int batch_gen_fd;
 extern int am_server;
 extern int relative_paths;
+extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int preserve_perms;
 extern int cvs_exclude;
 extern int io_error;
 extern char *tmpdir;
+extern char *partial_dir;
 extern char *compare_dest;
 extern int make_backups;
 extern int do_progress;
 extern char *backup_dir;
 extern char *backup_suffix;
 extern int backup_suffix_len;
 extern int cleanup_got_literal;
 extern int module_id;
 extern int ignore_errors;
 extern int orig_umask;
+extern int keep_partial;
+extern int checksum_seed;
+extern int inplace;
+
+extern struct exclude_list_struct server_exclude_list;
+
 
 static void delete_one(char *fn, int is_dir)
 {
 	if (!is_dir) {
 		if (robust_unlink(fn) != 0) {
-			rprintf(FERROR, "delete_one: unlink %s failed: %s\n",
-				full_fname(fn), strerror(errno));
-		} else if (verbose) {
-			rprintf(FINFO, "deleting %s\n", fn);
-		}
+			rsyserr(FERROR, errno, "delete_one: unlink %s failed",
+				full_fname(fn));
+		} else if (verbose)
+			rprintf(FINFO, "deleting %s\n", safe_fname(fn));
 	} else {
 		if (do_rmdir(fn) != 0) {
 			if (errno != ENOTEMPTY && errno != EEXIST) {
-				rprintf(FERROR, "delete_one: rmdir %s failed: %s\n",
-					full_fname(fn), strerror(errno));
+				rsyserr(FERROR, errno,
+					"delete_one: rmdir %s failed",
+					full_fname(fn));
 			}
 		} else if (verbose) {
-			rprintf(FINFO, "deleting directory %s\n", fn);
+			rprintf(FINFO, "deleting directory %s\n",
+				safe_fname(fn));
 		}
 	}
 }
 
 
 static int is_backup_file(char *fn)
@@ -100,25 +110,27 @@
 		argv[0] = f_name_to(flist->files[j], fbuf);
 
 		if (!(local_file_list = send_file_list(-1, 1, argv)))
 			continue;
 
 		if (verbose > 1)
-			rprintf(FINFO, "deleting in %s\n", fbuf);
+			rprintf(FINFO, "deleting in %s\n", safe_fname(fbuf));
 
 		for (i = local_file_list->count-1; i >= 0; i--) {
 			if (max_delete && deletion_count > max_delete)
 				break;
 			if (!local_file_list->files[i]->basename)
 				continue;
 			if (flist_find(flist,local_file_list->files[i]) < 0) {
 				char *f = f_name(local_file_list->files[i]);
 				if (make_backups && (backup_dir || !is_backup_file(f))) {
-					(void) make_backup(f);
-					if (verbose)
-						rprintf(FINFO, "deleting %s\n", f);
+					make_backup(f);
+					if (verbose) {
+						rprintf(FINFO, "deleting %s\n",
+							safe_fname(f));
+					}
 				} else {
 					int mode = local_file_list->files[i]->mode;
 					delete_one(f, S_ISDIR(mode) != 0);
 				}
 				deletion_count++;
 			}
@@ -186,28 +198,39 @@
 	strcat(fnametmp + length, ".XXXXXX");
 
 	return 1;
 }
 
 
-static int receive_data(int f_in,struct map_struct *mapbuf,int fd,char *fname,
-			OFF_T total_size)
+static int receive_data(int f_in, char *fname_r, int fd_r, OFF_T size_r,
+			char *fname, int fd, OFF_T total_size)
 {
-	int i;
+	static char file_sum1[MD4_SUM_LENGTH];
+	static char file_sum2[MD4_SUM_LENGTH];
+	struct map_struct *mapbuf;
 	struct sum_struct sum;
 	unsigned int len;
 	OFF_T offset = 0;
 	OFF_T offset2;
 	char *data;
-	static char file_sum1[MD4_SUM_LENGTH];
-	static char file_sum2[MD4_SUM_LENGTH];
-	char *map=NULL;
+	int i;
+	char *map = NULL;
 
 	read_sum_head(f_in, &sum);
 
-	sum_init();
+	if (fd_r >= 0 && size_r > 0) {
+		OFF_T map_size = MAX(sum.blength * 2, 16*1024);
+		mapbuf = map_file(fd_r, size_r, map_size, sum.blength);
+		if (verbose > 2) {
+			rprintf(FINFO, "recv mapped %s of size %.0f\n",
+				safe_fname(fname_r), (double)size_r);
+		}
+	} else
+		mapbuf = NULL;
+
+	sum_init(checksum_seed);
 
 	while ((i = recv_token(f_in, &data)) != 0) {
 		if (do_progress)
 			show_progress(offset, total_size);
 
 		if (i > 0) {
@@ -218,25 +241,22 @@
 
 			stats.literal_data += i;
 			cleanup_got_literal = 1;
 
 			sum_update(data,i);
 
-			if (fd != -1 && write_file(fd,data,i) != i) {
-				rprintf(FERROR, "write failed on %s: %s\n",
-					full_fname(fname), strerror(errno));
-				exit_cleanup(RERR_FILEIO);
-			}
+			if (fd != -1 && write_file(fd,data,i) != i)
+				goto report_write_error;
 			offset += i;
 			continue;
 		}
 
 		i = -(i+1);
 		offset2 = i*(OFF_T)sum.blength;
 		len = sum.blength;
-		if (i == (int) sum.count-1 && sum.remainder != 0)
+		if (i == (int)sum.count-1 && sum.remainder != 0)
 			len = sum.remainder;
 
 		stats.matched_data += len;
 
 		if (verbose > 3)
 			rprintf(FINFO,"chunk[%d] of size %d at %.0f offset=%.0f\n",
@@ -246,87 +266,117 @@
 			map = map_ptr(mapbuf,offset2,len);
 
 			see_token(map, len);
 			sum_update(map,len);
 		}
 
-		if (fd != -1 && write_file(fd,map,len) != (int) len) {
-			rprintf(FERROR, "write failed on %s: %s\n",
-				full_fname(fname), strerror(errno));
-			exit_cleanup(RERR_FILEIO);
+		if (inplace) {
+			if (offset == offset2 && fd != -1) {
+				if (flush_write_file(fd) < 0)
+					goto report_write_error;
+				offset += len;
+				if (do_lseek(fd, len, SEEK_CUR) != offset) {
+					rsyserr(FERROR, errno,
+						"lseek failed on %s",
+						full_fname(fname));
+					exit_cleanup(RERR_FILEIO);
+				}
+				continue;
+			}
 		}
+		if (fd != -1 && write_file(fd, map, len) != (int)len)
+			goto report_write_error;
 		offset += len;
 	}
 
 	flush_write_file(fd);
 
+#ifdef HAVE_FTRUNCATE
+	if (inplace && fd != -1)
+		ftruncate(fd, offset);
+#endif
+
 	if (do_progress)
 		end_progress(total_size);
 
 	if (fd != -1 && offset > 0 && sparse_end(fd) != 0) {
-		rprintf(FERROR, "write failed on %s: %s\n",
-			full_fname(fname), strerror(errno));
+	    report_write_error:
+		rsyserr(FERROR, errno, "write failed on %s",
+			full_fname(fname));
 		exit_cleanup(RERR_FILEIO);
 	}
 
 	sum_end(file_sum1);
 
+	if (mapbuf)
+		unmap_file(mapbuf);
+
 	read_buf(f_in,file_sum2,MD4_SUM_LENGTH);
-	if (verbose > 2) {
+	if (verbose > 2)
 		rprintf(FINFO,"got file_sum\n");
-	}
-	if (fd != -1 && memcmp(file_sum1,file_sum2,MD4_SUM_LENGTH) != 0) {
+	if (fd != -1 && memcmp(file_sum1, file_sum2, MD4_SUM_LENGTH) != 0)
 		return 0;
-	}
 	return 1;
 }
 
 
+static void discard_receive_data(int f_in, OFF_T length)
+{
+	receive_data(f_in, NULL, -1, 0, NULL, -1, length);
+}
+
+
 /**
  * main routine for receiver process.
  *
  * Receiver process runs on the same host as the generator process. */
-int recv_files(int f_in,struct file_list *flist,char *local_name)
+int recv_files(int f_in, struct file_list *flist, char *local_name)
 {
+	int next_gen_i = -1;
 	int fd1,fd2;
 	STRUCT_STAT st;
 	char *fname, fbuf[MAXPATHLEN];
 	char template[MAXPATHLEN];
 	char fnametmp[MAXPATHLEN];
-	char *fnamecmp;
+	char *fnamecmp, *partialptr;
 	char fnamecmpbuf[MAXPATHLEN];
-	struct map_struct *mapbuf;
-	int i;
 	struct file_struct *file;
-	int phase=0;
-	int recv_ok;
 	struct stats initial_stats;
+	int save_make_backups = make_backups;
+	int i, recv_ok, phase = 0;
 
-	if (verbose > 2) {
+	if (verbose > 2)
 		rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
-	}
 
 	if (flist->hlink_pool) {
 		pool_destroy(flist->hlink_pool);
 		flist->hlink_pool = NULL;
 	}
 
 	while (1) {
 		cleanup_disable();
 
 		i = read_int(f_in);
 		if (i == -1) {
-			if (phase == 0) {
-				phase++;
-				csum_length = SUM_LENGTH;
-				if (verbose > 2)
-					rprintf(FINFO,"recv_files phase=%d\n",phase);
-				send_msg(MSG_DONE, "", 0);
-				continue;
+			if (read_batch) {
+				if (next_gen_i != flist->count)
+					while (read_int(batch_gen_fd) != -1) {}
+				next_gen_i = -1;
 			}
-			break;
+
+			if (phase)
+				break;
+
+			phase = 1;
+			csum_length = SUM_LENGTH;
+			if (verbose > 2)
+				rprintf(FINFO, "recv_files phase=%d\n", phase);
+			send_msg(MSG_DONE, "", 0);
+			if (keep_partial)
+				make_backups = 0; /* prevents double backup */
+			continue;
 		}
 
 		if (i < 0 || i >= flist->count) {
 			rprintf(FERROR,"Invalid file index %d in recv_files (count=%d)\n",
 				i, flist->count);
 			exit_cleanup(RERR_PROTOCOL);
@@ -342,154 +392,222 @@
 		if (local_name)
 			fname = local_name;
 		else
 			fname = f_name_to(file, fbuf);
 
 		if (dry_run) {
-			if (!am_server && verbose) {	/* log transfer */
-				rprintf(FINFO, "%s\n", fname);
-			}
+			if (!am_server && verbose) /* log the transfer */
+				rprintf(FINFO, "%s\n", safe_fname(fname));
 			continue;
 		}
 
 		initial_stats = stats;
 
 		if (verbose > 2)
-			rprintf(FINFO,"recv_files(%s)\n",fname);
+			rprintf(FINFO, "recv_files(%s)\n", safe_fname(fname));
 
-		fnamecmp = fname;
+		if (read_batch) {
+			while (i > next_gen_i) {
+				next_gen_i = read_int(batch_gen_fd);
+				if (next_gen_i == -1)
+					next_gen_i = flist->count;
+			}
+			if (i < next_gen_i) {
+				rprintf(FINFO, "skipping update for \"%s\"\n",
+					safe_fname(fname));
+				discard_receive_data(f_in, file->length);
+				continue;
+			}
+		}
+
+		if (server_exclude_list.head
+		    && check_exclude(&server_exclude_list, fname,
+				     S_ISDIR(file->mode)) < 0) {
+			rprintf(FERROR, "attempt to hack rsync failed.\n");
+			exit_cleanup(RERR_PROTOCOL);
+		}
+
+		if (partial_dir) {
+			if ((partialptr = partial_dir_fname(fname)) != NULL)
+				fnamecmp = partialptr;
+			else
+				fnamecmp = fname;
+		} else
+			fnamecmp = partialptr = fname;
+
+		if (inplace && make_backups) {
+			if (!(fnamecmp = get_backup_name(fname)))
+				fnamecmp = partialptr;
+		}
 
 		/* open the file */
 		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 
+		if (fd1 == -1 && fnamecmp != fname) {
+			fnamecmp = fname;
+			fd1 = do_open(fnamecmp, O_RDONLY, 0);
+		}
+
 		if (fd1 == -1 && compare_dest != NULL) {
 			/* try the file at compare_dest instead */
 			pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
 				 compare_dest, fname);
 			fnamecmp = fnamecmpbuf;
 			fd1 = do_open(fnamecmp, O_RDONLY, 0);
 		}
 
 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
-			rprintf(FERROR, "fstat %s failed: %s\n",
-				full_fname(fnamecmp), strerror(errno));
-			receive_data(f_in,NULL,-1,NULL,file->length);
+			rsyserr(FERROR, errno, "fstat %s failed",
+				full_fname(fnamecmp));
+			discard_receive_data(f_in, file->length);
 			close(fd1);
 			continue;
 		}
 
 		if (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {
 			/* this special handling for directories
 			 * wouldn't be necessary if robust_rename()
 			 * and the underlying robust_unlink could cope
 			 * with directories
 			 */
 			rprintf(FERROR,"recv_files: %s is a directory\n",
 				full_fname(fnamecmp));
-			receive_data(f_in, NULL, -1, NULL, file->length);
+			discard_receive_data(f_in, file->length);
 			close(fd1);
 			continue;
 		}
 
 		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
 			close(fd1);
 			fd1 = -1;
-			mapbuf = NULL;
 		}
 
 		if (fd1 != -1 && !preserve_perms) {
 			/* if the file exists already and we aren't preserving
 			 * permissions then act as though the remote end sent
 			 * us the file permissions we already have */
 			file->mode = st.st_mode;
 		}
 
-		if (fd1 != -1 && st.st_size > 0) {
-			mapbuf = map_file(fd1,st.st_size);
-			if (verbose > 2)
-				rprintf(FINFO,"recv mapped %s of size %.0f\n",fnamecmp,(double)st.st_size);
-		} else
-			mapbuf = NULL;
-
-		if (!get_tmpname(fnametmp,fname)) {
-			if (mapbuf) unmap_file(mapbuf);
-			if (fd1 != -1) close(fd1);
-			continue;
-		}
+		/* We now check to see if we are writing file "inplace" */
+		if (inplace)  {
+			fd2 = do_open(fname, O_WRONLY|O_CREAT, 0);
+			if (fd2 == -1) {
+				rsyserr(FERROR, errno, "open %s failed",
+					full_fname(fname));
+				discard_receive_data(f_in, file->length);
+				if (fd1 != -1)
+					close(fd1);
+				continue;
+			}
+		} else {
+			if (!get_tmpname(fnametmp,fname)) {
+				discard_receive_data(f_in, file->length);
+				if (fd1 != -1)
+					close(fd1);
+				continue;
+			}
 
-		strlcpy(template, fnametmp, sizeof template);
+			strlcpy(template, fnametmp, sizeof template);
 
-		/* we initially set the perms without the
-		 * setuid/setgid bits to ensure that there is no race
-		 * condition. They are then correctly updated after
-		 * the lchown. Thanks to snabb@epipe.fi for pointing
-		 * this out.  We also set it initially without group
-		 * access because of a similar race condition. */
-		fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
-
-		/* in most cases parent directories will already exist
-		 * because their information should have been previously
-		 * transferred, but that may not be the case with -R */
-		if (fd2 == -1 && relative_paths && errno == ENOENT &&
-		    create_directory_path(fnametmp, orig_umask) == 0) {
-			strlcpy(fnametmp, template, sizeof fnametmp);
+			/* we initially set the perms without the
+			 * setuid/setgid bits to ensure that there is no race
+			 * condition. They are then correctly updated after
+			 * the lchown. Thanks to snabb@epipe.fi for pointing
+			 * this out.  We also set it initially without group
+			 * access because of a similar race condition. */
 			fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
-		}
-		if (fd2 == -1) {
-			rprintf(FERROR, "mkstemp %s failed: %s\n",
-				full_fname(fnametmp), strerror(errno));
-			receive_data(f_in,mapbuf,-1,NULL,file->length);
-			if (mapbuf) unmap_file(mapbuf);
-			if (fd1 != -1) close(fd1);
-			continue;
-		}
 
-		cleanup_set(fnametmp, fname, file, mapbuf, fd1, fd2);
+			/* in most cases parent directories will already exist
+			 * because their information should have been previously
+			 * transferred, but that may not be the case with -R */
+			if (fd2 == -1 && relative_paths && errno == ENOENT
+			    && create_directory_path(fnametmp, orig_umask) == 0) {
+				strlcpy(fnametmp, template, sizeof fnametmp);
+				fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
+			}
+			if (fd2 == -1) {
+				rsyserr(FERROR, errno, "mkstemp %s failed",
+					full_fname(fnametmp));
+				discard_receive_data(f_in, file->length);
+				if (fd1 != -1)
+					close(fd1);
+				continue;
+			}
 
-		if (!am_server && verbose) {	/* log transfer */
-			rprintf(FINFO, "%s\n", fname);
+			if (partialptr)
+				cleanup_set(fnametmp, partialptr, file, fd1, fd2);
 		}
 
+		if (!am_server && verbose) /* log the transfer */
+			rprintf(FINFO, "%s\n", safe_fname(fname));
+
 		/* recv file data */
-		recv_ok = receive_data(f_in,mapbuf,fd2,fname,file->length);
+		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
+				       fname, fd2, file->length);
 
 		log_recv(file, &initial_stats);
 
-		if (mapbuf) unmap_file(mapbuf);
-		if (fd1 != -1) {
+		if (fd1 != -1)
 			close(fd1);
-		}
 		if (close(fd2) < 0) {
-			rprintf(FERROR, "close failed on %s: %s\n",
-				full_fname(fnametmp), strerror(errno));
+			rsyserr(FERROR, errno, "close failed on %s",
+				full_fname(fnametmp));
 			exit_cleanup(RERR_FILEIO);
 		}
 
-		if (verbose > 2)
-			rprintf(FINFO,"renaming %s to %s\n",fnametmp,fname);
+		if (recv_ok || inplace)
+			finish_transfer(fname, fnametmp, file, recv_ok);
+		else if (keep_partial && partialptr
+		    && handle_partial_dir(partialptr, PDIR_CREATE))
+			finish_transfer(partialptr, fnametmp, file, 0);
+		else {
+			partialptr = NULL;
+			do_unlink(fnametmp);
+		}
 
-		finish_transfer(fname, fnametmp, file);
+		if (partialptr != fname && fnamecmp == partialptr && recv_ok) {
+			do_unlink(partialptr);
+			handle_partial_dir(partialptr, PDIR_DELETE);
+		}
 
 		cleanup_disable();
 
 		if (!recv_ok) {
-			if (csum_length == SUM_LENGTH) {
-				rprintf(FERROR,"ERROR: file corruption in %s. File changed during transfer?\n",
-					full_fname(fname));
-			} else {
+			int msgtype = csum_length == SUM_LENGTH || read_batch ?
+				FERROR : FINFO;
+			if (msgtype == FERROR || verbose) {
+				char *errstr, *redostr, *keptstr;
+				if (!(keep_partial && partialptr) && !inplace)
+					keptstr = "discarded";
+				else if (partial_dir)
+					keptstr = "put into partial-dir";
+				else
+					keptstr = "retained";
+				if (msgtype == FERROR) {
+					errstr = "ERROR";
+					redostr = "";
+				} else {
+					errstr = "WARNING";
+					redostr = " (will try again)";
+				}
+				rprintf(msgtype,
+					"%s: %s failed verification -- update %s%s.\n",
+					errstr, safe_fname(fname),
+					keptstr, redostr);
+			}
+			if (csum_length != SUM_LENGTH) {
 				char buf[4];
-				if (verbose > 1)
-					rprintf(FINFO,"redoing %s(%d)\n",fname,i);
 				SIVAL(buf, 0, i);
 				send_msg(MSG_REDO, buf, 4);
 			}
 		}
 	}
+	make_backups = save_make_backups;
 
-	if (delete_after && recurse && delete_mode && !local_name
-	    && flist->count > 0)
+	if (delete_after && recurse && !local_name && flist->count > 0)
 		delete_files(flist);
 
 	if (verbose > 2)
 		rprintf(FINFO,"recv_files finished\n");
 
 	return 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsync.1	2004-05-01 02:02:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsync.1	2004-10-01 00:36:01.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsync" "1" "30 Apr 2004" "" "" 
+.TH "rsync" "1" "30 Sep 2004" "" "" 
 .SH "NAME" 
 rsync \- faster, flexible replacement for rcp
 .SH "SYNOPSIS" 
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST:DEST
 .PP 
@@ -18,24 +18,24 @@
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. rsync://[USER@]HOST[:PORT]/DEST
 .PP 
 .SH "DESCRIPTION" 
 .PP 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
-greatly speed up file transfers when the destination file already
-exists\&.
+greatly speed up file transfers when the destination file is being
+updated\&.
 .PP 
 The rsync remote-update protocol allows rsync to transfer just the
 differences between two sets of files across the network connection, using
 an efficient checksum-search algorithm described in the technical
 report that accompanies this package\&.
 .PP 
 Some of the additional features of rsync are:
 .PP 
 .IP o 
-support for copying links, devices, owners, groups and permissions
+support for copying links, devices, owners, groups, and permissions
 .IP o 
 exclude and exclude-from options similar to GNU tar
 .IP o 
 a CVS exclude mode for ignoring the same files that CVS would ignore
 .IP o 
 can use any transparent remote shell, including ssh or rsh
@@ -122,13 +122,13 @@
 You use rsync in the same way you use rcp\&. You must specify a source
 and a destination, one of which may be remote\&.
 .PP 
 Perhaps the best way to explain the syntax is with some examples:
 .PP 
 .RS 
-rsync *\&.c foo:src/
+rsync -t *\&.c foo:src/
 .RE 
 .PP 
 This would transfer all files matching the pattern *\&.c from the
 current directory to the directory src on the machine foo\&. If any of
 the files already exist on the remote system then the rsync
 remote-update protocol is used to update the file by sending only the
@@ -156,16 +156,16 @@
 containing directory are transferred to the containing directory on the
 destination\&.  In other words, each of the following commands copies the
 files in the same way, including their setting of the attributes of
 /dest/foo:
 .PP 
 .RS 
-rsync -avz /src/foo /dest
+rsync -av /src/foo /dest
 .RE 
 .RS 
-rsync -avz /src/foo/ /dest/foo
+rsync -av /src/foo/ /dest/foo
 .RE 
 .PP 
 You can also use rsync in local-only mode, where both the source and
 destination don\&'t have a \&':\&' in the name\&. In this case it behaves like
 an improved copy command\&.
 .PP 
@@ -173,12 +173,48 @@
 rsync somehost\&.mydomain\&.com::
 .RE 
 .PP 
 This would list all the anonymous rsync modules available on the host
 somehost\&.mydomain\&.com\&.  (See the following section for more details\&.)
 .PP 
+.SH "ADVANCED USAGE" 
+.PP 
+The syntax for requesting multiple files from a remote host involves using
+quoted spaces in the SRC\&.  Some examples:
+.PP 
+.RS 
+rsync host::\&'modname/dir1/file1 modname/dir2/file2\&' /dest
+.RE 
+.PP 
+This would copy file1 and file2 into /dest from an rsync daemon\&.  Each
+additional arg must include the same "modname/" prefix as the first one,
+and must be preceded by a single space\&.  All other spaces are assumed
+to be a part of the filenames\&.
+.PP 
+.RS 
+rsync -av host:\&'dir1/file1 dir2/file2\&' /dest
+.RE 
+.PP 
+This would copy file1 and file2 into /dest using a remote shell\&.  This
+word-splitting is done by the remote shell, so if it doesn\&'t work it means
+that the remote shell isn\&'t configured to split its args based on
+whitespace (a very rare setting, but not unknown)\&.  If you need to transfer
+a filename that contains whitespace, you\&'ll need to either escape the
+whitespace in a way that the remote shell will understand, or use wildcards
+in place of the spaces\&.  Two examples of this are:
+.PP 
+.RS 
+rsync -av host:\&'file\e name\e with\e spaces\&' /dest
+.RE 
+.RS 
+rsync -av host:file?name?with?spaces /dest
+.RE 
+.PP 
+This latter example assumes that your shell passes through unmatched
+wildcards\&.  If it complains about "no match", put the name in quotes\&.
+.PP 
 .SH "CONNECTING TO AN RSYNC SERVER" 
 .PP 
 It is also possible to use rsync without a remote shell as the
 transport\&. In this case you will connect to a remote rsync server
 running on TCP port 873\&. 
 .PP 
@@ -323,12 +359,14 @@
      --no-relative           turn off --relative
      --no-implied-dirs       don\&'t send implied dirs with -R
  -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir            make backups into this directory
      --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                update only (don\&'t overwrite newer files)
+     --inplace               update the destination files inplace
+ -K, --keep-dirlinks         treat symlinked dir on receiver as dir
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            copy the referent of all symlinks
      --copy-unsafe-links     copy the referent of "unsafe" symlinks
      --safe-links            ignore "unsafe" symlinks
  -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
@@ -338,23 +376,24 @@
  -t, --times                 preserve times
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy whole files, no incremental checks
      --no-whole-file         turn off --whole-file
  -x, --one-file-system       don\&'t cross filesystem boundaries
- -B, --block-size=SIZE       checksum blocking size (default 700)
+ -B, --block-size=SIZE       force a fixed checksum block-size
  -e, --rsh=COMMAND           specify the remote shell
      --rsync-path=PATH       specify path to rsync on the remote machine
      --existing              only update files that already exist
      --ignore-existing       ignore files that already exist on receiver
      --delete                delete files that don\&'t exist on sender
      --delete-excluded       also delete excluded files on receiver
      --delete-after          receiver deletes after transfer, not before
      --ignore-errors         delete even if there are I/O errors
      --max-delete=NUM        don\&'t delete more than NUM files
      --partial               keep partially transferred files
+     --partial-dir=DIR       put a partially transferred file into DIR
      --force                 force deletion of dirs even if not empty
      --numeric-ids           don\&'t map uid/gid values by user/group name
      --timeout=TIME          set I/O timeout in seconds
  -I, --ignore-times          turn off mod time & file size quick check
      --size-only             ignore mod time for quick check (use size)
      --modify-window=NUM     compare mod times with reduced accuracy
@@ -380,14 +419,17 @@
      --no-blocking-io        turn off --blocking-io
      --stats                 give some file transfer stats
      --progress              show progress during transfer
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
      --bwlimit=KBPS          limit I/O bandwidth, KBytes per second
-     --write-batch=PREFIX    write batch fileset starting with PREFIX
-     --read-batch=PREFIX     read batch fileset starting with PREFIX
+     --write-batch=FILE      write a batch to FILE 
+     --read-batch=FILE       read a batch from FILE
+     --checksum-seed=NUM     set block/file checksum seed
+ -4  --ipv4                  prefer IPv4
+ -6  --ipv6                  prefer IPv6
  -h, --help                  show this help screen
 
 
 
 .fi 
  
@@ -541,19 +583,52 @@
 considered to be important enough for an update, no matter what date
 is on the objects\&.  In other words, if the source has a directory or a
 symlink where the destination has a file, the transfer would occur
 regardless of the timestamps\&.  This might change in the future (feel
 free to comment on this on the mailing list if you have an opinion)\&.
 .IP 
+.IP "\fB-K, --keep-dirlinks\fP" 
+On the receiving side, if a symlink is
+pointing to a directory, it will be treated as matching a directory
+from the sender\&.
+.IP 
+.IP "\fB--inplace\fP" 
+This causes rsync not to create a new copy of the file
+and then move it into place\&.  Instead rsync will overwrite the existing
+file, meaning that the rsync algorithm can\&'t extract the full amount of
+network reduction it might otherwise (since it does not yet try to sort
+data matches -- a future version may improve this)\&.
+.IP 
+This option is useful for transfer of large files with block-based changes
+or appended data, and also on systems that are disk bound, not network
+bound\&.
+.IP 
+The option implies --partial (since an interrupted transfer does not delete
+the file), but conflicts with --partial-dir, --compare-dest, and
+--link-dest (a future rsync version will hopefully update the protocol to
+remove these restrictions)\&.
+.IP 
+WARNING: The file\&'s data will be in an inconsistent state during the
+transfer (and possibly afterward if the transfer gets interrupted), so you
+should not use this option to update files that are in use\&.  Also note that
+rsync will be unable to update a file inplace that is not writable by the
+receiving user\&.
+.IP 
 .IP "\fB-l, --links\fP" 
 When symlinks are encountered, recreate the
 symlink on the destination\&.
 .IP 
 .IP "\fB-L, --copy-links\fP" 
 When symlinks are encountered, the file that
-they point to (the referent) is copied, rather than the symlink\&.
+they point to (the referent) is copied, rather than the symlink\&.  In older
+versions of rsync, this option also had the side-effect of telling the
+receiving side to follow symlinks, such as symlinks to directories\&.  In a
+modern rsync such as this one, you\&'ll need to specify --keep-dirlinks (-K)
+to get this extra behavior\&.  The only exception is when sending files to
+an rsync that is too old to understand -K -- in that case, the -L option
+will still have the side-effect of -K on that older receiving rsync\&.
 .IP 
 .IP "\fB--copy-unsafe-links\fP" 
 This tells rsync to copy the referent of
 symbolic links that point outside the copied tree\&.  Absolute symlinks
 are also treated like ordinary files, and so are any symlinks in the
 source path itself when --relative is used\&.
@@ -575,15 +650,15 @@
 This option can be quite slow, so only use it if you need it\&.
 .IP 
 .IP "\fB-W, --whole-file\fP" 
 With this option the incremental rsync algorithm
 is not used and the whole file is sent as-is instead\&.  The transfer may be
 faster if this option is used when the bandwidth between the source and
-target machines is higher than the bandwidth to disk (especially when the
+destination machines is higher than the bandwidth to disk (especially when the
 "disk" is actually a networked filesystem)\&.  This is the default when both
-the source and target are on the local machine\&.
+the source and destination are specified as local paths\&.
 .IP 
 .IP "\fB--no-whole-file\fP" 
 Turn off --whole-file, for use when it is the
 default\&.
 .IP 
 .IP "\fB-p, --perms\fP" 
@@ -617,15 +692,15 @@
 .IP 
 .IP "\fB-t, --times\fP" 
 This tells rsync to transfer modification times along
 with the files and update them on the remote system\&.  Note that if this
 option is not used, the optimization that excludes files that have not been
 modified cannot be effective; in other words, a missing -t or -a will
-cause the next transfer to behave as if it used -I, and all files will have
-their checksums compared and show up in log messages even if they haven\&'t
-changed\&.
+cause the next transfer to behave as if it used -I, causing all files to be
+updated (though the rsync algorithm will make the update fairly efficient
+if the files haven\&'t actually changed, you\&'re much better off using -t)\&.
 .IP 
 .IP "\fB-n, --dry-run\fP" 
 This tells rsync to not do any file transfers,
 instead it will just report the actions it would have taken\&.
 .IP 
 .IP "\fB-S, --sparse\fP" 
@@ -690,15 +765,16 @@
 .IP "\fB--force\fP" 
 This options tells rsync to delete directories even if
 they are not empty when they are to be replaced by non-directories\&.  This
 is only relevant without --delete because deletions are now done depth-first\&.
 Requires the --recursive option (which is implied by -a) to have any effect\&.
 .IP 
-.IP "\fB-B , --block-size=BLOCKSIZE\fP" 
-This controls the block size used in
-the rsync algorithm\&. See the technical report for details\&.
+.IP "\fB-B, --block-size=BLOCKSIZE\fP" 
+This forces the block size used in
+the rsync algorithm to a fixed value\&.  It is normally selected based on
+the size of each file being updated\&.  See the technical report for details\&.
 .IP 
 .IP "\fB-e, --rsh=COMMAND\fP" 
 This option allows you to choose an alternative
 remote shell program to use for communication between the local and
 remote copies of rsync\&. Typically, rsync is configured to use ssh by
 default, but you may prefer to use rsh on a local network\&.
@@ -777,18 +853,18 @@
 .IP 
 See the EXCLUDE PATTERNS section for detailed information on this option\&.
 .IP 
 .IP "\fB--include-from=FILE\fP" 
 This specifies a list of include patterns
 from a file\&.
-If \fIFILE\fP is \fB-\fP the list will be read from standard input\&.
+If \fIFILE\fP is "-" the list will be read from standard input\&.
 .IP 
 .IP "\fB--files-from=FILE\fP" 
 Using this option allows you to specify the
 exact list of files to transfer (as read from the specified FILE or "-"
-for stdin)\&.  It also tweaks the default behavior of rsync to make
+for standard input)\&.  It also tweaks the default behavior of rsync to make
 transferring just the specified files and directories easier\&.  For
 instance, the --relative option is enabled by default when this option
 is used (use --no-relative if you want to turn that off), all
 directories specified in the list are created on the destination (rather
 than being noisily skipped without -r), and the -a (--archive) option\&'s
 behavior does not imply -r (--recursive) -- specify it explicitly, if
@@ -846,33 +922,38 @@
 flash-cutover when all files have been successfully transferred (for
 example by moving directories around and removing the old directory,
 although this skips files that haven\&'t changed; see also --link-dest)\&.
 This option increases the usefulness of --partial because partially
 transferred files will remain in the new temporary destination until they
 have a chance to be completed\&.  If DIR is a relative path, it is relative
-to the destination directory (which changes in a recursive transfer)\&.
+to the destination directory\&.
 .IP 
 .IP "\fB--link-dest=DIR\fP" 
 This option behaves like \fB--compare-dest\fP but
 also will create hard links from \fIDIR\fP to the destination directory for
 unchanged files\&.  Files with changed ownership or permissions will not be
 linked\&.
-Like \fB--compare-dest\fP if DIR is a relative path, it is relative
-to the destination directory (which changes in a recursive transfer)\&.
 An example:
 .IP 
 
 .nf 
  
 
     rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/
 
 .fi 
  
 
 .IP 
+Like \fB--compare-dest\fP if DIR is a relative path, it is relative to the
+destination directory\&.
+Note that rsync versions prior to 2\&.6\&.1 had a bug that could prevent
+--link-dest from working properly for a non-root user when -o was specified
+(or implied by -a)\&.  If the receiving rsync is not new enough, you can work
+around this bug by avoiding the -o option\&.
+.IP 
 .IP "\fB-z, --compress\fP" 
 With this option, rsync compresses any data from
 the files that it sends to the destination machine\&.  This
 option is useful on slow connections\&.  The compression method used is the
 same method that gzip uses\&.
 .IP 
@@ -969,12 +1050,53 @@
 By default, rsync will delete any partially
 transferred file if the transfer is interrupted\&. In some circumstances
 it is more desirable to keep partially transferred files\&. Using the
 --partial option tells rsync to keep the partial file which should
 make a subsequent transfer of the rest of the file much faster\&.
 .IP 
+.IP "\fB--partial-dir=DIR\fP" 
+Turns on --partial mode, but tells rsync to
+put a partially transferred file into DIR instead of writing out the
+file to the destination dir\&.  Rsync will also use a file found in this
+dir as data to speed up the transfer (i\&.e\&. when you redo the send after
+rsync creates a partial file) and delete such a file after it has served
+its purpose\&.  Note that if --whole-file is specified (or implied) that an
+existing partial-dir file will not be used to speedup the transfer (since
+rsync is sending files without using the incremental rsync algorithm)\&.
+.IP 
+Rsync will create the dir if it is missing (just the last dir -- not the
+whole path)\&.  This makes it easy to use a relative path (such as
+"--partial-dir=\&.rsync-partial") to have rsync create the partial-directory
+in the destination file\&'s directory (rsync will also try to remove the DIR
+if a partial file was found to exist at the start of the transfer and the
+DIR was specified as a relative path)\&.
+.IP 
+If the partial-dir value is not an absolute path, rsync will also add an
+--exclude of this value at the end of all your existing excludes\&.  This
+will prevent partial-dir files from being transferred and also prevent the
+untimely deletion of partial-dir items on the receiving side\&.  An example:
+the above --partial-dir option would add an "--exclude=\&.rsync-partial/"
+rule at the end of any other include/exclude rules\&.  Note that if you are
+supplying your own include/exclude rules, you may need to manually insert a
+rule for this directory exclusion somewhere higher up in the list so that
+it has a high enough priority to be effective (e\&.g\&., if your rules specify
+a trailing --exclude=* rule, the auto-added rule will be ineffective)\&.
+.IP 
+IMPORTANT: the --partial-dir should not be writable by other users or it
+is a security risk\&.  E\&.g\&. AVOID "/tmp"\&.
+.IP 
+You can also set the partial-dir value the RSYNC_PARTIAL_DIR environment
+variable\&.  Setting this in the environment does not force --partial to be
+enabled, but rather it effects where partial files go when --partial (or
+-P) is used\&.  For instance, instead of specifying --partial-dir=\&.rsync-tmp
+along with --progress, you could set RSYNC_PARTIAL_DIR=\&.rsync-tmp in your
+environment and then just use the -P option to turn on the use of the
+\&.rsync-tmp dir for partial transfers\&.  The only time the --partial option
+does not look for this environment value is when --inplace was also
+specified (since --inplace conflicts with --partial-dir)\&.
+.IP 
 .IP "\fB--progress\fP" 
 This option tells rsync to print information
 showing the progress of the transfer\&. This gives a bored user
 something to watch\&.
 Implies --verbose without incrementing verbosity\&.
 .IP 
@@ -1011,15 +1133,15 @@
 transfer rate for the file, the amount of elapsed time it took to transfer
 the file, and the addition of a total-transfer summary in parentheses\&.
 These additional numbers tell you how many files have been updated, and
 what percent of the total number of files has been scanned\&.
 .IP 
 .IP "\fB-P\fP" 
-The -P option is equivalent to --partial --progress\&. I
-found myself typing that combination quite often so I created an
-option to make it easier\&.
+The -P option is equivalent to --partial --progress\&.  Its
+purpose is to make it much easier to specify these two options for a long
+transfer that may be interrupted\&.
 .IP 
 .IP "\fB--password-file\fP" 
 This option allows you to provide a password
 in a file for accessing a remote rsync server\&. Note that this option
 is only useful when accessing an rsync server using the built in
 transport, not when using a remote shell as the transport\&. The file
@@ -1032,21 +1154,43 @@
 using rsync with large files (several megabytes and up)\&. Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
 transfer was too fast, it will wait before sending the next data block\&. The
 result is an average transfer rate equaling the specified limit\&. A value
 of zero specifies no limit\&.
 .IP 
-.IP "\fB--write-batch=PREFIX\fP" 
-Generate a set of files that can be
-transferred as a batch update\&. Each filename in the set starts with
-PREFIX\&. See the "BATCH MODE" section for details\&.
-.IP 
-.IP "\fB--read-batch=PREFIX\fP" 
-Apply a previously generated change batch,
-using the fileset whose filenames start with PREFIX\&. See the "BATCH
-MODE" section for details\&.
+.IP "\fB--write-batch=FILE\fP" 
+Record a file that can later be applied to
+another identical destination with --read-batch\&. See the "BATCH MODE"
+section for details\&.
+.IP 
+.IP "\fB--read-batch=FILE\fP" 
+Apply all of the changes stored in FILE, a
+file previously generated by --write-batch\&.
+If \fIFILE\fP is "-" the batch data will be read from standard input\&.
+See the "BATCH MODE" section for details\&.
+.IP 
+.IP "\fB-4, --ipv4\fP or \fB-6, --ipv6\fP" 
+Tells rsync to prefer IPv4/IPv6
+when creating sockets\&.  This only affects sockets that rsync has direct
+control over, such as the outgoing socket when directly contacting an
+rsync daemon, or the incoming sockets that an rsync daemon uses to
+listen for connections\&.  One of these options may be required in older
+versions of Linux to work around an IPv6 bug in the kernel (if you see
+an "address already in use" error when nothing else is using the port,
+try specifying --ipv6 or --ipv4 when starting the daemon)\&.
+.IP 
+.IP "\fB--checksum-seed=NUM\fP" 
+Set the MD4 checksum seed to the integer
+NUM\&.  This 4 byte checksum seed is included in each block and file
+MD4 checksum calculation\&.  By default the checksum seed is generated
+by the server and defaults to the current time()\&.  This option
+is used to set a specific checksum seed, which is useful for
+applications that want repeatable block and file checksums, or
+in the case where the user wants a more random checksum seed\&.
+Note that setting NUM to 0 causes rsync to use the default of time()
+for checksum seed\&.
 .IP 
 .PP 
 .SH "EXCLUDE PATTERNS" 
 .PP 
 The exclude and include patterns specified to rsync allow for flexible
 selection of which files to transfer and which files to skip\&.
@@ -1240,99 +1384,137 @@
 only foo/bar\&.c (the foo/ directory must be explicitly included or
 it would be excluded by the "*")
 .PP 
 .SH "BATCH MODE" 
 .PP 
 \fBNote:\fP Batch mode should be considered experimental in this version
-of rsync\&. The interface or behavior may change before it stabilizes\&.
+of rsync\&. The interface and behavior have now stabilized, though, so
+feel free to try this out\&.
 .PP 
 Batch mode can be used to apply the same set of updates to many
 identical systems\&. Suppose one has a tree which is replicated on a
 number of hosts\&.  Now suppose some changes have been made to this
 source tree and those changes need to be propagated to the other
 hosts\&. In order to do this using batch mode, rsync is run with the
 write-batch option to apply the changes made to the source tree to one
 of the destination trees\&.  The write-batch option causes the rsync
-client to store the information needed to repeat this operation against
-other destination trees in a batch update fileset (see below)\&.  The
-filename of each file in the fileset starts with a prefix specified by
-the user as an argument to the write-batch option\&.  This fileset is
-then copied to each remote host, where rsync is run with the read-batch
-option, again specifying the same prefix, and the destination tree\&.
-Rsync updates the destination tree using the information stored in the
-batch update fileset\&.
+client to store in a "batch file" all the information needed to repeat
+this operation against other, identical destination trees\&.
 .PP 
-The fileset consists of 4 files:
+To apply the recorded changes to another destination tree, run rsync
+with the read-batch option, specifying the name of the same batch
+file, and the destination tree\&.  Rsync updates the destination tree
+using the information stored in the batch file\&.
+.PP 
+For convenience, one additional file is creating when the write-batch
+option is used\&.  This file\&'s name is created by appending
+"\&.sh" to the batch filename\&.  The \&.sh file contains
+a command-line suitable for updating a destination tree using that
+batch file\&. It can be executed using a Bourne(-like) shell, optionally
+passing in an alternate destination tree pathname which is then used
+instead of the original path\&. This is useful when the destination tree
+path differs from the original destination tree path\&.
 .PP 
-.IP o 
-\fB<prefix>\&.rsync_argvs\fP command-line arguments
-.IP o 
-\fB<prefix>\&.rsync_flist\fP rsync internal file metadata
-.IP o 
-\fB<prefix>\&.rsync_csums\fP rsync checksums
-.IP o 
-\fB<prefix>\&.rsync_delta\fP data blocks for file update & change
-.PP 
-The \&.rsync_argvs file contains a command-line suitable for updating a
-destination tree using that batch update fileset\&. It can be executed
-using a Bourne(-like) shell, optionally passing in an alternate
-destination tree pathname which is then used instead of the original
-path\&. This is useful when the destination tree path differs from the
-original destination tree path\&.
-.PP 
-Generating the batch update fileset once saves having to perform the
-file status, checksum and data block generation more than once when
+Generating the batch file once saves having to perform the file
+status, checksum, and data block generation more than once when
 updating multiple destination trees\&. Multicast transport protocols can
-be used to transfer the batch update files in parallel to many hosts at
-once, instead of sending the same data to every host individually\&.
+be used to transfer the batch update files in parallel to many hosts
+at once, instead of sending the same data to every host individually\&.
 .PP 
-Example:
+Examples:
+.PP 
+
+.nf 
+ 
+
+   $ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/
+   $ scp foo* remote:
+   $ ssh remote \&./foo\&.sh /bdest/dir/
+
+.fi 
+ 
+
 .PP 
 
 .nf 
  
 
-   $ rsync --write-batch=pfx -a /source/dir/ /adest/dir/
-   $ rcp pfx\&.rsync_* remote:
-   $ ssh remote rsync --read-batch=pfx -a /bdest/dir/
-   # or alternatively
-   $ ssh remote \&./pfx\&.rsync_argvs /bdest/dir/
+   $ rsync --write-batch=foo -a /source/dir/ /adest/dir/
+   $ ssh remote rsync --read-batch=- -a /bdest/dir/ <foo
 
 .fi 
  
 
 .PP 
-In this example, rsync is used to update /adest/dir/ with /source/dir/
-and the information to repeat this operation is stored in the files
-pfx\&.rsync_*\&. These files are then copied to the machine named "remote"\&.
-Rsync is then invoked on "remote" to update /bdest/dir/ the same way as
-/adest/dir/\&. The last line shows the rsync_argvs file being used to
-invoke rsync\&.
+In these examples, rsync is used to update /adest/dir/ from /source/dir/
+and the information to repeat this operation is stored in "foo" and
+"foo\&.sh"\&.  The host "remote" is then updated with the batched data going
+into the directory /bdest/dir\&.  The differences between the two examples
+reveals some of the flexibility you have in how you deal with batches:
+.PP 
+.IP 
+.IP o 
+The first example shows that the initial copy doesn\&'t have to be
+local -- you can push or pull data to/from a remote host using either the
+remote-shell syntax or rsync daemon syntax, as desired\&.
+.IP 
+.IP o 
+The first example uses the created "foo\&.sh" file to get the right
+rsync options when running the read-batch command on the remote host\&.
+.IP 
+.IP o 
+The second example reads the batch data via standard input so that
+the batch file doesn\&'t need to be copied to the remote machine first\&.
+This example avoids the foo\&.sh script because it needed to use a modified
+--read-batch option, but you could edit the script file if you wished to
+make use of it (just be sure that no other option is trying to use
+standard input, such as the "--exclude-from=-" option)\&.
+.IP 
 .PP 
 Caveats:
 .PP 
-The read-batch option expects the destination tree it is meant to update
+The read-batch option expects the destination tree that it is updating
 to be identical to the destination tree that was used to create the
 batch update fileset\&.  When a difference between the destination trees
-is encountered the update will fail at that point, leaving the
-destination tree in a partially updated state\&. In that case, rsync can
+is encountered the update might be discarded with no error (if the file
+appears to be up-to-date already) or the file-update may be attempted
+and then, if the file fails to verify, the update discarded with an
+error\&.  This means that it should be safe to re-run a read-batch operation
+if the command got interrupted\&.  If you wish to force the batched-update to
+always be attempted regardless of the file\&'s size and date, use the -I
+option (when reading the batch)\&.
+If an error occurs, the destination tree will probably be in a
+partially updated state\&. In that case, rsync can
 be used in its regular (non-batch) mode of operation to fix up the
 destination tree\&.
 .PP 
-The rsync version used on all destinations should be identical to the
-one used on the original destination\&.
+The rsync version used on all destinations must be at least as new as the
+one used to generate the batch file\&.  Rsync will die with an error if the
+protocol version in the batch file is too new for the batch-reading rsync
+to handle\&.
 .PP 
-The -z/--compress option does not work in batch mode and yields a usage
-error\&. A separate compression tool can be used instead to reduce the
-size of the batch update files for transport to the destination\&.
-.PP 
-The -n/--dryrun option does not work in batch mode and yields a runtime
+The --dry-run (-n) option does not work in batch mode and yields a runtime
 error\&.
 .PP 
-See \fBhttp://www\&.ils\&.unc\&.edu/i2dsi/unc_rsync+\&.html\fP for papers and technical
-reports\&.
+When reading a batch file, rsync will force the value of certain options
+to match the data in the batch file if you didn\&'t set them to the same
+as the batch-writing command\&.  Other options can (and should) be changed\&.
+For instance
+--write-batch changes to --read-batch, --files-from is dropped, and the
+--include/--exclude options are not needed unless --delete is specified
+without --delete-excluded\&.
+.PP 
+The code that creates the BATCH\&.sh file transforms any include/exclude
+options into a single list that is appended as a "here" document to the
+shell script file\&.  An advanced user can use this to modify the exclude
+list if a change in what gets deleted by --delete is desired\&.  A normal
+user can ignore this detail and just use the shell script as an easy way
+to run the appropriate --read-batch command for the batched data\&.
+.PP 
+The original batch mode in rsync was based on "rsync+", but the latest
+version uses a new implementation\&.
 .PP 
 .SH "SYMBOLIC LINKS" 
 .PP 
 Three basic behaviors are possible when rsync encounters a symbolic
 link in the source directory\&.
 .PP 
@@ -1513,13 +1695,13 @@
 .PP 
 Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
 and David Bell for helpful suggestions, patches and testing of rsync\&.
 I\&'ve probably missed some people, my apologies if I have\&.
 .PP 
 Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer,
-Martin Pool, Wayne Davison\&.
+Martin Pool, Wayne Davison, J\&.W\&. Schultz\&.
 .PP 
 .SH "AUTHOR" 
 .PP 
 rsync was originally written by Andrew Tridgell and Paul Mackerras\&.
 Many people have later contributed to it\&.
 .PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsync.c	2004-03-24 00:16:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsync.c	2004-09-08 04:37:36.000000000 +0800
@@ -23,19 +23,22 @@
 #include "rsync.h"
 
 extern int verbose;
 extern int dry_run;
 extern int preserve_times;
 extern int am_root;
-extern int am_server;
 extern int am_sender;
 extern int am_generator;
 extern int preserve_uid;
 extern int preserve_gid;
-extern int preserve_perms;
+extern int force_delete;
+extern int recurse;
+extern int keep_dirlinks;
 extern int make_backups;
+extern char *backup_dir;
+extern int inplace;
 
 
 /*
   free a sums struct
   */
 void free_sums(struct sum_struct *s)
@@ -51,106 +54,108 @@
  */
 int delete_file(char *fname)
 {
 	DIR *d;
 	struct dirent *di;
 	char buf[MAXPATHLEN];
-	extern int force_delete;
 	STRUCT_STAT st;
 	int ret;
-	extern int recurse;
 
 #if SUPPORT_LINKS
 	ret = do_lstat(fname, &st);
 #else
 	ret = do_stat(fname, &st);
 #endif
 	if (ret)
 		return -1;
 
 	if (!S_ISDIR(st.st_mode)) {
 		if (robust_unlink(fname) == 0 || errno == ENOENT)
 			return 0;
-		rprintf(FERROR, "delete_file: unlink %s failed: %s\n",
-			full_fname(fname), strerror(errno));
+		rsyserr(FERROR, errno, "delete_file: unlink %s failed",
+			full_fname(fname));
 		return -1;
 	}
 
 	if (do_rmdir(fname) == 0 || errno == ENOENT)
 		return 0;
 	if (!force_delete || !recurse
 	    || (errno != ENOTEMPTY && errno != EEXIST)) {
-		rprintf(FERROR, "delete_file: rmdir %s failed: %s\n",
-			full_fname(fname), strerror(errno));
+		rsyserr(FERROR, errno, "delete_file: rmdir %s failed",
+			full_fname(fname));
 		return -1;
 	}
 
 	/* now we do a recsursive delete on the directory ... */
 	if (!(d = opendir(fname))) {
-		rprintf(FERROR, "delete_file: opendir %s failed: %s\n",
-			full_fname(fname), strerror(errno));
+		rsyserr(FERROR, errno, "delete_file: opendir %s failed",
+			full_fname(fname));
 		return -1;
 	}
 
 	for (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {
 		char *dname = d_name(di);
 		if (dname[0] == '.' && (dname[1] == '\0'
 		    || (dname[1] == '.' && dname[2] == '\0')))
 			continue;
 		pathjoin(buf, sizeof buf, fname, dname);
 		if (verbose > 0)
-			rprintf(FINFO, "deleting %s\n", buf);
+			rprintf(FINFO, "deleting %s\n", safe_fname(buf));
 		if (delete_file(buf) != 0) {
 			closedir(d);
 			return -1;
 		}
 	}
 	if (errno) {
-		rprintf(FERROR, "delete_file: readdir %s failed: %s\n",
-			full_fname(fname), strerror(errno));
+		rsyserr(FERROR, errno, "delete_file: readdir %s failed",
+			full_fname(fname));
 		closedir(d);
 		return -1;
 	}
 
 	closedir(d);
 
 	if (do_rmdir(fname) != 0) {
-		rprintf(FERROR, "delete_file: rmdir %s failed: %s\n",
-			full_fname(fname), strerror(errno));
+		rsyserr(FERROR, errno, "delete_file: rmdir %s failed",
+			full_fname(fname));
 		return -1;
 	}
 
 	return 0;
 }
 
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
-		int report)
+	      int flags)
 {
 	int updated = 0;
 	STRUCT_STAT st2;
 	int change_uid, change_gid;
 
-	if (dry_run) return 0;
+	if (dry_run)
+		return 0;
 
 	if (!st) {
-		if (link_stat(fname,&st2) != 0) {
-			rprintf(FERROR, "stat %s failed: %s\n",
-				full_fname(fname), strerror(errno));
+		if (link_stat(fname, &st2, 0) < 0) {
+			rsyserr(FERROR, errno, "stat %s failed",
+				full_fname(fname));
 			return 0;
 		}
 		st = &st2;
 	}
 
-	if (preserve_times && !S_ISLNK(st->st_mode) &&
-	    cmp_modtime(st->st_mtime, file->modtime) != 0) {
+	if (!preserve_times || S_ISLNK(st->st_mode)
+	    || (make_backups && !backup_dir && S_ISDIR(st->st_mode)))
+		flags |= PERMS_SKIP_MTIME;
+	if (!(flags & PERMS_SKIP_MTIME)
+	    && cmp_modtime(st->st_mtime, file->modtime) != 0) {
 		/* don't complain about not setting times on directories
 		 * because some filesystems can't do it */
 		if (set_modtime(fname,file->modtime) != 0 &&
 		    !S_ISDIR(st->st_mode)) {
-			rprintf(FERROR, "failed to set times on %s: %s\n",
-				full_fname(fname), strerror(errno));
+			rsyserr(FERROR, errno, "failed to set times on %s",
+				full_fname(fname));
 			return 0;
 		}
 		updated = 1;
 	}
 
 	change_uid = am_root && preserve_uid && st->st_uid != file->uid;
@@ -171,40 +176,41 @@
 		}
 		if (do_lchown(fname,
 		    change_uid ? file->uid : st->st_uid,
 		    change_gid ? file->gid : st->st_gid) != 0) {
 			/* shouldn't have attempted to change uid or gid
 			 * unless have the privilege */
-			rprintf(FERROR, "%s %s failed: %s\n",
+			rsyserr(FERROR, errno, "%s %s failed",
 			    change_uid ? "chown" : "chgrp",
-			    full_fname(fname), strerror(errno));
+			    full_fname(fname));
 			return 0;
 		}
 		/* a lchown had been done - we have to re-stat if the
                  * destination had the setuid or setgid bits set due
                  * to the side effect of the chown call */
 		if (st->st_mode & (S_ISUID | S_ISGID)) {
-			link_stat(fname, st);
+			link_stat(fname, st,
+				  keep_dirlinks && S_ISDIR(st->st_mode));
 		}
 		updated = 1;
 	}
 
 #ifdef HAVE_CHMOD
 	if (!S_ISLNK(st->st_mode)) {
 		if ((st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS)) {
 			updated = 1;
 			if (do_chmod(fname,(file->mode & CHMOD_BITS)) != 0) {
-				rprintf(FERROR, "failed to set permissions on %s: %s\n",
-					full_fname(fname), strerror(errno));
+				rsyserr(FERROR, errno, "failed to set permissions on %s",
+					full_fname(fname));
 				return 0;
 			}
 		}
 	}
 #endif
 
-	if (verbose > 1 && report) {
+	if (verbose > 1 && flags & PERMS_REPORT) {
 		if (updated)
 			rprintf(FINFO,"%s\n",fname);
 		else
 			rprintf(FINFO,"%s is uptodate\n",fname);
 	}
 	return updated;
@@ -225,29 +231,46 @@
 	exit_cleanup(RERR_SIGNAL);
 }
 
 
 /* finish off a file transfer, renaming the file and setting the permissions
    and ownership */
-void finish_transfer(char *fname, char *fnametmp, struct file_struct *file)
+void finish_transfer(char *fname, char *fnametmp, struct file_struct *file,
+		     int ok_to_set_time)
 {
 	int ret;
 
+	if (inplace) {
+		if (verbose > 2)
+			rprintf(FINFO, "finishing %s\n", fname);
+		goto do_set_perms;
+	}
+
 	if (make_backups && !make_backup(fname))
 		return;
 
+	/* Change permissions before putting the file into place. */
+	set_perms(fnametmp, file, NULL, ok_to_set_time ? 0 : PERMS_SKIP_MTIME);
+
 	/* move tmp file over real file */
+	if (verbose > 2)
+		rprintf(FINFO, "renaming %s to %s\n", fnametmp, fname);
 	ret = robust_rename(fnametmp, fname, file->mode & INITACCESSPERMS);
 	if (ret < 0) {
-		rprintf(FERROR, "%s %s -> \"%s\": %s\n",
+		rsyserr(FERROR, errno, "%s %s -> \"%s\"",
 		    ret == -2 ? "copy" : "rename",
-		    full_fname(fnametmp), fname, strerror(errno));
+		    full_fname(fnametmp), fname);
 		do_unlink(fnametmp);
-	} else {
-		set_perms(fname,file,NULL,0);
+		return;
+	}
+	if (ret == 0) {
+		/* The file was moved into place (not copied), so it's done. */
+		return;
 	}
+    do_set_perms:
+	set_perms(fname, file, NULL, ok_to_set_time ? 0 : PERMS_SKIP_MTIME);
 }
 
 const char *who_am_i(void)
 {
-    return am_sender ? "sender" : am_generator ? "generator" : "receiver";
+	return am_sender ? "sender" : am_generator ? "generator" : "receiver";
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsyncd.conf.5	2004-05-01 02:02:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsyncd.conf.5	2004-10-01 00:36:04.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsyncd\&.conf" "5" "30 Apr 2004" "" "" 
+.TH "rsyncd\&.conf" "5" "30 Sep 2004" "" "" 
 .SH "NAME" 
 rsyncd\&.conf \- configuration file for rsync server
 .SH "SYNOPSIS" 
 .PP 
 rsyncd\&.conf
 .PP 
@@ -139,14 +139,14 @@
 .IP 
 .IP "\fBuse chroot\fP" 
 If "use chroot" is true, the rsync server will chroot
 to the "path" before starting the file transfer with the client\&.  This has
 the advantage of extra protection against possible implementation security
 holes, but it has the disadvantages of requiring super-user privileges, 
-of not being able to follow symbolic links outside of the new root path
-when reading, and of complicating the preservation of usernames and groups
+of not being able to follow symbolic links that are either absolute or outside
+of the new root path, and of complicating the preservation of usernames and groups
 (see below)\&.  When "use chroot" is false, for security reasons,
 symlinks may only be relative paths pointing to other files within the root
 path, and leading slashes are removed from most absolute paths (options
 such as --backup-dir, --compare-dest, etc\&. interpret an absolute path as
 rooted in the module\&'s "path" dir, just as if chroot was specified)\&.
 The default for "use chroot" is true\&.
@@ -159,18 +159,17 @@
 /etc/group)\&.  If these resources are not available, rsync will only be
 able to copy the IDs, just as if the --numeric-ids option had been
 specified\&.
 .IP 
 Note that you are free to setup user/group information in the chroot area
 differently from your normal system\&.  For example, you could abbreviate
-the list of users and groups\&.  Also, you can protect this information
-from being downloaded by adding an exclude rule to the rsync\&.conf file
-(e\&.g\&. "exclude = /etc/")\&.  To protect it from being changed by an upload
-(if the module is not read only), be sure to set the permissions (or
-owner) on the files and/or parent directories so that they cannot be
-written by the daemon\&.
+the list of users and groups\&.  Also, you can protect this information from
+being downloaded/uploaded by adding an exclude rule to the rsync\&.conf file
+(e\&.g\&. "exclude = /etc/")\&.  Note that having the exclusion affect uploads
+is a relatively new feature in rsync, so make sure your server is running
+at least 2\&.6\&.3 to effect this\&.
 .IP 
 .IP "\fBmax connections\fP" 
 The "max connections" option allows you to
 specify the maximum number of simultaneous connections you will allow\&.
 Any clients connecting when the maximum has been reached will receive a
 message telling them to try later\&.  The default is 0 which means no limit\&.
@@ -187,12 +186,19 @@
 The "read only" option determines whether clients
 will be able to upload files or not\&. If "read only" is true then any
 attempted uploads will fail\&. If "read only" is false then uploads will
 be possible if file permissions on the server allow them\&. The default
 is for all modules to be read only\&.
 .IP 
+.IP "\fBwrite only\fP" 
+The "write only" option determines whether clients
+will be able to download files or not\&. If "write only" is true then any
+attempted downloads will fail\&. If "write only" is false then downloads
+will be possible if file permissions on the server allow them\&.  The
+default is for this option to be disabled\&.
+.IP 
 .IP "\fBlist\fP" 
 The "list" option determines if this module should be
 listed when the client asks for a listing of available modules\&. By
 setting this to false you can create hidden modules\&. The default is
 for modules to be listable\&.
 .IP 
@@ -207,58 +213,52 @@
 The "gid" option specifies the group name or group ID that
 file transfers to and from that module should take place as when the daemon
 was run as root\&. This complements the "uid" option\&. The default is gid -2,
 which is normally the group "nobody"\&.
 .IP 
 .IP "\fBexclude\fP" 
-The "exclude" option allows you to specify a space
-separated list of patterns to add to the exclude list\&.
-This is only superficially equivalent
-to the client specifying these patterns with the --exclude option\&.
-Only one "exclude" option may be specified, but
-you can use "-" and "+" before patterns to specify exclude/include\&.
+The "exclude" option allows you to specify a
+space-separated list of patterns that the server will not allow to be read
+or written\&.  This is only superficially equivalent to the client
+specifying these patterns with the --exclude option\&.  Only one "exclude"
+option may be specified, but you can use "-" and "+" before patterns to
+specify exclude/include\&.
 .IP 
 Because this exclude list is not passed to the client it only applies on
 the server: that is, it excludes files received by a client when receiving
 from a server and files deleted on a server when sending to a server, but
-it doesn\&'t exclude files sent from a client when sending to a server or
-files deleted on a client when receiving from a server\&.  
-.IP 
-Note that this option is not designed with strong security in
-mind, it is quite possible that a client may find a way to bypass this
-exclude list\&. If you want to absolutely ensure that certain files
-cannot be accessed then use the uid/gid options in combination with
-file permissions\&.
+it doesn\&'t exclude files from being deleted on a client when receiving
+from a server\&.  
 .IP 
 .IP "\fBexclude from\fP" 
 The "exclude from" option specifies a filename
 on the server that contains exclude patterns, one per line\&.
 This is only superficially equivalent
 to the client specifying the --exclude-from option with an equivalent file\&.
 See the "exclude" option above\&.
 .IP 
 .IP "\fBinclude\fP" 
-The "include" option allows you to specify a space
-separated list of patterns which rsync should not exclude\&. This is
-only superficially equivalent to the client specifying these patterns
-with the --include option because it applies only on the server\&.
-This is useful as it
-allows you to build up quite complex exclude/include rules\&.  Only one
-"include" option may be specified, but you can use "+" and "-" before
-patterns to switch include/exclude\&.  See the "exclude" option above\&.
+The "include" option allows you to specify a
+space-separated list of patterns which rsync should not exclude\&. This is
+only superficially equivalent to the client specifying these patterns with
+the --include option because it applies only on the server\&.  This is
+useful as it allows you to build up quite complex exclude/include rules\&.
+Only one "include" option may be specified, but you can use "+" and "-"
+before patterns to switch include/exclude\&.  See the "exclude" option
+above\&.
 .IP 
 .IP "\fBinclude from\fP" 
 The "include from" option specifies a filename
 on the server that contains include patterns, one per line\&. This is
 only superficially equivalent to the client specifying the
 --include-from option with a equivalent file\&.
 See the "exclude" option above\&.
 .IP 
 .IP "\fBauth users\fP" 
 The "auth users" option specifies a comma and
-space separated list of usernames that will be allowed to connect to
+space-separated list of usernames that will be allowed to connect to
 this module\&. The usernames do not need to exist on the local
 system\&. The usernames may also contain shell wildcard characters\&. If
 "auth users" is set then the client will be challenged to supply a
 username and password to connect to the module\&. A challenge response
 authentication protocol is used for this exchange\&. The plain text
 usernames are passwords are stored in the file specified by the
@@ -425,28 +425,36 @@
 is specified in seconds\&. A value of zero means no timeout and is the
 default\&. A good choice for anonymous rsync servers may be 600 (giving
 a 10 minute timeout)\&.
 .IP 
 .IP "\fBrefuse options\fP" 
 The "refuse options" option allows you to
-specify a space separated list of rsync command line options that will
-be refused by your rsync server\&.  The full names of the options must be
-used (i\&.e\&., you must use "checksum" not "c" to disable checksumming)\&.  
+specify a space-separated list of rsync command line options that will
+be refused by your rsync server\&.
+You may specify the full option name, its one-letter abbreviation, or a
+wild-card string that matches multiple options\&.
+For example, this would refuse --checksum (-c) and all the options that
+start with "delete":
+.IP 
+.RS 
+refuse options = c delete*
+.RE 
+.IP 
 When an option is refused, the server prints an error message and exits\&.
 To prevent all compression, you can use "dont compress = *" (see below)
 instead of "refuse options = compress" to avoid returning an error to a
 client that requests compression\&.
 .IP 
 .IP "\fBdont compress\fP" 
 The "dont compress" option allows you to select
 filenames based on wildcard patterns that should not be compressed
 during transfer\&. Compression is expensive in terms of CPU usage so it
 is usually good to not try to compress files that won\&'t compress well,
 such as already compressed files\&. 
 .IP 
-The "dont compress" option takes a space separated list of
+The "dont compress" option takes a space-separated list of
 case-insensitive wildcard patterns\&. Any source filename matching one
 of the patterns will not be compressed during transfer\&.
 .IP 
 The default setting is 
 .nf 
  
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsyncd.conf.yo	2004-05-01 02:02:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsyncd.conf.yo	2004-10-01 00:35:56.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(30 Apr 2004)()()
+manpage(rsyncd.conf)(5)(30 Sep 2004)()()
 manpagename(rsyncd.conf)(configuration file for rsync server)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -131,14 +131,14 @@
 for each module in tt(rsyncd.conf).
 
 dit(bf(use chroot)) If "use chroot" is true, the rsync server will chroot
 to the "path" before starting the file transfer with the client.  This has
 the advantage of extra protection against possible implementation security
 holes, but it has the disadvantages of requiring super-user privileges, 
-of not being able to follow symbolic links outside of the new root path
-when reading, and of complicating the preservation of usernames and groups
+of not being able to follow symbolic links that are either absolute or outside
+of the new root path, and of complicating the preservation of usernames and groups
 (see below).  When "use chroot" is false, for security reasons,
 symlinks may only be relative paths pointing to other files within the root
 path, and leading slashes are removed from most absolute paths (options
 such as --backup-dir, --compare-dest, etc. interpret an absolute path as
 rooted in the module's "path" dir, just as if chroot was specified).
 The default for "use chroot" is true.
@@ -151,18 +151,17 @@
 /etc/group).  If these resources are not available, rsync will only be
 able to copy the IDs, just as if the --numeric-ids option had been
 specified.
 
 Note that you are free to setup user/group information in the chroot area
 differently from your normal system.  For example, you could abbreviate
-the list of users and groups.  Also, you can protect this information
-from being downloaded by adding an exclude rule to the rsync.conf file
-(e.g. "exclude = /etc/").  To protect it from being changed by an upload
-(if the module is not read only), be sure to set the permissions (or
-owner) on the files and/or parent directories so that they cannot be
-written by the daemon.
+the list of users and groups.  Also, you can protect this information from
+being downloaded/uploaded by adding an exclude rule to the rsync.conf file
+(e.g. "exclude = /etc/").  Note that having the exclusion affect uploads
+is a relatively new feature in rsync, so make sure your server is running
+at least 2.6.3 to effect this.
 
 dit(bf(max connections)) The "max connections" option allows you to
 specify the maximum number of simultaneous connections you will allow.
 Any clients connecting when the maximum has been reached will receive a
 message telling them to try later.  The default is 0 which means no limit.
 See also the "lock file" option.
@@ -176,12 +175,18 @@
 dit(bf(read only)) The "read only" option determines whether clients
 will be able to upload files or not. If "read only" is true then any
 attempted uploads will fail. If "read only" is false then uploads will
 be possible if file permissions on the server allow them. The default
 is for all modules to be read only.
 
+dit(bf(write only)) The "write only" option determines whether clients
+will be able to download files or not. If "write only" is true then any
+attempted downloads will fail. If "write only" is false then downloads
+will be possible if file permissions on the server allow them.  The
+default is for this option to be disabled.
+
 dit(bf(list)) The "list" option determines if this module should be
 listed when the client asks for a listing of available modules. By
 setting this to false you can create hidden modules. The default is
 for modules to be listable.
 
 dit(bf(uid)) The "uid" option specifies the user name or user ID that
@@ -192,54 +197,48 @@
 
 dit(bf(gid)) The "gid" option specifies the group name or group ID that
 file transfers to and from that module should take place as when the daemon
 was run as root. This complements the "uid" option. The default is gid -2,
 which is normally the group "nobody".
 
-dit(bf(exclude)) The "exclude" option allows you to specify a space
-separated list of patterns to add to the exclude list.
-This is only superficially equivalent
-to the client specifying these patterns with the --exclude option.
-Only one "exclude" option may be specified, but
-you can use "-" and "+" before patterns to specify exclude/include.
+dit(bf(exclude)) The "exclude" option allows you to specify a
+space-separated list of patterns that the server will not allow to be read
+or written.  This is only superficially equivalent to the client
+specifying these patterns with the --exclude option.  Only one "exclude"
+option may be specified, but you can use "-" and "+" before patterns to
+specify exclude/include.
 
 Because this exclude list is not passed to the client it only applies on
 the server: that is, it excludes files received by a client when receiving
 from a server and files deleted on a server when sending to a server, but
-it doesn't exclude files sent from a client when sending to a server or
-files deleted on a client when receiving from a server.  
-
-Note that this option is not designed with strong security in
-mind, it is quite possible that a client may find a way to bypass this
-exclude list. If you want to absolutely ensure that certain files
-cannot be accessed then use the uid/gid options in combination with
-file permissions.
+it doesn't exclude files from being deleted on a client when receiving
+from a server.  
 
 dit(bf(exclude from)) The "exclude from" option specifies a filename
 on the server that contains exclude patterns, one per line.
 This is only superficially equivalent
 to the client specifying the --exclude-from option with an equivalent file.
 See the "exclude" option above.
 
-dit(bf(include)) The "include" option allows you to specify a space
-separated list of patterns which rsync should not exclude. This is
-only superficially equivalent to the client specifying these patterns
-with the --include option because it applies only on the server.
-This is useful as it
-allows you to build up quite complex exclude/include rules.  Only one
-"include" option may be specified, but you can use "+" and "-" before
-patterns to switch include/exclude.  See the "exclude" option above.
+dit(bf(include)) The "include" option allows you to specify a
+space-separated list of patterns which rsync should not exclude. This is
+only superficially equivalent to the client specifying these patterns with
+the --include option because it applies only on the server.  This is
+useful as it allows you to build up quite complex exclude/include rules.
+Only one "include" option may be specified, but you can use "+" and "-"
+before patterns to switch include/exclude.  See the "exclude" option
+above.
 
 dit(bf(include from)) The "include from" option specifies a filename
 on the server that contains include patterns, one per line. This is
 only superficially equivalent to the client specifying the
 --include-from option with a equivalent file.
 See the "exclude" option above.
 
 dit(bf(auth users)) The "auth users" option specifies a comma and
-space separated list of usernames that will be allowed to connect to
+space-separated list of usernames that will be allowed to connect to
 this module. The usernames do not need to exist on the local
 system. The usernames may also contain shell wildcard characters. If
 "auth users" is set then the client will be challenged to supply a
 username and password to connect to the module. A challenge response
 authentication protocol is used for this exchange. The plain text
 usernames are passwords are stored in the file specified by the
@@ -377,27 +376,33 @@
 can ensure that rsync won't wait on a dead client forever. The timeout
 is specified in seconds. A value of zero means no timeout and is the
 default. A good choice for anonymous rsync servers may be 600 (giving
 a 10 minute timeout).
 
 dit(bf(refuse options)) The "refuse options" option allows you to
-specify a space separated list of rsync command line options that will
-be refused by your rsync server.  The full names of the options must be
-used (i.e., you must use "checksum" not "c" to disable checksumming).  
+specify a space-separated list of rsync command line options that will
+be refused by your rsync server.
+You may specify the full option name, its one-letter abbreviation, or a
+wild-card string that matches multiple options.
+For example, this would refuse --checksum (-c) and all the options that
+start with "delete":
+
+quote(refuse options = c delete*)
+
 When an option is refused, the server prints an error message and exits.
 To prevent all compression, you can use "dont compress = *" (see below)
 instead of "refuse options = compress" to avoid returning an error to a
 client that requests compression.
 
 dit(bf(dont compress)) The "dont compress" option allows you to select
 filenames based on wildcard patterns that should not be compressed
 during transfer. Compression is expensive in terms of CPU usage so it
 is usually good to not try to compress files that won't compress well,
 such as already compressed files. 
 
-The "dont compress" option takes a space separated list of
+The "dont compress" option takes a space-separated list of
 case-insensitive wildcard patterns. Any source filename matching one
 of the patterns will not be compressed during transfer.
 
 The default setting is verb(*.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz)
 
 enddit()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsync.h	2004-04-27 09:36:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsync.h	2004-09-22 12:10:10.000000000 +0800
@@ -105,28 +105,35 @@
 #define ALL_EXCLUDES	2
 
 #define XFLG_FATAL_ERRORS	(1<<0)
 #define XFLG_DEF_INCLUDE	(1<<1)
 #define XFLG_WORDS_ONLY 	(1<<2)
 #define XFLG_WORD_SPLIT 	(1<<3)
+#define XFLG_DIRECTORY	 	(1<<4)
+
+#define PERMS_REPORT		(1<<0)
+#define PERMS_SKIP_MTIME	(1<<1)
 
 #define FULL_FLUSH	1
 #define NORMAL_FLUSH	0
 
+#define PDIR_CREATE	1
+#define PDIR_DELETE	0
+
 
 /* Log-message categories.  FLOG is only used on the daemon side to
  * output messages to the log file. */
 enum logcode { FERROR=1, FINFO=2, FLOG=3 };
 
 /* Messages types that are sent over the message channel.  The logcode
  * values must all be present here with identical numbers. */
 enum msgcode {
-	MSG_DATA=0,	/* raw data on the multiplexed stream */
-	MSG_ERROR=FERROR, MSG_INFO=FINFO, MSG_LOG=FLOG, /* remote logging */
-	MSG_REDO=4,	/* reprocess indicated flist index */
 	MSG_DONE=5,	/* current phase is done */
+	MSG_REDO=4,	/* reprocess indicated flist index */
+	MSG_ERROR=FERROR, MSG_INFO=FINFO, MSG_LOG=FLOG, /* remote logging */
+	MSG_DATA=0	/* raw data on the multiplexed stream */
 };
 
 #include "errcode.h"
 
 #include "config.h"
 
@@ -306,13 +313,13 @@
 #define int64 int
 #elif HAVE_LONGLONG
 #define int64 long long
 #else
 /* As long as it gets... */
 #define int64 off_t
-#define NO_INT64
+#define INT64_IS_OFF_T
 #endif
 
 #if (SIZEOF_LONG == 8) 
 #define uint64 unsigned long
 #elif (SIZEOF_INT == 8) 
 #define uint64 unsigned int
@@ -385,13 +392,13 @@
 #endif
 
 #ifndef IN_LOOPBACKNET
 #define IN_LOOPBACKNET 127
 #endif
 
-#define GID_NONE (gid_t) -1
+#define GID_NONE ((gid_t)-1)
 
 #define HL_CHECK_MASTER	0
 #define HL_SKIP		1
 
 struct hlink {
 	int hlindex;
@@ -452,17 +459,19 @@
 	int malloced;
 	alloc_pool_t file_pool;
 	alloc_pool_t hlink_pool;
 	struct file_struct **files;
 };
 
+#define SUMFLG_SAME_OFFSET	(1<<0)
+
 struct sum_buf {
 	OFF_T offset;		/**< offset in file of this chunk */
 	unsigned int len;	/**< length of chunk of file */
-	int i;			/**< index of this chunk */
 	uint32 sum1;	        /**< simple checksum */
+	short flags;		/**< flag bits */
 	char sum2[SUM_LENGTH];	/**< checksum  */
 };
 
 struct sum_struct {
 	OFF_T flength;		/**< total file length */
 	size_t count;		/**< how many chunks */
@@ -472,33 +481,32 @@
 	struct sum_buf *sums;	/**< points to info for each chunk */
 };
 
 struct map_struct {
 	char *p;		/* Window pointer			*/
 	int fd;			/* File Descriptor			*/
-	int p_size;		/* Window size at allocation		*/
-	int p_len;		/* Window size after fill		*/
-				/*    p_size and p_len could be
-				 *    consolodated by using a local
-				 *    variable in map_ptr()		*/
+	int p_size;		/* Largest window size we allocated	*/
+	int p_len;		/* Latest (rounded) window size		*/
+	int def_window_size;	/* Default window size			*/
 	int status;		/* first errno from read errors		*/
 	OFF_T file_size;	/* File size (from stat)		*/
 	OFF_T p_offset;		/* Window start				*/
 	OFF_T p_fd_offset;	/* offset of cursor in fd ala lseek	*/
 };
 
 #define MATCHFLG_WILD		(1<<0) /* pattern has '*', '[', and/or '?' */
 #define MATCHFLG_WILD2		(1<<1) /* pattern has '**' */
 #define MATCHFLG_WILD2_PREFIX	(1<<2) /* pattern starts with '**' */
 #define MATCHFLG_ABS_PATH	(1<<3) /* path-match on absolute path */
+#define MATCHFLG_INCLUDE	(1<<4) /* this is an include, not an exclude */
+#define MATCHFLG_DIRECTORY	(1<<5) /* this matches only directories */
+#define MATCHFLG_CLEAR_LIST 	(1<<6) /* this item is the "!" token */
 struct exclude_struct {
 	struct exclude_struct *next;
 	char *pattern;
-	int match_flags;
-	int include;
-	int directory;
+	unsigned int match_flags;
 	int slash_cnt;
 };
 
 struct exclude_list_struct {
 	struct exclude_struct *head;
 	struct exclude_struct *tail;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/rsync.yo	2004-05-01 02:02:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/rsync.yo	2004-10-01 00:35:56.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(30 Apr 2004)()()
+manpage(rsync)(1)(30 Sep 2004)()()
 manpagename(rsync)(faster, flexible replacement for rcp)
 manpagesynopsis()
 
 rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
 
 rsync [OPTION]... [USER@]HOST:SRC DEST
@@ -18,24 +18,24 @@
 rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST
 
 manpagedescription()
 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
-greatly speed up file transfers when the destination file already
-exists.
+greatly speed up file transfers when the destination file is being
+updated.
 
 The rsync remote-update protocol allows rsync to transfer just the
 differences between two sets of files across the network connection, using
 an efficient checksum-search algorithm described in the technical
 report that accompanies this package.
 
 Some of the additional features of rsync are:
 
 itemize(
-  it() support for copying links, devices, owners, groups and permissions
+  it() support for copying links, devices, owners, groups, and permissions
   it() exclude and exclude-from options similar to GNU tar
   it() a CVS exclude mode for ignoring the same files that CVS would ignore
   it() can use any transparent remote shell, including ssh or rsh
   it() does not require root privileges
   it() pipelining of file transfers to minimize latency costs
   it() support for anonymous or authenticated rsync servers (ideal for
@@ -110,13 +110,13 @@
 
 You use rsync in the same way you use rcp. You must specify a source
 and a destination, one of which may be remote.
 
 Perhaps the best way to explain the syntax is with some examples:
 
-quote(rsync *.c foo:src/)
+quote(rsync -t *.c foo:src/)
 
 This would transfer all files matching the pattern *.c from the
 current directory to the directory src on the machine foo. If any of
 the files already exist on the remote system then the rsync
 remote-update protocol is used to update the file by sending only the
 differences. See the tech report for details.
@@ -138,25 +138,54 @@
 to "copy the directory by name", but in both cases the attributes of the
 containing directory are transferred to the containing directory on the
 destination.  In other words, each of the following commands copies the
 files in the same way, including their setting of the attributes of
 /dest/foo:
 
-quote(rsync -avz /src/foo /dest)
-quote(rsync -avz /src/foo/ /dest/foo)
+quote(rsync -av /src/foo /dest)
+quote(rsync -av /src/foo/ /dest/foo)
 
 You can also use rsync in local-only mode, where both the source and
 destination don't have a ':' in the name. In this case it behaves like
 an improved copy command.
 
 quote(rsync somehost.mydomain.com::)
 
 This would list all the anonymous rsync modules available on the host
 somehost.mydomain.com.  (See the following section for more details.)
 
 
+manpagesection(ADVANCED USAGE)
+
+The syntax for requesting multiple files from a remote host involves using
+quoted spaces in the SRC.  Some examples:
+
+quote(rsync host::'modname/dir1/file1 modname/dir2/file2' /dest)
+
+This would copy file1 and file2 into /dest from an rsync daemon.  Each
+additional arg must include the same "modname/" prefix as the first one,
+and must be preceded by a single space.  All other spaces are assumed
+to be a part of the filenames.
+
+quote(rsync -av host:'dir1/file1 dir2/file2' /dest)
+
+This would copy file1 and file2 into /dest using a remote shell.  This
+word-splitting is done by the remote shell, so if it doesn't work it means
+that the remote shell isn't configured to split its args based on
+whitespace (a very rare setting, but not unknown).  If you need to transfer
+a filename that contains whitespace, you'll need to either escape the
+whitespace in a way that the remote shell will understand, or use wildcards
+in place of the spaces.  Two examples of this are:
+
+quote(rsync -av host:'file\ name\ with\ spaces' /dest)
+quote(rsync -av host:file?name?with?spaces /dest)
+
+This latter example assumes that your shell passes through unmatched
+wildcards.  If it complains about "no match", put the name in quotes.
+
+
 manpagesection(CONNECTING TO AN RSYNC SERVER)
 
 It is also possible to use rsync without a remote shell as the
 transport. In this case you will connect to a remote rsync server
 running on TCP port 873. 
 
@@ -286,12 +315,14 @@
      --no-relative           turn off --relative
      --no-implied-dirs       don't send implied dirs with -R
  -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir            make backups into this directory
      --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                update only (don't overwrite newer files)
+     --inplace               update the destination files inplace
+ -K, --keep-dirlinks         treat symlinked dir on receiver as dir
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            copy the referent of all symlinks
      --copy-unsafe-links     copy the referent of "unsafe" symlinks
      --safe-links            ignore "unsafe" symlinks
  -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
@@ -301,23 +332,24 @@
  -t, --times                 preserve times
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy whole files, no incremental checks
      --no-whole-file         turn off --whole-file
  -x, --one-file-system       don't cross filesystem boundaries
- -B, --block-size=SIZE       checksum blocking size (default 700)
+ -B, --block-size=SIZE       force a fixed checksum block-size
  -e, --rsh=COMMAND           specify the remote shell
      --rsync-path=PATH       specify path to rsync on the remote machine
      --existing              only update files that already exist
      --ignore-existing       ignore files that already exist on receiver
      --delete                delete files that don't exist on sender
      --delete-excluded       also delete excluded files on receiver
      --delete-after          receiver deletes after transfer, not before
      --ignore-errors         delete even if there are I/O errors
      --max-delete=NUM        don't delete more than NUM files
      --partial               keep partially transferred files
+     --partial-dir=DIR       put a partially transferred file into DIR
      --force                 force deletion of dirs even if not empty
      --numeric-ids           don't map uid/gid values by user/group name
      --timeout=TIME          set I/O timeout in seconds
  -I, --ignore-times          turn off mod time & file size quick check
      --size-only             ignore mod time for quick check (use size)
      --modify-window=NUM     compare mod times with reduced accuracy
@@ -343,14 +375,17 @@
      --no-blocking-io        turn off --blocking-io
      --stats                 give some file transfer stats
      --progress              show progress during transfer
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
      --bwlimit=KBPS          limit I/O bandwidth, KBytes per second
-     --write-batch=PREFIX    write batch fileset starting with PREFIX
-     --read-batch=PREFIX     read batch fileset starting with PREFIX
+     --write-batch=FILE      write a batch to FILE 
+     --read-batch=FILE       read a batch from FILE
+     --checksum-seed=NUM     set block/file checksum seed
+ -4  --ipv4                  prefer IPv4
+ -6  --ipv6                  prefer IPv6
  -h, --help                  show this help screen
 
 
 )
 
 manpageoptions()
@@ -473,17 +508,48 @@
 considered to be important enough for an update, no matter what date
 is on the objects.  In other words, if the source has a directory or a
 symlink where the destination has a file, the transfer would occur
 regardless of the timestamps.  This might change in the future (feel
 free to comment on this on the mailing list if you have an opinion).
 
+dit(bf(-K, --keep-dirlinks)) On the receiving side, if a symlink is
+pointing to a directory, it will be treated as matching a directory
+from the sender.
+
+dit(bf(--inplace)) This causes rsync not to create a new copy of the file
+and then move it into place.  Instead rsync will overwrite the existing
+file, meaning that the rsync algorithm can't extract the full amount of
+network reduction it might otherwise (since it does not yet try to sort
+data matches -- a future version may improve this).
+
+This option is useful for transfer of large files with block-based changes
+or appended data, and also on systems that are disk bound, not network
+bound.
+
+The option implies --partial (since an interrupted transfer does not delete
+the file), but conflicts with --partial-dir, --compare-dest, and
+--link-dest (a future rsync version will hopefully update the protocol to
+remove these restrictions).
+
+WARNING: The file's data will be in an inconsistent state during the
+transfer (and possibly afterward if the transfer gets interrupted), so you
+should not use this option to update files that are in use.  Also note that
+rsync will be unable to update a file inplace that is not writable by the
+receiving user.
+
 dit(bf(-l, --links)) When symlinks are encountered, recreate the
 symlink on the destination.
 
 dit(bf(-L, --copy-links)) When symlinks are encountered, the file that
-they point to (the referent) is copied, rather than the symlink.
+they point to (the referent) is copied, rather than the symlink.  In older
+versions of rsync, this option also had the side-effect of telling the
+receiving side to follow symlinks, such as symlinks to directories.  In a
+modern rsync such as this one, you'll need to specify --keep-dirlinks (-K)
+to get this extra behavior.  The only exception is when sending files to
+an rsync that is too old to understand -K -- in that case, the -L option
+will still have the side-effect of -K on that older receiving rsync.
 
 dit(bf(--copy-unsafe-links)) This tells rsync to copy the referent of
 symbolic links that point outside the copied tree.  Absolute symlinks
 are also treated like ordinary files, and so are any symlinks in the
 source path itself when --relative is used.
 
@@ -501,15 +567,15 @@
 
 This option can be quite slow, so only use it if you need it.
 
 dit(bf(-W, --whole-file)) With this option the incremental rsync algorithm
 is not used and the whole file is sent as-is instead.  The transfer may be
 faster if this option is used when the bandwidth between the source and
-target machines is higher than the bandwidth to disk (especially when the
+destination machines is higher than the bandwidth to disk (especially when the
 "disk" is actually a networked filesystem).  This is the default when both
-the source and target are on the local machine.
+the source and destination are specified as local paths.
 
 dit(bf(--no-whole-file)) Turn off --whole-file, for use when it is the
 default.
 
 dit(bf(-p, --perms)) This option causes rsync to set the destination
 permissions to be the same as the source permissions.
@@ -537,15 +603,15 @@
 devices. This option is only available to the super-user.
 
 dit(bf(-t, --times)) This tells rsync to transfer modification times along
 with the files and update them on the remote system.  Note that if this
 option is not used, the optimization that excludes files that have not been
 modified cannot be effective; in other words, a missing -t or -a will
-cause the next transfer to behave as if it used -I, and all files will have
-their checksums compared and show up in log messages even if they haven't
-changed.
+cause the next transfer to behave as if it used -I, causing all files to be
+updated (though the rsync algorithm will make the update fairly efficient
+if the files haven't actually changed, you're much better off using -t).
 
 dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
 instead it will just report the actions it would have taken.
 
 dit(bf(-S, --sparse)) Try to handle sparse files efficiently so they take
 up less space on the destination.
@@ -600,14 +666,15 @@
 
 dit(bf(--force)) This options tells rsync to delete directories even if
 they are not empty when they are to be replaced by non-directories.  This
 is only relevant without --delete because deletions are now done depth-first.
 Requires the --recursive option (which is implied by -a) to have any effect.
 
-dit(bf(-B , --block-size=BLOCKSIZE)) This controls the block size used in
-the rsync algorithm. See the technical report for details.
+dit(bf(-B, --block-size=BLOCKSIZE)) This forces the block size used in
+the rsync algorithm to a fixed value.  It is normally selected based on
+the size of each file being updated.  See the technical report for details.
 
 dit(bf(-e, --rsh=COMMAND)) This option allows you to choose an alternative
 remote shell program to use for communication between the local and
 remote copies of rsync. Typically, rsync is configured to use ssh by
 default, but you may prefer to use rsh on a local network.
 
@@ -675,17 +742,17 @@
 build up quite complex exclude/include rules.
 
 See the EXCLUDE PATTERNS section for detailed information on this option.
 
 dit(bf(--include-from=FILE)) This specifies a list of include patterns
 from a file.
-If em(FILE) is bf(-) the list will be read from standard input.
+If em(FILE) is "-" the list will be read from standard input.
 
 dit(bf(--files-from=FILE)) Using this option allows you to specify the
 exact list of files to transfer (as read from the specified FILE or "-"
-for stdin).  It also tweaks the default behavior of rsync to make
+for standard input).  It also tweaks the default behavior of rsync to make
 transferring just the specified files and directories easier.  For
 instance, the --relative option is enabled by default when this option
 is used (use --no-relative if you want to turn that off), all
 directories specified in the list are created on the destination (rather
 than being noisily skipped without -r), and the -a (--archive) option's
 behavior does not imply -r (--recursive) -- specify it explicitly, if
@@ -736,26 +803,31 @@
 flash-cutover when all files have been successfully transferred (for
 example by moving directories around and removing the old directory,
 although this skips files that haven't changed; see also --link-dest).
 This option increases the usefulness of --partial because partially
 transferred files will remain in the new temporary destination until they
 have a chance to be completed.  If DIR is a relative path, it is relative
-to the destination directory (which changes in a recursive transfer).
+to the destination directory.
 
 dit(bf(--link-dest=DIR)) This option behaves like bf(--compare-dest) but
 also will create hard links from em(DIR) to the destination directory for
 unchanged files.  Files with changed ownership or permissions will not be
 linked.
-Like bf(--compare-dest) if DIR is a relative path, it is relative
-to the destination directory (which changes in a recursive transfer).
 An example:
 
 verb(
     rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/
 )
 
+Like bf(--compare-dest) if DIR is a relative path, it is relative to the
+destination directory.
+Note that rsync versions prior to 2.6.1 had a bug that could prevent
+--link-dest from working properly for a non-root user when -o was specified
+(or implied by -a).  If the receiving rsync is not new enough, you can work
+around this bug by avoiding the -o option.
+
 dit(bf(-z, --compress)) With this option, rsync compresses any data from
 the files that it sends to the destination machine.  This
 option is useful on slow connections.  The compression method used is the
 same method that gzip uses.
 
 Note this this option typically achieves better compression ratios
@@ -839,12 +911,52 @@
 dit(bf(--partial)) By default, rsync will delete any partially
 transferred file if the transfer is interrupted. In some circumstances
 it is more desirable to keep partially transferred files. Using the
 --partial option tells rsync to keep the partial file which should
 make a subsequent transfer of the rest of the file much faster.
 
+dit(bf(--partial-dir=DIR)) Turns on --partial mode, but tells rsync to
+put a partially transferred file into DIR instead of writing out the
+file to the destination dir.  Rsync will also use a file found in this
+dir as data to speed up the transfer (i.e. when you redo the send after
+rsync creates a partial file) and delete such a file after it has served
+its purpose.  Note that if --whole-file is specified (or implied) that an
+existing partial-dir file will not be used to speedup the transfer (since
+rsync is sending files without using the incremental rsync algorithm).
+
+Rsync will create the dir if it is missing (just the last dir -- not the
+whole path).  This makes it easy to use a relative path (such as
+"--partial-dir=.rsync-partial") to have rsync create the partial-directory
+in the destination file's directory (rsync will also try to remove the DIR
+if a partial file was found to exist at the start of the transfer and the
+DIR was specified as a relative path).
+
+If the partial-dir value is not an absolute path, rsync will also add an
+--exclude of this value at the end of all your existing excludes.  This
+will prevent partial-dir files from being transferred and also prevent the
+untimely deletion of partial-dir items on the receiving side.  An example:
+the above --partial-dir option would add an "--exclude=.rsync-partial/"
+rule at the end of any other include/exclude rules.  Note that if you are
+supplying your own include/exclude rules, you may need to manually insert a
+rule for this directory exclusion somewhere higher up in the list so that
+it has a high enough priority to be effective (e.g., if your rules specify
+a trailing --exclude=* rule, the auto-added rule will be ineffective).
+
+IMPORTANT: the --partial-dir should not be writable by other users or it
+is a security risk.  E.g. AVOID "/tmp".
+
+You can also set the partial-dir value the RSYNC_PARTIAL_DIR environment
+variable.  Setting this in the environment does not force --partial to be
+enabled, but rather it effects where partial files go when --partial (or
+-P) is used.  For instance, instead of specifying --partial-dir=.rsync-tmp
+along with --progress, you could set RSYNC_PARTIAL_DIR=.rsync-tmp in your
+environment and then just use the -P option to turn on the use of the
+.rsync-tmp dir for partial transfers.  The only time the --partial option
+does not look for this environment value is when --inplace was also
+specified (since --inplace conflicts with --partial-dir).
+
 dit(bf(--progress)) This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
 Implies --verbose without incrementing verbosity.
 
 When the file is transferring, the data looks like this:
@@ -867,15 +979,15 @@
 This tells you the final file size, that it's 100% complete, the final
 transfer rate for the file, the amount of elapsed time it took to transfer
 the file, and the addition of a total-transfer summary in parentheses.
 These additional numbers tell you how many files have been updated, and
 what percent of the total number of files has been scanned.
 
-dit(bf(-P)) The -P option is equivalent to --partial --progress. I
-found myself typing that combination quite often so I created an
-option to make it easier.
+dit(bf(-P)) The -P option is equivalent to --partial --progress.  Its
+purpose is to make it much easier to specify these two options for a long
+transfer that may be interrupted.
 
 dit(bf(--password-file)) This option allows you to provide a password
 in a file for accessing a remote rsync server. Note that this option
 is only useful when accessing an rsync server using the built in
 transport, not when using a remote shell as the transport. The file
 must not be world readable. It should contain just the password as a
@@ -886,19 +998,39 @@
 using rsync with large files (several megabytes and up). Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
 transfer was too fast, it will wait before sending the next data block. The
 result is an average transfer rate equaling the specified limit. A value
 of zero specifies no limit.
 
-dit(bf(--write-batch=PREFIX)) Generate a set of files that can be
-transferred as a batch update. Each filename in the set starts with
-PREFIX. See the "BATCH MODE" section for details.
-
-dit(bf(--read-batch=PREFIX)) Apply a previously generated change batch,
-using the fileset whose filenames start with PREFIX. See the "BATCH
-MODE" section for details.
+dit(bf(--write-batch=FILE)) Record a file that can later be applied to
+another identical destination with --read-batch. See the "BATCH MODE"
+section for details.
+
+dit(bf(--read-batch=FILE)) Apply all of the changes stored in FILE, a
+file previously generated by --write-batch.
+If em(FILE) is "-" the batch data will be read from standard input.
+See the "BATCH MODE" section for details.
+
+dit(bf(-4, --ipv4) or bf(-6, --ipv6)) Tells rsync to prefer IPv4/IPv6
+when creating sockets.  This only affects sockets that rsync has direct
+control over, such as the outgoing socket when directly contacting an
+rsync daemon, or the incoming sockets that an rsync daemon uses to
+listen for connections.  One of these options may be required in older
+versions of Linux to work around an IPv6 bug in the kernel (if you see
+an "address already in use" error when nothing else is using the port,
+try specifying --ipv6 or --ipv4 when starting the daemon).
+
+dit(bf(--checksum-seed=NUM)) Set the MD4 checksum seed to the integer
+NUM.  This 4 byte checksum seed is included in each block and file
+MD4 checksum calculation.  By default the checksum seed is generated
+by the server and defaults to the current time().  This option
+is used to set a specific checksum seed, which is useful for
+applications that want repeatable block and file checksums, or
+in the case where the user wants a more random checksum seed.
+Note that setting NUM to 0 causes rsync to use the default of time()
+for checksum seed.
 
 enddit()
 
 manpagesection(EXCLUDE PATTERNS)
 
 The exclude and include patterns specified to rsync allow for flexible
@@ -1064,91 +1196,124 @@
   it would be excluded by the "*")
 )
 
 manpagesection(BATCH MODE)
 
 bf(Note:) Batch mode should be considered experimental in this version
-of rsync. The interface or behavior may change before it stabilizes.
+of rsync. The interface and behavior have now stabilized, though, so
+feel free to try this out.
 
 Batch mode can be used to apply the same set of updates to many
 identical systems. Suppose one has a tree which is replicated on a
 number of hosts.  Now suppose some changes have been made to this
 source tree and those changes need to be propagated to the other
 hosts. In order to do this using batch mode, rsync is run with the
 write-batch option to apply the changes made to the source tree to one
 of the destination trees.  The write-batch option causes the rsync
-client to store the information needed to repeat this operation against
-other destination trees in a batch update fileset (see below).  The
-filename of each file in the fileset starts with a prefix specified by
-the user as an argument to the write-batch option.  This fileset is
-then copied to each remote host, where rsync is run with the read-batch
-option, again specifying the same prefix, and the destination tree.
-Rsync updates the destination tree using the information stored in the
-batch update fileset.
+client to store in a "batch file" all the information needed to repeat
+this operation against other, identical destination trees.
 
-The fileset consists of 4 files:
+To apply the recorded changes to another destination tree, run rsync
+with the read-batch option, specifying the name of the same batch
+file, and the destination tree.  Rsync updates the destination tree
+using the information stored in the batch file.
+
+For convenience, one additional file is creating when the write-batch
+option is used.  This file's name is created by appending
+".sh" to the batch filename.  The .sh file contains
+a command-line suitable for updating a destination tree using that
+batch file. It can be executed using a Bourne(-like) shell, optionally
+passing in an alternate destination tree pathname which is then used
+instead of the original path. This is useful when the destination tree
+path differs from the original destination tree path.
 
-itemize(
-it() bf(<prefix>.rsync_argvs) command-line arguments
-it() bf(<prefix>.rsync_flist) rsync internal file metadata
-it() bf(<prefix>.rsync_csums) rsync checksums
-it() bf(<prefix>.rsync_delta) data blocks for file update & change
-)
-
-The .rsync_argvs file contains a command-line suitable for updating a
-destination tree using that batch update fileset. It can be executed
-using a Bourne(-like) shell, optionally passing in an alternate
-destination tree pathname which is then used instead of the original
-path. This is useful when the destination tree path differs from the
-original destination tree path.
-
-Generating the batch update fileset once saves having to perform the
-file status, checksum and data block generation more than once when
+Generating the batch file once saves having to perform the file
+status, checksum, and data block generation more than once when
 updating multiple destination trees. Multicast transport protocols can
-be used to transfer the batch update files in parallel to many hosts at
-once, instead of sending the same data to every host individually.
+be used to transfer the batch update files in parallel to many hosts
+at once, instead of sending the same data to every host individually.
 
-Example:
+Examples:
 
 verb(
-   $ rsync --write-batch=pfx -a /source/dir/ /adest/dir/
-   $ rcp pfx.rsync_* remote:
-   $ ssh remote rsync --read-batch=pfx -a /bdest/dir/
-   # or alternatively
-   $ ssh remote ./pfx.rsync_argvs /bdest/dir/
+   $ rsync --write-batch=foo -a host:/source/dir/ /adest/dir/
+   $ scp foo* remote:
+   $ ssh remote ./foo.sh /bdest/dir/
 )
 
-In this example, rsync is used to update /adest/dir/ with /source/dir/
-and the information to repeat this operation is stored in the files
-pfx.rsync_*. These files are then copied to the machine named "remote".
-Rsync is then invoked on "remote" to update /bdest/dir/ the same way as
-/adest/dir/. The last line shows the rsync_argvs file being used to
-invoke rsync.
+verb(
+   $ rsync --write-batch=foo -a /source/dir/ /adest/dir/
+   $ ssh remote rsync --read-batch=- -a /bdest/dir/ <foo
+)
+
+In these examples, rsync is used to update /adest/dir/ from /source/dir/
+and the information to repeat this operation is stored in "foo" and
+"foo.sh".  The host "remote" is then updated with the batched data going
+into the directory /bdest/dir.  The differences between the two examples
+reveals some of the flexibility you have in how you deal with batches:
+
+itemize(
+
+  it() The first example shows that the initial copy doesn't have to be
+  local -- you can push or pull data to/from a remote host using either the
+  remote-shell syntax or rsync daemon syntax, as desired.
+
+  it() The first example uses the created "foo.sh" file to get the right
+  rsync options when running the read-batch command on the remote host.
+
+  it() The second example reads the batch data via standard input so that
+  the batch file doesn't need to be copied to the remote machine first.
+  This example avoids the foo.sh script because it needed to use a modified
+  --read-batch option, but you could edit the script file if you wished to
+  make use of it (just be sure that no other option is trying to use
+  standard input, such as the "--exclude-from=-" option).
+
+)
 
 Caveats:
 
-The read-batch option expects the destination tree it is meant to update
+The read-batch option expects the destination tree that it is updating
 to be identical to the destination tree that was used to create the
 batch update fileset.  When a difference between the destination trees
-is encountered the update will fail at that point, leaving the
-destination tree in a partially updated state. In that case, rsync can
+is encountered the update might be discarded with no error (if the file
+appears to be up-to-date already) or the file-update may be attempted
+and then, if the file fails to verify, the update discarded with an
+error.  This means that it should be safe to re-run a read-batch operation
+if the command got interrupted.  If you wish to force the batched-update to
+always be attempted regardless of the file's size and date, use the -I
+option (when reading the batch).
+If an error occurs, the destination tree will probably be in a
+partially updated state. In that case, rsync can
 be used in its regular (non-batch) mode of operation to fix up the
 destination tree.
 
-The rsync version used on all destinations should be identical to the
-one used on the original destination.
-
-The -z/--compress option does not work in batch mode and yields a usage
-error. A separate compression tool can be used instead to reduce the
-size of the batch update files for transport to the destination.
+The rsync version used on all destinations must be at least as new as the
+one used to generate the batch file.  Rsync will die with an error if the
+protocol version in the batch file is too new for the batch-reading rsync
+to handle.
 
-The -n/--dryrun option does not work in batch mode and yields a runtime
+The --dry-run (-n) option does not work in batch mode and yields a runtime
 error.
 
-See bf(http://www.ils.unc.edu/i2dsi/unc_rsync+.html) for papers and technical
-reports.
+When reading a batch file, rsync will force the value of certain options
+to match the data in the batch file if you didn't set them to the same
+as the batch-writing command.  Other options can (and should) be changed.
+For instance
+--write-batch changes to --read-batch, --files-from is dropped, and the
+--include/--exclude options are not needed unless --delete is specified
+without --delete-excluded.
+
+The code that creates the BATCH.sh file transforms any include/exclude
+options into a single list that is appended as a "here" document to the
+shell script file.  An advanced user can use this to modify the exclude
+list if a change in what gets deleted by --delete is desired.  A normal
+user can ignore this detail and just use the shell script as an easy way
+to run the appropriate --read-batch command for the batched data.
+
+The original batch mode in rsync was based on "rsync+", but the latest
+version uses a new implementation.
 
 manpagesection(SYMBOLIC LINKS)
 
 Three basic behaviors are possible when rsync encounters a symbolic
 link in the source directory.
 
@@ -1304,13 +1469,13 @@
 
 Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
 and David Bell for helpful suggestions, patches and testing of rsync.
 I've probably missed some people, my apologies if I have.
 
 Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer,
-Martin Pool, Wayne Davison.
+Martin Pool, Wayne Davison, J.W. Schultz.
 
 manpageauthor()
 
 rsync was originally written by Andrew Tridgell and Paul Mackerras.
 Many people have later contributed to it.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/sender.c	2004-02-18 05:57:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/sender.c	2004-09-20 12:17:42.000000000 +0800
@@ -24,12 +24,14 @@
 extern struct stats stats;
 extern int io_error;
 extern int dry_run;
 extern int am_server;
 extern int am_daemon;
 extern int protocol_version;
+extern int make_backups;
+extern struct stats stats;
 
 
 /**
  * @file
  *
  * The sender gets checksums from the generator, calculates deltas,
@@ -59,14 +61,14 @@
 static struct sum_struct *receive_sums(int f)
 {
 	struct sum_struct *s;
 	int i;
 	OFF_T offset = 0;
 
-	s = new(struct sum_struct);
-	if (!s) out_of_memory("receive_sums");
+	if (!(s = new(struct sum_struct)))
+		out_of_memory("receive_sums");
 
 	read_sum_head(f, s);
 
 	s->sums = NULL;
 
 	if (verbose > 3) {
@@ -74,32 +76,34 @@
 			(long)s->count, s->blength, s->remainder);
 	}
 
 	if (s->count == 0)
 		return(s);
 
-	s->sums = new_array(struct sum_buf, s->count);
-	if (!s->sums) out_of_memory("receive_sums");
+	if (!(s->sums = new_array(struct sum_buf, s->count)))
+		out_of_memory("receive_sums");
 
-	for (i = 0; i < (int) s->count; i++) {
+	for (i = 0; i < (int)s->count; i++) {
 		s->sums[i].sum1 = read_int(f);
 		read_buf(f, s->sums[i].sum2, s->s2length);
 
 		s->sums[i].offset = offset;
-		s->sums[i].i = i;
+		s->sums[i].flags = 0;
 
-		if (i == (int) s->count-1 && s->remainder != 0) {
+		if (i == (int)s->count-1 && s->remainder != 0)
 			s->sums[i].len = s->remainder;
-		} else {
+		else
 			s->sums[i].len = s->blength;
-		}
 		offset += s->sums[i].len;
 
-		if (verbose > 3)
-			rprintf(FINFO, "chunk[%d] len=%d offset=%.0f sum1=%08x\n",
-				i, s->sums[i].len, (double)s->sums[i].offset, s->sums[i].sum1);
+		if (verbose > 3) {
+			rprintf(FINFO,
+				"chunk[%d] len=%d offset=%.0f sum1=%08x\n",
+				i, s->sums[i].len, (double)s->sums[i].offset,
+				s->sums[i].sum1);
+		}
 	}
 
 	s->flength = offset;
 
 	return s;
 }
@@ -107,27 +111,21 @@
 
 
 void send_files(struct file_list *flist, int f_out, int f_in)
 {
 	int fd = -1;
 	struct sum_struct *s;
-	struct map_struct *buf = NULL;
+	struct map_struct *mbuf = NULL;
 	STRUCT_STAT st;
-	char fname[MAXPATHLEN];
+	char *fname2, fname[MAXPATHLEN];
 	int i;
 	struct file_struct *file;
 	int phase = 0;
-	extern struct stats stats;
 	struct stats initial_stats;
-	extern int write_batch;
-	extern int read_batch;
-	int checksums_match;
-	int buff_len;
-	char buff[CHUNK_SIZE];
+	int save_make_backups = make_backups;
 	int j;
-	int done;
 
 	if (verbose > 2)
 		rprintf(FINFO, "send_files starting\n");
 
 	while (1) {
 		unsigned int offset;
@@ -137,12 +135,15 @@
 			if (phase == 0) {
 				phase++;
 				csum_length = SUM_LENGTH;
 				write_int(f_out, -1);
 				if (verbose > 2)
 					rprintf(FINFO, "send_files phase=%d\n", phase);
+				/* For inplace: redo phase turns off the backup
+				 * flag so that we do a regular inplace send. */
+				make_backups = 0;
 				continue;
 			}
 			break;
 		}
 
 		if (i < 0 || i >= flist->count) {
@@ -161,163 +162,108 @@
 			/* N.B. We're sure that this fits, so offset is OK. */
 			offset = strlcpy(fname, file->basedir, sizeof fname);
 			if (!offset || fname[offset-1] != '/')
 				fname[offset++] = '/';
 		} else
 			offset = 0;
-		f_name_to(file, fname + offset);
+		fname2 = f_name_to(file, fname + offset);
 
 		if (verbose > 2)
 			rprintf(FINFO, "send_files(%d, %s)\n", i, fname);
 
 		if (dry_run) {
-			if (!am_server && verbose) {	/* log transfer */
-				rprintf(FINFO, "%s\n", fname+offset);
-			}
+			if (!am_server && verbose) /* log the transfer */
+				rprintf(FINFO, "%s\n", safe_fname(fname2));
 			write_int(f_out, i);
 			continue;
 		}
 
 		initial_stats = stats;
 
-		s = receive_sums(f_in);
-		if (!s) {
+		if (!(s = receive_sums(f_in))) {
 			io_error |= IOERR_GENERAL;
 			rprintf(FERROR, "receive_sums failed\n");
 			return;
 		}
 
-		if (write_batch)
-			write_batch_csum_info(&i, s);
-
-		if (!read_batch) {
-			fd = do_open(fname, O_RDONLY, 0);
-			if (fd == -1) {
-				if (errno == ENOENT) {
-					enum logcode c = am_daemon
-					    && protocol_version < 28 ? FERROR
-								     : FINFO;
-					io_error |= IOERR_VANISHED;
-					rprintf(c, "file has vanished: %s\n",
-						full_fname(fname));
-				} else {
-					io_error |= IOERR_GENERAL;
-					rprintf(FERROR, "send_files failed to open %s: %s\n",
-						full_fname(fname), strerror(errno));
-				}
-				free_sums(s);
-				continue;
-			}
-
-			/* map the local file */
-			if (do_fstat(fd, &st) != 0) {
-				io_error |= IOERR_GENERAL;
-				rprintf(FERROR, "fstat failed: %s\n", strerror(errno));
-				free_sums(s);
-				close(fd);
-				return;
-			}
-
-			if (st.st_size > 0) {
-				buf = map_file(fd, st.st_size);
+		fd = do_open(fname, O_RDONLY, 0);
+		if (fd == -1) {
+			if (errno == ENOENT) {
+				enum logcode c = am_daemon
+				    && protocol_version < 28 ? FERROR
+							     : FINFO;
+				io_error |= IOERR_VANISHED;
+				rprintf(c, "file has vanished: %s\n",
+					full_fname(fname));
 			} else {
-				buf = NULL;
+				io_error |= IOERR_GENERAL;
+				rsyserr(FERROR, errno,
+					"send_files failed to open %s",
+					full_fname(fname));
 			}
+			free_sums(s);
+			continue;
+		}
 
-			if (verbose > 2)
-				rprintf(FINFO, "send_files mapped %s of size %.0f\n",
-					fname, (double)st.st_size);
-
-			write_int(f_out, i);
+		/* map the local file */
+		if (do_fstat(fd, &st) != 0) {
+			io_error |= IOERR_GENERAL;
+			rsyserr(FERROR, errno, "fstat failed");
+			free_sums(s);
+			close(fd);
+			return;
+		}
 
-			if (write_batch)
-				write_batch_delta_file((char *)&i, sizeof i);
+		if (st.st_size) {
+			OFF_T map_size = MAX(s->blength * 3, MAX_MAP_SIZE);
+			mbuf = map_file(fd, st.st_size, map_size, s->blength);
+		} else
+			mbuf = NULL;
 
-			write_sum_head(f_out, s);
+		if (verbose > 2) {
+			rprintf(FINFO, "send_files mapped %s of size %.0f\n",
+				safe_fname(fname), (double)st.st_size);
 		}
 
-		if (verbose > 2 && !read_batch)
-			rprintf(FINFO, "calling match_sums %s\n", fname);
+		write_int(f_out, i);
+		write_sum_head(f_out, s);
 
-		if (!am_server && verbose) {	/* log transfer */
-			rprintf(FINFO, "%s\n", fname+offset);
+		if (verbose > 2) {
+			rprintf(FINFO, "calling match_sums %s\n",
+				safe_fname(fname));
 		}
 
+		if (!am_server && verbose) /* log the transfer */
+			rprintf(FINFO, "%s\n", safe_fname(fname2));
+
 		set_compression(fname);
 
-		if (read_batch) {
-			/* read checksums originally computed on sender side */
-			read_batch_csum_info(i, s, &checksums_match);
-			if (checksums_match) {
-				read_batch_delta_file((char*)&j, sizeof (int));
-				if (j != i) {    /* if flist index entries don't match*/
-					rprintf(FINFO, "index mismatch in send_files\n");
-					rprintf(FINFO, "read index = %d flist ndx = %d\n", j, i);
-					close_batch_delta_file();
-					close_batch_csums_file();
-					exit_cleanup(1);
-				} else {
-					write_int(f_out, j);
-					write_sum_head(f_out, s);
-					done = 0;
-					while (!done) {
-						read_batch_delta_file((char*)&buff_len, sizeof (int));
-						write_int(f_out, buff_len);
-						if (buff_len == 0) {
-							done = 1;
-						} else {
-							if (buff_len > 0) {
-								read_batch_delta_file(buff, buff_len);
-								write_buf(f_out, buff, buff_len);
-							}
-						}
-					}  /* end while  */
-					read_batch_delta_file( buff, MD4_SUM_LENGTH);
-					write_buf(f_out, buff, MD4_SUM_LENGTH);
-
-				}  /* j=i */
-			} else {  /* not checksum match */
-				rprintf (FINFO, "readbatch & checksums don't match\n");
-				rprintf (FINFO, "filename=%s is being skipped\n", fname);
-				continue;
-			}
-		} else  {
-			match_sums(f_out, s, buf, st.st_size);
-			log_send(file, &initial_stats);
-		}
+		match_sums(f_out, s, mbuf, st.st_size);
+		log_send(file, &initial_stats);
 
-		if (!read_batch) {
-			if (buf) {
-				j = unmap_file(buf);
-				if (j) {
-					io_error |= IOERR_GENERAL;
-					rprintf(FERROR,
-					    "read errors mapping %s: (%d) %s\n",
-					    full_fname(fname), j, strerror(j));
-				}
+		if (mbuf) {
+			j = unmap_file(mbuf);
+			if (j) {
+				io_error |= IOERR_GENERAL;
+				rsyserr(FERROR, j,
+					"read errors mapping %s",
+					full_fname(fname));
 			}
-			close(fd);
 		}
+		close(fd);
 
 		free_sums(s);
 
-		if (verbose > 2)
-			rprintf(FINFO, "sender finished %s\n", fname);
+		if (verbose > 2) {
+			rprintf(FINFO, "sender finished %s\n",
+				safe_fname(fname));
+		}
 	}
+	make_backups = save_make_backups;
 
 	if (verbose > 2)
 		rprintf(FINFO, "send files finished\n");
 
 	match_report();
 
 	write_int(f_out, -1);
-	if (write_batch || read_batch) {
-		close_batch_csums_file();
-		close_batch_delta_file();
-	}
-
 }
-
-
-
-
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/socket.c	2004-04-15 00:51:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/socket.c	2004-09-17 01:22:31.000000000 +0800
@@ -30,12 +30,14 @@
  * IPv4-only machines.  On systems that don't have that interface, we
  * emulate it using the KAME implementation.
  **/
 
 #include "rsync.h"
 
+extern char *bind_address;
+extern int default_af_hint;
 
 /**
  * Establish a proxy connection on an open socket to a web proxy by
  * using the CONNECT method. If proxy_user and proxy_pass are not NULL,
  * they are used to authenticate to the proxy using the "Basic"
  * proxy-authorization protocol
@@ -66,21 +68,19 @@
 	}
 
 	snprintf(buffer, sizeof buffer, "CONNECT %s:%d HTTP/1.0%s%s\r\n\r\n",
 		 host, port, authhdr, authbuf);
 	len = strlen(buffer);
 	if (write(fd, buffer, len) != len) {
-		rprintf(FERROR, "failed to write to proxy: %s\n",
-			strerror(errno));
+		rsyserr(FERROR, errno, "failed to write to proxy");
 		return -1;
 	}
 
 	for (cp = buffer; cp < &buffer[sizeof buffer - 1]; cp++) {
 		if (read(fd, cp, 1) != 1) {
-			rprintf(FERROR, "failed to read from proxy: %s\n",
-				strerror(errno));
+			rsyserr(FERROR, errno, "failed to read from proxy");
 			return -1;
 		}
 		if (*cp == '\n')
 			break;
 	}
 
@@ -103,14 +103,14 @@
 		return -1;
 	}
 	/* throw away the rest of the HTTP header */
 	while (1) {
 		for (cp = buffer; cp < &buffer[sizeof buffer - 1]; cp++) {
 			if (read(fd, cp, 1) != 1) {
-				rprintf(FERROR, "failed to read from proxy: %s\n",
-					strerror(errno));
+				rsyserr(FERROR, errno,
+					"failed to read from proxy");
 				return -1;
 			}
 			if (*cp == '\n')
 				break;
 		}
 		if (cp > buffer && *cp == '\n')
@@ -273,14 +273,13 @@
 			continue;
 		}
 		break;
 	}
 	freeaddrinfo(res0);
 	if (s < 0) {
-		rprintf(FERROR, RSYNC_NAME ": failed to connect to %s: %s\n",
-			h, strerror(errno));
+		rsyserr(FERROR, errno, "failed to connect to %s", h);
 		return -1;
 	}
 	return s;
 }
 
 
@@ -311,34 +310,29 @@
 	return open_socket_out(host, port, bind_address, af_hint);
 }
 
 
 
 /**
- * Open a socket of the specified type, port and address for incoming data
+ * Open one or more sockets for incoming data using the specified type,
+ * port, and address.
  *
- * Try to be better about handling the results of getaddrinfo(): when
- * opening an inbound socket, we might get several address results,
- * e.g. for the machine's ipv4 and ipv6 name.
- *
- * If binding a wildcard, then any one of them should do.  If an address
- * was specified but it's insufficiently specific then that's not our
- * fault.
- *
- * However, some of the advertized addresses may not work because e.g. we
- * don't have IPv6 support in the kernel.  In that case go on and try all
- * addresses until one succeeds.
+ * The getaddrinfo() call may return several address results, e.g. for
+ * the machine's IPv4 and IPv6 name.
+ *
+ * We return an array of file-descriptors to the sockets, with a trailing
+ * -1 value to indicate the end of the list.
  *
  * @param bind_address Local address to bind, or NULL to allow it to
  * default.
  **/
 static int *open_socket_in(int type, int port, const char *bind_address,
 			   int af_hint)
 {
-	int one=1;
-	int s, *sp, *socks, maxs;
+	int one = 1;
+	int s, *socks, maxs, i;
 	struct addrinfo hints, *all_ai, *resp;
 	char portbuf[10];
 	int error;
 
 	memset(&hints, 0, sizeof hints);
 	hints.ai_family = af_hint;
@@ -351,24 +345,20 @@
 			bind_address, gai_strerror(error));
 		return NULL;
 	}
 
 	/* Count max number of sockets we might open. */
 	for (maxs = 0, resp = all_ai; resp; resp = resp->ai_next, maxs++) {}
-	socks = new_array(int, maxs + 1);
-	if (!socks) {
-		rprintf(FERROR,
-			RSYNC_NAME "couldn't allocate memory for sockets");
-		return NULL;
-	}
+
+	if (!(socks = new_array(int, maxs + 1)))
+		out_of_memory("open_socket_in");
 
 	/* We may not be able to create the socket, if for example the
 	 * machine knows about IPv6 in the C library, but not in the
 	 * kernel. */
-	sp = socks + 1; /* Leave room for count at start of array. */
-	for (resp = all_ai; resp; resp = resp->ai_next) {
+	for (resp = all_ai, i = 0; resp; resp = resp->ai_next) {
 		s = socket(resp->ai_family, resp->ai_socktype,
 			   resp->ai_protocol);
 
 		if (s == -1) {
 			/* See if there's another address that will work... */
 			continue;
@@ -376,35 +366,39 @@
 
 		setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
 			   (char *)&one, sizeof one);
 
 #ifdef IPV6_V6ONLY
 		if (resp->ai_family == AF_INET6) {
-			setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
-				   (char *)&one, sizeof one);
+			if (setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
+				       (char *)&one, sizeof one) < 0
+			    && default_af_hint != AF_INET6) {
+				close(s);
+				continue;
+			}
 		}
 #endif
 
 		/* Now we've got a socket - we need to bind it. */
 		if (bind(s, resp->ai_addr, resp->ai_addrlen) < 0) {
 			/* Nope, try another */
 			close(s);
 			continue;
 		}
 
-		*sp++ = s;
+		socks[i++] = s;
 	}
-	*socks = sp - socks - 1;   /* Save count. */
+	socks[i] = -1;
 
 	if (all_ai)
 		freeaddrinfo(all_ai);
 
-	if (*socks == 0) {
+	if (!i) {
 		rprintf(FERROR,
-			RSYNC_NAME ": open inbound socket on port %d failed: "
-			"%s\n", port, strerror(errno));
+			"unable to bind any inbound sockets on port %d\n",
+			port);
 		free(socks);
 		return NULL;
 	}
 	return socks;
 }
 
@@ -443,29 +437,30 @@
 }
 
 
 void start_accept_loop(int port, int (*fn)(int, int))
 {
 	fd_set deffds;
-	int *sp, maxfd, i, j;
-	extern char *bind_address;
-	extern int default_af_hint;
+	int *sp, maxfd, i;
 
 	/* open an incoming socket */
 	sp = open_socket_in(SOCK_STREAM, port, bind_address, default_af_hint);
 	if (sp == NULL)
 		exit_cleanup(RERR_SOCKETIO);
 
 	/* ready to listen */
 	FD_ZERO(&deffds);
-	maxfd = -1;
-	for (i = 1; i <= *sp; i++) {
-		if (listen(sp[i], 5) == -1) {
-			for (j = 1; j <= i; j++)
-				close(sp[j]);
-			free(sp);
+	for (i = 0, maxfd = -1; sp[i] >= 0; i++) {
+		if (listen(sp[i], 5) < 0) {
+			rsyserr(FERROR, errno, "listen() on socket failed");
+#ifdef INET6
+			if (errno == EADDRINUSE && i > 0) {
+				rprintf(FINFO,
+				    "Try using --ipv4 or --ipv6 to avoid this listen() error.");
+			}
+#endif
 			exit_cleanup(RERR_SOCKETIO);
 		}
 		FD_SET(sp[i], &deffds);
 		if (maxfd < sp[i])
 			maxfd = sp[i];
 	}
@@ -491,14 +486,13 @@
 		fds = deffds;
 #endif
 
 		if (select(maxfd + 1, &fds, NULL, NULL, NULL) != 1)
 			continue;
 
-		fd = -1;
-		for (i = 1; i <= *sp; i++) {
+		for (i = 0, fd = -1; sp[i] >= 0; i++) {
 			if (FD_ISSET(sp[i], &fds)) {
 				fd = accept(sp[i], (struct sockaddr *)&addr,
 					    &addrlen);
 				break;
 			}
 		}
@@ -507,24 +501,23 @@
 			continue;
 
 		signal(SIGCHLD, sigchld_handler);
 
 		if ((pid = fork()) == 0) {
 			int ret;
-			close(sp[i]);
+			for (i = 0; sp[i] >= 0; i++)
+				close(sp[i]);
 			/* open log file in child before possibly giving
 			 * up privileges  */
 			log_open();
 			ret = fn(fd, fd);
 			close_all();
 			_exit(ret);
 		} else if (pid < 0) {
-			rprintf(FERROR,
-				RSYNC_NAME
-				": could not create child server process: %s\n",
-				strerror(errno));
+			rsyserr(FERROR, errno,
+				"could not create child server process");
 			close(fd);
 			/* This might have happened because we're
 			 * overloaded.  Sleep briefly before trying to
 			 * accept again. */
 			sleep(2);
 		} else {
@@ -635,15 +628,16 @@
 						 socket_options[i].option,
 						 (char *)&on, sizeof (int));
 			}
 			break;
 		}
 
-		if (ret != 0)
-			rprintf(FERROR, "failed to set socket option %s: %s\n", tok,
-				strerror(errno));
+		if (ret != 0) {
+			rsyserr(FERROR, errno,
+				"failed to set socket option %s", tok);
+		}
 	}
 
 	free(options);
 }
 
 /**
@@ -730,20 +724,22 @@
 		connect_done = 1;
 
 	if ((fd[0] = accept(listener, (struct sockaddr *)&sock, &socklen)) == -1)
 		goto failed;
 
 	close(listener);
+	listener = -1;
+
+	set_blocking(fd[1]);
+
 	if (connect_done == 0) {
 		if (connect(fd[1], (struct sockaddr *)&sock, sizeof sock) != 0
 		    && errno != EISCONN)
 			goto failed;
 	}
 
-	set_blocking(fd[1]);
-
 	/* all OK! */
 	return 0;
 
  failed:
 	if (fd[0] != -1)
 		close(fd[0]);
@@ -767,14 +763,13 @@
  **/
 int sock_exec(const char *prog)
 {
 	int fd[2];
 
 	if (socketpair_tcp(fd) != 0) {
-		rprintf(FERROR, RSYNC_NAME ": socketpair_tcp failed (%s)\n",
-			strerror(errno));
+		rsyserr(FERROR, errno, "socketpair_tcp failed");
 		return -1;
 	}
 	if (verbose >= 2)
 		rprintf(FINFO, "Running socket program: \"%s\"\n", prog);
 	if (fork() == 0) {
 		close(fd[0]);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/syscall.c	2004-02-19 06:33:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/syscall.c	2004-08-03 05:56:07.000000000 +0800
@@ -149,13 +149,13 @@
 /* like mkstemp but forces permissions */
 int do_mkstemp(char *template, mode_t perms)
 {
 	RETURN_ERROR_IF(dry_run, 0);
 	RETURN_ERROR_IF(read_only, EROFS);
 
-#if defined(HAVE_SECURE_MKSTEMP) && defined(HAVE_FCHMOD)
+#if HAVE_SECURE_MKSTEMP && HAVE_FCHMOD && (!HAVE_OPEN64 || HAVE_MKSTEMP64)
 	{
 		int fd = mkstemp(template);
 		if (fd == -1)
 			return -1;
 		if (fchmod(fd, perms) != 0 && preserve_perms) {
 			int errno_save = errno;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2: test.sh
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite: backup.test
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite: batch-mode.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/chgrp.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/chgrp.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/chgrp.test	2004-02-05 09:37:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/chgrp.test	2004-05-21 18:06:09.000000000 +0800
@@ -6,30 +6,27 @@
 # COPYING).
 
 # Test that rsync with -gr will preserve groups when the user running
 # the test is a member of them.  Hopefully they're in at least one
 # test.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 # Build some hardlinks
 
-fromdir="$scratchdir/from"
-todir="$scratchdir/to"
-
 mygrps="`rsync_getgroups`" || fail "Can't get groups"
 mkdir "$fromdir"
 
 for g in $mygrps
 do
     name="$fromdir/foo-$g"
     date > "$name"
     chgrp "$g" "$name" || fail "Can't chgrp"
 done
 sleep 2
 
-checkit "$RSYNC -rtgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -rtgpvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite: chmod-temp-dir.test
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite: chmod.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/chown.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/chown.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/chown.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/chown.test	2004-05-18 08:41:35.000000000 +0800
@@ -8,21 +8,18 @@
 # Test that when rsync is running as root and has -a it correctly sets
 # the ownership of the destination.
 
 # We don't know what users will be present on this system, so we just
 # use random numeric uids and gids.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 # Build some hardlinks
 
-fromdir="$scratchdir/from"
-todir="$scratchdir/to"
-
 mkdir "$fromdir"
 name1="$fromdir/name1"
 name2="$fromdir/name2"
 echo "This is the file" > "$name1"
 echo "This is the other file" > "$name2"
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite: compare-dest.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/daemon-gzip-download.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/daemon-gzip-download.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/daemon-gzip-download.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/daemon-gzip-download.test	2004-05-18 08:41:51.000000000 +0800
@@ -24,10 +24,14 @@
 build_rsyncd_conf
 
 RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
 hands_setup
-checkit "$RSYNC -avvvvz localhost::test-from/ \"$TO/\"" "$FROM" "$TO"
+
+# Build chkdir with a normal rsync and an --exclude.
+$RSYNC -av --exclude=foobar.baz "$fromdir/" "$chkdir/"
+
+checkit "$RSYNC -avvvvz localhost::test-from/ \"$todir/\"" "$chkdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/daemon-gzip-upload.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/daemon-gzip-upload.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/daemon-gzip-upload.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/daemon-gzip-upload.test	2004-05-18 08:41:51.000000000 +0800
@@ -18,10 +18,14 @@
 build_rsyncd_conf
 
 RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
 hands_setup
-checkit "$RSYNC -avvvvz \"$FROM/\" localhost::test-to/" "$FROM" "$TO"
+
+# Build chkdir with a normal rsync and an --exclude.
+$RSYNC -av --exclude=foobar.baz "$fromdir/" "$chkdir/"
+
+checkit "$RSYNC -avvvvz \"$fromdir/\" localhost::test-to/" "$chkdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/devices.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/devices.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/devices.test	2004-04-09 08:36:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/devices.test	2004-09-24 00:34:43.000000000 +0800
@@ -4,21 +4,18 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test rsync handling of devices.  This can only run if you're root.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 # Build some hardlinks
 
-fromdir="$scratchdir/from"
-todir="$scratchdir/to"
-
 case `id -u` in
 '') ;; # If "id" failed, try to continue...
 0) ;;
 *) test_skipped "Rsync won't copy devices unless we're root" ;;
 esac
 
@@ -28,11 +25,12 @@
 mknod "$fromdir/char" c 41 67  || test_skipped "Can't create char device node unless root"
 mknod "$fromdir/char2" c 42 68  || test_skipped "Can't create char device node unless root"
 mknod "$fromdir/char3" c 42 69  || test_skipped "Can't create char device node unless root"
 mknod "$fromdir/block" b 42 69 || test_skipped "Can't create block device node unless root"
 mknod "$fromdir/block2" b 42 73 || test_skipped "Can't create block device node unless root"
 mknod "$fromdir/block3" b 105 73 || test_skipped "Can't create block device node unless root"
+mkfifo "$fromdir/fifo" || test_skipped "Can't run mkfifo"
 
 checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/duplicates.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/duplicates.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/duplicates.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/duplicates.test	2004-05-18 08:41:35.000000000 +0800
@@ -16,21 +16,18 @@
 
 # We don't need to worry about hardlinks or symlinks.  Because we
 # always rename-and-replace the new copy, they can't affect us.
 
 # This test is not great, because it is a timing-dependent bug.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 # Build some hardlinks
 
-fromdir="$scratchdir/from"
-todir="$scratchdir/to"
-
 mkdir "$fromdir"
 name1="$fromdir/name1"
 name2="$fromdir/name2"
 echo "This is the file" > "$name1"
 ln -s "$name1" "$name2" || fail "can't create symlink"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/exclude.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/exclude.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/exclude.test	2004-04-15 04:50:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/exclude.test	2004-05-24 08:16:07.000000000 +0800
@@ -7,49 +7,44 @@
 
 # Test rsync handling of exclude/include directives.  
 
 # Test some of the more obscure wildcard handling of exclude/include
 # processing.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 HOME="$scratchdir"
 CVSIGNORE='*.junk'
 export HOME CVSIGNORE
 
 # Build some files/dirs/links to copy
 
-fromdir="$scratchdir/from"
-todir="$scratchdir/to"
-chkdir="$scratchdir/chk"
-
-echo home-cvs-exclude >"$scratchdir"/.cvsignore
 makepath "$fromdir/foo/down/to/you"
 makepath "$fromdir/bar/down/to/foo/too"
 makepath "$fromdir/mid/for/foo/and/that/is/who"
 echo kept >"$fromdir/foo/file1"
 echo removed >"$fromdir/foo/file2"
 echo cvsout >"$fromdir/foo/file2.old"
+echo cvsout >"$fromdir/bar/down/to/home-cvs-exclude"
 echo keeper >"$fromdir/bar/down/to/foo/file1"
 echo cvsout >"$fromdir/bar/down/to/foo/file1.bak"
 echo gone >"$fromdir/bar/down/to/foo/file3"
 echo lost >"$fromdir/bar/down/to/foo/file4"
 echo cvsout >"$fromdir/bar/down/to/foo/file4.junk"
 echo smashed >"$fromdir/bar/down/to/foo/to"
-echo cvsout >"$fromdir/bar/down/to/home-cvs-exclude"
 echo cvsout >"$fromdir/mid/one-in-one-out"
 echo one-in-one-out >"$fromdir/mid/.cvsignore"
 echo cvsin >"$fromdir/mid/one-for-all"
+echo cvsin >"$fromdir/mid/for/one-in-one-out"
 echo expunged >"$fromdir/mid/for/foo/extra"
 echo retained >"$fromdir/mid/for/foo/keep"
-echo cvsin >"$fromdir/mid/for/one-in-one-out"
 ln -s too "$fromdir/bar/down/to/foo/sym"
 
-# Setup our test exclude/include file.
+# Setup our test exclude/include files.
 
 excl="$scratchdir/exclude-from"
 cat >"$excl" <<EOF
 # If the second line of these two lines does anything, it's a bug.
 + **/bar
 - /bar
@@ -62,12 +57,16 @@
 - to
 + file4
 - file[2-9]
 - /mid/for/foo/extra
 EOF
 
+cat >"$scratchdir/.cvsignore" <<EOF
+home-cvs-exclude
+EOF
+
 # Create the chk dir with what we expect to be excluded
 
 checkit "$RSYNC -avv \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
 
 sleep 1 # Ensures that the rm commands will tweak the directory times.
 
@@ -80,13 +79,13 @@
 # Un-tweak the directory times in our first (weak) exclude test (though
 # it's a good test of the --existing option).
 $RSYNC -av --existing --include='*/' --exclude='*' "$fromdir/" "$chkdir/"
 
 # Now, test if rsync excludes the same files.
 
-checkit "$RSYNC -avv --exclude-from=$excl \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+checkit "$RSYNC -avv --exclude-from=\"$excl\" \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
 
 # Modify the chk dir by removing cvs-ignored files and then tweaking the dir times.
 
 rm "$chkdir"/foo/*.old
 rm "$chkdir"/bar/down/to/foo/*.bak
 rm "$chkdir"/bar/down/to/foo/*.junk
@@ -95,11 +94,11 @@
 
 $RSYNC -av --existing --include='*/' --exclude='*' "$fromdir/" "$chkdir/"
 
 # Now, test if rsync excludes the same files, this time with --cvs-exclude
 # and --delete-excluded.
 
-checkit "$RSYNC -avvC --delete-excluded --exclude-from=$excl \
-    \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+checkit "$RSYNC -avvC --exclude-from=\"$excl\" \
+    --delete-excluded \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/hands.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/hands.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/hands.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/hands.test	2004-05-18 08:41:46.000000000 +0800
@@ -8,22 +8,22 @@
 . "$suitedir/rsync.fns"
 
 hands_setup
 
 # Main script starts here
 
-runtest "basic operation" 'checkit "$RSYNC -av ${FROM}/ ${TO}" ${FROM}/ ${TO}'
+runtest "basic operation" 'checkit "$RSYNC -av \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
-ln ${FROM}/filelist ${FROM}/dir
-runtest "hard links" 'checkit "$RSYNC -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
+ln "$fromdir/filelist" "$fromdir/dir"
+runtest "hard links" 'checkit "$RSYNC -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
-rm ${TO}/text
-runtest "one file" 'checkit "$RSYNC -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
+rm "$todir/text"
+runtest "one file" 'checkit "$RSYNC -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
-echo "extra line" >> ${TO}/text
-runtest "extra data" 'checkit "$RSYNC -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
+echo "extra line" >> "$todir/text"
+runtest "extra data" 'checkit "$RSYNC -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
-cp ${FROM}/text ${TO}/ThisShouldGo
-runtest " --delete" 'checkit "$RSYNC --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
+cp "$fromdir/text" "$todir/ThisShouldGo"
+runtest " --delete" 'checkit "$RSYNC --delete -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/hardlinks.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/hardlinks.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/hardlinks.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/hardlinks.test	2004-05-18 08:41:40.000000000 +0800
@@ -7,13 +7,13 @@
 
 # Test rsync handling of hardlinks.  By default (in 2.5.1) rsync does
 # not detect symlinks and they get split into different files.  If you
 # specify -H, then hard links are detected and recreated as hardlinks
 # on the other end.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 # Build some hardlinks
 
 fromdir="$scratchdir/from"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/longdir.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/longdir.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/longdir.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/longdir.test	2004-05-18 17:47:42.000000000 +0800
@@ -8,17 +8,17 @@
 . "$suitedir/rsync.fns"
 
 # set -x
 
 hands_setup
 
-LONGNAME=This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job
-LONGDIR=$FROM/$LONGNAME/$LONGNAME/$LONGNAME
+longname=This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job
+longdir="$fromdir/$longname/$longname/$longname"
 
-makepath $LONGDIR || test_skipped "unable to create long directory"
-touch $LONGDIR/1 || test_skipped "unable to create files in long directory"
-date > ${LONGDIR}/1
-ls -la / > ${LONGDIR}/2
-checkit "$RSYNC --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}
+makepath "$longdir" || test_skipped "unable to create long directory"
+touch "$longdir/1" || test_skipped "unable to create files in long directory"
+date > "$longdir/1"
+ls -la / > "$longdir/2"
+checkit "$RSYNC --delete -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/merge.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/merge.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/merge.test	2004-05-01 01:24:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/merge.test	2004-05-18 08:41:38.000000000 +0800
@@ -4,24 +4,21 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Make sure we can merge files from multiple directories into one.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 # Build some files/dirs/links to copy
 
-fromdir="$scratchdir/from"
 from1dir="${fromdir}1"
 from2dir="${fromdir}2"
 from3dir="${fromdir}3"
-todir="$scratchdir/to"
-chkdir="$scratchdir/chk"
 
 mkdir "$from1dir" "$from2dir" "$from3dir"
 mkdir "$from2dir"/sub1 "$from3dir"/sub1
 mkdir "$from3dir"/sub2
 mkdir "$chkdir" "$chkdir"/sub1 "$chkdir"/sub2
 echo "one" >"$from1dir"/one
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/README.testsuite /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/README.testsuite
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/README.testsuite	2002-03-12 08:22:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/README.testsuite	2004-07-23 09:40:22.000000000 +0800
@@ -14,14 +14,14 @@
 You can use this to test a distribution build, or perhaps to run a new
 test suite against an old version of rsync.  Note that in accordance
 with the GNU Standards, installcheck does not look for rsync on the
 path.
 
 If the tests pass, you should see a report to that effect.  Some tests
-require being root or some other precondition, and so will normally be
-checked -- look at the test scripts for more information.
+require being root or some other precondition, and so will normally not
+be checked -- look at the test scripts for more information.
 
 If the tests fail, you will see rather more output.  The scratch
 directory will remain in the build directory.  It would be useful if
 you could include the log messages when reporting a failure.
 
 These tests also run automatically on the build farm, and you can see
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/rsync.fns /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/rsync.fns
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/rsync.fns	2004-02-04 15:32:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/rsync.fns	2004-09-17 01:16:36.000000000 +0800
@@ -15,35 +15,34 @@
 # 
 # You should have received a copy of the GNU Lesser General Public
 # License along with this program; if not, write to the Free Software
 # Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
 
-TMP="$scratchdir"
-FROM=${TMP}/from
-TO=${TMP}/to
-LOG=${TMP}/log
-RSYNC="$rsync_bin"
+tmpdir="$scratchdir"
+fromdir="$tmpdir/from"
+todir="$tmpdir/to"
+chkdir="$tmpdir/chk"
 
 # Berkley's nice.
 PATH="$PATH:/usr/ucb"
 
-if diff -u $srcdir/testsuite/rsync.fns $srcdir/testsuite/rsync.fns >/dev/null 2>&1; then
+if diff -u "$srcdir/testsuite/rsync.fns" "$srcdir/testsuite/rsync.fns" >/dev/null 2>&1; then
     diffopt="-u"
 else
     diffopt="-c"
 fi
 
 runtest() {
     echo $ECHO_N "Test $1: $ECHO_C"
     if eval "$2"
     then
-	echo "${ECHO_T}	done."
+	echo "$ECHO_T	done."
 	return 0
     else
-	echo "${ECHO_T} failed!"
+	echo "$ECHO_T failed!"
 	return 1
     fi
 }
 
 printmsg() {
     echo "$1"
@@ -57,57 +56,65 @@
 rsync_getgroups() { 
     "$TOOLDIR/getgroups"
 }
 
 
 ####################
-# Build test directories TO and FROM, with FROM full of files.
+# Build test directories $todir and $fromdir, with $fromdir full of files.
 
 hands_setup() {
     # Clean before creation
-    rm -rf $FROM
-    rm -rf $TO
+    rm -rf "$fromdir"
+    rm -rf "$todir"
 
-    [ -d $TMP ] || mkdir $TMP
-    [ -d $FROM ] || mkdir $FROM
-    [ -d $TO ] || mkdir $TO
+    [ -d "$tmpdir" ] || mkdir "$tmpdir"
+    [ -d "$fromdir" ] || mkdir "$fromdir"
+    [ -d "$todir" ] || mkdir "$todir"
 
     # On some BSD systems, the umask affects the mode of created
     # symlinks, even though the mode apparently has no effect on how
     # the links behave in the future, and it cannot be changed using
     # chmod!  rsync always sets its umask to 000 so that it can
     # accurately recreate permissions, but this script is probably run
     # with a different umask. 
 
     # This causes a little problem that "ls -l" of the two will not be
     # the same.  So, we need to set our umask before doing any creations.
 
     # set up test data
-    touch ${FROM}/empty
-    mkdir ${FROM}/emptydir
+    touch "$fromdir/empty"
+    mkdir "$fromdir/emptydir"
 
     # a hundred lines of text or so
-    rsync_ls_lR "${srcdir}" > ${FROM}/filelist
+    rsync_ls_lR "$srcdir" > "$fromdir/filelist"
 
-    # This might fail on systems that don't have -n
-    echo $ECHO_N "This file has no trailing lf$ECHO_C" > ${FROM}/nolf
+    echo $ECHO_N "This file has no trailing lf$ECHO_C" > "$fromdir/nolf"
     umask 0
-    ln -s nolf ${FROM}/nolf-symlink
+    ln -s nolf "$fromdir/nolf-symlink"
     umask 022
 
-    cat $srcdir/*.c > ${FROM}/text
-    mkdir ${FROM}/dir
-    cp ${FROM}/text ${FROM}/dir
-    mkdir ${FROM}/dir/subdir
-    mkdir ${FROM}/dir/subdir/subsubdir
-    ls -ltr /etc > ${FROM}/dir/subdir/subsubdir/etc-ltr-list
-    mkdir ${FROM}/dir/subdir/subsubdir2
-    ls -lt /bin > ${FROM}/dir/subdir/subsubdir2/bin-lt-list
+    cat $srcdir/*.c > "$fromdir/text"
+    mkdir "$fromdir/dir"
+    cp "$fromdir/text" "$fromdir/dir"
+    mkdir "$fromdir/dir/subdir"
+    echo some data > "$fromdir/dir/subdir/foobar.baz"
+    mkdir "$fromdir/dir/subdir/subsubdir"
+    if [ -r /etc ]; then
+	ls -ltr /etc > "$fromdir/dir/subdir/subsubdir/etc-ltr-list"
+    else
+	ls -ltr / > "$fromdir/dir/subdir/subsubdir/etc-ltr-list"
+    fi
+    mkdir "$fromdir/dir/subdir/subsubdir2"
+    if [ -r /bin ]; then
+	ls -lt /bin > "$fromdir/dir/subdir/subsubdir2/bin-lt-list"
+    else
+	ls -lt / > "$fromdir/dir/subdir/subsubdir2/bin-lt-list"
+    fi
 
 #      echo testing head:
-#      ls -lR ${srcdir} | head -10 || echo failed
+#      ls -lR "$srcdir" | head -10 || echo failed
 }
 
 
 ####################
 # Many machines do not have "mkdir -p", so we have to build up long paths.
 # How boring.  
@@ -166,16 +173,16 @@
         diff $diffopt "$2"/"$f" "$3"/"$f" || failed=YES
     done
 
     echo "-------------"
     echo "check how the directory listings compare with diff:"
     echo ""
-    ( cd "$2" && rsync_ls_lR . ) > ${TMP}/ls-from 
-    ( cd "$3" && rsync_ls_lR . ) > ${TMP}/ls-to 
-    diff $diffopt ${TMP}/ls-from ${TMP}/ls-to || failed=YES
-    if [ -z "${failed}" ] ; then
+    ( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
+    ( cd "$3" && rsync_ls_lR . ) > "$tmpdir/ls-to"
+    diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to" || failed=YES
+    if [ -z "$failed" ] ; then
 	return 0
     else
 	return 1
     fi
 }
 
@@ -186,38 +193,37 @@
     echo "building configuration $conf"
 
     port=2612
     pidfile="$scratchdir/rsyncd.pid"
     logfile="$scratchdir/rsyncd.log"
 
-    cat >$conf <<EOF
+    cat >"$conf" <<EOF
 # rsyncd configuration file autogenerated by $0
 
 pid file = $pidfile
 use chroot = no
 hosts allow = localhost, 127.0.0.1
 log file = $logfile
+exclude = foobar.baz
 max verbosity = 9
 
 uid = 0
 gid = 0
 
 [test-from]
-	path = $FROM
+	path = $fromdir
 	read only = yes
 
 [test-to]
-	path = $TO
+	path = $todir
 	read only = no
 EOF
 }
 
 
 build_symlinks() {
-    fromdir="$scratchdir/from"
-    todir="$scratchdir/to"
     mkdir "$fromdir"
     date >"$fromdir/referent"
     ln -s referent "$fromdir/relative"
     ln -s "$fromdir/referent" "$fromdir/absolute"
     ln -s nonexistent "$fromdir/dangling"
     ln -s "$srcdir/rsync.c" "$fromdir/unsafe"
@@ -227,13 +233,13 @@
     echo "$@" >&2
     exit 1
 }
 
 test_skipped() {
     echo "$@" >&2
-    echo "$@" > "$TMP/whyskipped"
+    echo "$@" > "$tmpdir/whyskipped"
     exit 77
 }
 
 # It failed, but we expected that.  don't dump out error logs, 
 # because most users won't want to see them.  But do leave
 # the working directory around.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/ssh-basic.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/ssh-basic.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/ssh-basic.test	2003-02-20 00:22:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/ssh-basic.test	2004-05-18 08:41:46.000000000 +0800
@@ -21,23 +21,23 @@
 
 if ! [ "`ssh -o'BatchMode yes' localhost echo yes`" = "yes" ]; then
     test_skipped "Skipping SSH tests because ssh conection to localhost not authorised"
 fi
 
 # Added by Steve Bonds Feb 2 2003
-# Without this, there are no files in the ${FROM} directory, so rsync has
+# Without this, there are no files in the $fromdir directory, so rsync has
 # nothing to do.
 hands_setup
 
-runtest "ssh: basic test" 'checkit "$RSYNC -avH -e ssh --rsync-path=$RSYNC ${FROM}/ localhost:${TO}" ${FROM}/ ${TO}'
+runtest "ssh: basic test" 'checkit "$RSYNC -avH -e ssh --rsync-path=$RSYNC \"$fromdir/\" \"localhost:$todir\"" "$fromdir/" "$todir"'
 
 # Added by Steve Bonds Feb 2 2003
 # I assumed that "F1" was intended to hold a single file for testing if
 # rsync could detect a renamed file over ssh.  Without this line below
 # it was unset so the "mv" tried to move a parent directory into a
 # subdirectory of itself.  There is probably a better way of pulling out
 # a sample file to rename.
-F1=`ls ${TO} | head -5 | tail -1`
+F1=`ls "$todir" | head -5 | tail -1`
 
-mv ${TO}/${F1} ${TO}/ThisShouldGo
+mv "$todir/$F1" "$todir/ThisShouldGo"
 
-runtest "ssh: renamed file" 'checkit "$RSYNC --delete -avH -e ssh --rsync-path=$RSYNC ${FROM}/ localhost:${TO}" ${FROM}/ ${TO}'
+runtest "ssh: renamed file" 'checkit "$RSYNC --delete -avH -e ssh --rsync-path=$RSYNC \"$fromdir/\" \"localhost:$todir\"" "$fromdir/" "$todir"'
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/symlink-ignore.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/symlink-ignore.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/symlink-ignore.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/symlink-ignore.test	2004-05-18 08:41:40.000000000 +0800
@@ -5,35 +5,35 @@
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test rsync's somewhat over-featured symlink control: the default
 # behaviour is that symlinks should not be copied at all.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 build_symlinks || test_fail "failed to build symlinks"
 
 # Copy recursively, but without -l or -L or -a, and all the symlinks
 # should be missing.
 $RSYNC -r "$fromdir/" "$todir" || test_fail "$RSYNC returned $?"
 
-[ -f "${todir}/referent" ] || test_fail "referent was not copied"
-[ -d "${todir}/from" ] && test_fail "extra level of directories"
-if is_a_link "${todir}/dangling" 
+[ -f "$todir/referent" ] || test_fail "referent was not copied"
+[ -d "$todir/from" ] && test_fail "extra level of directories"
+if is_a_link "$todir/dangling" 
 then 
     test_fail "dangling symlink was copied"
 fi
 
-if is_a_link "${todir}/relative" 
+if is_a_link "$todir/relative" 
 then
     test_fail "relative symlink was copied" 
 fi
 
-if is_a_link "${todir}/absolute" 
+if is_a_link "$todir/absolute" 
 then
     test_fail "absolute symlink was copied"
 fi
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/trimslash.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/trimslash.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/trimslash.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/trimslash.test	2004-05-18 08:41:40.000000000 +0800
@@ -4,13 +4,13 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test tiny function to trim trailing slashes.
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 "$TOOLDIR/trimslash" "/usr/local/bin" "/usr/local/bin/" "/usr/local/bin///" \
 	"//a//" "////" \
         "/Users/Wierd Macintosh Name/// Ooh, translucent plastic/" \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/unsafe-byname.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/unsafe-byname.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/unsafe-byname.test	2003-01-20 20:42:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/unsafe-byname.test	2004-05-18 08:41:40.000000000 +0800
@@ -1,13 +1,13 @@
 #! /bin/sh
 
 # Copyright (C) 2002 by Martin Pool
 
 # Call directly into unsafe_symlink and test its handling of various filenames
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 test_unsafe() {
     # $1 is the target of a symlink
     # $2 is the directory we're copying
     # $3 is the expected outcome: "safe" if the link lies within $2,
     # or "unsafe" otherwise
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/unsafe-links.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/unsafe-links.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/unsafe-links.test	2003-01-16 00:14:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/unsafe-links.test	2004-05-18 08:41:43.000000000 +0800
@@ -1,23 +1,23 @@
 #! /bin/sh
 
 # Originally by Vladimr Michl <Vladimir.Michl@hlubocky.del.cz>
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 test_symlink() {
 	is_a_link "$1" || test_fail "File $1 is not a symlink"
 };
 
 test_regular() {
 	if [ ! -f "$1" ]; then
 		test_fail "File $1 is not regular file or not exists";
 	fi;
 };
 
-cd "$TMP"
+cd "$tmpdir"
 
 mkdir from
 
 mkdir "from/safe"
 mkdir "from/unsafe"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/wildmatch.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/wildmatch.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/testsuite/wildmatch.test	2004-02-05 02:24:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/testsuite/wildmatch.test	2004-05-18 08:41:40.000000000 +0800
@@ -4,13 +4,13 @@
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test the wildmatch functionality
 
-. $srcdir/testsuite/rsync.fns
+. "$suitedir/rsync.fns"
 
 set -x
 
 "$TOOLDIR/wildtest" "$srcdir/wildtest.txt" >"$scratchdir/wild.out"
 diff $diffopt "$scratchdir/wild.out" - <<EOF
 No wildmatch errors found.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/tls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/tls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/tls.c	2004-04-10 04:22:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/tls.c	2004-09-23 13:33:48.000000000 +0800
@@ -46,32 +46,31 @@
 int dry_run = 0;
 int read_only = 1;
 int list_only = 0;
 int preserve_perms = 0;
 
 
-static void failed (char const *what,
-		    char const *where)
+static void failed(char const *what, char const *where)
 {
-	fprintf (stderr, PROGRAM ": %s %s: %s\n",
-		 what, where, strerror (errno));
-	exit (1);
+	fprintf(stderr, PROGRAM ": %s %s: %s\n",
+		what, where, strerror(errno));
+	exit(1);
 }
 
 
 
-static void list_file (const char *fname)
+static void list_file(const char *fname)
 {
 	STRUCT_STAT buf;
 	char permbuf[PERMSTRING_SIZE];
 	struct tm *mt;
 	char datebuf[50];
 	char linkbuf[4096];
 
 	if (do_lstat(fname, &buf) == -1)
-		failed ("stat", fname);
+		failed("stat", fname);
 
 	/* The size of anything but a regular file is probably not
 	 * worth thinking about. */
 	if (!S_ISREG(buf.st_mode))
 		buf.st_size = 0;
 
@@ -111,13 +110,13 @@
 		strcpy(datebuf, "                   ");
 	}
 
 	/* TODO: Perhaps escape special characters in fname? */
 
 	printf("%s ", permbuf);
-	if (IS_DEVICE(buf.st_mode)) {
+	if (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)) {
 		printf("%5ld,%6ld",
 		    (long)major(buf.st_rdev),
 		    (long)minor(buf.st_rdev));
 	} else /* NB: use double for size since it might not fit in a long. */
 		printf("%12.0f", (double)buf.st_size);
 	printf(" %6ld.%-6ld %6ld %s %s%s\n",
@@ -127,17 +126,17 @@
 
 
 int
 main(int argc, char *argv[])
 {
 	if (argc < 2) {
-		fprintf (stderr, "usage: " PROGRAM " DIR ...\n"
-			 "Trivial file listing program for portably checking rsync\n");
+		fprintf(stderr, "usage: " PROGRAM " DIR ...\n"
+			"Trivial file listing program for portably checking rsync\n");
 		return 1;
 	}
 
 	for (argv++; *argv; argv++) {
-		list_file (*argv);
+		list_file(*argv);
 	}
 
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/TODO	2004-04-30 05:12:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/TODO	2004-06-07 04:41:01.000000000 +0800
@@ -18,19 +18,18 @@
 Lazy directory creation
 proxy authentication						2002/01/23
 SOCKS								2002/01/23
 FAT support
 Allow forcing arbitrary permissions				2002/03/12
 --diff						david.e.sewell	2002/03/15
-Add daemon --no-detach and --no-fork options
+Add daemon --no-fork option
 Create more granular verbosity				jw	2003/05/15
 
 DOCUMENTATION --------------------------------------------------------
 Update README
 Keep list of open issues and todos on the web site
-Update web site from CVS
 Perhaps redo manual as SGML
 
 LOGGING --------------------------------------------------------------
 Make dry run list all updates					2002/04/03
 Memory accounting
 Improve error messages
@@ -323,13 +322,13 @@
 
   Security interactions with daemon mode?
 
                       --          --
 
 
-Add daemon --no-detach and --no-fork options
+Add daemon --no-fork option
 
   Very useful for debugging.  Also good when running under a
   daemon-monitoring process that tries to restart the service when the
   parent exits.
 
                       --          --
@@ -359,17 +358,12 @@
 
 Keep list of open issues and todos on the web site
 
                       --          --
 
 
-Update web site from CVS
-
-                      --          --
-
-
 Perhaps redo manual as SGML
 
   The man page is getting rather large, and there is more information
   that ought to be added.
 
   TexInfo source is probably a dying format.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/token.c	2004-01-06 13:33:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/token.c	2004-07-15 10:20:08.000000000 +0800
@@ -1,59 +1,63 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1996
    Copyright (C) Paul Mackerras 1996
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 #include "zlib/zlib.h"
 
 extern int do_compression;
+extern int module_id;
+
 static int compression_level = Z_DEFAULT_COMPRESSION;
 
 /* determine the compression level based on a wildcard filename list */
 void set_compression(char *fname)
 {
-	extern int module_id;
 	char *dont;
 	char *tok;
 
-	if (!do_compression) return;
+	if (!do_compression)
+		return;
 
 	compression_level = Z_DEFAULT_COMPRESSION;
 	dont = lp_dont_compress(module_id);
 
-	if (!dont || !*dont) return;
+	if (!dont || !*dont)
+		return;
 
-	if ((dont[0] == '*') && (!dont[1])) {
+	if (dont[0] == '*' && !dont[1]) {
 		/* an optimization to skip the rest of this routine */
 		compression_level = 0;
 		return;
 	}
 
 	dont = strdup(dont);
 	fname = strdup(fname);
-	if (!dont || !fname) return;
+	if (!dont || !fname)
+		return;
 
 	strlower(dont);
 	strlower(fname);
 
-	for (tok=strtok(dont," ");tok;tok=strtok(NULL," ")) {
+	for (tok = strtok(dont, " "); tok; tok = strtok(NULL, " ")) {
 		if (wildmatch(tok, fname)) {
 			compression_level = 0;
 			break;
 		}
 	}
 	free(dont);
@@ -66,18 +70,20 @@
 	static int residue;
 	static char *buf;
 	int n;
 
 	if (!buf) {
 		buf = new_array(char, CHUNK_SIZE);
-		if (!buf) out_of_memory("simple_recv_token");
+		if (!buf)
+			out_of_memory("simple_recv_token");
 	}
 
 	if (residue == 0) {
 		int i = read_int(f);
-		if (i <= 0) return i;
+		if (i <= 0)
+			return i;
 		residue = i;
 	}
 
 	*data = buf;
 	n = MIN(CHUNK_SIZE,residue);
 	residue -= n;
@@ -87,35 +93,24 @@
 
 
 /* non-compressing send token */
 static void simple_send_token(int f,int token,
 			      struct map_struct *buf,OFF_T offset,int n)
 {
-	extern int write_batch;
-	int hold_int;
-
 	if (n > 0) {
 		int l = 0;
 		while (l < n) {
 			int n1 = MIN(CHUNK_SIZE,n-l);
 			write_int(f,n1);
 			write_buf(f,map_ptr(buf,offset+l,n1),n1);
-			if (write_batch) {
-				write_batch_delta_file( (char *) &n1, sizeof(int) );
-				write_batch_delta_file(map_ptr(buf,offset+l,n1),n1);
-			}
 			l += n1;
 		}
 	}
 	/* a -2 token means to send data only and no token */
 	if (token != -2) {
 		write_int(f,-(token+1));
-		if (write_batch) {
-			hold_int = -(token+1);
-			write_batch_delta_file( (char *) &hold_int, sizeof(int) );
-		}
 	}
 }
 
 
 /* Flag bytes in compressed stream are encoded as follows: */
 #define END_FLAG	0	/* that's all folks */
@@ -156,14 +151,12 @@
 static void
 send_deflated_token(int f, int token,
 		    struct map_struct *buf, OFF_T offset, int nb, int toklen)
 {
 	int n, r;
 	static int init_done, flush_pending;
-	extern int write_batch;
-	char temp_byte;
 
 	if (last_token == -1) {
 		/* initialization */
 		if (!init_done) {
 			tx_strm.next_in = NULL;
 			tx_strm.zalloc = NULL;
@@ -190,34 +183,19 @@
 		   || token >= run_start + 65536) {
 		/* output previous run */
 		r = run_start - last_run_end;
 		n = last_token - run_start;
 		if (r >= 0 && r <= 63) {
 			write_byte(f, (n==0? TOKEN_REL: TOKENRUN_REL) + r);
-			if (write_batch) {
-				temp_byte = (char)( (n==0? TOKEN_REL: TOKENRUN_REL) + r);
-				write_batch_delta_file(&temp_byte,sizeof(char));
-			}
 		} else {
 			write_byte(f, (n==0? TOKEN_LONG: TOKENRUN_LONG));
 			write_int(f, run_start);
-			if (write_batch) {
-				temp_byte = (char)(n==0? TOKEN_LONG: TOKENRUN_LONG);
-				write_batch_delta_file(&temp_byte,sizeof(char));
-				write_batch_delta_file((char *)&run_start,sizeof(run_start));
-			}
 		}
 		if (n != 0) {
 			write_byte(f, n);
 			write_byte(f, n >> 8);
-			if (write_batch) {
-				temp_byte = (char)n;
-				write_batch_delta_file(&temp_byte,sizeof(char));
-				temp_byte = (char)(n >> 8);
-				write_batch_delta_file(&temp_byte,sizeof(char));
-			}
 		}
 		last_run_end = last_token;
 		run_start = token;
 	}
 
 	last_token = token;
@@ -270,28 +248,21 @@
 					n -= 4;
 				}
 				if (n > 0) {
 					obuf[0] = DEFLATED_DATA + (n >> 8);
 					obuf[1] = n;
 					write_buf(f, obuf, n+2);
-					if (write_batch)
-						write_batch_delta_file(obuf,n+2);
 				}
 			}
 		} while (nb != 0 || tx_strm.avail_out == 0);
 		flush_pending = token == -2;
 	}
 
 	if (token == -1) {
 		/* end of file - clean up */
 		write_byte(f, END_FLAG);
-		if (write_batch) {
-			temp_byte = END_FLAG;
-			write_batch_delta_file(&temp_byte,sizeof(char));
-		}
-
 	} else if (token != -2) {
 		/* add the data in the current block to the compressor's
 		   history and hash table */
 		tx_strm.next_in = (Bytef *) map_ptr(buf, offset, toklen);
 		tx_strm.avail_in = toklen;
 		tx_strm.next_out = (Bytef *) obuf;
@@ -488,13 +459,13 @@
 		}
 	} while (len || rx_strm.avail_out == 0);
 }
 
 /**
  * Transmit a verbatim buffer of length @p n followed by a token.
- * If token == -1 then we have reached EOF 
+ * If token == -1 then we have reached EOF
  * If n == 0 then don't send a buffer
  */
 void send_token(int f,int token,struct map_struct *buf,OFF_T offset,
 		int n,int toklen)
 {
 	if (!do_compression) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/t_stub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/t_stub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/t_stub.c	2004-04-22 17:58:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/t_stub.c	2004-07-30 00:06:38.000000000 +0800
@@ -25,22 +25,33 @@
  * This file contains really simple implementations for rsync global
  * functions, so that module test harnesses can run standalone.
  **/
 
 int modify_window = 0;
 int module_id = -1;
+char *partial_dir;
 struct exclude_list_struct server_exclude_list;
 
  void rprintf(UNUSED(enum logcode code), const char *format, ...)
 {
 	va_list ap;
 	va_start(ap, format);
 	vfprintf(stderr, format, ap);
 	va_end(ap);
 }
 
+ void rsyserr(UNUSED(enum logcode code), int errcode, const char *format, ...)
+{
+	va_list ap;
+	fputs(RSYNC_NAME ": ", stderr);
+	va_start(ap, format);
+	vfprintf(stderr, format, ap);
+	va_end(ap);
+	fprintf(stderr, ": %s (%d)\n", strerror(errcode), errcode);
+}
+
  void _exit_cleanup(int code, const char *file, int line)
 {
 	fprintf(stderr, "exit(%d): %s(%d)\n",
 		code, file, line);
 	exit(code);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.2/util.c	2004-04-28 03:59:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.3/util.c	2004-09-08 05:26:26.000000000 +0800
@@ -25,12 +25,16 @@
  * Utilities used in rsync
  **/
 
 #include "rsync.h"
 
 extern int verbose;
+extern int dry_run;
+extern int module_id;
+extern int modify_window;
+extern char *partial_dir;
 extern struct exclude_list_struct server_exclude_list;
 
 int sanitize_paths = 0;
 
 
 
@@ -123,19 +127,18 @@
 }
 
 
 
 int set_modtime(char *fname, time_t modtime)
 {
-	extern int dry_run;
 	if (dry_run)
 		return 0;
 
 	if (verbose > 2) {
 		rprintf(FINFO, "set modtime of %s to (%ld) %s",
-			fname, (long) modtime,
+			fname, (long)modtime,
 			asctime(localtime(&modtime)));
 	}
 
 	{
 #ifdef HAVE_UTIMBUF
 		struct utimbuf tbuf;
@@ -191,13 +194,13 @@
  * @retval len upon success
  *
  * @retval <0 write's (negative) error code
  *
  * Derived from GNU C's cccp.c.
  */
-static int full_write(int desc, char *ptr, size_t len)
+int full_write(int desc, char *ptr, size_t len)
 {
 	int total_written;
 
 	total_written = 0;
 	while (len > 0) {
 		int written = write(desc, ptr, len);
@@ -239,67 +242,62 @@
 	return n_chars;
 }
 
 
 /** Copy a file.
  *
- * This is used in conjunction with the --temp-dir option */
+ * This is used in conjunction with the --temp-dir and --backup options */
 int copy_file(char *source, char *dest, mode_t mode)
 {
 	int ifd;
 	int ofd;
 	char buf[1024 * 8];
 	int len;   /* Number of bytes read into `buf'. */
 
 	ifd = do_open(source, O_RDONLY, 0);
 	if (ifd == -1) {
-		rprintf(FERROR,"open %s: %s\n",
-			full_fname(source), strerror(errno));
+		rsyserr(FERROR, errno, "open %s", full_fname(source));
 		return -1;
 	}
 
 	if (robust_unlink(dest) && errno != ENOENT) {
-		rprintf(FERROR,"unlink %s: %s\n",
-			full_fname(dest), strerror(errno));
+		rsyserr(FERROR, errno, "unlink %s", full_fname(dest));
 		return -1;
 	}
 
 	ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode);
 	if (ofd == -1) {
-		rprintf(FERROR,"open %s: %s\n",
-			full_fname(dest), strerror(errno));
+		rsyserr(FERROR, errno, "open %s", full_fname(dest));
 		close(ifd);
 		return -1;
 	}
 
 	while ((len = safe_read(ifd, buf, sizeof buf)) > 0) {
 		if (full_write(ofd, buf, len) < 0) {
-			rprintf(FERROR,"write %s: %s\n",
-				full_fname(dest), strerror(errno));
+			rsyserr(FERROR, errno, "write %s", full_fname(dest));
 			close(ifd);
 			close(ofd);
 			return -1;
 		}
 	}
 
 	if (len < 0) {
-		rprintf(FERROR, "read %s: %s\n",
-			full_fname(source), strerror(errno));
+		rsyserr(FERROR, errno, "read %s", full_fname(source));
 		close(ifd);
 		close(ofd);
 		return -1;
 	}
 
 	if (close(ifd) < 0) {
-		rprintf(FINFO, "close failed on %s: %s\n",
-			full_fname(source), strerror(errno));
+		rsyserr(FINFO, errno, "close failed on %s",
+			full_fname(source));
 	}
 
 	if (close(ofd) < 0) {
-		rprintf(FERROR, "close failed on %s: %s\n",
-			full_fname(dest), strerror(errno));
+		rsyserr(FERROR, errno, "close failed on %s",
+			full_fname(dest));
 		return -1;
 	}
 
 	return 0;
 }
 
@@ -361,14 +359,14 @@
 		return -1;
 	}
 	return 0;
 #endif
 }
 
-/* Returns 0 on success, -1 on most errors, and -2 if we got an error
- * trying to copy the file across file systems. */
+/* Returns 0 on successful rename, 1 if we successfully copied the file
+ * across filesystems, -2 if copy_file() failed, and -1 on other errors. */
 int robust_rename(char *from, char *to, int mode)
 {
 	int tries = 4;
 
 	while (tries--) {
 		if (do_rename(from, to) == 0)
@@ -382,13 +380,13 @@
 			break;
 #endif
 		case EXDEV:
 			if (copy_file(from, to, mode) != 0)
 				return -2;
 			do_unlink(from);
-			return 0;
+			return 1;
 		default:
 			return -1;
 		}
 	}
 	return -1;
 }
@@ -439,26 +437,28 @@
 
 
 /** Turn a user name into a uid */
 int name_to_uid(char *name, uid_t *uid)
 {
 	struct passwd *pass;
-	if (!name || !*name) return 0;
+	if (!name || !*name)
+		return 0;
 	pass = getpwnam(name);
 	if (pass) {
 		*uid = pass->pw_uid;
 		return 1;
 	}
 	return 0;
 }
 
 /** Turn a group name into a gid */
 int name_to_gid(char *name, gid_t *gid)
 {
 	struct group *grp;
-	if (!name || !*name) return 0;
+	if (!name || !*name)
+		return 0;
 	grp = getgrnam(name);
 	if (grp) {
 		*gid = grp->gr_gid;
 		return 1;
 	}
 	return 0;
@@ -493,93 +493,110 @@
 			*s++ = '/';
 		}
 	}
 	return 0;
 }
 
-static void glob_expand_one(char *s, char **argv, int *argc, int maxargs)
+static void glob_expand_one(char *s, char ***argv_ptr, int *argc_ptr,
+			    int *maxargs_ptr)
 {
+	char **argv = *argv_ptr;
+	int argc = *argc_ptr;
+	int maxargs = *maxargs_ptr;
 #if !(defined(HAVE_GLOB) && defined(HAVE_GLOB_H))
-	if (!*s) s = ".";
-	s = argv[*argc] = strdup(s);
+	if (argc == maxargs) {
+		maxargs += MAX_ARGS;
+		if (!(argv = realloc_array(argv, char *, maxargs)))
+			out_of_memory("glob_expand_one");
+		*argv_ptr = argv;
+		*maxargs_ptr = maxargs;
+	}
+	if (!*s)
+		s = ".";
+	s = argv[argc++] = strdup(s);
 	exclude_server_path(s);
-	(*argc)++;
 #else
-	extern int sanitize_paths;
 	glob_t globbuf;
 	int i;
 
-	if (!*s) s = ".";
+	if (maxargs <= argc)
+		return;
+	if (!*s)
+		s = ".";
 
-	s = argv[*argc] = strdup(s);
-	if (sanitize_paths) {
-		sanitize_path(s, NULL);
-	}
+	if (sanitize_paths)
+		s = sanitize_path(NULL, s, "", 0);
+	else
+		s = strdup(s);
 
 	memset(&globbuf, 0, sizeof globbuf);
 	if (!exclude_server_path(s))
 		glob(s, 0, NULL, &globbuf);
-	if (globbuf.gl_pathc == 0) {
-		(*argc)++;
-		globfree(&globbuf);
-		return;
+	if (MAX((int)globbuf.gl_pathc, 1) > maxargs - argc) {
+		maxargs += globbuf.gl_pathc + MAX_ARGS;
+		if (!(argv = realloc_array(argv, char *, maxargs)))
+			out_of_memory("glob_expand_one");
+		*argv_ptr = argv;
+		*maxargs_ptr = maxargs;
 	}
-	for (i = 0; i < maxargs - *argc && i < (int)globbuf.gl_pathc; i++) {
-		if (i == 0)
-			free(s);
-		argv[*argc + i] = strdup(globbuf.gl_pathv[i]);
-		if (!argv[*argc + i])
-			out_of_memory("glob_expand");
+	if (globbuf.gl_pathc == 0)
+		argv[argc++] = s;
+	else {
+		int j = globbuf.gl_pathc;
+		free(s);
+		for (i = 0; i < j; i++) {
+			if (!(argv[argc++] = strdup(globbuf.gl_pathv[i])))
+				out_of_memory("glob_expand_one");
+		}
 	}
 	globfree(&globbuf);
-	*argc += i;
 #endif
+	*argc_ptr = argc;
 }
 
 /* This routine is only used in daemon mode. */
-void glob_expand(char *base1, char **argv, int *argc, int maxargs)
+void glob_expand(char *base1, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr)
 {
-	char *s = argv[*argc];
+	char *s = (*argv_ptr)[*argc_ptr];
 	char *p, *q;
 	char *base = base1;
 	int base_len = strlen(base);
 
-	if (!s || !*s) return;
+	if (!s || !*s)
+		return;
 
 	if (strncmp(s, base, base_len) == 0)
 		s += base_len;
 
-	s = strdup(s);
-	if (!s) out_of_memory("glob_expand");
+	if (!(s = strdup(s)))
+		out_of_memory("glob_expand");
 
-	if (asprintf(&base," %s/", base1) <= 0) out_of_memory("glob_expand");
+	if (asprintf(&base," %s/", base1) <= 0)
+		out_of_memory("glob_expand");
 	base_len++;
 
-	q = s;
-	while ((p = strstr(q,base)) != NULL && *argc < maxargs) {
-		/* split it at this point */
-		*p = 0;
-		glob_expand_one(q, argv, argc, maxargs);
-		q = p + base_len;
+	for (q = s; *q; q = p + base_len) {
+		if ((p = strstr(q, base)) != NULL)
+			*p = '\0'; /* split it at this point */
+		glob_expand_one(q, argv_ptr, argc_ptr, maxargs_ptr);
+		if (!p)
+			break;
 	}
 
-	if (*q && *argc < maxargs)
-		glob_expand_one(q, argv, argc, maxargs);
-
 	free(s);
 	free(base);
 }
 
 /**
  * Convert a string to lower case
  **/
 void strlower(char *s)
 {
 	while (*s) {
-		if (isupper(* (unsigned char *) s))
-			*s = tolower(* (unsigned char *) s);
+		if (isupper(*(unsigned char *)s))
+			*s = tolower(*(unsigned char *)s);
 		s++;
 	}
 }
 
 /* Join strings p1 & p2 into "dest" with a guaranteed '/' between them.  (If
  * p1 ends with a '/', no extra '/' is inserted.)  Returns the length of both
@@ -630,196 +647,174 @@
 	*dest = '\0';
 	va_end(ap);
 
 	return ret;
 }
 
-void clean_fname(char *name)
+int count_dir_elements(const char *p)
 {
-	char *p;
-	int l;
-	int modified = 1;
+	int cnt = 0, new_component = 1;
+	while (*p) {
+		if (*p++ == '/')
+			new_component = 1;
+		else if (new_component) {
+			new_component = 0;
+			cnt++;
+		}
+	}
+	return cnt;
+}
 
-	if (!name) return;
+/* Turns multiple adjacent slashes into a single slash, gets rid of "./"
+ * elements (but not a trailing dot dir), removes a trailing slash, and
+ * optionally collapses ".." elements (except for those at the start of the
+ * string).  If the resulting name would be empty, change it into a ".". */
+unsigned int clean_fname(char *name, BOOL collapse_dot_dot)
+{
+	char *limit = name - 1, *t = name, *f = name;
+	int anchored;
 
-	while (modified) {
-		modified = 0;
+	if (!name)
+		return 0;
 
-		if ((p = strstr(name,"/./")) != NULL) {
-			modified = 1;
-			while (*p) {
-				p[0] = p[2];
-				p++;
-			}
+	if ((anchored = *f == '/') != 0)
+		*t++ = *f++;
+	while (*f) {
+		/* discard extra slashes */
+		if (*f == '/') {
+			f++;
+			continue;
 		}
-
-		if ((p = strstr(name,"//")) != NULL) {
-			modified = 1;
-			while (*p) {
-				p[0] = p[1];
-				p++;
+		if (*f == '.') {
+			/* discard "." dirs (but NOT a trailing '.'!) */
+			if (f[1] == '/') {
+				f += 2;
+				continue;
+			}
+			/* collapse ".." dirs */
+			if (collapse_dot_dot
+			    && f[1] == '.' && (f[2] == '/' || !f[2])) {
+				char *s = t - 1;
+				if (s == name && anchored) {
+					f += 2;
+					continue;
+				}
+				while (s > limit && *--s != '/') {}
+				if (s != t - 1 && (s < name || *s == '/')) {
+					t = s + 1;
+					f += 2;
+					continue;
+				}
+				limit = t + 2;
 			}
 		}
+		while (*f && (*t++ = *f++) != '/') {}
+	}
 
-		if (strncmp(p = name, "./", 2) == 0) {
-			modified = 1;
-			do {
-				p[0] = p[2];
-			} while (*p++);
-		}
+	if (t > name+anchored && t[-1] == '/')
+		t--;
+	if (t == name)
+		*t++ = '.';
+	*t = '\0';
 
-		l = strlen(p = name);
-		if (l > 1 && p[l-1] == '/') {
-			modified = 1;
-			p[l-1] = 0;
-		}
-	}
+	return t - name;
 }
 
-/**
- * Make path appear as if a chroot had occurred:
- *
- * @li 1. remove leading "/" (or replace with "." if at end)
- *
- * @li 2. remove leading ".." components (except those allowed by @p reldir)
+/* Make path appear as if a chroot had occurred.  This handles a leading
+ * "/" (either removing it or expanding it) and any leading or embedded
+ * ".." components that attempt to escape past the module's top dir.
  *
- * @li 3. delete any other "<dir>/.." (recursively)
+ * If dest is NULL, a buffer is allocated to hold the result.  It is legal
+ * to call with the dest and the path (p) pointing to the same buffer, but
+ * rootdir will be ignored to avoid expansion of the string.
  *
- * Can only shrink paths, so sanitizes in place.
+ * The rootdir string contains a value to use in place of a leading slash.
+ * Specify NULL to get the default of lp_path(module_id).
  *
- * While we're at it, remove double slashes and "." components like
- *   clean_fname() does, but DON'T remove a trailing slash because that
- *   is sometimes significant on command line arguments.
+ * If depth is >= 0, it is a count of how many '..'s to allow at the start
+ * of the path.  Use -1 to allow unlimited depth.
  *
- * If @p reldir is non-null, it is a sanitized directory that the path will be
- *    relative to, so allow as many ".." at the beginning of the path as
- *    there are components in reldir.  This is used for symbolic link targets.
- *    If reldir is non-null and the path began with "/", to be completely like
- *    a chroot we should add in depth levels of ".." at the beginning of the
- *    path, but that would blow the assumption that the path doesn't grow and
- *    it is not likely to end up being a valid symlink anyway, so just do
- *    the normal removal of the leading "/" instead.
+ * We also clean the path in a manner similar to clean_fname() but with a
+ * few differences: 
  *
- * Contributed by Dave Dykstra <dwd@bell-labs.com>
- */
-void sanitize_path(char *p, char *reldir)
+ * Turns multiple adjacent slashes into a single slash, gets rid of "." dir
+ * elements (INCLUDING a trailing dot dir), PRESERVES a trailing slash, and
+ * ALWAYS collapses ".." elements (except for those at the start of the
+ * string up to "depth" deep).  If the resulting name would be empty,
+ * change it into a ".". */
+char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth)
 {
 	char *start, *sanp;
-	int depth = 0;
-	int allowdotdot = 0;
+	int rlen = 0;
 
-	if (reldir) {
-		depth++;
-		while (*reldir) {
-			if (*reldir++ == '/') {
-				depth++;
-			}
+	if (dest != p) {
+		int plen = strlen(p);
+		if (*p == '/') {
+			if (!rootdir)
+				rootdir = lp_path(module_id);
+			rlen = strlen(rootdir);
+			depth = 0;
+			p++;
+		}
+		if (dest) {
+			if (rlen + plen + 1 >= MAXPATHLEN)
+				return NULL;
+		} else if (!(dest = new_array(char, rlen + plen + 1)))
+			out_of_memory("sanitize_path");
+		if (rlen) {
+			memcpy(dest, rootdir, rlen);
+			if (rlen > 1)
+				dest[rlen++] = '/';
 		}
 	}
-	start = p;
-	sanp = p;
-	while (*p == '/') {
-		/* remove leading slashes */
-		p++;
-	}
+
+	start = sanp = dest + rlen;
 	while (*p != '\0') {
+		/* discard leading or extra slashes */
+		if (*p == '/') {
+			p++;
+			continue;
+		}
 		/* this loop iterates once per filename component in p.
 		 * both p (and sanp if the original had a slash) should
 		 * always be left pointing after a slash
 		 */
 		if (*p == '.' && (p[1] == '/' || p[1] == '\0')) {
 			/* skip "." component */
-			while (*++p == '/') {
-				/* skip following slashes */
-				;
-			}
+			p++;
 			continue;
 		}
-		allowdotdot = 0;
 		if (*p == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\0')) {
 			/* ".." component followed by slash or end */
-			if (depth > 0 && sanp == start) {
-				/* allow depth levels of .. at the beginning */
-				--depth;
-				allowdotdot = 1;
-			} else {
+			if (depth <= 0 || sanp != start) {
 				p += 2;
-				if (*p == '/')
-					p++;
 				if (sanp != start) {
 					/* back up sanp one level */
 					--sanp; /* now pointing at slash */
 					while (sanp > start && sanp[-1] != '/') {
 						/* skip back up to slash */
 						sanp--;
 					}
 				}
 				continue;
 			}
-		}
-		while (1) {
-			/* copy one component through next slash */
-			*sanp++ = *p++;
-			if (*p == '\0' || p[-1] == '/') {
-				while (*p == '/') {
-					/* skip multiple slashes */
-					p++;
-				}
-				break;
-			}
-		}
-		if (allowdotdot) {
+			/* allow depth levels of .. at the beginning */
+			depth--;
 			/* move the virtual beginning to leave the .. alone */
-			start = sanp;
+			start = sanp + 3;
 		}
+		/* copy one component through next slash */
+		while (*p && (*sanp++ = *p++) != '/') {}
 	}
-	if (sanp == start && !allowdotdot) {
+	if (sanp == dest) {
 		/* ended up with nothing, so put in "." component */
-		/*
-		 * note that the !allowdotdot doesn't prevent this from
-		 *  happening in all allowed ".." situations, but I didn't
-		 *  think it was worth putting in an extra variable to ensure
-		 *  it since an extra "." won't hurt in those situations.
-		 */
 		*sanp++ = '.';
 	}
 	*sanp = '\0';
-}
 
-/* Works much like sanitize_path(), with these differences:  (1) a new buffer
- * is allocated for the sanitized path rather than modifying it in-place; (2)
- * a leading slash gets transformed into the rootdir value (which can be empty
- * or NULL if you just want the slash to get dropped); (3) no "reldir" can be
- * specified. */
-char *alloc_sanitize_path(const char *path, const char *rootdir)
-{
-	char *buf;
-	int rlen, plen = strlen(path);
-
-	if (*path == '/' && rootdir) {
-		rlen = strlen(rootdir);
-		if (rlen == 1)
-			path++;
-	} else
-		rlen = 0;
-	if (!(buf = new_array(char, rlen + plen + 1)))
-		out_of_memory("alloc_sanitize_path");
-	if (rlen)
-		memcpy(buf, rootdir, rlen);
-	memcpy(buf + rlen, path, plen + 1);
-
-	if (rlen > 1)
-		rlen++;
-	sanitize_path(buf + rlen, NULL);
-	if (rlen && buf[rlen] == '.' && buf[rlen+1] == '\0') {
-		if (rlen > 1)
-			rlen--;
-		buf[rlen] = '\0';
-	}
-
-	return buf;
+	return dest;
 }
 
 char curr_dir[MAXPATHLEN];
 unsigned int curr_dir_len;
 
 /**
@@ -857,13 +852,13 @@
 	} else {
 		curr_dir[curr_dir_len++] = '/';
 		memcpy(curr_dir + curr_dir_len, dir, len + 1);
 		curr_dir_len += len;
 	}
 
-	clean_fname(curr_dir);
+	curr_dir_len = clean_fname(curr_dir, 1);
 
 	return 1;
 }
 
 /**
  * Reverse a push_dir() call.  You must pass in an absolute path
@@ -879,26 +874,50 @@
 		curr_dir_len = sizeof curr_dir - 1;
 
 	return 1;
 }
 
 /**
+ * Return the filename, turning any newlines into '?'s.  This ensures that
+ * outputting it on a line of its own cannot generate an empty line.  This
+ * function can handle only 2 names at a time!
+ **/
+const char *safe_fname(const char *fname)
+{
+	static char fbuf1[MAXPATHLEN], fbuf2[MAXPATHLEN];
+	static char *fbuf = fbuf2;
+	char *nl = strchr(fname, '\n');
+
+	if (!nl)
+		return fname;
+
+	fbuf = fbuf == fbuf1 ? fbuf2 : fbuf1;
+	strlcpy(fbuf, fname, MAXPATHLEN);
+	nl = fbuf + (nl - (char *)fname);
+	do {
+		*nl = '?';
+	} while ((nl = strchr(nl+1, '\n')) != NULL);
+
+	return fbuf;
+}
+
+/**
  * Return a quoted string with the full pathname of the indicated filename.
  * The string " (in MODNAME)" may also be appended.  The returned pointer
  * remains valid until the next time full_fname() is called.
  **/
-char *full_fname(char *fn)
+char *full_fname(const char *fn)
 {
-	extern int module_id;
 	static char *result = NULL;
 	char *m1, *m2, *m3;
 	char *p1, *p2;
 
 	if (result)
 		free(result);
 
+	fn = safe_fname(fn);
 	if (*fn == '/')
 		p1 = p2 = "";
 	else {
 		p1 = curr_dir;
 		p2 = "/";
 	}
@@ -924,12 +943,75 @@
 
 	asprintf(&result, "\"%s%s%s\"%s%s%s", p1, p2, fn, m1, m2, m3);
 
 	return result;
 }
 
+static char partial_fname[MAXPATHLEN];
+
+char *partial_dir_fname(const char *fname)
+{
+	char *t = partial_fname;
+	int sz = sizeof partial_fname;
+	const char *fn;
+
+	if ((fn = strrchr(fname, '/')) != NULL) {
+		fn++;
+		if (*partial_dir != '/') {
+			int len = fn - fname;
+			strncpy(t, fname, len); /* safe */
+			t += len;
+			sz -= len;
+		}
+	} else
+		fn = fname;
+	if ((int)pathjoin(t, sz, partial_dir, fn) >= sz)
+		return NULL;
+	if (server_exclude_list.head
+	    && check_exclude(&server_exclude_list, partial_fname, 0) < 0)
+		return NULL;
+
+	return partial_fname;
+}
+
+/* If no --partial-dir option was specified, we don't need to do anything
+ * (the partial-dir is essentially '.'), so just return success. */
+int handle_partial_dir(const char *fname, int create)
+{
+	char *fn, *dir;
+
+	if (fname != partial_fname)
+		return 1;
+	if (!create && *partial_dir == '/')
+		return 1;
+	if (!(fn = strrchr(partial_fname, '/')))
+		return 1;
+
+	*fn = '\0';
+	dir = partial_fname;
+	if (create) {
+		STRUCT_STAT st;
+#if SUPPORT_LINKS
+		int statret = do_lstat(dir, &st);
+#else
+		int statret = do_stat(dir, &st);
+#endif
+		if (statret == 0 && !S_ISDIR(st.st_mode)) {
+			if (do_unlink(dir) < 0)
+				return 0;
+			statret = -1;
+		}
+		if (statret < 0 && do_mkdir(dir, 0700) < 0)
+			return 0;
+	} else
+		do_rmdir(dir);
+	*fn = '/';
+
+	return 1;
+}
+
 /** We need to supply our own strcmp function for file list comparisons
    to ensure that signed/unsigned usage is consistent between machines. */
 int u_strcmp(const char *cs1, const char *cs2)
 {
 	const uchar *s1 = (const uchar *)cs1;
 	const uchar *s2 = (const uchar *)cs2;
@@ -970,13 +1052,14 @@
 int unsafe_symlink(const char *dest, const char *src)
 {
 	const char *name, *slash;
 	int depth = 0;
 
 	/* all absolute and null symlinks are unsafe */
-	if (!dest || !*dest || *dest == '/') return 1;
+	if (!dest || !*dest || *dest == '/')
+		return 1;
 
 	/* find out what our safety margin is */
 	for (name = src; (slash = strchr(name, '/')) != 0; name = slash+1) {
 		if (strncmp(name, "../", 3) == 0) {
 			depth = 0;
 		} else if (strncmp(name, "./", 2) == 0) {
@@ -1038,13 +1121,12 @@
 int msleep(int t)
 {
 	int tdiff = 0;
 	struct timeval tval, t1, t2;
 
 	gettimeofday(&t1, NULL);
-	gettimeofday(&t2, NULL);
 
 	while (tdiff < t) {
 		tval.tv_sec = (t-tdiff)/1000;
 		tval.tv_usec = 1000*((t-tdiff)%1000);
 
 		errno = 0;
@@ -1069,19 +1151,19 @@
  * @retval +1 if the first is later
  *
  * @retval -1 if the 2nd is later
  **/
 int cmp_modtime(time_t file1, time_t file2)
 {
-	extern int modify_window;
-
 	if (file2 > file1) {
-		if (file2 - file1 <= modify_window) return 0;
+		if (file2 - file1 <= modify_window)
+			return 0;
 		return -1;
 	}
-	if (file1 - file2 <= modify_window) return 0;
+	if (file1 - file2 <= modify_window)
+		return 0;
 	return 1;
 }
 
 
 #ifdef __INSURE__XX
 #include <dlfcn.h>
