diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/access.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/access.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/access.c	2000-08-19 21:04:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/access.c	2003-01-20 21:46:28.000000000 +0800
@@ -27,60 +27,172 @@
 static int match_hostname(char *host, char *tok)
 {
 	if (!host || !*host) return 0;
 	return (fnmatch(tok, host, 0) == 0);
 }
 
+static int match_binary(char *b1, char *b2, char *mask, int addrlen)
+{
+	int i;
+
+	for (i=0; i<addrlen; i++) {
+		if ((b1[i]^b2[i])&mask[i]) {
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static void make_mask(char *mask, int plen, int addrlen) {
+	int w, b;
+
+	w = plen >> 3;
+	b = plen & 0x7;
+
+	if (w)
+		memset(mask, 0xff, w);
+	if (w < addrlen)
+		mask[w] = 0xff & (0xff<<(8-b));
+	if (w+1 < addrlen)
+		memset(mask+w+1, 0, addrlen-w-1);
+
+	return;
+}
 
 static int match_address(char *addr, char *tok)
 {
 	char *p;
-	unsigned long a, t, mask = (unsigned long)~0;
+	struct addrinfo hints, *resa, *rest;
+	int gai;
+	int ret = 0;
+	int addrlen = 0;
+#ifdef HAVE_STRTOL
+	long int bits;
+#else
+	int bits;
+#endif
+	char mask[16];
+	char *a = NULL, *t = NULL;
 
 	if (!addr || !*addr) return 0;
 
-	if (!isdigit(tok[0])) return 0;
-
 	p = strchr(tok,'/');
 	if (p) *p = 0;
 
-	a = inet_addr(addr);
-	t = inet_addr(tok);
-
-	if (p) {
-		*p = '/';
-	}
-
-	if (t == INADDR_NONE) {
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+#ifdef AI_NUMERICHOST
+	hints.ai_flags = AI_NUMERICHOST;
+#endif
+
+	gai = getaddrinfo(addr, NULL, &hints, &resa);
+	if (gai) return 0;
+
+	gai = getaddrinfo(tok, NULL, &hints, &rest);
+	if (p)
+		*p++ = '/';
+	if (gai) {
 		rprintf(FERROR,"malformed address %s\n", tok);
+		freeaddrinfo(resa);
 		return 0;
 	}
 
-	a = ntohl(a);
-	t = ntohl(t);
+	if (rest->ai_family != resa->ai_family) {
+		ret = 0;
+		goto out;
+	}
+
+	switch(resa->ai_family) {
+	case PF_INET:
+		a = (char *)&((struct sockaddr_in *)resa->ai_addr)->sin_addr;
+		t = (char *)&((struct sockaddr_in *)rest->ai_addr)->sin_addr;
+		addrlen = 4;
+
+		break;
+
+#ifdef INET6
+	case PF_INET6:
+	    {
+		struct sockaddr_in6 *sin6a, *sin6t;
+
+		sin6a = (struct sockaddr_in6 *)resa->ai_addr;
+		sin6t = (struct sockaddr_in6 *)rest->ai_addr;
+
+		a = (char *)&sin6a->sin6_addr;
+		t = (char *)&sin6t->sin6_addr;
+
+		addrlen = 16;
+
+#ifdef HAVE_SOCKADDR_IN6_SCOPE_ID
+		if (sin6t->sin6_scope_id &&
+		    sin6a->sin6_scope_id != sin6t->sin6_scope_id) {
+			ret = 0;
+			goto out;
+		}
+#endif
+
+		break;
+	    }
+#endif
+	default:
+	    rprintf(FERROR,"unknown family %u\n", rest->ai_family);
+	    ret = 0;
+	    goto out;
+	}
 
+	bits = -1;
 	if (p) {
-		if (strchr(p+1,'.')) {
-			mask = inet_addr(p+1);
-			if (mask == INADDR_NONE) {
+		if (inet_pton(resa->ai_addr->sa_family, p, mask) <= 0) {
+#ifdef HAVE_STRTOL
+			char *ep = NULL;
+#else
+			unsigned char *pp;
+#endif
+
+#ifdef HAVE_STRTOL
+			bits = strtol(p, &ep, 10);
+			if (!*p || *ep) {
 				rprintf(FERROR,"malformed mask in %s\n", tok);
-				return 0;
+				ret = 0;
+				goto out;
+			}
+#else
+			for (pp = (unsigned char *)p; *pp; pp++) {
+				if (!isascii(*pp) || !isdigit(*pp)) {
+					rprintf(FERROR,"malformed mask in %s\n", tok);
+					ret = 0;
+					goto out;
+				}
 			}
-			mask = ntohl(mask);
-		} else {
-			int bits = atoi(p+1);
-			if (bits == 0) return 1;
-			if (bits <= 0 || bits > 32) {
+			bits = atoi(p);
+#endif
+			if (bits == 0) {
+				ret = 1;
+				goto out;
+			}
+			if (bits < 0 || bits > (addrlen << 3)) {
 				rprintf(FERROR,"malformed mask in %s\n", tok);
-				return 0;
+				ret = 0;
+				goto out;
 			}
-			mask &= (mask << (32-bits));
 		}
+	} else {
+		bits = 128;
 	}
 
-	return ((a&mask) == (t&mask));
+	if (bits >= 0)
+		make_mask(mask, bits, addrlen);
+
+	ret = match_binary(a, t, mask, addrlen);
+
+out:
+	freeaddrinfo(resa);
+	freeaddrinfo(rest);
+	return ret;
 }
 
 static int access_match(char *list, char *addr, char *host)
 {
 	char *tok;
 	char *list2 = strdup(list);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/acconfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/acconfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/acconfig.h	2001-11-23 15:35:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/acconfig.h	2003-01-10 05:14:10.000000000 +0800
@@ -4,7 +4,8 @@
 #undef HAVE_GETOPT_LONG
 #undef REPLACE_INET_NTOA
 #undef REPLACE_INET_ATON
 #undef HAVE_GETTIMEOFDAY_TZ
 #undef ENABLE_IPV6
 #undef HAVE_SOCKADDR_LEN
+#undef HAVE_SOCKADDR_IN6_SCOPE_ID
 #undef HAVE_SOCKETPAIR
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/authenticate.c	2002-01-24 10:33:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/authenticate.c	2003-01-27 03:37:54.000000000 +0800
@@ -200,13 +200,13 @@
    return NULL if authentication failed
 
    return "" if anonymous access
 
    otherwise return username
 */
-char *auth_server(int fd, int module, char *addr, char *leader)
+char *auth_server(int f_in, int f_out, int module, char *addr, char *leader)
 {
 	char *users = lp_auth_users(module);
 	char challenge[16];
 	char b64_challenge[30];
 	char line[MAXPATHLEN];
 	static char user[100];
@@ -219,15 +219,15 @@
 	if (!users || !*users) return "";
 
 	gen_challenge(addr, challenge);
 	
 	base64_encode(challenge, 16, b64_challenge);
 
-	io_printf(fd,"%s%s\n", leader, b64_challenge);
+	io_printf(f_out, "%s%s\n", leader, b64_challenge);
 
-	if (!read_line(fd, line, sizeof(line)-1)) {
+	if (!read_line(f_in, line, sizeof(line)-1)) {
 		return NULL;
 	}
 
 	memset(user, 0, sizeof(user));
 	memset(pass, 0, sizeof(pass));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/backup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/backup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/backup.c	2001-05-07 14:59:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/backup.c	2002-05-10 05:44:46.000000000 +0800
@@ -18,12 +18,13 @@
 
 /* backup handling code */
 
 #include "rsync.h"
 
 extern int verbose;
+extern int suffix_specified;
 extern char *backup_suffix;
 extern char *backup_dir;
 
 
 extern int am_root;
 extern int preserve_devices;
@@ -200,18 +201,23 @@
 	file = make_file(-1, fname, NULL, 1);
 
 	/* the file could have disappeared */
 	if (!file) return 1;
 
         /* make a complete pathname for backup file */
-        if (strlen(backup_dir) + strlen(fname) > (MAXPATHLEN - 1)) {
+        if (strlen(backup_dir) + strlen(fname) + 
+		(suffix_specified ? strlen(backup_suffix) : 0) > (MAXPATHLEN - 1)) {
                 rprintf (FERROR, "keep_backup filename too long\n");
                 return 0;
         }
 
-        snprintf(keep_name, sizeof (keep_name), "%s/%s", backup_dir, fname);
+	if (suffix_specified) {
+        	snprintf(keep_name, sizeof (keep_name), "%s/%s%s", backup_dir, fname, backup_suffix);
+		} else {
+        	snprintf(keep_name, sizeof (keep_name), "%s/%s", backup_dir, fname);
+		}
 
 
 #ifdef HAVE_MKNOD
 	/* Check to see if this is a device file, or link */
         if(IS_DEVICE(file->mode)) {
                 if(am_root && preserve_devices) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/batch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/batch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/batch.c	2002-03-25 14:06:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/batch.c	2002-12-24 15:42:04.000000000 +0800
@@ -261,13 +261,13 @@
 		close(fdb);
 	}
 
 	return bytes_read;
 }
 
-unsigned char read_batch_flags()
+unsigned char read_batch_flags(void)
 {
 	int flags;
 
 	if (read_batch_flist_file((char *) &flags, 4)) {
 		return 1;
 	} else {
@@ -389,26 +389,33 @@
 
 void close_batch_csums_file(void)
 {
 	close(fdb);
 }
 
+
+/**
+ * Write csum info to batch file 
+ *
+ * @todo This will break if s->count is ever larger than maxint.  The
+ * batch code should probably be changed to consistently use the
+ * variable-length integer routines, which is probably a compatible
+ * change.
+ **/
 void write_batch_csum_info(int *flist_entry, int flist_count,
 			   struct sum_struct *s)
 {
 	size_t i;
-	size_t int_zero = 0;
+	int int_count;
 	extern int csum_length;
 
 	fdb_open = 1;
 
-	/* Write csum info to batch file */
-
-	/* FIXME: This will break if s->count is ever not exactly an int. */
 	write_batch_csums_file(flist_entry, sizeof(int));
-	write_batch_csums_file(s ? &s->count : &int_zero, sizeof(int));
+	int_count = s ? (int) s->count : 0;
+	write_batch_csums_file(&int_count, sizeof int_count);
 	
 	if (s) {
 		for (i = 0; i < s->count; i++) {
 			write_batch_csums_file(&s->sums[i].sum1, sizeof(uint32));
 			if ((*flist_entry == flist_count - 1)
 			    && (i == s->count - 1)) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/checksum.c	1999-10-26 06:04:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/checksum.c	2002-04-08 16:29:04.000000000 +0800
@@ -137,13 +137,21 @@
 	mdfour_begin(&md);
 	sumresidue=0;
 	SIVAL(s,0,checksum_seed);
 	sum_update(s,4);
 }
 
-void sum_update(char *p,int len)
+/**
+ * Feed data into an MD4 accumulator, md.  The results may be
+ * retrieved using sum_end().  md is used for different purposes at
+ * different points during execution.
+ *
+ * @todo Perhaps get rid of md and just pass in the address each time.
+ * Very slightly clearer and slower.
+ **/
+void sum_update(char *p, int len)
 {
 	int i;
 	if (len + sumresidue < CSUM_CHUNK) {
 		memcpy(sumrbuf+sumresidue, p, len);
 		sumresidue += len;
 		return;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/cleanup.c	2002-03-27 09:03:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/cleanup.c	2003-01-27 11:35:08.000000000 +0800
@@ -1,10 +1,11 @@
 /* -*- c-file-style: "linux" -*-
    
    Copyright (C) 1996-2000 by Andrew Tridgell
    Copyright (C) Paul Mackerras 1996
+   Copyright (C) 2002 by Martin Pool
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
    
@@ -17,35 +18,85 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
-/* handling the cleanup when a transfer is interrupted is tricky when
-   --partial is selected. We need to ensure that the partial file is
-   kept if any real data has been transferred */
+/**
+ * Close all open sockets and files, allowing a (somewhat) graceful
+ * shutdown() of socket connections.  This eliminates the abortive
+ * TCP RST sent by a Winsock-based system when the close() occurs.
+ **/
+void close_all()
+{
+#ifdef SHUTDOWN_ALL_SOCKETS
+	int max_fd;
+	int fd;
+	int ret;
+	struct stat st;
+
+	max_fd = sysconf(_SC_OPEN_MAX) - 1;
+	for (fd = max_fd; fd >= 0; fd--) {
+		ret = fstat(fd,&st);
+		if (fstat(fd,&st) == 0) {
+			if (is_a_socket(fd)) {
+				ret = shutdown(fd, 2);
+			}
+			ret = close(fd);
+		}
+	}
+#endif
+}
+
+/**
+ * @file cleanup.c
+ *
+ * Code for handling interrupted transfers.  Depending on the @c
+ * --partial option, we may either delete the temporary file, or go
+ * ahead and overwrite the destination.  This second behaviour only
+ * occurs if we've sent literal data and therefore hopefully made
+ * progress on the transfer.
+ **/
+
+/**
+ * Set to True once literal data has been sent across the link for the
+ * current file. (????)
+ *
+ * Handling the cleanup when a transfer is interrupted is tricky when
+ * --partial is selected.  We need to ensure that the partial file is
+ * kept if any real data has been transferred.
+ **/
 int cleanup_got_literal=0;
 
 static char *cleanup_fname;
 static char *cleanup_new_fname;
 static struct file_struct *cleanup_file;
 static int cleanup_fd1, cleanup_fd2;
 static struct map_struct *cleanup_buf;
 static int cleanup_pid = 0;
 extern int io_error;
 
 pid_t cleanup_child_pid = -1;
 
-/*
- * Code is one of the RERR_* codes from errcode.h.
- */
+/**
+ * Eventually calls exit(), passing @p code, therefore does not return.
+ *
+ * @param code one of the RERR_* codes from errcode.h.
+ **/
 void _exit_cleanup(int code, const char *file, int line)
 {
 	int ocode = code;
 	extern int keep_partial;
 	extern int log_got_error;
+	static int inside_cleanup = 0;
+
+	if (inside_cleanup > 10) {
+		/* prevent the occasional infinite recursion */
+		return;
+	}
+	inside_cleanup++;
 
 	signal(SIGUSR1, SIG_IGN);
 	signal(SIGUSR2, SIG_IGN);
 
 	if (verbose > 3)
 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): entered\n", 
@@ -87,12 +138,13 @@
 	if (code) log_exit(code, file, line);
 
 	if (verbose > 2)
 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n", 
 			ocode, file, line, code);
 
+	close_all();
 	exit(code);
 }
 
 void cleanup_disable(void)
 {
 	cleanup_fname = NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/clientname.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/clientname.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/clientname.c	2002-01-26 06:59:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/clientname.c	2003-01-11 10:05:56.000000000 +0800
@@ -31,33 +31,51 @@
  * emulate it using the KAME implementation.
  **/
 
 #include "rsync.h"
 
 static const char default_name[] = "UNKNOWN";
+extern int am_daemon;
+extern int am_server;
 
 
 /**
  * Return the IP addr of the client as a string 
  **/
 char *client_addr(int fd)
 {
 	struct sockaddr_storage ss;
 	socklen_t length = sizeof ss;
+	char *ssh_client, *p;
+	int len;
 	static char addr_buf[100];
 	static int initialised;
 
 	if (initialised) return addr_buf;
 
 	initialised = 1;
 
-	client_sockaddr(fd, &ss, &length);
+	if (am_server) {
+		/* daemon over --rsh mode */
+		strcpy(addr_buf, "0.0.0.0");
+		if ((ssh_client = getenv("SSH_CLIENT")) != NULL) {
+			/* truncate SSH_CLIENT to just IP address */
+			p = strchr(ssh_client, ' ');
+			if (p) {
+				len = MIN((unsigned int) (p - ssh_client), 
+						sizeof(addr_buf) - 1);
+				strncpy(addr_buf, ssh_client, len);
+				*(addr_buf + len) = '\0';
+			}
+		}
+	} else {
+		client_sockaddr(fd, &ss, &length);
+		getnameinfo((struct sockaddr *)&ss, length,
+			    addr_buf, sizeof addr_buf, NULL, 0, NI_NUMERICHOST);
+	}
 
-	getnameinfo((struct sockaddr *)&ss, length,
-		    addr_buf, sizeof(addr_buf), NULL, 0, NI_NUMERICHOST);
-	
 	return addr_buf;
 }
 
 
 static int get_sockaddr_family(const struct sockaddr_storage *ss)
 {
@@ -71,30 +89,73 @@
  * The name is statically cached so that repeated lookups are quick,
  * so there is a limit of one lookup per customer.
  *
  * If anything goes wrong, including the name->addr->name check, then
  * we just use "UNKNOWN", so you can use that value in hosts allow
  * lines.
+ *
+ * After translation from sockaddr to name we do a forward lookup to
+ * make sure nobody is spoofing PTR records.
  **/
 char *client_name(int fd)
 {
-	struct sockaddr_storage ss;
-	socklen_t ss_len = sizeof ss;
 	static char name_buf[100];
 	static char port_buf[100];
 	static int initialised;
+	struct sockaddr_storage ss, *ssp;
+	struct sockaddr_in sin;
+#ifdef INET6
+	struct sockaddr_in6 sin6;
+#endif
+	socklen_t ss_len;
 
 	if (initialised) return name_buf;
 
 	strcpy(name_buf, default_name);
 	initialised = 1;
 
-	client_sockaddr(fd, &ss, &ss_len);
+	if (am_server) {
+		/* daemon over --rsh mode */
+
+		char *addr = client_addr(fd);
+#ifdef INET6
+		int dots = 0;
+		char *p;
+
+		for (p = addr; *p && (dots <= 3); p++) {
+		    if (*p == '.')
+			dots++;
+		}
+		if (dots > 3) {
+			/* more than 4 parts to IP address, must be ipv6 */
+			ssp = (struct sockaddr_storage *) &sin6;
+			ss_len = sizeof sin6;
+			memset(ssp, 0, ss_len);
+			inet_pton(AF_INET6, addr, &sin6.sin6_addr);
+			sin6.sin6_family = AF_INET6;
+		} else
+#endif
+		{
+			ssp = (struct sockaddr_storage *) &sin;
+			ss_len = sizeof sin;
+			memset(ssp, 0, ss_len);
+			inet_pton(AF_INET, addr, &sin.sin_addr);
+			sin.sin_family = AF_INET;
+		}
+
+	} else {
+		ss_len = sizeof ss;
+		ssp = &ss;
 
-	if (!lookup_name(fd, &ss, ss_len, name_buf, sizeof name_buf, port_buf, sizeof port_buf))
-		check_name(fd, &ss, name_buf, port_buf);
+		client_sockaddr(fd, &ss, &ss_len);
+
+	}
+
+	if (!lookup_name(fd, ssp, ss_len, name_buf, sizeof name_buf, 
+			port_buf, sizeof port_buf))
+		check_name(fd, ssp, name_buf);
 
 	return name_buf;
 }
 
 
 
@@ -105,12 +166,14 @@
  * convert it back to a regular IPv4.
  **/
 void client_sockaddr(int fd,
 		     struct sockaddr_storage *ss,
 		     socklen_t *ss_len)
 {
+	memset(ss, 0, sizeof(*ss));
+
 	if (getpeername(fd, (struct sockaddr *) ss, ss_len)) {
 		/* FIXME: Can we really not continue? */
 		rprintf(FERROR, RSYNC_NAME ": getpeername on fd%d failed: %s\n",
 			fd, strerror(errno));
 		exit_cleanup(RERR_SOCKETIO);
 	}
@@ -146,12 +209,14 @@
 #endif
 }
 
 
 /**
  * Look up a name from @p ss into @p name_buf.
+ *
+ * @param fd file descriptor for client socket.
  **/
 int lookup_name(int fd, const struct sockaddr_storage *ss,
 		socklen_t ss_len,
 		char *name_buf, size_t name_buf_len,
 		char *port_buf, size_t port_buf_len)
 {
@@ -206,15 +271,29 @@
 #ifdef INET6
 	else if (ss_family == AF_INET6) {
 		const struct sockaddr_in6 *sin1, *sin2;
 
 		sin1 = (const struct sockaddr_in6 *) ss;
 		sin2 = (const struct sockaddr_in6 *) ai->ai_addr;
-		
-		return memcmp(&sin1->sin6_addr, &sin2->sin6_addr,
-			      sizeof sin1->sin6_addr);
+
+		if (ai->ai_addrlen < sizeof(struct sockaddr_in6)) {
+			rprintf(FERROR,
+				"%s: too short sockaddr_in6; length=%d\n",
+				fn, ai->ai_addrlen);
+			return 1;
+		}
+
+		if (memcmp(&sin1->sin6_addr, &sin2->sin6_addr,
+			   sizeof sin1->sin6_addr))
+			return 1;
+
+#ifdef HAVE_SOCKADDR_IN6_SCOPE_ID
+		if (sin1->sin6_scope_id != sin2->sin6_scope_id)
+			return 1;
+#endif
+		return 0;
 	}
 #endif /* INET6 */
 	else {
 		/* don't know */
 		return 1;
 	}
@@ -223,27 +302,30 @@
 
 /**
  * Do a forward lookup on @p name_buf and make sure it corresponds to
  * @p ss -- otherwise we may be being spoofed.  If we suspect we are,
  * then we don't abort the connection but just emit a warning, and
  * change @p name_buf to be "UNKNOWN".
+ *
+ * We don't do anything with the service when checking the name,
+ * because it doesn't seem that it could be spoofed in any way, and
+ * getaddrinfo on random service names seems to cause problems on AIX.
  **/
 int check_name(int fd,
 	       const struct sockaddr_storage *ss,
-	       char *name_buf,
-	       const char *port_buf)
+	       char *name_buf)
 {
 	struct addrinfo hints, *res, *res0;
 	int error;
 	int ss_family = get_sockaddr_family(ss);
 
 	memset(&hints, 0, sizeof(hints));
 	hints.ai_family = ss_family;
 	hints.ai_flags = AI_CANONNAME;
 	hints.ai_socktype = SOCK_STREAM;
-	error = getaddrinfo(name_buf, port_buf, &hints, &res0);
+	error = getaddrinfo(name_buf, NULL, &hints, &res0);
 	if (error) {
 		rprintf(FERROR,
 			RSYNC_NAME ": forward name lookup for %s failed: %s\n",
 			name_buf, gai_strerror(error));
 		strcpy(name_buf, default_name);
 		return error;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/clientserver.c	2002-03-27 09:03:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/clientserver.c	2003-01-27 04:08:14.000000000 +0800
@@ -1,117 +1,136 @@
 /* -*- c-file-style: "linux"; -*-
-   
-   Copyright (C) 1998-2001 by Andrew Tridgell <tridge@samba.org>
-   Copyright (C) 2001-2002 by Martin Pool <mbp@samba.org>
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * 
+ * Copyright (C) 1998-2001 by Andrew Tridgell <tridge@samba.org>
+ * Copyright (C) 2001-2002 by Martin Pool <mbp@samba.org>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
-/* the socket based protocol for setting up a connection with rsyncd */
+/**
+ * @file
+ *
+ * The socket based protocol for setting up a connection with
+ * rsyncd.
+ **/
 
 #include "rsync.h"
 
 extern int module_id;
 extern int read_only;
 extern int verbose;
 extern int rsync_port;
 char *auth_user;
-int sanitize_paths = 0;
+extern int sanitize_paths;
 
 /**
  * Run a client connected to an rsyncd.  The alternative to this
  * function for remote-shell connections is do_cmd().
  *
- * After initial server startup, hands over to client_run().
+ * After negotiating which module to use and reading the server's
+ * motd, this hands over to client_run().  Telling the server the
+ * module will cause it to chroot/setuid/etc.
+ *
+ * Instead of doing a transfer, the client may at this stage instead
+ * get a listing of remote modules and exit.
  *
  * @return -1 for error in startup, or the result of client_run().
+ * Either way, it eventually gets passed to exit_cleanup().
  **/
 int start_socket_client(char *host, char *path, int argc, char *argv[])
 {
-	int fd, i;
-	char *sargs[MAX_ARGS];
-	int sargc=0;
-	char line[MAXPATHLEN];
+	int fd, ret;
 	char *p, *user=NULL;
-	extern int remote_version;
-	extern int am_sender;
-	extern char *shell_cmd;
-	extern int list_only;
-	extern int kludge_around_eof;
 	extern char *bind_address;
 	extern int default_af_hint;
        
-	if (argc == 0 && !am_sender) {
-		extern int list_only;
-		list_only = 1;
-	}
-
-        /* This is just a friendliness enhancement: if the connection
-         * is to an rsyncd then there is no point specifying the -e option.
-         * Note that this is only set if the -e was explicitly specified,
-         * not if the environment variable just happens to be set.
-         * See http://lists.samba.org/pipermail/rsync/2000-September/002744.html
-         */
-        if (shell_cmd) {
-                rprintf(FERROR, "WARNING: --rsh or -e option ignored when "
-                        "connecting to rsync daemon\n");
-                /* continue */
-        }
-        
+	/* this is redundant with code in start_inband_exchange(), but
+	   this short-circuits a problem before we open a socket, and 
+	   the extra check won't hurt */
 	if (*path == '/') {
 		rprintf(FERROR,"ERROR: The remote path must start with a module name not a /\n");
 		return -1;
 	}
 
 	p = strchr(host, '@');
 	if (p) {
 		user = host;
 		host = p+1;
 		*p = 0;
 	}
 
-	if (!user) user = getenv("USER");
-	if (!user) user = getenv("LOGNAME");
-
 	if (verbose >= 2) {
 		/* FIXME: If we're going to use a socket program for
 		 * testing, then this message is wrong.  We need to
 		 * say something like "(except really using %s)" */
 		rprintf(FINFO, "opening tcp connection to %s port %d\n",
 			host, rsync_port);
 	}
 	fd = open_socket_out_wrapped (host, rsync_port, bind_address,
 				      default_af_hint);
 	if (fd == -1) {
 		exit_cleanup(RERR_SOCKETIO);
 	}
-	
-	server_options(sargs,&sargc);
+
+	ret = start_inband_exchange(user, path, fd, fd, argc);
+
+	return ret < 0? ret : client_run(fd, fd, -1, argc, argv);
+}
+
+int start_inband_exchange(char *user, char *path, int f_in, int f_out, int argc)
+{
+	int i;
+	char *sargs[MAX_ARGS];
+	int sargc = 0;
+	char line[MAXPATHLEN];
+	char *p;
+	extern int remote_version;
+	extern int kludge_around_eof;
+	extern int am_sender;
+	extern int daemon_over_rsh;
+	extern int list_only;
+
+	if (argc == 0 && !am_sender)
+		list_only = 1;
+
+	if (*path == '/') {
+		rprintf(FERROR, "ERROR: The remote path must start with a module name\n");
+		return -1;
+	}
+
+	if (!user) user = getenv("USER");
+	if (!user) user = getenv("LOGNAME");
+
+	/* set daemon_over_rsh to false since we need to build the 
+	   true set of args passed through the rsh/ssh connection; 
+	   this is a no-op for direct-socket-connection mode */
+	daemon_over_rsh = 0;
+	server_options(sargs, &sargc);
 
 	sargs[sargc++] = ".";
 
 	if (path && *path) 
 		sargs[sargc++] = path;
 
 	sargs[sargc] = NULL;
 
-	io_printf(fd,"@RSYNCD: %d\n", PROTOCOL_VERSION);
+	io_printf(f_out, "@RSYNCD: %d\n", PROTOCOL_VERSION);
 
-	if (!read_line(fd, line, sizeof(line)-1)) {
+	if (!read_line(f_in, line, sizeof(line)-1)) {
 		rprintf(FERROR, "rsync: did not see server greeting\n");
 		return -1;
 	}
 
 	if (sscanf(line,"@RSYNCD: %d", &remote_version) != 1) {
 		/* note that read_line strips of \n or \r */
@@ -119,128 +138,145 @@
 			line);
 		return -1;
 	}
 
 	p = strchr(path,'/');
 	if (p) *p = 0;
-	io_printf(fd,"%s\n",path);
+	io_printf(f_out, "%s\n", path);
 	if (p) *p = '/';
 
 	/* Old servers may just drop the connection here,
 	 rather than sending a proper EXIT command.  Yuck. */
 	kludge_around_eof = list_only && (remote_version < 25);
 
 	while (1) {
-		if (!read_line(fd, line, sizeof(line)-1)) {
+		if (!read_line(f_in, line, sizeof(line)-1)) {
 			rprintf(FERROR, "rsync: didn't get server startup line\n");
 			return -1;
 		}
 
 		if (strncmp(line,"@RSYNCD: AUTHREQD ",18) == 0) {
-			auth_client(fd, user, line+18);
+			auth_client(f_out, user, line+18);
 			continue;
 		}
 
 		if (strcmp(line,"@RSYNCD: OK") == 0) break;
 
-		if (strcmp(line,"@RSYNCD: EXIT") == 0) exit(0);
+		if (strcmp(line,"@RSYNCD: EXIT") == 0) {
+			/* This is sent by recent versions of the
+			 * server to terminate the listing of modules.
+			 * We don't want to go on and transfer
+			 * anything; just exit. */
+			exit(0);
+		}
 
-		if (strncmp(line, "@ERROR", 6) == 0)
+		if (strncmp(line, "@ERROR", 6) == 0) {
 			rprintf(FERROR,"%s\n", line);
-		else
+			/* This is always fatal; the server will now
+			 * close the socket. */
+			return RERR_STARTCLIENT;
+		} else {
 			rprintf(FINFO,"%s\n", line);
+		}
 	}
 	kludge_around_eof = False;
 
-	for (i=0;i<sargc;i++) {
-		io_printf(fd,"%s\n", sargs[i]);
+	for (i = 0; i < sargc; i++) {
+		io_printf(f_out, "%s\n", sargs[i]);
 	}
-	io_printf(fd,"\n");
+	io_printf(f_out, "\n");
 
 	if (remote_version < 23) {
 		if (remote_version == 22 || (remote_version > 17 && !am_sender))
-			io_start_multiplex_in(fd);
+			io_start_multiplex_in(f_in);
 	}
 
-	return client_run(fd, fd, -1, argc, argv);
+	return 0;
 }
 
 
 
-static int rsync_module(int fd, int i)
+static int rsync_module(int f_in, int f_out, int i)
 {
 	int argc=0;
 	char *argv[MAX_ARGS];
 	char **argp;
 	char line[MAXPATHLEN];
 	uid_t uid = (uid_t)-2;  /* canonically "nobody" */
 	gid_t gid = (gid_t)-2;
 	char *p;
-	char *addr = client_addr(fd);
-	char *host = client_name(fd);
+	char *addr = client_addr(f_in);
+	char *host = client_name(f_in);
 	char *name = lp_name(i);
 	int use_chroot = lp_use_chroot(i);
 	int start_glob=0;
 	int ret;
 	char *request=NULL;
 	extern int am_sender;
+	extern int am_server;
+	extern int am_daemon;
 	extern int remote_version;
 	extern int am_root;
 
 	if (!allow_access(addr, host, lp_hosts_allow(i), lp_hosts_deny(i))) {
 		rprintf(FERROR,"rsync denied on module %s from %s (%s)\n",
 			name, host, addr);
-		io_printf(fd,"@ERROR: access denied to %s from %s (%s)\n",
+		io_printf(f_out, "@ERROR: access denied to %s from %s (%s)\n",
 			  name, host, addr);
 		return -1;
 	}
 
+	if (am_daemon && am_server) {
+		rprintf(FINFO, "rsync allowed access on module %s from %s (%s)\n",
+			name, host, addr);
+	}
+
 	if (!claim_connection(lp_lock_file(i), lp_max_connections(i))) {
 		if (errno) {
 			rprintf(FERROR,"failed to open lock file %s : %s\n",
 				lp_lock_file(i), strerror(errno));
-			io_printf(fd,"@ERROR: failed to open lock file %s : %s\n",
+			io_printf(f_out, "@ERROR: failed to open lock file %s : %s\n",
 				  lp_lock_file(i), strerror(errno));
 		} else {
 			rprintf(FERROR,"max connections (%d) reached\n",
 				lp_max_connections(i));
-			io_printf(fd,"@ERROR: max connections (%d) reached - try again later\n", lp_max_connections(i));
+			io_printf(f_out, "@ERROR: max connections (%d) reached - try again later\n", lp_max_connections(i));
 		}
 		return -1;
 	}
 
 	
-	auth_user = auth_server(fd, i, addr, "@RSYNCD: AUTHREQD ");
+	auth_user = auth_server(f_in, f_out, i, addr, "@RSYNCD: AUTHREQD ");
 
 	if (!auth_user) {
 		rprintf(FERROR,"auth failed on module %s from %s (%s)\n",
-			name, client_name(fd), client_addr(fd));
-		io_printf(fd,"@ERROR: auth failed on module %s\n",name);
+			name, host, addr);
+		io_printf(f_out, "@ERROR: auth failed on module %s\n", name);
 		return -1;		
 	}
 
 	module_id = i;
 
 	am_root = (getuid() == 0);
 
 	if (am_root) {
 		p = lp_uid(i);
 		if (!name_to_uid(p, &uid)) {
-			if (!isdigit(*p)) {
+			if (!isdigit(* (unsigned char *) p)) {
 				rprintf(FERROR,"Invalid uid %s\n", p);
-				io_printf(fd,"@ERROR: invalid uid %s\n", p);
+				io_printf(f_out, "@ERROR: invalid uid %s\n", p);
 				return -1;
 			} 
 			uid = atoi(p);
 		}
 
 		p = lp_gid(i);
 		if (!name_to_gid(p, &gid)) {
-			if (!isdigit(*p)) {
+			if (!isdigit(* (unsigned char *) p)) {
 				rprintf(FERROR,"Invalid gid %s\n", p);
-				io_printf(fd,"@ERROR: invalid gid %s\n", p);
+				io_printf(f_out, "@ERROR: invalid gid %s\n", p);
 				return -1;
 			} 
 			gid = atoi(p);
 		}
 	}
         
@@ -277,38 +313,38 @@
 		 * So, perhaps if we can't chroot we should just issue
 		 * a warning, unless a "require chroot" flag is set,
 		 * in which case we fail.
 		 */
 		if (chroot(lp_path(i))) {
 			rsyserr(FERROR, errno, "chroot %s failed", lp_path(i));
-			io_printf(fd,"@ERROR: chroot failed\n");
+			io_printf(f_out, "@ERROR: chroot failed\n");
 			return -1;
 		}
 
 		if (!push_dir("/", 0)) {
                         rsyserr(FERROR, errno, "chdir %s failed\n", lp_path(i));
-			io_printf(fd,"@ERROR: chdir failed\n");
+			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 
 	} else {
 		if (!push_dir(lp_path(i), 0)) {
 			rsyserr(FERROR, errno, "chdir %s failed\n", lp_path(i));
-			io_printf(fd,"@ERROR: chdir failed\n");
+			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 		sanitize_paths = 1;
 	}
 
 	if (am_root) {
 #ifdef HAVE_SETGROUPS
 		/* Get rid of any supplementary groups this process
 		 * might have inheristed. */
 		if (setgroups(0, NULL)) {
 			rsyserr(FERROR, errno, "setgroups failed");
-			io_printf(fd, "@ERROR: setgroups failed\n");
+			io_printf(f_out, "@ERROR: setgroups failed\n");
 			return -1;
 		}
 #endif
 
 		/* XXXX: You could argue that if the daemon is started
 		 * by a non-root user and they explicitly specify a
@@ -319,31 +355,31 @@
 		/* TODO: Perhaps we need to document that if rsyncd is
 		 * started by somebody other than root it will inherit
 		 * all their supplementary groups. */
 
 		if (setgid(gid)) {
 			rsyserr(FERROR, errno, "setgid %d failed", (int) gid);
-			io_printf(fd,"@ERROR: setgid failed\n");
+			io_printf(f_out, "@ERROR: setgid failed\n");
 			return -1;
 		}
 
 		if (setuid(uid)) {
 			rsyserr(FERROR, errno, "setuid %d failed", (int) uid);
-			io_printf(fd,"@ERROR: setuid failed\n");
+			io_printf(f_out, "@ERROR: setuid failed\n");
 			return -1;
 		}
 
 		am_root = (getuid() == 0);
 	}
 
-	io_printf(fd,"@RSYNCD: OK\n");
+	io_printf(f_out, "@RSYNCD: OK\n");
 
 	argv[argc++] = "rsyncd";
 
 	while (1) {
-		if (!read_line(fd, line, sizeof(line)-1)) {
+		if (!read_line(f_in, line, sizeof(line)-1)) {
 			return -1;
 		}
 
 		if (!*line) break;
 
 		p = line;
@@ -405,13 +441,13 @@
 	/* don't allow the logs to be flooded too fast */
 	if (verbose > 1) verbose = 1;
 #endif
 
 	if (remote_version < 23) {
 		if (remote_version == 22 || (remote_version > 17 && am_sender))
-			io_start_multiplex_out(fd);
+			io_start_multiplex_out(f_out);
 	}
         
         /* For later protocol versions, we don't start multiplexing
          * until we've configured nonblocking in start_server.  That
          * means we're in a sticky situation now: there's no way to
          * convey errors to the client. */
@@ -426,13 +462,13 @@
 
 	if (lp_timeout(i)) {
 		extern int io_timeout;
 		io_timeout = lp_timeout(i);
 	}
 
-	start_server(fd, fd, argc, argp);
+	start_server(f_in, f_out, argc, argp);
 
 	return 0;
 }
 
 /* send a list of available modules to the client. Don't list those
    with "list = False". */
@@ -447,81 +483,86 @@
 		    io_printf(fd, "%-15s\t%s\n", lp_name(i), lp_comment(i));
 
 	if (remote_version >= 25)
 		io_printf(fd,"@RSYNCD: EXIT\n");
 }
 
-/* this is called when a socket connection is established to a client
+/* this is called when a connection is established to a client
    and we want to start talking. The setup of the system is done from
    here */
-static int start_daemon(int fd)
+int start_daemon(int f_in, int f_out)
 {
 	char line[200];
 	char *motd;
 	int i = -1;
 	extern char *config_file;
 	extern int remote_version;
+	extern int am_server;
 
 	if (!lp_load(config_file, 0)) {
 		exit_cleanup(RERR_SYNTAX);
 	}
 
-	set_socket_options(fd,"SO_KEEPALIVE");
-	set_socket_options(fd,lp_socket_options());
-	set_nonblocking(fd);
+	log_init();
+
+	if (!am_server) {
+		set_socket_options(f_in, "SO_KEEPALIVE");
+		set_socket_options(f_in, lp_socket_options());
+		set_nonblocking(f_in);
+	}
 
-	io_printf(fd,"@RSYNCD: %d\n", PROTOCOL_VERSION);
+	io_printf(f_out, "@RSYNCD: %d\n", PROTOCOL_VERSION);
 
 	motd = lp_motd_file();
 	if (motd && *motd) {
 		FILE *f = fopen(motd,"r");
 		while (f && !feof(f)) {
 			int len = fread(line, 1, sizeof(line)-1, f);
 			if (len > 0) {
 				line[len] = 0;
-				io_printf(fd,"%s", line);
+				io_printf(f_out, "%s", line);
 			}
 		}
 		if (f) fclose(f);
-		io_printf(fd,"\n");
+		io_printf(f_out, "\n");
 	}
 
-	if (!read_line(fd, line, sizeof(line)-1)) {
+	if (!read_line(f_in, line, sizeof(line)-1)) {
 		return -1;
 	}
 
 	if (sscanf(line,"@RSYNCD: %d", &remote_version) != 1) {
-		io_printf(fd,"@ERROR: protocol startup error\n");
+		io_printf(f_out, "@ERROR: protocol startup error\n");
 		return -1;
 	}	
 
 	while (i == -1) {
 		line[0] = 0;
-		if (!read_line(fd, line, sizeof(line)-1)) {
+		if (!read_line(f_in, line, sizeof(line)-1)) {
 			return -1;
 		}
 
 		if (!*line || strcmp(line,"#list")==0) {
-			send_listing(fd);
+			send_listing(f_out);
 			return -1;
 		} 
 
 		if (*line == '#') {
 			/* it's some sort of command that I don't understand */
-			io_printf(fd,"@ERROR: Unknown command '%s'\n", line);
+			io_printf(f_out, "@ERROR: Unknown command '%s'\n", line);
 			return -1;
 		}
 
 		i = lp_number(line);
 		if (i == -1) {
-			io_printf(fd,"@ERROR: Unknown module '%s'\n", line);
+			io_printf(f_out, "@ERROR: Unknown module '%s'\n", line);
 			return -1;
 		}
 	}
 
-	return rsync_module(fd, i);
+	return rsync_module(f_in, f_out, i);
 }
 
 
 int daemon_main(void)
 {
 	extern char *config_file;
@@ -537,13 +578,13 @@
 		   try to use them. Redirect them to /dev/null */
 		for (i=1;i<3;i++) {
 			close(i); 
 			open("/dev/null", O_RDWR);
 		}
 
-		return start_daemon(STDIN_FILENO);
+		return start_daemon(STDIN_FILENO, STDIN_FILENO);
 	}
 
 	if (!no_detach)
 	    become_daemon();
 
 	if (!lp_load(config_file, 1)) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/compat.c	2001-08-14 10:04:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/compat.c	2002-04-08 11:43:54.000000000 +0800
@@ -14,13 +14,17 @@
    
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-/* compatability routines for older rsync protocol versions */
+/**
+ * @file compat.c
+ *
+ * Compatibility routines for older rsync protocol versions.
+ **/
 
 #include "rsync.h"
 
 extern int am_server;
 
 extern int preserve_links;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/config.guess /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/config.guess
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/config.guess	2001-07-22 10:39:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/config.guess	2003-01-23 06:24:53.000000000 +0800
@@ -1,12 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-#   Free Software Foundation, Inc.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
-timestamp='2001-07-19'
+timestamp='2003-01-10'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
@@ -21,14 +21,15 @@
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-# Written by Per Bothner <bothner@cygnus.com>.
-# Please send patches to <config-patches@gnu.org>.
+# Originally written by Per Bothner <per@bothner.com>.
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
 # The plan is that this can be called by configure scripts if you
@@ -84,36 +85,47 @@
 
 if test $# != 0; then
   echo "$me: too many arguments$help" >&2
   exit 1
 fi
 
+trap 'exit 1' 1 2 15
 
-dummy=dummy-$$
-trap 'rm -f $dummy.c $dummy.o $dummy.rel $dummy; exit 1' 1 2 15
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
 
-# CC_FOR_BUILD -- compiler used by this script.
 # Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
 # use `HOST_CC' if defined, but it is deprecated.
 
-set_cc_for_build='case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int dummy(){}" > $dummy.c ;
-	for c in cc gcc c89 ; do
-	  ($c $dummy.c -c -o $dummy.o) >/dev/null 2>&1 ;
-	  if test $? = 0 ; then
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
 	     CC_FOR_BUILD="$c"; break ;
 	  fi ;
 	done ;
-	rm -f $dummy.c $dummy.o $dummy.rel ;
 	if test x"$CC_FOR_BUILD" = x ; then
 	  CC_FOR_BUILD=no_compiler_found ;
 	fi
 	;;
  ,,*)   CC_FOR_BUILD=$CC ;;
  ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac'
+esac ;'
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
 if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
@@ -124,35 +136,36 @@
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
     *:NetBSD:*:*)
-	# Netbsd (nbsd) targets should (where applicable) match one or
+	# NetBSD (nbsd) targets should (where applicable) match one or
 	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
 	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
 	# compatibility and a consistent mechanism for selecting the
 	# object file format.
-	# Determine the machine/vendor (is the vendor relevant).
-	case "${UNAME_MACHINE}" in
-	    amiga) machine=m68k-unknown ;;
-	    arm32) machine=arm-unknown ;;
-	    atari*) machine=m68k-atari ;;
-	    sun3*) machine=m68k-sun ;;
-	    mac68k) machine=m68k-apple ;;
-	    macppc) machine=powerpc-apple ;;
-	    hp3[0-9][05]) machine=m68k-hp ;;
-	    ibmrt|romp-ibm) machine=romp-ibm ;;
-	    *) machine=${UNAME_MACHINE}-unknown ;;
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	case "${UNAME_MACHINE_ARCH}" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently, or will in the future.
-	case "${UNAME_MACHINE}" in
-	    i386|sparc|amiga|arm*|hp300|mvme68k|vax|atari|luna68k|mac68k|news68k|next68k|pc532|sun3*|x68k)
+	case "${UNAME_MACHINE_ARCH}" in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
 		eval $set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep __ELF__ >/dev/null
 		then
 		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
 		    # Return netbsd for either.  FIX?
@@ -163,26 +176,80 @@
 		;;
 	    *)
 	        os=netbsd
 		;;
 	esac
 	# The OS release
-	release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "${UNAME_VERSION}" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
 	echo "${machine}-${os}${release}"
 	exit 0 ;;
+    amiga:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    arc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hp300:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    macppc:OpenBSD:*:*)
+	echo powerpc-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme88k:OpenBSD:*:*)
+	echo m88k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvmeppc:OpenBSD:*:*)
+	echo powerpc-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    pmax:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sgi:OpenBSD:*:*)
+	echo mipseb-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    wgrisc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    *:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    *:MicroBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-microbsd${UNAME_RELEASE}
+	exit 0 ;;
     alpha:OSF1:*:*)
 	if test $UNAME_RELEASE = "V4.0"; then
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
 	fi
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
+	eval $set_cc_for_build
 	cat <<EOF >$dummy.s
 	.data
 \$Lformat:
 	.byte 37,100,45,37,120,10,0	# "%d-%x\n"
 
 	.text
@@ -202,16 +269,15 @@
 	jsr \$26,printf
 	ldgp \$29,0(\$26)
 	mov 0,\$16
 	jsr \$26,exit
 	.end main
 EOF
-	eval $set_cc_for_build
-	$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null
+	$CC_FOR_BUILD -o $dummy $dummy.s 2>/dev/null
 	if test "$?" = 0 ; then
-		case `./$dummy` in
+		case `$dummy` in
 			0-0)
 				UNAME_MACHINE="alpha"
 				;;
 			1-0)
 				UNAME_MACHINE="alphaev5"
 				;;
@@ -224,15 +290,20 @@
 			2-303)
 				UNAME_MACHINE="alphaev6"
 				;;
 			2-307)
 				UNAME_MACHINE="alphaev67"
 				;;
+			2-1307)
+				UNAME_MACHINE="alphaev68"
+				;;
+			3-1307)
+				UNAME_MACHINE="alphaev7"
+				;;
 		esac
 	fi
-	rm -f $dummy.s $dummy
 	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
 	exit 0 ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
 	# of the specific Alpha model?
@@ -241,35 +312,17 @@
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
 	exit 0 ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
 	exit 0;;
-    amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
     *:[Aa]miga[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-amigaos
 	exit 0 ;;
-    arc64:OpenBSD:*:*)
-	echo mips64el-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    arc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    hkmips:OpenBSD:*:*)
-	echo mips-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    pmax:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mips-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    wgrisc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
 	exit 0 ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
 	exit 0 ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
@@ -285,12 +338,16 @@
 		echo pyramid-pyramid-bsd
 	fi
 	exit 0 ;;
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
 	exit 0 ;;
+    DRS?6000:UNIX_SV:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7 && exit 0 ;;
+	esac ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
@@ -313,13 +370,13 @@
 	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
 	exit 0 ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos${UNAME_RELEASE}
 	exit 0 ;;
     sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(head -1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
 		echo m68k-sun-sunos${UNAME_RELEASE}
 		;;
 	    sun4)
@@ -327,15 +384,12 @@
 		;;
 	esac
 	exit 0 ;;
     aushp:SunOS:*:*)
 	echo sparc-auspex-sunos${UNAME_RELEASE}
 	exit 0 ;;
-    atari*:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
     # "atarist" or "atariste" at least should have a processor
     # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
     # to the lowercase version "mint" (or "freemint").  Finally
     # the system name "TOS" denotes a system which is actually not
@@ -356,24 +410,12 @@
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
         echo m68k-hades-mint${UNAME_RELEASE}
         exit 0 ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
         echo m68k-unknown-mint${UNAME_RELEASE}
         exit 0 ;;
-    sun3*:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
     powerpc:machten:*:*)
 	echo powerpc-apple-machten${UNAME_RELEASE}
 	exit 0 ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
 	exit 0 ;;
@@ -384,12 +426,13 @@
 	echo vax-dec-ultrix${UNAME_RELEASE}
 	exit 0 ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
 	echo clipper-intergraph-clix${UNAME_RELEASE}
 	exit 0 ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
 #else
 	int main (argc, argv) int argc; char *argv[]; {
@@ -405,22 +448,26 @@
 	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
-	eval $set_cc_for_build
-	$CC_FOR_BUILD $dummy.c -o $dummy \
-	  && ./$dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
-	  && rm -f $dummy.c $dummy && exit 0
-	rm -f $dummy.c $dummy
+	$CC_FOR_BUILD -o $dummy $dummy.c \
+	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+	  && exit 0
 	echo mips-mips-riscos${UNAME_RELEASE}
 	exit 0 ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
 	exit 0 ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit 0 ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit 0 ;;
     Night_Hawk:Power_UNIX:*:*)
 	echo powerpc-harris-powerunix
 	exit 0 ;;
     m88k:CX/UX:7*:*)
 	echo m88k-harris-cxux7
 	exit 0 ;;
@@ -475,35 +522,34 @@
 		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
 	fi
 	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
 	exit 0 ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		eval $set_cc_for_build
 		sed 's/^		//' << EOF >$dummy.c
 		#include <sys/systemcfg.h>
 
 		main()
 			{
 			if (!__power_pc())
 				exit(1);
 			puts("powerpc-ibm-aix3.2.5");
 			exit(0);
 			}
 EOF
-		eval $set_cc_for_build
-		$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm -f $dummy.c $dummy && exit 0
-		rm -f $dummy.c $dummy
+		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
 		echo rs6000-ibm-aix3.2.5
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
 	exit 0 ;;
     *:AIX:*:[45])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
 	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
 	if [ -x /usr/bin/oslevel ] ; then
@@ -537,30 +583,29 @@
     9000/[34678]??:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	case "${UNAME_MACHINE}" in
 	    9000/31? )            HP_ARCH=m68000 ;;
 	    9000/[34]?? )         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
-              case "${HPUX_REV}" in
-                11.[0-9][0-9])
-                  if [ -x /usr/bin/getconf ]; then
+		if [ -x /usr/bin/getconf ]; then
                     sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
                     sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
                     case "${sc_cpu_version}" in
                       523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
                       528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
                       532)                      # CPU_PA_RISC2_0
                         case "${sc_kernel_bits}" in
                           32) HP_ARCH="hppa2.0n" ;;
                           64) HP_ARCH="hppa2.0w" ;;
+			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
                         esac ;;
                     esac
-                  fi ;;
-              esac
-              if [ "${HP_ARCH}" = "" ]; then
-              sed 's/^              //' << EOF >$dummy.c
+		fi
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^              //' << EOF >$dummy.c
 
               #define _HPUX_SOURCE
               #include <stdlib.h>
               #include <unistd.h>
 
               int main ()
@@ -587,25 +632,35 @@
               #endif
               	default: puts ("hppa1.0"); break;
               	}
                   exit (0);
               }
 EOF
-	eval $set_cc_for_build
-	(CCOPTS= $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`
-	if test -z "$HP_ARCH"; then HP_ARCH=hppa; fi
-	rm -f $dummy.c $dummy
-	fi ;;
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
 	esac
+	if [ ${HP_ARCH} = "hppa2.0w" ]
+	then
+	    # avoid double evaluation of $set_cc_for_build
+	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
+	    then
+		HP_ARCH="hppa2.0w"
+	    else
+		HP_ARCH="hppa64"
+	    fi
+	fi
 	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
 	exit 0 ;;
     ia64:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	echo ia64-hp-hpux${HPUX_REV}
 	exit 0 ;;
     3050*:HI-UX:*:*)
+	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <unistd.h>
 	int
 	main ()
 	{
 	  long cpu = sysconf (_SC_CPU_VERSION);
@@ -625,15 +680,13 @@
 	  else if (CPU_IS_HP_MC68K (cpu))
 	    puts ("m68k-hitachi-hiuxwe2");
 	  else puts ("unknown-hitachi-hiuxwe2");
 	  exit (0);
 	}
 EOF
-	eval $set_cc_for_build
-	$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm -f $dummy.c $dummy && exit 0
-	rm -f $dummy.c $dummy
+	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
 	echo unknown-hitachi-hiuxwe2
 	exit 0 ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
 	echo hppa1.1-hp-bsd
 	exit 0 ;;
     9000/8??:4.3bsd:*:*)
@@ -655,15 +708,12 @@
 	    echo ${UNAME_MACHINE}-unknown-osf1
 	fi
 	exit 0 ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
 	exit 0 ;;
-    hppa*:OpenBSD:*:*)
-	echo hppa-unknown-openbsd
-	exit 0 ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
         exit 0 ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
@@ -676,77 +726,82 @@
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
         exit 0 ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
         exit 0 ;;
-    CRAY*X-MP:*:*:*)
-	echo xmp-cray-unicos
-        exit 0 ;;
     CRAY*Y-MP:*:*:*)
 	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
     CRAY*[A-Z]90:*:*:*)
 	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
     CRAY*TS:*:*:*)
 	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
-    CRAY*T3D:*:*:*)
-	echo alpha-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
     CRAY*T3E:*:*:*)
 	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
     CRAY*SV1:*:*:*)
 	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
-    CRAY-2:*:*:*)
-	echo cray2-cray-unicos
+    *:UNICOS/mp:*:*)
+	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/' 
         exit 0 ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
         FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
         FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
         echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
         exit 0 ;;
-    hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
-	exit 0 ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
 	exit 0 ;;
     sparc*:BSD/OS:*:*)
 	echo sparc-unknown-bsdi${UNAME_RELEASE}
 	exit 0 ;;
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
 	exit 0 ;;
     *:FreeBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
-	exit 0 ;;
-    *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	# Determine whether the default compiler uses glibc.
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#if __GLIBC__ >= 2
+	LIBC=gnu
+	#else
+	LIBC=
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
 	exit 0 ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit 0 ;;
     i*:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit 0 ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
 	exit 0 ;;
+    x86:Interix*:3*)
+	echo i586-pc-interix3
+	exit 0 ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit 0 ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
 	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i386-pc-interix
+	echo i586-pc-interix
 	exit 0 ;;
     i*:UWIN*:*)
 	echo ${UNAME_MACHINE}-pc-uwin
 	exit 0 ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin
@@ -761,22 +816,54 @@
 	echo ${UNAME_MACHINE}-pc-minix
 	exit 0 ;;
     arm*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
     m68*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
     mips:Linux:*:*)
-	case `sed -n '/^byte/s/^.*: \(.*\) endian/\1/p' < /proc/cpuinfo` in
-	  big)    echo mips-unknown-linux-gnu && exit 0 ;;
-	  little) echo mipsel-unknown-linux-gnu && exit 0 ;;
-	esac
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mipsel
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	;;
+    mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips64
+	#undef mips64el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mips64el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips64
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
 	;;
     ppc:Linux:*:*)
 	echo powerpc-unknown-linux-gnu
 	exit 0 ;;
     ppc64:Linux:*:*)
 	echo powerpc64-unknown-linux-gnu
@@ -786,13 +873,13 @@
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
 	  EV56)  UNAME_MACHINE=alphaev56 ;;
 	  PCA56) UNAME_MACHINE=alphapca56 ;;
 	  PCA57) UNAME_MACHINE=alphapca56 ;;
 	  EV6)   UNAME_MACHINE=alphaev6 ;;
 	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
         esac
 	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
 	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
 	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
 	exit 0 ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
@@ -819,62 +906,59 @@
 	echo x86_64-unknown-linux-gnu
 	exit 0 ;;
     i*86:Linux:*:*)
 	# The BFD linker knows what the default object file format is, so
 	# first see if it will tell us. cd to the root directory to prevent
 	# problems with other programs or directories called `ld' in the path.
-	ld_supported_targets=`cd /; ld --help 2>&1 \
+	# Set LC_ALL=C to ensure ld outputs messages in English.
+	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
 			 | sed -ne '/supported targets:/!d
 				    s/[ 	][ 	]*/ /g
 				    s/.*supported targets: *//
 				    s/ .*//
 				    p'`
         case "$ld_supported_targets" in
 	  elf32-i386)
 		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
 		;;
 	  a.out-i386-linux)
 		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit 0 ;;		
+		exit 0 ;;
 	  coff-i386)
 		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
 		exit 0 ;;
 	  "")
 		# Either a pre-BFD a.out linker (linux-gnuoldld) or
 		# one that does not give us useful --help.
 		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
 		exit 0 ;;
 	esac
 	# Determine whether the default compiler is a.out or elf
-	cat >$dummy.c <<EOF
-#include <features.h>
-#ifdef __cplusplus
-#include <stdio.h>  /* for printf() prototype */
-	int main (int argc, char *argv[]) {
-#else
-	int main (argc, argv) int argc; char *argv[]; {
-#endif
-#ifdef __ELF__
-# ifdef __GLIBC__
-#  if __GLIBC__ >= 2
-    printf ("%s-pc-linux-gnu\n", argv[1]);
-#  else
-    printf ("%s-pc-linux-gnulibc1\n", argv[1]);
-#  endif
-# else
-   printf ("%s-pc-linux-gnulibc1\n", argv[1]);
-# endif
-#else
-  printf ("%s-pc-linux-gnuaout\n", argv[1]);
-#endif
-  return 0;
-}
-EOF
 	eval $set_cc_for_build
-	$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm -f $dummy.c $dummy && exit 0
-	rm -f $dummy.c $dummy
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#ifdef __ELF__
+	# ifdef __GLIBC__
+	#  if __GLIBC__ >= 2
+	LIBC=gnu
+	#  else
+	LIBC=gnulibc1
+	#  endif
+	# else
+	LIBC=gnulibc1
+	# endif
+	#else
+	#ifdef __INTEL_COMPILER
+	LIBC=gnu
+	#else
+	LIBC=gnuaout
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
 	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
 	;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
 	# sysname and nodename.
@@ -885,12 +969,29 @@
         # number series starting with 2...
         # I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
         # Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
 	exit 0 ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit 0 ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit 0 ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit 0 ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit 0 ;;
     i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
 	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
 		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
 	else
 		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
@@ -906,28 +1007,25 @@
 	exit 0 ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
 		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
-		(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
-		(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
 			&& UNAME_MACHINE=i586
-		(/bin/uname -X|egrep '^Machine.*Pent ?II' >/dev/null) \
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
 			&& UNAME_MACHINE=i686
-		(/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) \
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
 	else
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
 	exit 0 ;;
-    i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit 0 ;;
     pc:*:*:*)
 	# Left here for compatibility:
         # uname -m prints for DJGPP always 'pc', but it prints nothing about
         # the processor, so we play safe by assuming i386.
 	echo i386-pc-msdosdjgpp
         exit 0 ;;
@@ -945,15 +1043,21 @@
 	fi
 	exit 0 ;;
     mini*:CTIX:SYS*5:*)
 	# "miniframe"
 	echo m68010-convergent-sysv
 	exit 0 ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit 0 ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit 0 ;;
     M68*:*:R3V[567]*:*)
 	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
+    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
@@ -964,15 +1068,12 @@
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
 	echo m68k-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
 	exit 0 ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
     rs6000:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
@@ -993,25 +1094,29 @@
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
 		echo ${UNAME_MACHINE}-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
 	exit 0 ;;
-    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                           # says <Richard.M.Bartel@ccMail.Census.GOV>
+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                      # says <Richard.M.Bartel@ccMail.Census.GOV>
         echo i586-unisys-sysv4
         exit 0 ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
 	echo hppa1.1-stratus-sysv4
 	exit 0 ;;
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
 	echo i860-stratus-sysv4
 	exit 0 ;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo hppa1.1-stratus-vos
+	exit 0 ;;
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
 	exit 0 ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
 	exit 0 ;;
@@ -1034,31 +1139,40 @@
     SX-4:SUPER-UX:*:*)
 	echo sx4-nec-superux${UNAME_RELEASE}
 	exit 0 ;;
     SX-5:SUPER-UX:*:*)
 	echo sx5-nec-superux${UNAME_RELEASE}
 	exit 0 ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit 0 ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody${UNAME_RELEASE}
 	exit 0 ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
 	exit 0 ;;
     *:Darwin:*:*)
-	echo `uname -p`-apple-darwin${UNAME_RELEASE}
+	case `uname -p` in
+	    *86) UNAME_PROCESSOR=i686 ;;
+	    powerpc) UNAME_PROCESSOR=powerpc ;;
+	esac
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
 	exit 0 ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	if test "${UNAME_MACHINE}" = "x86pc"; then
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = "x86"; then
+		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
-	echo `uname -p`-${UNAME_MACHINE}-nto-qnx
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
 	exit 0 ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
 	exit 0 ;;
-    NSR-[KW]:NONSTOP_KERNEL:*:*)
+    NSR-[DGKLNPTVW]:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
 	exit 0 ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
 	exit 0 ;;
     BS2000:POSIX*:*:*)
@@ -1075,17 +1189,12 @@
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
 	fi
 	echo ${UNAME_MACHINE}-unknown-plan9
 	exit 0 ;;
-    i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
-	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit 0 ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
 	exit 0 ;;
     *:TENEX:*:*)
 	echo pdp10-unknown-tenex
 	exit 0 ;;
@@ -1103,12 +1212,13 @@
 	exit 0 ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
 #echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
 
+eval $set_cc_for_build
 cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
 # include <sys/types.h>
 # include <sys/utsname.h>
 #endif
 main ()
@@ -1217,15 +1327,13 @@
 #endif
 
   exit (1);
 }
 EOF
 
-eval $set_cc_for_build
-$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm -f $dummy.c $dummy && exit 0
-rm -f $dummy.c $dummy
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
 
 # Apollos put the system type in the environment.
 
 test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
 
 # Convex versions that predate uname can use getsysinfo(1)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/config.h.in	2002-04-02 09:50:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/config.h.in	2003-01-28 13:05:53.000000000 +0800
@@ -1,304 +1,347 @@
-/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
 #undef ino_t
 #undef HAVE_CONNECT
 #undef HAVE_SHORT_INO_T
 #undef HAVE_GETOPT_LONG
 #undef REPLACE_INET_NTOA
 #undef REPLACE_INET_ATON
 #undef HAVE_GETTIMEOFDAY_TZ
 #undef ENABLE_IPV6
 #undef HAVE_SOCKADDR_LEN
+#undef HAVE_SOCKADDR_IN6_SCOPE_ID
 #undef HAVE_SOCKETPAIR
 
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#undef CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#undef C_ALLOCA
+
 /* Define to the type of elements in the array set by `getgroups'. Usually
    this is either `int' or `gid_t'. */
 #undef GETGROUPS_T
 
-/* Define if you have the <alloca.h> header file. */
+/* Define to 1 if you have `alloca', as a function or macro. */
+#undef HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
 #undef HAVE_ALLOCA_H
 
-/* Define if you have the <arpa/inet.h> header file. */
+/* Define to 1 if you have the <arpa/inet.h> header file. */
 #undef HAVE_ARPA_INET_H
 
-/* Define if you have the <arpa/nameser.h> header file. */
+/* Define to 1 if you have the <arpa/nameser.h> header file. */
 #undef HAVE_ARPA_NAMESER_H
 
-/* Define if you have the `asprintf' function. */
+/* Define to 1 if you have the `asprintf' function. */
 #undef HAVE_ASPRINTF
 
 /* */
 #undef HAVE_BROKEN_READDIR
 
 /* */
 #undef HAVE_C99_VSNPRINTF
 
-/* Define if you have the `chmod' function. */
+/* Define to 1 if you have the `chmod' function. */
 #undef HAVE_CHMOD
 
-/* Define if you have the `chown' function. */
+/* Define to 1 if you have the `chown' function. */
 #undef HAVE_CHOWN
 
-/* Define if you have the <compat.h> header file. */
+/* Define to 1 if you have the <compat.h> header file. */
 #undef HAVE_COMPAT_H
 
 /* */
 #undef HAVE_CONNECT
 
-/* Define if you have the <ctype.h> header file. */
+/* Define to 1 if you have the <ctype.h> header file. */
 #undef HAVE_CTYPE_H
 
-/* Define if you have the <dirent.h> header file, and it defines `DIR'. */
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
 #undef HAVE_DIRENT_H
 
 /* */
 #undef HAVE_ERRNO_DECL
 
-/* Define if you have the `fchmod' function. */
+/* Define to 1 if you have the `fchmod' function. */
 #undef HAVE_FCHMOD
 
-/* Define if you have the <fcntl.h> header file. */
+/* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
+/* Define to 1 if you have the <float.h> header file. */
+#undef HAVE_FLOAT_H
+
 /* */
 #undef HAVE_FNMATCH
 
-/* Define if you have the `fstat' function. */
+/* Define to 1 if you have the `fstat' function. */
 #undef HAVE_FSTAT
 
 /* Define if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
-/* Define if you have the `getcwd' function. */
+/* Define to 1 if you have the `getcwd' function. */
 #undef HAVE_GETCWD
 
-/* Define if you have the `getnameinfo' function. */
+/* Define to 1 if you have the `getnameinfo' function. */
 #undef HAVE_GETNAMEINFO
 
 /* */
 #undef HAVE_GETTIMEOFDAY_TZ
 
-/* Define if you have the `glob' function. */
+/* Define to 1 if you have the `glob' function. */
 #undef HAVE_GLOB
 
-/* Define if you have the <glob.h> header file. */
+/* Define to 1 if you have the <glob.h> header file. */
 #undef HAVE_GLOB_H
 
-/* Define if you have the <grp.h> header file. */
+/* Define to 1 if you have the <grp.h> header file. */
 #undef HAVE_GRP_H
 
-/* Define if you have the `inet_ntop' function. */
+/* Define to 1 if you have the `inet_ntop' function. */
 #undef HAVE_INET_NTOP
 
-/* Define if you have the `inet_pton' function. */
+/* Define to 1 if you have the `inet_pton' function. */
 #undef HAVE_INET_PTON
 
-/* Define if you have the <inttypes.h> header file. */
+/* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
-/* Define if you have the `lchown' function. */
+/* Define to 1 if you have the `lchown' function. */
 #undef HAVE_LCHOWN
 
-/* Define if you have the `inet' library (-linet). */
+/* Define to 1 if you have the `inet' library (-linet). */
 #undef HAVE_LIBINET
 
-/* Define if you have the `nsl' library (-lnsl). */
+/* Define to 1 if you have the `nsl' library (-lnsl). */
 #undef HAVE_LIBNSL
 
-/* Define if you have the `nsl_s' library (-lnsl_s). */
+/* Define to 1 if you have the `nsl_s' library (-lnsl_s). */
 #undef HAVE_LIBNSL_S
 
-/* Define if you have the `popt' library (-lpopt). */
+/* Define to 1 if you have the `popt' library (-lpopt). */
 #undef HAVE_LIBPOPT
 
-/* Define if you have the `resolv' library (-lresolv). */
+/* Define to 1 if you have the `resolv' library (-lresolv). */
 #undef HAVE_LIBRESOLV
 
-/* Define if you have the `socket' library (-lsocket). */
+/* Define to 1 if you have the `socket' library (-lsocket). */
 #undef HAVE_LIBSOCKET
 
-/* Define if you have the `link' function. */
+/* Define to 1 if you have the `link' function. */
 #undef HAVE_LINK
 
 /* */
 #undef HAVE_LONGLONG
 
-/* Define if you have the `mallinfo' function. */
+/* Define to 1 if you have the `mallinfo' function. */
 #undef HAVE_MALLINFO
 
-/* Define if you have the <malloc.h> header file. */
+/* Define to 1 if you have the <malloc.h> header file. */
 #undef HAVE_MALLOC_H
 
-/* Define if you have the <mcheck.h> header file. */
+/* Define to 1 if you have the <mcheck.h> header file. */
 #undef HAVE_MCHECK_H
 
-/* Define if you have the `memmove' function. */
+/* Define to 1 if you have the `memmove' function. */
 #undef HAVE_MEMMOVE
 
-/* Define if you have the <memory.h> header file. */
+/* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
-/* Define if you have the `mknod' function. */
+/* Define to 1 if you have the `mkfifo' function. */
+#undef HAVE_MKFIFO
+
+/* Define to 1 if you have the `mknod' function. */
 #undef HAVE_MKNOD
 
-/* Define if you have the `mtrace' function. */
+/* Define to 1 if you have the `mtrace' function. */
 #undef HAVE_MTRACE
 
-/* Define if you have the <ndir.h> header file, and it defines `DIR'. */
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
 #undef HAVE_NDIR_H
 
-/* Define if you have the <netdb.h> header file. */
+/* Define to 1 if you have the <netdb.h> header file. */
 #undef HAVE_NETDB_H
 
 /* */
 #undef HAVE_OFF64_T
 
-/* Define if you have the `readlink' function. */
+/* Define to 1 if you have the `readlink' function. */
 #undef HAVE_READLINK
 
 /* remote shell is remsh not rsh */
 #undef HAVE_REMSH
 
 /* */
 #undef HAVE_SECURE_MKSTEMP
 
-/* Define if you have the `setgroups' function. */
+/* Define to 1 if you have the `setgroups' function. */
 #undef HAVE_SETGROUPS
 
-/* Define if you have the `setsid' function. */
+/* Define to 1 if you have the `setsid' function. */
 #undef HAVE_SETSID
 
 /* */
 #undef HAVE_SHORT_INO_T
 
-/* Define if you have the `snprintf' function. */
+/* Define to 1 if you have the `snprintf' function. */
 #undef HAVE_SNPRINTF
 
 /* Define if you have strct sockaddr_storage. */
 #undef HAVE_SOCKADDR_STORAGE
 
 /* */
 #undef HAVE_SOCKETPAIR
 
-/* Define if you have the <stdint.h> header file. */
+/* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
-/* Define if you have the <stdlib.h> header file. */
+/* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
-/* Define if you have the `strcasecmp' function. */
+/* Define to 1 if you have the `strcasecmp' function. */
 #undef HAVE_STRCASECMP
 
-/* Define if you have the `strchr' function. */
+/* Define to 1 if you have the `strchr' function. */
 #undef HAVE_STRCHR
 
-/* Define if you have the `strdup' function. */
+/* Define to 1 if you have the `strdup' function. */
 #undef HAVE_STRDUP
 
-/* Define if you have the `strerror' function. */
+/* Define to 1 if you have the `strerror' function. */
 #undef HAVE_STRERROR
 
-/* Define if you have the `strftime' function. */
+/* Define to 1 if you have the `strftime' function. */
 #undef HAVE_STRFTIME
 
-/* Define if you have the <strings.h> header file. */
+/* Define to 1 if you have the <strings.h> header file. */
 #undef HAVE_STRINGS_H
 
-/* Define if you have the <string.h> header file. */
+/* Define to 1 if you have the <string.h> header file. */
 #undef HAVE_STRING_H
 
-/* Define if you have the `strlcat' function. */
+/* Define to 1 if you have the `strlcat' function. */
 #undef HAVE_STRLCAT
 
-/* Define if you have the `strlcpy' function. */
+/* Define to 1 if you have the `strlcpy' function. */
 #undef HAVE_STRLCPY
 
-/* Define if you have the `strpbrk' function. */
+/* Define to 1 if you have the `strpbrk' function. */
 #undef HAVE_STRPBRK
 
-/* Define if `st_rdev' is member of `struct stat'. */
+/* Define to 1 if you have the `strtol' function. */
+#undef HAVE_STRTOL
+
+/* Define to 1 if `st_rdev' is member of `struct stat'. */
 #undef HAVE_STRUCT_STAT_ST_RDEV
 
-/* Define if you have the <sys/dir.h> header file, and it defines `DIR'. */
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
 #undef HAVE_SYS_DIR_H
 
-/* Define if you have the <sys/fcntl.h> header file. */
+/* Define to 1 if you have the <sys/fcntl.h> header file. */
 #undef HAVE_SYS_FCNTL_H
 
-/* Define if you have the <sys/filio.h> header file. */
+/* Define to 1 if you have the <sys/filio.h> header file. */
 #undef HAVE_SYS_FILIO_H
 
-/* Define if you have the <sys/ioctl.h> header file. */
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
 #undef HAVE_SYS_IOCTL_H
 
-/* Define if you have the <sys/mode.h> header file. */
+/* Define to 1 if you have the <sys/mode.h> header file. */
 #undef HAVE_SYS_MODE_H
 
-/* Define if you have the <sys/ndir.h> header file, and it defines `DIR'. */
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
 #undef HAVE_SYS_NDIR_H
 
-/* Define if you have the <sys/param.h> header file. */
+/* Define to 1 if you have the <sys/param.h> header file. */
 #undef HAVE_SYS_PARAM_H
 
-/* Define if you have the <sys/select.h> header file. */
+/* Define to 1 if you have the <sys/select.h> header file. */
 #undef HAVE_SYS_SELECT_H
 
-/* Define if you have the <sys/socket.h> header file. */
+/* Define to 1 if you have the <sys/socket.h> header file. */
 #undef HAVE_SYS_SOCKET_H
 
-/* Define if you have the <sys/stat.h> header file. */
+/* Define to 1 if you have the <sys/stat.h> header file. */
 #undef HAVE_SYS_STAT_H
 
-/* Define if you have the <sys/sysctl.h> header file. */
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
 #undef HAVE_SYS_SYSCTL_H
 
-/* Define if you have the <sys/time.h> header file. */
+/* Define to 1 if you have the <sys/time.h> header file. */
 #undef HAVE_SYS_TIME_H
 
-/* Define if you have the <sys/types.h> header file. */
+/* Define to 1 if you have the <sys/types.h> header file. */
 #undef HAVE_SYS_TYPES_H
 
-/* Define if you have the <sys/unistd.h> header file. */
+/* Define to 1 if you have the <sys/unistd.h> header file. */
 #undef HAVE_SYS_UNISTD_H
 
-/* Define if you have the <sys/wait.h> header file. */
+/* Define to 1 if you have the <sys/un.h> header file. */
+#undef HAVE_SYS_UN_H
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
 #undef HAVE_SYS_WAIT_H
 
-/* Define if you have the <unistd.h> header file. */
+/* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
 /* */
 #undef HAVE_UNSIGNED_CHAR
 
 /* */
 #undef HAVE_UTIMBUF
 
-/* Define if you have the `utime' function. */
+/* Define to 1 if you have the `utime' function. */
 #undef HAVE_UTIME
 
-/* Define if you have the `utimes' function. */
+/* Define to 1 if you have the `utimes' function. */
 #undef HAVE_UTIMES
 
-/* Define if you have the <utime.h> header file. */
+/* Define to 1 if you have the <utime.h> header file. */
 #undef HAVE_UTIME_H
 
-/* Define if `utime(file, NULL)' sets file's timestamp to the present. */
+/* Define to 1 if `utime(file, NULL)' sets file's timestamp to the present. */
 #undef HAVE_UTIME_NULL
 
-/* Define if you have the `vsnprintf' function. */
+/* Define to 1 if you have the `vsnprintf' function. */
 #undef HAVE_VSNPRINTF
 
-/* Define if you have the `wait4' function. */
+/* Define to 1 if you have the `wait4' function. */
 #undef HAVE_WAIT4
 
-/* Define if you have the `waitpid' function. */
+/* Define to 1 if you have the `waitpid' function. */
 #undef HAVE_WAITPID
 
 /* true if you have IPv6 */
 #undef INET6
 
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
 /* */
 #undef REPLACE_INET_ATON
 
 /* */
 #undef REPLACE_INET_NTOA
 
@@ -311,29 +354,40 @@
 /* default -e command */
 #undef RSYNC_RSH
 
 /* rsync release version */
 #undef RSYNC_VERSION
 
+/* Define if sockets need to be shutdown */
+#undef SHUTDOWN_ALL_SOCKETS
+
 /* The size of a `int', as computed by sizeof. */
 #undef SIZEOF_INT
 
 /* The size of a `long', as computed by sizeof. */
 #undef SIZEOF_LONG
 
 /* The size of a `short', as computed by sizeof. */
 #undef SIZEOF_SHORT
 
-/* Define if you have the ANSI C header files. */
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+        STACK_DIRECTION > 0 => grows toward higher addresses
+        STACK_DIRECTION < 0 => grows toward lower addresses
+        STACK_DIRECTION = 0 => direction of growth unknown */
+#undef STACK_DIRECTION
+
+/* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
-/* Define if you can safely include both <sys/time.h> and <time.h>. */
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #undef TIME_WITH_SYS_TIME
 
-/* Define if your processor stores words with the most significant byte first
-   (like Motorola and SPARC, unlike Intel and VAX). */
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
 #undef WORDS_BIGENDIAN
 
 /* Number of bits in a file offset, on hosts where this is settable. */
 #undef _FILE_OFFSET_BITS
 
 /* Define _GNU_SOURCE so that we get all necessary prototypes */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/config.sub /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/config.sub
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/config.sub	2001-07-22 10:39:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/config.sub	2003-01-23 06:24:53.000000000 +0800
@@ -1,12 +1,12 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-#   Free Software Foundation, Inc.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
-timestamp='2001-06-08'
+timestamp='2003-01-22'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
 # can handle that machine.  It does not imply ALL GNU software can.
 #
 # This file is free software; you can redistribute it and/or modify
@@ -26,13 +26,14 @@
 
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-# Please send patches to <config-patches@gnu.org>.
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
 # Otherwise, we print the canonical config type on stdout and succeed.
 
@@ -114,13 +115,13 @@
 esac
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | storm-chaos* | os2-emx* | windows32-*)
+  nto-qnx* | linux-gnu* | freebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
@@ -220,32 +221,54 @@
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
-	tahoe | i860 | ia64 | m32r | m68k | m68000 | m88k | ns32k | arc \
-	        | arm | arme[lb] | arm[bl]e | armv[2345] | armv[345][lb] | strongarm | xscale \
-		| pyramid | mn10200 | mn10300 | tron | a29k \
-		| 580 | i960 | h8300 \
-		| x86 | ppcbe | mipsbe | mipsle | shbe | shle \
-		| hppa | hppa1.0 | hppa1.1 | hppa2.0 | hppa2.0w | hppa2.0n \
-		| hppa64 \
-		| alpha | alphaev[4-8] | alphaev56 | alphapca5[67] \
-		| alphaev6[78] \
-		| we32k | ns16k | clipper | i370 | sh | sh[34] \
-		| powerpc | powerpcle \
-		| 1750a | dsp16xx | pdp10 | pdp11 \
-		| mips16 | mips64 | mipsel | mips64el \
-		| mips64orion | mips64orionel | mipstx39 | mipstx39el \
-		| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \
-		| mips64vr5000 | mips64vr5000el | mcore | s390 | s390x \
-		| sparc | sparclet | sparclite | sparc64 | sparcv9 | sparcv9b \
-		| v850 | c4x \
-		| thumb | d10v | d30v | fr30 | avr | openrisc | tic80 \
-		| pj | pjl | h8500 | z8k)
+	1750a | 580 \
+	| a29k \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
+	| clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k \
+	| m32r | m68000 | m68k | m88k | mcore \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64vr | mips64vrel \
+	| mips64orion | mips64orionel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| msp430 \
+	| ns16k | ns32k \
+	| openrisc | or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pyramid \
+	| sh | sh[1234] | sh3e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
+	| strongarm \
+	| tahoe | thumb | tic80 | tron \
+	| v850 | v850e \
+	| we32k \
+	| x86 | xscale | xstormy16 | xtensa \
+	| z8k)
 		basic_machine=$basic_machine-unknown
 		;;
 	m6811 | m68hc11 | m6812 | m68hc12)
 		# Motorola 68HC11/12.
 		basic_machine=$basic_machine-unknown
 		os=-none
@@ -262,37 +285,64 @@
 	# Object if more than one company name word.
 	*-*-*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
-	# FIXME: clean up the formatting here.
-	vax-* | tahoe-* | i*86-* | i860-* | ia64-* | m32r-* | m68k-* | m68000-* \
-	      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | c[123]* \
-	      | arm-*  | armbe-* | armle-* | armv*-* | strongarm-* | xscale-* \
-	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \
-	      | power-* | none-* | 580-* | cray2-* | h8300-* | h8500-* | i960-* \
-	      | xmp-* | ymp-* \
-	      | x86-* | ppcbe-* | mipsbe-* | mipsle-* | shbe-* | shle-* \
-	      | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* | hppa2.0w-* \
-	      | hppa2.0n-* | hppa64-* \
-	      | alpha-* | alphaev[4-8]-* | alphaev56-* | alphapca5[67]-* \
-	      | alphaev6[78]-* \
-	      | we32k-* | cydra-* | ns16k-* | pn-* | np1-* | xps100-* \
-	      | clipper-* | orion-* \
-	      | sparclite-* | pdp10-* | pdp11-* | sh-* | sh[34]-* | sh[34]eb-* \
-	      | powerpc-* | powerpcle-* | sparc64-* | sparcv9-* | sparcv9b-* | sparc86x-* \
-	      | mips16-* | mips64-* | mipsel-* \
-	      | mips64el-* | mips64orion-* | mips64orionel-* \
-	      | mips64vr4100-* | mips64vr4100el-* | mips64vr4300-* | mips64vr4300el-* \
-	      | mipstx39-* | mipstx39el-* | mcore-* \
-	      | f30[01]-* | f700-* | s390-* | s390x-* | sv1-* | t3e-* \
-	      | [cjt]90-* \
-	      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \
-	      | thumb-* | v850-* | d30v-* | tic30-* | tic80-* | c30-* | fr30-* \
-	      | bs2000-* | tic54x-* | c54x-* | x86_64-* | pj-* | pjl-*)
+	580-* \
+	| a29k-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* \
+	| bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* \
+	| clipper-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* \
+	| m32r-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipstx39-* | mipstx39el-* \
+	| msp430-* \
+	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pyramid-* \
+	| romp-* | rs6000-* \
+	| sh-* | sh[1234]-* | sh3e-* | sh[34]eb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
+	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| tahoe-* | thumb-* | tic30-* | tic4x-* | tic54x-* | tic80-* | tron-* \
+	| v850-* | v850e-* | vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xps100-* | xscale-* | xstormy16-* \
+	| xtensa-* \
+	| ymp-* \
+	| z8k-*)
 		;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
 		basic_machine=i386-unknown
 		os=-bsd
@@ -349,12 +399,16 @@
 		os=-aux
 		;;
 	balance)
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
 		;;
 	convex-c2)
 		basic_machine=c2-convex
@@ -369,22 +423,14 @@
 		os=-bsd
 		;;
 	convex-c38)
 		basic_machine=c38-convex
 		os=-bsd
 		;;
-	cray | ymp)
-		basic_machine=ymp-cray
-		os=-unicos
-		;;
-	cray2)
-		basic_machine=cray2-cray
-		os=-unicos
-		;;
-	[cjt]90)
-		basic_machine=${basic_machine}-cray
+	cray | j90)
+		basic_machine=j90-cray
 		os=-unicos
 		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
 	cris | cris-* | etrax*)
@@ -393,12 +439,20 @@
 	da30 | da30-*)
 		basic_machine=m68k-da30
 		;;
 	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
 		basic_machine=mips-dec
 		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
 	delta | 3300 | motorola-3300 | motorola-delta \
 	      | 3300-motorola | delta-motorola)
 		basic_machine=m68k-motorola
 		;;
 	delta88)
 		basic_machine=m88k-motorola
@@ -573,20 +627,12 @@
 		basic_machine=m68000-convergent
 		;;
 	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
 		basic_machine=m68k-atari
 		os=-mint
 		;;
-	mipsel*-linux*)
-		basic_machine=mipsel-unknown
-		os=-linux-gnu
-		;;
-	mips*-linux*)
-		basic_machine=mips-unknown
-		os=-linux-gnu
-		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
@@ -595,12 +641,16 @@
 		os=-mmixware
 		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
 		;;
 	mvs)
 		basic_machine=i370-ibm
@@ -667,19 +717,27 @@
 		basic_machine=mips-compaq
 		os=-nonstopux
 		;;
 	np1)
 		basic_machine=np1-gould
 		;;
+	nv1)
+		basic_machine=nv1-cray
+		os=-unicosmp
+		;;
 	nsr-tandem)
 		basic_machine=nsr-tandem
 		;;
 	op50n-* | op60c-*)
 		basic_machine=hppa1.1-oki
 		os=-proelf
 		;;
+	or32 | or32-*)
+		basic_machine=or32-unknown
+		os=-coff
+		;;
 	OSE68000 | ose68000)
 		basic_machine=m68000-ericsson
 		os=-ose
 		;;
 	os68k)
 		basic_machine=m68k-none
@@ -699,22 +757,22 @@
 	pbb)
 		basic_machine=m68k-tti
 		;;
         pc532 | pc532-*)
 		basic_machine=ns32k-pc532
 		;;
-	pentium | p5 | k5 | k6 | nexgen)
+	pentium | p5 | k5 | k6 | nexgen | viac3)
 		basic_machine=i586-pc
 		;;
-	pentiumpro | p6 | 6x86 | athlon)
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
 		basic_machine=i686-pc
 		;;
 	pentiumii | pentium2)
 		basic_machine=i686-pc
 		;;
-	pentium-* | p5-* | k5-* | k6-* | nexgen-*)
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumpro-* | p6-* | 6x86-* | athlon-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumii-* | pentium2-*)
@@ -732,12 +790,22 @@
 	ppcle | powerpclittle | ppc-le | powerpc-little)
 		basic_machine=powerpcle-unknown
 	        ;;
 	ppcle-* | powerpclittle-*)
 		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	ps2)
 		basic_machine=i386-ibm
 		;;
 	pw32)
 		basic_machine=i586-unknown
 		os=-pw32
@@ -749,24 +817,36 @@
 	rm[46]00)
 		basic_machine=mips-siemens
 		;;
 	rtpc | rtpc-*)
 		basic_machine=romp-ibm
 		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
 	sa29200)
 		basic_machine=a29k-amd
 		os=-udi
 		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
 	sh)
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
-	sparclite-wrs)
+	sparclite-wrs | simso-wrs)
 		basic_machine=sparclite-wrs
 		os=-vxworks
 		;;
 	sps7)
 		basic_machine=m68k-bull
 		os=-sysv2
@@ -827,25 +907,37 @@
 		;;
 	symmetry)
 		basic_machine=i386-sequent
 		os=-dynix
 		;;
 	t3e)
-		basic_machine=t3e-cray
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
 		os=-unicos
 		;;
+        tic4x | c4x*)
+		basic_machine=tic4x-unknown
+		os=-coff
+		;;
 	tic54x | c54x*)
 		basic_machine=tic54x-unknown
 		os=-coff
 		;;
 	tx39)
 		basic_machine=mipstx39-unknown
 		;;
 	tx39el)
 		basic_machine=mipstx39el-unknown
 		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
 	udi29k)
 		basic_machine=a29k-amd
 		os=-udi
@@ -864,14 +956,14 @@
 		;;
 	vms)
 		basic_machine=vax-dec
 		os=-vms
 		;;
 	vpp*|vx|vx-*)
-               basic_machine=f301-fujitsu
-               ;;
+		basic_machine=f301-fujitsu
+		;;
 	vxworks960)
 		basic_machine=i960-wrs
 		os=-vxworks
 		;;
 	vxworks68)
 		basic_machine=m68k-wrs
@@ -886,23 +978,19 @@
 		os=-none
 		;;
 	w89k-*)
 		basic_machine=hppa1.1-winbond
 		os=-proelf
 		;;
-	windows32)
-		basic_machine=i386-pc
-		os=-windows32-msvcrt
-		;;
-	xmp)
-		basic_machine=xmp-cray
-		os=-unicos
-		;;
         xps | xps100)
 		basic_machine=xps100-honeywell
 		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
 	z8k-*-coff)
 		basic_machine=z8k-unknown
 		os=-sim
 		;;
 	none)
 		basic_machine=none-none
@@ -917,19 +1005,12 @@
 	op50n)
 		basic_machine=hppa1.1-oki
 		;;
 	op60c)
 		basic_machine=hppa1.1-oki
 		;;
-	mips)
-		if [ x$os = x-linux-gnu ]; then
-			basic_machine=mips-unknown
-		else
-			basic_machine=mips-mips
-		fi
-		;;
 	romp)
 		basic_machine=romp-ibm
 		;;
 	rs6000)
 		basic_machine=rs6000-ibm
 		;;
@@ -943,15 +1024,18 @@
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh3 | sh4)
+	sh3 | sh4 | sh3eb | sh4eb | sh[1234]le | sh3ele)
 		basic_machine=sh-unknown
 		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
 	sparc | sparcv9 | sparcv9b)
 		basic_machine=sparc-sun
 		;;
         cydra)
 		basic_machine=cydra-cydrome
 		;;
@@ -964,16 +1048,12 @@
 	mac | mpw | mac-mpw)
 		basic_machine=m68k-apple
 		;;
 	pmac | pmac-mpw)
 		basic_machine=powerpc-apple
 		;;
-	c4x*)
-		basic_machine=c4x-none
-		os=-coff
-		;;
 	*-unknown)
 		# Make sure to match an already-canonicalized machine name.
 		;;
 	*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
@@ -1030,28 +1110,33 @@
 	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -rhapsody* | -darwin* | -opened* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
-	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* | -os2*)
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -microbsd*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
 		case $basic_machine in
 		    x86-* | i*86-*)
 			;;
 		    *)
 			os=-nto$os
 			;;
 		esac
 		;;
+	-nto-qnx*)
+		;;
 	-nto*)
-		os=-nto-qnx
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
 		;;
 	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
 	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
@@ -1084,18 +1169,24 @@
 	-dynix*)
 		os=-bsd
 		;;
 	-acis*)
 		os=-aos
 		;;
+	-atheos*)
+		os=-atheos
+		;;
 	-386bsd)
 		os=-bsd
 		;;
 	-ctix* | -uts*)
 		os=-sysv
 		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
 	-ns2 )
 	        os=-nextstep2
 		;;
 	-nsk*)
 		os=-nsk
 		;;
@@ -1133,12 +1224,15 @@
 	-xenix)
 		os=-xenix
 		;;
         -*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
 	        os=-mint
 		;;
+	-aros*)
+		os=-aros
+		;;
 	-none)
 		;;
 	*)
 		# Get rid of the `-' at the beginning of $os.
 		os=`echo $os | sed 's/[^-]*-//'`
 		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
@@ -1164,12 +1258,13 @@
 	arm*-rebel)
 		os=-linux
 		;;
 	arm*-semi)
 		os=-aout
 		;;
+	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
 		;;
         pdp11-*)
 		os=-none
 		;;
@@ -1194,12 +1289,15 @@
 	mips*-cisco)
 		os=-elf
 		;;
 	mips*-*)
 		os=-elf
 		;;
+	or32-*)
+		os=-coff
+		;;
 	*-tti)	# must be before sparc entry or we get the wrong os.
 		os=-sysv3
 		;;
 	sparc-* | *-sun)
 		os=-sunos4.1.1
 		;;
@@ -1341,13 +1439,13 @@
 			-mvs* | -opened*)
 				vendor=ibm
 				;;
 			-ptx*)
 				vendor=sequent
 				;;
-			-vxsim* | -vxworks*)
+			-vxsim* | -vxworks* | -windiss*)
 				vendor=wrs
 				;;
 			-aux*)
 				vendor=apple
 				;;
 			-hms*)
@@ -1356,12 +1454,15 @@
 			-mpw* | -macos*)
 				vendor=apple
 				;;
 			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
 				vendor=atari
 				;;
+			-vos*)
+				vendor=stratus
+				;;
 		esac
 		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
 echo $basic_machine$os
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/configure	2002-04-02 09:50:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/configure	2003-01-28 13:27:40.000000000 +0800
@@ -1202,13 +1202,13 @@
 
 
 ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=2.5.5
+RSYNC_VERSION=2.5.6
 
 { echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
 echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -2464,13 +2464,13 @@
 
 cat >>confdefs.h <<\_ACEOF
 #define _GNU_SOURCE 1
 _ACEOF
 
 
-if test "$xac_cv_prog_cc_stdc" = xno
+if test "x$ac_cv_prog_cc_stdc" = xno
 then
 	{ echo "$as_me:$LINENO: WARNING: rsync requires an ANSI C compiler and you don't seem to have one" >&5
 echo "$as_me: WARNING: rsync requires an ANSI C compiler and you don't seem to have one" >&2;}
 fi
 
 # We must decide this before testing the compiler.
@@ -3292,12 +3292,27 @@
   test "$ac_cv_search_getaddrinfo" = "none required" || LIBS="$ac_cv_search_getaddrinfo $LIBS"
 
 fi
 
 fi
 
+echo "$as_me:$LINENO: checking whether to call shutdown on all sockets" >&5
+echo $ECHO_N "checking whether to call shutdown on all sockets... $ECHO_C" >&6
+case $host_os in
+	*cygwin* ) echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+cat >>confdefs.h <<\_ACEOF
+#define SHUTDOWN_ALL_SOCKETS 1
+_ACEOF
+
+		   ;;
+	       * ) echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6;;
+esac
+
 echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
 echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6
 if test "${ac_cv_c_bigendian+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   # See if sys/param.h defines the BYTE_ORDER macro.
@@ -4341,13 +4356,14 @@
 
 
 
 
 
 
-for ac_header in sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h
+
+for ac_header in sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h sys/un.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
@@ -4459,14 +4475,13 @@
 
 
 
 
 
 
-
-for ac_header in glob.h alloca.h mcheck.h sys/sysctl.h arpa/inet.h arpa/nameser.h
+for ac_header in glob.h mcheck.h sys/sysctl.h arpa/inet.h arpa/nameser.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
@@ -4802,12 +4817,126 @@
 
 fi
 
 done
 
 
+for ac_header in float.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  egrep -v '^ *\+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
 echo "$as_me:$LINENO: checking for int" >&5
 echo $ECHO_N "checking for int... $ECHO_C" >&6
 if test "${ac_cv_type_int+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -7247,12 +7376,46 @@
 else
   LIBOBJS="$LIBOBJS lib/inet_pton.$ac_objext"
 fi
 done
 
 
+# Irix 6.5 has getaddrinfo but not the corresponding defines, so use
+#   builtin getaddrinfo if one of the defines don't exist
+echo "$as_me:$LINENO: checking whether defines needed by getaddrinfo exist" >&5
+echo $ECHO_N "checking whether defines needed by getaddrinfo exist... $ECHO_C" >&6
+if test "${rsync_cv_HAVE_GETADDR_DEFINES+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+			cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+
+			#include <sys/types.h>
+			#include <sys/socket.h>
+			#include <netdb.h>
+			#ifdef AI_PASSIVE
+			yes
+			#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "yes" >/dev/null 2>&1; then
+  rsync_cv_HAVE_GETADDR_DEFINES=yes
+else
+  rsync_cv_HAVE_GETADDR_DEFINES=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $rsync_cv_HAVE_GETADDR_DEFINES" >&5
+echo "${ECHO_T}$rsync_cv_HAVE_GETADDR_DEFINES" >&6
+if test x"$rsync_cv_HAVE_GETADDR_DEFINES" = x"yes"; then
+	# Tru64 UNIX has getaddrinfo() but has it renamed in libc as
+	# something else so we must include <netdb.h> to get the
+	# redefinition.
 
 for ac_func in getaddrinfo
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
@@ -7321,13 +7484,61 @@
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
 else
-  LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext"
+  echo "$as_me:$LINENO: checking for getaddrinfo by including <netdb.h>" >&5
+echo $ECHO_N "checking for getaddrinfo by including <netdb.h>... $ECHO_C" >&6
+		cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+		#include <sys/socket.h>
+		#include <netdb.h>
+#ifdef F77_DUMMY_MAIN
+#  ifdef __cplusplus
+     extern "C"
+#  endif
+   int F77_DUMMY_MAIN() { return 1; }
+#endif
+int
+main ()
+{
+getaddrinfo(NULL, NULL, NULL, NULL);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETADDRINFO 1
+_ACEOF
+
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+			LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 done
 
 
 for ac_func in getnameinfo
 do
@@ -7403,12 +7614,17 @@
 
 else
   LIBOBJS="$LIBOBJS lib/getnameinfo.$ac_objext"
 fi
 done
 
+else
+	LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext"
+	LIBOBJS="$LIBOBJS lib/getnameinfo.$ac_objext"
+fi
+
 
 echo "$as_me:$LINENO: checking for struct sockaddr.sa_len" >&5
 echo $ECHO_N "checking for struct sockaddr.sa_len... $ECHO_C" >&6
 if test "${ac_cv_member_struct_sockaddr_sa_len+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -7511,12 +7727,72 @@
 cat conftest.$ac_ext >&5
 echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 
+echo "$as_me:$LINENO: checking for struct sockaddr_in6.sin6_scope_id" >&5
+echo $ECHO_N "checking for struct sockaddr_in6.sin6_scope_id... $ECHO_C" >&6
+if test "${ac_cv_member_struct_sockaddr_in6_sin6_scope_id+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+
+#ifdef F77_DUMMY_MAIN
+#  ifdef __cplusplus
+     extern "C"
+#  endif
+   int F77_DUMMY_MAIN() { return 1; }
+#endif
+int
+main ()
+{
+static struct sockaddr_in6 ac_aggr;
+if (ac_aggr.sin6_scope_id)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+ac_cv_member_struct_sockaddr_in6_sin6_scope_id=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&5
+echo "${ECHO_T}$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&6
+if test $ac_cv_member_struct_sockaddr_in6_sin6_scope_id = yes; then
+   cat >>confdefs.h <<\_ACEOF
+#define HAVE_SOCKADDR_IN6_SCOPE_ID 1
+_ACEOF
+
+fi
+
+
 # if we can't find strcasecmp, look in -lresolv (for Unixware at least)
 #
 
 for ac_func in strcasecmp
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
@@ -7725,21 +8001,330 @@
 #define HAVE_UTIME_NULL 1
 _ACEOF
 
 fi
 rm -f conftest.data
 
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+echo "$as_me:$LINENO: checking for working alloca.h" >&5
+echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
+if test "${ac_cv_working_alloca_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+#include <alloca.h>
+#ifdef F77_DUMMY_MAIN
+#  ifdef __cplusplus
+     extern "C"
+#  endif
+   int F77_DUMMY_MAIN() { return 1; }
+#endif
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_working_alloca_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+ac_cv_working_alloca_h=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
+echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
+if test $ac_cv_working_alloca_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA_H 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for alloca" >&5
+echo $ECHO_N "checking for alloca... $ECHO_C" >&6
+if test "${ac_cv_func_alloca_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+#ifdef F77_DUMMY_MAIN
+#  ifdef __cplusplus
+     extern "C"
+#  endif
+   int F77_DUMMY_MAIN() { return 1; }
+#endif
+int
+main ()
+{
+char *p = (char *) alloca (1);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_alloca_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+ac_cv_func_alloca_works=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
+echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
 
+if test $ac_cv_func_alloca_works = yes; then
 
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA 1
+_ACEOF
 
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
 
+ALLOCA=alloca.$ac_objext
+
+cat >>confdefs.h <<\_ACEOF
+#define C_ALLOCA 1
+_ACEOF
 
 
+echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
+echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
+if test "${ac_cv_os_cray+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+#if defined(CRAY) && ! defined(CRAY2)
+webecray
+#else
+wenotbecray
+#endif
 
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "webecray" >/dev/null 2>&1; then
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
 
-for ac_func in waitpid wait4 getcwd strdup strerror chown chmod mknod
+fi
+echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
+echo "${ECHO_T}$ac_cv_os_cray" >&6
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+char (*f) ();
+
+#ifdef F77_DUMMY_MAIN
+#  ifdef __cplusplus
+     extern "C"
+#  endif
+   int F77_DUMMY_MAIN() { return 1; }
+#endif
+int
+main ()
+{
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+f = $ac_func;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
+echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
+if test "${ac_cv_c_stack_direction+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  exit (find_stack_direction () < 0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_stack_direction=1
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+( exit $ac_status )
+ac_cv_c_stack_direction=-1
+fi
+rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
+echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+
+
+
+
+
+
+
+
+
+for ac_func in waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -7979,13 +8564,14 @@
 
 
 
 
 
 
-for ac_func in strlcat strlcpy mtrace mallinfo setgroups
+
+for ac_func in strlcat strlcpy strtol mtrace mallinfo setgroups
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -8235,12 +8821,19 @@
 if test x"$with_included_popt" = x"yes"
 then
     echo "$as_me:$LINENO: result: $srcdir/popt" >&5
 echo "${ECHO_T}$srcdir/popt" >&6
     BUILD_POPT='$(popt_OBJS)'
     CFLAGS="$CFLAGS -I$srcdir/popt"
+    if test x"$ALLOCA" != x
+    then
+	# this can be removed when/if we add an included alloca.c;
+	#  see autoconf documentation on AC_FUNC_ALLOCA
+	{ echo "$as_me:$LINENO: WARNING: included libpopt will use malloc, not alloca (which wastes a small amount of memory)" >&5
+echo "$as_me: WARNING: included libpopt will use malloc, not alloca (which wastes a small amount of memory)" >&2;}
+    fi
 else
     echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 echo "$as_me:$LINENO: checking for long long" >&5
@@ -9442,12 +10035,13 @@
 s,@CPP@,$CPP,;t t
 s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
 s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
 s,@INSTALL_DATA@,$INSTALL_DATA,;t t
 s,@HAVE_REMSH@,$HAVE_REMSH,;t t
 s,@LIBOBJS@,$LIBOBJS,;t t
+s,@ALLOCA@,$ALLOCA,;t t
 s,@OBJ_SAVE@,$OBJ_SAVE,;t t
 s,@OBJ_RESTORE@,$OBJ_RESTORE,;t t
 s,@CC_SHOBJ_FLAG@,$CC_SHOBJ_FLAG,;t t
 s,@BUILD_POPT@,$BUILD_POPT,;t t
 CEOF
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/configure.in	2002-04-02 09:41:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/configure.in	2003-01-28 13:27:40.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.52)
 
-RSYNC_VERSION=2.5.5
+RSYNC_VERSION=2.5.6
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -22,13 +22,13 @@
 AC_PROG_CC_STDC
 AC_SUBST(SHELL)
 
 AC_DEFINE([_GNU_SOURCE], 1,
           [Define _GNU_SOURCE so that we get all necessary prototypes])
 
-if test "$xac_cv_prog_cc_stdc" = xno
+if test "x$ac_cv_prog_cc_stdc" = xno
 then
 	AC_MSG_WARN([rsync requires an ANSI C compiler and you don't seem to have one])
 fi
 
 # We must decide this before testing the compiler.
 
@@ -244,22 +244,32 @@
 	done
 	AC_MSG_RESULT($ipv6type)
 
 	AC_SEARCH_LIBS(getaddrinfo, inet6)
 fi
 
+AC_MSG_CHECKING([whether to call shutdown on all sockets])
+case $host_os in
+	*cygwin* ) AC_MSG_RESULT(yes)
+                   AC_DEFINE(SHUTDOWN_ALL_SOCKETS, 1, 
+			    [Define if sockets need to be shutdown])
+		   ;;
+	       * ) AC_MSG_RESULT(no);;
+esac
+
 AC_C_BIGENDIAN
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h unistd.h utime.h grp.h)
 AC_CHECK_HEADERS(compat.h sys/param.h ctype.h sys/wait.h sys/ioctl.h)
-AC_CHECK_HEADERS(sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h)
-AC_CHECK_HEADERS(glob.h alloca.h mcheck.h sys/sysctl.h arpa/inet.h arpa/nameser.h)
+AC_CHECK_HEADERS(sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h sys/un.h)
+AC_CHECK_HEADERS(glob.h mcheck.h sys/sysctl.h arpa/inet.h arpa/nameser.h)
 AC_CHECK_HEADERS(netdb.h)
 AC_CHECK_HEADERS(malloc.h)
+AC_CHECK_HEADERS(float.h)
 
 AC_CHECK_SIZEOF(int)
 AC_CHECK_SIZEOF(long)
 AC_CHECK_SIZEOF(short)
 
 AC_C_INLINE
@@ -323,14 +333,45 @@
 
 dnl AC_MSG_NOTICE([Looking in libraries: $LIBS])
 
 AC_CHECK_FUNCS(inet_ntop, , AC_LIBOBJ(lib/inet_ntop)) 
 AC_CHECK_FUNCS(inet_pton, , AC_LIBOBJ(lib/inet_pton))
 
-AC_CHECK_FUNCS(getaddrinfo, , AC_LIBOBJ(lib/getaddrinfo))
-AC_CHECK_FUNCS(getnameinfo, , AC_LIBOBJ(lib/getnameinfo))
+# Irix 6.5 has getaddrinfo but not the corresponding defines, so use
+#   builtin getaddrinfo if one of the defines don't exist
+AC_CACHE_CHECK([whether defines needed by getaddrinfo exist],
+               rsync_cv_HAVE_GETADDR_DEFINES,[
+			AC_EGREP_CPP(yes, [
+			#include <sys/types.h>
+			#include <sys/socket.h>
+			#include <netdb.h>
+			#ifdef AI_PASSIVE
+			yes
+			#endif], 
+			rsync_cv_HAVE_GETADDR_DEFINES=yes,
+			rsync_cv_HAVE_GETADDR_DEFINES=no)])
+if test x"$rsync_cv_HAVE_GETADDR_DEFINES" = x"yes"; then
+	# Tru64 UNIX has getaddrinfo() but has it renamed in libc as
+	# something else so we must include <netdb.h> to get the
+	# redefinition.
+	AC_CHECK_FUNCS(getaddrinfo, ,
+		[AC_MSG_CHECKING([for getaddrinfo by including <netdb.h>])
+		AC_TRY_LINK([#include <sys/types.h>
+		#include <sys/socket.h>
+		#include <netdb.h>],[getaddrinfo(NULL, NULL, NULL, NULL);],
+			[AC_MSG_RESULT([yes])
+			AC_DEFINE(HAVE_GETADDRINFO, 1,
+				[Define if you have the `getaddrinfo' function.])],
+			[AC_MSG_RESULT([no])
+			AC_LIBOBJ(lib/getaddrinfo)])])
+	AC_CHECK_FUNCS(getnameinfo, , AC_LIBOBJ(lib/getnameinfo))
+else
+	AC_LIBOBJ(lib/getaddrinfo)
+	AC_LIBOBJ(lib/getnameinfo)
+fi
+
 
 AC_CHECK_MEMBER([struct sockaddr.sa_len], 
 		[ AC_DEFINE(HAVE_SOCKADDR_LEN) ],
 		[],
 		[
 #include <sys/types.h>
@@ -343,12 +384,21 @@
 [struct sockaddr_storage x;],
 	AC_MSG_RESULT(yes)
 	AC_DEFINE(HAVE_SOCKADDR_STORAGE, 1, 
 		[Define if you have strct sockaddr_storage.] ),
 	AC_MSG_RESULT(no))
 
+AC_CHECK_MEMBER([struct sockaddr_in6.sin6_scope_id],
+		[ AC_DEFINE(HAVE_SOCKADDR_IN6_SCOPE_ID) ],
+		[],
+		[
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+])
+
 # if we can't find strcasecmp, look in -lresolv (for Unixware at least)
 #
 AC_CHECK_FUNCS(strcasecmp)
 if test x"$ac_cv_func_strcasecmp" = x"no"; then
     AC_CHECK_LIB(resolv, strcasecmp)
 fi
@@ -356,16 +406,17 @@
 dnl At the moment we don't test for a broken memcmp(), because all we
 dnl need to do is test for equality, not comparison, and it seems that
 dnl every platform has a memcmp that can do at least that.  
 dnl AC_FUNC_MEMCMP
 
 AC_FUNC_UTIME_NULL
-AC_CHECK_FUNCS(waitpid wait4 getcwd strdup strerror chown chmod mknod)
+AC_FUNC_ALLOCA
+AC_CHECK_FUNCS(waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo)
 AC_CHECK_FUNCS(fchmod fstat strchr readlink link utime utimes strftime)
 AC_CHECK_FUNCS(memmove lchown vsnprintf snprintf asprintf setsid glob strpbrk)
-AC_CHECK_FUNCS(strlcat strlcpy mtrace mallinfo setgroups)
+AC_CHECK_FUNCS(strlcat strlcpy strtol mtrace mallinfo setgroups)
 
 AC_CACHE_CHECK([for working socketpair],rsync_cv_HAVE_SOCKETPAIR,[
 AC_TRY_RUN([
 #include <sys/types.h>
 #include <sys/socket.h>
 
@@ -395,12 +446,18 @@
 AC_MSG_CHECKING([whether to use included libpopt])
 if test x"$with_included_popt" = x"yes"
 then
     AC_MSG_RESULT($srcdir/popt)
     BUILD_POPT='$(popt_OBJS)'
     CFLAGS="$CFLAGS -I$srcdir/popt"
+    if test x"$ALLOCA" != x
+    then
+	# this can be removed when/if we add an included alloca.c;
+	#  see autoconf documentation on AC_FUNC_ALLOCA
+	AC_MSG_WARN([included libpopt will use malloc, not alloca (which wastes a small amount of memory)])
+    fi
 else
     AC_MSG_RESULT(no)
 fi
 
 AC_CACHE_CHECK([for long long],rsync_cv_HAVE_LONGLONG,[
 AC_TRY_RUN([#include <stdio.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/.cvsignore /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/.cvsignore
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/.cvsignore	2002-03-26 09:27:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/.cvsignore	2003-01-10 23:16:23.000000000 +0800
@@ -5,15 +5,19 @@
 config.cache
 config.h
 config.log
 config.status
 conftest.c
 conftest.log
+dox
+getgroups
 gmon.out
 rsync
 shconfig
 testdir
 tests-dont-exist
 testtmp
 testtmp.*
 tls
+trimslash
+t_unsafe
 zlib/dummy
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6: cvs.log
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6: Doxyfile
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/errcode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/errcode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/errcode.h	2002-02-07 05:20:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/errcode.h	2002-04-09 13:29:26.000000000 +0800
@@ -19,12 +19,13 @@
 
 /*
  * error codes returned by rsync.  If you change these, please also update the
  * string mappings in log.c
  */
 
+#define RERR_OK         0
 #define RERR_SYNTAX     1       /* syntax or usage error */
 #define RERR_PROTOCOL   2       /* protocol incompatibility */
 #define RERR_FILESELECT 3       /* errors selecting input/output files, dirs */
 #define RERR_UNSUPPORTED 4       /* requested action not supported */
 #define RERR_STARTCLIENT 5      /* error starting client-server protocol */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/exclude.c	2002-02-19 03:10:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/exclude.c	2003-01-27 04:10:23.000000000 +0800
@@ -1,25 +1,26 @@
 /* -*- c-file-style: "linux" -*-
-     
-   Copyright (C) 1996-2001 by Andrew Tridgell <tridge@samba.org>
-   Copyright (C) 1996 by Paul Mackerras
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * 
+ * Copyright (C) 1996-2001 by Andrew Tridgell <tridge@samba.org>
+ * Copyright (C) 1996 by Paul Mackerras
+ * Copyright (C) 2002 by Martin Pool
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 /* a lot of this stuff was originally derived from GNU tar, although
    it has now changed so much that it is hard to tell :) */
 
 /* include/exclude cluestick added by Martin Pool <mbp@samba.org> */
 
@@ -27,13 +28,13 @@
 
 extern int verbose;
 extern int delete_mode;
 
 static struct exclude_struct **exclude_list;
 
-/* build an exclude structure given a exclude pattern */
+/** Build an exclude structure given a exclude pattern */
 static struct exclude_struct *make_exclude(const char *pattern, int include)
 {
 	struct exclude_struct *ret;
 
 	ret = (struct exclude_struct *)malloc(sizeof(*ret));
 	if (!ret) out_of_memory("make_exclude");
@@ -216,14 +217,20 @@
 
 struct exclude_struct **make_exclude_list(const char *fname,
 					  struct exclude_struct **list1,
 					  int fatal, int include)
 {
 	struct exclude_struct **list=list1;
-	FILE *f = fopen(fname,"r");
+	FILE *f;
 	char line[MAXPATHLEN];
+
+	if (strcmp(fname, "-")) {
+		f = fopen(fname,"r");
+	} else {
+		f = fdopen(0, "r");
+	}
 	if (!f) {
 		if (fatal) {
 			rsyserr(FERROR, errno,
                                 "failed to open %s file %s",
                                 include ? "include" : "exclude",
                                 fname);
@@ -231,13 +238,13 @@
 		}
 		return list;
 	}
 
 	while (fgets(line,MAXPATHLEN,f)) {
 		int l = strlen(line);
-		if (l && line[l-1] == '\n') l--;
+		while (l && (line[l-1] == '\n' || line[l-1] == '\r')) l--;
 		line[l] = 0;
 		if (line[0] && (line[0] != ';') && (line[0] != '#')) {
 			/* Skip lines starting with semicolon or pound.
 			   It probably wouldn't cause any harm to not skip
 			     them but there's no need to save them. */
 			add_exclude_list(line,&list,include);
@@ -331,26 +338,26 @@
 	}
 
 	if (!more)
 		return(NULL);
 
 	/* Skip over any initial spaces */
-	while(isspace(*s))
+	while (isspace(* (unsigned char *) s))
 		s++;
 
 	/* Are we at the end of the string? */
 	if (*s) {
 		/* remember the beginning of the token */
 		t=s;
 
 		/* Is this a '+' or '-' followed by a space (not whitespace)? */
 		if ((*s=='+' || *s=='-') && *(s+1)==' ')
 			s+=2;
 	
 		/* Skip to the next space or the end of the string */
-		while(!isspace(*s) && *s!='\0')
+		while (!isspace(* (unsigned char *) s) && *s != '\0')
 			s++;
 	} else {
 		t=NULL;
 	}
 
 	/* Have we reached the end of the string? */
@@ -383,18 +390,17 @@
 		add_exclude(tok, 1);
 	free(p);
 }
 
 
 static char *cvs_ignore_list[] = {
-  "RCS","SCCS","CVS","CVS.adm","RCSLOG","cvslog.*",
-  "tags","TAGS",".make.state",".nse_depinfo",
-  "*~", "#*", ".#*", ",*", "*.old", "*.bak", "*.BAK", "*.orig",
+  "RCS/", "SCCS/", "CVS/", ".svn/", "CVS.adm", "RCSLOG", "cvslog.*",
+  "tags", "TAGS", ".make.state", ".nse_depinfo",
+  "*~", "#*", ".#*", ", *", "*.old", "*.bak", "*.BAK", "*.orig",
   "*.rej", ".del-*", "*.a", "*.o", "*.obj", "*.so", "*.Z", "*.elc", "*.ln",
-  "core",NULL};
-
+  "core", NULL};
 
 
 void add_cvs_excludes(void)
 {
 	char fname[MAXPATHLEN];
 	char *p;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/flist.c	2002-03-15 05:20:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/flist.c	2003-01-19 02:00:23.000000000 +0800
@@ -58,14 +58,12 @@
 extern int io_error;
 extern int sanitize_paths;
 
 extern int read_batch;
 extern int write_batch;
 
-static char topsrcname[MAXPATHLEN];
-
 static struct exclude_struct **local_exclude_list;
 
 static struct file_struct null_file;
 
 static void clean_flist(struct file_list *flist, int strip_root);
 
@@ -189,50 +187,65 @@
 			(double) f->length, timestring(f->modtime),
 			f_name(f));
 	}
 }
 
 
-int readlink_stat(const char *Path, STRUCT_STAT * Buffer, char *Linkbuf)
+/**
+ * Stat either a symlink or its referent, depending on the settings of
+ * copy_links, copy_unsafe_links, etc.
+ *
+ * @retval -1 on error
+ *
+ * @retval 0 for success
+ *
+ * @post If @p path is a symlink, then @p linkbuf (of size @c
+ * MAXPATHLEN) contains the symlink target.
+ *
+ * @post @p buffer contains information about the link or the
+ * referrent as appropriate, if they exist.
+ **/
+int readlink_stat(const char *path, STRUCT_STAT * buffer, char *linkbuf)
 {
 #if SUPPORT_LINKS
 	if (copy_links) {
-		return do_stat(Path, Buffer);
+		return do_stat(path, buffer);
 	}
-	if (do_lstat(Path, Buffer) == -1) {
+	if (do_lstat(path, buffer) == -1) {
 		return -1;
 	}
-	if (S_ISLNK(Buffer->st_mode)) {
+	if (S_ISLNK(buffer->st_mode)) {
 		int l;
-		if ((l =
-		     readlink((char *) Path, Linkbuf,
-			      MAXPATHLEN - 1)) == -1) {
+		l = readlink((char *) path, linkbuf, MAXPATHLEN - 1);
+		if (l == -1) 
 			return -1;
-		}
-		Linkbuf[l] = 0;
-		if (copy_unsafe_links && (topsrcname[0] != '\0') &&
-		    unsafe_symlink(Linkbuf, topsrcname)) {
-			return do_stat(Path, Buffer);
+		linkbuf[l] = 0;
+		if (copy_unsafe_links && unsafe_symlink(linkbuf, path)) {
+			if (verbose > 1) {
+				rprintf(FINFO,"copying unsafe symlink \"%s\" -> \"%s\"\n", 
+					path, linkbuf);
+			}
+			return do_stat(path, buffer);
 		}
 	}
 	return 0;
 #else
-	return do_stat(Path, Buffer);
+	return do_stat(path, buffer);
 #endif
 }
 
-int link_stat(const char *Path, STRUCT_STAT * Buffer)
+int link_stat(const char *path, STRUCT_STAT * buffer)
 {
 #if SUPPORT_LINKS
 	if (copy_links) {
-		return do_stat(Path, Buffer);
+		return do_stat(path, buffer);
 	} else {
-		return do_lstat(Path, Buffer);
+		return do_lstat(path, buffer);
 	}
 #else
-	return do_stat(Path, Buffer);
+	return do_stat(path, buffer);
 #endif
 }
 
 /*
   This function is used to check if a file should be included/excluded
   from the list of files based on its name and type etc
@@ -339,12 +352,14 @@
 
 	if (!file) {
 		write_byte(f, 0);
 		return;
 	}
 
+	io_write_phase = "send_file_entry";
+
 	fname = f_name(file);
 
 	flags = base_flags;
 
 	if (file->mode == last_mode)
 		flags |= SAME_MODE;
@@ -434,12 +449,14 @@
 	last_uid = file->uid;
 	last_gid = file->gid;
 	last_time = file->modtime;
 
 	strlcpy(lastname, fname, MAXPATHLEN);
 	lastname[MAXPATHLEN - 1] = 0;
+
+	io_write_phase = "unknown";
 }
 
 
 
 static void receive_file_entry(struct file_struct **fptr,
 			       unsigned flags, int f)
@@ -519,13 +536,13 @@
 		    (flags & SAME_UID) ? last_uid : (uid_t) read_int(f);
 	if (preserve_gid)
 		file->gid =
 		    (flags & SAME_GID) ? last_gid : (gid_t) read_int(f);
 	if (preserve_devices && IS_DEVICE(file->mode))
 		file->rdev =
-		    (flags & SAME_RDEV) ? last_rdev : (dev_t) read_int(f);
+		    (flags & SAME_RDEV) ? last_rdev : (DEV64_T) read_int(f);
 
 	if (preserve_links && S_ISLNK(file->mode)) {
 		int l = read_int(f);
 		if (l < 0) {
 			rprintf(FERROR, "overflow: l=%d\n", l);
 			overflow("receive_file_entry");
@@ -641,14 +658,16 @@
 	fname = cleaned_name;
 
 	memset(sum, 0, SUM_LENGTH);
 
 	if (readlink_stat(fname, &st, linkbuf) != 0) {
 		int save_errno = errno;
-		if ((errno == ENOENT) && copy_links && !noexcludes) {
-			/* symlink pointing nowhere, see if excluded */
+		if ((errno == ENOENT) && !noexcludes) {
+			/* either symlink pointing nowhere or file that 
+			 * was removed during rsync run; see if excluded
+			 * before reporting an error */
 			memset((char *) &st, 0, sizeof(st));
 			if (check_exclude_file(f, fname, &st)) {
 				/* file is excluded anyway, ignore silently */
 				return NULL;
 			}
 		}
@@ -848,17 +867,17 @@
 	}
 
 	closedir(d);
 }
 
 
-/*
+/**
  *
- * I *think* f==-1 means that the list should just be built in memory
- * and not transmitted.  But who can tell? -- mbp
- */
+ * I <b>think</b> f==-1 means that the list should just be built in
+ * memory and not transmitted.  But who can tell? -- mbp
+ **/
 struct file_list *send_file_list(int f, int argc, char *argv[])
 {
 	int i, l;
 	STRUCT_STAT st;
 	char *p, *dir, *olddir;
 	char lastpath[MAXPATHLEN] = "";
@@ -874,13 +893,14 @@
 
 	if (f != -1) {
 		io_start_buffering(f);
 	}
 
 	for (i = 0; i < argc; i++) {
-		char *fname = topsrcname;
+		char fname2[MAXPATHLEN];
+		char *fname = fname2;
 
 		strlcpy(fname, argv[i], MAXPATHLEN);
 
 		l = strlen(fname);
 		if (l != 1 && fname[l - 1] == '/') {
 			if ((l == 2) && (fname[0] == '.')) {
@@ -979,14 +999,12 @@
 					dir, strerror(errno));
 				exit_cleanup(RERR_FILESELECT);
 			}
 		}
 	}
 
-	topsrcname[0] = '\0';
-
 	if (f != -1) {
 		send_file_entry(NULL, f, 0);
 	}
 
 	if (show_filelist_p() && f != -1) {
 		finish_filelist_progress(flist);
@@ -1132,13 +1150,15 @@
 
 
 int flist_find(struct file_list *flist, struct file_struct *f)
 {
 	int low = 0, high = flist->count - 1;
 
-	if (flist->count <= 0)
+	while (high >= 0 && !flist->files[high]->basename) high--;
+
+	if (high < 0)
 		return -1;
 
 	while (low != high) {
 		int mid = (low + high) / 2;
 		int ret =
 		    file_compare(&flist->files[flist_up(flist, mid)], &f);
@@ -1174,13 +1194,13 @@
 }
 
 
 /*
  * allocate a new file list
  */
-struct file_list *flist_new()
+struct file_list *flist_new(void)
 {
 	struct file_list *flist;
 
 	flist = (struct file_list *) malloc(sizeof(flist[0]));
 	if (!flist)
 		out_of_memory("send_file_list");
@@ -1226,43 +1246,48 @@
  * This routine ensures we don't have any duplicate names in our file list.
  * duplicate names can cause corruption because of the pipelining 
  */
 static void clean_flist(struct file_list *flist, int strip_root)
 {
 	int i;
+	char *name, *prev_name = NULL;
 
 	if (!flist || flist->count == 0)
 		return;
 
 	qsort(flist->files, flist->count,
 	      sizeof(flist->files[0]), (int (*)()) file_compare);
 
-	for (i = 1; i < flist->count; i++) {
-		if (flist->files[i]->basename &&
-		    flist->files[i - 1]->basename &&
-		    strcmp(f_name(flist->files[i]),
-			   f_name(flist->files[i - 1])) == 0) {
-			if (verbose > 1 && !am_server)
+	for (i = 0; i < flist->count; i++) {
+		if (flist->files[i]->basename) {
+			prev_name = f_name(flist->files[i]);
+			break;
+		}
+	}
+	while (++i < flist->count) {
+		if (!flist->files[i]->basename)
+			continue;
+		name = f_name(flist->files[i]);
+		if (strcmp(name, prev_name) == 0) {
+			if (verbose > 1 && !am_server) {
 				rprintf(FINFO,
 					"removing duplicate name %s from file list %d\n",
-					f_name(flist->files[i - 1]),
-					i - 1);
-			/* it's not great that the flist knows the semantics of the
-			 * file memory usage, but i'd rather not add a flag byte
-			 * to that struct. XXX can i use a bit in the flags field? */
+					name, i);
+			}
+			/* it's not great that the flist knows the semantics of
+			 * the file memory usage, but i'd rather not add a flag
+			 * byte to that struct.
+			 * XXX can i use a bit in the flags field? */
 			if (flist->string_area)
 				flist->files[i][0] = null_file;
 			else
 				free_file(flist->files[i]);
 		}
+		prev_name = name;
 	}
 
-	/* FIXME: There is a bug here when filenames are repeated more
-	 * than once, because we don't handle freed files when doing
-	 * the comparison. */
-
 	if (strip_root) {
 		/* we need to strip off the root directory in the case
 		   of relative paths, but this must be done _after_
 		   the sorting phase */
 		for (i = 0; i < flist->count; i++) {
 			if (flist->files[i]->dirname &&
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/generator.c	2002-03-25 13:54:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/generator.c	2002-08-29 22:44:55.000000000 +0800
@@ -38,21 +38,31 @@
 extern int size_only;
 extern int io_timeout;
 extern int remote_version;
 extern int always_checksum;
 extern int modify_window;
 extern char *compare_dest;
+extern int link_dest;
 
 
 /* choose whether to skip a particular file */
 static int skip_file(char *fname,
 		     struct file_struct *file, STRUCT_STAT *st)
 {
 	if (st->st_size != file->length) {
 		return 0;
 	}
+	if (link_dest) {
+		if((st->st_mode & ~_S_IFMT) !=  (file->mode & ~_S_IFMT)) {
+			return 0;
+		}
+		if (st->st_uid != file->uid || st->st_gid != file->gid) {
+			return 0;
+		}
+	}
+
 	
 	/* if always checksum is set then we use the checksum instead 
 	   of the file time to determine whether to sync */
 	if (always_checksum && S_ISREG(st->st_mode)) {
 		char sum[MD4_SUM_LENGTH];
 		char fnamecmpdest[MAXPATHLEN];
@@ -97,39 +107,23 @@
 	if (ret > CHUNK_SIZE/2) ret = CHUNK_SIZE/2;
 	return ret;
 }
 
 
 /*
-  send a sums struct down a fd
+  send a header that says "we have no checksums" down the f_out fd
   */
-static void send_sums(struct sum_struct *s, int f_out)
+static void send_null_sums(int f_out)
 {
-	if (s) {
-		size_t i;
-
-		/* tell the other guy how many we are going to be
-		   doing and how many bytes there are in the last
-		   chunk */
-		write_int(f_out, s->count);
-		write_int(f_out, s->n);
-		write_int(f_out, s->remainder);
-
-		for (i = 0; i < s->count; i++) {
-			write_int(f_out, s->sums[i].sum1);
-			write_buf(f_out, s->sums[i].sum2, csum_length);
-		}
-	} else {
-		/* we don't have checksums */
-		write_int(f_out, 0);
-		write_int(f_out, block_size);
-		write_int(f_out, 0);
-	}
+	write_int(f_out, 0);
+	write_int(f_out, block_size);
+	write_int(f_out, 0);
 }
 
 
+
 /**
  * Perhaps we want to just send an empty checksum set for this file,
  * which will force the whole thing to be literally transferred.
  *
  * When do we do this?  If the user's explicitly said they
  * want the whole thing, or if { they haven't explicitly
@@ -155,93 +149,83 @@
 	else
 		return local_server;
 }
 
 
 /*
-  generate a stream of signatures/checksums that describe a buffer
-
-  generate approximately one checksum every n bytes
-  */
-static struct sum_struct *generate_sums(struct map_struct *buf,OFF_T len,int n)
+ * Generate and send a stream of signatures/checksums that describe a buffer
+ *
+ * Generate approximately one checksum every block_len bytes.
+ */
+static void generate_and_send_sums(struct map_struct *buf, OFF_T len,
+				   int block_len, int f_out)
 {
-	int i;
-	struct sum_struct *s;
-	int count;
-	int block_len = n;
-	int remainder = (len%block_len);
+	size_t i;
+	struct sum_struct sum;
 	OFF_T offset = 0;
 
-	count = (len+(block_len-1))/block_len;
-
-	s = (struct sum_struct *)malloc(sizeof(*s));
-	if (!s) out_of_memory("generate_sums");
-
-	s->count = count;
-	s->remainder = remainder;
-	s->n = n;
-	s->flength = len;
-
-	if (count==0) {
-		s->sums = NULL;
-		return s;
-	}
-
-	if (verbose > 3)
-		rprintf(FINFO,"count=%d rem=%d n=%d flength=%.0f\n",
-			s->count,s->remainder,s->n,(double)s->flength);
-
-	s->sums = (struct sum_buf *)malloc(sizeof(s->sums[0])*s->count);
-	if (!s->sums) out_of_memory("generate_sums");
-  
-	for (i=0;i<count;i++) {
-		int n1 = MIN(len,n);
-		char *map = map_ptr(buf,offset,n1);
-
-		s->sums[i].sum1 = get_checksum1(map,n1);
-		get_checksum2(map,n1,s->sums[i].sum2);
-
-		s->sums[i].offset = offset;
-		s->sums[i].len = n1;
-		s->sums[i].i = i;
-
-		if (verbose > 3)
-			rprintf(FINFO,"chunk[%d] offset=%.0f len=%d sum1=%08x\n",
-				i,(double)s->sums[i].offset,s->sums[i].len,s->sums[i].sum1);
-
+	sum.count = (len + (block_len - 1)) / block_len;
+	sum.remainder = (len % block_len);
+	sum.n = block_len;
+	sum.flength = len;
+	/* not needed here  sum.sums = NULL; */
+
+	if (sum.count && verbose > 3) {
+		rprintf(FINFO, "count=%ld rem=%ld n=%ld flength=%.0f\n",
+			(long) sum.count, (long) sum.remainder,
+			(long) sum.n, (double) sum.flength);
+	}
+
+	write_int(f_out, sum.count);
+	write_int(f_out, sum.n);
+	write_int(f_out, sum.remainder);
+
+	for (i = 0; i < sum.count; i++) {
+		int n1 = MIN(len, block_len);
+		char *map = map_ptr(buf, offset, n1);
+		uint32 sum1 = get_checksum1(map, n1);
+		char sum2[SUM_LENGTH];
+
+		get_checksum2(map, n1, sum2);
+
+		if (verbose > 3) {
+			rprintf(FINFO,
+				"chunk[%d] offset=%.0f len=%d sum1=%08lx\n",
+				i, (double) offset, n1, (unsigned long) sum1);
+		}
+		write_int(f_out, sum1);
+		write_buf(f_out, sum2, csum_length);
 		len -= n1;
 		offset += n1;
 	}
-
-	return s;
 }
 
 
 
-/*
- * Acts on file number I from FLIST, whose name is fname.
+/**
+ * Acts on file number @p i from @p flist, whose name is @p fname.
  *
  * First fixes up permissions, then generates checksums for the file.
  *
- * (This comment was added later by mbp who was trying to work it out;
- * it might be wrong.)
- */ 
-void recv_generator(char *fname,struct file_list *flist,int i,int f_out)
+ * @note This comment was added later by mbp who was trying to work it
+ * out.  It might be wrong.
+ **/ 
+void recv_generator(char *fname, struct file_list *flist, int i, int f_out)
 {  
 	int fd;
 	STRUCT_STAT st;
 	struct map_struct *buf;
-	struct sum_struct *s;
 	int statret;
 	struct file_struct *file = flist->files[i];
 	char *fnamecmp;
 	char fnamecmpbuf[MAXPATHLEN];
 	extern char *compare_dest;
 	extern int list_only;
 	extern int preserve_perms;
 	extern int only_existing;
+	extern int orig_umask;
 
 	if (list_only) return;
 
 	if (verbose > 2)
 		rprintf(FINFO,"recv_generator(%s,%d)\n",fname,i);
 
@@ -278,13 +262,13 @@
 				return;
 			}
 			statret = -1;
 		}
 		if (statret != 0 && do_mkdir(fname,file->mode) != 0 && errno != EEXIST) {
 			if (!(relative_paths && errno==ENOENT && 
-			      create_directory_path(fname)==0 && 
+			      create_directory_path(fname, orig_umask)==0 && 
 			      do_mkdir(fname,file->mode)==0)) {
 				rprintf(FERROR, RSYNC_NAME ": recv_generator: mkdir \"%s\": %s (2)\n",
 					fname,strerror(errno));
 			}
 		}
 		/* f_out is set to -1 when doing final directory 
@@ -379,20 +363,32 @@
 		snprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",compare_dest,fname);
 		statret = link_stat(fnamecmpbuf,&st);
 		if (!S_ISREG(st.st_mode))
 			statret = -1;
 		if (statret == -1)
 			errno = saveerrno;
+#if HAVE_LINK
+		else if (link_dest && !dry_run) {
+			if (do_link(fnamecmpbuf, fname) != 0) {
+				if (verbose > 0)
+					rprintf(FINFO,"link %s => %s : %s\n",
+						fnamecmpbuf,
+						fname,
+						strerror(errno));
+			}
+			fnamecmp = fnamecmpbuf;
+		}
+#endif
 		else
 			fnamecmp = fnamecmpbuf;
 	}
 
 	if (statret == -1) {
 		if (errno == ENOENT) {
 			write_int(f_out,i);
-			if (!dry_run) send_sums(NULL,f_out);
+			if (!dry_run) send_null_sums(f_out);
 		} else {
 			if (verbose > 1)
 				rprintf(FERROR, RSYNC_NAME
 					": recv_generator failed to open \"%s\": %s\n",
 					fname, strerror(errno));
 		}
@@ -403,13 +399,13 @@
 		if (delete_file(fname) != 0) {
 			return;
 		}
 
 		/* now pretend the file didn't exist */
 		write_int(f_out,i);
-		if (!dry_run) send_sums(NULL,f_out);    
+		if (!dry_run) send_null_sums(f_out);
 		return;
 	}
 
 	if (opt_ignore_existing && fnamecmp == fname) { 
 		if (verbose > 1)
 			rprintf(FINFO,"%s exists\n",fname);
@@ -432,48 +428,45 @@
 		write_int(f_out,i);
 		return;
 	}
 
 	if (disable_deltas_p()) {
 		write_int(f_out,i);
-		send_sums(NULL,f_out);    
+		send_null_sums(f_out);
 		return;
 	}
 
 	/* open the file */  
 	fd = do_open(fnamecmp, O_RDONLY, 0);
 
 	if (fd == -1) {
 		rprintf(FERROR,RSYNC_NAME": failed to open \"%s\", continuing : %s\n",fnamecmp,strerror(errno));
 		/* pretend the file didn't exist */
 		write_int(f_out,i);
-		send_sums(NULL,f_out);
+		send_null_sums(f_out);
 		return;
 	}
 
 	if (st.st_size > 0) {
 		buf = map_file(fd,st.st_size);
 	} else {
 		buf = NULL;
 	}
 
 	if (verbose > 3)
 		rprintf(FINFO,"gen mapped %s of size %.0f\n",fnamecmp,(double)st.st_size);
 
-	s = generate_sums(buf,st.st_size,adapt_block_size(file, block_size));
-
 	if (verbose > 2)
-		rprintf(FINFO,"sending sums for %d\n",i);
+		rprintf(FINFO, "generating and sending sums for %d\n", i);
 
 	write_int(f_out,i);
-	send_sums(s,f_out);
+	generate_and_send_sums(buf, st.st_size,
+			       adapt_block_size(file, block_size), f_out);
 
 	close(fd);
 	if (buf) unmap_file(buf);
-
-	free_sums(s);
 }
 
 
 
 void generate_files(int f,struct file_list *flist,char *local_name,int f_recv)
 {
@@ -481,12 +474,19 @@
 	int phase=0;
 
 	if (verbose > 2)
 		rprintf(FINFO,"generator starting pid=%d count=%d\n",
 			(int)getpid(),flist->count);
 
+	if (verbose >= 2) {
+		rprintf(FINFO,
+			disable_deltas_p() 
+			? "delta-transmission disabled for local transfer or --whole-file\n"
+			: "delta transmission enabled\n");
+	}
+	
 	/* we expect to just sit around now, so don't exit on a
 	   timeout. If we really get a timeout then the other process should
 	   exit */
 	io_timeout = 0;
 
 	for (i = 0; i < flist->count; i++) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/install-sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/install-sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/install-sh	1996-06-22 13:04:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/install-sh	2003-01-11 03:58:51.000000000 +0800
@@ -205,13 +205,13 @@
 	else
 		true
 	fi
 
 # Make a temp file name in the proper directory.
 
-	dsttmp=$dstdir/#inst.$$#
+	dsttmp=$dstdir/_inst.$$_
 
 # Move or copy the file name to the temp name
 
 	$doit $instcmd $src $dsttmp &&
 
 	trap "rm -f ${dsttmp}" 0 &&
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/io.c	2002-03-22 13:14:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/io.c	2002-04-11 10:11:50.000000000 +0800
@@ -1,26 +1,26 @@
 /* -*- c-file-style: "linux" -*-
-   
-   Copyright (C) 1996-2001 by Andrew Tridgell 
-   Copyright (C) Paul Mackerras 1996
-   Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * 
+ * Copyright (C) 1996-2001 by Andrew Tridgell 
+ * Copyright (C) Paul Mackerras 1996
+ * Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 /**
  * @file io.c
  *
  * Socket and pipe IO utilities used in rsync.
  *
@@ -33,13 +33,13 @@
  * connection, but it's switched on quite early using
  * io_start_multiplex_out() and io_start_multiplex_in().
  **/
 
 #include "rsync.h"
 
-/* if no timeout is specified then use a 60 second select timeout */
+/** If no timeout is specified then use a 60 second select timeout */
 #define SELECT_TIMEOUT 60
 
 static int io_multiplexing_out;
 static int io_multiplexing_in;
 static int multiplex_in_fd;
 static int multiplex_out_fd;
@@ -49,12 +49,30 @@
 extern int bwlimit;
 extern int verbose;
 extern int io_timeout;
 extern struct stats stats;
 
 
+const char phase_unknown[] = "unknown";
+
+/**
+ * The connection might be dropped at some point; perhaps because the
+ * remote instance crashed.  Just giving the offset on the stream is
+ * not very helpful.  So instead we try to make io_phase_name point to
+ * something useful.
+ *
+ * For buffered/multiplexed IO these names will be somewhat
+ * approximate; perhaps for ease of support we would rather make the
+ * buffer always flush when a single application-level IO finishes.
+ *
+ * @todo Perhaps we want some simple stack functionality, but there's
+ * no need to overdo it.
+ **/
+const char *io_write_phase = phase_unknown;
+const char *io_read_phase = phase_unknown;
+
 /** Ignore EOF errors while reading a module listing if the remote
     version is 24 or less. */
 int kludge_around_eof = False;
 
 
 static int io_error_fd = -1;
@@ -83,19 +101,19 @@
 				(int)(t-last_io));
 		}
 		exit_cleanup(RERR_TIMEOUT);
 	}
 }
 
-/* setup the fd used to propogate errors */
+/** Setup the fd used to propagate errors */
 void io_set_error_fd(int fd)
 {
 	io_error_fd = fd;
 }
 
-/* read some data from the error fd and write it to the write log code */
+/** Read some data from the error fd and write it to the write log code */
 static void read_error_fd(void)
 {
 	char buf[200];
 	size_t n;
 	int fd = io_error_fd;
 	int tag, len;
@@ -121,27 +139,24 @@
 	}
 
 	io_error_fd = fd;
 }
 
 
+/**
+ * It's almost always an error to get an EOF when we're trying to read
+ * from the network, because the protocol is self-terminating.
+ *
+ * However, there is one unfortunate cases where it is not, which is
+ * rsync <2.4.6 sending a list of modules on a server, since the list
+ * is terminated by closing the socket. So, for the section of the
+ * program where that is a problem (start_socket_client),
+ * kludge_around_eof is True and we just exit.
+ */
 static void whine_about_eof (void)
 {
-	/**
-	   It's almost always an error to get an EOF when we're trying
-	   to read from the network, because the protocol is
-	   self-terminating.
-	   
-	   However, there is one unfortunate cases where it is not,
-	   which is rsync <2.4.6 sending a list of modules on a
-	   server, since the list is terminated by closing the socket.
-	   So, for the section of the program where that is a problem
-	   (start_socket_client), kludge_around_eof is True and we
-	   just exit.
-	*/
-
 	if (kludge_around_eof)
 		exit_cleanup (0);
 	else {
 		rprintf (FERROR,
 			 "%s: connection unexpectedly closed "
 			 "(%.0f bytes read so far)\n",
@@ -160,13 +175,13 @@
 	rprintf(FERROR, "%s: read error: %s\n",
 		RSYNC_NAME, strerror (err));
 	exit_cleanup(RERR_STREAMIO);
 }
 
 
-/*!
+/**
  * Read from a socket with IO timeout. return the number of bytes
  * read. If no bytes can be read then exit, never return a number <= 0.
  *
  * TODO: If the remote shell connection fails, then current versions
  * actually report an "unexpected EOF" error here.  Since it's a
  * fairly common mistake to try to use rsh when ssh is required, we
@@ -242,14 +257,16 @@
 	return ret;
 }
 
 
 
 
-/*! Continue trying to read len bytes - don't return until len has
-  been read.   */
+/**
+ * Continue trying to read len bytes - don't return until len has been
+ * read.
+ **/
 static void read_loop (int fd, char *buf, size_t len)
 {
 	while (len) {
 		int n = read_timeout(fd, buf, len);
 
 		buf += n;
@@ -313,14 +330,17 @@
 
 	return ret;
 }
 
 
 
-/* do a buffered read from fd. don't return until all N bytes
-   have been read. If all N can't be read then exit with an error */
+/**
+ * Do a buffered read from @p fd.  Don't return until all @p n bytes
+ * have been read.  If all @p n can't be read then exit with an
+ * error.
+ **/
 static void readfd (int fd, char *buffer, size_t N)
 {
 	int  ret;
 	size_t total=0;  
 	
 	while (total < N) {
@@ -384,14 +404,46 @@
 {
 	unsigned char c;
 	read_buf (f, (char *)&c, 1);
 	return c;
 }
 
-/* Write len bytes to fd.  This underlies the multiplexing system,
- * which is always called by application code.  */
+
+/**
+ * Sleep after writing to limit I/O bandwidth usage.
+ *
+ * @todo Rather than sleeping after each write, it might be better to
+ * use some kind of averaging.  The current algorithm seems to always
+ * use a bit less bandwidth than specified, because it doesn't make up
+ * for slow periods.  But arguably this is a feature.  In addition, we
+ * ought to take the time used to write the data into account.
+ **/
+static void sleep_for_bwlimit(int bytes_written)
+{
+	struct timeval tv;
+
+	if (!bwlimit)
+		return;
+
+	assert(bytes_written > 0);
+	assert(bwlimit > 0);
+	
+	tv.tv_usec = bytes_written * 1000 / bwlimit;
+	tv.tv_sec  = tv.tv_usec / 1000000;
+	tv.tv_usec = tv.tv_usec % 1000000;
+
+	select(0, NULL, NULL, NULL, &tv);
+}
+
+
+/**
+ * Write len bytes to the file descriptor @p fd.
+ *
+ * This function underlies the multiplexing system.  The body of the
+ * application never calls this function directly.
+ **/
 static void writefd_unbuffered(int fd,char *buf,size_t len)
 {
 	size_t total = 0;
 	fd_set w_fds, r_fds;
 	int fd_count, count;
 	struct timeval tv;
@@ -454,30 +506,19 @@
 
 			if (ret <= 0) {
 				/* Don't try to write errors back
 				 * across the stream */
 				io_multiplexing_close();
 				rprintf(FERROR, RSYNC_NAME
-					": error writing %d unbuffered bytes"
-					" - exiting: %s\n", len,
+					": writefd_unbuffered failed to write %ld bytes: phase \"%s\": %s\n",
+					(long) len, io_write_phase, 
 					strerror(errno));
 				exit_cleanup(RERR_STREAMIO);
 			}
 
-			/* Sleep after writing to limit I/O bandwidth */
-			if (bwlimit)
-			{
-			    tv.tv_sec = 0;
-			    tv.tv_usec = ret * 1000 / bwlimit;
-			    while (tv.tv_usec > 1000000)
-			    {
-				tv.tv_sec++;
-				tv.tv_usec -= 1000000;
-			    }
-			    select(0, NULL, NULL, NULL, &tv);
- 			}
+			sleep_for_bwlimit(ret);
  
 			total += ret;
 
 			if (io_timeout)
 				last_io = time(NULL);
 		}
@@ -496,14 +537,16 @@
 	multiplex_out_fd = fd;
 	io_buffer = (char *)malloc(IO_BUFFER_SIZE);
 	if (!io_buffer) out_of_memory("writefd");
 	io_buffer_count = 0;
 }
 
-/* write an message to a multiplexed stream. If this fails then rsync
-   exits */
+/**
+ * Write an message to a multiplexed stream. If this fails then rsync
+ * exits.
+ **/
 static void mplex_write(int fd, enum logcode code, char *buf, size_t len)
 {
 	char buffer[4096];
 	size_t n = len;
 
 	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
@@ -580,12 +623,20 @@
 	char b[4];
 	SIVAL(b,0,x);
 	writefd(f,b,4);
 }
 
 
+void write_int_named(int f, int32 x, const char *phase)
+{
+	io_write_phase = phase;
+	write_int(f, x);
+	io_write_phase = phase_unknown;
+}
+
+
 /*
  * Note: int64 may actually be a 32-bit type if ./configure couldn't find any
  * 64-bit types on this platform.
  */
 void write_longint(int f, int64 x)
 {
@@ -606,13 +657,13 @@
 
 void write_buf(int f,char *buf,size_t len)
 {
 	writefd(f,buf,len);
 }
 
-/* write a string to the connection */
+/** Write a string to the connection */
 static void write_sbuf(int f,char *buf)
 {
 	write_buf(f, buf, strlen(buf));
 }
 
 
@@ -667,40 +718,40 @@
 	if (len < 0) exit_cleanup(RERR_STREAMIO);
 
 	write_sbuf(fd, buf);
 }
 
 
-/* setup for multiplexing an error stream with the data stream */
+/** Setup for multiplexing an error stream with the data stream */
 void io_start_multiplex_out(int fd)
 {
 	multiplex_out_fd = fd;
 	io_flush();
 	io_start_buffering(fd);
 	io_multiplexing_out = 1;
 }
 
-/* setup for multiplexing an error stream with the data stream */
+/** Setup for multiplexing an error stream with the data stream */
 void io_start_multiplex_in(int fd)
 {
 	multiplex_in_fd = fd;
 	io_flush();
 	io_multiplexing_in = 1;
 }
 
-/* write an message to the multiplexed error stream */
+/** Write an message to the multiplexed error stream */
 int io_multiplex_write(enum logcode code, char *buf, size_t len)
 {
 	if (!io_multiplexing_out) return 0;
 
 	io_flush();
 	stats.total_written += (len+4);
 	mplex_write(multiplex_out_fd, code, buf, len);
 	return 1;
 }
 
-/* stop output multiplexing */
+/** Stop output multiplexing */
 void io_multiplexing_close(void)
 {
 	io_multiplexing_out = 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/compat.c	2002-01-15 19:32:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/compat.c	2002-04-08 11:40:02.000000000 +0800
@@ -1,8 +1,9 @@
 /* 
    Copyright (C) Andrew Tridgell 1998
+   Copyright (C) 2002 by Martin Pool
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
    
@@ -13,17 +14,21 @@
    
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
-/*
-  compatibility functions - replacing functions for platforms that don't
-  have them.
+/**
+ * @file compat.c
+ *
+ * Reimplementations of standard functions for platforms that don't
+ * have them.
+ **/
+
+
 
-  */
 #include "rsync.h"
 
 
 #ifndef HAVE_STRDUP
  char *strdup(char *s)
 {
@@ -75,15 +80,17 @@
 	bcopy((char *) src, (char *) dest, n);
 	return dest;
 }
 #endif
 
 #ifndef HAVE_STRPBRK
-/* Find the first ocurrence in S of any character in ACCEPT.  
-   derived from glibc 
-*/
+/**
+ * Find the first ocurrence in @p s of any character in @p accept.
+ *
+ * Derived from glibc 
+ **/
  char *strpbrk(const char *s, const char *accept)
 {
 	while (*s != '\0')  {
 		const char *a = accept;
 		while (*a != '\0') {
 			if (*a++ == *s)	return (char *)s;
@@ -94,16 +101,20 @@
 	return NULL;
 }
 #endif
 
 
 #ifndef HAVE_STRLCPY
-/* Like strncpy but does not 0 fill the buffer and always null 
- * terminates. bufsize is the size of the destination buffer.
+/**
+ * Like strncpy but does not 0 fill the buffer and always null 
+ * terminates.
+ *
+ * @param bufsize is the size of the destination buffer.
  *
- * Returns the index of the terminating byte. */
+ * @return index of the terminating byte.
+ **/
  size_t strlcpy(char *d, const char *s, size_t bufsize)
 {
 	size_t len = strlen(s);
 	size_t ret = len;
 	if (bufsize <= 0) return 0;
 	if (len >= bufsize) len = bufsize-1;
@@ -111,15 +122,19 @@
 	d[len] = 0;
 	return ret;
 }
 #endif
 
 #ifndef HAVE_STRLCAT
-/* like strncat but does not 0 fill the buffer and always null 
-   terminates. bufsize is the length of the buffer, which should
-   be one more than the maximum resulting string length */
+/**
+ * Like strncat() but does not 0 fill the buffer and always null 
+ * terminates.
+ *
+ * @param bufsize length of the buffer, which should be one more than
+ * the maximum resulting string length.
+ **/
  size_t strlcat(char *d, const char *s, size_t bufsize)
 {
 	size_t len1 = strlen(d);
 	size_t len2 = strlen(s);
 	size_t ret = len1 + len2;
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib: .cvsignore
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/getaddrinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/getaddrinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/getaddrinfo.c	2001-12-14 13:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/getaddrinfo.c	2003-01-11 06:38:25.000000000 +0800
@@ -393,29 +393,31 @@
 	}
 	
 	/* hostname as numeric name */
 	for (i = 0; afdl[i].a_af; i++) {
 		if (inet_pton(afdl[i].a_af, hostname, pton)) {
 			u_long v4a;
-			u_char pfx;
 
 			switch (afdl[i].a_af) {
 			case AF_INET:
 				v4a = ((struct in_addr *)pton)->s_addr;
 				if (IN_MULTICAST(v4a) || IN_EXPERIMENTAL(v4a))
 					pai->ai_flags &= ~AI_CANONNAME;
 				v4a >>= IN_CLASSA_NSHIFT;
 				if (v4a == 0 || v4a == IN_LOOPBACKNET)
 					pai->ai_flags &= ~AI_CANONNAME;
 				break;
 #ifdef INET6
 			case AF_INET6:
+			{
+				u_char pfx;
 				pfx = ((struct in6_addr *)pton)->s6_addr[0];
 				if (pfx == 0 || pfx == 0xfe || pfx == 0xff)
 					pai->ai_flags &= ~AI_CANONNAME;
 				break;
+			}
 #endif
 			}
 			
 			if (pai->ai_family == afdl[i].a_af ||
 			    pai->ai_family == PF_UNSPEC) {
 				if (! (pai->ai_flags & AI_CANONNAME)) {
@@ -470,16 +472,19 @@
 	struct addrinfo *pai;
 	int port0;
 {
 	u_short port = port0 & 0xffff;
 	struct hostent *hp;
 	struct addrinfo *cur;
-	int error = 0, h_error;
+	int error = 0;
 	
 #ifdef INET6
-	hp = getipnodebyaddr(addr, afd->a_addrlen, afd->a_af, &h_error);
+	{
+		int h_error;
+		hp = getipnodebyaddr(addr, afd->a_addrlen, afd->a_af, &h_error);
+	}
 #else
 	hp = gethostbyaddr(addr, afd->a_addrlen, AF_INET);
 #endif
 	if (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {
 		if (!get_ai(&cur, pai, afd, hp->h_addr_list[0], port))
 			goto free;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/getnameinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/getnameinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/getnameinfo.c	2001-12-05 21:40:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/getnameinfo.c	2003-01-11 06:38:25.000000000 +0800
@@ -51,13 +51,13 @@
 #ifdef INET6
 	{PF_INET6, sizeof(struct in6_addr), sizeof(struct sockaddr_in6),
 		offsetof(struct sockaddr_in6, sin6_addr)},
 #endif
 	{PF_INET, sizeof(struct in_addr), sizeof(struct sockaddr_in),
 		offsetof(struct sockaddr_in, sin_addr)},
-	{0, 0, 0},
+	{0, 0, 0, 0},
 };
 
 struct sockinet {
 	u_char	si_len;
 	u_char	si_family;
 	u_short	si_port;
@@ -86,13 +86,15 @@
 	struct servent *sp;
 	struct hostent *hp;
 	u_short port;
 	int family, i;
 	char *addr, *p;
 	u_long v4a;
+#ifdef INET6
 	u_char pfx;
+#endif
 	int h_error;
 	char numserv[512];
 	char numaddr[512];
 
 	if (sa == NULL)
 		return ENI_NOSOCKET;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/inet_pton.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/inet_pton.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/inet_pton.c	2001-11-28 09:29:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/inet_pton.c	2003-01-11 04:08:12.000000000 +0800
@@ -24,16 +24,18 @@
 /*
  * WARNING: Don't even consider trying to compile this on a system where
  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
  */
 
 static int inet_pton4(const char *src, unsigned char *dst);
+#ifdef INET6
 static int inet_pton6(const char *src, unsigned char *dst);
+#endif
 
 /* int
- * isc_net_pton(af, src, dst)
+ * inet_pton(af, src, dst)
  *	convert from presentation format (which usually means ASCII printable)
  *	to network format (which is usually some kind of binary format).
  * return:
  *	1 if the address was valid for the specified address family
  *	0 if the address wasn't valid (`dst' is untouched in this case)
  *	-1 if some other error occurred (`dst' is untouched in this case, too)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/permstring.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/permstring.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/lib/permstring.c	2001-11-29 08:15:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/lib/permstring.c	2003-01-11 04:08:43.000000000 +0800
@@ -44,14 +44,16 @@
 	if (mode & S_ISUID)
 		perms[3] = (mode & S_IXUSR) ? 's' : 'S';
 
 	if (mode & S_ISGID)
 		perms[6] = (mode & S_IXGRP) ? 's' : 'S';
 	
+#ifdef S_ISVTX
 	if (mode & S_ISVTX)
 		perms[9] = (mode & S_IXOTH) ? 't' : 'T';
+#endif
 		
 	if (S_ISLNK(mode)) perms[0] = 'l';
 	if (S_ISDIR(mode)) perms[0] = 'd';
 	if (S_ISBLK(mode)) perms[0] = 'b';
 	if (S_ISCHR(mode)) perms[0] = 'c';
 	if (S_ISSOCK(mode)) perms[0] = 's';
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/loadparm.c	2002-03-25 12:04:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/loadparm.c	2002-08-31 07:27:26.000000000 +0800
@@ -476,17 +476,18 @@
           if (psz2 == NULL)
               return (1);
 
    /* sync the strings on first non-whitespace */
    while (1)
    {
-      while (isspace(*psz1))
+      while (isspace(* (unsigned char *) psz1))
          psz1++;
-      while (isspace(*psz2))
+      while (isspace(* (unsigned char *) psz2))
          psz2++;
-      if (toupper(*psz1) != toupper(*psz2) || *psz1 == '\0' || *psz2 == '\0')
+      if (toupper(* (unsigned char *) psz1) != toupper(* (unsigned char *) psz2)
+	  || *psz1 == '\0' || *psz2 == '\0')
          break;
       psz1++;
       psz2++;
    }
    return (*psz1 - *psz2);
 }
@@ -744,22 +745,30 @@
 /***************************************************************************
 Load the services array from the services file. Return True on success, 
 False on failure.
 ***************************************************************************/
 BOOL lp_load(char *pszFname, int globals_only)
 {
+	extern int am_server;
+	extern int am_daemon;
+	extern int am_root;
 	pstring n2;
 	BOOL bRetval;
  
 	bRetval = False;
 
 	bInGlobalSection = True;
   
 	init_globals();
 
-	pstrcpy(n2,pszFname);
+	if (pszFname)
+	    pstrcpy(n2,pszFname);
+	else if (am_server && am_daemon && !am_root)
+	    pstrcpy(n2,RSYNCD_USERCONF);
+	else
+	    pstrcpy(n2,RSYNCD_SYSCONF);
 
 	/* We get sections first, so have to start 'behind' to make up */
 	iServiceIndex = -1;
 	bRetval = pm_process(n2, globals_only?NULL:do_section, do_parameter);
   
 	return (bRetval);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/log.c	2002-02-19 03:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/log.c	2002-12-24 15:42:04.000000000 +0800
@@ -24,15 +24,17 @@
 
   Mapping to human-readable messages added by Martin Pool
   <mbp@samba.org>, Oct 2000.
   */
 #include "rsync.h"
 
+static int log_initialised;
 static char *logfname;
 static FILE *logfile;
 static int log_error_fd = -1;
+struct stats stats;
 
 int log_got_error=0;
 
 struct {
         int code;
         char const *name;
@@ -47,13 +49,13 @@
 	{ RERR_STREAMIO   , "error in rsync protocol data stream" }, 
 	{ RERR_MESSAGEIO  , "errors with program diagnostics" }, 
 	{ RERR_IPC        , "error in IPC code" }, 
 	{ RERR_SIGNAL     , "received SIGUSR1 or SIGINT" }, 
 	{ RERR_WAITCHILD  , "some error returned by waitpid()" }, 
 	{ RERR_MALLOC     , "error allocating core memory buffers" }, 
-	{ RERR_PARTIAL    , "partial transfer" }, 
+	{ RERR_PARTIAL    , "some files could not be transferred" }, 
 	{ RERR_TIMEOUT    , "timeout in data send/receive" }, 
 	{ RERR_CMD_FAILED , "remote shell failed" },
 	{ RERR_CMD_KILLED , "remote shell killed" },
 	{ RERR_CMD_RUN,     "remote command could not be run" },
         { RERR_CMD_NOTFOUND, "remote command not found" },
         { 0, NULL }
@@ -142,18 +144,17 @@
 		syslog(priority, "%s", buf);
 	}
 }
 
 void log_init(void)
 {
-	static int initialised;
 	int options = LOG_PID;
 	time_t t;
 
-	if (initialised) return;
-	initialised = 1;
+	if (log_initialised) return;
+	log_initialised = 1;
 
 	/* this looks pointless, but it is needed in order for the
 	   C library on some systems to fetch the timezone info
 	   before the chroot */
 	t = time(NULL);
 	localtime(&t);
@@ -180,23 +181,23 @@
 
 #ifndef LOG_NDELAY
 	logit(LOG_INFO,"rsyncd started\n");
 #endif
 }
 
-void log_open()
+void log_open(void)
 {
 	if (logfname && !logfile) {
 		extern int orig_umask;
 		int old_umask = umask(022 | orig_umask);
 		logfile = fopen(logfname, "a");
 		umask(old_umask);
 	}
 }
 
-void log_close()
+void log_close(void)
 {
 	if (logfile) {
 		fclose(logfile);
 		logfile = NULL;
 	}
 }
@@ -234,22 +235,26 @@
 	if (am_server && log_error_fd != -1) {
 		err_list_add(code, buf, len);
 		err_list_push();
 		return;
 	}
 
-	/* If that fails, try to pass it to the other end.
-	 *
-	 * io_multiplex_write can fail if we do not have a multiplexed
-	 * connection at the moment, in which case we fall through and
-	 * log locally instead. */
-	if (am_server && io_multiplex_write(code, buf, len)) {
+	/* next, if we are a server but not in daemon mode, and multiplexing
+	 *  is enabled, pass it to the other side.  */
+	if (am_server && !am_daemon && io_multiplex_write(code, buf, len)) {
 		return;
 	}
 
-	if (am_daemon) {
+	/* otherwise, if in daemon mode and either we are not a server
+	 *  (that is, we are not running --daemon over a remote shell) or
+	 *  the log has already been initialised, log the message on this
+	 *  side because we don't want the client to see most errors for
+	 *  security reasons.  We do want early messages when running daemon
+	 *  mode over a remote shell to go to the remote side; those will
+	 *  fall through to the next case. */
+	if (am_daemon && (!am_server || log_initialised)) {
 		static int depth;
 		int priority = LOG_INFO;
 		if (code == FERROR) priority = LOG_WARNING;
 
 		if (depth) return;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/main.c	2002-03-27 13:10:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/main.c	2003-01-28 13:05:53.000000000 +0800
@@ -20,28 +20,53 @@
 */
 
 #include "rsync.h"
 
 time_t starttime = 0;
 
-struct stats stats;
-
+extern struct stats stats;
 extern int verbose;
 
+/* there's probably never more than at most 2 outstanding child processes,
+ * but set it higher just in case.
+ */
+#define MAXCHILDPROCS 5
+
+struct pid_status {
+	pid_t pid;
+	int   status;
+} pid_stat_table[MAXCHILDPROCS];
+
 static void show_malloc_stats(void);
 
 /****************************************************************************
 wait for a process to exit, calling io_flush while waiting
 ****************************************************************************/
 void wait_process(pid_t pid, int *status)
 {
-	while (waitpid(pid, status, WNOHANG) == 0) {
+	pid_t waited_pid;
+	int cnt;
+
+	while ((waited_pid = waitpid(pid, status, WNOHANG)) == 0) {
 		msleep(20);
 		io_flush();
 	}
         
+	if ((waited_pid == -1) && (errno == ECHILD)) {
+		/* status of requested child no longer available.
+		 * check to see if it was processed by the sigchld_handler.
+		 */
+		for (cnt = 0;  cnt < MAXCHILDPROCS; cnt++) {
+			if (pid == pid_stat_table[cnt].pid) {
+				*status = pid_stat_table[cnt].status;
+				pid_stat_table[cnt].pid = 0;
+				break;
+			}
+		}
+	}
+
         /* TODO: If the child exited on a signal, then log an
          * appropriate error message.  Perhaps we should also accept a
          * message describing the purpose of the child.  Also indicate
          * this to the caller so that thhey know something went
          * wrong.  */
 	*status = WEXITSTATUS(*status);
@@ -169,15 +194,17 @@
 static pid_t do_cmd(char *cmd,char *machine,char *user,char *path,int *f_in,int *f_out)
 {
 	char *args[100];
 	int i,argc=0;
 	pid_t ret;
 	char *tok,*dir=NULL;
+	int dash_l_set = 0;
 	extern int local_server;
 	extern char *rsync_path;
 	extern int blocking_io;
+	extern int daemon_over_rsh;
 	extern int read_batch;
 
 	if (!read_batch && !local_server) {
 		if (!cmd)
 			cmd = getenv(RSYNC_RSH_ENV);
 		if (!cmd)
@@ -187,21 +214,28 @@
 			goto oom;
 
 		for (tok=strtok(cmd," ");tok;tok=strtok(NULL," ")) {
 			args[argc++] = tok;
 		}
 
+		/* check to see if we've already been given '-l user' in 
+		   the remote-shell command */
+		for (i = 0; i < argc-1; i++) {
+			if (!strcmp(args[i], "-l") && args[i+1][0] != '-')
+				dash_l_set = 1;
+		}
+
 #if HAVE_REMSH
 		/* remsh (on HPUX) takes the arguments the other way around */
 		args[argc++] = machine;
-		if (user) {
+		if (user && !(daemon_over_rsh && dash_l_set)) {
 			args[argc++] = "-l";
 			args[argc++] = user;
 		}
 #else
-		if (user) {
+		if (user && !(daemon_over_rsh && dash_l_set)) {
 			args[argc++] = "-l";
 			args[argc++] = user;
 		}
 		args[argc++] = machine;
 #endif
 
@@ -213,13 +247,13 @@
 		server_options(args,&argc);
 
 	}
 
 	args[argc++] = ".";
 
-	if (path && *path) 
+	if (!daemon_over_rsh && path && *path) 
 		args[argc++] = path;
 
 	args[argc] = NULL;
 
 	if (verbose > 3) {
 		rprintf(FINFO,"cmd=");
@@ -228,13 +262,13 @@
 		rprintf(FINFO,"\n");
 	}
 
 	if (local_server) {
 		if (read_batch)
 		    create_flist_from_batch(); /* sets batch_flist */
-		ret = local_child(argc, args, f_in, f_out);
+		ret = local_child(argc, args, f_in, f_out, child_main);
 	} else {
 		ret = piped_child(args,f_in,f_out);
 	}
 
 	if (dir) free(dir);
 
@@ -424,12 +458,13 @@
 	if (remote_version >= 24) {
 		/* send a final goodbye message */
 		write_int(f_out, -1);
 	}
 	io_flush();
 
+	io_set_error_fd(-1);
 	kill(pid, SIGUSR2);
 	wait_process(pid, &status);
 	return status;
 }
 
 
@@ -490,12 +525,19 @@
 
 	status = do_recv(f_in,f_out,flist,local_name);
 	exit_cleanup(status);
 }
 
 
+int child_main(int argc, char *argv[])
+{
+	start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
+	return 0;
+}
+
+
 void start_server(int f_in, int f_out, int argc, char *argv[])
 {
 	extern int cvs_exclude;
 	extern int am_sender;
 	extern int remote_version;
 	extern int read_batch;
@@ -658,48 +700,53 @@
 	pid_t pid;
 	int f_in,f_out;
 	extern int local_server;
 	extern int am_sender;
 	extern char *shell_cmd;
 	extern int rsync_port;
-	extern int whole_file;
-	extern int write_batch;
+	extern int daemon_over_rsh;
 	extern int read_batch;
 	int rc;
 
 	/* Don't clobber argv[] so that ps(1) can still show the right
            command line. */
-	if ((rc = copy_argv (argv)))
+	if ((rc = copy_argv(argv)))
 		return rc;
 
+	/* rsync:// always uses rsync server over direct socket connection */
 	if (strncasecmp(URL_PREFIX, argv[0], strlen(URL_PREFIX)) == 0) {
 		char *host, *path;
 
 		host = argv[0] + strlen(URL_PREFIX);
 		p = strchr(host,'/');
 		if (p) {
 			*p = 0;
 			path = p+1;
 		} else {
-			path="";
+			path = "";
 		}
 		p = strchr(host,':');
 		if (p) {
 			rsync_port = atoi(p+1);
 			*p = 0;
 		}
 		return start_socket_client(host, path, argc-1, argv+1);
 	}
 
 	if (!read_batch) {
-	    p = find_colon(argv[0]);
+		p = find_colon(argv[0]);
 
 	if (p) {
 		if (p[1] == ':') { /* double colon */
 			*p = 0;
-			return start_socket_client(argv[0], p+2, argc-1, argv+1);
+			if (!shell_cmd) {
+				return start_socket_client(argv[0], p+2,
+							   argc-1, argv+1);
+			}
+			p++;
+			daemon_over_rsh = 1;
 		}
 
 		if (argc < 1) {
 			usage(FERROR);
 			exit_cleanup(RERR_SYNTAX);
 		}
@@ -710,18 +757,43 @@
 		shell_path = p+1;
 		argc--;
 		argv++;
 	} else {
 		am_sender = 1;
 
+		/* rsync:// destination uses rsync server over direct socket */
+		if (strncasecmp(URL_PREFIX, argv[argc-1], strlen(URL_PREFIX)) == 0) {
+			char *host, *path;
+
+			host = argv[argc-1] + strlen(URL_PREFIX);
+			p = strchr(host,'/');
+			if (p) {
+				*p = 0;
+				path = p+1;
+			} else {
+				path = "";
+			}
+			p = strchr(host,':');
+			if (p) {
+				rsync_port = atoi(p+1);
+				*p = 0;
+			}
+			return start_socket_client(host, path, argc-1, argv);
+		}
+
 		p = find_colon(argv[argc-1]);
 		if (!p) {
 			local_server = 1;
-		} else if (p[1] == ':') {
+		} else if (p[1] == ':') { /* double colon */
 			*p = 0;
-			return start_socket_client(argv[argc-1], p+2, argc-1, argv);
+			if (!shell_cmd) {
+				return start_socket_client(argv[argc-1], p+2,
+							   argc-1, argv);
+			}
+			p++;
+			daemon_over_rsh = 1;
 		}
 
 		if (argc < 2) {
 			usage(FERROR);
 			exit_cleanup(RERR_SYNTAX);
 		}
@@ -766,14 +838,25 @@
 
 	if (argc == 0 && !am_sender) {
 		extern int list_only;
 		list_only = 1;
 	}
 	
-	pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,&f_in,&f_out);
-	
+	pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,
+		     &f_in,&f_out);
+
+	/* if we're running an rsync server on the remote host over a
+	   remote shell command, we need to do the RSYNCD protocol first */
+	if (daemon_over_rsh) {
+		int tmpret;
+		tmpret = start_inband_exchange(shell_user, shell_path,
+					       f_in, f_out, argc);
+		if (tmpret < 0)
+			return tmpret;
+	}
+
 	ret = client_run(f_in, f_out, pid, argc, argv);
 
 	fflush(stdout);
 	fflush(stderr);
 
 	return ret;
@@ -789,13 +872,30 @@
 	if (log_got_error) _exit(RERR_PARTIAL);
 	_exit(0);
 }
 
 static RETSIGTYPE sigchld_handler(int UNUSED(val)) {
 #ifdef WNOHANG
-	while (waitpid(-1, NULL, WNOHANG) > 0) ;
+	int cnt, status;
+	pid_t pid;
+	/* An empty waitpid() loop was put here by Tridge and we could never
+	 * get him to explain why he put it in, so rather than taking it 
+	 * out we're instead saving the child exit statuses for later use.
+	 * The waitpid() loop presumably eliminates all possibility of leaving
+	 * zombie children, maybe that's why he did it.
+	 */
+	while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
+		 /* save the child's exit status */
+		 for (cnt = 0; cnt < MAXCHILDPROCS; cnt++) {
+			  if (pid_stat_table[cnt].pid == 0) {
+				   pid_stat_table[cnt].pid = pid;
+				   pid_stat_table[cnt].status = status;
+				   break;
+			  }
+		 }
+	}
 #endif
 }
 
 
 /**
  * This routine catches signals and tries to send them to gdb.
@@ -808,19 +908,38 @@
  * variable, or just call a script?
  *
  * @todo The /proc/ magic probably only works on Linux (and
  * Solaris?)  Can we be more portable?
  **/
 #ifdef MAINTAINER_MODE
+const char *get_panic_action(void)
+{
+	const char *cmd_fmt = getenv("RSYNC_PANIC_ACTION");
+
+	if (cmd_fmt)
+		return cmd_fmt;
+	else
+		return "xterm -display :0 -T Panic -n Panic "
+			"-e gdb /proc/%d/exe %d";
+}
+
+
+/**
+ * Handle a fatal signal by launching a debugger, controlled by $RSYNC_PANIC_ACTION.
+ *
+ * This signal handler is only installed if we were configured with
+ * --enable-maintainer-mode.  Perhaps it should always be on and we
+ * should just look at the environment variable, but I'm a bit leery
+ * of a signal sending us into a busy loop.
+ **/
 static RETSIGTYPE rsync_panic_handler(int UNUSED(whatsig))
 {
 	char cmd_buf[300];
 	int ret;
-	sprintf(cmd_buf, 
-		"xterm -display :0 -T Panic -n Panic "
-		"-e gdb /proc/%d/exe %d", 
+
+	sprintf(cmd_buf, get_panic_action(),
 		getpid(), getpid());
 
 	/* Unless we failed to execute gdb, we allow the process to
 	 * continue.  I'm not sure if that's right. */
 	ret = system(cmd_buf);
 	if (ret)
@@ -890,15 +1009,14 @@
 	push_dir(NULL,0);
 
 	if (write_batch && !am_server) {
 	    write_batch_argvs_file(orig_argc, orig_argv);
 	}
 
-	if (am_daemon) {
+	if (am_daemon && !am_server)
 		return daemon_main();
-	}
 
 	if (argc < 1) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
@@ -912,12 +1030,14 @@
 	}
 #endif
 
 	if (am_server) {
 		set_nonblocking(STDIN_FILENO);
 		set_nonblocking(STDOUT_FILENO);
+		if (am_daemon)
+			return start_daemon(STDIN_FILENO, STDOUT_FILENO);
 		start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
 	}
 
 	ret = start_client(argc, argv);
 	if (ret == -1) 
 		exit_cleanup(RERR_STARTCLIENT);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/Makefile.in	2002-03-25 12:36:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/Makefile.in	2003-01-21 02:26:14.000000000 +0800
@@ -6,12 +6,14 @@
 bindir=@bindir@
 mandir=@mandir@
 
 LIBS=@LIBS@
 CC=@CC@
 CFLAGS=@CFLAGS@
+CPPFLAGS=@CPPFLAGS@
+EXEEXT=@EXEEXT@
 LDFLAGS=@LDFLAGS@
 
 INSTALLCMD=@INSTALL@
 INSTALLMAN=@INSTALL@
 
 srcdir=@srcdir@
@@ -21,108 +23,121 @@
 VERSION=@VERSION@
 
 .SUFFIXES:
 .SUFFIXES: .c .o
 
 LIBOBJ=lib/fnmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o \
-	lib/permstring.o \
-	@LIBOBJS@
+	lib/permstring.o @LIBOBJS@
 ZLIBOBJ=zlib/deflate.o zlib/infblock.o zlib/infcodes.o zlib/inffast.o \
 	zlib/inflate.o zlib/inftrees.o zlib/infutil.o zlib/trees.o \
-	zlib/zutil.o zlib/adler32.o 
-OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o main.o checksum.o match.o syscall.o log.o backup.o
-OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o fileio.o batch.o \
-	clientname.o
+	zlib/zutil.o zlib/adler32.o
+OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
+	main.o checksum.o match.o syscall.o log.o backup.o
+OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
+	fileio.o batch.o clientname.o
+OBJS3=progress.o pipe.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 	popt/popthelp.o popt/poptparse.o
-OBJS=$(OBJS1) $(OBJS2) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
+OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
 
-TLS_OBJ = tls.o syscall.o lib/permstring.o 
+TLS_OBJ = tls.o syscall.o lib/permstring.o
 
 # Programs we must have to run the test cases
-CHECK_PROGS = rsync tls getgroups trimslash
+CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) \
+	trimslash$(EXEEXT) t_unsafe$(EXEEXT)
+
+# Objects for CHECK_PROGS to clean
+CHECK_OBJS=getgroups.o t_stub.o t_unsafe.o trimslash.o
 
 # note that the -I. is needed to handle config.h when using VPATH
 .c.o:
 @OBJ_SAVE@
-	$(CC) -I. -I$(srcdir) $(CFLAGS) -c $< @CC_SHOBJ_FLAG@
+	$(CC) -I. -I$(srcdir) $(CFLAGS) $(CPPFLAGS) -c $< @CC_SHOBJ_FLAG@
 @OBJ_RESTORE@
 
-all: rsync
+all: rsync$(EXEEXT)
 
 man: rsync.1 rsyncd.conf.5
 
 install: all
 	-mkdir -p ${DESTDIR}${bindir}
-	${INSTALLCMD} ${STRIP} -m 755 rsync ${DESTDIR}${bindir}
+	${INSTALLCMD} ${STRIP} -m 755 rsync$(EXEEXT) ${DESTDIR}${bindir}
 	-mkdir -p ${DESTDIR}${mandir}/man1
 	-mkdir -p ${DESTDIR}${mandir}/man5
 	${INSTALLMAN} -m 644 $(srcdir)/rsync.1 ${DESTDIR}${mandir}/man1
 	${INSTALLMAN} -m 644 $(srcdir)/rsyncd.conf.5 ${DESTDIR}${mandir}/man5
 
 install-strip:
 	$(MAKE) STRIP='-s' install
 
-rsync: $(OBJS)
-	@echo "Please ignore warnings below about mktemp -- it is used in a safe way"
-	$(CC) $(CFLAGS) $(LDFLAGS) -o rsync $(OBJS) $(LIBS)
+rsync$(EXEEXT): $(OBJS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
 
 $(OBJS): config.h
 
-tls: $(TLS_OBJ)
+tls$(EXEEXT): $(TLS_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TLS_OBJ) $(LIBS)
 
-getgroups: getgroups.o
+getgroups$(EXEEXT): getgroups.o
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getgroups.o $(LIBS)
 
 TRIMSLASH_OBJ = trimslash.o syscall.o
-trimslash: $(TRIMSLASH_OBJ)
+trimslash$(EXEEXT): $(TRIMSLASH_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
 
-Makefile: Makefile.in configure config.status
-	echo "WARNING: You need to run ./config.status --recheck"
+T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o t_stub.o lib/compat.o lib/snprintf.o
+t_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(T_UNSAFE_OBJ) $(LIBS)
+
+# I don't like these rules because CVS can skew the timestamps and
+# produce spurious warnings, and also make "make install" fail if the
+# source directory can no longer be found.  Since we don't rebuild
+# automatically they're kind of lame anyhow.
+
+#Makefile: Makefile.in configure config.status
+#	echo "WARNING: You need to run ./config.status --recheck"
 
 # don't actually run autoconf, just issue a warning
-configure: configure.in
-	echo "WARNING: you need to rerun autoconf"
+#configure: configure.in
+#	echo "WARNING: you need to rerun autoconf"
 
-rsync.1: rsync.yo
-	yodl2man -o rsync.1 rsync.yo
+$(srcdir)/rsync.1: $(srcdir)/rsync.yo
+	yodl2man -o $(srcdir)/rsync.1 $(srcdir)/rsync.yo
 
-rsyncd.conf.5: rsyncd.conf.yo
-	yodl2man -o rsyncd.conf.5 rsyncd.conf.yo
+$(srcdir)/rsyncd.conf.5: $(srcdir)/rsyncd.conf.yo
+	yodl2man -o $(srcdir)/rsyncd.conf.5 $(srcdir)/rsyncd.conf.yo
 
 proto:
 	cat $(srcdir)/*.c $(srcdir)/lib/compat.c | awk -f $(srcdir)/mkproto.awk > $(srcdir)/proto.h
 
 clean: cleantests
-	rm -f *~ $(OBJS) rsync $(TLS_OBJ) $(CHECK_PROGS)
+	rm -f *~ $(OBJS) $(TLS_OBJ) $(CHECK_PROGS) $(CHECK_OBJS)
 
 cleantests:
 	rm -rf ./testtmp*
 
 # We try to delete built files from both the source and build
 # directories, just in case somebody previously configured things in
 # the source directory.
 distclean: clean
-	rm -f Makefile config.h config.status 
-	rm -f $(srcdir)/Makefile $(srcdir)/config.h $(srcdir)/config.status 
+	rm -f Makefile config.h config.status
+	rm -f $(srcdir)/Makefile $(srcdir)/config.h $(srcdir)/config.status
 
 	rm -f config.cache config.log
 	rm -f $(srcdir)/config.cache $(srcdir)/config.log
 
 	rm -f shconfig $(srcdir)/shconfig
 
 # this target is really just for my use. It only works on a limited
 # range of machines and is used to produce a list of potentially
 # dead (ie. unused) functions in the code. (tridge)
 finddead:
 	nm *.o */*.o |grep 'U ' | awk '{print $$2}' | sort -u > nmused.txt
 	nm *.o */*.o |grep 'T ' | awk '{print $$3}' | sort -u > nmfns.txt
-	comm -13 nmused.txt nmfns.txt 
+	comm -13 nmused.txt nmfns.txt
 
 # 'check' is the GNU name, 'test' is the name for everybody else :-)
 .PHONY: check test
 
 test: check
 
@@ -138,31 +153,40 @@
 
 # We try to run the scripts with POSIX mode on, in the hope that will
 # catch Bash-isms earlier even if we're running on GNU.  Of course, we
 # might lose in the future where POSIX diverges from old sh.
 
 check: all $(CHECK_PROGS)
-	POSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin=`pwd`/rsync srcdir="$(srcdir)" $(srcdir)/runtests.sh
+	POSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin=`pwd`/rsync$(EXEEXT) srcdir="$(srcdir)" $(srcdir)/runtests.sh
 
 # This does *not* depend on building or installing: you can use it to
 # check a version installed from a binary or some other source tree,
 # if you want.
 
 installcheck: $(CHECK_PROGS)
-	POSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin="$(bindir)/rsync" srcdir="$(srcdir)" $(srcdir)/runtests.sh
+	POSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin="$(bindir)/rsync$(EXEEXT)" srcdir="$(srcdir)" $(srcdir)/runtests.sh
 
 # TODO: Add 'dist' target; need to know which files will be included
 
 # Run the SPLINT (Secure Programming Lint) tool.  <www.splint.org>
 .PHONY: splint
-splint: 
+splint:
 	splint +unixlib +gnuextensions -weak rsync.c
 
 
 rsync.dvi: doc/rsync.texinfo
 	texi2dvi -o $@ $<
 
-rsync.ps: rsync.dvi	
+rsync.ps: rsync.dvi
 	dvips -ta4 -o $@ $<
 
 rsync.pdf: doc/rsync.texinfo
 	texi2dvi -o $@ --pdf $<
+
+
+doxygen:
+	cd $(srcdir) && rm dox/html/* && doxygen
+
+# for maintainers only
+doxygen-upload:
+	rsync -avzv $(srcdir)/dox/html/ --delete \
+	samba.org:/home/httpd/html/rsync/doxygen/head/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/match.c	2002-02-03 09:38:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/match.c	2002-04-09 14:11:06.000000000 +0800
@@ -87,12 +87,24 @@
 }
 
 
 static OFF_T last_match;
 
 
+/**
+ * Transmit a literal and/or match token.
+ *
+ * This delightfully-named function is called either when we find a
+ * match and need to transmit all the unmatched data leading up to it,
+ * or when we get bored of accumulating literal data and just need to
+ * transmit it.  As a result of this second case, it is called even if
+ * we have not matched at all!
+ *
+ * @param i If >0, the number of a matched token.  If 0, indicates we
+ * have only literal data.
+ **/
 static void matched(int f,struct sum_struct *s,struct map_struct *buf,
 		    OFF_T offset,int i)
 {
 	OFF_T n = offset - last_match;
 	OFF_T j;
 
@@ -138,15 +150,18 @@
 
 	/* last_i is used to encourage adjacent matches, allowing the RLL coding of the
 	   output to work more efficiently */
 	last_i = -1;
 
 	if (verbose > 2)
-		rprintf(FINFO,"hash search b=%d len=%.0f\n",s->n,(double)len);
+		rprintf(FINFO,"hash search b=%ld len=%.0f\n",
+			(long) s->n, (double)len);
 
-	k = MIN(len, s->n);
+	/* cast is to make s->n signed; it should always be reasonably
+	 * small */
+	k = MIN(len, (OFF_T) s->n);
 	
 	map = (schar *)map_ptr(buf,0,k);
 	
 	sum = get_checksum1((char *)map, k);
 	s1 = sum & 0xFFFF;
 	s2 = sum >> 16;
@@ -155,14 +170,14 @@
 	
 	offset = 0;
 	
 	end = len + 1 - s->sums[s->count-1].len;
 	
 	if (verbose > 3)
-		rprintf(FINFO,"hash search s->n=%d len=%.0f count=%d\n",
-			s->n,(double)len,s->count);
+		rprintf(FINFO, "hash search s->n=%ld len=%.0f count=%ld\n",
+			(long) s->n, (double) len, (long) s->count);
 	
 	do {
 		tag t = gettag2(s1,s2);
 		int done_csum2 = 0;
 			
 		j = tag_table[t];
@@ -255,13 +270,27 @@
 	
 	matched(f,s,buf,len,-1);
 	map_ptr(buf,len-1,1);
 }
 
 
-void match_sums(int f,struct sum_struct *s,struct map_struct *buf,OFF_T len)
+/**
+ * Scan through a origin file, looking for sections that match
+ * checksums from the generator, and transmit either literal or token
+ * data.
+ *
+ * Also calculates the MD4 checksum of the whole file, using the md
+ * accumulator.  This is transmitted with the file as protection
+ * against corruption on the wire.
+ *
+ * @param s Checksums received from the generator.  If <tt>s->count ==
+ * 0</tt>, then there are actually no checksums for this file.
+ *
+ * @param len Length of the file to send.
+ **/
+void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len)
 {
 	char file_sum[MD4_SUM_LENGTH];
 	extern int write_batch;  /*  dw */
 
 	last_match = 0;
 	false_alarms = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/NEWS	2002-04-02 09:41:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/NEWS	2003-01-28 13:13:16.000000000 +0800
@@ -1,37 +1,91 @@
-rsync 2.5.5 "Snowy River" (2 April 2002)
+NEWS for rsync version 2.5.6, aka the dwd-between-jobs release
+Changes since version 2.5.5:
 
   ENHANCEMENTS:
 
-    * With --progress, when a transfer is complete show the time taken;
-      otherwise show expected time to complete. (Cameron Simpson)
+    * The --delete-after option now implies --delete.  (Wayne Davison)
 
-    * Make "make install-strip" works properly, and "make install"
-      accepts a DESTDIR variable for help in building binary packages.
-      (Peter Breitenlohner, Greg Louis)
-
-    * If configured with --enable-maintainer-mode, then on receipt of
-      a fatal signal rsync will try to open an xterm running gdb,
-      similarly to Samba's "panic action" or GNOME's bug-buddy.
-      (Martin Pool)
+    * The --suffix option can now be used with --backup-dir.  (Michael
+      Zimmerman)
 
+    * Combining "::" syntax with the -rsh/-e option now uses the
+      specified remote-shell as a transport to talk to a (newly-spawned)
+      server-daemon.  This allows someone to use daemon features, such
+      as modules, over a secure protocol, such as ssh.  (JD Paul)
+
+    * The rsync:// syntax for daemon connections is now accepted in the
+      destination field.
+
+    * If the file name given to --include-from or --exclude-from is "-",
+      rsync will read from standard input.  (J.W. Schultz)
+
+    * New option --link-dest which is like --compare-dest except that
+      unchanged files are hard-linked in to the destination directory.
+      (J.W. Schultz)
+
+    * Don't report an error if an excluded file disappears during an
+      rsync run.  (Eugene Chupriyanov and Bo Kersey)
+
+    * Added .svn to --cvs-exclude list to support subversion.  (Jon
+      Middleton)
+
+    * Properly support IPv6 addresses in the rsyncd.conf "hosts allow"
+      and "hosts deny" fields.  (Hideaki Yoshifuji)
+
+    * Changed exclude file handling to permit DOS or MAC style line
+      terminations.  (J.W. Schultz)
+
+    * Ignore errors from chmod when -p/-a/--preserve-perms is not set.
+      (Dave Dykstra)
 
   BUG FIXES:
+  
+    * Fix "forward name lookup failed" errors on AIX 4.3.3.  (John
+      L. Allen, Martin Pool)
+
+    * Generate each file's rolling-checksum data as we send it, not
+      in a separate (memory-eating) pass before hand.  This prevents
+      timeout errors on really large files. (Stefan Nehlsen)
+
+    * Fix compilation on Tru64.  (Albert Chin, Zoong Pham)
+
+    * Better handling of some client-server errors.  (Martin Pool)
+
+    * Fixed a crash that would occur when sending a list of files that
+      contains a duplicate name (if it sorts to the end of the file
+      list) and using --delete.  (Wayne Davison)
+
+    * Fixed the file-name duplicate-removal code when dealing with multiple
+      dups in a row. (Wayne Davison)
+
+    * Fixed a bug that caused rsync to lose the exit status of its child
+      processes and sometimes return an exit code of 0 instead of showing
+      an error.  (David R. Staples, Dave Dykstra)
+
+    * Fixed bug in --copy-unsafe-links that caused it to be completely
+      broken.  (Dave Dykstra)
+
+    * Prevent infinite recursion in cleanup code under certain circumstances.
+      (Sviatoslav Sviridov and Marc Espie)
+
+    * Fixed a bug that prevented rsync from creating intervening directories
+      when --relative-paths/-R is set.  (Craig Barratt)
+
+    * Prevent "Connection reset by peer" messages from Cygwin. (Randy O'Meara)
+
+  INTERNAL:
 
-    * Fix situation where failure to fork (e.g. because out of process
-      slots) would cause rsync to kill all processes owned by the
-      current user.  Yes, really!  (Paul Haas, Martin Pool)
+    * Many code cleanups and improved internal documentation.  (Martin 
+      Pool, Nelson Beebe)
 
-    * Fix test suite on Solaris.  (Jos Backus, Martin Pool)
+    * Portability fixes. (Dave Dykstra and Wayne Davison)
 
-    * Fix minor memory leak in socket code.  (Dave Dykstra, Martin
-      Pool.)
+    * More test cases.  (Martin Pool)
 
-    * Fix --whole-file problem that caused it to be the default even
-      for remote connections.  (Martin Pool, Frank Schulz)
+    * Some test-case fixes.  (Brian Poole, Wayne Davison)
 
-    * Work around bug in Mac OS X mkdir(2), which cannot handle
-      trailing slashes.
-      <http://www.opensource.apple.com/bugs/X/BSD%20Kernel/2734739.html>
-      (Martin Pool)
+    * Updated included popt to the latest vendor drop, version 1.6.4.
+      (Jos Backus)
 
-    * Improved network error handling.  (Greg A. Woods)
+    * Updated config.guess and config.sub to latest versions; this
+      means rsync should build on more platforms.  (Paul Green)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/OLDNEWS	2002-03-14 18:33:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/OLDNEWS	2002-04-03 10:13:43.000000000 +0800
@@ -1,6 +1,45 @@
+rsync 2.5.5 "Snowy River" (2 April 2002)
+
+  ENHANCEMENTS:
+
+    * With --progress, when a transfer is complete show the time taken;
+      otherwise show expected time to complete. (Cameron Simpson)
+
+    * Make "make install-strip" works properly, and "make install"
+      accepts a DESTDIR variable for help in building binary packages.
+      (Peter Breitenlohner, Greg Louis)
+
+    * If configured with --enable-maintainer-mode, then on receipt of
+      a fatal signal rsync will try to open an xterm running gdb,
+      similarly to Samba's "panic action" or GNOME's bug-buddy.
+      (Martin Pool)
+
+
+  BUG FIXES:
+
+    * Fix situation where failure to fork (e.g. because out of process
+      slots) would cause rsync to kill all processes owned by the
+      current user.  Yes, really!  (Paul Haas, Martin Pool)
+
+    * Fix test suite on Solaris.  (Jos Backus, Martin Pool)
+
+    * Fix minor memory leak in socket code.  (Dave Dykstra, Martin
+      Pool.)
+
+    * Fix --whole-file problem that caused it to be the default even
+      for remote connections.  (Martin Pool, Frank Schulz)
+
+    * Work around bug in Mac OS X mkdir(2), which cannot handle
+      trailing slashes.
+      <http://www.opensource.apple.com/bugs/X/BSD%20Kernel/2734739.html>
+      (Martin Pool)
+
+    * Improved network error handling.  (Greg A. Woods)
+
+
 rsync 2.5.4 (13 March 2002)
 
   "Imitation lizard skin"
 
   BUG FIXES:
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/options.c	2002-03-20 04:16:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/options.c	2003-01-28 11:11:57.000000000 +0800
@@ -1,40 +1,39 @@
 /*  -*- c-file-style: "linux" -*-
-    
-    Copyright (C) 1998-2001 by Andrew Tridgell <tridge@samba.org>
-    Copyright (C) 2000, 2001, 2002 by Martin Pool <mbp@samba.org>
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * 
+ * Copyright (C) 1998-2001 by Andrew Tridgell <tridge@samba.org>
+ * Copyright (C) 2000, 2001, 2002 by Martin Pool <mbp@samba.org>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
 #include "rsync.h"
 #include "popt.h"
 
 int make_backups = 0;
 
 /**
- * Should we send the whole file as literal data rather than trying to
- * create an incremental diff?  This is on by default when both source
- * and destination are local and we're not doing a batch delta,
- * because there it's no cheaper to read the whole basis file than to
- * just rewrite it.
+ * If True, send the whole file as literal data rather than trying to
+ * create an incremental diff.
  *
  * If both are 0, then look at whether we're local or remote and go by
  * that.
+ *
+ * @sa disable_deltas_p()
  **/
 int whole_file = 0;
 int no_whole_file = 0;
 
 int copy_links = 0;
 int preserve_links = 0;
@@ -64,13 +63,14 @@
 int io_error = 0;
 int read_only = 0;
 int module_id = -1;
 int am_server = 0;
 int am_sender = 0;
 int recurse = 0;
-int am_daemon=0;
+int am_daemon = 0;
+int daemon_over_rsh = 0;
 int do_stats=0;
 int do_progress=0;
 int keep_partial=0;
 int safe_symlinks=0;
 int copy_unsafe_links=0;
 int block_size=BLOCK_SIZE;
@@ -78,19 +78,16 @@
 int bwlimit=0;
 int delete_after=0;
 int only_existing=0;
 int opt_ignore_existing=0;
 int max_delete=0;
 int ignore_errors=0;
-#ifdef _WIN32
-int modify_window=2;
-#else
 int modify_window=0;
-#endif
 int blocking_io=-1;
 
+
 /** Network address family. **/
 #ifdef INET6
 int default_af_hint = 0;	/* Any protocol */
 #else
 int default_af_hint = AF_INET;	/* Must use IPv4 */
 #endif
@@ -99,23 +96,25 @@
  * for debugging and required for running as a service on W32,
  * or under Unix process-monitors. **/
 int no_detach = 0;
 
 int write_batch = 0;
 int read_batch = 0;
+int suffix_specified = 0;
 
 char *backup_suffix = BACKUP_SUFFIX;
 char *tmpdir = NULL;
 char *compare_dest = NULL;
-char *config_file = RSYNCD_CONF;
+char *config_file = NULL;
 char *shell_cmd = NULL;
 char *log_format = NULL;
 char *password_file = NULL;
 char *rsync_path = RSYNC_PATH;
 char *backup_dir = NULL;
 int rsync_port = RSYNC_PORT;
+int link_dest = 0;
 
 int verbose = 0;
 int quiet = 0;
 int always_checksum = 0;
 int list_only = 0;
 
@@ -167,12 +166,16 @@
 	 * on the complicated interaction between largefile feature
 	 * macros. */
 	rprintf(f, "              %sIPv6, %d-bit system inums, %d-bit internal inums\n",
 		ipv6, 
 		(int) (sizeof(dumstat->st_ino) * 8),
 		(int) (sizeof(INO64_T) * 8));
+#ifdef MAINTAINER_MODE
+	rprintf(f, "              panic action: \"%s\"\n",
+		get_panic_action());
+#endif
 
 #ifdef NO_INT64
         rprintf(f, "WARNING: no 64-bit integers on this platform!\n");
 #endif
 
 	rprintf(f,
@@ -193,20 +196,21 @@
   rprintf(F,"Usage: rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST\n");
   rprintf(F,"  or   rsync [OPTION]... [USER@]HOST:SRC DEST\n");
   rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... DEST\n");
   rprintf(F,"  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]\n");
   rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\n");
   rprintf(F,"  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n");
+  rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\n");
   rprintf(F,"SRC on single-colon remote HOST will be expanded by remote shell\n");
   rprintf(F,"SRC on server remote HOST may contain shell wildcards or multiple\n");
   rprintf(F,"  sources separated by space as long as they have same top-level\n");
   rprintf(F,"\nOptions\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
   rprintf(F," -q, --quiet                 decrease verbosity\n");
   rprintf(F," -c, --checksum              always checksum\n");
-  rprintf(F," -a, --archive               archive mode\n");
+  rprintf(F," -a, --archive               archive mode, equivalent to -rlptgoD\n");
   rprintf(F," -r, --recursive             recurse into directories\n");
   rprintf(F," -R, --relative              use relative path names\n");
   rprintf(F," -b, --backup                make backups (default %s suffix)\n",BACKUP_SUFFIX);
   rprintf(F,"     --backup-dir            make backups into this directory\n");
   rprintf(F,"     --suffix=SUFFIX         override backup suffix\n");  
   rprintf(F," -u, --update                update only (don't overwrite newer files)\n");
@@ -223,13 +227,13 @@
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
   rprintf(F," -n, --dry-run               show what would have been transferred\n");
   rprintf(F," -W, --whole-file            copy whole files, no incremental checks\n");
   rprintf(F,"     --no-whole-file         turn off --whole-file\n");
   rprintf(F," -x, --one-file-system       don't cross filesystem boundaries\n");
   rprintf(F," -B, --block-size=SIZE       checksum blocking size (default %d)\n",BLOCK_SIZE);  
-  rprintf(F," -e, --rsh=COMMAND           specify rsh replacement\n");
+  rprintf(F," -e, --rsh=COMMAND           specify the remote shell\n");
   rprintf(F,"     --rsync-path=PATH       specify path to rsync on the remote machine\n");
   rprintf(F," -C, --cvs-exclude           auto ignore files in the same way CVS does\n");
   rprintf(F,"     --existing              only update files that already exist\n");
   rprintf(F,"     --ignore-existing       ignore files that already exist on the receiving side\n");
   rprintf(F,"     --delete                delete files that don't exist on the sending side\n");
   rprintf(F,"     --delete-excluded       also delete excluded files on the receiving side\n");
@@ -279,33 +283,33 @@
 }
 
 enum {OPT_VERSION = 1000, OPT_SUFFIX, OPT_SENDER, OPT_SERVER, OPT_EXCLUDE,
       OPT_EXCLUDE_FROM, OPT_DELETE, OPT_DELETE_EXCLUDED, OPT_NUMERIC_IDS,
       OPT_RSYNC_PATH, OPT_FORCE, OPT_TIMEOUT, OPT_DAEMON, OPT_CONFIG, OPT_PORT,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_STATS, OPT_PARTIAL, OPT_PROGRESS,
-      OPT_COPY_UNSAFE_LINKS, OPT_SAFE_LINKS, OPT_COMPARE_DEST,
+      OPT_COPY_UNSAFE_LINKS, OPT_SAFE_LINKS, OPT_COMPARE_DEST, OPT_LINK_DEST,
       OPT_LOG_FORMAT, OPT_PASSWORD_FILE, OPT_SIZE_ONLY, OPT_ADDRESS,
       OPT_DELETE_AFTER, OPT_EXISTING, OPT_MAX_DELETE, OPT_BACKUP_DIR, 
       OPT_IGNORE_ERRORS, OPT_BWLIMIT, OPT_BLOCKING_IO,
       OPT_NO_BLOCKING_IO, OPT_WHOLE_FILE, OPT_NO_WHOLE_FILE,
       OPT_MODIFY_WINDOW, OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_IGNORE_EXISTING};
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"version",          0,  POPT_ARG_NONE,   0,             OPT_VERSION, 0, 0},
-  {"suffix",           0,  POPT_ARG_STRING, &backup_suffix,	0, 0, 0 },
+  {"suffix",           0,  POPT_ARG_STRING, &backup_suffix,	OPT_SUFFIX, 0, 0 },
   {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path,	0, 0, 0 },
   {"password-file",    0,  POPT_ARG_STRING, &password_file,	0, 0, 0 },
   {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times , 0, 0, 0 },
   {"size-only",        0,  POPT_ARG_NONE,   &size_only , 0, 0, 0 },
   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
   {"one-file-system", 'x', POPT_ARG_NONE,   &one_file_system , 0, 0, 0 },
   {"delete",           0,  POPT_ARG_NONE,   &delete_mode , 0, 0, 0 },
   {"existing",         0,  POPT_ARG_NONE,   &only_existing , 0, 0, 0 },
   {"ignore-existing",  0,  POPT_ARG_NONE,   &opt_ignore_existing , 0, 0, 0 },
-  {"delete-after",     0,  POPT_ARG_NONE,   &delete_after , 0, 0, 0 },
+  {"delete-after",     0,  POPT_ARG_NONE,   0,              OPT_DELETE_AFTER, 0, 0 },
   {"delete-excluded",  0,  POPT_ARG_NONE,   0,              OPT_DELETE_EXCLUDED, 0, 0 },
   {"force",            0,  POPT_ARG_NONE,   &force_delete , 0, 0, 0 },
   {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids , 0, 0, 0 },
   {"exclude",          0,  POPT_ARG_STRING, 0,              OPT_EXCLUDE, 0, 0 },
   {"include",          0,  POPT_ARG_STRING, 0,              OPT_INCLUDE, 0, 0 },
   {"exclude-from",     0,  POPT_ARG_STRING, 0,              OPT_EXCLUDE_FROM, 0, 0 },
@@ -338,12 +342,13 @@
   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd , 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_INT,    &block_size , 0, 0, 0 },
   {"max-delete",       0,  POPT_ARG_INT,    &max_delete , 0, 0, 0 },
   {"timeout",          0,  POPT_ARG_INT,    &io_timeout , 0, 0, 0 },
   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir , 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, &compare_dest , 0, 0, 0 },
+  {"link-dest",        0,  POPT_ARG_STRING, 0,               OPT_LINK_DEST, 0, 0 },
   /* TODO: Should this take an optional int giving the compression level? */
   {"compress",        'z', POPT_ARG_NONE,   &do_compression , 0, 0, 0 },
   {"daemon",           0,  POPT_ARG_NONE,   &am_daemon , 0, 0, 0 },
   {"no-detach",        0,  POPT_ARG_NONE,   &no_detach , 0, 0, 0 },
   {"stats",            0,  POPT_ARG_NONE,   &do_stats , 0, 0, 0 },
   {"progress",         0,  POPT_ARG_NONE,   &do_progress , 0, 0, 0 },
@@ -369,15 +374,17 @@
 };
 
 
 static char err_buf[100];
 
 
-/* We store the option error message, if any, so that we can log the
-   connection attempt (which requires parsing the options), and then
-   show the error later on. */
+/**
+ * Store the option error message, if any, so that we can log the
+ * connection attempt (which requires parsing the options), and then
+ * show the error later on.
+ **/
 void option_error(void)
 {
 	if (err_buf[0]) {
 		rprintf(FLOG, "%s", err_buf);
 		rprintf(FERROR, "%s: %s", RSYNC_NAME, err_buf);
 	} else {
@@ -385,13 +392,16 @@
 			 "option may be supported on client but not on server?\n");
 		rprintf (FERROR, RSYNC_NAME ": Error parsing options: "
 			 "option may be supported on client but not on server?\n");
 	}
 }
 
-/* check to see if we should refuse this option */
+
+/**
+ * Check to see if we should refuse this option
+ **/
 static int check_refuse_options(char *ref, int opt)
 {
 	int i, len;
 	char *p;
 	const char *name;
 
@@ -425,15 +435,20 @@
                 i++;
         
         return i;
 }
 
 
-/* Process command line arguments.  Called on both local and remote.
- * Returns if all options are OK, otherwise fills in err_buf and
- * returns 0. */
+/**
+ * Process command line arguments.  Called on both local and remote.
+ *
+ * @retval 1 if all options are OK; with globals set to appropriate
+ * values
+ *
+ * @retval 0 on error, with err_buf containing an explanation
+ **/
 int parse_arguments(int *argc, const char ***argv, int frommain)
 {
 	int opt;
 	char *ref = lp_refuse_options(module_id);
         poptContext pc;
 
@@ -453,19 +468,31 @@
 
 		switch (opt) {
 		case OPT_VERSION:
                         print_rsync_version(FINFO);
 			exit_cleanup(0);
 			
+		case OPT_SUFFIX:
+                        /* The value has already been set by popt, but
+                         * we need to remember that a suffix was specified
+                         * in case a backup-directory is used. */
+                        suffix_specified = 1;
+			break;
+			
 		case OPT_MODIFY_WINDOW:
                         /* The value has already been set by popt, but
                          * we need to remember that we're using a
                          * non-default setting. */
 			modify_window_set = 1;
 			break;
-			
+
+		case OPT_DELETE_AFTER:
+			delete_after = 1;
+			delete_mode = 1;
+			break;
+
 		case OPT_DELETE_EXCLUDED:
 			delete_excluded = 1;
 			delete_mode = 1;
 			break;
 
 		case OPT_EXCLUDE:
@@ -559,12 +586,25 @@
 			break;
 
 		case OPT_READ_BATCH:
 			/* popt stores the filename in batch_prefix for us */
 			read_batch = 1;
 			break;
+		case OPT_LINK_DEST:
+#if HAVE_LINK
+			compare_dest = (char *)poptGetOptArg(pc);
+			link_dest = 1;
+			break;
+#else
+			snprintf(err_buf,sizeof(err_buf),
+                                 "hard links are not supported on this %s\n",
+				 am_server ? "server" : "client");
+			rprintf(FERROR,"ERROR: hard links not supported on this platform\n");
+			return 0;
+#endif
+
 
 		default:
                         /* FIXME: If --daemon is specified, then errors for later
                          * parameters seem to disappear. */
                         snprintf(err_buf, sizeof(err_buf),
                                  "%s%s: %s\n",
@@ -598,14 +638,20 @@
                 *argc = 0;
 
 	return 1;
 }
 
 
-/* Construct a filtered list of options to pass through from the
- * client to the server */
+/**
+ * Construct a filtered list of options to pass through from the
+ * client to the server.
+ *
+ * This involves setting options that will tell the server how to
+ * behave, and also filtering out options that are processed only
+ * locally.
+ **/
 void server_options(char **args,int *argc)
 {
 	int ac = *argc;
 	static char argstr[50];
 	static char bsize[30];
 	static char iotime[30];
@@ -619,12 +665,19 @@
 
 	if (blocking_io == -1)
 		blocking_io = 0;
 
 	args[ac++] = "--server";
 
+	if (daemon_over_rsh) {
+		args[ac++] = "--daemon";
+		*argc = ac;
+		/* if we're passing --daemon, we're done */
+		return;
+	}
+
 	if (!am_sender)
 		args[ac++] = "--sender";
 
 	x = 1;
 	argstr[0] = '-';
 	for (i=0;i<verbose;i++)
@@ -782,13 +835,13 @@
 
 	if (compare_dest && am_sender) {
 		/* the server only needs this option if it is not the sender,
 		 *   and it may be an older version that doesn't know this
 		 *   option, so don't send it if client is the sender.
 		 */
-		args[ac++] = "--compare-dest";
+		args[ac++] = link_dest ? "--link-dest" : "--compare-dest";
 		args[ac++] = compare_dest;
 	}
 
 	*argc = ac;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/lsb/rsync.spec	2002-01-03 15:11:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/packaging/lsb/rsync.spec	2003-01-28 13:28:35.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.5.1
+Version: 2.5.6
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.5.1.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.5.6.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/lsb: rsync.spec.tmpl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/redhat/5.0/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/packaging/redhat/5.0/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/redhat/5.0/rsync.spec	2002-01-03 15:11:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/packaging/redhat/5.0/rsync.spec	2003-01-28 13:28:35.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.5.1
+Version: 2.5.6
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.5.1.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.5.6.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/redhat/5.0: rsync.spec.tmpl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/redhat/7.1/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/packaging/redhat/7.1/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/redhat/7.1/rsync.spec	2002-03-26 13:15:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/packaging/redhat/7.1/rsync.spec	2003-01-28 13:28:35.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.5.4
+Version: 2.5.6
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-%{version}.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.5.6.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
@@ -18,15 +18,12 @@
 sets of files are present at one of the ends of the link beforehand.
 
 A technical report describing the rsync algorithm is included with
 this package. 
 
 %changelog
-* Mon Sep 11 2000 John H Terpstra <jht@turbolinux.com>
-  Changed target paths to be Linux Standards Base compliant
-
 * Mon Jan 25 1999 Stefan Hornburg <racke@linuxia.de>
   quoted RPM_OPT_FLAGS for the sake of robustness  
 * Mon May 18 1998 Andrew Tridgell <tridge@samba.anu.edu.au>
   reworked for auto-building when I release rsync (tridge@samba.anu.edu.au)
 
 * Sat May 16 1998 John H Terpstra <jht@aquasoft.com.au>
@@ -59,26 +56,26 @@
 previous package(s).)
 
 %prep
 %setup
 
 %build
-./configure --prefix=/usr --mandir=/usr/share/man
+./configure --prefix=/usr
 make CFLAGS="$RPM_OPT_FLAGS"
 strip rsync
 
 %install
-mkdir -p $RPM_BUILD_ROOT/usr/{bin,share/man/{man1,man5}}
+mkdir -p $RPM_BUILD_ROOT/usr/{bin,man/{man1,man5}}
 install -m755 rsync $RPM_BUILD_ROOT/usr/bin
-install -m644 rsync.1 $RPM_BUILD_ROOT/usr/share/man/man1
-install -m644 rsyncd.conf.5 $RPM_BUILD_ROOT/usr/share/man/man5
+install -m644 rsync.1* $RPM_BUILD_ROOT/usr/man/man1
+install -m644 rsyncd.conf.5* $RPM_BUILD_ROOT/usr/man/man5
 
 %clean
 rm -rf $RPM_BUILD_ROOT
 
 %files
 %attr(-,root,root) /usr/bin/rsync
-%attr(-,root,root) /usr/share/man/man1/rsync.1*
-%attr(-,root,root) /usr/share/man/man5/rsyncd.conf.5*
+%attr(-,root,root) /usr/man/man1/rsync.1*
+%attr(-,root,root) /usr/man/man5/rsyncd.conf.5*
 %attr(-,root,root) %doc tech_report.tex
 %attr(-,root,root) %doc README
 %attr(-,root,root) %doc COPYING
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/packaging/redhat/7.1: rsync.spec.tmpl
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/packaging: solaris
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/params.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/params.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/params.c	1999-02-10 02:35:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/params.c	2003-01-27 04:07:55.000000000 +0800
@@ -161,13 +161,13 @@
    *          indicate that it was not.
    *
    * ------------------------------------------------------------------------ **
    */
   {
   pos--;
-  while( (pos >= 0) && isspace(line[pos]) )
+  while( (pos >= 0) && isspace(((unsigned char *)line)[pos]) )
      pos--;
 
   return( ((pos >= 0) && ('\\' == line[pos])) ? pos : -1 );
   } /* Continuation */
 
 
@@ -383,13 +383,13 @@
       case '\n':              /* Marks end of value unless there's a '\'. */
         i = Continuation( bufr, i );
         if( i < 0 )
           c = 0;
         else
           {
-          for( end = i; (end >= 0) && isspace(bufr[end]); end-- )
+          for( end = i; (end >= 0) && isspace(((unsigned char *) bufr)[end]); end-- )
             ;
           c = getc( InFile );
           }
         break;
 
       default:               /* All others verbatim.  Note that spaces do */
@@ -488,14 +488,14 @@
     return( NULL );
     }
 
   OpenedFile = fopen( FileName, "r" );
   if( NULL == OpenedFile )
     {
-    rprintf(FERROR,"%s Unable to open configuration file \"%s\":\n\t%s\n",
-	    func, FileName, strerror(errno));
+    rprintf(FERROR,"rsync: unable to open configuration file \"%s\": %s\n",
+	    FileName, strerror(errno));
     }
 
   return( OpenedFile );
   } /* OpenConfFile */
 
 BOOL pm_process( char *FileName,
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/patches: craigb-perf.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/patches: db3l_ignore-case.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/patches: gzip-rsyncable.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/patches: jw_rsync3.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/patches: kikuchi_set_rsyncdconf_location.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/patches: marco_soften-links.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/patches: proxy-auth.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/patches: rsync-chmod-v1.patch
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/patches: rusty-fuzzy.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6: pipe.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/CHANGES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/CHANGES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/CHANGES	2001-02-24 09:32:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/CHANGES	2002-07-28 02:32:25.000000000 +0800
@@ -1,7 +1,10 @@
-1.3 ->
+1.5 -> 1.6
+	- add ability to perform callbacks for every, not just first, match.
+
+1.3 -> 1.5
 	- heavy dose of const's
 	- poptParseArgvString() now NULL terminates the list
 
 1.2.3 -> 1.3
 	- added support for single -
 	- misc bug fixes
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt: config.log
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/findme.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/findme.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/findme.c	2001-03-23 11:44:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/findme.c	2002-07-28 02:32:25.000000000 +0800
@@ -1,46 +1,50 @@
-/* (C) 1998 Red Hat Software, Inc. -- Licensing details are in the COPYING
+/** \ingroup popt
+ * \file popt/findme.c
+ */
+
+/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
-   ftp://ftp.redhat.com/pub/code/popt */
+   ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
 #include "findme.h"
 
 const char * findProgramPath(const char * argv0) {
     char * path = getenv("PATH");
     char * pathbuf;
     char * start, * chptr;
-    char * buf, *local = NULL;
+    char * buf;
 
-    /* If there is a / in the argv[0], it has to be an absolute
-       path */
+    if (argv0 == NULL) return NULL;	/* XXX can't happen */
+    /* If there is a / in the argv[0], it has to be an absolute path */
     if (strchr(argv0, '/'))
 	return xstrdup(argv0);
 
-    if (!path) return NULL;
+    if (path == NULL) return NULL;
 
-    local = start = pathbuf = malloc(strlen(path) + 1);
-    buf = malloc(strlen(path) + strlen(argv0) + 2);
+    start = pathbuf = alloca(strlen(path) + 1);
+    buf = malloc(strlen(path) + strlen(argv0) + sizeof("/"));
+    if (buf == NULL) return NULL;	/* XXX can't happen */
     strcpy(pathbuf, path);
 
     chptr = NULL;
+    /*@-branchstate@*/
     do {
 	if ((chptr = strchr(start, ':')))
 	    *chptr = '\0';
 	sprintf(buf, "%s/%s", start, argv0);
 
-	if (!access(buf, X_OK)) {
-		if (local) free(local);
-		return buf;
-	}
+	if (!access(buf, X_OK))
+	    return buf;
 
 	if (chptr) 
 	    start = chptr + 1;
 	else
 	    start = NULL;
     } while (start && *start);
+    /*@=branchstate@*/
 
     free(buf);
-    if (local) free(local);
 
     return NULL;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/findme.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/findme.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/findme.h	2001-02-24 09:32:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/findme.h	2002-07-28 02:32:25.000000000 +0800
@@ -1,10 +1,20 @@
-/* (C) 1998 Red Hat Software, Inc. -- Licensing details are in the COPYING
+/** \ingroup popt
+ * \file popt/findme.h
+ */
+
+/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
-   ftp://ftp.redhat.com/pub/code/popt */
+   ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #ifndef H_FINDME
 #define H_FINDME
 
-const char * findProgramPath(const char * argv0);
+/**
+ * Return absolute path to executable by searching PATH.
+ * @param argv0		name of executable
+ * @return		(malloc'd) absolute path to executable (or NULL)
+ */
+/*@null@*/ const char * findProgramPath(/*@null@*/ const char * argv0)
+	/*@*/;
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/popt.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/popt.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/popt.c	2001-03-23 11:44:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/popt.c	2003-01-19 03:00:07.000000000 +0800
@@ -1,11 +1,23 @@
-/* (C) 1998 Red Hat Software, Inc. -- Licensing details are in the COPYING
+/** \ingroup popt
+ * \file popt/popt.c
+ */
+
+/* (C) 19982000 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from
-   ftp://ftp.redhat.com/pub/code/popt */
+   ftp://ftp.rpm.org/pub/rpm/dist */
+
+#undef	MYDEBUG
 
 #include "system.h"
+
+#if HAVE_FLOAT_H
+#include <float.h>
+#endif
+#include <math.h>
+
 #include "findme.h"
 #include "poptint.h"
 
 #ifndef HAVE_STRERROR
 static char * strerror(int errno) {
     extern int sys_nerr;
@@ -15,53 +27,149 @@
 	return sys_errlist[errno];
     else
 	return POPT_("unknown errno");
 }
 #endif
 
-void poptSetExecPath(poptContext con, const char * path, int allowAbsolute) {
-    if (con->execPath) xfree(con->execPath);
+#ifdef MYDEBUG
+/*@unused@*/ static void prtcon(const char *msg, poptContext con)
+{
+    if (msg) fprintf(stderr, "%s", msg);
+    fprintf(stderr, "\tcon %p os %p nextCharArg \"%s\" nextArg \"%s\" argv[%d] \"%s\"\n",
+	con, con->os,
+	(con->os->nextCharArg ? con->os->nextCharArg : ""),
+	(con->os->nextArg ? con->os->nextArg : ""),
+	con->os->next,
+	(con->os->argv && con->os->argv[con->os->next]
+		? con->os->argv[con->os->next] : ""));
+}
+#endif
+
+void poptSetExecPath(poptContext con, const char * path, int allowAbsolute)
+{
+    con->execPath = _free(con->execPath);
     con->execPath = xstrdup(path);
     con->execAbsolute = allowAbsolute;
+    /*@-nullstate@*/ /* LCL: con->execPath can be NULL? */
+    return;
+    /*@=nullstate@*/
 }
 
-static void invokeCallbacks(poptContext con, const struct poptOption * table,
-			    int post) {
-    const struct poptOption * opt = table;
-    poptCallbackType cb;
+static void invokeCallbacksPRE(poptContext con, const struct poptOption * opt)
+	/*@globals internalState@*/
+	/*@modifies internalState@*/
+{
+    if (opt != NULL)
+    for (; opt->longName || opt->shortName || opt->arg; opt++) {
+	if (opt->arg == NULL) continue;		/* XXX program error. */
+	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
+	    /* Recurse on included sub-tables. */
+	    invokeCallbacksPRE(con, opt->arg);
+	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_CALLBACK &&
+		   (opt->argInfo & POPT_CBFLAG_PRE))
+	{   /*@-castfcnptr@*/
+	    poptCallbackType cb = (poptCallbackType)opt->arg;
+	    /*@=castfcnptr@*/
+	    /* Perform callback. */
+	    /*@-moduncon -noeffectuncon @*/
+	    cb(con, POPT_CALLBACK_REASON_PRE, NULL, NULL, opt->descrip);
+	    /*@=moduncon =noeffectuncon @*/
+	}
+    }
+}
 
-    while (opt->longName || opt->shortName || opt->arg) {
+static void invokeCallbacksPOST(poptContext con, const struct poptOption * opt)
+	/*@globals internalState@*/
+	/*@modifies internalState@*/
+{
+    if (opt != NULL)
+    for (; opt->longName || opt->shortName || opt->arg; opt++) {
+	if (opt->arg == NULL) continue;		/* XXX program error. */
 	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
-	    invokeCallbacks(con, opt->arg, post);
-	} else if (((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_CALLBACK) &&
-		   ((!post && (opt->argInfo & POPT_CBFLAG_PRE)) ||
-		    ( post && (opt->argInfo & POPT_CBFLAG_POST)))) {
-	    cb = (poptCallbackType)opt->arg;
-	    cb(con, post ? POPT_CALLBACK_REASON_POST : POPT_CALLBACK_REASON_PRE,
-	       NULL, NULL, opt->descrip);
+	    /* Recurse on included sub-tables. */
+	    invokeCallbacksPOST(con, opt->arg);
+	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_CALLBACK &&
+		   (opt->argInfo & POPT_CBFLAG_POST))
+	{   /*@-castfcnptr@*/
+	    poptCallbackType cb = (poptCallbackType)opt->arg;
+	    /*@=castfcnptr@*/
+	    /* Perform callback. */
+	    /*@-moduncon -noeffectuncon @*/
+	    cb(con, POPT_CALLBACK_REASON_POST, NULL, NULL, opt->descrip);
+	    /*@=moduncon =noeffectuncon @*/
+	}
+    }
+}
+
+static void invokeCallbacksOPTION(poptContext con,
+				  const struct poptOption * opt,
+				  const struct poptOption * myOpt,
+				  /*@null@*/ const void * myData, int shorty)
+	/*@globals internalState@*/
+	/*@modifies internalState@*/
+{
+    const struct poptOption * cbopt = NULL;
+
+    if (opt != NULL)
+    for (; opt->longName || opt->shortName || opt->arg; opt++) {
+	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
+	    /* Recurse on included sub-tables. */
+	    if (opt->arg != NULL)	/* XXX program error */
+		invokeCallbacksOPTION(con, opt->arg, myOpt, myData, shorty);
+	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_CALLBACK &&
+		  !(opt->argInfo & POPT_CBFLAG_SKIPOPTION)) {
+	    /* Save callback info. */
+	    cbopt = opt;
+	} else if (cbopt != NULL &&
+		   ((myOpt->shortName && opt->shortName && shorty &&
+			myOpt->shortName == opt->shortName) ||
+		    (myOpt->longName && opt->longName &&
+		/*@-nullpass@*/		/* LCL: opt->longName != NULL */
+			!strcmp(myOpt->longName, opt->longName)))
+		/*@=nullpass@*/
+		   )
+	{   /*@-castfcnptr@*/
+	    poptCallbackType cb = (poptCallbackType)cbopt->arg;
+	    /*@=castfcnptr@*/
+	    const void * cbData = (cbopt->descrip ? cbopt->descrip : myData);
+	    /* Perform callback. */
+	    if (cb != NULL) {	/* XXX program error */
+		/*@-moduncon -noeffectuncon @*/
+		cb(con, POPT_CALLBACK_REASON_OPTION, myOpt,
+			con->os->nextArg, cbData);
+		/*@=moduncon =noeffectuncon @*/
+	    }
+	    /* Terminate (unless explcitly continuing). */
+	    if (!(cbopt->argInfo & POPT_CBFLAG_CONTINUE))
+		return;
 	}
-	opt++;
     }
 }
 
 poptContext poptGetContext(const char * name, int argc, const char ** argv,
-			   const struct poptOption * options, int flags) {
+			   const struct poptOption * options, int flags)
+{
     poptContext con = malloc(sizeof(*con));
 
+    if (con == NULL) return NULL;	/* XXX can't happen */
     memset(con, 0, sizeof(*con));
 
     con->os = con->optionStack;
     con->os->argc = argc;
+    /*@-dependenttrans -assignexpose@*/	/* FIX: W2DO? */
     con->os->argv = argv;
+    /*@=dependenttrans =assignexpose@*/
     con->os->argb = NULL;
 
     if (!(flags & POPT_CONTEXT_KEEP_FIRST))
 	con->os->next = 1;			/* skip argv[0] */
 
-    con->leftovers = calloc( (argc + 1), sizeof(char *) );
+    con->leftovers = calloc( (argc + 1), sizeof(*con->leftovers) );
+    /*@-dependenttrans -assignexpose@*/	/* FIX: W2DO? */
     con->options = options;
+    /*@=dependenttrans =assignexpose@*/
     con->aliases = NULL;
     con->numAliases = 0;
     con->flags = flags;
     con->execs = NULL;
     con->numExecs = 0;
     con->finalArgvAlloced = argc * 2;
@@ -69,86 +177,91 @@
     con->execAbsolute = 1;
     con->arg_strip = NULL;
 
     if (getenv("POSIXLY_CORRECT") || getenv("POSIX_ME_HARDER"))
 	con->flags |= POPT_CONTEXT_POSIXMEHARDER;
 
-    if (name)
-	con->appName = strcpy(malloc(strlen(name) + 1), name);
+    if (name) {
+	char * t = malloc(strlen(name) + 1);
+	if (t) con->appName = strcpy(t, name);
+    }
 
-    invokeCallbacks(con, con->options, 0);
+    /*@-internalglobs@*/
+    invokeCallbacksPRE(con, con->options);
+    /*@=internalglobs@*/
 
     return con;
 }
 
-static void cleanOSE(struct optionStackEntry *os)
+static void cleanOSE(/*@special@*/ struct optionStackEntry *os)
+	/*@uses os @*/
+	/*@releases os->nextArg, os->argv, os->argb @*/
+	/*@modifies os @*/
 {
-    if (os->nextArg) {
-	xfree(os->nextArg);
-	os->nextArg = NULL;
-    }
-    if (os->argv) {
-	xfree(os->argv);
-	os->argv = NULL;
-    }
-    if (os->argb) {
-	PBM_FREE(os->argb);
-	os->argb = NULL;
-    }
+    os->nextArg = _free(os->nextArg);
+    os->argv = _free(os->argv);
+    os->argb = PBM_FREE(os->argb);
 }
 
-void poptResetContext(poptContext con) {
+void poptResetContext(poptContext con)
+{
     int i;
 
+    if (con == NULL) return;
     while (con->os > con->optionStack) {
 	cleanOSE(con->os--);
     }
-    if (con->os->argb) {
-	PBM_FREE(con->os->argb);
-	con->os->argb = NULL;
-    }
+    con->os->argb = PBM_FREE(con->os->argb);
     con->os->currAlias = NULL;
     con->os->nextCharArg = NULL;
     con->os->nextArg = NULL;
     con->os->next = 1;			/* skip argv[0] */
 
     con->numLeftovers = 0;
     con->nextLeftover = 0;
     con->restLeftover = 0;
     con->doExec = NULL;
 
-    for (i = 0; i < con->finalArgvCount; i++) {
-	if (con->finalArgv[i]) {
-	    xfree(con->finalArgv[i]);
-	    con->finalArgv[i] = NULL;
-	}
-    }
+    if (con->finalArgv != NULL)
+    for (i = 0; i < con->finalArgvCount; i++)
+	/*@-unqualifiedtrans@*/		/* FIX: typedef double indirection. */
+	con->finalArgv[i] = _free(con->finalArgv[i]);
+	/*@=unqualifiedtrans@*/
 
     con->finalArgvCount = 0;
-
-    if (con->arg_strip) {
-	PBM_FREE(con->arg_strip);
-	con->arg_strip = NULL;
-    }
+    con->arg_strip = PBM_FREE(con->arg_strip);
+    /*@-nullstate@*/	/* FIX: con->finalArgv != NULL */
+    return;
+    /*@=nullstate@*/
 }
 
-/* Only one of longName, shortName may be set at a time */
-static int handleExec(poptContext con, char * longName, char shortName) {
+/* Only one of longName, shortName should be set, not both. */
+static int handleExec(/*@special@*/ poptContext con,
+		/*@null@*/ const char * longName, char shortName)
+	/*@uses con->execs, con->numExecs, con->flags, con->doExec,
+		con->finalArgv, con->finalArgvAlloced, con->finalArgvCount @*/
+	/*@modifies con @*/
+{
+    poptItem item;
     int i;
 
-    i = con->numExecs - 1;
-    if (longName) {
-	while (i >= 0 && (!con->execs[i].longName ||
-	    strcmp(con->execs[i].longName, longName))) i--;
-    } else {
-	while (i >= 0 &&
-	    con->execs[i].shortName != shortName) i--;
-    }
+    if (con->execs == NULL || con->numExecs <= 0) /* XXX can't happen */
+	return 0;
 
+    for (i = con->numExecs - 1; i >= 0; i--) {
+	item = con->execs + i;
+	if (longName && !(item->option.longName &&
+			!strcmp(longName, item->option.longName)))
+	    continue;
+	else if (shortName != item->option.shortName)
+	    continue;
+	break;
+    }
     if (i < 0) return 0;
 
+
     if (con->flags & POPT_CONTEXT_NO_EXEC)
 	return 1;
 
     if (con->doExec == NULL) {
 	con->doExec = con->execs + i;
 	return 1;
@@ -160,44 +273,61 @@
 	con->finalArgvAlloced += 10;
 	con->finalArgv = realloc(con->finalArgv,
 			sizeof(*con->finalArgv) * con->finalArgvAlloced);
     }
 
     i = con->finalArgvCount++;
+    if (con->finalArgv != NULL)	/* XXX can't happen */
     {	char *s  = malloc((longName ? strlen(longName) : 0) + 3);
-	if (longName)
-	    sprintf(s, "--%s", longName);
-	else
-	    sprintf(s, "-%c", shortName);
-	con->finalArgv[i] = s;
+	if (s != NULL) {	/* XXX can't happen */
+	    if (longName)
+		sprintf(s, "--%s", longName);
+	    else
+		sprintf(s, "-%c", shortName);
+	    con->finalArgv[i] = s;
+	} else
+	    con->finalArgv[i] = NULL;
     }
 
+    /*@-nullstate@*/	/* FIX: con->finalArgv[] == NULL */
     return 1;
+    /*@=nullstate@*/
 }
 
 /* Only one of longName, shortName may be set at a time */
-static int handleAlias(poptContext con, const char * longName, char shortName,
-		       /*@keep@*/ const char * nextCharArg) {
+static int handleAlias(/*@special@*/ poptContext con,
+		/*@null@*/ const char * longName, char shortName,
+		/*@keep@*/ /*@null@*/ const char * nextCharArg)
+	/*@uses con->aliases, con->numAliases, con->optionStack, con->os,
+		con->os->currAlias, con->os->currAlias->option.longName @*/
+	/*@modifies con @*/
+{
+    poptItem item = con->os->currAlias;
+    int rc;
     int i;
 
-    if (con->os->currAlias && con->os->currAlias->longName && longName &&
-	!strcmp(con->os->currAlias->longName, longName))
-	return 0;
-    if (con->os->currAlias && shortName &&
-	    shortName == con->os->currAlias->shortName)
+    if (item) {
+	if (longName && (item->option.longName &&
+		!strcmp(longName, item->option.longName)))
+	    return 0;
+	if (shortName && shortName == item->option.shortName)
+	    return 0;
+    }
+
+    if (con->aliases == NULL || con->numAliases <= 0) /* XXX can't happen */
 	return 0;
 
-    i = con->numAliases - 1;
-    if (longName) {
-	while (i >= 0 && (!con->aliases[i].longName ||
-	    strcmp(con->aliases[i].longName, longName))) i--;
-    } else {
-	while (i >= 0 &&
-	    con->aliases[i].shortName != shortName) i--;
+    for (i = con->numAliases - 1; i >= 0; i--) {
+	item = con->aliases + i;
+	if (longName && !(item->option.longName &&
+			!strcmp(longName, item->option.longName)))
+	    continue;
+	else if (shortName != item->option.shortName)
+	    continue;
+	break;
     }
-
     if (i < 0) return 0;
 
     if ((con->os - con->optionStack + 1) == POPT_OPTION_DEPTH)
 	return POPT_ERROR_OPTSTOODEEP;
 
     if (nextCharArg && *nextCharArg)
@@ -206,251 +336,391 @@
     con->os++;
     con->os->next = 0;
     con->os->stuffed = 0;
     con->os->nextArg = NULL;
     con->os->nextCharArg = NULL;
     con->os->currAlias = con->aliases + i;
-    poptDupArgv(con->os->currAlias->argc, con->os->currAlias->argv,
+    rc = poptDupArgv(con->os->currAlias->argc, con->os->currAlias->argv,
 		&con->os->argc, &con->os->argv);
     con->os->argb = NULL;
 
-    return 1;
+    return (rc ? rc : 1);
 }
 
-static void execCommand(poptContext con) {
+static int execCommand(poptContext con)
+    /*@*/
+{
+    poptItem item = con->doExec;
     const char ** argv;
-    int pos = 0;
-    const char * script = con->doExec->script;
+    int argc = 0;
+    int rc;
 
-    argv = malloc(sizeof(*argv) *
-			(6 + con->numLeftovers + con->finalArgvCount));
+    if (item == NULL) /*XXX can't happen*/
+	return POPT_ERROR_NOARG;
 
-    if (!con->execAbsolute && strchr(script, '/')) return;
+    if (item->argv == NULL || item->argc < 1 ||
+	(!con->execAbsolute && strchr(item->argv[0], '/')))
+	    return POPT_ERROR_NOARG;
 
-    if (!strchr(script, '/') && con->execPath) {
-	char *s = malloc(strlen(con->execPath) + strlen(script) + 2);
-	sprintf(s, "%s/%s", con->execPath, script);
-	argv[pos] = s;
+    argv = malloc(sizeof(*argv) *
+			(6 + item->argc + con->numLeftovers + con->finalArgvCount));
+    if (argv == NULL) return POPT_ERROR_MALLOC;	/* XXX can't happen */
+
+    if (!strchr(item->argv[0], '/') && con->execPath) {
+	char *s = alloca(strlen(con->execPath) + strlen(item->argv[0]) + sizeof("/"));
+	sprintf(s, "%s/%s", con->execPath, item->argv[0]);
+	argv[argc] = s;
     } else {
-	argv[pos] = script;
+	argv[argc] = findProgramPath(item->argv[0]);
     }
-    pos++;
+    if (argv[argc++] == NULL) return POPT_ERROR_NOARG;
 
-    argv[pos] = findProgramPath(con->os->argv[0]);
-    if (argv[pos]) pos++;
-    argv[pos++] = ";";
+    if (item->argc > 1) {
+	memcpy(argv + argc, item->argv + 1, sizeof(*argv) * (item->argc - 1));
+	argc += (item->argc - 1);
+    }
 
-    memcpy(argv + pos, con->finalArgv, sizeof(*argv) * con->finalArgvCount);
-    pos += con->finalArgvCount;
+    if (con->finalArgv != NULL && con->finalArgvCount > 0) {
+	memcpy(argv + argc, con->finalArgv,
+		sizeof(*argv) * con->finalArgvCount);
+	argc += con->finalArgvCount;
+    }
 
-    if (con->numLeftovers) {
-	argv[pos++] = "--";
-	memcpy(argv + pos, con->leftovers, sizeof(*argv) * con->numLeftovers);
-	pos += con->numLeftovers;
+    if (con->leftovers != NULL && con->numLeftovers > 0) {
+#if 0
+	argv[argc++] = "--";
+#endif
+	memcpy(argv + argc, con->leftovers, sizeof(*argv) * con->numLeftovers);
+	argc += con->numLeftovers;
     }
 
-    argv[pos++] = NULL;
+    argv[argc] = NULL;
 
 #ifdef __hpux
-    setresuid(getuid(), getuid(),-1);
+    rc = setresuid(getuid(), getuid(),-1);
+    if (rc) return POPT_ERROR_ERRNO;
 #else
 /*
  * XXX " ... on BSD systems setuid() should be preferred over setreuid()"
  * XXX 	sez' Timur Bakeyev <mc@bat.ru>
  * XXX	from Norbert Warmuth <nwarmuth@privat.circular.de>
  */
 #if defined(HAVE_SETUID)
-    setuid(getuid());
+    rc = setuid(getuid());
+    if (rc) return POPT_ERROR_ERRNO;
 #elif defined (HAVE_SETREUID)
-    setreuid(getuid(), getuid()); /*hlauer: not portable to hpux9.01 */
+    rc = setreuid(getuid(), getuid()); /*hlauer: not portable to hpux9.01 */
+    if (rc) return POPT_ERROR_ERRNO;
 #else
     ; /* Can't drop privileges */
 #endif
 #endif
 
-    execvp(argv[0], (char *const *)argv);
+    if (argv[0] == NULL)
+	return POPT_ERROR_NOARG;
+#ifdef MYDEBUG
+    {	const char ** avp;
+	fprintf(stderr, "==> execvp(%s) argv[%d]:", argv[0], argc);
+	for (avp = argv; *avp; avp++)
+	    fprintf(stderr, " '%s'", *avp);
+	fprintf(stderr, "\n");
+    }
+#endif
+
+    rc = execvp(argv[0], (char *const *)argv);
+    return POPT_ERROR_ERRNO;
 }
 
-/*@observer@*/ static const struct poptOption *
-findOption(const struct poptOption * table, const char * longName,
-    char shortName,
-    /*@out@*/ poptCallbackType * callback, /*@out@*/ const void ** callbackData,
-    int singleDash)
+/*@observer@*/ /*@null@*/ static const struct poptOption *
+findOption(const struct poptOption * opt, /*@null@*/ const char * longName,
+		char shortName,
+		/*@null@*/ /*@out@*/ poptCallbackType * callback,
+		/*@null@*/ /*@out@*/ const void ** callbackData,
+		int singleDash)
+	/*@modifies *callback, *callbackData */
 {
-    const struct poptOption * opt = table;
-    const struct poptOption * opt2;
     const struct poptOption * cb = NULL;
 
     /* This happens when a single - is given */
-    if (singleDash && !shortName && !*longName)
+    if (singleDash && !shortName && (longName && *longName == '\0'))
 	shortName = '-';
 
-    while (opt->longName || opt->shortName || opt->arg) {
+    for (; opt->longName || opt->shortName || opt->arg; opt++) {
+
 	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
+	    const struct poptOption * opt2;
+
+	    /* Recurse on included sub-tables. */
+	    if (opt->arg == NULL) continue;	/* XXX program error */
 	    opt2 = findOption(opt->arg, longName, shortName, callback,
 			      callbackData, singleDash);
-	    if (opt2) {
-		if (*callback && !*callbackData)
-		    *callbackData = opt->descrip;
-		return opt2;
-	    }
+	    if (opt2 == NULL) continue;
+	    /* Sub-table data will be inheirited if no data yet. */
+	    if (!(callback && *callback)) return opt2;
+	    if (!(callbackData && *callbackData == NULL)) return opt2;
+	    /*@-observertrans -dependenttrans @*/
+	    *callbackData = opt->descrip;
+	    /*@=observertrans =dependenttrans @*/
+	    return opt2;
 	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_CALLBACK) {
 	    cb = opt;
 	} else if (longName && opt->longName &&
 		   (!singleDash || (opt->argInfo & POPT_ARGFLAG_ONEDASH)) &&
-		   !strcmp(longName, opt->longName)) {
+		/*@-nullpass@*/		/* LCL: opt->longName != NULL */
+		   !strcmp(longName, opt->longName))
+		/*@=nullpass@*/
+	{
 	    break;
 	} else if (shortName && shortName == opt->shortName) {
 	    break;
 	}
-	opt++;
     }
 
-    if (!opt->longName && !opt->shortName) return NULL;
-    *callbackData = NULL;
-    *callback = NULL;
+    if (!opt->longName && !opt->shortName)
+	return NULL;
+    /*@-modobserver -mods @*/
+    if (callback) *callback = NULL;
+    if (callbackData) *callbackData = NULL;
     if (cb) {
-	*callback = (poptCallbackType)cb->arg;
-	if (!(cb->argInfo & POPT_CBFLAG_INC_DATA))
-	    *callbackData = cb->descrip;
+	if (callback)
+	/*@-castfcnptr@*/
+	    *callback = (poptCallbackType)cb->arg;
+	/*@=castfcnptr@*/
+	if (!(cb->argInfo & POPT_CBFLAG_INC_DATA)) {
+	    if (callbackData)
+		/*@-observertrans@*/	/* FIX: typedef double indirection. */
+		*callbackData = cb->descrip;
+		/*@=observertrans@*/
+	}
     }
+    /*@=modobserver =mods @*/
 
     return opt;
 }
 
-static const char *findNextArg(poptContext con, unsigned argx, int delete)
+static const char * findNextArg(/*@special@*/ poptContext con,
+		unsigned argx, int delete_arg)
+	/*@uses con->optionStack, con->os,
+		con->os->next, con->os->argb, con->os->argc, con->os->argv @*/
+	/*@modifies con @*/
 {
     struct optionStackEntry * os = con->os;
     const char * arg;
 
     do {
 	int i;
 	arg = NULL;
 	while (os->next == os->argc && os > con->optionStack) os--;
 	if (os->next == os->argc && os == con->optionStack) break;
+	if (os->argv != NULL)
 	for (i = os->next; i < os->argc; i++) {
-	    if (os->argb && PBM_ISSET(i, os->argb)) continue;
-	    if (*os->argv[i] == '-') continue;
-	    if (--argx > 0) continue;
+	    /*@-sizeoftype@*/
+	    if (os->argb && PBM_ISSET(i, os->argb))
+		/*@innercontinue@*/ continue;
+	    if (*os->argv[i] == '-')
+		/*@innercontinue@*/ continue;
+	    if (--argx > 0)
+		/*@innercontinue@*/ continue;
 	    arg = os->argv[i];
-	    if (delete) {
+	    if (delete_arg) {
 		if (os->argb == NULL) os->argb = PBM_ALLOC(os->argc);
+		if (os->argb != NULL)	/* XXX can't happen */
 		PBM_SET(i, os->argb);
 	    }
-	    break;
+	    /*@innerbreak@*/ break;
+	    /*@=sizeoftype@*/
 	}
 	if (os > con->optionStack) os--;
     } while (arg == NULL);
     return arg;
 }
 
-static /*@only@*/ const char * expandNextArg(poptContext con, const char * s)
+static /*@only@*/ /*@null@*/ const char *
+expandNextArg(/*@special@*/ poptContext con, const char * s)
+	/*@uses con->optionStack, con->os,
+		con->os->next, con->os->argb, con->os->argc, con->os->argv @*/
+	/*@modifies con @*/
 {
-    const char *a;
+    const char * a = NULL;
     size_t alen;
     char *t, *te;
     size_t tn = strlen(s) + 1;
     char c;
 
     te = t = malloc(tn);;
+    if (t == NULL) return NULL;		/* XXX can't happen */
     while ((c = *s++) != '\0') {
 	switch (c) {
 #if 0	/* XXX can't do this */
 	case '\\':	/* escape */
 	    c = *s++;
-	    break;
+	    /*@switchbreak@*/ break;
 #endif
 	case '!':
 	    if (!(s[0] == '#' && s[1] == ':' && s[2] == '+'))
-		break;
-	    if ((a = findNextArg(con, 1, 1)) == NULL)
-		break;
+		/*@switchbreak@*/ break;
+	    /* XXX Make sure that findNextArg deletes only next arg. */
+	    if (a == NULL) {
+		if ((a = findNextArg(con, 1, 1)) == NULL)
+		    /*@switchbreak@*/ break;
+	    }
 	    s += 3;
 
 	    alen = strlen(a);
 	    tn += alen;
 	    *te = '\0';
 	    t = realloc(t, tn);
 	    te = t + strlen(t);
 	    strncpy(te, a, alen); te += alen;
 	    continue;
-	    /*@notreached@*/ break;
+	    /*@notreached@*/ /*@switchbreak@*/ break;
 	default:
-	    break;
+	    /*@switchbreak@*/ break;
 	}
 	*te++ = c;
     }
     *te = '\0';
-    t = realloc(t, strlen(t)+1);	/* XXX memory leak, hard to plug */
+    t = realloc(t, strlen(t) + 1);	/* XXX memory leak, hard to plug */
     return t;
 }
 
-static void poptStripArg(poptContext con, int which)
+static void poptStripArg(/*@special@*/ poptContext con, int which)
+	/*@uses con->arg_strip, con->optionStack @*/
+	/*@defines con->arg_strip @*/
+	/*@modifies con @*/
 {
-    if(con->arg_strip == NULL) {
+    /*@-sizeoftype@*/
+    if (con->arg_strip == NULL)
 	con->arg_strip = PBM_ALLOC(con->optionStack[0].argc);
-    }
+    if (con->arg_strip != NULL)		/* XXX can't happen */
     PBM_SET(which, con->arg_strip);
+    /*@=sizeoftype@*/
+    /*@-compdef@*/ /* LCL: con->arg_strip udefined? */
+    return;
+    /*@=compdef@*/
+}
+
+static int poptSaveLong(const struct poptOption * opt, long aLong)
+	/*@modifies opt->arg @*/
+{
+    if (opt->arg == NULL)
+	return POPT_ERROR_NULLARG;
+
+    if (opt->argInfo & POPT_ARGFLAG_NOT)
+	aLong = ~aLong;
+    switch (opt->argInfo & POPT_ARGFLAG_LOGICALOPS) {
+    case 0:
+	*((long *) opt->arg) = aLong;
+	break;
+    case POPT_ARGFLAG_OR:
+	*((long *) opt->arg) |= aLong;
+	break;
+    case POPT_ARGFLAG_AND:
+	*((long *) opt->arg) &= aLong;
+	break;
+    case POPT_ARGFLAG_XOR:
+	*((long *) opt->arg) ^= aLong;
+	break;
+    default:
+	return POPT_ERROR_BADOPERATION;
+	/*@notreached@*/ break;
+    }
+    return 0;
+}
+
+static int poptSaveInt(const struct poptOption * opt, long aLong)
+	/*@modifies opt->arg @*/
+{
+    if (opt->arg == NULL)
+	return POPT_ERROR_NULLARG;
+
+    if (opt->argInfo & POPT_ARGFLAG_NOT)
+	aLong = ~aLong;
+    switch (opt->argInfo & POPT_ARGFLAG_LOGICALOPS) {
+    case 0:
+	*((int *) opt->arg) = aLong;
+	break;
+    case POPT_ARGFLAG_OR:
+	*((int *) opt->arg) |= aLong;
+	break;
+    case POPT_ARGFLAG_AND:
+	*((int *) opt->arg) &= aLong;
+	break;
+    case POPT_ARGFLAG_XOR:
+	*((int *) opt->arg) ^= aLong;
+	break;
+    default:
+	return POPT_ERROR_BADOPERATION;
+	/*@notreached@*/ break;
+    }
+    return 0;
 }
 
 /* returns 'val' element, -1 on last item, POPT_ERROR_* on error */
 int poptGetNextOpt(poptContext con)
 {
     const struct poptOption * opt = NULL;
     int done = 0;
 
-    /* looks a bit tricky to get rid of alloca properly in this fn */
-#if HAVE_ALLOCA_H
-#define ALLOCA(x) alloca(x)
-#else
-#define ALLOCA(x) malloc(x)
-#endif
-
-
+    if (con == NULL)
+	return -1;
     while (!done) {
 	const char * origOptString = NULL;
 	poptCallbackType cb = NULL;
 	const void * cbData = NULL;
 	const char * longArg = NULL;
 	int canstrip = 0;
+	int shorty = 0;
 
 	while (!con->os->nextCharArg && con->os->next == con->os->argc
 		&& con->os > con->optionStack) {
 	    cleanOSE(con->os--);
 	}
 	if (!con->os->nextCharArg && con->os->next == con->os->argc) {
-	    invokeCallbacks(con, con->options, 1);
-	    if (con->doExec) execCommand(con);
+	    /*@-internalglobs@*/
+	    invokeCallbacksPOST(con, con->options);
+	    /*@=internalglobs@*/
+	    if (con->doExec) return execCommand(con);
 	    return -1;
 	}
 
 	/* Process next long option */
 	if (!con->os->nextCharArg) {
 	    char * localOptString, * optString;
 	    int thisopt;
 
+	    /*@-sizeoftype@*/
 	    if (con->os->argb && PBM_ISSET(con->os->next, con->os->argb)) {
 		con->os->next++;
 		continue;
 	    }
-	    thisopt=con->os->next;
+	    /*@=sizeoftype@*/
+	    thisopt = con->os->next;
+	    if (con->os->argv != NULL)	/* XXX can't happen */
 	    origOptString = con->os->argv[con->os->next++];
 
+	    if (origOptString == NULL)	/* XXX can't happen */
+		return POPT_ERROR_BADOPT;
+
 	    if (con->restLeftover || *origOptString != '-') {
-		con->leftovers[con->numLeftovers++] = origOptString;
 		if (con->flags & POPT_CONTEXT_POSIXMEHARDER)
 		    con->restLeftover = 1;
+		if (con->flags & POPT_CONTEXT_ARG_OPTS) {
+		    con->os->nextArg = xstrdup(origOptString);
+		    return 0;
+		}
+		if (con->leftovers != NULL)	/* XXX can't happen */
+		    con->leftovers[con->numLeftovers++] = origOptString;
 		continue;
 	    }
 
 	    /* Make a copy we can hack at */
 	    localOptString = optString =
-			strcpy(ALLOCA(strlen(origOptString) + 1),
-			origOptString);
+		strcpy(alloca(strlen(origOptString) + 1), origOptString);
 
-	    if (!optString[0])
+	    if (optString[0] == '\0')
 		return POPT_ERROR_BADOPT;
 
 	    if (optString[1] == '-' && !optString[2]) {
 		con->restLeftover = 1;
 		continue;
 	    } else {
@@ -463,18 +733,19 @@
 		else
 		    singleDash = 1;
 
 		/* XXX aliases with arg substitution need "--alias=arg" */
 		if (handleAlias(con, optString, '\0', NULL))
 		    continue;
+
 		if (handleExec(con, optString, '\0'))
 		    continue;
 
 		/* Check for "--long=arg" option. */
 		for (oe = optString; *oe && *oe != '='; oe++)
-		    ;
+		    {};
 		if (*oe == '=') {
 		    *oe++ = '\0';
 		    /* XXX longArg is mapped back to persistent storage. */
 		    longArg = origOptString + (oe - localOptString);
 		}
 
@@ -484,299 +755,455 @@
 		    return POPT_ERROR_BADOPT;
 	    }
 
 	    if (!opt) {
 		con->os->nextCharArg = origOptString + 1;
 	    } else {
-		if(con->os == con->optionStack &&
-		   opt->argInfo & POPT_ARGFLAG_STRIP) {
+		if (con->os == con->optionStack &&
+		   opt->argInfo & POPT_ARGFLAG_STRIP)
+		{
 		    canstrip = 1;
 		    poptStripArg(con, thisopt);
 		}
+		shorty = 0;
 	    }
 	}
 
 	/* Process next short option */
+	/*@-branchstate@*/		/* FIX: W2DO? */
 	if (con->os->nextCharArg) {
 	    origOptString = con->os->nextCharArg;
 
 	    con->os->nextCharArg = NULL;
 
-	    if (handleAlias(con, NULL, *origOptString,
-			    origOptString + 1)) {
+	    if (handleAlias(con, NULL, *origOptString, origOptString + 1))
+		continue;
+
+	    if (handleExec(con, NULL, *origOptString)) {
+		/* Restore rest of short options for further processing */
 		origOptString++;
+		if (*origOptString != '\0')
+		    con->os->nextCharArg = origOptString;
 		continue;
 	    }
-	    if (handleExec(con, NULL, *origOptString))
-		continue;
 
 	    opt = findOption(con->options, NULL, *origOptString, &cb,
 			     &cbData, 0);
 	    if (!opt)
 		return POPT_ERROR_BADOPT;
+	    shorty = 1;
 
 	    origOptString++;
-	    if (*origOptString)
+	    if (*origOptString != '\0')
 		con->os->nextCharArg = origOptString;
 	}
+	/*@=branchstate@*/
 
+	if (opt == NULL) return POPT_ERROR_BADOPT;	/* XXX can't happen */
 	if (opt->arg && (opt->argInfo & POPT_ARG_MASK) == POPT_ARG_NONE) {
-	    *((int *)opt->arg) = 1;
+	    if (poptSaveInt(opt, 1L))
+		return POPT_ERROR_BADOPERATION;
 	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_VAL) {
-	    if (opt->arg)
-		*((int *) opt->arg) = opt->val;
-	} else if ((opt->argInfo & POPT_ARG_MASK) != POPT_ARG_NONE) {
-	    if (con->os->nextArg) {
-		xfree(con->os->nextArg);
-		con->os->nextArg = NULL;
+	    if (opt->arg) {
+		if (poptSaveInt(opt, (long)opt->val))
+		    return POPT_ERROR_BADOPERATION;
 	    }
+	} else if ((opt->argInfo & POPT_ARG_MASK) != POPT_ARG_NONE) {
+	    con->os->nextArg = _free(con->os->nextArg);
+	    /*@-usedef@*/	/* FIX: W2DO? */
 	    if (longArg) {
-		con->os->nextArg = expandNextArg(con, longArg);
+	    /*@=usedef@*/
+		longArg = expandNextArg(con, longArg);
+		con->os->nextArg = longArg;
 	    } else if (con->os->nextCharArg) {
-		con->os->nextArg = expandNextArg(con, con->os->nextCharArg);
+		longArg = expandNextArg(con, con->os->nextCharArg);
+		con->os->nextArg = longArg;
 		con->os->nextCharArg = NULL;
 	    } else {
 		while (con->os->next == con->os->argc &&
 		       con->os > con->optionStack) {
 		    cleanOSE(con->os--);
 		}
-		if (con->os->next == con->os->argc)
-		    return POPT_ERROR_NOARG;
-
-		/* make sure this isn't part of a short arg or the
-                   result of an alias expansion */
-		if(con->os == con->optionStack &&
-		   opt->argInfo & POPT_ARGFLAG_STRIP &&
-		   canstrip) {
-		    poptStripArg(con, con->os->next);
-		}
+		if (con->os->next == con->os->argc) {
+		    if (!(opt->argInfo & POPT_ARGFLAG_OPTIONAL))
+			/*@-compdef@*/	/* FIX: con->os->argv not defined */
+			return POPT_ERROR_NOARG;
+			/*@=compdef@*/
+		    con->os->nextArg = NULL;
+		} else {
+
+		    /*
+		     * Make sure this isn't part of a short arg or the
+		     * result of an alias expansion.
+		     */
+		    if (con->os == con->optionStack &&
+			(opt->argInfo & POPT_ARGFLAG_STRIP) &&
+			canstrip) {
+			poptStripArg(con, con->os->next);
+		    }
 		
-		con->os->nextArg = expandNextArg(con, con->os->argv[con->os->next++]);
+		    if (con->os->argv != NULL) {	/* XXX can't happen */
+			/* XXX watchout: subtle side-effects live here. */
+			longArg = con->os->argv[con->os->next++];
+			longArg = expandNextArg(con, longArg);
+			con->os->nextArg = longArg;
+		    }
+		}
 	    }
+	    longArg = NULL;
 
 	    if (opt->arg) {
-		long aLong;
-		char *end;
-
 		switch (opt->argInfo & POPT_ARG_MASK) {
-		  case POPT_ARG_STRING:
+		case POPT_ARG_STRING:
 		    /* XXX memory leak, hard to plug */
-		    *((const char **) opt->arg) = xstrdup(con->os->nextArg);
-		    break;
-
-		  case POPT_ARG_INT:
-		  case POPT_ARG_LONG:
-		    aLong = strtol(con->os->nextArg, &end, 0);
-		    if (!(end && *end == '\0'))
-			return POPT_ERROR_BADNUMBER;
+		    *((const char **) opt->arg) = (con->os->nextArg)
+			? xstrdup(con->os->nextArg) : NULL;
+		    /*@switchbreak@*/ break;
+
+		case POPT_ARG_INT:
+		case POPT_ARG_LONG:
+		{   long aLong = 0;
+		    char *end;
+
+		    if (con->os->nextArg) {
+			aLong = strtol(con->os->nextArg, &end, 0);
+			if (!(end && *end == '\0'))
+			    return POPT_ERROR_BADNUMBER;
+		    }
 
-		    if (aLong == LONG_MIN || aLong == LONG_MAX)
-			return POPT_ERROR_OVERFLOW;
 		    if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_LONG) {
-			*((long *) opt->arg) = aLong;
+			if (aLong == LONG_MIN || aLong == LONG_MAX)
+			    return POPT_ERROR_OVERFLOW;
+			if (poptSaveLong(opt, aLong))
+			    return POPT_ERROR_BADOPERATION;
 		    } else {
 			if (aLong > INT_MAX || aLong < INT_MIN)
 			    return POPT_ERROR_OVERFLOW;
-			*((int *) opt->arg) = aLong;
+			if (poptSaveInt(opt, aLong))
+			    return POPT_ERROR_BADOPERATION;
 		    }
-		    break;
+		}   /*@switchbreak@*/ break;
 
-		  default:
-		    fprintf(stdout, POPT_("option type (%d) not implemented in popt\n"),
-		      opt->argInfo & POPT_ARG_MASK);
+		case POPT_ARG_FLOAT:
+		case POPT_ARG_DOUBLE:
+		{   double aDouble = 0.0;
+		    char *end;
+
+		    if (con->os->nextArg) {
+			/*@-mods@*/
+			int saveerrno = errno;
+			errno = 0;
+			aDouble = strtod(con->os->nextArg, &end);
+			if (errno == ERANGE)
+			    return POPT_ERROR_OVERFLOW;
+			errno = saveerrno;
+			/*@=mods@*/
+			if (*end != '\0')
+			    return POPT_ERROR_BADNUMBER;
+		    }
+
+		    if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_DOUBLE) {
+			*((double *) opt->arg) = aDouble;
+		    } else {
+#ifndef DBL_EPSILON
+#define DBL_EPSILON 2.2204460492503131e-16
+#endif
+#define _ABS(a)	((((a) - 0.0) < DBL_EPSILON) ? -(a) : (a))
+			if ((_ABS(aDouble) - FLT_MAX) > DBL_EPSILON)
+			    return POPT_ERROR_OVERFLOW;
+			if ((FLT_MIN - _ABS(aDouble)) > DBL_EPSILON)
+			    return POPT_ERROR_OVERFLOW;
+			*((float *) opt->arg) = aDouble;
+		    }
+		}   /*@switchbreak@*/ break;
+		default:
+		    fprintf(stdout,
+			POPT_("option type (%d) not implemented in popt\n"),
+			(opt->argInfo & POPT_ARG_MASK));
 		    exit(EXIT_FAILURE);
+		    /*@notreached@*/ /*@switchbreak@*/ break;
 		}
 	    }
 	}
 
-	if (cb)
-	    cb(con, POPT_CALLBACK_REASON_OPTION, opt, con->os->nextArg, cbData);
-	else if (opt->val && ((opt->argInfo & POPT_ARG_MASK) != POPT_ARG_VAL))
+	if (cb) {
+	    /*@-internalglobs@*/
+	    invokeCallbacksOPTION(con, con->options, opt, cbData, shorty);
+	    /*@=internalglobs@*/
+	} else if (opt->val && ((opt->argInfo & POPT_ARG_MASK) != POPT_ARG_VAL))
 	    done = 1;
 
 	if ((con->finalArgvCount + 2) >= (con->finalArgvAlloced)) {
 	    con->finalArgvAlloced += 10;
 	    con->finalArgv = realloc(con->finalArgv,
 			    sizeof(*con->finalArgv) * con->finalArgvAlloced);
 	}
 
-	{    char *s = malloc((opt->longName ? strlen(opt->longName) : 0) + 3);
-	    if (opt->longName)
-		sprintf(s, "--%s", opt->longName);
-	    else
-		sprintf(s, "-%c", opt->shortName);
-	    con->finalArgv[con->finalArgvCount++] = s;
+	if (con->finalArgv != NULL)
+	{   char *s = malloc((opt->longName ? strlen(opt->longName) : 0) + 3);
+	    if (s != NULL) {	/* XXX can't happen */
+		if (opt->longName)
+		    sprintf(s, "%s%s",
+			((opt->argInfo & POPT_ARGFLAG_ONEDASH) ? "-" : "--"),
+			opt->longName);
+		else
+		    sprintf(s, "-%c", opt->shortName);
+		con->finalArgv[con->finalArgvCount++] = s;
+	    } else
+		con->finalArgv[con->finalArgvCount++] = NULL;
 	}
 
-	if (opt->arg && (opt->argInfo & POPT_ARG_MASK) != POPT_ARG_NONE
-		     && (opt->argInfo & POPT_ARG_MASK) != POPT_ARG_VAL) {
-	    con->finalArgv[con->finalArgvCount++] = xstrdup(con->os->nextArg);
+	if (opt->arg && (opt->argInfo & POPT_ARG_MASK) == POPT_ARG_NONE)
+	    /*@-ifempty@*/ ; /*@=ifempty@*/
+	else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_VAL)
+	    /*@-ifempty@*/ ; /*@=ifempty@*/
+	else if ((opt->argInfo & POPT_ARG_MASK) != POPT_ARG_NONE) {
+	    if (con->finalArgv != NULL && con->os->nextArg)
+	        con->finalArgv[con->finalArgvCount++] =
+			/*@-nullpass@*/	/* LCL: con->os->nextArg != NULL */
+			xstrdup(con->os->nextArg);
+			/*@=nullpass@*/
 	}
     }
 
-    return opt->val;
+    return (opt ? opt->val : -1);	/* XXX can't happen */
 }
 
-const char * poptGetOptArg(poptContext con) {
-    const char * ret = con->os->nextArg;
-    con->os->nextArg = NULL;
+const char * poptGetOptArg(poptContext con)
+{
+    const char * ret = NULL;
+    /*@-branchstate@*/
+    if (con) {
+	ret = con->os->nextArg;
+	con->os->nextArg = NULL;
+    }
+    /*@=branchstate@*/
     return ret;
 }
 
-const char * poptGetArg(poptContext con) {
-    if (con->numLeftovers == con->nextLeftover) return NULL;
-    return con->leftovers[con->nextLeftover++];
+const char * poptGetArg(poptContext con)
+{
+    const char * ret = NULL;
+    if (con && con->leftovers != NULL && con->nextLeftover < con->numLeftovers)
+	ret = con->leftovers[con->nextLeftover++];
+    return ret;
 }
 
-const char * poptPeekArg(poptContext con) {
-    if (con->numLeftovers == con->nextLeftover) return NULL;
-    return con->leftovers[con->nextLeftover];
+const char * poptPeekArg(poptContext con)
+{
+    const char * ret = NULL;
+    if (con && con->leftovers != NULL && con->nextLeftover < con->numLeftovers)
+	ret = con->leftovers[con->nextLeftover];
+    return ret;
 }
 
-const char ** poptGetArgs(poptContext con) {
-    if (con->numLeftovers == con->nextLeftover) return NULL;
+const char ** poptGetArgs(poptContext con)
+{
+    if (con == NULL ||
+	con->leftovers == NULL || con->numLeftovers == con->nextLeftover)
+	return NULL;
 
     /* some apps like [like RPM ;-) ] need this NULL terminated */
     con->leftovers[con->numLeftovers] = NULL;
 
+    /*@-nullret -nullstate @*/	/* FIX: typedef double indirection. */
     return (con->leftovers + con->nextLeftover);
+    /*@=nullret =nullstate @*/
 }
 
-void poptFreeContext(poptContext con) {
+poptContext poptFreeContext(poptContext con)
+{
+    poptItem item;
     int i;
 
+    if (con == NULL) return con;
     poptResetContext(con);
-    if (con->os->argb) free(con->os->argb);
+    con->os->argb = _free(con->os->argb);
 
+    if (con->aliases != NULL)
     for (i = 0; i < con->numAliases; i++) {
-	if (con->aliases[i].longName) xfree(con->aliases[i].longName);
-	free(con->aliases[i].argv);
+	item = con->aliases + i;
+	/*@-modobserver -observertrans -dependenttrans@*/
+	item->option.longName = _free(item->option.longName);
+	item->option.descrip = _free(item->option.descrip);
+	item->option.argDescrip = _free(item->option.argDescrip);
+	/*@=modobserver =observertrans =dependenttrans@*/
+	item->argv = _free(item->argv);
     }
+    con->aliases = _free(con->aliases);
 
+    if (con->execs != NULL)
     for (i = 0; i < con->numExecs; i++) {
-	if (con->execs[i].longName) xfree(con->execs[i].longName);
-	xfree(con->execs[i].script);
-    }
-    if (con->execs) xfree(con->execs);
-
-    free(con->leftovers);
-    free(con->finalArgv);
-    if (con->appName) xfree(con->appName);
-    if (con->aliases) free(con->aliases);
-    if (con->otherHelp) xfree(con->otherHelp);
-    if (con->execPath) xfree(con->execPath);
-    if (con->arg_strip) PBM_FREE(con->arg_strip);
+	item = con->execs + i;
+	/*@-modobserver -observertrans -dependenttrans@*/
+	item->option.longName = _free(item->option.longName);
+	item->option.descrip = _free(item->option.descrip);
+	item->option.argDescrip = _free(item->option.argDescrip);
+	/*@=modobserver =observertrans =dependenttrans@*/
+	item->argv = _free(item->argv);
+    }
+    con->execs = _free(con->execs);
+
+    con->leftovers = _free(con->leftovers);
+    con->finalArgv = _free(con->finalArgv);
+    con->appName = _free(con->appName);
+    con->otherHelp = _free(con->otherHelp);
+    con->execPath = _free(con->execPath);
+    con->arg_strip = PBM_FREE(con->arg_strip);
     
-    free(con);
+    con = _free(con);
+    return con;
 }
 
-int poptAddAlias(poptContext con, struct poptAlias newAlias,
+int poptAddAlias(poptContext con, struct poptAlias alias,
 		/*@unused@*/ int flags)
 {
-    int aliasNum = con->numAliases++;
-    struct poptAlias * alias;
+    poptItem item = (poptItem) alloca(sizeof(*item));
+    memset(item, 0, sizeof(*item));
+    item->option.longName = alias.longName;
+    item->option.shortName = alias.shortName;
+    item->option.argInfo = POPT_ARGFLAG_DOC_HIDDEN;
+    item->option.arg = 0;
+    item->option.val = 0;
+    item->option.descrip = NULL;
+    item->option.argDescrip = NULL;
+    item->argc = alias.argc;
+    item->argv = alias.argv;
+    return poptAddItem(con, item, 0);
+}
 
-    /* SunOS won't realloc(NULL, ...) */
-    if (!con->aliases)
-	con->aliases = malloc(sizeof(newAlias) * con->numAliases);
-    else
-	con->aliases = realloc(con->aliases,
-			       sizeof(newAlias) * con->numAliases);
-    alias = con->aliases + aliasNum;
-
-    alias->longName = (newAlias.longName)
-	? strcpy(malloc(strlen(newAlias.longName) + 1), newAlias.longName)
-	: NULL;
-    alias->shortName = newAlias.shortName;
-    alias->argc = newAlias.argc;
-    alias->argv = newAlias.argv;
+/*@-mustmod@*/ /* LCL: con not modified? */
+int poptAddItem(poptContext con, poptItem newItem, int flags)
+{
+    poptItem * items, item;
+    int * nitems;
+
+    switch (flags) {
+    case 1:
+	items = &con->execs;
+	nitems = &con->numExecs;
+	break;
+    case 0:
+	items = &con->aliases;
+	nitems = &con->numAliases;
+	break;
+    default:
+	return 1;
+	/*@notreached@*/ break;
+    }
+
+    *items = realloc((*items), ((*nitems) + 1) * sizeof(**items));
+    if ((*items) == NULL)
+	return 1;
+
+    item = (*items) + (*nitems);
+
+    item->option.longName =
+	(newItem->option.longName ? xstrdup(newItem->option.longName) : NULL);
+    item->option.shortName = newItem->option.shortName;
+    item->option.argInfo = newItem->option.argInfo;
+    item->option.arg = newItem->option.arg;
+    item->option.val = newItem->option.val;
+    item->option.descrip =
+	(newItem->option.descrip ? xstrdup(newItem->option.descrip) : NULL);
+    item->option.argDescrip =
+       (newItem->option.argDescrip ? xstrdup(newItem->option.argDescrip) : NULL);
+    item->argc = newItem->argc;
+    item->argv = newItem->argv;
+
+    (*nitems)++;
 
     return 0;
 }
+/*@=mustmod@*/
 
-const char * poptBadOption(poptContext con, int flags) {
-    struct optionStackEntry * os;
+const char * poptBadOption(poptContext con, int flags)
+{
+    struct optionStackEntry * os = NULL;
 
-    if (flags & POPT_BADOPTION_NOALIAS)
-	os = con->optionStack;
-    else
-	os = con->os;
+    if (con != NULL)
+	os = (flags & POPT_BADOPTION_NOALIAS) ? con->optionStack : con->os;
 
-    return os->argv[os->next - 1];
+    /*@-nullderef@*/	/* LCL: os->argv != NULL */
+    return (os && os->argv ? os->argv[os->next - 1] : NULL);
+    /*@=nullderef@*/
 }
 
-#define POPT_ERROR_NOARG	-10
-#define POPT_ERROR_BADOPT	-11
-#define POPT_ERROR_OPTSTOODEEP	-13
-#define POPT_ERROR_BADQUOTE	-15	/* only from poptParseArgString() */
-#define POPT_ERROR_ERRNO	-16	/* only from poptParseArgString() */
-
-const char *const poptStrerror(const int error) {
+const char *const poptStrerror(const int error)
+{
     switch (error) {
       case POPT_ERROR_NOARG:
 	return POPT_("missing argument");
       case POPT_ERROR_BADOPT:
 	return POPT_("unknown option");
+      case POPT_ERROR_BADOPERATION:
+	return POPT_("mutually exclusive logical operations requested");
+      case POPT_ERROR_NULLARG:
+	return POPT_("opt->arg should not be NULL");
       case POPT_ERROR_OPTSTOODEEP:
 	return POPT_("aliases nested too deeply");
       case POPT_ERROR_BADQUOTE:
-	return POPT_("error in paramter quoting");
+	return POPT_("error in parameter quoting");
       case POPT_ERROR_BADNUMBER:
 	return POPT_("invalid numeric value");
       case POPT_ERROR_OVERFLOW:
 	return POPT_("number too large or too small");
+      case POPT_ERROR_MALLOC:
+	return POPT_("memory allocation failed");
       case POPT_ERROR_ERRNO:
 	return strerror(errno);
       default:
 	return POPT_("unknown error");
     }
 }
 
-int poptStuffArgs(poptContext con, const char ** argv) {
+int poptStuffArgs(poptContext con, const char ** argv)
+{
     int argc;
+    int rc;
 
     if ((con->os - con->optionStack) == POPT_OPTION_DEPTH)
 	return POPT_ERROR_OPTSTOODEEP;
 
     for (argc = 0; argv[argc]; argc++)
-	;
+	{};
 
     con->os++;
     con->os->next = 0;
     con->os->nextArg = NULL;
     con->os->nextCharArg = NULL;
     con->os->currAlias = NULL;
-    poptDupArgv(argc, argv, &con->os->argc, &con->os->argv);
+    rc = poptDupArgv(argc, argv, &con->os->argc, &con->os->argv);
     con->os->argb = NULL;
     con->os->stuffed = 1;
 
-    return 0;
+    return rc;
 }
 
-const char * poptGetInvocationName(poptContext con) {
-    return con->os->argv[0];
+const char * poptGetInvocationName(poptContext con)
+{
+    return (con->os->argv ? con->os->argv[0] : "");
 }
 
-int poptStrippedArgv(poptContext con, int argc, char **argv)
+int poptStrippedArgv(poptContext con, int argc, char ** argv)
 {
-    int i,j=1, numargs=argc;
+    int numargs = argc;
+    int j = 1;
+    int i;
     
-    for(i=1; i<argc; i++) {
-	if(PBM_ISSET(i, con->arg_strip)) {
+    /*@-sizeoftype@*/
+    if (con->arg_strip)
+    for (i = 1; i < argc; i++) {
+	if (PBM_ISSET(i, con->arg_strip))
 	    numargs--;
-	}
     }
     
-    for(i=1; i<argc; i++) {
-	if(PBM_ISSET(i, con->arg_strip)) {
+    for (i = 1; i < argc; i++) {
+	if (con->arg_strip && PBM_ISSET(i, con->arg_strip))
 	    continue;
-	} else {
-	    if(j<numargs) {
-		argv[j++]=argv[i];
-	    } else {
-		argv[j++]='\0';
-	    }
-	}
+	argv[j] = (j < numargs) ? argv[i] : NULL;
+	j++;
     }
+    /*@=sizeoftype@*/
     
-    return(numargs);
+    return numargs;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/poptconfig.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/poptconfig.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/poptconfig.c	2001-03-23 11:44:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/poptconfig.c	2003-01-12 03:01:31.000000000 +0800
@@ -1,142 +1,183 @@
-/* (C) 1998 Red Hat Software, Inc. -- Licensing details are in the COPYING
+/** \ingroup popt
+ * \file popt/poptconfig.c
+ */
+
+/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
-   ftp://ftp.redhat.com/pub/code/popt */
+   ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
 #include "poptint.h"
 
-static void configLine(poptContext con, char * line) {
+/*@-compmempass@*/	/* FIX: item->option.longName kept, not dependent. */
+static void configLine(poptContext con, char * line)
+	/*@modifies con @*/
+{
+    /*@-type@*/
     int nameLength = strlen(con->appName);
-    char * opt;
-    struct poptAlias alias;
-    char * entryType;
-    char * longName = NULL;
-    char shortName = '\0';
+    /*@=type@*/
+    const char * entryType;
+    const char * opt;
+    poptItem item = (poptItem) alloca(sizeof(*item));
+    int i, j;
     
+    memset(item, 0, sizeof(*item));
+
+    /*@-type@*/
     if (strncmp(line, con->appName, nameLength)) return;
+    /*@=type@*/
+
     line += nameLength;
-    if (!*line || !isspace(*line)) return;
-    while (*line && isspace(*line)) line++;
-    entryType = line;
+    if (*line == '\0' || !isspace(*line)) return;
 
-    while (!*line || !isspace(*line)) line++;
+    while (*line != '\0' && isspace(*line)) line++;
+    entryType = line;
+    while (*line == '\0' || !isspace(*line)) line++;
     *line++ = '\0';
-    while (*line && isspace(*line)) line++;
-    if (!*line) return;
-    opt = line;
 
-    while (!*line || !isspace(*line)) line++;
+    while (*line != '\0' && isspace(*line)) line++;
+    if (*line == '\0') return;
+    opt = line;
+    while (*line == '\0' || !isspace(*line)) line++;
     *line++ = '\0';
-    while (*line && isspace(*line)) line++;
-    if (!*line) return;
 
-    if (opt[0] == '-' && opt[1] == '-')
-	longName = opt + 2;
-    else if (opt[0] == '-' && !opt[2])
-	shortName = opt[1];
-
-    if (!strcmp(entryType, "alias")) {
-	if (poptParseArgvString(line, &alias.argc, &alias.argv)) return;
-	alias.longName = longName, alias.shortName = shortName;
-	poptAddAlias(con, alias, 0);
-    } else if (!strcmp(entryType, "exec")) {
-	con->execs = realloc(con->execs,
-				sizeof(*con->execs) * (con->numExecs + 1));
-	if (longName)
-	    con->execs[con->numExecs].longName = xstrdup(longName);
-	else
-	    con->execs[con->numExecs].longName = NULL;
+    while (*line != '\0' && isspace(*line)) line++;
+    if (*line == '\0') return;
 
-	con->execs[con->numExecs].shortName = shortName;
-	con->execs[con->numExecs].script = xstrdup(line);
-	
-	con->numExecs++;
+    /*@-temptrans@*/ /* FIX: line alias is saved */
+    if (opt[0] == '-' && opt[1] == '-')
+	item->option.longName = opt + 2;
+    else if (opt[0] == '-' && opt[2] == '\0')
+	item->option.shortName = opt[1];
+    /*@=temptrans@*/
+
+    if (poptParseArgvString(line, &item->argc, &item->argv)) return;
+
+    /*@-modobserver@*/
+    item->option.argInfo = POPT_ARGFLAG_DOC_HIDDEN;
+    for (i = 0, j = 0; i < item->argc; i++, j++) {
+	const char * f;
+	if (!strncmp(item->argv[i], "--POPTdesc=", sizeof("--POPTdesc=")-1)) {
+	    f = item->argv[i] + sizeof("--POPTdesc=");
+	    if (f[0] == '$' && f[1] == '"') f++;
+	    item->option.descrip = f;
+	    item->option.argInfo &= ~POPT_ARGFLAG_DOC_HIDDEN;
+	    j--;
+	} else
+	if (!strncmp(item->argv[i], "--POPTargs=", sizeof("--POPTargs=")-1)) {
+	    f = item->argv[i] + sizeof("--POPTargs=");
+	    if (f[0] == '$' && f[1] == '"') f++;
+	    item->option.argDescrip = f;
+	    item->option.argInfo &= ~POPT_ARGFLAG_DOC_HIDDEN;
+	    item->option.argInfo |= POPT_ARG_STRING;
+	    j--;
+	} else
+	if (j != i)
+	    item->argv[j] = item->argv[i];
+    }
+    if (j != i) {
+	item->argv[j] = NULL;
+	item->argc = j;
     }
+    /*@=modobserver@*/
+	
+    /*@-nullstate@*/ /* FIX: item->argv[] may be NULL */
+    if (!strcmp(entryType, "alias"))
+	(void) poptAddItem(con, item, 0);
+    else if (!strcmp(entryType, "exec"))
+	(void) poptAddItem(con, item, 1);
+    /*@=nullstate@*/
 }
+/*@=compmempass@*/
 
-int poptReadConfigFile(poptContext con, const char * fn) {
-    char * file=NULL, * chptr, * end;
-    char * buf=NULL, * dst;
+int poptReadConfigFile(poptContext con, const char * fn)
+{
+    const char * file, * chptr, * end;
+    char * buf;
+/*@dependent@*/ char * dst;
     int fd, rc;
-    int fileLength;
+    off_t fileLength;
 
     fd = open(fn, O_RDONLY);
-    if (fd < 0) {
-	if (errno == ENOENT)
-	    return 0;
-	else 
-	    return POPT_ERROR_ERRNO;
-    }
+    if (fd < 0)
+	return (errno == ENOENT ? 0 : POPT_ERROR_ERRNO);
 
     fileLength = lseek(fd, 0, SEEK_END);
-    (void) lseek(fd, 0, 0);
+    if (fileLength == -1 || lseek(fd, 0, 0) == -1) {
+	rc = errno;
+	(void) close(fd);
+	/*@-mods@*/
+	errno = rc;
+	/*@=mods@*/
+	return POPT_ERROR_ERRNO;
+    }
 
-    file = malloc(fileLength + 1);
-    if (read(fd, file, fileLength) != fileLength) {
+    file = alloca(fileLength + 1);
+    if (read(fd, (char *)file, fileLength) != fileLength) {
 	rc = errno;
-	close(fd);
+	(void) close(fd);
+	/*@-mods@*/
 	errno = rc;
-	if (file) free(file);
+	/*@=mods@*/
 	return POPT_ERROR_ERRNO;
     }
-    close(fd);
+    if (close(fd) == -1)
+	return POPT_ERROR_ERRNO;
 
-    dst = buf = malloc(fileLength + 1);
+    dst = buf = alloca(fileLength + 1);
 
     chptr = file;
     end = (file + fileLength);
+    /*@-infloops@*/	/* LCL: can't detect chptr++ */
     while (chptr < end) {
 	switch (*chptr) {
 	  case '\n':
 	    *dst = '\0';
 	    dst = buf;
 	    while (*dst && isspace(*dst)) dst++;
-	    if (*dst && *dst != '#') {
+	    if (*dst && *dst != '#')
 		configLine(con, dst);
-	    }
 	    chptr++;
-	    break;
+	    /*@switchbreak@*/ break;
 	  case '\\':
 	    *dst++ = *chptr++;
 	    if (chptr < end) {
 		if (*chptr == '\n') 
 		    dst--, chptr++;	
 		    /* \ at the end of a line does not insert a \n */
 		else
 		    *dst++ = *chptr++;
 	    }
-	    break;
+	    /*@switchbreak@*/ break;
 	  default:
 	    *dst++ = *chptr++;
-	    break;
+	    /*@switchbreak@*/ break;
 	}
     }
-
-    free(file);
-    free(buf);
+    /*@=infloops@*/
 
     return 0;
 }
 
 int poptReadDefaultConfig(poptContext con, /*@unused@*/ int useEnv) {
     char * fn, * home;
     int rc;
 
+    /*@-type@*/
     if (!con->appName) return 0;
+    /*@=type@*/
 
     rc = poptReadConfigFile(con, "/etc/popt");
     if (rc) return rc;
     if (getuid() != geteuid()) return 0;
 
     if ((home = getenv("HOME"))) {
-	fn = malloc(strlen(home) + 20);
+	fn = alloca(strlen(home) + 20);
 	strcpy(fn, home);
 	strcat(fn, "/.popt");
 	rc = poptReadConfigFile(con, fn);
-	free(fn);
 	if (rc) return rc;
     }
 
     return 0;
 }
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/popt.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/popt.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/popt.h	2001-02-24 09:32:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/popt.h	2002-07-28 02:32:25.000000000 +0800
@@ -1,130 +1,446 @@
-/* (C) 1998 Red Hat Software, Inc. -- Licensing details are in the COPYING
+/** \file popt/popt.h
+ * \ingroup popt
+ */
+
+/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
-   ftp://ftp.redhat.com/pub/code/popt */
+   ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #ifndef H_POPT
 #define H_POPT
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 #include <stdio.h>			/* for FILE * */
 
 #define POPT_OPTION_DEPTH	10
 
-#define POPT_ARG_NONE		0
-#define POPT_ARG_STRING		1
-#define POPT_ARG_INT		2
-#define POPT_ARG_LONG		3
-#define POPT_ARG_INCLUDE_TABLE	4	/* arg points to table */
-#define POPT_ARG_CALLBACK	5	/* table-wide callback... must be
+/** \ingroup popt
+ * \name Arg type identifiers
+ */
+/*@{*/
+#define POPT_ARG_NONE		0	/*!< no arg */
+#define POPT_ARG_STRING		1	/*!< arg will be saved as string */
+#define POPT_ARG_INT		2	/*!< arg will be converted to int */
+#define POPT_ARG_LONG		3	/*!< arg will be converted to long */
+#define POPT_ARG_INCLUDE_TABLE	4	/*!< arg points to table */
+#define POPT_ARG_CALLBACK	5	/*!< table-wide callback... must be
 					   set first in table; arg points 
 					   to callback, descrip points to 
 					   callback data to pass */
-#define POPT_ARG_INTL_DOMAIN    6       /* set the translation domain
+#define POPT_ARG_INTL_DOMAIN    6       /*!< set the translation domain
 					   for this table and any
 					   included tables; arg points
 					   to the domain string */
-#define POPT_ARG_VAL		7	/* arg should take value val */
+#define POPT_ARG_VAL		7	/*!< arg should take value val */
+#define	POPT_ARG_FLOAT		8	/*!< arg will be converted to float */
+#define	POPT_ARG_DOUBLE		9	/*!< arg will be converted to double */
+
 #define POPT_ARG_MASK		0x0000FFFF
-#define POPT_ARGFLAG_ONEDASH	0x80000000  /* allow -longoption */
-#define POPT_ARGFLAG_DOC_HIDDEN 0x40000000  /* don't show in help/usage */
-#define POPT_ARGFLAG_STRIP	0x20000000  /* strip this arg from argv (only applies to long args) */
-#define POPT_CBFLAG_PRE		0x80000000  /* call the callback before parse */
-#define POPT_CBFLAG_POST	0x40000000  /* call the callback after parse */
-#define POPT_CBFLAG_INC_DATA	0x20000000  /* use data from the include line,
-					       not the subtable */
+/*@}*/
 
-#define POPT_ERROR_NOARG	-10
-#define POPT_ERROR_BADOPT	-11
-#define POPT_ERROR_OPTSTOODEEP	-13
-#define POPT_ERROR_BADQUOTE	-15	/* only from poptParseArgString() */
-#define POPT_ERROR_ERRNO	-16	/* only from poptParseArgString() */
-#define POPT_ERROR_BADNUMBER	-17
-#define POPT_ERROR_OVERFLOW	-18
-
-/* poptBadOption() flags */
-#define POPT_BADOPTION_NOALIAS  (1 << 0)  /* don't go into an alias */
-
-/* poptGetContext() flags */
-#define POPT_CONTEXT_NO_EXEC	(1 << 0)  /* ignore exec expansions */
-#define POPT_CONTEXT_KEEP_FIRST	(1 << 1)  /* pay attention to argv[0] */
-#define POPT_CONTEXT_POSIXMEHARDER (1 << 2) /* options can't follow args */
+/** \ingroup popt
+ * \name Arg modifiers
+ */
+/*@{*/
+#define POPT_ARGFLAG_ONEDASH	0x80000000  /*!< allow -longoption */
+#define POPT_ARGFLAG_DOC_HIDDEN 0x40000000  /*!< don't show in help/usage */
+#define POPT_ARGFLAG_STRIP	0x20000000  /*!< strip this arg from argv(only applies to long args) */
+#define	POPT_ARGFLAG_OPTIONAL	0x10000000  /*!< arg may be missing */
+
+#define	POPT_ARGFLAG_OR		0x08000000  /*!< arg will be or'ed */
+#define	POPT_ARGFLAG_NOR	0x09000000  /*!< arg will be nor'ed */
+#define	POPT_ARGFLAG_AND	0x04000000  /*!< arg will be and'ed */
+#define	POPT_ARGFLAG_NAND	0x05000000  /*!< arg will be nand'ed */
+#define	POPT_ARGFLAG_XOR	0x02000000  /*!< arg will be xor'ed */
+#define	POPT_ARGFLAG_NOT	0x01000000  /*!< arg will be negated */
+#define POPT_ARGFLAG_LOGICALOPS \
+        (POPT_ARGFLAG_OR|POPT_ARGFLAG_AND|POPT_ARGFLAG_XOR)
+
+#define	POPT_BIT_SET	(POPT_ARG_VAL|POPT_ARGFLAG_OR)
+					/*!< set arg bit(s) */
+#define	POPT_BIT_CLR	(POPT_ARG_VAL|POPT_ARGFLAG_NAND)
+					/*!< clear arg bit(s) */
+
+#define	POPT_ARGFLAG_SHOW_DEFAULT 0x00800000 /*!< show default value in --help */
+
+/*@}*/
+
+/** \ingroup popt
+ * \name Callback modifiers
+ */
+/*@{*/
+#define POPT_CBFLAG_PRE		0x80000000  /*!< call the callback before parse */
+#define POPT_CBFLAG_POST	0x40000000  /*!< call the callback after parse */
+#define POPT_CBFLAG_INC_DATA	0x20000000  /*!< use data from the include line,
+					       not the subtable */
+#define POPT_CBFLAG_SKIPOPTION	0x10000000  /*!< don't callback with option */
+#define POPT_CBFLAG_CONTINUE	0x08000000  /*!< continue callbacks with option */
+/*@}*/
+
+/** \ingroup popt
+ * \name Error return values
+ */
+/*@{*/
+#define POPT_ERROR_NOARG	-10	/*!< missing argument */
+#define POPT_ERROR_BADOPT	-11	/*!< unknown option */
+#define POPT_ERROR_OPTSTOODEEP	-13	/*!< aliases nested too deeply */
+#define POPT_ERROR_BADQUOTE	-15	/*!< error in paramter quoting */
+#define POPT_ERROR_ERRNO	-16	/*!< errno set, use strerror(errno) */
+#define POPT_ERROR_BADNUMBER	-17	/*!< invalid numeric value */
+#define POPT_ERROR_OVERFLOW	-18	/*!< number too large or too small */
+#define	POPT_ERROR_BADOPERATION	-19	/*!< mutually exclusive logical operations requested */
+#define	POPT_ERROR_NULLARG	-20	/*!< opt->arg should not be NULL */
+#define	POPT_ERROR_MALLOC	-21	/*!< memory allocation failed */
+/*@}*/
+
+/** \ingroup popt
+ * \name poptBadOption() flags
+ */
+/*@{*/
+#define POPT_BADOPTION_NOALIAS  (1 << 0)  /*!< don't go into an alias */
+/*@}*/
+
+/** \ingroup popt
+ * \name poptGetContext() flags
+ */
+/*@{*/
+#define POPT_CONTEXT_NO_EXEC	(1 << 0)  /*!< ignore exec expansions */
+#define POPT_CONTEXT_KEEP_FIRST	(1 << 1)  /*!< pay attention to argv[0] */
+#define POPT_CONTEXT_POSIXMEHARDER (1 << 2) /*!< options can't follow args */
+#define POPT_CONTEXT_ARG_OPTS	(1 << 4) /*!< return args as options with value 0 */
+/*@}*/
 
+/** \ingroup popt
+ */
 struct poptOption {
-    /*@observer@*/ /*@null@*/ const char * longName;	/* may be NULL */
-    char shortName;		/* may be '\0' */
+/*@observer@*/ /*@null@*/ const char * longName; /*!< may be NULL */
+    char shortName;			/*!< may be '\0' */
     int argInfo;
-    /*@shared@*/ /*@null@*/ void * arg;		/* depends on argInfo */
-    int val;			/* 0 means don't return, just update flag */
-    /*@shared@*/ /*@null@*/ const char * descrip;	/* description for autohelp -- may be NULL */
-    /*@shared@*/ /*@null@*/ const char * argDescrip;	/* argument description for autohelp */
+/*@shared@*/ /*@null@*/ void * arg;	/*!< depends on argInfo */
+    int val;			/*!< 0 means don't return, just update flag */
+/*@observer@*/ /*@null@*/ const char * descrip;	/*!< description for autohelp -- may be NULL */
+/*@observer@*/ /*@null@*/ const char * argDescrip; /*!< argument description for autohelp */
 };
 
+/** \ingroup popt
+ * A popt alias argument for poptAddAlias().
+ */
 struct poptAlias {
-    /*@owned@*/ /*@null@*/ const char * longName;	/* may be NULL */
-    char shortName;		/* may be '\0' */
+/*@owned@*/ /*@null@*/ const char * longName;	/*!< may be NULL */
+    char shortName;		/*!< may be '\0' */
     int argc;
-    /*@owned@*/ const char ** argv;		/* must be free()able */
+/*@owned@*/ const char ** argv;	/*!< must be free()able */
 };
 
+/** \ingroup popt
+ * A popt alias or exec argument for poptAddItem().
+ */
+typedef struct poptItem_s {
+    struct poptOption option;	/*!< alias/exec name(s) and description. */
+    int argc;			/*!< (alias) no. of args. */
+/*@owned@*/ const char ** argv;	/*!< (alias) args, must be free()able. */
+} * poptItem;
+
+/** \ingroup popt
+ * \name Auto-generated help/usage
+ */
+/*@{*/
+
+/**
+ * Empty table marker to enable displaying popt alias/exec options.
+ */
+/*@observer@*/ /*@checked@*/
+extern struct poptOption poptAliasOptions[];
+#define POPT_AUTOALIAS { NULL, '\0', POPT_ARG_INCLUDE_TABLE, poptAliasOptions, \
+			0, "Options implemented via popt alias/exec:", NULL },
+
+/**
+ * Auto help table options.
+ */
+/*@observer@*/ /*@checked@*/
 extern struct poptOption poptHelpOptions[];
 #define POPT_AUTOHELP { NULL, '\0', POPT_ARG_INCLUDE_TABLE, poptHelpOptions, \
-			0, "Help options", NULL },
+			0, "Help options:", NULL },
 
-typedef struct poptContext_s * poptContext;
+#define POPT_TABLEEND { NULL, '\0', 0, 0, 0, NULL, NULL }
+/*@}*/
+
+/** \ingroup popt
+ */
+typedef /*@abstract@*/ struct poptContext_s * poptContext;
+
+/** \ingroup popt
+ */
 #ifndef __cplusplus
+/*@-typeuse@*/
 typedef struct poptOption * poptOption;
+/*@=typeuse@*/
 #endif
 
 enum poptCallbackReason { POPT_CALLBACK_REASON_PRE, 
 			  POPT_CALLBACK_REASON_POST,
 			  POPT_CALLBACK_REASON_OPTION };
-typedef void (*poptCallbackType)(poptContext con, 
-				 enum poptCallbackReason reason,
-			         const struct poptOption * opt,
-				 const char * arg, const void * data);
-
-/*@only@*/ poptContext poptGetContext(/*@keep@*/ const char * name,
-		int argc, /*@keep@*/ const char ** argv,
-		/*@keep@*/ const struct poptOption * options, int flags);
-void poptResetContext(poptContext con);
-
-/* returns 'val' element, -1 on last item, POPT_ERROR_* on error */
-int poptGetNextOpt(poptContext con);
-/* returns NULL if no argument is available */
-/*@observer@*/ /*@null@*/ const char * poptGetOptArg(poptContext con);
-/* returns NULL if no more options are available */
-/*@observer@*/ /*@null@*/ const char * poptGetArg(poptContext con);
-/*@observer@*/ /*@null@*/ const char * poptPeekArg(poptContext con);
-/*@observer@*/ /*@null@*/ const char ** poptGetArgs(poptContext con);
-/* returns the option which caused the most recent error */
-/*@observer@*/ const char * poptBadOption(poptContext con, int flags);
-void poptFreeContext( /*@only@*/ poptContext con);
-int poptStuffArgs(poptContext con, /*@keep@*/ const char ** argv);
-int poptAddAlias(poptContext con, struct poptAlias alias, int flags);
-int poptReadConfigFile(poptContext con, const char * fn);
-/* like above, but reads /etc/popt and $HOME/.popt along with environment 
-   vars */
-int poptReadDefaultConfig(poptContext con, int useEnv);
-/* argv should be freed -- this allows ', ", and \ quoting, but ' is treated
-   the same as " and both may include \ quotes */
-int poptDupArgv(int argc, const char **argv,
-		/*@out@*/ int * argcPtr, /*@out@*/ const char *** argvPtr);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+/*@-type@*/
+
+/** \ingroup popt
+ * Table callback prototype.
+ * @param con		context
+ * @param reason	reason for callback
+ * @param opt		option that triggered callback
+ * @param arg		@todo Document.
+ * @param data		@todo Document.
+ */
+typedef void (*poptCallbackType) (poptContext con, 
+		enum poptCallbackReason reason,
+		/*@null@*/ const struct poptOption * opt,
+		/*@null@*/ const char * arg,
+		/*@null@*/ const void * data)
+	/*@*/;
+
+/** \ingroup popt
+ * Initialize popt context.
+ * @param name
+ * @param argc		no. of arguments
+ * @param argv		argument array
+ * @param options	address of popt option table
+ * @param flags		or'd POPT_CONTEXT_* bits
+ * @return		initialized popt context
+ */
+/*@only@*/ /*@null@*/ poptContext poptGetContext(
+		/*@dependent@*/ /*@keep@*/ const char * name,
+		int argc, /*@dependent@*/ /*@keep@*/ const char ** argv,
+		/*@dependent@*/ /*@keep@*/ const struct poptOption * options,
+		int flags)
+	/*@*/;
+
+/** \ingroup popt
+ * Reinitialize popt context.
+ * @param con		context
+ */
+void poptResetContext(/*@null@*/poptContext con)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Return value of next option found.
+ * @param con		context
+ * @return		next option val, -1 on last item, POPT_ERROR_* on error
+ */
+int poptGetNextOpt(/*@null@*/poptContext con)
+	/*@globals fileSystem@*/
+	/*@modifies con, fileSystem @*/;
+
+/*@-redecl@*/
+/** \ingroup popt
+ * Return next option argument (if any).
+ * @param con		context
+ * @return		option argument, NULL if no more options are available
+ */
+/*@observer@*/ /*@null@*/ const char * poptGetOptArg(/*@null@*/poptContext con)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Return current option's argument.
+ * @param con		context
+ * @return		option argument, NULL if no more options are available
+ */
+/*@observer@*/ /*@null@*/ const char * poptGetArg(/*@null@*/poptContext con)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Peek at current option's argument.
+ * @param con		context
+ * @return		option argument
+ */
+/*@observer@*/ /*@null@*/ const char * poptPeekArg(/*@null@*/poptContext con)
+	/*@*/;
+
+/** \ingroup popt
+ * Return remaining arguments.
+ * @param con		context
+ * @return		argument array, terminated with NULL
+ */
+/*@observer@*/ /*@null@*/ const char ** poptGetArgs(/*@null@*/poptContext con)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Return the option which caused the most recent error.
+ * @param con		context
+ * @return		offending option
+ */
+/*@observer@*/ const char * poptBadOption(/*@null@*/poptContext con, int flags)
+	/*@*/;
+/*@=redecl@*/
+
+/** \ingroup popt
+ * Destroy context.
+ * @param con		context
+ * @return		NULL always
+ */
+/*@null@*/ poptContext poptFreeContext( /*@only@*/ /*@null@*/ poptContext con)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Add arguments to context.
+ * @param con		context
+ * @param argv		argument array, NULL terminated
+ * @return		0 on success, POPT_ERROR_OPTSTOODEEP on failure
+ */
+int poptStuffArgs(poptContext con, /*@keep@*/ const char ** argv)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Add alias to context.
+ * @todo Pass alias by reference, not value.
+ * @deprecated Use poptAddItem instead.
+ * @param con		context
+ * @param alias		alias to add
+ * @param flags		(unused)
+ * @return		0 on success
+ */
+/*@unused@*/
+int poptAddAlias(poptContext con, struct poptAlias alias, int flags)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Add alias/exec item to context.
+ * @param con		context
+ * @param item		alias/exec item to add
+ * @param flags		0 for alias, 1 for exec
+ * @return		0 on success
+ */
+int poptAddItem(poptContext con, poptItem newItem, int flags)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Read configuration file.
+ * @param con		context
+ * @param fn		file name to read
+ * @return		0 on success, POPT_ERROR_ERRNO on failure
+ */
+int poptReadConfigFile(poptContext con, const char * fn)
+	/*@globals fileSystem@*/
+	/*@modifies fileSystem,
+		con->execs, con->numExecs @*/;
+
+/** \ingroup popt
+ * Read default configuration from /etc/popt and $HOME/.popt.
+ * @param con		context
+ * @param useEnv	(unused)
+ * @return		0 on success, POPT_ERROR_ERRNO on failure
+ */
+int poptReadDefaultConfig(poptContext con, /*@unused@*/ int useEnv)
+	/*@globals fileSystem@*/
+	/*@modifies fileSystem,
+		con->execs, con->numExecs @*/;
+
+/** \ingroup popt
+ * Duplicate an argument array.
+ * @note: The argument array is malloc'd as a single area, so only argv must
+ * be free'd.
+ *
+ * @param argc		no. of arguments
+ * @param argv		argument array
+ * @retval argcPtr	address of returned no. of arguments
+ * @retval argvPtr	address of returned argument array
+ * @return		0 on success, POPT_ERROR_NOARG on failure
+ */
+int poptDupArgv(int argc, /*@null@*/ const char **argv,
+		/*@null@*/ /*@out@*/ int * argcPtr,
+		/*@null@*/ /*@out@*/ const char *** argvPtr)
+	/*@modifies *argcPtr, *argvPtr @*/;
+
+/** \ingroup popt
+ * Parse a string into an argument array.
+ * The parse allows ', ", and \ quoting, but ' is treated the same as " and
+ * both may include \ quotes.
+ * @note: The argument array is malloc'd as a single area, so only argv must
+ * be free'd.
+ *
+ * @param s		string to parse
+ * @retval argcPtr	address of returned no. of arguments
+ * @retval argvPtr	address of returned argument array
+ */
 int poptParseArgvString(const char * s,
-		/*@out@*/ int * argcPtr, /*@out@*/ const char *** argvPtr);
-/*@observer@*/ const char *const poptStrerror(const int error);
-void poptSetExecPath(poptContext con, const char * path, int allowAbsolute);
-void poptPrintHelp(poptContext con, FILE * f, int flags);
-void poptPrintUsage(poptContext con, FILE * f, int flags);
-void poptSetOtherOptionHelp(poptContext con, const char * text);
-/*@observer@*/ const char * poptGetInvocationName(poptContext con);
-/* shuffles argv pointers to remove stripped args, returns new argc */
-int poptStrippedArgv(poptContext con, int argc, char **argv);
+		/*@out@*/ int * argcPtr, /*@out@*/ const char *** argvPtr)
+	/*@modifies *argcPtr, *argvPtr @*/;
+
+/** \ingroup popt
+ * Return formatted error string for popt failure.
+ * @param error		popt error
+ * @return		error string
+ */
+/*@-redecl@*/
+/*@observer@*/ const char *const poptStrerror(const int error)
+	/*@*/;
+/*@=redecl@*/
+
+/** \ingroup popt
+ * Limit search for executables.
+ * @param con		context
+ * @param path		single path to search for executables
+ * @param allowAbsolute	absolute paths only?
+ */
+void poptSetExecPath(poptContext con, const char * path, int allowAbsolute)
+	/*@modifies con @*/;
+
+/** \ingroup popt
+ * Print detailed description of options.
+ * @param con		context
+ * @param fp		ouput file handle
+ * @param flags		(unused)
+ */
+void poptPrintHelp(poptContext con, FILE * fp, /*@unused@*/ int flags)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/;
+
+/** \ingroup popt
+ * Print terse description of options.
+ * @param con		context
+ * @param fp		ouput file handle
+ * @param flags		(unused)
+ */
+void poptPrintUsage(poptContext con, FILE * fp, /*@unused@*/ int flags)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/;
+
+/** \ingroup popt
+ * Provide text to replace default "[OPTION...]" in help/usage output.
+ * @param con		context
+ * @param text		replacement text
+ */
+/*@-fcnuse@*/
+void poptSetOtherOptionHelp(poptContext con, const char * text)
+	/*@modifies con @*/;
+/*@=fcnuse@*/
+
+/** \ingroup popt
+ * Return argv[0] from context.
+ * @param con		context
+ * @return		argv[0]
+ */
+/*@-redecl -fcnuse@*/
+/*@observer@*/ const char * poptGetInvocationName(poptContext con)
+	/*@*/;
+/*@=redecl =fcnuse@*/
+
+/** \ingroup popt
+ * Shuffle argv pointers to remove stripped args, returns new argc.
+ * @param con		context
+ * @param argc		no. of args
+ * @param argv		arg vector
+ * @return		new argc
+ */
+/*@-fcnuse@*/
+int poptStrippedArgv(poptContext con, int argc, char ** argv)
+	/*@modifies *argv @*/;
+/*@=fcnuse@*/
 
+/*@=type@*/
 #ifdef  __cplusplus
 }
 #endif
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/popthelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/popthelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/popthelp.c	2001-02-24 09:32:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/popthelp.c	2003-01-15 05:37:08.000000000 +0800
@@ -1,301 +1,661 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 
-/* (C) 1998 Red Hat Software, Inc. -- Licensing details are in the COPYING
+/*@-type@*/
+/** \ingroup popt
+ * \file popt/popthelp.c
+ */
+
+/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
-   ftp://ftp.redhat.com/pub/code/popt */
+   ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
 #include "poptint.h"
 
+/**
+ * @param con		context
+ * @param key		option(s)
+ */
 static void displayArgs(poptContext con,
 		/*@unused@*/ enum poptCallbackReason foo,
 		struct poptOption * key, 
-		/*@unused@*/ const char * arg, /*@unused@*/ void * data) {
-    if (key->shortName== '?')
+		/*@unused@*/ const char * arg, /*@unused@*/ void * data)
+	/*@globals fileSystem@*/
+	/*@modifies fileSystem@*/
+{
+    if (key->shortName == '?')
 	poptPrintHelp(con, stdout, 0);
     else
 	poptPrintUsage(con, stdout, 0);
     exit(0);
 }
 
+#ifdef	NOTYET
+/*@unchecked@*/
+static int show_option_defaults = 0;
+#endif
+
+/**
+ * Empty table marker to enable displaying popt alias/exec options.
+ */
+/*@observer@*/ /*@unchecked@*/
+struct poptOption poptAliasOptions[] = {
+    POPT_TABLEEND
+};
+
+/**
+ * Auto help table options.
+ */
+/*@-castfcnptr@*/
+/*@observer@*/ /*@unchecked@*/
 struct poptOption poptHelpOptions[] = {
-    { NULL, '\0', POPT_ARG_CALLBACK, (void *)&displayArgs, '\0', NULL, NULL },
-    { "help", '?', 0, NULL, '?', N_("Show this help message"), NULL },
-    { "usage", '\0', 0, NULL, 'u', N_("Display brief usage message"), NULL },
-    { NULL, '\0', 0, NULL, 0, NULL, NULL }
+  { NULL, '\0', POPT_ARG_CALLBACK, (void *)&displayArgs, '\0', NULL, NULL },
+  { "help", '?', 0, NULL, '?', N_("Show this help message"), NULL },
+  { "usage", '\0', 0, NULL, 'u', N_("Display brief usage message"), NULL },
+#ifdef	NOTYET
+  { "defaults", '\0', POPT_ARG_NONE, &show_option_defaults, 0,
+	N_("Display option defaults in message"), NULL },
+#endif
+    POPT_TABLEEND
 } ;
+/*@=castfcnptr@*/
 
-
+/**
+ * @param table		option(s)
+ */
 /*@observer@*/ /*@null@*/ static const char *const
-getTableTranslationDomain(const struct poptOption *table)
+getTableTranslationDomain(/*@null@*/ const struct poptOption *table)
+	/*@*/
 {
-  const struct poptOption *opt;
-
-  for(opt = table;
-      opt->longName || opt->shortName || opt->arg;
-      opt++) {
-    if(opt->argInfo == POPT_ARG_INTL_DOMAIN)
-      return opt->arg;
-  }
+    const struct poptOption *opt;
 
-  return NULL;
+    if (table != NULL)
+    for (opt = table; opt->longName || opt->shortName || opt->arg; opt++) {
+	if (opt->argInfo == POPT_ARG_INTL_DOMAIN)
+	    return opt->arg;
+    }
+    return NULL;
 }
 
+/**
+ * @param opt		option(s)
+ * @param translation_domain	translation domain
+ */
 /*@observer@*/ /*@null@*/ static const char *const
-getArgDescrip(const struct poptOption * opt, const char *translation_domain)
+getArgDescrip(const struct poptOption * opt,
+		/*@-paramuse@*/		/* FIX: wazzup? */
+		/*@null@*/ const char * translation_domain)
+		/*@=paramuse@*/
+	/*@*/
 {
     if (!(opt->argInfo & POPT_ARG_MASK)) return NULL;
 
     if (opt == (poptHelpOptions + 1) || opt == (poptHelpOptions + 2))
 	if (opt->argDescrip) return POPT_(opt->argDescrip);
 
     if (opt->argDescrip) return D_(translation_domain, opt->argDescrip);
-    return POPT_("ARG");
+
+    switch (opt->argInfo & POPT_ARG_MASK) {
+    case POPT_ARG_NONE:		return POPT_("NONE");
+    case POPT_ARG_VAL:		return POPT_("VAL");
+    case POPT_ARG_INT:		return POPT_("INT");
+    case POPT_ARG_LONG:		return POPT_("LONG");
+    case POPT_ARG_STRING:	return POPT_("STRING");
+    case POPT_ARG_FLOAT:	return POPT_("FLOAT");
+    case POPT_ARG_DOUBLE:	return POPT_("DOUBLE");
+    default:			return POPT_("ARG");
+    }
 }
 
-static void singleOptionHelp(FILE * f, int maxLeftCol, 
-			     const struct poptOption * opt,
-			     const char *translation_domain) {
+/**
+ * @param opt		option(s)
+ * @param translation_domain	translation domain
+ */
+static /*@only@*/ /*@null@*/ char *
+singleOptionDefaultValue(int lineLength,
+		const struct poptOption * opt,
+		/*@-paramuse@*/	/* FIX: i18n macros disable with lclint */
+		/*@null@*/ const char * translation_domain)
+		/*@=paramuse@*/
+	/*@*/
+{
+    const char * defstr = D_(translation_domain, "default");
+    char * le = malloc(4*lineLength + 1);
+    char * l = le;
+
+    if (le == NULL) return NULL;	/* XXX can't happen */
+    *le = '\0';
+    *le++ = '(';
+    strcpy(le, defstr);	le += strlen(le);
+    *le++ = ':';
+    *le++ = ' ';
+    if (opt->arg)	/* XXX programmer error */
+    switch (opt->argInfo & POPT_ARG_MASK) {
+    case POPT_ARG_VAL:
+    case POPT_ARG_INT:
+    {	long aLong = *((int *)opt->arg);
+	sprintf(le, "%ld", aLong);
+	le += strlen(le);
+    }	break;
+    case POPT_ARG_LONG:
+    {	long aLong = *((long *)opt->arg);
+	sprintf(le, "%ld", aLong);
+	le += strlen(le);
+    }	break;
+    case POPT_ARG_FLOAT:
+    {	double aDouble = *((float *)opt->arg);
+	sprintf(le, "%g", aDouble);
+	le += strlen(le);
+    }	break;
+    case POPT_ARG_DOUBLE:
+    {	double aDouble = *((double *)opt->arg);
+	sprintf(le, "%g", aDouble);
+	le += strlen(le);
+    }	break;
+    case POPT_ARG_STRING:
+    {	const char * s = *(const char **)opt->arg;
+	if (s == NULL) {
+	    strcpy(le, "null");	le += strlen(le);
+	} else {
+	    size_t slen = 4*lineLength - (le - l) - sizeof("\"...\")");
+	    *le++ = '"';
+	    strncpy(le, s, slen); le[slen] = '\0'; le += strlen(le);	
+	    if (slen < strlen(s)) {
+		strcpy(le, "...");	le += strlen(le);
+	    }
+	    *le++ = '"';
+	}
+    }	break;
+    case POPT_ARG_NONE:
+    default:
+	l = _free(l);
+	return NULL;
+	/*@notreached@*/ break;
+    }
+    *le++ = ')';
+    *le = '\0';
+
+    return l;
+}
+
+/**
+ * @param fp		output file handle
+ * @param opt		option(s)
+ * @param translation_domain	translation domain
+ */
+static void singleOptionHelp(FILE * fp, int maxLeftCol, 
+		const struct poptOption * opt,
+		/*@null@*/ const char * translation_domain)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/
+{
     int indentLength = maxLeftCol + 5;
     int lineLength = 79 - indentLength;
     const char * help = D_(translation_domain, opt->descrip);
+    const char * argDescrip = getArgDescrip(opt, translation_domain);
     int helpLength;
-    const char * ch;
-    char format[10];
+    char * defs = NULL;
     char * left;
-    const char * argDescrip = getArgDescrip(opt, translation_domain);
+    int nb = maxLeftCol + 1;
 
-    left = malloc(maxLeftCol + 1);
-    *left = '\0';
+    /* Make sure there's more than enough room in target buffer. */
+    if (opt->longName)	nb += strlen(opt->longName);
+    if (argDescrip)	nb += strlen(argDescrip);
+
+    left = malloc(nb);
+    if (left == NULL) return;	/* XXX can't happen */
+    left[0] = '\0';
+    left[maxLeftCol] = '\0';
 
     if (opt->longName && opt->shortName)
-	sprintf(left, "-%c, --%s", opt->shortName, opt->longName);
-    else if (opt->shortName) 
+	sprintf(left, "-%c, %s%s", opt->shortName,
+		((opt->argInfo & POPT_ARGFLAG_ONEDASH) ? "-" : "--"),
+		opt->longName);
+    else if (opt->shortName != '\0') 
 	sprintf(left, "-%c", opt->shortName);
     else if (opt->longName)
-	sprintf(left, "--%s", opt->longName);
-    if (!*left) return ;
+	sprintf(left, "%s%s",
+		((opt->argInfo & POPT_ARGFLAG_ONEDASH) ? "-" : "--"),
+		opt->longName);
+    if (!*left) goto out;
     if (argDescrip) {
-	strcat(left, "=");
-	strcat(left, argDescrip);
+	char * le = left + strlen(left);
+
+	if (opt->argInfo & POPT_ARGFLAG_OPTIONAL)
+	    *le++ = '[';
+
+	/* Choose type of output */
+	/*@-branchstate@*/
+	if (opt->argInfo & POPT_ARGFLAG_SHOW_DEFAULT) {
+	    defs = singleOptionDefaultValue(lineLength, opt, translation_domain);
+	    if (defs) {
+		char * t = malloc((help ? strlen(help) : 0) +
+				strlen(defs) + sizeof(" "));
+		if (t) {
+		    char * te = t;
+		    *te = '\0';
+		    if (help) {
+			strcpy(te, help);	te += strlen(te);
+		    }
+		    *te++ = ' ';
+		    strcpy(te, defs);
+		    defs = _free(defs);
+		}
+		defs = t;
+	    }
+	}
+	/*@=branchstate@*/
+
+	if (opt->argDescrip == NULL) {
+	    switch (opt->argInfo & POPT_ARG_MASK) {
+	    case POPT_ARG_NONE:
+		break;
+	    case POPT_ARG_VAL:
+	    {	long aLong = opt->val;
+		int ops = (opt->argInfo & POPT_ARGFLAG_LOGICALOPS);
+		int negate = (opt->argInfo & POPT_ARGFLAG_NOT);
+
+		/* Don't bother displaying typical values */
+		if (!ops && (aLong == 0L || aLong == 1L || aLong == -1L))
+		    break;
+		*le++ = '[';
+		switch (ops) {
+		case POPT_ARGFLAG_OR:
+		    *le++ = '|';
+		    /*@innerbreak@*/ break;
+		case POPT_ARGFLAG_AND:
+		    *le++ = '&';
+		    /*@innerbreak@*/ break;
+		case POPT_ARGFLAG_XOR:
+		    *le++ = '^';
+		    /*@innerbreak@*/ break;
+		default:
+		    /*@innerbreak@*/ break;
+		}
+		*le++ = '=';
+		if (negate) *le++ = '~';
+		/*@-formatconst@*/
+		sprintf(le, (ops ? "0x%lx" : "%ld"), aLong);
+		le += strlen(le);
+		/*@=formatconst@*/
+		*le++ = ']';
+	    }	break;
+	    case POPT_ARG_INT:
+	    case POPT_ARG_LONG:
+	    case POPT_ARG_FLOAT:
+	    case POPT_ARG_DOUBLE:
+	    case POPT_ARG_STRING:
+		*le++ = '=';
+		strcpy(le, argDescrip);		le += strlen(le);
+		break;
+	    default:
+		break;
+	    }
+	} else {
+	    *le++ = '=';
+	    strcpy(le, argDescrip);		le += strlen(le);
+	}
+	if (opt->argInfo & POPT_ARGFLAG_OPTIONAL)
+	    *le++ = ']';
+	*le = '\0';
     }
 
     if (help)
-	fprintf(f,"  %-*s   ", maxLeftCol, left);
+	fprintf(fp,"  %-*s   ", maxLeftCol, left);
     else {
-	fprintf(f,"  %s\n", left); 
+	fprintf(fp,"  %s\n", left); 
 	goto out;
     }
 
+    left = _free(left);
+    if (defs) {
+	help = defs; defs = NULL;
+    }
+
     helpLength = strlen(help);
     while (helpLength > lineLength) {
+	const char * ch;
+	char format[10];
+
 	ch = help + lineLength - 1;
 	while (ch > help && !isspace(*ch)) ch--;
 	if (ch == help) break;		/* give up */
 	while (ch > (help + 1) && isspace(*ch)) ch--;
 	ch++;
 
 	sprintf(format, "%%.%ds\n%%%ds", (int) (ch - help), indentLength);
-	fprintf(f, format, help, " ");
+	/*@-formatconst@*/
+	fprintf(fp, format, help, " ");
+	/*@=formatconst@*/
 	help = ch;
 	while (isspace(*help) && *help) help++;
 	helpLength = strlen(help);
     }
 
-    if (helpLength) fprintf(f, "%s\n", help);
+    if (helpLength) fprintf(fp, "%s\n", help);
 
 out:
-    free(left);
+    /*@-dependenttrans@*/
+    defs = _free(defs);
+    /*@=dependenttrans@*/
+    left = _free(left);
 }
 
+/**
+ * @param opt		option(s)
+ * @param translation_domain	translation domain
+ */
 static int maxArgWidth(const struct poptOption * opt,
-		       const char * translation_domain) {
+		       /*@null@*/ const char * translation_domain)
+	/*@*/
+{
     int max = 0;
-    int this;
+    int len = 0;
     const char * s;
     
+    if (opt != NULL)
     while (opt->longName || opt->shortName || opt->arg) {
 	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
-	    this = maxArgWidth(opt->arg, translation_domain);
-	    if (this > max) max = this;
+	    if (opt->arg)	/* XXX program error */
+	    len = maxArgWidth(opt->arg, translation_domain);
+	    if (len > max) max = len;
 	} else if (!(opt->argInfo & POPT_ARGFLAG_DOC_HIDDEN)) {
-	    this = opt->shortName ? 2 : 0;
+	    len = sizeof("  ")-1;
+	    if (opt->shortName != '\0') len += sizeof("-X")-1;
+	    if (opt->shortName != '\0' && opt->longName) len += sizeof(", ")-1;
 	    if (opt->longName) {
-		if (this) this += 2;
-		this += strlen(opt->longName) + 2;
+		len += ((opt->argInfo & POPT_ARGFLAG_ONEDASH)
+			? sizeof("-")-1 : sizeof("--")-1);
+		len += strlen(opt->longName);
 	    }
 
 	    s = getArgDescrip(opt, translation_domain);
 	    if (s)
-		this += strlen(s) + 1;
-	    if (this > max) max = this;
+		len += sizeof("=")-1 + strlen(s);
+	    if (opt->argInfo & POPT_ARGFLAG_OPTIONAL) len += sizeof("[]")-1;
+	    if (len > max) max = len;
 	}
 
 	opt++;
     }
     
     return max;
 }
 
-static void singleTableHelp(FILE * f, const struct poptOption * table, 
-			    int left,
-			    const char *translation_domain) {
+/**
+ * Display popt alias and exec help.
+ * @param fp		output file handle
+ * @param items		alias/exec array
+ * @param nitems	no. of alias/exec entries
+ * @param translation_domain	translation domain
+ */
+static void itemHelp(FILE * fp,
+		/*@null@*/ poptItem items, int nitems, int left,
+		/*@null@*/ const char * translation_domain)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/
+{
+    poptItem item;
+    int i;
+
+    if (items != NULL)
+    for (i = 0, item = items; i < nitems; i++, item++) {
+	const struct poptOption * opt;
+	opt = &item->option;
+	if ((opt->longName || opt->shortName) && 
+	    !(opt->argInfo & POPT_ARGFLAG_DOC_HIDDEN))
+	    singleOptionHelp(fp, left, opt, translation_domain);
+    }
+}
+
+/**
+ * @param fp		output file handle
+ * @param table		option(s)
+ * @param translation_domain	translation domain
+ */
+static void singleTableHelp(poptContext con, FILE * fp,
+		/*@null@*/ const struct poptOption * table, int left,
+		/*@null@*/ const char * translation_domain)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/
+{
     const struct poptOption * opt;
     const char *sub_transdom;
 
-    opt = table;
-    while (opt->longName || opt->shortName || opt->arg) {
+    if (table == poptAliasOptions) {
+	itemHelp(fp, con->aliases, con->numAliases, left, NULL);
+	itemHelp(fp, con->execs, con->numExecs, left, NULL);
+	return;
+    }
+
+    if (table != NULL)
+    for (opt = table; (opt->longName || opt->shortName || opt->arg); opt++) {
 	if ((opt->longName || opt->shortName) && 
 	    !(opt->argInfo & POPT_ARGFLAG_DOC_HIDDEN))
-	    singleOptionHelp(f, left, opt, translation_domain);
-	opt++;
+	    singleOptionHelp(fp, left, opt, translation_domain);
     }
 
-    opt = table;
-    while (opt->longName || opt->shortName || opt->arg) {
-	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
-	    sub_transdom = getTableTranslationDomain(opt->arg);
-	    if(!sub_transdom)
-		sub_transdom = translation_domain;
+    if (table != NULL)
+    for (opt = table; (opt->longName || opt->shortName || opt->arg); opt++) {
+	if ((opt->argInfo & POPT_ARG_MASK) != POPT_ARG_INCLUDE_TABLE)
+	    continue;
+	sub_transdom = getTableTranslationDomain(opt->arg);
+	if (sub_transdom == NULL)
+	    sub_transdom = translation_domain;
 	    
-	    if (opt->descrip)
-		fprintf(f, "\n%s\n", D_(sub_transdom, opt->descrip));
+	if (opt->descrip)
+	    fprintf(fp, "\n%s\n", D_(sub_transdom, opt->descrip));
 
-	    singleTableHelp(f, opt->arg, left, sub_transdom);
-	}
-	opt++;
+	singleTableHelp(con, fp, opt->arg, left, sub_transdom);
     }
 }
 
-static int showHelpIntro(poptContext con, FILE * f) {
+/**
+ * @param con		context
+ * @param fp		output file handle
+ */
+static int showHelpIntro(poptContext con, FILE * fp)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/
+{
     int len = 6;
     const char * fn;
 
-    fprintf(f, POPT_("Usage:"));
+    fprintf(fp, POPT_("Usage:"));
     if (!(con->flags & POPT_CONTEXT_KEEP_FIRST)) {
+	/*@-nullderef@*/	/* LCL: wazzup? */
 	fn = con->optionStack->argv[0];
-	if (strchr(fn, '/')) fn = strchr(fn, '/') + 1;
-	fprintf(f, " %s", fn);
+	/*@=nullderef@*/
+	if (fn == NULL) return len;
+	if (strchr(fn, '/')) fn = strrchr(fn, '/') + 1;
+	fprintf(fp, " %s", fn);
 	len += strlen(fn) + 1;
     }
 
     return len;
 }
 
-void poptPrintHelp(poptContext con, FILE * f, /*@unused@*/ int flags) {
+void poptPrintHelp(poptContext con, FILE * fp, /*@unused@*/ int flags)
+{
     int leftColWidth;
 
-    showHelpIntro(con, f);
+    (void) showHelpIntro(con, fp);
     if (con->otherHelp)
-	fprintf(f, " %s\n", con->otherHelp);
+	fprintf(fp, " %s\n", con->otherHelp);
     else
-	fprintf(f, " %s\n", POPT_("[OPTION...]"));
+	fprintf(fp, " %s\n", POPT_("[OPTION...]"));
 
     leftColWidth = maxArgWidth(con->options, NULL);
-    singleTableHelp(f, con->options, leftColWidth, NULL);
+    singleTableHelp(con, fp, con->options, leftColWidth, NULL);
 }
 
-static int singleOptionUsage(FILE * f, int cursor, 
-			     const struct poptOption * opt,
-			     const char *translation_domain) {
+/**
+ * @param fp		output file handle
+ * @param opt		option(s)
+ * @param translation_domain	translation domain
+ */
+static int singleOptionUsage(FILE * fp, int cursor, 
+		const struct poptOption * opt,
+		/*@null@*/ const char *translation_domain)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/
+{
     int len = 3;
     char shortStr[2] = { '\0', '\0' };
     const char * item = shortStr;
     const char * argDescrip = getArgDescrip(opt, translation_domain);
 
-    if (opt->shortName) {
+    if (opt->shortName!= '\0' ) {
 	if (!(opt->argInfo & POPT_ARG_MASK)) 
 	    return cursor;	/* we did these already */
 	len++;
-	*shortStr = opt->shortName;
+	shortStr[0] = opt->shortName;
 	shortStr[1] = '\0';
     } else if (opt->longName) {
 	len += 1 + strlen(opt->longName);
 	item = opt->longName;
     }
 
     if (len == 3) return cursor;
 
     if (argDescrip) 
 	len += strlen(argDescrip) + 1;
 
     if ((cursor + len) > 79) {
-	fprintf(f, "\n       ");
+	fprintf(fp, "\n       ");
 	cursor = 7;
     } 
 
-    fprintf(f, " [-%s%s%s%s]", opt->shortName ? "" : "-", item,
-	    argDescrip ? (opt->shortName ? " " : "=") : "",
-	    argDescrip ? argDescrip : "");
+    fprintf(fp, " [-%s%s%s%s]",
+	((opt->shortName || (opt->argInfo & POPT_ARGFLAG_ONEDASH)) ? "" : "-"),
+	item,
+	(argDescrip ? (opt->shortName != '\0' ? " " : "=") : ""),
+	(argDescrip ? argDescrip : ""));
 
     return cursor + len + 1;
 }
 
-static int singleTableUsage(FILE * f, int cursor, const struct poptOption * table,
-		     const char *translation_domain) {
-    const struct poptOption * opt;
-    
-    opt = table;
-    while (opt->longName || opt->shortName || opt->arg) {
-        if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INTL_DOMAIN)
+/**
+ * Display popt alias and exec usage.
+ * @param fp		output file handle
+ * @param item		alias/exec array
+ * @param nitems	no. of ara/exec entries
+ * @param translation_domain	translation domain
+ */
+static int itemUsage(FILE * fp, int cursor, poptItem item, int nitems,
+		/*@null@*/ const char * translation_domain)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/
+{
+    int i;
+
+    /*@-branchstate@*/		/* FIX: W2DO? */
+    if (item != NULL)
+    for (i = 0; i < nitems; i++, item++) {
+	const struct poptOption * opt;
+	opt = &item->option;
+        if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INTL_DOMAIN) {
 	    translation_domain = (const char *)opt->arg;
-	else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) 
-	    cursor = singleTableUsage(f, cursor, opt->arg,
-				      translation_domain);
-	else if ((opt->longName || opt->shortName) && 
-		 !(opt->argInfo & POPT_ARGFLAG_DOC_HIDDEN))
-	  cursor = singleOptionUsage(f, cursor, opt, translation_domain);
+	} else if ((opt->longName || opt->shortName) &&
+		 !(opt->argInfo & POPT_ARGFLAG_DOC_HIDDEN)) {
+	    cursor = singleOptionUsage(fp, cursor, opt, translation_domain);
+	}
+    }
+    /*@=branchstate@*/
 
-	opt++;
+    return cursor;
+}
+
+/**
+ * @param fp		output file handle
+ * @param opt		option(s)
+ * @param translation_domain	translation domain
+ */
+static int singleTableUsage(poptContext con, FILE * fp,
+		int cursor, const struct poptOption * opt,
+		/*@null@*/ const char * translation_domain)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, fileSystem @*/
+{
+    /*@-branchstate@*/		/* FIX: W2DO? */
+    if (opt != NULL)
+    for (; (opt->longName || opt->shortName || opt->arg) ; opt++) {
+        if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INTL_DOMAIN) {
+	    translation_domain = (const char *)opt->arg;
+	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
+	    if (opt->arg)	/* XXX program error */
+	    cursor = singleTableUsage(con, fp, cursor, opt->arg,
+			translation_domain);
+	} else if ((opt->longName || opt->shortName) &&
+		 !(opt->argInfo & POPT_ARGFLAG_DOC_HIDDEN)) {
+	    cursor = singleOptionUsage(fp, cursor, opt, translation_domain);
+	}
     }
+    /*@=branchstate@*/
 
     return cursor;
 }
 
-static int showShortOptions(const struct poptOption * opt, FILE * f, 
-			    char * str) {
-    char s[300];		/* this is larger then the ascii set, so
-				   it should do just fine */
+/**
+ * Return concatenated short options for display.
+ * @param opt		option(s)
+ * @param fp		output file handle
+ * @retval str		concatenation of short options
+ * @return		length of display string
+ */
+static int showShortOptions(const struct poptOption * opt, FILE * fp,
+		/*@null@*/ char * str)
+	/*@globals fileSystem @*/
+	/*@modifies *str, *fp, fileSystem @*/
+{
+    char * s = alloca(300);	/* larger then the ascii set */
 
     s[0] = '\0';
+    /*@-branchstate@*/		/* FIX: W2DO? */
     if (str == NULL) {
 	memset(s, 0, sizeof(s));
 	str = s;
     }
+    /*@=branchstate@*/
 
-    while (opt->longName || opt->shortName || opt->arg) {
+    if (opt != NULL)
+    for (; (opt->longName || opt->shortName || opt->arg); opt++) {
 	if (opt->shortName && !(opt->argInfo & POPT_ARG_MASK))
 	    str[strlen(str)] = opt->shortName;
 	else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE)
-	    showShortOptions(opt->arg, f, str);
-
-	opt++;
+	    if (opt->arg)	/* XXX program error */
+		(void) showShortOptions(opt->arg, fp, str);
     } 
 
-    if (s != str || !*s)
+    if (s != str || *s != '\0')
 	return 0;
 
-    fprintf(f, " [-%s]", s);
+    fprintf(fp, " [-%s]", s);
     return strlen(s) + 4;
 }
 
-void poptPrintUsage(poptContext con, FILE * f, /*@unused@*/ int flags) {
+void poptPrintUsage(poptContext con, FILE * fp, /*@unused@*/ int flags)
+{
     int cursor;
 
-    cursor = showHelpIntro(con, f);
-    cursor += showShortOptions(con->options, f, NULL);
-    singleTableUsage(f, cursor, con->options, NULL);
+    cursor = showHelpIntro(con, fp);
+    cursor += showShortOptions(con->options, fp, NULL);
+    (void) singleTableUsage(con, fp, cursor, con->options, NULL);
+    (void) itemUsage(fp, cursor, con->aliases, con->numAliases, NULL);
+    (void) itemUsage(fp, cursor, con->execs, con->numExecs, NULL);
 
     if (con->otherHelp) {
 	cursor += strlen(con->otherHelp) + 1;
-	if (cursor > 79) fprintf(f, "\n       ");
-	fprintf(f, " %s", con->otherHelp);
+	if (cursor > 79) fprintf(fp, "\n       ");
+	fprintf(fp, " %s", con->otherHelp);
     }
 
-    fprintf(f, "\n");
+    fprintf(fp, "\n");
 }
 
-void poptSetOtherOptionHelp(poptContext con, const char * text) {
-    if (con->otherHelp) xfree(con->otherHelp);
+void poptSetOtherOptionHelp(poptContext con, const char * text)
+{
+    con->otherHelp = _free(con->otherHelp);
     con->otherHelp = xstrdup(text);
 }
+/*@=type@*/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/poptint.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/poptint.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/poptint.h	2001-02-24 09:32:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/poptint.h	2002-07-28 02:32:25.000000000 +0800
@@ -1,87 +1,96 @@
-/* (C) 1998 Red Hat Software, Inc. -- Licensing details are in the COPYING
+/** \ingroup popt
+ * \file popt/poptint.h
+ */
+
+/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
-   ftp://ftp.redhat.com/pub/code/popt */
+   ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #ifndef H_POPTINT
 #define H_POPTINT
 
+/**
+ * Wrapper to free(3), hides const compilation noise, permit NULL, return NULL.
+ * @param p		memory to free
+ * @retval		NULL always
+ */
+/*@unused@*/ static inline /*@null@*/ void *
+_free(/*@only@*/ /*@null@*/ const void * p)
+	/*@modifies p @*/
+{
+    if (p != NULL)	free((void *)p);
+    return NULL;
+}
+
 /* Bit mask macros. */
 typedef	unsigned int __pbm_bits;
 #define	__PBM_NBITS		(8 * sizeof (__pbm_bits))
 #define	__PBM_IX(d)		((d) / __PBM_NBITS)
-#define __PBM_MASK(d)		((__pbm_bits) 1 << ((d) % __PBM_NBITS))
+#define __PBM_MASK(d)		((__pbm_bits) 1 << (((unsigned)(d)) % __PBM_NBITS))
 typedef struct {
     __pbm_bits bits[1];
 } pbm_set;
 #define	__PBM_BITS(set)	((set)->bits)
 
 #define	PBM_ALLOC(d)	calloc(__PBM_IX (d) + 1, sizeof(__pbm_bits))
-#define	PBM_FREE(s)	free(s);
+#define	PBM_FREE(s)	_free(s);
 #define PBM_SET(d, s)   (__PBM_BITS (s)[__PBM_IX (d)] |= __PBM_MASK (d))
 #define PBM_CLR(d, s)   (__PBM_BITS (s)[__PBM_IX (d)] &= ~__PBM_MASK (d))
 #define PBM_ISSET(d, s) ((__PBM_BITS (s)[__PBM_IX (d)] & __PBM_MASK (d)) != 0)
 
 struct optionStackEntry {
     int argc;
-    /*@only@*/ const char ** argv;
-    /*@only@*/ pbm_set * argb;
+/*@only@*/ /*@null@*/ const char ** argv;
+/*@only@*/ /*@null@*/ pbm_set * argb;
     int next;
-    /*@only@*/ const char * nextArg;
-    /*@keep@*/ const char * nextCharArg;
-    /*@dependent@*/ struct poptAlias * currAlias;
+/*@only@*/ /*@null@*/ const char * nextArg;
+/*@keep@*/ /*@null@*/ const char * nextCharArg;
+/*@dependent@*/ /*@null@*/ poptItem currAlias;
     int stuffed;
 };
 
-struct execEntry {
-    const char * longName;
-    char shortName;
-    const char * script;
-};
-
 struct poptContext_s {
     struct optionStackEntry optionStack[POPT_OPTION_DEPTH];
-    /*@dependent@*/ struct optionStackEntry * os;
-    /*@owned@*/ const char ** leftovers;
+/*@dependent@*/ struct optionStackEntry * os;
+/*@owned@*/ /*@null@*/ const char ** leftovers;
     int numLeftovers;
     int nextLeftover;
-    /*@keep@*/ const struct poptOption * options;
+/*@keep@*/ const struct poptOption * options;
     int restLeftover;
-    /*@only@*/ const char * appName;
-    /*@only@*/ struct poptAlias * aliases;
+/*@only@*/ /*@null@*/ const char * appName;
+/*@only@*/ /*@null@*/ poptItem aliases;
     int numAliases;
     int flags;
-    struct execEntry * execs;
+/*@owned@*/ /*@null@*/ poptItem execs;
     int numExecs;
-    /*@only@*/ const char ** finalArgv;
+/*@only@*/ /*@null@*/ const char ** finalArgv;
     int finalArgvCount;
     int finalArgvAlloced;
-    /*@dependent@*/ struct execEntry * doExec;
-    /*@only@*/ const char * execPath;
+/*@dependent@*/ /*@null@*/ poptItem doExec;
+/*@only@*/ const char * execPath;
     int execAbsolute;
-    /*@only@*/ const char * otherHelp;
-    pbm_set * arg_strip;
+/*@only@*/ const char * otherHelp;
+/*@null@*/ pbm_set * arg_strip;
 };
 
-#define	xfree(_a)	free((void *)_a)
-
 #ifdef HAVE_LIBINTL_H
 #include <libintl.h>
 #endif
 
 #if defined(HAVE_GETTEXT) && !defined(__LCLINT__)
 #define _(foo) gettext(foo)
 #else
-#define _(foo) (foo)
+#define _(foo) foo
 #endif
 
 #if defined(HAVE_DGETTEXT) && !defined(__LCLINT__)
 #define D_(dom, str) dgettext(dom, str)
 #define POPT_(foo) D_("popt", foo)
 #else
-#define POPT_(foo) (foo)
-#define D_(dom, str) (str)
+#define D_(dom, str) str
+#define POPT_(foo) foo
 #endif
 
-#define N_(foo) (foo)
+#define N_(foo) foo
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/poptparse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/poptparse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/poptparse.c	2001-03-23 11:44:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/poptparse.c	2002-07-28 02:32:25.000000000 +0800
@@ -1,9 +1,13 @@
-/* (C) 1998 Red Hat Software, Inc. -- Licensing details are in the COPYING
+/** \ingroup popt
+ * \file popt/poptparse.c
+ */
+
+/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
-   ftp://ftp.redhat.com/pub/code/popt */
+   ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
 
 #define POPT_ARGV_ARRAY_GROW_DELTA 5
 
 int poptDupArgv(int argc, const char **argv,
@@ -11,92 +15,104 @@
 {
     size_t nb = (argc + 1) * sizeof(*argv);
     const char ** argv2;
     char * dst;
     int i;
 
+    if (argc <= 0 || argv == NULL)	/* XXX can't happen */
+	return POPT_ERROR_NOARG;
     for (i = 0; i < argc; i++) {
 	if (argv[i] == NULL)
 	    return POPT_ERROR_NOARG;
 	nb += strlen(argv[i]) + 1;
     }
 	
     dst = malloc(nb);
+    if (dst == NULL)			/* XXX can't happen */
+	return POPT_ERROR_MALLOC;
     argv2 = (void *) dst;
     dst += (argc + 1) * sizeof(*argv);
 
+    /*@-branchstate@*/
     for (i = 0; i < argc; i++) {
 	argv2[i] = dst;
 	dst += strlen(strcpy(dst, argv[i])) + 1;
     }
+    /*@=branchstate@*/
     argv2[argc] = NULL;
 
-    *argvPtr = argv2;
-    *argcPtr = argc;
+    if (argvPtr) {
+	*argvPtr = argv2;
+    } else {
+	free(argv2);
+	argv2 = NULL;
+    }
+    if (argcPtr)
+	*argcPtr = argc;
     return 0;
 }
 
 int poptParseArgvString(const char * s, int * argcPtr, const char *** argvPtr)
 {
     const char * src;
     char quote = '\0';
     int argvAlloced = POPT_ARGV_ARRAY_GROW_DELTA;
     const char ** argv = malloc(sizeof(*argv) * argvAlloced);
     int argc = 0;
     int buflen = strlen(s) + 1;
-    char *buf0 = calloc(buflen, 1);
-    char *buf = buf0;
+    char * buf = memset(alloca(buflen), 0, buflen);
+    int rc = POPT_ERROR_MALLOC;
 
+    if (argv == NULL) return rc;
     argv[argc] = buf;
 
-    for (src = s; *src; src++) {
+    for (src = s; *src != '\0'; src++) {
 	if (quote == *src) {
 	    quote = '\0';
-	} else if (quote) {
+	} else if (quote != '\0') {
 	    if (*src == '\\') {
 		src++;
 		if (!*src) {
-		    free(argv);
-		    free(buf0);
-		    return POPT_ERROR_BADQUOTE;
+		    rc = POPT_ERROR_BADQUOTE;
+		    goto exit;
 		}
 		if (*src != quote) *buf++ = '\\';
 	    }
 	    *buf++ = *src;
 	} else if (isspace(*src)) {
-	    if (*argv[argc]) {
+	    if (*argv[argc] != '\0') {
 		buf++, argc++;
 		if (argc == argvAlloced) {
 		    argvAlloced += POPT_ARGV_ARRAY_GROW_DELTA;
 		    argv = realloc(argv, sizeof(*argv) * argvAlloced);
+		    if (argv == NULL) goto exit;
 		}
 		argv[argc] = buf;
 	    }
 	} else switch (*src) {
 	  case '"':
 	  case '\'':
 	    quote = *src;
-	    break;
+	    /*@switchbreak@*/ break;
 	  case '\\':
 	    src++;
 	    if (!*src) {
-		free(argv);
-		free(buf0);
-		return POPT_ERROR_BADQUOTE;
+		rc = POPT_ERROR_BADQUOTE;
+		goto exit;
 	    }
 	    /*@fallthrough@*/
 	  default:
 	    *buf++ = *src;
-	    break;
+	    /*@switchbreak@*/ break;
 	}
     }
 
     if (strlen(argv[argc])) {
 	argc++, buf++;
     }
 
-    (void) poptDupArgv(argc, argv, argcPtr, argvPtr);
+    rc = poptDupArgv(argc, argv, argcPtr, argvPtr);
 
-    free(argv);
-    free(buf0);
-    return 0;
+exit:
+    if (argv) free(argv);
+    return rc;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/README	2001-02-24 09:32:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/README	2002-07-28 02:32:25.000000000 +0800
@@ -2,13 +2,13 @@
 to getopt(3), it contains a number of enhancements, including:
 
 	1) popt is fully reentrant
 	2) popt can parse arbitrary argv[] style arrays while 
 	   getopt(2) makes this quite difficult
 	3) popt allows users to alias command line arguments
-	4) popt provides convience functions for parsting strings
+	4) popt provides convience functions for parsing strings
 	   into argv[] style arrays
 
 popt is used by rpm, the Red Hat install program, and many other Red Hat
 utilities, all of which provide excellent examples of how to use popt. 
 Complete documentation on popt is available in popt.ps (included in this
 tarball), which is excerpted with permission from the book "Linux
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/README.rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/README.rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/README.rsync	2002-03-25 17:42:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/README.rsync	2002-07-28 02:32:25.000000000 +0800
@@ -1,5 +1,4 @@
-Unlike zlib, this is a perfectly ordinary copy of libpopt.  It's only
-used on platforms that don't have a sufficiently up-to-date copy of
-their own.  If you build rsync on a platform which has popt, this
-directory should not be used.  (You can control that using
---with-included-popt.)
+This is a perfectly ordinary copy of libpopt.  It is only used on platforms
+that do not have a sufficiently up-to-date copy of their own.  If you build
+rsync on a platform which has popt, this directory should not be used.  (You
+can control that using the --with-included-popt configure flag.)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/system.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/system.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/popt/system.h	2001-02-24 09:32:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/popt/system.h	2003-01-13 05:49:44.000000000 +0800
@@ -22,30 +22,48 @@
 #ifdef __NeXT
 /* access macros are not declared in non posix mode in unistd.h -
  don't try to use posix on NeXTstep 3.3 ! */
 #include <libc.h>
 #endif
 
+#if defined(__LCLINT__)
+/*@-declundef -incondefs -redecl@*/ /* LCL: missing annotation */
+/*@only@*/ void * alloca (size_t __size)
+	/*@ensures MaxSet(result) == (__size - 1) @*/
+	/*@*/;
+/*@=declundef =incondefs =redecl@*/
+#endif
+
 /* AIX requires this to be the first thing in the file.  */ 
 #ifndef __GNUC__
 # if HAVE_ALLOCA_H
 #  include <alloca.h>
 # else
 #  ifdef _AIX
 #pragma alloca
 #  else
-#   ifndef alloca /* predefined by HP cc +Olibcalls */
+#   if HAVE_ALLOCA
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
 char *alloca ();
+#    endif
+#   else
+#    ifdef alloca
+#     undef alloca
+#    endif
+#    define alloca(sz) malloc(sz) /* Kludge this for now */
 #   endif
 #  endif
 # endif
 #elif defined(__GNUC__) && defined(__STRICT_ANSI__)
 #define alloca __builtin_alloca
 #endif
 
-/*@only@*/ char * xstrdup (const char *str);
+/*@-redecl -redef@*/
+/*@mayexit@*/ /*@only@*/ char * xstrdup (const char *str)
+	/*@*/;
+/*@=redecl =redef@*/
 
 #if HAVE_MCHECK_H && defined(__GNUC__)
 #define	vmefail()	(fprintf(stderr, "virtual memory exhausted.\n"), exit(EXIT_FAILURE), NULL)
 #define xstrdup(_str)   (strcpy((malloc(strlen(_str)+1) ? : vmefail()), (_str)))
 #else
 #define	xstrdup(_str)	strdup(_str)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6: progress.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/proto.h	2002-03-25 11:51:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/proto.h	2003-01-27 11:35:09.000000000 +0800
@@ -1,19 +1,19 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
 int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
-char *auth_server(int fd, int module, char *addr, char *leader);
+char *auth_server(int f_in, int f_out, int module, char *addr, char *leader);
 void auth_client(int fd, char *user, char *challenge);
 int make_backup(char *fname);
 void write_batch_flist_file(char *buff, int bytes_to_write);
 void write_batch_flist_info(int flist_count, struct file_struct **fptr);
 void write_char_bufs(char *buf);
 void write_batch_argvs_file(int argc, char *argv[]);
 struct file_list *create_flist_from_batch(void);
 int read_batch_flist_file(char *buff, int len);
-unsigned char read_batch_flags();
+unsigned char read_batch_flags(void);
 void read_batch_flist_info(struct file_struct **fptr);
 void write_batch_csums_file(void *buff, int bytes_to_write);
 void close_batch_csums_file(void);
 void write_batch_csum_info(int *flist_entry, int flist_count,
 			   struct sum_struct *s);
 int read_batch_csums_file(char *buff, int len);
@@ -26,14 +26,15 @@
 void show_argvs(int argc, char *argv[]);
 uint32 get_checksum1(char *buf1,int len);
 void get_checksum2(char *buf,int len,char *sum);
 void file_checksum(char *fname,char *sum,OFF_T size);
 void checksum_init(void);
 void sum_init(void);
-void sum_update(char *p,int len);
+void sum_update(char *p, int len);
 void sum_end(char *sum);
+void close_all(void);
 void _exit_cleanup(int code, const char *file, int line);
 void cleanup_disable(void);
 void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
 		 struct map_struct *buf, int fd1, int fd2);
 void cleanup_set_pid(int pid);
 char *client_addr(int fd);
@@ -46,15 +47,16 @@
 		char *name_buf, size_t name_buf_len,
 		char *port_buf, size_t port_buf_len);
 int compare_addrinfo_sockaddr(const struct addrinfo *ai,
 			      const struct sockaddr_storage *ss);
 int check_name(int fd,
 	       const struct sockaddr_storage *ss,
-	       char *name_buf,
-	       const char *port_buf);
+	       char *name_buf);
 int start_socket_client(char *host, char *path, int argc, char *argv[]);
+int start_inband_exchange(char *user, char *path, int f_in, int f_out, int argc);
+int start_daemon(int f_in, int f_out);
 int daemon_main(void);
 void setup_protocol(int f_out,int f_in);
 int claim_connection(char *fname,int max_connections);
 int check_exclude(char *name, struct exclude_struct **local_exclude_list,
 		  STRUCT_STAT *st);
 void add_exclude_list(const char *pattern, struct exclude_struct ***list, int include);
@@ -72,27 +74,27 @@
 int sparse_end(int f);
 int write_file(int f,char *buf,size_t len);
 struct map_struct *map_file(int fd,OFF_T len);
 char *map_ptr(struct map_struct *map,OFF_T offset,int len);
 void unmap_file(struct map_struct *map);
 void show_flist_stats(void);
-int readlink_stat(const char *Path, STRUCT_STAT * Buffer, char *Linkbuf);
-int link_stat(const char *Path, STRUCT_STAT * Buffer);
+int readlink_stat(const char *path, STRUCT_STAT * buffer, char *linkbuf);
+int link_stat(const char *path, STRUCT_STAT * buffer);
 struct file_struct *make_file(int f, char *fname, struct string_area **ap,
 			      int noexcludes);
 void send_file_name(int f, struct file_list *flist, char *fname,
 		    int recursive, unsigned base_flags);
 struct file_list *send_file_list(int f, int argc, char *argv[]);
 struct file_list *recv_file_list(int f);
 int file_compare(struct file_struct **f1, struct file_struct **f2);
 int flist_find(struct file_list *flist, struct file_struct *f);
 void free_file(struct file_struct *file);
-struct file_list *flist_new();
+struct file_list *flist_new(void);
 void flist_free(struct file_list *flist);
 char *f_name(struct file_struct *f);
-void recv_generator(char *fname,struct file_list *flist,int i,int f_out);
+void recv_generator(char *fname, struct file_list *flist, int i, int f_out);
 void generate_files(int f,struct file_list *flist,char *local_name,int f_recv);
 int main(int argc, char *argv[]);
 void init_hard_links(struct file_list *flist);
 int check_hard_link(struct file_struct *file);
 void do_hard_links(void);
 void io_set_error_fd(int fd);
@@ -102,12 +104,13 @@
 void read_sbuf(int f,char *buf,size_t len);
 unsigned char read_byte(int f);
 void io_start_buffering(int fd);
 void io_flush(void);
 void io_end_buffering(void);
 void write_int(int f,int32 x);
+void write_int_named(int f, int32 x, const char *phase);
 void write_longint(int f, int64 x);
 void write_buf(int f,char *buf,size_t len);
 void write_byte(int f,unsigned char c);
 int read_line(int f, char *buf, size_t maxlen);
 void io_printf(int fd, const char *format, ...);
 void io_start_multiplex_out(int fd);
@@ -147,36 +150,42 @@
 int lp_max_connections(int );
 BOOL lp_load(char *pszFname, int globals_only);
 int lp_numservices(void);
 int lp_number(char *name);
 void err_list_push(void);
 void log_init(void);
-void log_open();
-void log_close();
+void log_open(void);
+void log_close(void);
 void set_error_fd(int fd);
 void rwrite(enum logcode code, char *buf, int len);
 void rprintf(enum logcode code, const char *format, ...);
 void rsyserr(enum logcode code, int errcode, const char *format, ...);
 void rflush(enum logcode code);
 void log_send(struct file_struct *file, struct stats *initial_stats);
 void log_recv(struct file_struct *file, struct stats *initial_stats);
 void log_exit(int code, const char *file, int line);
 void log_transfer(struct file_struct *file, const char *fname);
 void wait_process(pid_t pid, int *status);
+int child_main(int argc, char *argv[]);
 void start_server(int f_in, int f_out, int argc, char *argv[]);
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[]);
 int main(int argc,char *argv[]);
-void match_sums(int f,struct sum_struct *s,struct map_struct *buf,OFF_T len);
+void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len);
 void match_report(void);
 void usage(enum logcode F);
 void option_error(void);
 int parse_arguments(int *argc, const char ***argv, int frommain);
 void server_options(char **args,int *argc);
 BOOL pm_process( char *FileName,
                  BOOL (*sfunc)(char *),
                  BOOL (*pfunc)(char *, char *) );
+pid_t piped_child(char **command, int *f_in, int *f_out);
+pid_t local_child(int argc, char **argv,int *f_in,int *f_out,
+		  int (*child_main)(int, char*[]));
+void end_progress(OFF_T size);
+void show_progress(OFF_T ofs, OFF_T size);
 void delete_files(struct file_list *flist);
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen);
 void free_sums(struct sum_struct *s);
 int delete_file(char *fname);
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
 	      int report);
@@ -190,13 +199,13 @@
 		    int af_hint);
 int open_socket_out_wrapped (char *host,
 			     int port,
 			     const char *bind_address,
 			     int af_hint);
 int is_a_socket(int fd);
-void start_accept_loop(int port, int (*fn)(int ));
+void start_accept_loop(int port, int (*fn)(int, int));
 void set_socket_options(int fd, char *options);
 void become_daemon(void);
 int sock_exec(const char *prog);
 int do_unlink(char *fname);
 int do_symlink(char *fname1, char *fname2);
 int do_link(char *fname1, char *fname2);
@@ -212,12 +221,13 @@
 int do_stat(const char *fname, STRUCT_STAT *st);
 int do_lstat(const char *fname, STRUCT_STAT *st);
 int do_fstat(int fd, STRUCT_STAT *st);
 OFF_T do_lseek(int fd, OFF_T offset, int whence);
 void *do_mmap(void *start, int len, int prot, int flags, int fd, OFF_T offset);
 char *d_name(struct dirent *di);
+int main(int argc, char **argv);
 int main (int argc, char *argv[]);
 void set_compression(char *fname);
 void send_token(int f,int token,struct map_struct *buf,OFF_T offset,
 		int n,int toklen);
 int recv_token(int f,char **data);
 void see_token(char *data, int toklen);
@@ -226,18 +236,17 @@
 void add_gid(gid_t gid);
 void send_uid_list(int f);
 void recv_uid_list(int f, struct file_list *flist);
 void set_nonblocking(int fd);
 void set_blocking(int fd);
 int fd_pair(int fd[2]);
-pid_t piped_child(char **command, int *f_in, int *f_out);
-pid_t local_child(int argc, char **argv,int *f_in,int *f_out);
+void print_child_argv(char **cmd);
 void out_of_memory(char *str);
 void overflow(char *str);
 int set_modtime(char *fname, time_t modtime);
-int create_directory_path(char *fname);
+int create_directory_path(char *fname, int base_umask);
 int copy_file(char *source, char *dest, mode_t mode);
 int robust_unlink(char *fname);
 int robust_rename(char *from, char *to);
 pid_t do_fork(void);
 void kill_all(int sig);
 int name_to_uid(char *name, uid_t *uid);
@@ -248,14 +257,12 @@
 void *Realloc(void *p, int size);
 void clean_fname(char *name);
 void sanitize_path(char *p, char *reldir);
 char *push_dir(char *dir, int save);
 int pop_dir(char *dir);
 int u_strcmp(const char *cs1, const char *cs2);
-void end_progress(OFF_T size);
-void show_progress(OFF_T ofs, OFF_T size);
-int unsafe_symlink(char *dest, char *src);
+int unsafe_symlink(const char *dest, const char *src);
 char *timestring(time_t t);
 int msleep(int t);
 int cmp_modtime(time_t file1, time_t file2);
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6);
 int sys_gettimeofday(struct timeval *tv);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/README	2001-12-18 09:07:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/README	2002-05-14 02:34:37.000000000 +0800
@@ -15,79 +15,18 @@
 this package. 
 
 
 USAGE
 -----
 
-Basically you use rsync just like rcp, but rsync has many additional options.
+Basically you use rsync just like rcp, but rsync has many additional
+options.  To get a complete list of supported options type
 
-Here is a brief description of rsync usage:
-
-Usage: rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
-  or   rsync [OPTION]... [USER@]HOST:SRC DEST
-  or   rsync [OPTION]... SRC [SRC]... DEST
-  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]
-  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST
-  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
-SRC on single-colon remote HOST will be expanded by remote shell
-SRC on server remote HOST may contain shell wildcards or multiple
-  sources separated by space as long as they have same top-level
-
-Options
- -v, --verbose               increase verbosity
- -q, --quiet                 decrease verbosity
- -c, --checksum              always checksum
- -a, --archive               archive mode
- -r, --recursive             recurse into directories
- -R, --relative              use relative path names
- -b, --backup                make backups (default ~ suffix)
-     --suffix=SUFFIX         override backup suffix
- -u, --update                update only (don't overwrite newer files)
- -l, --links                 preserve soft links
- -L, --copy-links            treat soft links like regular files
-     --copy-unsafe-links     copy links outside the source tree
-     --safe-links            ignore links outside the destination tree
- -H, --hard-links            preserve hard links
- -p, --perms                 preserve permissions
- -o, --owner                 preserve owner (root only)
- -g, --group                 preserve group
- -D, --devices               preserve devices (root only)
- -t, --times                 preserve times
- -S, --sparse                handle sparse files efficiently
- -n, --dry-run               show what would have been transferred
- -W, --whole-file            copy whole files, no incremental checks
- -x, --one-file-system       don't cross filesystem boundaries
- -B, --block-size=SIZE       checksum blocking size (default 700)
- -e, --rsh=COMMAND           specify rsh replacement
-     --rsync-path=PATH       specify path to rsync on the remote machine
- -C, --cvs-exclude           auto ignore files in the same way CVS does
-     --delete                delete files that don't exist on the sending side
-     --delete-excluded       also delete excluded files on the receiving side
-     --partial               keep partially transferred files
-     --force                 force deletion of directories even if not empty
-     --numeric-ids           don't map uid/gid values by user/group name
-     --timeout=TIME          set IO timeout in seconds
- -I, --ignore-times          don't exclude files that match length and time
-     --size-only             only use file size when determining if a file should be transferred
- -T  --temp-dir=DIR          create temporary files in directory DIR
-     --compare-dest=DIR      also compare destination files relative to DIR
- -z, --compress              compress file data
-     --exclude=PATTERN       exclude files matching PATTERN
-     --exclude-from=FILE     exclude patterns listed in FILE
-     --include=PATTERN       don't exclude files matching PATTERN
-     --include-from=FILE     don't exclude patterns listed in FILE
-     --version               print version number
-     --daemon                run as a rsync daemon
-     --config=FILE           specify alternate rsyncd.conf file
-     --port=PORT             specify alternate rsyncd port number
-     --stats                 give some file transfer stats
-     --progress              show progress during transfer
-     --log-format=FORMAT     log file transfers using specified format
-     --password-file=FILE    get password from FILE
- -h, --help                  show this help screen
+  rsync --help
 
+and see the manual for more information.
 
 
 SETUP
 -----
 
 Rsync normally uses rsh or ssh for communication.  It does not need to
@@ -134,19 +73,25 @@
 
 
 BUG REPORTS
 -----------
 
 If you have web access then please look at
-http://rsync.samba.org/rsync/ 
 
-This will give you access to the bug tracking system used by the
-developers of rsync and will allow you to look at other bug reports or
-submit a new bug report.
+  http://rsync.samba.org
+
+That page contains links to the current bug list, and information on
+how to report a bug well.  You might also like to try searching the
+internet for the error message you've received, or looking in the
+mailing list archives at
+
+  http://mail-archive.com/rsync@lists.samba.org/
+
+Please send bug reports to 
 
-If you don't have web access then mail bug reports to rsync@samba.org.
+  rsync@lists.samba.org
 
 
 CVS TREE
 --------
 
 If you want to get the very latest version of rsync direct from the
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/receiver.c	2002-02-14 02:42:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/receiver.c	2003-01-21 07:32:17.000000000 +0800
@@ -294,15 +294,16 @@
 		}
 	}
 	return 1;
 }
 
 
-/* main routine for receiver process. Receiver process runs on the
-	same host as the generator process. */
-
+/**
+ * main routine for receiver process.
+ *
+ * Receiver process runs on the same host as the generator process. */
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen)
 {  
 	int fd1,fd2;
 	STRUCT_STAT st;
 	char *fname;
 	char template[MAXPATHLEN];
@@ -314,12 +315,13 @@
 	struct file_struct *file;
 	int phase=0;
 	int recv_ok;
 	extern struct stats stats;		
 	extern int preserve_perms;
 	extern int delete_after;
+	extern int orig_umask;
 	struct stats initial_stats;
 
 	if (verbose > 2) {
 		rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
 	}
 
@@ -420,29 +422,23 @@
 		   setuid/setgid bits to ensure that there is no race
 		   condition. They are then correctly updated after
 		   the lchown. Thanks to snabb@epipe.fi for pointing
 		   this out.  We also set it initially without group
 		   access because of a similar race condition. */
 		fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
-		if (fd2 == -1) {
-			rprintf(FERROR,"mkstemp %s failed: %s\n",fnametmp,strerror(errno));
-			receive_data(f_in,buf,-1,NULL,file->length);
-			if (buf) unmap_file(buf);
-			continue;
-		}
 
 		/* in most cases parent directories will already exist
 		   because their information should have been previously
 		   transferred, but that may not be the case with -R */
 		if (fd2 == -1 && relative_paths && errno == ENOENT && 
-		    create_directory_path(fnametmp) == 0) {
+		    create_directory_path(fnametmp, orig_umask) == 0) {
 			strlcpy(fnametmp, template, sizeof(fnametmp));
 			fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
 		}
 		if (fd2 == -1) {
-			rprintf(FERROR,"cannot create %s : %s\n",fnametmp,strerror(errno));
+			rprintf(FERROR,"mkstemp %s failed: %s\n",fnametmp,strerror(errno));
 			receive_data(f_in,buf,-1,NULL,file->length);
 			if (buf) unmap_file(buf);
 			if (fd1 != -1) close(fd1);
 			continue;
 		}
       
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsync.1	2002-02-07 05:21:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsync.1	2003-01-28 11:11:57.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsync" "1" "25 Jan 2002" "" "" 
+.TH "rsync" "1" "26 Jan 2003" "" "" 
 .SH "NAME" 
 rsync \- faster, flexible replacement for rcp
 .SH "SYNOPSIS" 
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST:DEST
 .PP 
@@ -12,12 +12,14 @@
 rsync [OPTION]\&.\&.\&. [USER@]HOST::SRC [DEST]
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST::DEST
 .PP 
 rsync [OPTION]\&.\&.\&. rsync://[USER@]HOST[:PORT]/SRC [DEST]
 .PP 
+rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. rsync://[USER@]HOST[:PORT]/DEST
+.PP 
 .SH "DESCRIPTION" 
 .PP 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speed up file transfers when the destination file already
 exists\&.
@@ -44,13 +46,13 @@
 .IP o 
 support for anonymous or authenticated rsync servers (ideal for
 mirroring)
 .PP 
 .SH "GENERAL" 
 .PP 
-There are six different ways of using rsync\&. They are:
+There are eight different ways of using rsync\&. They are:
 .PP 
 .IP o 
 for copying local files\&. This is invoked when neither
 source nor destination path contains a : separator
 .IP 
 .IP o 
@@ -69,13 +71,27 @@
 machine\&. This is invoked when the source path contains a ::
 separator or a rsync:// URL\&.
 .IP 
 .IP o 
 for copying from the local machine to a remote rsync
 server\&. This is invoked when the destination path contains a ::
-separator\&. 
+separator or a rsync:// URL\&.
+.IP 
+.IP o 
+for copying from a remote machine using a remote shell
+program as the transport, using rsync server on the remote
+machine\&.  This is invoked when the source path contains a ::
+separator and the --rsh=COMMAND (aka "-e COMMAND") option is
+also provided\&.
+.IP 
+.IP o 
+for copying from the local machine to a remote machine
+using a remote shell program as the transport, using rsync
+server on the remote machine\&.  This is invoked when the
+destination path contains a :: separator and the
+--rsh=COMMMAND option is also provided\&.
 .IP 
 .IP o 
 for listing files on a remote machine\&. This is done the
 same way as rsync transfers except that you leave off the
 local destination\&.  
 .PP 
@@ -83,17 +99,19 @@
 and destination paths must be local\&.
 .PP 
 .SH "SETUP" 
 .PP 
 See the file README for installation instructions\&.
 .PP 
-Once installed you can use rsync to any machine that you can use rsh
-to\&.  rsync uses rsh for its communications, unless both the source and
-destination are local\&.
+Once installed, you can use rsync to any machine that you can access via
+a remote shell (as well as some that you can access using the rsync
+daemon-mode protocol)\&.  For remote transfers, rsync typically uses rsh
+for its communications, but it may have been configured to use a
+different remote shell by default, such as ssh\&.
 .PP 
-You can also specify an alternative to rsh, either by using the -e
+You can also specify any remote shell you like, either by using the -e
 command line option, or by setting the RSYNC_RSH environment variable\&.
 .PP 
 One common substitute is to use ssh, which offers a high degree of
 security\&.
 .PP 
 Note that rsync must be installed on both the source and destination
@@ -148,27 +166,27 @@
 .PP 
 this would list all the anonymous rsync modules available on the host
 somehost\&.mydomain\&.com\&.  (See the following section for more details\&.)
 .PP 
 .SH "CONNECTING TO AN RSYNC SERVER" 
 .PP 
-It is also possible to use rsync without using rsh or ssh as the
+It is also possible to use rsync without a remote shell as the
 transport\&. In this case you will connect to a remote rsync server
 running on TCP port 873\&. 
 .PP 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
 your web proxy\&.  Note that your web proxy\'s configuration must allow
 proxying to port 873\&.
 .PP 
-Using rsync in this way is the same as using it with rsh or ssh except
+Using rsync in this way is the same as using it with a remote shell except
 that:
 .PP 
 .IP o 
 you use a double colon :: instead of a single colon to
-separate the hostname from the path\&. 
+separate the hostname from the path or a rsync:// URL\&.
 .IP 
 .IP o 
 the remote server may print a message of the day when you
 connect\&.
 .IP 
 .IP o 
@@ -185,17 +203,73 @@
 the password you want to use or using the --password-file option\&. This
 may be useful when scripting rsync\&.
 .PP 
 WARNING: On some systems environment variables are visible to all
 users\&. On those systems using --password-file is recommended\&.
 .PP 
+.SH "CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" 
+.PP 
+It is sometimes useful to be able to set up file transfers using rsync
+server capabilities on the remote machine, while still using rsh or
+ssh for transport\&.  This is especially useful when you want to connect
+to a remote machine via ssh (for encryption or to get through a
+firewall), but you still want to have access to the rsync server
+features (see RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM,
+below)\&.  
+.PP 
+From the user\'s perspective, using rsync in this way is the same as
+using it to connect to an rsync server, except that you must
+explicitly set the remote shell program on the command line with
+--rsh=COMMAND\&.  (Setting RSYNC_RSH in the environment will not turn on
+this functionality\&.)
+.PP 
+In order to distinguish between the remote-shell user and the rsync
+server user, you can use \'-l user\' on your remote-shell command:
+.PP 
+.RS 
+rsync -av --rsh="ssh -l ssh-user" rsync-user@host::module[/path] local-path
+.RE 
+.PP 
+The "ssh-user" will be used at the ssh level; the "rsync-user" will be
+used to check against the rsyncd\&.conf on the remote host\&.
+.PP 
 .SH "RUNNING AN RSYNC SERVER" 
 .PP 
-An rsync server is configured using a config file which by default is
-called /etc/rsyncd\&.conf\&. Please see the rsyncd\&.conf(5) man page for more
-information\&. 
+An rsync server is configured using a config file\&.  Please see the 
+rsyncd\&.conf(5) man page for more information\&.  By default the configuration
+file is called /etc/rsyncd\&.conf, unless rsync is running over a remote
+shell program and is not running as root; in that case, the default name
+is rsyncd\&.conf in the current directory on the remote computer 
+(typically $HOME)\&.
+.PP 
+.SH "RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" 
+.PP 
+See the rsyncd\&.conf(5) man page for full information on the rsync
+server configuration file\&.  
+.PP 
+Several configuration options will not be available unless the remote
+user is root (e\&.g\&. chroot, setuid/setgid, etc\&.)\&.  There is no need to
+configure inetd or the services map to include the rsync server port
+if you run an rsync server only via a remote shell program\&.
+.PP 
+To run an rsync server out of a single-use ssh key, use the
+"command=\fICOMMAND\fP" syntax in the remote user\'s
+authorized_keys entry, where command would be
+.PP 
+.RS 
+rsync --server --daemon \&.
+.RE 
+.PP 
+NOTE: rsync\'s argument parsing expects the trailing "\&.", so make sure
+that it\'s there\&.  If you want to use a rsyncd\&.conf(5)-style
+configuration file other than the default, you can added a
+--config option to the \fIcommand\fP:
+.PP 
+.RS 
+rsync --server --daemon --config=\fIfile\fP \&.
+.RE 
 .PP 
 .SH "EXAMPLES" 
 .PP 
 Here are some examples of how I use rsync\&.
 .PP 
 To backup my wife\'s home directory, which consists of large MS Word
@@ -245,18 +319,18 @@
 .nf 
  
 
  -v, --verbose               increase verbosity
  -q, --quiet                 decrease verbosity
  -c, --checksum              always checksum
- -a, --archive               archive mode
+ -a, --archive               archive mode, equivalent to -rlptgoD
  -r, --recursive             recurse into directories
  -R, --relative              use relative path names
  -b, --backup                make backups (default ~ suffix)
      --backup-dir            make backups into this directory
-     --suffix=SUFFIX         override backup suffix
+     --suffix=SUFFIX         define backup suffix
  -u, --update                update only (don\'t overwrite newer files)
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            copy the referent of symlinks
      --copy-unsafe-links     copy links outside the source tree
      --safe-links            ignore links outside the destination tree
  -H, --hard-links            preserve hard links
@@ -268,13 +342,13 @@
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy whole files, no incremental checks
      --no-whole-file         turn off --whole-file
  -x, --one-file-system       don\'t cross filesystem boundaries
  -B, --block-size=SIZE       checksum blocking size (default 700)
- -e, --rsh=COMMAND           specify rsh replacement
+ -e, --rsh=COMMAND           specify the remote shell to use
      --rsync-path=PATH       specify path to rsync on the remote machine
  -C, --cvs-exclude           auto ignore files in the same way CVS does
      --existing              only update files that already exist
      --ignore-existing       ignore files that already exist on the receiving side
      --delete                delete files that don\'t exist on the sending side
      --delete-excluded       also delete excluded files on the receiving side
@@ -287,12 +361,13 @@
      --timeout=TIME          set IO timeout in seconds
  -I, --ignore-times          don\'t exclude files that match length and time
      --size-only             only use file size when determining if a file should be transferred
      --modify-window=NUM     Timestamp window (seconds) for file match (default=0)
  -T  --temp-dir=DIR          create temporary files in directory DIR
      --compare-dest=DIR      also compare destination files relative to DIR
+     --link-dest=DIR         create hardlinks to DIR for unchanged files
  -P                          equivalent to --partial --progress
  -z, --compress              compress file data
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     exclude patterns listed in FILE
      --include=PATTERN       don\'t exclude files matching PATTERN
      --include-from=FILE     don\'t exclude patterns listed in FILE
@@ -364,14 +439,14 @@
 .IP 
 .IP "\fB--modify-window\fP" 
 When comparing two timestamps rsync treats
 the timestamps as being equal if they are within the value of
 modify_window\&. This is normally zero, but you may find it useful to
 set this to a larger value in some situations\&. In particular, when
-transferring to/from FAT filesystems which cannot represent times with
-a 1 second resolution this option is useful\&.
+transferring to Windows FAT filesystems which cannot represent times
+with a 1 second resolution --modify-window=1 is useful\&.
 .IP 
 .IP "\fB-c, --checksum\fP" 
 This forces the sender to checksum all files using
 a 128-bit MD4 checksum before transfer\&. The checksum is then
 explicitly checked on the receiver and any files of the same name
 which already exist and have the same checksum and size on the
@@ -425,17 +500,22 @@
 renamed with a ~ extension as each file is transferred\&.  You can
 control the backup suffix using the --suffix option\&.
 .IP 
 .IP "\fB--backup-dir=DIR\fP" 
 In combination with the --backup option, this
 tells rsync to store all backups in the specified directory\&. This is
-very useful for incremental backups\&.
+very useful for incremental backups\&.  You can additionally
+specify a backup suffix using the --suffix option
+(otherwise the files backed up in the specified directory
+will keep their original filenames)\&.
 .IP 
 .IP "\fB--suffix=SUFFIX\fP" 
 This option allows you to override the default
 backup suffix used with the -b option\&. The default is a ~\&.
+If --backup-dir and --suffix are both specified,
+the SUFFIX is appended to the filename even in the backup directory\&.
 .IP 
 .IP "\fB-u, --update\fP" 
 This forces rsync to skip any files for which the
 destination file already exists and has a date later than the source
 file\&.
 .IP 
@@ -485,13 +565,15 @@
 This option causes rsync to update the remote
 permissions to be the same as the local permissions\&.
 .IP 
 .IP "\fB-o, --owner\fP" 
 This option causes rsync to set the owner of the
 destination file to be the same as the source file\&.  On most systems,
-only the super-user can set file ownership\&.  
+only the super-user can set file ownership\&.  Note that if the remote system
+is a daemon using chroot, the --numeric-ids option is implied because the
+remote system cannot get access to the usernames from /etc/passwd\&.
 .IP 
 .IP "\fB-g, --group\fP" 
 This option causes rsync to set the group of the
 destination file to be the same as the source file\&.  If the receiving
 program is not running as the super-user, only groups that the
 receiver is a member of will be preserved (by group name, not group id
@@ -559,18 +641,19 @@
 destination\&.  You can override this with the --ignore-errors option\&.
 .IP 
 .IP "\fB--delete-excluded\fP" 
 In addition to deleting the files on the
 receiving side that are not on the sending side, this tells rsync to also
 delete any files on the receiving side that are excluded (see --exclude)\&.
+Implies --delete\&.
 .IP 
 .IP "\fB--delete-after\fP" 
 By default rsync does file deletions before
 transferring files to try to ensure that there is sufficient space on
 the receiving filesystem\&. If you want to delete after transferring
-then use the --delete-after switch\&.
+then use the --delete-after switch\&. Implies --delete\&.
 .IP 
 .IP "\fB--ignore-errors\fP" 
 Tells --delete to go ahead and delete files
 even when there are IO errors\&.
 .IP 
 .IP "\fB--force\fP" 
@@ -583,17 +666,34 @@
 This controls the block size used in
 the rsync algorithm\&. See the technical report for details\&.
 .IP 
 .IP "\fB-e, --rsh=COMMAND\fP" 
 This option allows you to choose an alternative
 remote shell program to use for communication between the local and
-remote copies of rsync\&. By default, rsync will use rsh, but you may
-like to instead use ssh because of its high security\&.
+remote copies of rsync\&. Typically, rsync is configured to use rsh by
+default, but you may prefer to use ssh because of its high security\&.
+.IP 
+If this option is used with \fB[user@]host::module/path\fP, then the
+remote shell \fICOMMMAND\fP will be used to run an rsync server on the
+remote host, and all data will be transmitted through that remote
+shell connection, rather than through a direct socket connection to a
+running rsync server on the remote host\&.  See the section "CONNECTING
+TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" above\&.
+.IP 
+Command-line arguments are permitted in COMMAND provided that COMMAND is
+presented to rsync as a single argument\&.  For example:
+.IP 
+.RS 
+-e "ssh -p 2234"
+.RE 
+.IP 
+(Note that ssh users can alternately customize site-specific connect
+options in their \&.ssh/config file\&.)
 .IP 
 You can also choose the remote shell program using the RSYNC_RSH
-environment variable\&.
+environment variable, which accepts the same range of values as -e\&.
 .IP 
 See also the --blocking-io option which is affected by this option\&.
 .IP 
 .IP "\fB--rsync-path=PATH\fP" 
 Use this to specify the path to the copy of
 rsync on the remote machine\&. Useful when it\'s not in your path\&. Note
@@ -613,35 +713,37 @@
 .IP 
 .IP "\fB--exclude-from=FILE\fP" 
 This option is similar to the --exclude
 option, but instead it adds all exclude patterns listed in the file
 FILE to the exclude list\&.  Blank lines in FILE and lines starting with
 \';\' or \'#\' are ignored\&.
+If \fIFILE\fP is \fB-\fP the list will be read from standard input\&.
 .IP 
 .IP "\fB--include=PATTERN\fP" 
 This option tells rsync to not exclude the
 specified pattern of filenames\&. This is useful as it allows you to
 build up quite complex exclude/include rules\&.
 .IP 
 See the section of exclude patterns for information on the syntax of 
 this option\&.
 .IP 
 .IP "\fB--include-from=FILE\fP" 
 This specifies a list of include patterns
 from a file\&.
+If \fIFILE\fP is \fB-\fP the list will be read from standard input\&.
 .IP 
 .IP "\fB-C, --cvs-exclude\fP" 
 This is a useful shorthand for excluding a
 broad range of files that you often don\'t want to transfer between
 systems\&. It uses the same algorithm that CVS uses to determine if
 a file should be ignored\&.
 .IP 
 The exclude list is initialized to:
 .IP 
 .RS 
-RCS SCCS CVS CVS\&.adm RCSLOG cvslog\&.* tags TAGS \&.make\&.state
+RCS/ SCCS/ CVS/ \&.svn/ CVS\&.adm RCSLOG cvslog\&.* tags TAGS \&.make\&.state
 \&.nse_depinfo *~ #* \&.#* ,* *\&.old *\&.bak *\&.BAK *\&.orig *\&.rej \&.del-*
 *\&.a *\&.o *\&.obj *\&.so *\&.Z *\&.elc *\&.ln core
 .RE 
 .IP 
 then files listed in a $HOME/\&.cvsignore are added to the list and any
 files listed in the CVSIGNORE environment variable (space delimited)\&.
@@ -676,21 +778,28 @@
 transferred on the receiving side\&.  The default behavior is to create
 the temporary files in the receiving directory\&.
 .IP 
 .IP "\fB--compare-dest=DIR\fP" 
 This option instructs rsync to use DIR on
 the destination machine as an additional directory to compare destination
-files against when doing transfers\&.  This is useful for doing transfers to
-a new destination while leaving existing files intact, and then doing a
+files against when doing transfers if the files are missing in the
+destination directory\&.  This is useful for doing transfers to a new
+destination while leaving existing files intact, and then doing a
 flash-cutover when all files have been successfully transferred (for
 example by moving directories around and removing the old directory,
-although this requires also doing the transfer with -I to avoid skipping
-files that haven\'t changed)\&.  This option increases the usefulness of
---partial because partially transferred files will remain in the new
-temporary destination until they have a chance to be completed\&.  If DIR is
-a relative path, it is relative to the destination directory\&.
+although this skips files that haven\'t changed; see also --link-dest)\&.
+This option increases the usefulness of --partial because partially
+transferred files will remain in the new temporary destination until they
+have a chance to be completed\&.  If DIR is a relative path, it is relative
+to the destination directory\&.
+.IP 
+.IP "\fB--link-dest=DIR\fP" 
+This option behaves like \fB--compare-dest\fP but
+also will create hard links from \fIDIR\fP to the destination directory for
+unchanged files\&.  Files with changed ownership or permissions will not be
+linked\&.
 .IP 
 .IP "\fB-z, --compress\fP" 
 With this option, rsync compresses any data from
 the files that it sends to the destination machine\&.  This
 option is useful on slow links\&.  The compression method used is the
 same method that gzip uses\&.
@@ -724,13 +833,13 @@
 daemon may be accessed using the \fBhost::module\fP or
 \fBrsync://host/module/\fP syntax\&.
 .IP 
 If standard input is a socket then rsync will assume that it is being
 run via inetd, otherwise it will detach from the current terminal and
 become a background daemon\&.  The daemon will read the config file
-(/etc/rsyncd\&.conf) on each connect made by a client and respond to
+(rsyncd\&.conf) on each connect made by a client and respond to
 requests accordingly\&.  See the rsyncd\&.conf(5) man page for more
 details\&.
 .IP 
 .IP "\fB--no-detach\fP" 
 When running as a daemon, this option instructs
 rsync to not detach itself and become a background process\&.  This
@@ -747,25 +856,28 @@
 rsync server\&. The --address option allows you to specify a specific IP
 address (or hostname) to bind to\&. This makes virtual hosting possible
 in conjunction with the --config option\&.
 .IP 
 .IP "\fB--config=FILE\fP" 
 This specifies an alternate config file than
-the default /etc/rsyncd\&.conf\&. This is only relevant when --daemon is
-specified\&. 
+the default\&.  This is only relevant when --daemon is specified\&. 
+The default is /etc/rsyncd\&.conf unless the daemon is running over
+a remote shell program and the remote user is not root; in that case
+the default is rsyncd\&.conf in the current directory (typically $HOME)\&.
 .IP 
 .IP "\fB--port=PORT\fP" 
 This specifies an alternate TCP port number to use
 rather than the default port 873\&.
 .IP 
 .IP "\fB--blocking-io\fP" 
 This tells rsync to use blocking IO when launching
 a remote shell transport\&.  If -e or --rsh are not specified or are set to
 the default "rsh", this defaults to blocking IO, otherwise it defaults to
 non-blocking IO\&.  You may find the --blocking-io option is needed for some
-remote shells that can\'t handle non-blocking IO\&.  Ssh prefers blocking IO\&.
+remote shells that can\'t handle non-blocking IO\&.  (Note that ssh prefers
+non-blocking IO\&.)
 .IP 
 .IP "\fB--no-blocking-io\fP" 
 Turn off --blocking-io, for use when it is the
 default\&.
 .IP 
 .IP "\fB--log-format=FORMAT\fP" 
@@ -1037,12 +1149,16 @@
 ensure the rsync module they copy does not include symbolic links to
 \fB/etc/passwd\fP in the public section of the site\&.  Using
 \fB--copy-unsafe-links\fP will cause any links to be copied as the file
 they point to on the destination\&.  Using \fB--safe-links\fP will cause
 unsafe links to be ommitted altogether\&.
 .PP 
+Symbolic links are considered unsafe if they are absolute symlinks
+(start with \fB/\fP), empty, or if they contain enough \fB"\&.\&."\fP
+components to ascend from the directory being copied\&.
+.PP 
 .SH "DIAGNOSTICS" 
 .PP 
 rsync occasionally produces error messages that may seem a little
 cryptic\&. The one that seems to cause the most confusion is "protocol
 version mismatch - is your shell clean?"\&.
 .PP 
@@ -1114,14 +1230,14 @@
 The CVSIGNORE environment variable supplements any
 ignore patterns in \&.cvsignore files\&. See the --cvs-exclude option for
 more details\&.
 .IP 
 .IP "\fBRSYNC_RSH\fP" 
 The RSYNC_RSH environment variable allows you to
-override the default shell used as the transport for rsync\&. This can
-be used instead of the -e option\&.
+override the default shell used as the transport for rsync\&.  Command line
+options are permitted after the command name, just as in the -e option\&.
 .IP 
 .IP "\fBRSYNC_PROXY\fP" 
 The RSYNC_PROXY environment variable allows you to
 redirect your rsync client to use a web proxy when connecting to a
 rsync daemon\&. You should set RSYNC_PROXY to a hostname:port pair\&.
 .IP 
@@ -1139,34 +1255,35 @@
 The HOME environment variable is used to find the user\'s
 default \&.cvsignore file\&.
 .IP 
 .PP 
 .SH "FILES" 
 .PP 
-/etc/rsyncd\&.conf
+/etc/rsyncd\&.conf or rsyncd\&.conf
 .PP 
 .SH "SEE ALSO" 
 .PP 
 rsyncd\&.conf(5)
 .PP 
 .SH "DIAGNOSTICS" 
 .PP 
 .SH "BUGS" 
 .PP 
 times are transferred as unix time_t values
 .PP 
+When transferring to FAT filesystmes rsync may resync
+unmodified files\&.
+See the comments on the --modify-window option\&.
+.PP 
 file permissions, devices etc are transferred as native numerical
 values
 .PP 
 see also the comments on the --delete option
 .PP 
-Please report bugs! The rsync bug tracking system is online at
-http://rsync\&.samba\&.org/rsync/
-.PP 
-.SH "VERSION" 
-This man page is current for version 2\&.0 of rsync
+Please report bugs! See the website at
+http://rsync\&.samba\&.org/
 .PP 
 .SH "CREDITS" 
 .PP 
 rsync is distributed under the GNU public license\&.  See the file
 COPYING for details\&.
 .PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsyncd.conf.5	2001-08-31 16:12:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsyncd.conf.5	2003-01-27 11:07:18.000000000 +0800
@@ -1,19 +1,17 @@
-.TH "rsyncd\&.conf" "5" "12 Feb 1999" "" "" 
+.TH "rsyncd\&.conf" "5" "26 Jan 2003" "" "" 
 .SH "NAME" 
 rsyncd\&.conf \- configuration file for rsync server
 .SH "SYNOPSIS" 
 .PP 
 rsyncd\&.conf
 .PP 
 .SH "DESCRIPTION" 
 .PP 
 The rsyncd\&.conf file is the runtime configuration file for rsync when
-run with the --daemon option\&. When run in this way rsync becomes a
-rsync server listening on TCP port 873\&. Connections from rsync clients
-are accepted for either anonymous or authenticated rsync sessions\&. 
+run as an rsync server\&. 
 .PP 
 The rsyncd\&.conf file controls authentication, access, logging and
 available modules\&.
 .PP 
 .SH "FILE FORMAT" 
 .PP 
@@ -48,15 +46,18 @@
 .PP 
 The daemon must run with root privileges if you wish to use chroot, to
 bind to a port numbered under 1024 (as is the default 873), or to set
 file ownership\&.  Otherwise, it must just have permission to read and
 write the appropriate data, log, and lock files\&.
 .PP 
-You can launch it either via inetd or as a stand-alone daemon\&. If run
-as a daemon then just run the command "rsync --daemon" from a suitable
-startup script\&.
+You can launch it either via inetd, as a stand-alone daemon, or from
+an rsync client via a remote shell\&.  If run as a stand-alone daemon then
+just run the command "rsync --daemon" from a suitable startup script\&.
+If run from an rsync client via a remote shell (by specifying both the
+"-e/--rsh" option and server mode with "::" or "rsync://"), the --daemon
+option is automatically passed to the remote side\&.
 .PP 
 When run via inetd you should add a line like this to /etc/services:
 .PP 
 .RS 
 rsync           873/tcp
 .RE 
@@ -69,13 +70,13 @@
 .PP 
 Replace "/usr/bin/rsync" with the path to where you have rsync installed on
 your system\&.  You will then need to send inetd a HUP signal to tell it to
 reread its config file\&.
 .PP 
 Note that you should not send the rsync server a HUP signal to force
-it to reread the \f(CW/etc/rsyncd\&.conf\fP\&. The file is re-read on each client
+it to reread the \f(CWrsyncd\&.conf\fP file\&. The file is re-read on each client
 connection\&. 
 .PP 
 .SH "GLOBAL OPTIONS" 
 .PP 
 The first parameters in the file (before a [module] header) are the
 global parameters\&. 
@@ -131,37 +132,39 @@
 that is displayed next to the module name when clients obtain a list
 of available modules\&. The default is no comment\&.
 .IP 
 .IP "\fBpath\fP" 
 The "path" option specifies the directory in the servers
 filesystem to make available in this module\&.  You must specify this option
-for each module in \f(CW/etc/rsyncd\&.conf\fP\&.
+for each module in \f(CWrsyncd\&.conf\fP\&.
 .IP 
 .IP "\fBuse chroot\fP" 
 If "use chroot" is true, the rsync server will chroot
 to the "path" before starting the file transfer with the client\&.  This has
 the advantage of extra protection against possible implementation security
-holes, but it has the disadvantages of requiring super-user privileges and
+holes, but it has the disadvantages of requiring super-user privileges, 
 of not being able to follow symbolic links outside of the new root path
-when reading\&.  When "use chroot" is false, for security reasons
-symlinks may only be relative paths pointing to other files within the
-root path, and leading slashes are removed from absolute paths\&.  The
-default for "use chroot" is true\&.
+when reading, and of implying the --numeric-ids option because /etc/passwd
+becomes inaccessible\&.  When "use chroot" is false, for security reasons
+symlinks may only be relative paths pointing to other files within the root
+path, and leading slashes are removed from absolute paths\&.  The default for
+"use chroot" is true\&.
 .IP 
 .IP "\fBmax connections\fP" 
 The "max connections" option allows you to
-specify the maximum number of simultaneous connections you will allow
-to this module of your rsync server\&. Any clients connecting when the
-maximum has been reached will receive a message telling them to try
-later\&.  The default is 0 which means no limit\&.
+specify the maximum number of simultaneous connections you will allow\&.
+Any clients connecting when the maximum has been reached will receive a
+message telling them to try later\&.  The default is 0 which means no limit\&.
+See also the "lock file" option\&.
 .IP 
 .IP "\fBlock file\fP" 
 The "lock file" option specifies the file to use to
 support the "max connections" option\&. The rsync server uses record
 locking on this file to ensure that the max connections limit is not
-exceeded\&. The default is \f(CW/var/run/rsyncd\&.lock\fP\&.
+exceeded for the modules sharing the lock file\&. 
+The default is \f(CW/var/run/rsyncd\&.lock\fP\&.
 .IP 
 .IP "\fBread only\fP" 
 The "read only" option determines whether clients
 will be able to upload files or not\&. If "read only" is true then any
 attempted uploads will fail\&. If "read only" is false then uploads will
 be possible if file permissions on the server allow them\&. The default
@@ -185,49 +188,50 @@
 file transfers to and from that module should take place as when the daemon
 was run as root\&. This complements the "uid" option\&. The default is gid -2,
 which is normally the group "nobody"\&.
 .IP 
 .IP "\fBexclude\fP" 
 The "exclude" option allows you to specify a space
-separated list of patterns to add to the exclude list\&. This is
-equivalent to the client specifying these patterns with the --exclude
-option except that the exclude list is not passed to the client and
-thus only apply on the server\&.  Only one "exclude" option may be
-specified, but you can use "-" and "+" before patterns to specify
-exclude/include\&.
+separated list of patterns to add to the exclude list\&. This is equivalent
+to the client specifying these patterns with the --exclude option, except
+that the exclude list is not passed to the client and thus only applies on
+the server: that is, it excludes files received by a client when receiving
+from a server and files deleted on a server when sending to a server, but
+it doesn\'t exclude files sent from a client when sending to a server or
+files deleted on a client when receiving from a server\&.  
+Only one "exclude" option may be specified, but
+you can use "-" and "+" before patterns to specify exclude/include\&.
 .IP 
 Note that this option is not designed with strong security in
 mind, it is quite possible that a client may find a way to bypass this
 exclude list\&. If you want to absolutely ensure that certain files
 cannot be accessed then use the uid/gid options in combination with
 file permissions\&.
 .IP 
 .IP "\fBexclude from\fP" 
 The "exclude from" option specifies a filename
 on the server that contains exclude patterns, one per line\&. This is
 equivalent to the client specifying the --exclude-from option with a
-equivalent file except that the resulting exclude patterns are not
-passed to the client and thus only apply on the server\&. See also the
-note about security for the exclude option above\&.
+equivalent file except that it applies only on the server\&.  See also
+the "exclude" option above\&.
 .IP 
 .IP "\fBinclude\fP" 
 The "include" option allows you to specify a space
 separated list of patterns which rsync should not exclude\&. This is
 equivalent to the client specifying these patterns with the --include
-option\&.  This is useful as it allows you to build up quite complex
-exclude/include rules\&.  Only one "include" option may be specified, but you
-can use "+" and "-" before patterns to switch include/exclude\&.
-.IP 
-See the section of exclude patterns in the rsync man page for information
-on the syntax of this option\&.
+option except that it applies only on the server\&.  This is useful as it
+allows you to build up quite complex exclude/include rules\&.  Only one
+"include" option may be specified, but you can use "+" and "-" before
+patterns to switch include/exclude\&.  See also the "exclude" option above\&.
 .IP 
 .IP "\fBinclude from\fP" 
 The "include from" option specifies a filename
 on the server that contains include patterns, one per line\&. This is
 equivalent to the client specifying the --include-from option with a
-equivalent file\&.
+equivalent file except that it applies only on the server\&.  See also
+the "exclude" option above\&.
 .IP 
 .IP "\fBauth users\fP" 
 The "auth users" option specifies a comma and
 space separated list of usernames that will be allowed to connect to
 this module\&. The usernames do not need to exist on the local
 system\&. The usernames may also contain shell wildcard characters\&. If
@@ -235,12 +239,17 @@
 username and password to connect to the module\&. A challenge response
 authentication protocol is used for this exchange\&. The plain text
 usernames are passwords are stored in the file specified by the
 "secrets file" option\&. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync")\&.
 .IP 
+See also the \fBCONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL
+PROGRAM\fP section in rsync(1) for information on how handle an
+rsyncd\&.conf-level username that differs from the remote-shell-level
+username when using a remote shell to connect to a rsync server\&.
+.IP 
 .IP "\fBsecrets file\fP" 
 The "secrets file" option specifies the name of
 a file that contains the username:password pairs used for
 authenticating this module\&. This file is only consulted if the "auth
 users" option is specified\&. The file is line based and contains
 username:password pairs separated by a single colon\&. Any line starting
@@ -267,35 +276,49 @@
 hostname and IP address\&. If none of the patterns match then the
 connection is rejected\&.
 .IP 
 Each pattern can be in one of five forms:
 .IP 
 .IP o 
-a dotted decimal IP address\&. In this case the incoming machines
-IP address must match exactly\&.
+a dotted decimal IPv4 address of the form a\&.b\&.c\&.d, or an IPv6 address
+of the form a:b:c::d:e:f\&. In this case the incoming machine\'s IP address
+must match exactly\&.
 .IP 
 .IP o 
-a address/mask in the form a\&.b\&.c\&.d/n were n is the number of
-one bits in in the netmask\&. All IP addresses which match the masked
-IP address will be allowed in\&.
+an address/mask in the form ipaddr/n where ipaddr is the IP address
+and n is the number of one bits in the netmask\&.  All IP addresses which
+match the masked IP address will be allowed in\&.
 .IP 
 .IP o 
-a address/mask in the form a\&.b\&.c\&.d/e\&.f\&.g\&.h where e\&.f\&.g\&.h is a
-netmask in dotted decimal notation\&. All IP addresses which match the masked
-IP address will be allowed in\&.
+an address/mask in the form ipaddr/maskaddr where ipaddr is the
+IP address and maskaddr is the netmask in dotted decimal notation for IPv4,
+or similar for IPv6, e\&.g\&. ffff:ffff:ffff:ffff:: instead of /64\&. All IP
+addresses which match the masked IP address will be allowed in\&.
 .IP 
 .IP o 
 a hostname\&. The hostname as determined by a reverse lookup will
 be matched (case insensitive) against the pattern\&. Only an exact
 match is allowed in\&.
 .IP 
 .IP o 
 a hostname pattern using wildcards\&. These are matched using the
 same rules as normal unix filename matching\&. If the pattern matches
 then the client is allowed in\&.
 .IP 
+Note IPv6 link-local addresses can have a scope in the address specification:
+.IP 
+.RS 
+fe80::1%link1
+.RE 
+.RS 
+fe80::%link1/64
+.RE 
+.RS 
+fe80::%link1/ffff:ffff:ffff:ffff::
+.RE 
+.IP 
 You can also combine "hosts allow" with a separate "hosts deny"
 option\&. If both options are specified then the "hosts allow" option s
 checked first and a match results in the client being able to
 connect\&. The "hosts deny" option is then checked and a match means
 that the host is rejected\&. If the host does not match either the 
 "hosts allow" or the "hosts deny" patterns then it is allowed to
@@ -492,13 +515,13 @@
 tridge:mypass 
 .br 
 susan:herpass
 .PP 
 .SH "FILES" 
 .PP 
-/etc/rsyncd\&.conf
+/etc/rsyncd\&.conf or rsyncd\&.conf
 .PP 
 .SH "SEE ALSO" 
 .PP 
 rsync(1)
 .PP 
 .SH "DIAGNOSTICS" 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsyncd.conf.yo	2001-08-31 16:12:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsyncd.conf.yo	2003-01-27 11:07:18.000000000 +0800
@@ -1,19 +1,17 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(12 Feb 1999)()()
+manpage(rsyncd.conf)(5)(26 Jan 2003)()()
 manpagename(rsyncd.conf)(configuration file for rsync server)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
 
 The rsyncd.conf file is the runtime configuration file for rsync when
-run with the --daemon option. When run in this way rsync becomes a
-rsync server listening on TCP port 873. Connections from rsync clients
-are accepted for either anonymous or authenticated rsync sessions. 
+run as an rsync server. 
 
 The rsyncd.conf file controls authentication, access, logging and
 available modules.
 
 manpagesection(FILE FORMAT)
 
@@ -48,15 +46,18 @@
 
 The daemon must run with root privileges if you wish to use chroot, to
 bind to a port numbered under 1024 (as is the default 873), or to set
 file ownership.  Otherwise, it must just have permission to read and
 write the appropriate data, log, and lock files.
 
-You can launch it either via inetd or as a stand-alone daemon. If run
-as a daemon then just run the command "rsync --daemon" from a suitable
-startup script.
+You can launch it either via inetd, as a stand-alone daemon, or from
+an rsync client via a remote shell.  If run as a stand-alone daemon then
+just run the command "rsync --daemon" from a suitable startup script.
+If run from an rsync client via a remote shell (by specifying both the
+"-e/--rsh" option and server mode with "::" or "rsync://"), the --daemon
+option is automatically passed to the remote side.
 
 When run via inetd you should add a line like this to /etc/services:
 
 quote(rsync           873/tcp)
 
 and a single line something like this to /etc/inetd.conf:
@@ -65,13 +66,13 @@
 
 Replace "/usr/bin/rsync" with the path to where you have rsync installed on
 your system.  You will then need to send inetd a HUP signal to tell it to
 reread its config file.
 
 Note that you should not send the rsync server a HUP signal to force
-it to reread the tt(/etc/rsyncd.conf). The file is re-read on each client
+it to reread the tt(rsyncd.conf) file. The file is re-read on each client
 connection. 
 
 manpagesection(GLOBAL OPTIONS)
 
 The first parameters in the file (before a [module] header) are the
 global parameters. 
@@ -124,34 +125,36 @@
 dit(bf(comment)) The "comment" option specifies a description string
 that is displayed next to the module name when clients obtain a list
 of available modules. The default is no comment.
 
 dit(bf(path)) The "path" option specifies the directory in the servers
 filesystem to make available in this module.  You must specify this option
-for each module in tt(/etc/rsyncd.conf).
+for each module in tt(rsyncd.conf).
 
 dit(bf(use chroot)) If "use chroot" is true, the rsync server will chroot
 to the "path" before starting the file transfer with the client.  This has
 the advantage of extra protection against possible implementation security
-holes, but it has the disadvantages of requiring super-user privileges and
+holes, but it has the disadvantages of requiring super-user privileges, 
 of not being able to follow symbolic links outside of the new root path
-when reading.  When "use chroot" is false, for security reasons
-symlinks may only be relative paths pointing to other files within the
-root path, and leading slashes are removed from absolute paths.  The
-default for "use chroot" is true.
+when reading, and of implying the --numeric-ids option because /etc/passwd
+becomes inaccessible.  When "use chroot" is false, for security reasons
+symlinks may only be relative paths pointing to other files within the root
+path, and leading slashes are removed from absolute paths.  The default for
+"use chroot" is true.
 
 dit(bf(max connections)) The "max connections" option allows you to
-specify the maximum number of simultaneous connections you will allow
-to this module of your rsync server. Any clients connecting when the
-maximum has been reached will receive a message telling them to try
-later.  The default is 0 which means no limit.
+specify the maximum number of simultaneous connections you will allow.
+Any clients connecting when the maximum has been reached will receive a
+message telling them to try later.  The default is 0 which means no limit.
+See also the "lock file" option.
 
 dit(bf(lock file)) The "lock file" option specifies the file to use to
 support the "max connections" option. The rsync server uses record
 locking on this file to ensure that the max connections limit is not
-exceeded. The default is tt(/var/run/rsyncd.lock).
+exceeded for the modules sharing the lock file. 
+The default is tt(/var/run/rsyncd.lock).
 
 dit(bf(read only)) The "read only" option determines whether clients
 will be able to upload files or not. If "read only" is true then any
 attempted uploads will fail. If "read only" is false then uploads will
 be possible if file permissions on the server allow them. The default
 is for all modules to be read only.
@@ -170,58 +173,64 @@
 dit(bf(gid)) The "gid" option specifies the group name or group id that
 file transfers to and from that module should take place as when the daemon
 was run as root. This complements the "uid" option. The default is gid -2,
 which is normally the group "nobody".
 
 dit(bf(exclude)) The "exclude" option allows you to specify a space
-separated list of patterns to add to the exclude list. This is
-equivalent to the client specifying these patterns with the --exclude
-option except that the exclude list is not passed to the client and
-thus only apply on the server.  Only one "exclude" option may be
-specified, but you can use "-" and "+" before patterns to specify
-exclude/include.
+separated list of patterns to add to the exclude list. This is equivalent
+to the client specifying these patterns with the --exclude option, except
+that the exclude list is not passed to the client and thus only applies on
+the server: that is, it excludes files received by a client when receiving
+from a server and files deleted on a server when sending to a server, but
+it doesn't exclude files sent from a client when sending to a server or
+files deleted on a client when receiving from a server.  
+Only one "exclude" option may be specified, but
+you can use "-" and "+" before patterns to specify exclude/include.
 
 Note that this option is not designed with strong security in
 mind, it is quite possible that a client may find a way to bypass this
 exclude list. If you want to absolutely ensure that certain files
 cannot be accessed then use the uid/gid options in combination with
 file permissions.
 
 dit(bf(exclude from)) The "exclude from" option specifies a filename
 on the server that contains exclude patterns, one per line. This is
 equivalent to the client specifying the --exclude-from option with a
-equivalent file except that the resulting exclude patterns are not
-passed to the client and thus only apply on the server. See also the
-note about security for the exclude option above.
+equivalent file except that it applies only on the server.  See also
+the "exclude" option above.
 
 dit(bf(include)) The "include" option allows you to specify a space
 separated list of patterns which rsync should not exclude. This is
 equivalent to the client specifying these patterns with the --include
-option.  This is useful as it allows you to build up quite complex
-exclude/include rules.  Only one "include" option may be specified, but you
-can use "+" and "-" before patterns to switch include/exclude.
-
-See the section of exclude patterns in the rsync man page for information
-on the syntax of this option.
+option except that it applies only on the server.  This is useful as it
+allows you to build up quite complex exclude/include rules.  Only one
+"include" option may be specified, but you can use "+" and "-" before
+patterns to switch include/exclude.  See also the "exclude" option above.
 
 dit(bf(include from)) The "include from" option specifies a filename
 on the server that contains include patterns, one per line. This is
 equivalent to the client specifying the --include-from option with a
-equivalent file.
+equivalent file except that it applies only on the server.  See also
+the "exclude" option above.
 
 dit(bf(auth users)) The "auth users" option specifies a comma and
 space separated list of usernames that will be allowed to connect to
 this module. The usernames do not need to exist on the local
 system. The usernames may also contain shell wildcard characters. If
 "auth users" is set then the client will be challenged to supply a
 username and password to connect to the module. A challenge response
 authentication protocol is used for this exchange. The plain text
 usernames are passwords are stored in the file specified by the
 "secrets file" option. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync").
 
+See also the bf(CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL
+PROGRAM) section in rsync(1) for information on how handle an
+rsyncd.conf-level username that differs from the remote-shell-level
+username when using a remote shell to connect to a rsync server.
+
 dit(bf(secrets file)) The "secrets file" option specifies the name of
 a file that contains the username:password pairs used for
 authenticating this module. This file is only consulted if the "auth
 users" option is specified. The file is line based and contains
 username:password pairs separated by a single colon. Any line starting
 with a hash (#) is considered a comment and is skipped. The passwords
@@ -245,32 +254,40 @@
 hostname and IP address. If none of the patterns match then the
 connection is rejected.
 
 Each pattern can be in one of five forms:
 
 itemize(
-  it() a dotted decimal IP address. In this case the incoming machines
-  IP address must match exactly.
-
-  it() a address/mask in the form a.b.c.d/n were n is the number of
-  one bits in in the netmask. All IP addresses which match the masked
-  IP address will be allowed in.
-
-  it() a address/mask in the form a.b.c.d/e.f.g.h where e.f.g.h is a
-  netmask in dotted decimal notation. All IP addresses which match the masked
-  IP address will be allowed in.
+  it() a dotted decimal IPv4 address of the form a.b.c.d, or an IPv6 address
+  of the form a:b:c::d:e:f. In this case the incoming machine's IP address
+  must match exactly.
+
+  it() an address/mask in the form ipaddr/n where ipaddr is the IP address
+  and n is the number of one bits in the netmask.  All IP addresses which
+  match the masked IP address will be allowed in.
+
+  it() an address/mask in the form ipaddr/maskaddr where ipaddr is the
+  IP address and maskaddr is the netmask in dotted decimal notation for IPv4,
+  or similar for IPv6, e.g. ffff:ffff:ffff:ffff:: instead of /64. All IP
+  addresses which match the masked IP address will be allowed in.
 
   it() a hostname. The hostname as determined by a reverse lookup will
   be matched (case insensitive) against the pattern. Only an exact
   match is allowed in.
 
   it() a hostname pattern using wildcards. These are matched using the
   same rules as normal unix filename matching. If the pattern matches
   then the client is allowed in.
 )
 
+Note IPv6 link-local addresses can have a scope in the address specification:
+
+quote(fe80::1%link1)
+quote(fe80::%link1/64)
+quote(fe80::%link1/ffff:ffff:ffff:ffff::)
+
 You can also combine "hosts allow" with a separate "hosts deny"
 option. If both options are specified then the "hosts allow" option s
 checked first and a match results in the client being able to
 connect. The "hosts deny" option is then checked and a match means
 that the host is rejected. If the host does not match either the 
 "hosts allow" or the "hosts deny" patterns then it is allowed to
@@ -427,13 +444,13 @@
 
 tridge:mypass nl()
 susan:herpass
 
 manpagefiles()
 
-/etc/rsyncd.conf
+/etc/rsyncd.conf or rsyncd.conf
 
 manpageseealso()
 
 rsync(1)
 
 manpagediagnostics()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsync.h	2002-03-25 15:29:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsync.h	2003-01-27 04:11:16.000000000 +0800
@@ -23,13 +23,14 @@
 #define True 1
 
 #define BLOCK_SIZE 700
 #define RSYNC_RSH_ENV "RSYNC_RSH"
 
 #define RSYNC_NAME "rsync"
-#define RSYNCD_CONF "/etc/rsyncd.conf"
+#define RSYNCD_SYSCONF "/etc/rsyncd.conf"
+#define RSYNCD_USERCONF "rsyncd.conf"
 
 #define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
 #define URL_PREFIX "rsync://"
 
 #define BACKUP_SUFFIX "~"
 
@@ -327,12 +328,16 @@
 #endif
 
 #ifndef INADDR_NONE
 #define INADDR_NONE 0xffffffff
 #endif
 
+#ifndef IN_LOOPBACKNET
+#define IN_LOOPBACKNET 127
+#endif
+
 struct file_struct {
 	unsigned flags;
 	time_t modtime;
 	OFF_T length;
 	mode_t mode;
 
@@ -366,25 +371,25 @@
 	int malloced;
 	struct file_struct **files;
 	struct string_area *string_area;
 };
 
 struct sum_buf {
-	OFF_T offset;		/* offset in file of this chunk */
-	int len;		/* length of chunk of file */
-	int i;			/* index of this chunk */
-	uint32 sum1;	        /* simple checksum */
-	char sum2[SUM_LENGTH];	/* checksum  */
+	OFF_T offset;		/**< offset in file of this chunk */
+	int len;		/**< length of chunk of file */
+	int i;			/**< index of this chunk */
+	uint32 sum1;	        /**< simple checksum */
+	char sum2[SUM_LENGTH];	/**< checksum  */
 };
 
 struct sum_struct {
-	OFF_T flength;		/* total file length */
-	size_t count;		/* how many chunks */
-	size_t remainder;	/* flength % block_length */
-	size_t n;		/* block_length */
-	struct sum_buf *sums;	/* points to info for each chunk */
+	OFF_T flength;		/**< total file length */
+	size_t count;		/**< how many chunks */
+	size_t remainder;	/**< flength % block_length */
+	size_t n;		/**< block_length */
+	struct sum_buf *sums;	/**< points to info for each chunk */
 };
 
 struct map_struct {
 	char *p;
 	int fd,p_size,p_len;
 	OFF_T file_size, p_offset, p_fd_offset;
@@ -611,10 +616,16 @@
 #ifndef HAVE_INET_NTOP
 const char *                 
 inet_ntop(int af, const void *src, char *dst, size_t size);
 #endif /* !HAVE_INET_NTOP */
 
 #ifndef HAVE_INET_PTON
-int isc_net_pton(int af, const char *src, void *dst);
+int inet_pton(int af, const char *src, void *dst);
+#endif
+
+#ifdef MAINTAINER_MODE
+const char *get_panic_action(void);
 #endif
 
 #define UNUSED(x) x __attribute__((__unused__))
+
+extern const char *io_write_phase, *io_read_phase;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/rsync.yo	2002-02-07 05:20:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/rsync.yo	2003-01-28 11:11:57.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(25 Jan 2002)()()
+manpage(rsync)(1)(26 Jan 2003)()()
 manpagename(rsync)(faster, flexible replacement for rcp)
 manpagesynopsis()
 
 rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
 
 rsync [OPTION]... [USER@]HOST:SRC DEST
@@ -12,12 +12,14 @@
 rsync [OPTION]... [USER@]HOST::SRC [DEST]
 
 rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST
 
 rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
 
+rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST
+
 manpagedescription()
 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speed up file transfers when the destination file already
 exists.
@@ -39,13 +41,13 @@
   it() support for anonymous or authenticated rsync servers (ideal for
        mirroring)
 )
 
 manpagesection(GENERAL)
 
-There are six different ways of using rsync. They are:
+There are eight different ways of using rsync. They are:
 
 itemize(
 	it() for copying local files. This is invoked when neither
 	     source nor destination path contains a : separator
 
 	it() for copying from the local machine to a remote machine using
@@ -60,13 +62,25 @@
 	it() for copying from a remote rsync server to the local
 	machine. This is invoked when the source path contains a ::
 	separator or a rsync:// URL.
 
 	it() for copying from the local machine to a remote rsync
 	server. This is invoked when the destination path contains a ::
-	separator. 
+	separator or a rsync:// URL.
+
+	it() for copying from a remote machine using a remote shell
+	program as the transport, using rsync server on the remote
+	machine.  This is invoked when the source path contains a ::
+	separator and the --rsh=COMMAND (aka "-e COMMAND") option is
+	also provided.
+
+	it() for copying from the local machine to a remote machine
+	using a remote shell program as the transport, using rsync
+	server on the remote machine.  This is invoked when the
+	destination path contains a :: separator and the
+	--rsh=COMMMAND option is also provided.
 
 	it() for listing files on a remote machine. This is done the
 	same way as rsync transfers except that you leave off the
 	local destination.  
 )
 
@@ -74,17 +88,19 @@
 and destination paths must be local.
 
 manpagesection(SETUP)
 
 See the file README for installation instructions.
 
-Once installed you can use rsync to any machine that you can use rsh
-to.  rsync uses rsh for its communications, unless both the source and
-destination are local.
+Once installed, you can use rsync to any machine that you can access via
+a remote shell (as well as some that you can access using the rsync
+daemon-mode protocol).  For remote transfers, rsync typically uses rsh
+for its communications, but it may have been configured to use a
+different remote shell by default, such as ssh.
 
-You can also specify an alternative to rsh, either by using the -e
+You can also specify any remote shell you like, either by using the -e
 command line option, or by setting the RSYNC_RSH environment variable.
 
 One common substitute is to use ssh, which offers a high degree of
 security.
 
 Note that rsync must be installed on both the source and destination
@@ -132,27 +148,27 @@
 this would list all the anonymous rsync modules available on the host
 somehost.mydomain.com.  (See the following section for more details.)
 
 
 manpagesection(CONNECTING TO AN RSYNC SERVER)
 
-It is also possible to use rsync without using rsh or ssh as the
+It is also possible to use rsync without a remote shell as the
 transport. In this case you will connect to a remote rsync server
 running on TCP port 873. 
 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
 your web proxy.  Note that your web proxy's configuration must allow
 proxying to port 873.
 
-Using rsync in this way is the same as using it with rsh or ssh except
+Using rsync in this way is the same as using it with a remote shell except
 that:
 
 itemize(
 	it() you use a double colon :: instead of a single colon to
-	separate the hostname from the path. 
+	separate the hostname from the path or a rsync:// URL.
 
 	it() the remote server may print a message of the day when you
 	connect.
 
 	it() if you specify no path name on the remote server then the
 	list of accessible paths on the server will be shown.
@@ -167,17 +183,67 @@
 the password you want to use or using the --password-file option. This
 may be useful when scripting rsync.
 
 WARNING: On some systems environment variables are visible to all
 users. On those systems using --password-file is recommended.
 
+manpagesection(CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM)
+
+It is sometimes useful to be able to set up file transfers using rsync
+server capabilities on the remote machine, while still using rsh or
+ssh for transport.  This is especially useful when you want to connect
+to a remote machine via ssh (for encryption or to get through a
+firewall), but you still want to have access to the rsync server
+features (see RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM,
+below).  
+
+From the user's perspective, using rsync in this way is the same as
+using it to connect to an rsync server, except that you must
+explicitly set the remote shell program on the command line with
+--rsh=COMMAND.  (Setting RSYNC_RSH in the environment will not turn on
+this functionality.)
+
+In order to distinguish between the remote-shell user and the rsync
+server user, you can use '-l user' on your remote-shell command:
+
+quote(rsync -av --rsh="ssh -l ssh-user" rsync-user@host::module[/path] local-path)
+
+The "ssh-user" will be used at the ssh level; the "rsync-user" will be
+used to check against the rsyncd.conf on the remote host.
+
 manpagesection(RUNNING AN RSYNC SERVER)
 
-An rsync server is configured using a config file which by default is
-called /etc/rsyncd.conf. Please see the rsyncd.conf(5) man page for more
-information. 
+An rsync server is configured using a config file.  Please see the 
+rsyncd.conf(5) man page for more information.  By default the configuration
+file is called /etc/rsyncd.conf, unless rsync is running over a remote
+shell program and is not running as root; in that case, the default name
+is rsyncd.conf in the current directory on the remote computer 
+(typically $HOME).
+
+manpagesection(RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM)
+
+See the rsyncd.conf(5) man page for full information on the rsync
+server configuration file.  
+
+Several configuration options will not be available unless the remote
+user is root (e.g. chroot, setuid/setgid, etc.).  There is no need to
+configure inetd or the services map to include the rsync server port
+if you run an rsync server only via a remote shell program.
+
+To run an rsync server out of a single-use ssh key, use the
+"command=em(COMMAND)" syntax in the remote user's
+authorized_keys entry, where command would be
+
+quote(rsync --server --daemon .)
+
+NOTE: rsync's argument parsing expects the trailing ".", so make sure
+that it's there.  If you want to use a rsyncd.conf(5)-style
+configuration file other than the default, you can added a
+--config option to the em(command):
+
+quote(rsync --server --daemon --config=em(file) .)
 
 manpagesection(EXAMPLES)
 
 Here are some examples of how I use rsync.
 
 To backup my wife's home directory, which consists of large MS Word
@@ -216,18 +282,18 @@
 to the detailed description below for a complete description.
 
 verb(
  -v, --verbose               increase verbosity
  -q, --quiet                 decrease verbosity
  -c, --checksum              always checksum
- -a, --archive               archive mode
+ -a, --archive               archive mode, equivalent to -rlptgoD
  -r, --recursive             recurse into directories
  -R, --relative              use relative path names
  -b, --backup                make backups (default ~ suffix)
      --backup-dir            make backups into this directory
-     --suffix=SUFFIX         override backup suffix
+     --suffix=SUFFIX         define backup suffix
  -u, --update                update only (don't overwrite newer files)
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            copy the referent of symlinks
      --copy-unsafe-links     copy links outside the source tree
      --safe-links            ignore links outside the destination tree
  -H, --hard-links            preserve hard links
@@ -239,13 +305,13 @@
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy whole files, no incremental checks
      --no-whole-file         turn off --whole-file
  -x, --one-file-system       don't cross filesystem boundaries
  -B, --block-size=SIZE       checksum blocking size (default 700)
- -e, --rsh=COMMAND           specify rsh replacement
+ -e, --rsh=COMMAND           specify the remote shell to use
      --rsync-path=PATH       specify path to rsync on the remote machine
  -C, --cvs-exclude           auto ignore files in the same way CVS does
      --existing              only update files that already exist
      --ignore-existing       ignore files that already exist on the receiving side
      --delete                delete files that don't exist on the sending side
      --delete-excluded       also delete excluded files on the receiving side
@@ -258,12 +324,13 @@
      --timeout=TIME          set IO timeout in seconds
  -I, --ignore-times          don't exclude files that match length and time
      --size-only             only use file size when determining if a file should be transferred
      --modify-window=NUM     Timestamp window (seconds) for file match (default=0)
  -T  --temp-dir=DIR          create temporary files in directory DIR
      --compare-dest=DIR      also compare destination files relative to DIR
+     --link-dest=DIR         create hardlinks to DIR for unchanged files
  -P                          equivalent to --partial --progress
  -z, --compress              compress file data
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     exclude patterns listed in FILE
      --include=PATTERN       don't exclude files matching PATTERN
      --include-from=FILE     don't exclude patterns listed in FILE
@@ -326,14 +393,14 @@
 exactly.
 
 dit(bf(--modify-window)) When comparing two timestamps rsync treats
 the timestamps as being equal if they are within the value of
 modify_window. This is normally zero, but you may find it useful to
 set this to a larger value in some situations. In particular, when
-transferring to/from FAT filesystems which cannot represent times with
-a 1 second resolution this option is useful.
+transferring to Windows FAT filesystems which cannot represent times
+with a 1 second resolution --modify-window=1 is useful.
 
 dit(bf(-c, --checksum)) This forces the sender to checksum all files using
 a 128-bit MD4 checksum before transfer. The checksum is then
 explicitly checked on the receiver and any files of the same name
 which already exist and have the same checksum and size on the
 receiver are skipped.  This option can be quite slow.
@@ -369,16 +436,21 @@
 dit(bf(-b, --backup)) With this option preexisting destination files are
 renamed with a ~ extension as each file is transferred.  You can
 control the backup suffix using the --suffix option.
 
 dit(bf(--backup-dir=DIR)) In combination with the --backup option, this
 tells rsync to store all backups in the specified directory. This is
-very useful for incremental backups.
+very useful for incremental backups.  You can additionally
+specify a backup suffix using the --suffix option
+(otherwise the files backed up in the specified directory
+will keep their original filenames).
 
 dit(bf(--suffix=SUFFIX)) This option allows you to override the default
 backup suffix used with the -b option. The default is a ~.
+If --backup-dir and --suffix are both specified,
+the SUFFIX is appended to the filename even in the backup directory.
 
 dit(bf(-u, --update)) This forces rsync to skip any files for which the
 destination file already exists and has a date later than the source
 file.
 
 dit(bf(-l, --links)) When symlinks are encountered, recreate the
@@ -418,13 +490,15 @@
 
 dit(bf(-p, --perms)) This option causes rsync to update the remote
 permissions to be the same as the local permissions.
 
 dit(bf(-o, --owner)) This option causes rsync to set the owner of the
 destination file to be the same as the source file.  On most systems,
-only the super-user can set file ownership.  
+only the super-user can set file ownership.  Note that if the remote system
+is a daemon using chroot, the --numeric-ids option is implied because the
+remote system cannot get access to the usernames from /etc/passwd.
 
 dit(bf(-g, --group)) This option causes rsync to set the group of the
 destination file to be the same as the source file.  If the receiving
 program is not running as the super-user, only groups that the
 receiver is a member of will be preserved (by group name, not group id
 number).
@@ -482,17 +556,18 @@
 sending side causing a massive deletion of files on the
 destination.  You can override this with the --ignore-errors option.
 
 dit(bf(--delete-excluded)) In addition to deleting the files on the
 receiving side that are not on the sending side, this tells rsync to also
 delete any files on the receiving side that are excluded (see --exclude).
+Implies --delete.
 
 dit(bf(--delete-after)) By default rsync does file deletions before
 transferring files to try to ensure that there is sufficient space on
 the receiving filesystem. If you want to delete after transferring
-then use the --delete-after switch.
+then use the --delete-after switch. Implies --delete.
 
 dit(bf(--ignore-errors)) Tells --delete to go ahead and delete files
 even when there are IO errors.
 
 dit(bf(--force)) This options tells rsync to delete directories even if
 they are not empty when they are to be replaced by non-directories.  This
@@ -501,17 +576,32 @@
 
 dit(bf(-B , --block-size=BLOCKSIZE)) This controls the block size used in
 the rsync algorithm. See the technical report for details.
 
 dit(bf(-e, --rsh=COMMAND)) This option allows you to choose an alternative
 remote shell program to use for communication between the local and
-remote copies of rsync. By default, rsync will use rsh, but you may
-like to instead use ssh because of its high security.
+remote copies of rsync. Typically, rsync is configured to use rsh by
+default, but you may prefer to use ssh because of its high security.
+
+If this option is used with bf([user@]host::module/path), then the
+remote shell em(COMMMAND) will be used to run an rsync server on the
+remote host, and all data will be transmitted through that remote
+shell connection, rather than through a direct socket connection to a
+running rsync server on the remote host.  See the section "CONNECTING
+TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" above.
+
+Command-line arguments are permitted in COMMAND provided that COMMAND is
+presented to rsync as a single argument.  For example:
+
+quote(-e "ssh -p 2234")
+
+(Note that ssh users can alternately customize site-specific connect
+options in their .ssh/config file.)
 
 You can also choose the remote shell program using the RSYNC_RSH
-environment variable.
+environment variable, which accepts the same range of values as -e.
 
 See also the --blocking-io option which is affected by this option.
 
 dit(bf(--rsync-path=PATH)) Use this to specify the path to the copy of
 rsync on the remote machine. Useful when it's not in your path. Note
 that this is the full path to the binary, not just the directory that
@@ -528,31 +618,35 @@
 this option.
 
 dit(bf(--exclude-from=FILE)) This option is similar to the --exclude
 option, but instead it adds all exclude patterns listed in the file
 FILE to the exclude list.  Blank lines in FILE and lines starting with
 ';' or '#' are ignored.
+If em(FILE) is bf(-) the list will be read from standard input.
+
 
 dit(bf(--include=PATTERN)) This option tells rsync to not exclude the
 specified pattern of filenames. This is useful as it allows you to
 build up quite complex exclude/include rules.
 
 See the section of exclude patterns for information on the syntax of 
 this option.
 
 dit(bf(--include-from=FILE)) This specifies a list of include patterns
 from a file.
+If em(FILE) is bf(-) the list will be read from standard input.
+
 
 dit(bf(-C, --cvs-exclude)) This is a useful shorthand for excluding a
 broad range of files that you often don't want to transfer between
 systems. It uses the same algorithm that CVS uses to determine if
 a file should be ignored.
 
 The exclude list is initialized to:
 
-quote(RCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS .make.state
+quote(RCS/ SCCS/ CVS/ .svn/ CVS.adm RCSLOG cvslog.* tags TAGS .make.state
 .nse_depinfo *~ #* .#* ,* *.old *.bak *.BAK *.orig *.rej .del-*
 *.a *.o *.obj *.so *.Z *.elc *.ln core)
 
 then files listed in a $HOME/.cvsignore are added to the list and any
 files listed in the CVSIGNORE environment variable (space delimited).
 
@@ -583,21 +677,27 @@
 scratch directory when creating temporary copies of the files
 transferred on the receiving side.  The default behavior is to create
 the temporary files in the receiving directory.
 
 dit(bf(--compare-dest=DIR)) This option instructs rsync to use DIR on
 the destination machine as an additional directory to compare destination
-files against when doing transfers.  This is useful for doing transfers to
-a new destination while leaving existing files intact, and then doing a
+files against when doing transfers if the files are missing in the
+destination directory.  This is useful for doing transfers to a new
+destination while leaving existing files intact, and then doing a
 flash-cutover when all files have been successfully transferred (for
 example by moving directories around and removing the old directory,
-although this requires also doing the transfer with -I to avoid skipping
-files that haven't changed).  This option increases the usefulness of
---partial because partially transferred files will remain in the new
-temporary destination until they have a chance to be completed.  If DIR is
-a relative path, it is relative to the destination directory.
+although this skips files that haven't changed; see also --link-dest).
+This option increases the usefulness of --partial because partially
+transferred files will remain in the new temporary destination until they
+have a chance to be completed.  If DIR is a relative path, it is relative
+to the destination directory.
+
+dit(bf(--link-dest=DIR)) This option behaves like bf(--compare-dest) but
+also will create hard links from em(DIR) to the destination directory for
+unchanged files.  Files with changed ownership or permissions will not be
+linked.
 
 dit(bf(-z, --compress)) With this option, rsync compresses any data from
 the files that it sends to the destination machine.  This
 option is useful on slow links.  The compression method used is the
 same method that gzip uses.
 
@@ -627,13 +727,13 @@
 daemon may be accessed using the bf(host::module) or
 bf(rsync://host/module/) syntax.
 
 If standard input is a socket then rsync will assume that it is being
 run via inetd, otherwise it will detach from the current terminal and
 become a background daemon.  The daemon will read the config file
-(/etc/rsyncd.conf) on each connect made by a client and respond to
+(rsyncd.conf) on each connect made by a client and respond to
 requests accordingly.  See the rsyncd.conf(5) man page for more
 details.
 
 dit(bf(--no-detach)) When running as a daemon, this option instructs
 rsync to not detach itself and become a background process.  This
 option is required when running as a service on Cygwin, and may also
@@ -647,23 +747,26 @@
 when run as a daemon with the --daemon option or when connecting to a
 rsync server. The --address option allows you to specify a specific IP
 address (or hostname) to bind to. This makes virtual hosting possible
 in conjunction with the --config option.
 
 dit(bf(--config=FILE)) This specifies an alternate config file than
-the default /etc/rsyncd.conf. This is only relevant when --daemon is
-specified. 
+the default.  This is only relevant when --daemon is specified. 
+The default is /etc/rsyncd.conf unless the daemon is running over
+a remote shell program and the remote user is not root; in that case
+the default is rsyncd.conf in the current directory (typically $HOME).
 
 dit(bf(--port=PORT)) This specifies an alternate TCP port number to use
 rather than the default port 873.
 
 dit(bf(--blocking-io)) This tells rsync to use blocking IO when launching
 a remote shell transport.  If -e or --rsh are not specified or are set to
 the default "rsh", this defaults to blocking IO, otherwise it defaults to
 non-blocking IO.  You may find the --blocking-io option is needed for some
-remote shells that can't handle non-blocking IO.  Ssh prefers blocking IO.
+remote shells that can't handle non-blocking IO.  (Note that ssh prefers
+non-blocking IO.)
 
 dit(bf(--no-blocking-io)) Turn off --blocking-io, for use when it is the
 default.
 
 dit(bf(--log-format=FORMAT)) This allows you to specify exactly what the
 rsync client logs to stdout on a per-file basis. The log format is
@@ -907,12 +1010,16 @@
 ensure the rsync module they copy does not include symbolic links to
 bf(/etc/passwd) in the public section of the site.  Using
 bf(--copy-unsafe-links) will cause any links to be copied as the file
 they point to on the destination.  Using bf(--safe-links) will cause
 unsafe links to be ommitted altogether.
 
+Symbolic links are considered unsafe if they are absolute symlinks
+(start with bf(/)), empty, or if they contain enough bf("..")
+components to ascend from the directory being copied.
+
 manpagesection(DIAGNOSTICS)
 
 rsync occasionally produces error messages that may seem a little
 cryptic. The one that seems to cause the most confusion is "protocol
 version mismatch - is your shell clean?".
 
@@ -966,14 +1073,14 @@
 
 dit(bf(CVSIGNORE)) The CVSIGNORE environment variable supplements any
 ignore patterns in .cvsignore files. See the --cvs-exclude option for
 more details.
 
 dit(bf(RSYNC_RSH)) The RSYNC_RSH environment variable allows you to
-override the default shell used as the transport for rsync. This can
-be used instead of the -e option.
+override the default shell used as the transport for rsync.  Command line
+options are permitted after the command name, just as in the -e option.
 
 dit(bf(RSYNC_PROXY)) The RSYNC_PROXY environment variable allows you to
 redirect your rsync client to use a web proxy when connecting to a
 rsync daemon. You should set RSYNC_PROXY to a hostname:port pair.
 
 dit(bf(RSYNC_PASSWORD)) Setting RSYNC_PASSWORD to the required
@@ -988,34 +1095,35 @@
 default .cvsignore file.
 
 enddit()
 
 manpagefiles()
 
-/etc/rsyncd.conf
+/etc/rsyncd.conf or rsyncd.conf
 
 manpageseealso()
 
 rsyncd.conf(5)
 
 manpagediagnostics()
 
 manpagebugs()
 
 times are transferred as unix time_t values
 
+When transferring to FAT filesystmes rsync may resync
+unmodified files.
+See the comments on the --modify-window option.
+
 file permissions, devices etc are transferred as native numerical
 values
 
 see also the comments on the --delete option
 
-Please report bugs! The rsync bug tracking system is online at
-url(http://rsync.samba.org/rsync/)(http://rsync.samba.org/rsync/)
-
-manpagesection(VERSION)
-This man page is current for version 2.0 of rsync
+Please report bugs! See the website at
+url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/runtests.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/runtests.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/runtests.sh	2002-03-26 09:25:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/runtests.sh	2003-01-22 03:27:11.000000000 +0800
@@ -227,13 +227,14 @@
 	echo "PASS    $testbase"
 	passed=`expr $passed + 1`
 	maybe_discard_scratch
 	;;
     77)
 	# backticks will fill the whole file onto one line, which is a feature
-	echo "SKIP    $testbase (`cat \"$scratchdir/whyskipped\"`)"
+	whyskipped=`cat "$scratchdir/whyskipped"`
+	echo "SKIP    $testbase ($whyskipped)"
 	skipped=`expr $skipped + 1`
 	maybe_discard_scratch
 	;;
     78)
         # It failed, but we expected that.  don't dump out error logs, 
 	# because most users won't want to see them.  But do leave
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/sender.c	2002-01-26 07:07:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/sender.c	2002-04-09 14:03:50.000000000 +0800
@@ -25,15 +25,24 @@
 extern struct stats stats;
 extern int io_error;
 extern int dry_run;
 extern int am_server;
 
 
-/*
-  receive the checksums for a buffer
-  */
+/**
+ * @file
+ *
+ * The sender gets checksums from the generator, calculates deltas,
+ * and transmits them to the receiver.  The sender process runs on the
+ * machine holding the source files.
+ **/
+
+
+/**
+ * Receive the checksums for a buffer
+ **/
 static struct sum_struct *receive_sums(int f)
 {
 	struct sum_struct *s;
 	int i;
 	OFF_T offset = 0;
 
@@ -43,14 +52,14 @@
 	s->count = read_int(f);
 	s->n = read_int(f);
 	s->remainder = read_int(f);  
 	s->sums = NULL;
 
 	if (verbose > 3)
-		rprintf(FINFO,"count=%d n=%d rem=%d\n",
-			s->count,s->n,s->remainder);
+		rprintf(FINFO,"count=%ld n=%ld rem=%ld\n",
+			(long) s->count, (long) s->n, (long) s->remainder);
 
 	if (s->count == 0) 
 		return(s);
 
 	s->sums = (struct sum_buf *)malloc(sizeof(s->sums[0])*s->count);
 	if (!s->sums) out_of_memory("receive_sums");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/socket.c	2002-03-16 17:00:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/socket.c	2003-01-27 11:35:09.000000000 +0800
@@ -31,14 +31,16 @@
  * emulate it using the KAME implementation.
  **/
 
 #include "rsync.h"
 
 
-/* Establish a proxy connection on an open socket to a web roxy by
- * using the CONNECT method. */
+/**
+ * Establish a proxy connection on an open socket to a web proxy by
+ * using the HTTP CONNECT method.
+ **/
 static int establish_proxy_connection(int fd, char *host, int port)
 {
 	char buffer[1024];
 	char *cp;
 
 	snprintf(buffer, sizeof(buffer), "CONNECT %s:%d HTTP/1.0\r\n\r\n", host, port);
@@ -65,13 +67,13 @@
 		*cp = '\0';
 	if (strncmp(buffer, "HTTP/", 5) != 0) {
 		rprintf(FERROR, "bad response from proxy - %s\n",
 			buffer);
 		return -1;
 	}
-	for (cp = &buffer[5]; isdigit(*cp) || (*cp == '.'); cp++)
+	for (cp = &buffer[5]; isdigit(* (unsigned char *) cp) || (*cp == '.'); cp++)
 		;
 	while (*cp == ' ')
 		cp++;
 	if (*cp != '2') {
 		rprintf(FERROR, "bad response from proxy - %s\n",
 			buffer);
@@ -369,13 +371,13 @@
          *
          * We now return to your regularly scheduled programming.  */
 	return(getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&v, &l) == 0);
 }
 
 
-void start_accept_loop(int port, int (*fn)(int ))
+void start_accept_loop(int port, int (*fn)(int, int))
 {
 	int s;
 	extern char *bind_address;
 	extern int default_af_hint;
 
 	/* open an incoming socket */
@@ -424,17 +426,20 @@
 		   are produced, so this ensures that they are reaped */
 #ifdef WNOHANG
                 while (waitpid(-1, NULL, WNOHANG) > 0);
 #endif
 
 		if ((pid = fork()) == 0) {
+			int ret;
 			close(s);
 			/* open log file in child before possibly giving
 			   up privileges  */
 			log_open();
-			_exit(fn(fd));
+			ret = fn(fd, fd);
+			close_all();
+			_exit(ret);
 		} else if (pid < 0) {
 			rprintf(FERROR,
 				RSYNC_NAME
 				": could not create child server process: %s\n",
 				strerror(errno));
 			close(fd);
@@ -491,15 +496,15 @@
   {"SO_RCVTIMEO",       SOL_SOCKET,    SO_RCVTIMEO,     0,                 OPT_INT},
 #endif
   {NULL,0,0,0,0}};
 
 	
 
-/****************************************************************************
-set user socket options
-****************************************************************************/
+/**
+ * Set user socket options
+ **/
 void set_socket_options(int fd, char *options)
 {
 	char *tok;
 	if (!options || !*options) return;
 
 	options = strdup(options);
@@ -551,15 +556,15 @@
 				strerror(errno));
 	}
 
 	free(options);
 }
 
-/****************************************************************************
-become a daemon, discarding the controlling terminal
-****************************************************************************/
+/**
+ * Become a daemon, discarding the controlling terminal
+ **/
 void become_daemon(void)
 {
 	int i;
 
 	if (fork()) {
 		_exit(0);
@@ -583,20 +588,21 @@
 		close(i); 
 		open("/dev/null", O_RDWR);
 	}
 }
 
 
-/*******************************************************************
-this is like socketpair but uses tcp. It is used by the Samba
-regression test code
-The function guarantees that nobody else can attach to the socket,
-or if they do that this function fails and the socket gets closed
-returns 0 on success, -1 on failure
-the resulting file descriptors are symmetrical
- ******************************************************************/
+/**
+ * This is like socketpair but uses tcp. It is used by the Samba
+ * regression test code.
+ * 
+ * The function guarantees that nobody else can attach to the socket,
+ * or if they do that this function fails and the socket gets closed
+ * returns 0 on success, -1 on failure the resulting file descriptors
+ * are symmetrical.
+ **/
 static int socketpair_tcp(int fd[2])
 {
 	int listener;
 	struct sockaddr_in sock;
 	struct sockaddr_in sock2;
 	socklen_t socklen = sizeof(sock);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/syscall.c	2002-03-25 11:51:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/syscall.c	2003-01-27 04:09:02.000000000 +0800
@@ -26,12 +26,13 @@
 
 #include "rsync.h"
 
 extern int dry_run;
 extern int read_only;
 extern int list_only;
+extern int preserve_perms;
 
 #define CHECK_RO if (read_only || list_only) {errno = EROFS; return -1;}
 
 int do_unlink(char *fname)
 {
 	if (dry_run) return 0;
@@ -94,15 +95,19 @@
 	return open(pathname, flags, mode);
 }
 
 #if HAVE_CHMOD
 int do_chmod(const char *path, mode_t mode)
 {
+	int code;
 	if (dry_run) return 0;
 	CHECK_RO
-	return chmod(path, mode);
+	code = chmod(path, mode);
+	if ((code != 0) && preserve_perms)
+	    return code;
+	return 0;
 }
 #endif
 
 int do_rename(char *fname1, char *fname2)
 {
 	if (dry_run) return 0;
@@ -147,13 +152,13 @@
 	if (read_only) {errno = EROFS; return -1;}
 
 #if defined(HAVE_SECURE_MKSTEMP) && defined(HAVE_FCHMOD)
 	{
 		int fd = mkstemp(template);
 		if (fd == -1) return -1;
-		if (fchmod(fd, perms) != 0) {
+		if ((fchmod(fd, perms) != 0) && preserve_perms) {
 			close(fd);
 			unlink(template);
 			return -1;
 		}
 		return fd;
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/00-hello.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/00-hello.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/00-hello.test	2001-08-31 13:45:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/00-hello.test	2002-12-24 15:25:25.000000000 +0800
@@ -1,5 +1,5 @@
 #! /bin/sh
 
 echo $0 running
 
-"$rsync_bin" --version || exit 1
+$RSYNC --version || exit 1
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/chgrp.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/chgrp.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/chgrp.test	2002-03-25 11:01:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/chgrp.test	2002-11-06 02:35:59.000000000 +0800
@@ -28,11 +28,11 @@
     name="$fromdir/foo-$g"
     date > "$name"
     chgrp "$g" "$name" || fail "Can't chgrp"
 done
 sleep 2
 
-checkit "rsync -rtgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -rtgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
 exit 0
 # last [] may have failed but if we get here then we've won
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/chown.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/chown.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/chown.test	2002-03-22 14:07:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/chown.test	2002-12-24 15:25:25.000000000 +0800
@@ -28,11 +28,11 @@
 
 chown 5000 "$name1" || test_skipped "Can't chown (probably need root)"
 chown 5001 "$name2" || test_skipped "Can't chown (probably need root)"
 chgrp 5002 "$name1" || test_skipped "Can't chgrp (probably need root)"
 chgrp 5003 "$name2" || test_skipped "Can't chgrp (probably need root)"
 
-checkit "rsync -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
 exit 0
 # last [] may have failed but if we get here then we've won
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/daemon-gzip-download.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/daemon-gzip-download.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/daemon-gzip-download.test	2002-03-12 08:11:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/daemon-gzip-download.test	2003-01-22 04:19:53.000000000 +0800
@@ -20,12 +20,12 @@
 # the server.  This ought to exercise (exorcise?) a bug in 2.5.3.
 
 . "$suitedir/rsync.fns"
 
 build_rsyncd_conf
 
-RSYNC_CONNECT_PROG="$rsync_bin --config=$conf --daemon"
+RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
 hands_setup
-checkit "$rsync_bin -avvz localhost::test-from/ \"$TO/\"" "$FROM" "$TO"
+checkit "$RSYNC -avvz localhost::test-from/ \"$TO/\"" "$FROM" "$TO"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/daemon-gzip-upload.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/daemon-gzip-upload.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/daemon-gzip-upload.test	2002-03-12 08:09:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/daemon-gzip-upload.test	2003-01-25 11:45:40.000000000 +0800
@@ -14,12 +14,12 @@
 # server.  This ought to exercise (exorcise?) a bug in 2.5.3.
 
 . "$suitedir/rsync.fns"
 
 build_rsyncd_conf
 
-RSYNC_CONNECT_PROG="$rsync_bin --config=$conf --daemon"
+RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
 hands_setup
-checkit "$rsync_bin -avvz \"$FROM/\" localhost::test-to/" "$FROM" "$TO"
+checkit "$RSYNC -avvz \"$FROM/\" localhost::test-to/" "$FROM" "$TO"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/daemon.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/daemon.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/daemon.test	2001-09-06 14:30:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/daemon.test	2002-12-24 15:25:25.000000000 +0800
@@ -23,10 +23,10 @@
 # subtests fail and keep going.
 
 . "$suitedir/rsync.fns"
 
 build_rsyncd_conf
 
-RSYNC_CONNECT_PROG="$rsync_bin --config=$conf --daemon"
+RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
-$rsync_bin -v localhost::
+$RSYNC -v localhost::
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/devices.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/devices.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/devices.test	2002-03-22 14:09:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/devices.test	2002-12-24 15:25:25.000000000 +0800
@@ -19,11 +19,11 @@
 # TODO: Need to test whether hardlinks are possible on this OS/filesystem
 
 mkdir "$fromdir"
 mknod "$fromdir/char" c 42 69  || test_skipped "Can't create char device node unless root"
 mknod "$fromdir/block" b 42 69 || test_skipped "Can't create block device node unless root"
 
-checkit "rsync -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
 exit 0
 # last [] may have failed but if we get here then we've won
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/duplicates.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/duplicates.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/duplicates.test	2002-03-22 14:07:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/duplicates.test	2002-12-24 15:25:25.000000000 +0800
@@ -35,13 +35,13 @@
 name2="$fromdir/name2"
 echo "This is the file" > "$name1"
 ln -s "$name1" "$name2" || fail "can't create symlink"
 
 outfile="$scratchdir/rsync.out"
 
-checkit "rsync -avv \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
+checkit "$RSYNC -avv \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
     | tee "$outfile"
 
 # Make sure each file was only copied once...
 if [ `grep -c '^name1$' "$outfile"` != 1 ]
 then
     test_xfail "name1 was not copied exactly once"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/hardlinks.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/hardlinks.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/hardlinks.test	2002-01-11 15:11:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/hardlinks.test	2002-11-06 02:35:59.000000000 +0800
@@ -28,11 +28,11 @@
 name4="$fromdir/name4"
 echo "This is the file" > "$name1"
 ln "$name1" "$name2" || fail "Can't create hardlink"
 ln "$name2" "$name3" || fail "Can't create hardlink"
 cp "$name2" "$name4" || fail "Can't copy file"
 
-checkit "rsync -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
 exit 0
 # last [] may have failed but if we get here then we've won
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/longdir.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/longdir.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/longdir.test	2001-12-14 13:52:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/longdir.test	2003-01-11 16:19:24.000000000 +0800
@@ -8,12 +8,14 @@
 . "$suitedir/rsync.fns"
 
 # set -x
 
 hands_setup
 
-LONGDIR=${FROM}/This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job/This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job/This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job
+LONGNAME=This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job
+LONGDIR=$FROM/$LONGNAME/$LONGNAME/$LONGNAME
 
-makepath ${LONGDIR}
+makepath $LONGDIR || test_skipped "unable to create long directory"
+touch $LONGDIR/1 || test_skipped "unable to create files in long directory"
 date > ${LONGDIR}/1
 ls -la / > ${LONGDIR}/2
 checkit "$RSYNC --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/rsync.fns /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/rsync.fns
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/rsync.fns	2002-03-26 18:28:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/rsync.fns	2003-01-28 11:11:57.000000000 +0800
@@ -188,17 +188,14 @@
 
 pid file = $pidfile
 use chroot = no
 hosts allow = localhost, 127.0.0.1
 log file = $logfile
 
-# We don't know if this machine has "nobody" or "nogroup", so use the quasi-canonical
-# values of (uint16_t) -2. 
-
-uid = 65534
-gid = 65534
+uid = 0
+gid = 0
 
 [test-from]
 	path = $FROM
 	read only = yes
 
 [test-to]
@@ -250,12 +247,14 @@
 	    TEST_SYMLINK_CMD="$cmd $switch"
 	    # i wonder if break 2 is portable?
 	    break 2
 	fi
    done
 done
+# ok, now get rid of it
+rm "$scratchdir/testlink"
 
 
 if [ "x$TEST_SYMLINK_CMD" = 'x' ]
 then
     test_fail "Couldn't determine how to test for symlinks"
 else
@@ -273,7 +272,7 @@
 # We need to set the umask to be reproducible.  Note also that when we
 # do some daemon tests as root, we will setuid() and therefore the
 # directory has to be writable by the nobody user in some cases.  The
 # best thing is probably to explicitly chmod those directories after
 # creation.
  
-umask 022
\ No newline at end of file
+umask 022
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/symlink-ignore.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/symlink-ignore.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/testsuite/symlink-ignore.test	2002-03-15 09:08:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite/symlink-ignore.test	2002-12-24 15:25:25.000000000 +0800
@@ -13,13 +13,13 @@
 set -x
 
 build_symlinks || test_fail "failed to build symlinks"
 
 # Copy recursively, but without -l or -L or -a, and all the symlinks
 # should be missing.
-"$rsync_bin" -r "$fromdir/" "$todir" || test_fail "rsync returned $?"
+$RSYNC -r "$fromdir/" "$todir" || test_fail "$RSYNC returned $?"
 
 [ -f "${todir}/referent" ] || test_fail "referent was not copied"
 [ -d "${todir}/from" ] && test_fail "extra level of directories"
 if is_a_link "${todir}/dangling" 
 then 
     test_fail "dangling symlink was copied"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite: unsafe-byname.test
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/testsuite: unsafe-links.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/tls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/tls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/tls.c	2002-02-19 06:49:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/tls.c	2003-01-21 09:35:23.000000000 +0800
@@ -14,16 +14,15 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /**
- * \section tls
+ * @file tls.c
  *
- * tls -- Trivial recursive ls, for comparing two directories after
- * running an rsync.
+ * Trivial @c ls for comparing two directories after running an rsync.
  *
  * The problem with using the system's own ls is that some features
  * have little quirks that make directories look different when for
  * our purposes they're the same -- for example, the BSD braindamage
  * about setting the mode on symlinks based on your current umask.
  *
@@ -45,12 +43,13 @@
 #define PROGRAM "tls"
 
 /* These are to make syscall.o shut up. */
 int dry_run = 0;
 int read_only = 1;
 int list_only = 0;
+int preserve_perms = 0;
 
 
 static void failed (char const *what,
 		    char const *where)
 {
 	fprintf (stderr, PROGRAM ": %s %s: %s\n",
@@ -114,15 +113,15 @@
 	
 	/* TODO: Perhaps escape special characters in fname? */
 	
 	
 	/* NB: need to pass size as a double because it might be be
 	 * too large for a long. */
-	printf("%s %12.0f %6d.%-6d %6d %s %s%s\n",
+	printf("%s %12.0f %6ld.%-6ld %6d %s %s%s\n",
 	       permbuf, (double) buf.st_size,
-	       buf.st_uid, buf.st_gid,
+	       (long) buf.st_uid, (long) buf.st_gid,
 	       buf.st_nlink,
 	       datebuf, fname, linkbuf);
 }
 
 
 int main (int argc, char *argv[])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/TODO	2002-03-26 07:09:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/TODO	2003-01-28 00:33:47.000000000 +0800
@@ -1,10 +1,17 @@
 -*- indented-text -*-
 
 BUGS ---------------------------------------------------------------
 
+rsync-url barfs on upload
+
+  rsync foo rsync://localhost/transfer/
+
+  Fix the parser.
+
+
 There seems to be a bug with hardlinks
 
   mbp/2 build$ ls -l /tmp/a /tmp/b -i
   /tmp/a:
   total 32
   2568307 -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a1
@@ -70,13 +77,88 @@
   -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a5
   -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b1
   -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b2
   -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b3
 
 
-IMPORTANT ------------------------------------------------------------
+Progress indicator can produce corrupt output when transferring directories:
+
+  main/binary-arm/
+  main/binary-arm/admin/
+  main/binary-arm/base/
+  main/binary-arm/comm/8.56kB/s    0:00:52
+  main/binary-arm/devel/
+  main/binary-arm/doc/
+  main/binary-arm/editors/
+  main/binary-arm/electronics/s    0:00:53
+  main/binary-arm/games/
+  main/binary-arm/graphics/
+  main/binary-arm/hamradio/
+  main/binary-arm/interpreters/
+  main/binary-arm/libs/6.61kB/s    0:00:54
+  main/binary-arm/mail/
+  main/binary-arm/math/
+  main/binary-arm/misc/
+
+
+lchmod
+  I don't think we handle this properly on systems that don't have the
+  call.  Are there any such?
+
+
+Cross-test versions
+  Part of the regression suite should be making sure that we don't
+  break backwards compatibility: old clients vs new servers and so
+  on.  Ideally we would test the cross product of versions.  
+
+  It might be sufficient to test downloads from well-known public
+  rsync servers running different versions of rsync.  This will give
+  some testing and also be the most common case for having different
+  versions and not being able to upgrade.
+
+--no-blocking-io might be broken
+
+  in the same way as --no-whole-file; somebody needs to check.
+
+Do not rely on having a group called "nobody"
+
+  http://www.linuxbase.org/spec/refspecs/LSB_1.1.0/gLSB/usernames.html
+
+  On Debian it's "nogroup"
+
+Temporary file names can exceed max name length
+
+  Rsync creates temporary file names that are 10 characters longer
+  than the length of the file being transferred.  This creates
+  problems for operating systems have fairly short maximum lengths
+  (e.g., 32 characters for Stratus VOS). Even on operating systems
+  with long max lengths it can still be a problem as it is perfectly
+  reasonable to be using files with long names.
+
+
+DAEMON --------------------------------------------------------------
+
+server-imposed bandwidth limits
+
+rsyncd over ssh
+
+  There are already some patches to do this.
+
+  BitKeeper uses a server whose login shell is set to bkd.  That's
+  probably a reasonable approach.
+
+
+FEATURES ------------------------------------------------------------
+
+
+--dry-run is too dry
+
+  Mark Santcroos points out that -n fails to list files which have
+  only metadata changes, though it probably should.
+
+  There may be a Debian bug about this as well.
 
 
 use chroot
 
   If the platform doesn't support it, then don't even try.
 
@@ -89,22 +172,30 @@
 --files-from
 
   Avoids traversal.  Better option than a pile of --include statements
   for people who want to generate the file list using a find(1)
   command or a script.
 
+
+supplementary groups
+
+  Perhaps allow supplementary groups to be specified in rsyncd.conf;
+  then make the first one the primary gid and all the rest be
+  supplementary gids.
+
+
 File list structure in memory
 
   Rather than one big array, perhaps have a tree in memory mirroring
-  the directory tree.  
+  the directory tree.
 
   This might make sorting much faster!  (I'm not sure it's a big CPU
-  problem, mind you.)  
+  problem, mind you.)
 
   It might also reduce memory use in storing repeated directory names
-  -- again I'm not sure this is a problem.
+-- again I'm not sure this is a problem.
 
 Performance
 
   Traverse just one directory at a time.  Tridge says it's possible.
 
   At the moment rsync reads the whole file list into memory at the
@@ -119,13 +210,13 @@
   the same file.  Bad.
 
   I think duplicates are only a problem if they're both flowing
   through the pipeline at the same time.  For example we might have
   updated the first occurrence after reading the checksums for the
   second.  So possibly we just need to make sure that we don't have
-  both in the pipeline at the same time.  
+  both in the pipeline at the same time.
 
   Possibly if we did one directory at a time that would be sufficient.
 
   Alternatively we could pre-process the arguments to make sure no
   duplicates will ever be inserted.  There could be some bad cases
   when we're collapsing symlinks.
@@ -165,13 +256,13 @@
   make us allocate a huge amount of memory for large file lists.
 
 
 Hard-link handling
 
   At the moment hardlink handling is very expensive, so it's off by
-  default.  It does not need to be so.  
+  default.  It does not need to be so.
 
   Since most of the solutions are rather intertwined with the file
   list it is probably better to fix that first, although fixing
   hardlinks is possibly simpler.
 
   We can rule out hardlinked directories since they will probably
@@ -179,13 +270,13 @@
 
   At the moment rsync only cares about hardlinks to regular files.  I
   guess you could also use them for sockets, devices and other beasts,
   but I have not seen them.
 
   When trying to reproduce hard links, we only need to worry about
-  files that have more than one name (nlinks>1 && !S_ISDIR). 
+  files that have more than one name (nlinks>1 && !S_ISDIR).
 
   The basic point of this is to discover alternate names that refer to
   the same file.  All operations, including creating the file and
   writing modifications to it need only to be done for the first name.
   For all later names, we just create the link and then leave it
   alone.
@@ -229,14 +320,45 @@
 
   We should have a test case that exercises hard links.  Since it
   might be hard to compare ./tls output where the inodes change we
   might need a little program to check whether several names refer to
   the same file.
 
-IPv6
 
+
+Handling IPv6 on old machines
+
+  The KAME IPv6 patch is nice in theory but has proved a bit of a
+  nightmare in practice.  The basic idea of their patch is that rsync
+  is rewritten to use the new getaddrinfo()/getnameinfo() interface,
+  rather than gethostbyname()/gethostbyaddr() as in rsync 2.4.6.
+  Systems that don't have the new interface are handled by providing
+  our own implementation in lib/, which is selectively linked in.
+
+  The problem with this is that it is really hard to get right on
+  platforms that have a half-working implementation, so redefining
+  these functions clashes with system headers, and leaving them out
+  breaks.  This affects at least OSF/1, RedHat 5, and Cobalt, which
+  are moderately improtant.
+
+  Perhaps the simplest solution would be to have two different files
+  implementing the same interface, and choose either the new or the
+  old API.  This is probably necessary for systems that e.g. have
+  IPv6, but gethostbyaddr() can't handle it.  The Linux manpage claims
+  this is currently the case.
+
+  In fact, our internal sockets interface (things like
+  open_socket_out(), etc) is much narrower than the getaddrinfo()
+  interface, and so probably simpler to get right.  In addition, the
+  old code is known to work well on old machines.
+
+  We could drop the rather large lib/getaddrinfo files.
+
+
+Other IPv6 stuff:
+  
   Implement suggestions from http://www.kame.net/newsletter/19980604/
   and ftp://ftp.iij.ad.jp/pub/RFC/rfc2553.txt
 
   If a host has multiple addresses, then listen try to connect to all
   in order until we get through.  (getaddrinfo may return multiple
   addresses.)  This is kind of implemented already.
@@ -246,14 +368,13 @@
   may need to select on all of them.  Hm.
 
   Define a syntax for IPv6 literal addresses.  Since they include
   colons, they tend to break most naming systems, including ours.
   Based on the HTTP IPv6 syntax, I think we should use
  
-     rsync://[::1]/foo/bar
-     [::1]::bar
+     rsync://[::1]/foo/bar [::1]::bar
 
   which should just take a small change to the parser code.
 
 
 Errors
 
@@ -261,22 +382,22 @@
   have a static buffer that contains the current function name, or
   some kind of description of what we were trying to do.  This is a
   little easier on people than needing to run strace/truss.
 
   "The dungeon collapses!  You are killed."  Rather than "unexpected
   eof" give a message that is more detailed if possible and also more
-  helpful.  
+  helpful.
 
   If we get an error writing to a socket, then we should perhaps
   continue trying to read to see if an error message comes across
   explaining why the socket is closed.  I'm not sure if this would
   work, but it would certainly make our messages more helpful.
 
   What happens if a directory is missing -x attributes.  Do we lose
-  our load?  (Debian #28416)  Probably fixed now, but a test case
-  would be good.
+  our load?  (Debian #28416) Probably fixed now, but a test case would
+  be good.
 
 
 File attributes
 
   Device major/minor numbers should be at least 32 bits each.  See
   http://lists.samba.org/pipermail/rsync/2001-November/005357.html
@@ -291,13 +412,13 @@
   can end up with many empty directories.  We might avoid this by
   lazily creating such directories.
 
 
 zlib
 
-  Perhaps don't use our own zlib.  
+  Perhaps don't use our own zlib.
 
   Advantages:
    
     - will automatically be up to date with bugfixes in zlib
 
     - can leave it out for small rsync on e.g. recovery disks
@@ -327,46 +448,55 @@
 
   If a child of the rsync daemon dies with a signal, we should notice
   that when we reap it and log a message.
 
   Keep stderr and stdout properly separated (Debian #23626)
 
-  Use a separate function for reporting errors; prefix it with
-  "rsync:" or "rsync(remote)", or perhaps even "rsync(local
-  generator): ".
-
-
-rsyncd over ssh
+  After we get the @RSYNCD greeting from the server, we know it's
+  version but we have not yet sent the command line, so we could just
+  remove the -z option if the server is too old.
+
+  For ssh invocation it's not so simple, because we actually use the
+  command line to start the remote process.  However, we only actually
+  do compression in token.c, and we could therefore once we discover
+  the remote version emit an error if it's too old.  I'm not sure if
+  that's a good tradeoff or not.
 
-  There are already some patches to do this.
 
 proxy authentication
 
   Allow RSYNC_PROXY to be http://user:pass@proxy.foo:3128/, and do
-  HTTP Basic Proxy-Authentication.  
+  HTTP Basic Proxy-Authentication.
 
   Multiple schemes are possible, up to and including the insanity that
   is NTLM, but Basic probably covers most cases.
 
 SOCKS
 
   Add --with-socks, and then perhaps a command-line option to put them
   on or off.  This might be more reliable than LD_PRELOAD hacks.
 
+FAT support
+
+  rsync to a FAT partition on a Unix machine doesn't work very well at
+  the moment.  I think we get errors about invalid filenames and
+  perhaps also trying to do atomic renames.
+
+  I guess the code to do this is currently #ifdef'd on Windows;
+  perhaps we ought to intelligently fall back to it on Unix too.
+
+
 Better statistics:
 
   <Rasmus> mbp: hey, how about an rsync option that just gives you the
   summary without the list of files?  And perhaps gives more
   information like the number of new files, number of changed,
-  deleted, etc. ?
-  <mbp> Rasmus: nice idea
-  <mbp> there is --stats
-  <mbp> but at the moment it's very tridge-oriented
-  <mbp> rather than user-friendly
-  <mbp> it would be nice to improve it
-  <mbp> that would also work well with --dryrun
+  deleted, etc. ?  <mbp> Rasmus: nice idea <mbp> there is --stats
+  <mbp> but at the moment it's very tridge-oriented <mbp> rather than
+  user-friendly <mbp> it would be nice to improve it <mbp> that would
+  also work well with --dryrun
 
 TDB:
 
   Rather than storing the file list in memory, store it in a TDB.
 
   This *might* make memory usage lower while building the file list.
@@ -377,29 +507,31 @@
   This would neatly eliminate one of the major post-fork shared data
   structures.
 
 
 chmod:
 
-  On 12 Mar 2002, Dave Dykstra <dwd@bell-labs.com> wrote:
-  > If we would add an option to do that functionality, I would vote for one
-  > that was more general which could mask off any set of permission bits and
-  > possibly add any set of bits.  Perhaps a chmod-like syntax if it could be
-  > implemented simply.
+  On 12 Mar 2002, Dave Dykstra <dwd@bell-labs.com> wrote: > If we
+would add an option to do that functionality, I would vote for one >
+that was more general which could mask off any set of permission bits
+and > possibly add any set of bits.  Perhaps a chmod-like syntax if it
+could be > implemented simply.
 
-  I think that would be good too.  For example, people uploading files   
+  I think that would be good too.  For example, people uploading files
   to a web server might like to say
 
   rsync -avzP --chmod a+rX ./ sourcefrog.net:/home/www/sourcefrog/
 
   Ideally the patch would implement as many of the gnu chmod semantics
   as possible.  I think the mode parser should be a separate function
-  that passes back something like (mask,set) description to the rest of
-  the program.  For bonus points there would be a test case for the  
+  that passes back something like (mask,set) description to the rest
+  of the program.  For bonus points there would be a test case for the
   parser.
 
+  Possibly also --chown
+
   (Debian #23628)
 
 
 --diff
 
   Allow people to specify the diff command.  (Might want to use wdiff,
@@ -424,12 +556,36 @@
 
   We need a test case for this...
 
   Was this broken when we changed to popt?
 
 
+PERFORMANCE ----------------------------------------------------------
+
+MD4 file_sum
+
+  If we're doing a local transfer, or using -W, then perhaps don't
+  send the file checksum.  If we're doing a local transfer, then
+  calculating MD4 checksums uses 90% of CPU and is unlikely to be
+  useful.
+
+  Indeed for transfers over zlib or ssh we can also rely on the
+  transport to have quite strong protection against corruption.
+
+  Perhaps we should have an option to disable this, analogous to
+--whole-file, although it would default to disabled.  The file
+checksum takes up a definite space in the protocol -- we can either
+set it to 0, or perhaps just leave it out.
+
+MD4
+
+  Perhaps borrow an assembler MD4 from someone?
+
+  Make sure we call MD4 with properly-sized blocks whenever possible
+  to avoid copying into the residue region?
+
 String area code
 
   Test whether this is actually faster than just using malloc().  If
   it's not (anymore), throw it out.
 	  
 
@@ -439,18 +594,12 @@
 Win32
 
   Don't detach, because this messes up --srvany.
 
   http://sources.redhat.com/ml/cygwin/2001-08/msg00234.html
 
-  According to "Effective TCP/IP Programming" (??) close() on a socket
-  has incorrect behaviour on Windows -- it sends a RST packet to the
-  other side, which gives a "connection reset by peer" error.  On that
-  platform we should probably do shutdown() instead.  However, on Unix
-  we are correct to call close(), because shutdown() discards
-  untransmitted data.
 
 DEVELOPMENT ----------------------------------------------------------
 
 Splint
 
   Build rsync with SPLINT to try to find security holes.  Add
@@ -471,25 +620,56 @@
 Memory debugger
 
   jra recommends Valgrind:
 
     http://devel-home.kde.org/~sewardj/
 
+Release script
+  
+  Update spec files
+
+  Build tar file; upload
+
+  Send announcement to mailing list and c.o.l.a.
+  
+  Make freshmeat announcement
+
+  Update web site
+
+
+
 TESTING --------------------------------------------------------------
 
 Cross-test versions
 
   Part of the regression suite should be making sure that we don't
-  break backwards compatibility: old clients vs new servers and so
-  on.  Ideally we would test the cross product of versions.  
+  break backwards compatibility: old clients vs new servers and so on.
+  Ideally we would test both up and down from the current release to
+  all old versions.
+
+  We might need to omit broken old versions, or versions in which
+  particular functionality is broken
 
   It might be sufficient to test downloads from well-known public
   rsync servers running different versions of rsync.  This will give
   some testing and also be the most common case for having different
   versions and not being able to upgrade.
 
+
+Test on kernel source
+
+  Download all versions of kernel; unpack, sync between them.  Also
+  sync between uncompressed tarballs.  Compare directories after
+  transfer.
+
+  Use local mode; ssh; daemon; --whole-file and --no-whole-file.
+
+  Use awk to pull out the 'speedup' number for each transfer.  Make
+  sure it is >= x.
+
+
 Test large files
 
   Sparse and non-sparse
 
 Mutator program
 
@@ -500,65 +680,136 @@
 If tests are skipped, say why.
 
 Test daemon feature to disallow particular options.
 
 Pipe program that makes slow/jerky connections.
 
-Versions of read() and write() that corrupt the stream, or abruptly fail
+Versions of read() and write() that corrupt the stream, or abruptly
+fail
 
 Separate makefile target to run rough tests -- or perhaps just run
 them every time?
 
+Test "refuse options" works
+
+  What about for --recursive?
+
+  If you specify an unrecognized option here, you should get an error.
+
 
 DOCUMENTATION --------------------------------------------------------
 
 Update README
 
 Keep list of open issues and todos on the web site
 
 Update web site from CVS
 
+
+Perhaps redo manual as SGML
+
+  The man page is getting rather large, and there is more information
+  that ought to be added.
+
+  TexInfo source is probably a dying format.
+
+  Linuxdoc looks like the most likely contender.  I know DocBook is
+  favoured by some people, but it's so bloody verbose, even with emacs
+  support.
+
+
 BUILD FARM -----------------------------------------------------------
 
 Add machines
 
-  AMDAHL UTS (Dave Dykstra)
-
   Cygwin (on different versions of Win32?)
 
   HP-UX variants (via HP?)
 
   SCO
 
-NICE -----------------------------------------------------------------
 
---no-detach and --no-fork options
+LOGGING --------------------------------------------------------------
 
-  Very useful for debugging.  Also good when running under a
-  daemon-monitoring process that tries to restart the service when the
-  parent exits.
+  Perhaps flush stdout after each filename, so that people trying to
+  monitor progress in a log file can do so more easily.  See
+  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=48108
 
-hang/timeout friendliness
+  At the connections that just get a list of modules are not logged,
+  but they should be.
+
+  If a child of the rsync daemon dies with a signal, we should notice
+  that when we reap it and log a message.
+
+  Keep stderr and stdout properly separated (Debian #23626)
+
+  Use a separate function for reporting errors; prefix it with
+  "rsync:" or "rsync(remote)", or perhaps even "rsync(local
+  generator): ".
 
 verbose output
   
   Indicate whether files are new, updated, or deleted
 
   At end of transfer, show how many files were or were not transferred
   correctly.
 
+-vv
+
+  Explain *why* every file is transferred or not (e.g. "local mtime
+  123123 newer than 1283198")
+
+
+debugging of daemon
+
+  Add an rsyncd.conf parameter to turn on debugging on the server.
+
+
+
+NICE -----------------------------------------------------------------
+
+--no-detach and --no-fork options
+
+  Very useful for debugging.  Also good when running under a
+  daemon-monitoring process that tries to restart the service when the
+  parent exits.
+
+hang/timeout friendliness
+
 internationalization
 
   Change to using gettext().  Probably need to ship this for platforms
-  that don't have it.  
+  that don't have it.
 
   Solicit translations.
 
-  Does anyone care?
+  Does anyone care?  Before we bother modifying the code, we ought to
+  get the manual translated first, because that's possibly more useful
+  and at any rate demonstrates desire.
 
-rsyncsh 
+rsyncsh
 
    Write a small emulation of interactive ftp as a Pythonn program
    that calls rsync.  Commands such as "cd", "ls", "ls *.c" etc map
    fairly directly into rsync commands: it just needs to remember the
    current host, directory and so on.  We can probably even do
    completion of remote filenames.
+
+
+RELATED PROJECTS -----------------------------------------------------
+
+http://rsync.samba.org/rsync-and-debian/
+
+rsyncable gzip patch
+
+  Exhaustive, tortuous testing
+
+  Cleanups?
+
+rsyncsplit as alternative to real integration with gzip?
+
+reverse rsync over HTTP Range
+
+  Goswin Brederlow suggested this on Debian; I think tridge and I
+  talked about it previous in relation to rproxy.
+
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/token.c	2001-08-14 10:04:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/token.c	2002-04-08 16:35:30.000000000 +0800
@@ -471,14 +471,14 @@
 			rprintf(FERROR, "inflate (token) returned %d\n", r);
 			exit_cleanup(RERR_STREAMIO);
 		}
 	} while (len || rx_strm.avail_out == 0);
 }
 
-/*
- * transmit a verbatim buffer of length n followed by a token 
+/**
+ * Transmit a verbatim buffer of length @p n followed by a token.
  * If token == -1 then we have reached EOF 
  * If n == 0 then don't send a buffer
  */
 void send_token(int f,int token,struct map_struct *buf,OFF_T offset,
 		int n,int toklen)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/trimslash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/trimslash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/trimslash.c	2002-03-25 11:51:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/trimslash.c	2003-01-21 09:35:23.000000000 +0800
@@ -19,12 +19,13 @@
 #include "rsync.h"
 
 /* These are to make syscall.o shut up. */
 int dry_run = 0;
 int read_only = 1;
 int list_only = 0;
+int preserve_perms = 0;
 
 /**
  * @file trimslash.c
  *
  * Test harness; not linked into release.
  **/
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6: t_stub.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6: t_unsafe.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.5/util.c	2002-03-20 09:09:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.6/util.c	2003-01-20 05:37:11.000000000 +0800
@@ -1,72 +1,77 @@
 /*  -*- c-file-style: "linux" -*-
-    
-    Copyright (C) 1996-2000 by Andrew Tridgell 
-    Copyright (C) Paul Mackerras 1996
-    Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
-   
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
+ * 
+ * Copyright (C) 1996-2000 by Andrew Tridgell 
+ * Copyright (C) Paul Mackerras 1996
+ * Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
 
-/*
-  Utilities used in rsync 
+/**
+ * @file
+ *
+ * Utilities used in rsync 
+ **/
 
-  tridge, June 1996
-  */
 #include "rsync.h"
 
 extern int verbose;
 
+int sanitize_paths = 0;
 
-/****************************************************************************
-Set a fd into nonblocking mode
-****************************************************************************/
+
+
+/**
+ * Set a fd into nonblocking mode
+ **/
 void set_nonblocking(int fd)
 {
 	int val;
 
-	if((val = fcntl(fd, F_GETFL, 0)) == -1)
+	if ((val = fcntl(fd, F_GETFL, 0)) == -1)
 		return;
 	if (!(val & NONBLOCK_FLAG)) {
 		val |= NONBLOCK_FLAG;
 		fcntl(fd, F_SETFL, val);
 	}
 }
 
-/****************************************************************************
-Set a fd into blocking mode
-****************************************************************************/
+/**
+ * Set a fd into blocking mode
+ **/
 void set_blocking(int fd)
 {
 	int val;
 
-	if((val = fcntl(fd, F_GETFL, 0)) == -1)
+	if ((val = fcntl(fd, F_GETFL, 0)) == -1)
 		return;
 	if (val & NONBLOCK_FLAG) {
 		val &= ~NONBLOCK_FLAG;
 		fcntl(fd, F_SETFL, val);
 	}
 }
 
 
-/* create a file descriptor pair - like pipe() but use socketpair if
-   possible (because of blocking issues on pipes)
-
-   always set non-blocking
+/**
+ * Create a file descriptor pair - like pipe() but use socketpair if
+ * possible (because of blocking issues on pipes).
+ * 
+ * Always set non-blocking.
  */
 int fd_pair(int fd[2])
 {
 	int ret;
 
 #if HAVE_SOCKETPAIR
@@ -76,18 +81,18 @@
 #endif
 
 	if (ret == 0) {
 		set_nonblocking(fd[0]);
 		set_nonblocking(fd[1]);
 	}
-	
+
 	return ret;
 }
 
 
-static void print_child_argv(char **cmd)
+void print_child_argv(char **cmd)
 {
 	rprintf(FINFO, "opening connection using ");
 	for (; *cmd; cmd++) {
 		/* Look for characters that ought to be quoted.  This
 		* is not a great quoting algorithm, but it's
 		* sufficient for a log message. */
@@ -101,134 +106,12 @@
 		}
 	}
 	rprintf(FINFO, "\n");
 }
 
 
-/* this is derived from CVS code 
-
-   note that in the child STDIN is set to blocking and STDOUT
-   is set to non-blocking. This is necessary as rsh relies on stdin being blocking
-   and ssh relies on stdout being non-blocking
-
-   if blocking_io is set then use blocking io on both fds. That can be
-   used to cope with badly broken rsh implementations like the one on
-   solaris.
- */
-pid_t piped_child(char **command, int *f_in, int *f_out)
-{
-	pid_t pid;
-	int to_child_pipe[2];
-	int from_child_pipe[2];
-	extern int blocking_io;
-	
-	if (verbose >= 2) {
-		print_child_argv(command);
-	}
-
-	if (fd_pair(to_child_pipe) < 0 || fd_pair(from_child_pipe) < 0) {
-		rprintf(FERROR, "pipe: %s\n", strerror(errno));
-		exit_cleanup(RERR_IPC);
-	}
-
-
-	pid = do_fork();
-	if (pid == -1) {
-		rprintf(FERROR, "fork: %s\n", strerror(errno));
-		exit_cleanup(RERR_IPC);
-	}
-
-	if (pid == 0) {
-		extern int orig_umask;
-		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
-		    close(to_child_pipe[1]) < 0 ||
-		    close(from_child_pipe[0]) < 0 ||
-		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
-			rprintf(FERROR, "Failed to dup/close : %s\n",
-				strerror(errno));
-			exit_cleanup(RERR_IPC);
-		}
-		if (to_child_pipe[0] != STDIN_FILENO)
-			close(to_child_pipe[0]);
-		if (from_child_pipe[1] != STDOUT_FILENO)
-			close(from_child_pipe[1]);
-		umask(orig_umask);
-		set_blocking(STDIN_FILENO);
-		if (blocking_io) {
-			set_blocking(STDOUT_FILENO);
-		}
-		execvp(command[0], command);
-		rprintf(FERROR, "Failed to exec %s : %s\n",
-			command[0], strerror(errno));
-		exit_cleanup(RERR_IPC);
-	}
-
-	if (close(from_child_pipe[1]) < 0 || close(to_child_pipe[0]) < 0) {
-		rprintf(FERROR, "Failed to close : %s\n", strerror(errno));
-		exit_cleanup(RERR_IPC);
-	}
-
-	*f_in = from_child_pipe[0];
-	*f_out = to_child_pipe[1];
-
-	return pid;
-}
-
-pid_t local_child(int argc, char **argv,int *f_in,int *f_out)
-{
-	pid_t pid;
-	int to_child_pipe[2];
-	int from_child_pipe[2];
-	extern int read_batch;  /* dw */
-
-	if (fd_pair(to_child_pipe) < 0 ||
-	    fd_pair(from_child_pipe) < 0) {
-		rprintf(FERROR,"pipe: %s\n",strerror(errno));
-		exit_cleanup(RERR_IPC);
-	}
-
-
-	pid = do_fork();
-	if (pid == -1) {
-		rprintf(FERROR,"fork: %s\n",strerror(errno));
-		exit_cleanup(RERR_IPC);
-	}
-
-	if (pid == 0) {
-		extern int am_sender;
-		extern int am_server;
-
-		am_sender = read_batch ? 0 : !am_sender;
-		am_server = 1;		
-
-		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
-		    close(to_child_pipe[1]) < 0 ||
-		    close(from_child_pipe[0]) < 0 ||
-		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
-			rprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
-			exit_cleanup(RERR_IPC);
-		}
-		if (to_child_pipe[0] != STDIN_FILENO) close(to_child_pipe[0]);
-		if (from_child_pipe[1] != STDOUT_FILENO) close(from_child_pipe[1]);
-		start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
-	}
-
-	if (close(from_child_pipe[1]) < 0 ||
-	    close(to_child_pipe[0]) < 0) {
-		rprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
-		exit_cleanup(RERR_IPC);
-	}
-
-	*f_in = from_child_pipe[0];
-	*f_out = to_child_pipe[1];
-  
-	return pid;
-}
-
-
-
 void out_of_memory(char *str)
 {
   rprintf(FERROR,"ERROR: out of memory in %s\n",str);
   exit_cleanup(RERR_MALLOC);
 }
 
@@ -272,41 +155,45 @@
 		return utimes(fname,t);
 #endif
 	}
 }
 
 
-/****************************************************************************
-create any necessary directories in fname. Unfortunately we don't know
-what perms to give the directory when this is called so we need to rely
-on the umask
-****************************************************************************/
-int create_directory_path(char *fname)
+/**
+   Create any necessary directories in fname. Unfortunately we don't know
+   what perms to give the directory when this is called so we need to rely
+   on the umask
+**/
+int create_directory_path(char *fname, int base_umask)
 {
-	extern int orig_umask;
 	char *p;
 
 	while (*fname == '/') fname++;
 	while (strncmp(fname,"./",2)==0) fname += 2;
 
 	p = fname;
 	while ((p=strchr(p,'/'))) {
 		*p = 0;
-		do_mkdir(fname,0777 & ~orig_umask); 
+		do_mkdir(fname, 0777 & ~base_umask); 
 		*p = '/';
 		p++;
 	}
 	return 0;
 }
 
 
-/* Write LEN bytes at PTR to descriptor DESC, retrying if interrupted.
-   Return LEN upon success, write's (negative) error code otherwise.  
-
-   derived from GNU C's cccp.c.
-*/
+/**
+ * Write @p len bytes at @p ptr to descriptor @p desc, retrying if
+ * interrupted.
+ *
+ * @retval len upon success
+ *
+ * @retval <0 write's (negative) error code
+ *
+ * Derived from GNU C's cccp.c.
+ */
 static int full_write(int desc, char *ptr, size_t len)
 {
 	int total_written;
 	
 	total_written = 0;
 	while (len > 0) {
@@ -322,17 +209,24 @@
 		ptr += written;
 		len -= written;
 	}
 	return total_written;
 }
 
-/* Read LEN bytes at PTR from descriptor DESC, retrying if interrupted.
-   Return the actual number of bytes read, zero for EOF, or negative
-   for an error.  
 
-   derived from GNU C's cccp.c. */
+/**
+ * Read @p len bytes at @p ptr from descriptor @p desc, retrying if
+ * interrupted.
+ *
+ * @retval >0 the actual number of bytes read
+ *
+ * @retval 0 for EOF
+ *
+ * @retval <0 for an error.
+ *
+ * Derived from GNU C's cccp.c. */
 static int safe_read(int desc, char *ptr, size_t len)
 {
 	int n_chars;
  
 	if (len == 0)
 		return len;
@@ -346,13 +240,15 @@
 #endif
  
 	return n_chars;
 }
 
 
-/* copy a file - this is used in conjunction with the --temp-dir option */
+/** Copy a file.
+ *
+ * This is used in conjunction with the --temp-dir option */
 int copy_file(char *source, char *dest, mode_t mode)
 {
 	int ifd;
 	int ofd;
 	char buf[1024 * 8];
 	int len;   /* Number of bytes read into `buf'. */
@@ -397,24 +293,26 @@
 		return -1;
 	}
 
 	return 0;
 }
 
-/*
-  Robust unlink: some OS'es (HPUX) refuse to unlink busy files, so
-  rename to <path>/.rsyncNNN instead. Note that successive rsync runs
-  will shuffle the filenames around a bit as long as the file is still
-  busy; this is because this function does not know if the unlink call
-  is due to a new file coming in, or --delete trying to remove old
-  .rsyncNNN files, hence it renames it each time.
-*/
 /* MAX_RENAMES should be 10**MAX_RENAMES_DIGITS */
 #define MAX_RENAMES_DIGITS 3
 #define MAX_RENAMES 1000
 
+/**
+ * Robust unlink: some OS'es (HPUX) refuse to unlink busy files, so
+ * rename to <path>/.rsyncNNN instead.
+ *
+ * Note that successive rsync runs will shuffle the filenames around a
+ * bit as long as the file is still busy; this is because this function
+ * does not know if the unlink call is due to a new file coming in, or
+ * --delete trying to remove old .rsyncNNN files, hence it renames it
+ * each time.
+ **/
 int robust_unlink(char *fname)
 {
 #ifndef ETXTBSY
 	return do_unlink(fname);
 #else
 	static int counter = 1;
@@ -516,26 +414,26 @@
 
 		kill(p, sig);
 	}
 }
 
 
-/* turn a user name into a uid */
+/** Turn a user name into a uid */
 int name_to_uid(char *name, uid_t *uid)
 {
 	struct passwd *pass;
 	if (!name || !*name) return 0;
 	pass = getpwnam(name);
 	if (pass) {
 		*uid = pass->pw_uid;
 		return 1;
 	}
 	return 0;
 }
 
-/* turn a group name into a gid */
+/** Turn a group name into a gid */
 int name_to_gid(char *name, gid_t *gid)
 {
 	struct group *grp;
 	if (!name || !*name) return 0;
 	grp = getgrnam(name);
 	if (grp) {
@@ -543,13 +441,13 @@
 		return 1;
 	}
 	return 0;
 }
 
 
-/* lock a byte range in a open file */
+/** Lock a byte range in a open file */
 int lock_range(int fd, int offset, int len)
 {
 	struct flock lock;
 
 	lock.l_type = F_WRLCK;
 	lock.l_whence = SEEK_SET;
@@ -625,19 +523,20 @@
 	if (*q && (*argc < maxargs)) glob_expand_one(q, argv, argc, maxargs);
 
 	free(s);
 	free(base);
 }
 
-/*******************************************************************
-  convert a string to lower case
-********************************************************************/
+/**
+ * Convert a string to lower case
+ **/
 void strlower(char *s)
 {
 	while (*s) {
-		if (isupper(*s)) *s = tolower(*s);
+		if (isupper(* (unsigned char *) s))
+			*s = tolower(* (unsigned char *) s);
 		s++;
 	}
 }
 
 void *Realloc(void *p, int size)
 {
@@ -685,32 +584,38 @@
 			modified = 1;
 			p[l-1] = 0;
 		}
 	}
 }
 
-/*
+/**
  * Make path appear as if a chroot had occurred:
- *    1. remove leading "/" (or replace with "." if at end)
- *    2. remove leading ".." components (except those allowed by "reldir")
- *    3. delete any other "<dir>/.." (recursively)
+ *
+ * @li 1. remove leading "/" (or replace with "." if at end)
+ *
+ * @li 2. remove leading ".." components (except those allowed by @p reldir)
+ *
+ * @li 3. delete any other "<dir>/.." (recursively)
+ *
  * Can only shrink paths, so sanitizes in place.
+ *
  * While we're at it, remove double slashes and "." components like
- *   clean_fname does(), but DON'T remove a trailing slash because that
+ *   clean_fname() does, but DON'T remove a trailing slash because that
  *   is sometimes significant on command line arguments.
- * If "reldir" is non-null, it is a sanitized directory that the path will be
+ *
+ * If @p reldir is non-null, it is a sanitized directory that the path will be
  *    relative to, so allow as many ".." at the beginning of the path as
  *    there are components in reldir.  This is used for symbolic link targets.
  *    If reldir is non-null and the path began with "/", to be completely like
  *    a chroot we should add in depth levels of ".." at the beginning of the
  *    path, but that would blow the assumption that the path doesn't grow and
  *    it is not likely to end up being a valid symlink anyway, so just do
  *    the normal removal of the leading "/" instead.
+ *
  * Contributed by Dave Dykstra <dwd@bell-labs.com>
  */
-
 void sanitize_path(char *p, char *reldir)
 {
 	char *start, *sanp;
 	int depth = 0;
 	int allowdotdot = 0;
 
@@ -793,14 +698,16 @@
 	*sanp = '\0';
 }
 
 
 static char curr_dir[MAXPATHLEN];
 
-/* like chdir() but can be reversed with pop_dir() if save is set. It
-   is also much faster as it remembers where we have been */
+/**
+ * Like chdir() but can be reversed with pop_dir() if @p save is set.
+ * It is also much faster as it remembers where we have been.
+ **/
 char *push_dir(char *dir, int save)
 {
 	char *ret = curr_dir;
 	static int initialised;
 
 	if (!initialised) {
@@ -825,13 +732,13 @@
 
 	clean_fname(curr_dir);
 
 	return ret;
 }
 
-/* reverse a push_dir call */
+/** Reverse a push_dir() call */
 int pop_dir(char *dir)
 {
 	int ret;
 
 	ret = chdir(dir);
 	if (ret) {
@@ -843,13 +750,13 @@
 
 	free(dir);
 
 	return 0;
 }
 
-/* we need to supply our own strcmp function for file list comparisons
+/** We need to supply our own strcmp function for file list comparisons
    to ensure that signed/unsigned usage is consistent between machines. */
 int u_strcmp(const char *cs1, const char *cs2)
 {
 	const uchar *s1 = (const uchar *)cs1;
 	const uchar *s2 = (const uchar *)cs2;
 
@@ -857,158 +764,81 @@
 		s1++; s2++;
 	}
 	
 	return (int)*s1 - (int)*s2;
 }
 
-static OFF_T  last_ofs;
-static struct timeval print_time;
-static struct timeval start_time;
-static OFF_T  start_ofs;
-
-static unsigned long msdiff(struct timeval *t1, struct timeval *t2)
-{
-    return (t2->tv_sec - t1->tv_sec) * 1000
-        + (t2->tv_usec - t1->tv_usec) / 1000;
-}
 
 
 /**
- * @param ofs Current position in file
- * @param size Total size of file
- * @param is_last True if this is the last time progress will be
- * printed for this file, so we should output a newline.  (Not
- * necessarily the same as all bytes being received.)
+ * Determine if a symlink points outside the current directory tree.
+ * This is considered "unsafe" because e.g. when mirroring somebody
+ * else's machine it might allow them to establish a symlink to
+ * /etc/passwd, and then read it through a web server.
+ *
+ * Null symlinks and absolute symlinks are always unsafe.
+ *
+ * Basically here we are concerned with symlinks whose target contains
+ * "..", because this might cause us to walk back up out of the
+ * transferred directory.  We are not allowed to go back up and
+ * reenter.
+ *
+ * @param dest Target of the symlink in question.
+ *
+ * @param src Top source directory currently applicable.  Basically this
+ * is the first parameter to rsync in a simple invocation, but it's
+ * modified by flist.c in slightly complex ways.
+ *
+ * @retval True if unsafe
+ * @retval False is unsafe
+ *
+ * @sa t_unsafe.c
  **/
-static void rprint_progress(OFF_T ofs, OFF_T size, struct timeval *now,
-			    int is_last)
-{
-    int           pct  = (ofs == size) ? 100 : (int)((100.0*ofs)/size);
-    unsigned long diff = msdiff(&start_time, now);
-    double        rate = diff ? (double) (ofs-start_ofs) * 1000.0 / diff / 1024.0 : 0;
-    const char    *units;
-    /* If we've finished transferring this file, show the time taken;
-     * otherwise show expected time to complete.  That's kind of
-     * inconsistent, but people can probably cope.  Hopefully we'll
-     * get more consistent and complete progress reporting soon. --
-     * mbp */
-    double        remain = is_last
-                        ? (double) diff / 1000.0
-                        : rate ? (double) (size-ofs) / rate / 1000.0 : 0.0;
-    int 	  remain_h, remain_m, remain_s;
-
-    if (rate > 1024*1024) {
-	    rate /= 1024.0 * 1024.0;
-	    units = "GB/s";
-    } else if (rate > 1024) {
-	    rate /= 1024.0;
-	    units = "MB/s";
-    } else {
-	    units = "kB/s";
-    }
-
-    remain_s = (int) remain % 60;
-    remain_m = (int) (remain / 60.0) % 60;
-    remain_h = (int) (remain / 3600.0);
-    
-    rprintf(FINFO, "%12.0f %3d%% %7.2f%s %4d:%02d:%02d%s",
-	    (double) ofs, pct, rate, units,
-	    remain_h, remain_m, remain_s,
-	    is_last ? "\n" : "\r");
-}
-
-void end_progress(OFF_T size)
-{
-	extern int do_progress, am_server;
-
-	if (do_progress && !am_server) {
-        	struct timeval now;
-                gettimeofday(&now, NULL);
-                rprint_progress(size, size, &now, True);
-	}
-	last_ofs   = 0;
-        start_ofs  = 0;
-        print_time.tv_sec  = print_time.tv_usec  = 0;
-        start_time.tv_sec  = start_time.tv_usec  = 0;
-}
-
-void show_progress(OFF_T ofs, OFF_T size)
-{
-	extern int do_progress, am_server;
-        struct timeval now;
-
-        gettimeofday(&now, NULL);
-
-        if (!start_time.tv_sec && !start_time.tv_usec) {
-        	start_time.tv_sec  = now.tv_sec;
-                start_time.tv_usec = now.tv_usec;
-                start_ofs          = ofs;
-        }
-
-	if (do_progress
-            && !am_server
-            && ofs > last_ofs + 1000
-            && msdiff(&print_time, &now) > 250) {
-        	rprint_progress(ofs, size, &now, False);
-                last_ofs = ofs;
-                print_time.tv_sec  = now.tv_sec;
-                print_time.tv_usec = now.tv_usec;
-	}
-}
-
-/* determine if a symlink points outside the current directory tree */
-int unsafe_symlink(char *dest, char *src)
+int unsafe_symlink(const char *dest, const char *src)
 {
-	char *tok;
+	const char *name, *slash;
 	int depth = 0;
 
 	/* all absolute and null symlinks are unsafe */
-	if (!dest || !(*dest) || (*dest == '/')) return 1;
-
-	src = strdup(src);
-	if (!src) out_of_memory("unsafe_symlink");
+	if (!dest || !*dest || *dest == '/') return 1;
 
 	/* find out what our safety margin is */
-	for (tok=strtok(src,"/"); tok; tok=strtok(NULL,"/")) {
-		if (strcmp(tok,"..") == 0) {
+	for (name = src; (slash = strchr(name, '/')) != 0; name = slash+1) {
+		if (strncmp(name, "../", 3) == 0) {
 			depth=0;
-		} else if (strcmp(tok,".") == 0) {
+		} else if (strncmp(name, "./", 2) == 0) {
 			/* nothing */
 		} else {
 			depth++;
 		}
 	}
-	free(src);
-
-	/* drop by one to account for the filename portion */
-	depth--;
+	if (strcmp(name, "..") == 0)
+		depth = 0;
 
-	dest = strdup(dest);
-	if (!dest) out_of_memory("unsafe_symlink");
-
-	for (tok=strtok(dest,"/"); tok; tok=strtok(NULL,"/")) {
-		if (strcmp(tok,"..") == 0) {
-			depth--;
-		} else if (strcmp(tok,".") == 0) {
+	for (name = dest; (slash = strchr(name, '/')) != 0; name = slash+1) {
+		if (strncmp(name, "../", 3) == 0) {
+			/* if at any point we go outside the current directory
+			   then stop - it is unsafe */
+			if (--depth < 0)
+				return 1;
+		} else if (strncmp(name, "./", 2) == 0) {
 			/* nothing */
 		} else {
 			depth++;
 		}
-		/* if at any point we go outside the current directory then
-		   stop - it is unsafe */
-		if (depth < 0) break;
 	}
+	if (strcmp(name, "..") == 0)
+		depth--;
 
-	free(dest);
 	return (depth < 0);
 }
 
 
-/****************************************************************************
-  return the date and time as a string
-****************************************************************************/
+/**
+ * Return the date and time as a string
+ **/
 char *timestring(time_t t)
 {
 	static char TimeBuf[200];
 	struct tm *tm = localtime(&t);
 
 #ifdef HAVE_STRFTIME
@@ -1052,18 +882,23 @@
 	}
 
 	return True;
 }
 
 
-/*******************************************************************
- Determine if two file modification times are equivalent (either exact 
- or in the modification timestamp window established by --modify-window) 
- Returns 0 if the times should be treated as the same, 1 if the 
- first is later and -1 if the 2nd is later
- *******************************************************************/
+/**
+ * Determine if two file modification times are equivalent (either
+ * exact or in the modification timestamp window established by
+ * --modify-window).
+ *
+ * @retval 0 if the times should be treated as the same
+ *
+ * @retval +1 if the first is later
+ *
+ * @retval -1 if the 2nd is later
+ **/
 int cmp_modtime(time_t file1, time_t file2)
 {
 	extern int modify_window;
 
 	if (file2 > file1) {
 		if (file2 - file1 <= modify_window) return 0;
@@ -1074,17 +909,17 @@
 }
 
 
 #ifdef __INSURE__XX
 #include <dlfcn.h>
 
-/*******************************************************************
-This routine is a trick to immediately catch errors when debugging
-with insure. A xterm with a gdb is popped up when insure catches
-a error. It is Linux specific.
-********************************************************************/
+/**
+   This routine is a trick to immediately catch errors when debugging
+   with insure. A xterm with a gdb is popped up when insure catches
+   a error. It is Linux specific.
+**/
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6)
 {
 	static int (*fn)();
 	int ret;
 	char *cmd;
 
