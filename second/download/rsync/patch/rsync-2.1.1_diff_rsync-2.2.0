diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/acconfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/acconfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/acconfig.h	1998-07-17 22:46:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/acconfig.h	1998-11-04 06:00:45.000000000 +0800
@@ -5,6 +5,7 @@
 #undef HAVE_REMSH
 #undef HAVE_UNSIGNED_CHAR
 #undef HAVE_UTIMBUF
 #undef ino_t
 #undef HAVE_CONNECT
 #undef HAVE_SHORT_INO_T
+#undef REPLACE_INET_NTOA
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0: aclocal.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/checksum.c	1998-06-18 18:30:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/checksum.c	1998-11-04 06:00:45.000000000 +0800
@@ -46,88 +46,77 @@
 	s1 += (buf[i]+CHAR_OFFSET); s2 += s1;
     }
     return (s1 & 0xffff) + (s2 << 16);
 }
 
 
-static void sum_put(MDstruct *md,char *sum)
-{
-  SIVAL(sum,0,md->buffer[0]);
-  if (csum_length <= 4) return;
-  SIVAL(sum,4,md->buffer[1]);
-  if (csum_length <= 8) return;
-  SIVAL(sum,8,md->buffer[2]);
-  if (csum_length <= 12) return;
-  SIVAL(sum,12,md->buffer[3]);
-}
-
-
 void get_checksum2(char *buf,int len,char *sum)
 {
-  int i;
-  MDstruct MD;
-  static char *buf1;
-  static int len1;
-
-  if (len > len1) {
-    if (buf1) free(buf1);
-    buf1 = (char *)malloc(len+4);
-    len1 = len;
-    if (!buf1) out_of_memory("get_checksum2");
-  }
-
-  MDbegin(&MD);
-
-  memcpy(buf1,buf,len);
-  if (checksum_seed) {
-    SIVAL(buf1,len,checksum_seed);
-    len += 4;
-  }
-
-  for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
-    MDupdate(&MD, buf1+i, CSUM_CHUNK*8);
-  }
-  if (len - i > 0)
-    MDupdate(&MD, buf1+i, (len-i)*8);
-
-  sum_put(&MD,sum);
+	int i;
+	static char *buf1;
+	static int len1;
+	struct mdfour m;
+
+	if (len > len1) {
+		if (buf1) free(buf1);
+		buf1 = (char *)malloc(len+4);
+		len1 = len;
+		if (!buf1) out_of_memory("get_checksum2");
+	}
+	
+	mdfour_begin(&m);
+	
+	memcpy(buf1,buf,len);
+	if (checksum_seed) {
+		SIVAL(buf1,len,checksum_seed);
+		len += 4;
+	}
+	
+	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
+		mdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);
+	}
+	if (len - i > 0) {
+		mdfour_update(&m, (uchar *)(buf1+i), (len-i));
+	}
+	
+	mdfour_result(&m, (uchar *)sum);
 }
 
 
 void file_checksum(char *fname,char *sum,OFF_T size)
 {
-  OFF_T i;
-  MDstruct MD;
-  struct map_struct *buf;
-  int fd;
-  OFF_T len = size;
-  char tmpchunk[CSUM_CHUNK];
-
-  memset(sum,0,csum_length);
-
-  fd = open(fname,O_RDONLY);
-  if (fd == -1) return;
+	OFF_T i;
+	struct map_struct *buf;
+	int fd;
+	OFF_T len = size;
+	char tmpchunk[CSUM_CHUNK];
+	struct mdfour m;
+	
+	memset(sum,0,csum_length);
+	
+	fd = open(fname,O_RDONLY);
+	if (fd == -1) return;
+	
+	buf = map_file(fd,size);
+	
+	mdfour_begin(&m);
+
+	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
+		memcpy(tmpchunk, map_ptr(buf,i,CSUM_CHUNK), CSUM_CHUNK);
+		mdfour_update(&m, (uchar *)tmpchunk, CSUM_CHUNK);
+	}
+
+	if (len - i > 0) {
+		memcpy(tmpchunk, map_ptr(buf,i,len-i), len-i);
+		mdfour_update(&m, (uchar *)tmpchunk, (len-i));
+	}
 
-  buf = map_file(fd,size);
+	mdfour_result(&m, (uchar *)sum);
 
-  MDbegin(&MD);
-
-  for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
-    memcpy(tmpchunk, map_ptr(buf,i,CSUM_CHUNK), CSUM_CHUNK);
-    MDupdate(&MD, tmpchunk, CSUM_CHUNK*8);
-  }
-
-  if (len - i > 0) {
-    memcpy(tmpchunk, map_ptr(buf,i,len-i), len-i);
-    MDupdate(&MD, tmpchunk, (len-i)*8);
-  }
-
-  sum_put(&MD,sum);
-
-  close(fd);
-  unmap_file(buf);
+	close(fd);
+	unmap_file(buf);
 }
 
 
 void checksum_init(void)
 {
   if (remote_version >= 14)
@@ -135,61 +124,57 @@
   else
     csum_length = SUM_LENGTH;
 }
 
 
 
-static MDstruct sumMD;
 static int sumresidue;
 static char sumrbuf[CSUM_CHUNK];
+static struct mdfour md;
 
 void sum_init(void)
 {
-  char s[4];
-  MDbegin(&sumMD);  
-  sumresidue=0;
-  SIVAL(s,0,checksum_seed);
-  sum_update(s,4);
+	char s[4];
+	mdfour_begin(&md);
+	sumresidue=0;
+	SIVAL(s,0,checksum_seed);
+	sum_update(s,4);
 }
 
 void sum_update(char *p,int len)
 {
-  int i;
-  if (len + sumresidue < CSUM_CHUNK) {
-    memcpy(sumrbuf+sumresidue, p, len);
-    sumresidue += len;
-    return;
-  }
-
-  if (sumresidue) {
-    i = MIN(CSUM_CHUNK-sumresidue,len);
-    memcpy(sumrbuf+sumresidue,p,i);
-    MDupdate(&sumMD, sumrbuf, (i+sumresidue)*8);
-    len -= i;
-    p += i;
-  }
-
-  for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
-    memcpy(sumrbuf,p+i,CSUM_CHUNK);
-    MDupdate(&sumMD, sumrbuf, CSUM_CHUNK*8);
-  }
-
-  if (len - i > 0) {
-    sumresidue = len-i;
-    memcpy(sumrbuf,p+i,sumresidue);
-  } else {
-    sumresidue = 0;    
-  }
+	int i;
+	if (len + sumresidue < CSUM_CHUNK) {
+		memcpy(sumrbuf+sumresidue, p, len);
+		sumresidue += len;
+		return;
+	}
+
+	if (sumresidue) {
+		i = MIN(CSUM_CHUNK-sumresidue,len);
+		memcpy(sumrbuf+sumresidue,p,i);
+		mdfour_update(&md, (uchar *)sumrbuf, (i+sumresidue));
+		len -= i;
+		p += i;
+	}
+
+	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
+		memcpy(sumrbuf,p+i,CSUM_CHUNK);
+		mdfour_update(&md, (uchar *)sumrbuf, CSUM_CHUNK);
+	}
+
+	if (len - i > 0) {
+		sumresidue = len-i;
+		memcpy(sumrbuf,p+i,sumresidue);
+	} else {
+		sumresidue = 0;    
+	}
 }
 
 void sum_end(char *sum)
 {
-  if (sumresidue)
-    MDupdate(&sumMD, sumrbuf, sumresidue*8);
+	if (sumresidue) {
+		mdfour_update(&md, (uchar *)sumrbuf, sumresidue);
+	}
 
-  SIVAL(sum,0,sumMD.buffer[0]);
-  SIVAL(sum,4,sumMD.buffer[1]);
-  SIVAL(sum,8,sumMD.buffer[2]);
-  SIVAL(sum,12,sumMD.buffer[3]);  
+	mdfour_result(&md, (uchar *)sum);
 }
-
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/cleanup.c	1998-09-09 14:23:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/cleanup.c	1998-11-04 06:00:45.000000000 +0800
@@ -26,12 +26,13 @@
 
 static char *cleanup_fname;
 static char *cleanup_new_fname;
 static struct file_struct *cleanup_file;
 static int cleanup_fd1, cleanup_fd2;
 static struct map_struct *cleanup_buf;
+static int cleanup_pid = 0;
 
 void exit_cleanup(int code)
 {
 	extern int keep_partial;
 
 	signal(SIGUSR1, SIG_IGN);
@@ -47,12 +48,21 @@
 	io_flush();
 	if (cleanup_fname)
 		do_unlink(cleanup_fname);
 	if (code) {
 		kill_all(SIGUSR1);
 	}
+	if ((cleanup_pid != 0) && (cleanup_pid == (int) getpid())) {
+		char *pidf = lp_pid_file();
+		if (pidf && *pidf) {
+			unlink(lp_pid_file());
+		}
+	}
+
+	if (code) log_exit(code);
+
 	exit(code);
 }
 
 void cleanup_disable(void)
 {
 	cleanup_fname = NULL;
@@ -67,6 +77,11 @@
 	cleanup_new_fname = fname;
 	cleanup_file = file;
 	cleanup_buf = buf;
 	cleanup_fd1 = fd1;
 	cleanup_fd2 = fd2;
 }
+
+void cleanup_set_pid(int pid)
+{
+	cleanup_pid = pid;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/clientserver.c	1998-09-09 15:06:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/clientserver.c	1998-11-04 06:00:45.000000000 +0800
@@ -21,12 +21,13 @@
 #include "rsync.h"
 
 extern int module_id;
 extern int read_only;
 extern int verbose;
 extern int rsync_port;
+char *auth_user;
 
 int start_socket_client(char *host, char *path, int argc, char *argv[])
 {
 	int fd, i;
 	char *sargs[MAX_ARGS];
 	int sargc=0;
@@ -52,13 +53,13 @@
 	if (!user) user = getenv("LOGNAME");
 
 	am_client = 1;
 
 	fd = open_socket_out(host, rsync_port);
 	if (fd == -1) {
-		exit_cleanup(1);
+		exit_cleanup(RERR_SOCKETIO);
 	}
 	
 	server_options(sargs,&sargc);
 
 	sargs[sargc++] = ".";
 
@@ -118,13 +119,13 @@
 	uid_t uid = (uid_t)-2;
 	gid_t gid = (gid_t)-2;
 	char *p;
 	char *addr = client_addr(fd);
 	char *host = client_name(fd);
 	char *name = lp_name(i);
-	char *user;
+	int use_chroot = lp_use_chroot(i);
 	int start_glob=0;
 	int ret;
 	char *request=NULL;
 	extern int am_sender;
 	extern int remote_version;
 	extern int am_root;
@@ -149,15 +150,15 @@
 			io_printf(fd,"@ERROR: max connections (%d) reached - try again later\n", lp_max_connections());
 		}
 		return -1;
 	}
 
 	
-	user = auth_server(fd, i, addr, "@RSYNCD: AUTHREQD ");
+	auth_user = auth_server(fd, i, addr, "@RSYNCD: AUTHREQD ");
 
-	if (!user) {
+	if (!auth_user) {
 		rprintf(FERROR,"auth failed on module %s from %s (%s)\n",
 			name, client_name(fd), client_addr(fd));
 		io_printf(fd,"@ERROR: auth failed on module %s\n",name);
 		return -1;		
 	}
 
@@ -191,34 +192,43 @@
 
 	p = lp_exclude(i);
 	add_exclude_line(p);
 
 	log_open();
 
-	if (chroot(lp_path(i))) {
-		rprintf(FERROR,"chroot %s failed\n", lp_path(i));
-		io_printf(fd,"@ERROR: chroot failed\n");
-		return -1;
-	}
+	if (use_chroot) {
+		if (chroot(lp_path(i))) {
+			rprintf(FERROR,"chroot %s failed\n", lp_path(i));
+			io_printf(fd,"@ERROR: chroot failed\n");
+			return -1;
+		}
 
-	if (chdir("/")) {
-		rprintf(FERROR,"chdir %s failed\n", lp_path(i));
-		io_printf(fd,"@ERROR: chdir failed\n");
-		return -1;
-	}
+		if (chdir("/")) {
+			rprintf(FERROR,"chdir %s failed\n", lp_path(i));
+			io_printf(fd,"@ERROR: chdir failed\n");
+			return -1;
+		}
 
-	if (setgid(gid) || getgid() != gid) {
-		rprintf(FERROR,"setgid %d failed\n", gid);
-		io_printf(fd,"@ERROR: setgid failed\n");
-		return -1;
-	}
+		if (setgid(gid) || getgid() != gid) {
+			rprintf(FERROR,"setgid %d failed\n", gid);
+			io_printf(fd,"@ERROR: setgid failed\n");
+			return -1;
+		}
 
-	if (setuid(uid) || getuid() != uid) {
-		rprintf(FERROR,"setuid %d failed\n", uid);
-		io_printf(fd,"@ERROR: setuid failed\n");
-		return -1;
+		if (setuid(uid) || getuid() != uid) {
+			rprintf(FERROR,"setuid %d failed\n", uid);
+			io_printf(fd,"@ERROR: setuid failed\n");
+			return -1;
+		}
+
+	} else {
+		if (!push_dir(lp_path(i), 0)) {
+			rprintf(FERROR,"chdir %s failed\n", lp_path(i));
+			io_printf(fd,"@ERROR: chdir failed\n");
+			return -1;
+		}
 	}
 
 	am_root = (getuid() == 0);
 
 	io_printf(fd,"@RSYNCD: OK\n");
 
@@ -254,19 +264,34 @@
 
 		if (argc == MAX_ARGS) {
 			return -1;
 		}
 	}
 
+	if (!use_chroot) {
+		/*
+		 * Note that this is applied to all parameters, whether or not
+		 *    they are filenames, but no other legal parameters contain
+		 *    the forms that need to be sanitized so it doesn't hurt;
+		 *    it is not known at this point which parameters are files
+		 *    and which aren't.
+		 */
+		for (i = 1; i < argc; i++) {
+			char *copy = sanitize_path(argv[i]);
+			free((void *)argv[i]);
+			argv[i] = copy;
+		}
+	}
+
 	ret = parse_arguments(argc, argv);
 
 	if (request) {
-		if (*user) {
+		if (*auth_user) {
 			rprintf(FINFO,"rsync %s %s from %s@%s (%s)\n",
 				am_sender?"on":"to",
-				request, user, host, addr);
+				request, auth_user, host, addr);
 		} else {
 			rprintf(FINFO,"rsync %s %s from %s (%s)\n",
 				am_sender?"on":"to",
 				request, host, addr);
 		}
 		free(request);
@@ -283,13 +308,13 @@
 
 	if (remote_version > 17 && am_sender)
 		io_start_multiplex_out(fd);
 
 	if (!ret) {
 		rprintf(FERROR,"Error parsing options (unsupported option?) - aborting\n");
-		exit_cleanup(1);
+		exit_cleanup(RERR_SYNTAX);
 	}
 
 	start_server(fd, fd, argc, argp);
 
 	return 0;
 }
@@ -315,23 +340,23 @@
 	char *motd;
 	int i = -1;
 	extern char *config_file;
 	extern int remote_version;
 
 	if (!lp_load(config_file, 0)) {
-		exit_cleanup(1);
+		exit_cleanup(RERR_SYNTAX);
 	}
 
 	set_socket_options(fd,"SO_KEEPALIVE");
 	set_socket_options(fd,lp_socket_options());
 	
 
 	io_printf(fd,"@RSYNCD: %d\n", PROTOCOL_VERSION);
 
 	motd = lp_motd_file();
-	if (*motd) {
+	if (motd && *motd) {
 		FILE *f = fopen(motd,"r");
 		while (f && !feof(f)) {
 			int len = fread(line, 1, sizeof(line)-1, f);
 			if (len > 0) {
 				line[len] = 0;
 				io_printf(fd,"%s", line);
@@ -378,12 +403,13 @@
 }
 
 
 int daemon_main(void)
 {
 	extern char *config_file;
+	char *pid_file;
 
 	/* this ensures that we don't call getcwd after the chroot,
            which doesn't work on platforms that use popen("pwd","r")
            for getcwd */
 	push_dir("/", 0);
 
@@ -404,17 +430,30 @@
 	}
 
 	become_daemon();
 
 	if (!lp_load(config_file, 1)) {
 		fprintf(stderr,"failed to load config file %s\n", config_file);
-		exit_cleanup(1);
+		exit_cleanup(RERR_SYNTAX);
 	}
 
 	log_open();
 
 	rprintf(FINFO,"rsyncd version %s starting\n",VERSION);
 
+	if (((pid_file = lp_pid_file()) != NULL) && (*pid_file != '\0')) {
+		FILE *f;
+		int pid = (int) getpid();
+		cleanup_set_pid(pid);
+		if ((f = fopen(lp_pid_file(), "w")) == NULL) {
+		    cleanup_set_pid(0);
+		    fprintf(stderr,"failed to create pid file %s\n", pid_file);
+		    exit_cleanup(RERR_FILEIO);
+		}
+		fprintf(f, "%d\n", pid);
+		fclose(f);
+	}
+
 	start_accept_loop(rsync_port, start_daemon);
 	return -1;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/compat.c	1998-07-17 22:46:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/compat.c	1998-11-04 06:00:45.000000000 +0800
@@ -51,13 +51,13 @@
 	}
 
 	if (remote_version < MIN_PROTOCOL_VERSION ||
 	    remote_version > MAX_PROTOCOL_VERSION) {
 		rprintf(FERROR,"protocol version mismatch - is your shell clean?\n");
 		rprintf(FERROR,"(see the rsync man page for an explanation)\n");
-		exit_cleanup(1);
+		exit_cleanup(RERR_PROTOCOL);
 	}	
 	
 	if (verbose > 2)
 		rprintf(FINFO, "local_version=%d remote_version=%d\n",
 			PROTOCOL_VERSION, remote_version);
 	
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0: config.guess
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/config.h.in	1998-09-09 15:06:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/config.h.in	1998-11-04 06:00:45.000000000 +0800
@@ -39,22 +39,27 @@
 /* Define if you can safely include both <sys/time.h> and <time.h>.  */
 #undef TIME_WITH_SYS_TIME
 
 /* Define to `int' if <sys/types.h> doesn't define.  */
 #undef uid_t
 
+/* Define if your processor stores words with the most significant
+   byte first (like Motorola and SPARC, unlike Intel and VAX).  */
+#undef WORDS_BIGENDIAN
+
 #undef HAVE_BROKEN_READDIR
 #undef HAVE_ERRNO_DECL
 #undef HAVE_LONGLONG
 #undef HAVE_OFF64_T
 #undef HAVE_REMSH
 #undef HAVE_UNSIGNED_CHAR
 #undef HAVE_UTIMBUF
 #undef ino_t
 #undef HAVE_CONNECT
 #undef HAVE_SHORT_INO_T
+#undef REPLACE_INET_NTOA
 
 /* The number of bytes in a int.  */
 #undef SIZEOF_INT
 
 /* The number of bytes in a long.  */
 #undef SIZEOF_LONG
@@ -65,12 +70,15 @@
 /* Define if you have the chmod function.  */
 #undef HAVE_CHMOD
 
 /* Define if you have the chown function.  */
 #undef HAVE_CHOWN
 
+/* Define if you have the connect function.  */
+#undef HAVE_CONNECT
+
 /* Define if you have the fchmod function.  */
 #undef HAVE_FCHMOD
 
 /* Define if you have the fstat function.  */
 #undef HAVE_FSTAT
 
@@ -104,12 +112,15 @@
 /* Define if you have the readlink function.  */
 #undef HAVE_READLINK
 
 /* Define if you have the setsid function.  */
 #undef HAVE_SETSID
 
+/* Define if you have the snprintf function.  */
+#undef HAVE_SNPRINTF
+
 /* Define if you have the strchr function.  */
 #undef HAVE_STRCHR
 
 /* Define if you have the strdup function.  */
 #undef HAVE_STRDUP
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0: config.sub
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/configure	1998-09-09 15:06:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/configure	1998-11-04 06:00:45.000000000 +0800
@@ -517,16 +517,144 @@
   ac_n= ac_c='\c' ac_t=
 fi
 
 
 
 
+ac_aux_dir=
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
+fi
+ac_config_guess=$ac_aux_dir/config.guess
+ac_config_sub=$ac_aux_dir/config.sub
+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
+
+
+# Do some error checking and defaulting for the host and target type.
+# The inputs are:
+#    configure --host=HOST --target=TARGET --build=BUILD NONOPT
+#
+# The rules are:
+# 1. You are not allowed to specify --host, --target, and nonopt at the
+#    same time.
+# 2. Host defaults to nonopt.
+# 3. If nonopt is not specified, then host defaults to the current host,
+#    as determined by config.guess.
+# 4. Target and build default to nonopt.
+# 5. If nonopt is not specified, then target and build default to host.
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+case $host---$target---$nonopt in
+NONE---*---* | *---NONE---* | *---*---NONE) ;;
+*) { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; } ;;
+esac
+
+
+# Make sure we can run config.sub.
+if $ac_config_sub sun4 >/dev/null 2>&1; then :
+else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
+fi
+
+echo $ac_n "checking host system type""... $ac_c" 1>&6
+echo "configure:571: checking host system type" >&5
+
+host_alias=$host
+case "$host_alias" in
+NONE)
+  case $nonopt in
+  NONE)
+    if host_alias=`$ac_config_guess`; then :
+    else { echo "configure: error: can not guess host type; you must specify one" 1>&2; exit 1; }
+    fi ;;
+  *) host_alias=$nonopt ;;
+  esac ;;
+esac
+
+host=`$ac_config_sub $host_alias`
+host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$host" 1>&6
+
+echo $ac_n "checking target system type""... $ac_c" 1>&6
+echo "configure:592: checking target system type" >&5
+
+target_alias=$target
+case "$target_alias" in
+NONE)
+  case $nonopt in
+  NONE) target_alias=$host_alias ;;
+  *) target_alias=$nonopt ;;
+  esac ;;
+esac
+
+target=`$ac_config_sub $target_alias`
+target_cpu=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$target" 1>&6
+
+echo $ac_n "checking build system type""... $ac_c" 1>&6
+echo "configure:610: checking build system type" >&5
+
+build_alias=$build
+case "$build_alias" in
+NONE)
+  case $nonopt in
+  NONE) build_alias=$host_alias ;;
+  *) build_alias=$nonopt ;;
+  esac ;;
+esac
+
+build=`$ac_config_sub $build_alias`
+build_cpu=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+echo "$ac_t""$build" 1>&6
+
+test "$host_alias" != "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+
+    
+    echo $ac_n "checking config.cache system type""... $ac_c" 1>&6
+echo "configure:635: checking config.cache system type" >&5
+    if { test x"${ac_cv_host_system_type+set}" = x"set" &&
+         test x"$ac_cv_host_system_type" != x"$host"; } ||
+       { test x"${ac_cv_build_system_type+set}" = x"set" &&
+         test x"$ac_cv_build_system_type" != x"$build"; } ||
+       { test x"${ac_cv_target_system_type+set}" = x"set" &&
+         test x"$ac_cv_target_system_type" != x"$target"; }; then
+	echo "$ac_t""different" 1>&6
+	{ echo "configure: error: "you must remove config.cache and restart configure"" 1>&2; exit 1; }
+    else
+	echo "$ac_t""same" 1>&6
+    fi
+    ac_cv_host_system_type="$host"
+    ac_cv_build_system_type="$build"
+    ac_cv_target_system_type="$target"
+
+
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:527: checking for $ac_word" >&5
+echo "configure:655: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -549,13 +677,13 @@
 fi
 
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:556: checking for $ac_word" >&5
+echo "configure:684: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -597,27 +725,27 @@
 fi
 
   test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:604: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:732: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
 ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext <<EOF
-#line 614 "configure"
+#line 742 "configure"
 #include "confdefs.h"
 main(){return(0);}
 EOF
-if { (eval echo configure:618: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:746: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
     ac_cv_prog_cc_cross=no
   else
     ac_cv_prog_cc_cross=yes
@@ -631,27 +759,27 @@
 
 echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
 if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:638: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:766: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:643: checking whether we are using GNU C" >&5
+echo "configure:771: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.c <<EOF
 #ifdef __GNUC__
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:652: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:780: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
 fi
 fi
 
@@ -660,13 +788,13 @@
 if test $ac_cv_prog_gcc = yes; then
   GCC=yes
   ac_test_CFLAGS="${CFLAGS+set}"
   ac_save_CFLAGS="$CFLAGS"
   CFLAGS=
   echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:667: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:795: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo 'void f(){}' > conftest.c
 if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
   ac_cv_prog_cc_g=yes
@@ -687,43 +815,24 @@
   fi
 else
   GCC=
   test "${CFLAGS+set}" = set || CFLAGS="-g"
 fi
 
-ac_aux_dir=
-for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
-  if test -f $ac_dir/install-sh; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f $ac_dir/install.sh; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
-fi
-ac_config_guess=$ac_aux_dir/config.guess
-ac_config_sub=$ac_aux_dir/config.sub
-ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
-
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
 # incompatible versions:
 # SysV /etc/install, /usr/sbin/install
 # SunOS /usr/etc/install
 # IRIX /sbin/install
 # AIX /bin/install
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:724: checking for a BSD compatible install" >&5
+echo "configure:833: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS="${IFS}:"
   for ac_dir in $PATH; do
@@ -771,13 +880,13 @@
 
 
 
 # Extract the first word of "remsh", so it can be a program name with args.
 set dummy remsh; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:778: checking for $ac_word" >&5
+echo "configure:887: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_HAVE_REMSH'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$HAVE_REMSH"; then
   ac_cv_prog_HAVE_REMSH="$HAVE_REMSH" # Let the user override the test.
 else
@@ -802,31 +911,121 @@
 
 cat >> confdefs.h <<EOF
 #define HAVE_REMSH $HAVE_REMSH
 EOF
 
 
+echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
+echo "configure:919: checking whether byte ordering is bigendian" >&5
+if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_cv_c_bigendian=unknown
+# See if sys/param.h defines the BYTE_ORDER macro.
+cat > conftest.$ac_ext <<EOF
+#line 926 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/param.h>
+int main() {
+
+#if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
+ bogus endian macros
+#endif
+; return 0; }
+EOF
+if { (eval echo configure:937: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  # It does; now see whether it defined to BIG_ENDIAN or not.
+cat > conftest.$ac_ext <<EOF
+#line 941 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/param.h>
+int main() {
+
+#if BYTE_ORDER != BIG_ENDIAN
+ not big endian
+#endif
+; return 0; }
+EOF
+if { (eval echo configure:952: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_c_bigendian=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_c_bigendian=no
+fi
+rm -f conftest*
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+fi
+rm -f conftest*
+if test $ac_cv_c_bigendian = unknown; then
+if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 972 "configure"
+#include "confdefs.h"
+main () {
+  /* Are we little or big endian?  From Harbison&Steele.  */
+  union
+  {
+    long l;
+    char c[sizeof (long)];
+  } u;
+  u.l = 1;
+  exit (u.c[sizeof (long) - 1] == 1);
+}
+EOF
+if { (eval echo configure:985: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_c_bigendian=no
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_c_bigendian=yes
+fi
+rm -fr conftest*
+fi
+
+fi
+fi
+
+echo "$ac_t""$ac_cv_c_bigendian" 1>&6
+if test $ac_cv_c_bigendian = yes; then
+  cat >> confdefs.h <<\EOF
+#define WORDS_BIGENDIAN 1
+EOF
+
+fi
+
 ac_header_dirent=no
 for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:814: checking for $ac_hdr that defines DIR" >&5
+echo "configure:1013: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 819 "configure"
+#line 1018 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
 int main() {
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:827: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1026: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -845,32 +1044,32 @@
   echo "$ac_t""no" 1>&6
 fi
 done
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:852: checking for opendir in -ldir" >&5
+echo "configure:1051: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 860 "configure"
+#line 1059 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char opendir();
 
 int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:871: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:1070: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -886,32 +1085,32 @@
 else
   echo "$ac_t""no" 1>&6
 fi
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:893: checking for opendir in -lx" >&5
+echo "configure:1092: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 901 "configure"
+#line 1100 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char opendir();
 
 int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:912: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:1111: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -928,27 +1127,27 @@
   echo "$ac_t""no" 1>&6
 fi
 
 fi
 
 echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:935: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:1134: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 940 "configure"
+#line 1139 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
 #include <time.h>
 int main() {
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:949: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1148: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -963,18 +1162,18 @@
 #define TIME_WITH_SYS_TIME 1
 EOF
 
 fi
 
 echo $ac_n "checking for sys/wait.h that is POSIX.1 compatible""... $ac_c" 1>&6
-echo "configure:970: checking for sys/wait.h that is POSIX.1 compatible" >&5
+echo "configure:1169: checking for sys/wait.h that is POSIX.1 compatible" >&5
 if eval "test \"`echo '$''{'ac_cv_header_sys_wait_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 975 "configure"
+#line 1174 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/wait.h>
 #ifndef WEXITSTATUS
 #define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
 #endif
@@ -984,13 +1183,13 @@
 int main() {
 int s;
 wait (&s);
 s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
 ; return 0; }
 EOF
-if { (eval echo configure:991: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1190: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_sys_wait_h=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1005,13 +1204,13 @@
 #define HAVE_SYS_WAIT_H 1
 EOF
 
 fi
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:1012: checking how to run the C preprocessor" >&5
+echo "configure:1211: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
 fi
 if test -z "$CPP"; then
 if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
@@ -1020,36 +1219,36 @@
     # This must be in double quotes, not single quotes, because CPP may get
   # substituted into the Makefile and "${CC-cc}" will confuse make.
   CPP="${CC-cc} -E"
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 1027 "configure"
+#line 1226 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1033: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1232: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 1044 "configure"
+#line 1243 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1050: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1249: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
@@ -1069,23 +1268,23 @@
 echo "$ac_t""$CPP" 1>&6
 
 for ac_hdr in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h unistd.h utime.h grp.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1076: checking for $ac_hdr" >&5
+echo "configure:1275: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1081 "configure"
+#line 1280 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1086: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1285: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -1109,23 +1308,23 @@
 done
 
 for ac_hdr in compat.h sys/param.h ctype.h sys/wait.h sys/ioctl.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1116: checking for $ac_hdr" >&5
+echo "configure:1315: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1121 "configure"
+#line 1320 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1126: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1325: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -1149,23 +1348,23 @@
 done
 
 for ac_hdr in sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1156: checking for $ac_hdr" >&5
+echo "configure:1355: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1161 "configure"
+#line 1360 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1166: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1365: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -1189,23 +1388,23 @@
 done
 
 for ac_hdr in glob.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1196: checking for $ac_hdr" >&5
+echo "configure:1395: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1201 "configure"
+#line 1400 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1206: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1405: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -1227,32 +1426,32 @@
   echo "$ac_t""no" 1>&6
 fi
 done
 
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:1234: checking size of int" >&5
+echo "configure:1433: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 1242 "configure"
+#line 1441 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(int));
   exit(0);
 }
 EOF
-if { (eval echo configure:1253: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1452: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1266,32 +1465,32 @@
 cat >> confdefs.h <<EOF
 #define SIZEOF_INT $ac_cv_sizeof_int
 EOF
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:1273: checking size of long" >&5
+echo "configure:1472: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 1281 "configure"
+#line 1480 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long));
   exit(0);
 }
 EOF
-if { (eval echo configure:1292: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1491: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1305,32 +1504,32 @@
 cat >> confdefs.h <<EOF
 #define SIZEOF_LONG $ac_cv_sizeof_long
 EOF
 
 
 echo $ac_n "checking size of short""... $ac_c" 1>&6
-echo "configure:1312: checking size of short" >&5
+echo "configure:1511: checking size of short" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 1320 "configure"
+#line 1519 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(short));
   exit(0);
 }
 EOF
-if { (eval echo configure:1331: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1530: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_short=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1345,27 +1544,27 @@
 #define SIZEOF_SHORT $ac_cv_sizeof_short
 EOF
 
 
 
 echo $ac_n "checking for inline""... $ac_c" 1>&6
-echo "configure:1352: checking for inline" >&5
+echo "configure:1551: checking for inline" >&5
 if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat > conftest.$ac_ext <<EOF
-#line 1359 "configure"
+#line 1558 "configure"
 #include "confdefs.h"
 
 int main() {
 } $ac_kw foo() {
 ; return 0; }
 EOF
-if { (eval echo configure:1366: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1565: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_inline=$ac_kw; break
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -1386,18 +1585,18 @@
 EOF
  ;;
 esac
 
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:1393: checking return type of signal handlers" >&5
+echo "configure:1592: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1398 "configure"
+#line 1597 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
 #ifdef signal
 #undef signal
 #endif
@@ -1408,13 +1607,13 @@
 #endif
 
 int main() {
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:1415: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1614: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1427,18 +1626,18 @@
 cat >> confdefs.h <<EOF
 #define RETSIGTYPE $ac_cv_type_signal
 EOF
 
 
 echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:1434: checking for uid_t in sys/types.h" >&5
+echo "configure:1633: checking for uid_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1439 "configure"
+#line 1638 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "uid_t" >/dev/null 2>&1; then
   rm -rf conftest*
@@ -1461,26 +1660,26 @@
 #define gid_t int
 EOF
 
 fi
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:1468: checking for ANSI C header files" >&5
+echo "configure:1667: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1473 "configure"
+#line 1672 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1481: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1680: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   ac_cv_header_stdc=yes
 else
   echo "$ac_err" >&5
@@ -1491,13 +1690,13 @@
 fi
 rm -f conftest*
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 1498 "configure"
+#line 1697 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "memchr" >/dev/null 2>&1; then
   :
@@ -1509,13 +1708,13 @@
 
 fi
 
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 1516 "configure"
+#line 1715 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "free" >/dev/null 2>&1; then
   :
@@ -1530,24 +1729,24 @@
 if test $ac_cv_header_stdc = yes; then
   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
 if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 1537 "configure"
+#line 1736 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
 #define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
 #define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int main () { int i; for (i = 0; i < 256; i++)
 if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
 exit (0); }
 
 EOF
-if { (eval echo configure:1548: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1747: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1565,18 +1764,18 @@
 #define STDC_HEADERS 1
 EOF
 
 fi
 
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:1572: checking for mode_t" >&5
+echo "configure:1771: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1577 "configure"
+#line 1776 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1598,18 +1797,18 @@
 #define mode_t int
 EOF
 
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:1605: checking for off_t" >&5
+echo "configure:1804: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1610 "configure"
+#line 1809 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1631,18 +1830,18 @@
 #define off_t long
 EOF
 
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:1638: checking for size_t" >&5
+echo "configure:1837: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1643 "configure"
+#line 1842 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1664,18 +1863,18 @@
 #define size_t unsigned
 EOF
 
 fi
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:1671: checking for pid_t" >&5
+echo "configure:1870: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1676 "configure"
+#line 1875 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1697,26 +1896,26 @@
 #define pid_t int
 EOF
 
 fi
 
 echo $ac_n "checking for st_rdev in struct stat""... $ac_c" 1>&6
-echo "configure:1704: checking for st_rdev in struct stat" >&5
+echo "configure:1903: checking for st_rdev in struct stat" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_st_rdev'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1709 "configure"
+#line 1908 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
 int main() {
 struct stat s; s.st_rdev;
 ; return 0; }
 EOF
-if { (eval echo configure:1717: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1916: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_st_rdev=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1731,18 +1930,18 @@
 #define HAVE_ST_RDEV 1
 EOF
 
 fi
 
 echo $ac_n "checking for ino_t""... $ac_c" 1>&6
-echo "configure:1738: checking for ino_t" >&5
+echo "configure:1937: checking for ino_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ino_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1743 "configure"
+#line 1942 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1764,55 +1963,66 @@
 #define ino_t unsigned
 EOF
 
 fi
 
 
-echo $ac_n "checking for errno in errno.h... $ac_c"
-cat > conftest.$ac_ext <<EOF
-#line 1773 "configure"
+echo $ac_n "checking for errno in errno.h""... $ac_c" 1>&6
+echo "configure:1971: checking for errno in errno.h" >&5
+if eval "test \"`echo '$''{'rsync_cv_errno'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
+    cat > conftest.$ac_ext <<EOF
+#line 1977 "configure"
 #include "confdefs.h"
 #include <errno.h>
 int main() {
 int i = errno
 ; return 0; }
 EOF
-if { (eval echo configure:1780: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1984: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
-  echo yes; cat >> confdefs.h <<\EOF
-#define HAVE_ERRNO_DECL 1
-EOF
-
+  rsync_cv_errno=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
-  echo no
+  rsync_cv_have_errno_decl=no
 fi
 rm -f conftest*
+fi
+
+echo "$ac_t""$rsync_cv_errno" 1>&6
+if test x"$rsync_cv_errno" = x"yes"; then
+   cat >> confdefs.h <<\EOF
+#define HAVE_ERRNO_DECL 1
+EOF
+
+fi
 
 echo $ac_n "checking for 8-bit clean memcmp""... $ac_c" 1>&6
-echo "configure:1795: checking for 8-bit clean memcmp" >&5
+echo "configure:2005: checking for 8-bit clean memcmp" >&5
 if eval "test \"`echo '$''{'ac_cv_func_memcmp_clean'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_func_memcmp_clean=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 1803 "configure"
+#line 2013 "configure"
 #include "confdefs.h"
 
 main()
 {
   char c0 = 0x40, c1 = 0x80, c2 = 0x81;
   exit(memcmp(&c0, &c2, 1) < 0 && memcmp(&c1, &c2, 1) < 0 ? 0 : 1);
 }
 
 EOF
-if { (eval echo configure:1813: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2023: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_memcmp_clean=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1824,34 +2034,34 @@
 fi
 
 echo "$ac_t""$ac_cv_func_memcmp_clean" 1>&6
 test $ac_cv_func_memcmp_clean = no && LIBOBJS="$LIBOBJS memcmp.o"
 
 echo $ac_n "checking whether utime accepts a null argument""... $ac_c" 1>&6
-echo "configure:1831: checking whether utime accepts a null argument" >&5
+echo "configure:2041: checking whether utime accepts a null argument" >&5
 if eval "test \"`echo '$''{'ac_cv_func_utime_null'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   rm -f conftestdata; > conftestdata
 # Sequent interprets utime(file, 0) to mean use start of epoch.  Wrong.
 if test "$cross_compiling" = yes; then
   ac_cv_func_utime_null=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 1841 "configure"
+#line 2051 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
 main() {
 struct stat s, t;
 exit(!(stat ("conftestdata", &s) == 0 && utime("conftestdata", (long *)0) == 0
 && stat("conftestdata", &t) == 0 && t.st_mtime >= s.st_mtime
 && t.st_mtime - s.st_mtime < 120));
 }
 EOF
-if { (eval echo configure:1852: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2062: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_utime_null=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1871,18 +2081,18 @@
 
 fi
 
 for ac_func in mmap munmap waitpid getcwd strdup strerror chown chmod mknod
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1878: checking for $ac_func" >&5
+echo "configure:2088: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1883 "configure"
+#line 2093 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1899,13 +2109,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:1906: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2116: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1926,18 +2136,18 @@
 fi
 done
 
 for ac_func in fchmod fstat strchr readlink link utime utimes strftime
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1933: checking for $ac_func" >&5
+echo "configure:2143: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1938 "configure"
+#line 2148 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1954,13 +2164,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:1961: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2171: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1978,21 +2188,21 @@
  
 else
   echo "$ac_t""no" 1>&6
 fi
 done
 
-for ac_func in memmove getopt_long lchown vsnprintf setsid glob strpbrk
+for ac_func in memmove getopt_long lchown vsnprintf snprintf setsid glob strpbrk
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1988: checking for $ac_func" >&5
+echo "configure:2198: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1993 "configure"
+#line 2203 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2009,13 +2219,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2016: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2226: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2039,18 +2249,18 @@
 
 echo $ac_n "checking for working fnmatch... $ac_c"
 if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2046 "configure"
+#line 2256 "configure"
 #include "confdefs.h"
 #include <fnmatch.h>
 main() { exit(fnmatch("*.o", "x.o", 0) == 0? 0: 1); }
 EOF
-if { (eval echo configure:2051: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2261: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   echo yes;cat >> confdefs.h <<\EOF
 #define HAVE_FNMATCH 1
 EOF
 
 else
@@ -2060,78 +2270,100 @@
   echo no
 fi
 rm -fr conftest*
 fi
 
 
-echo $ac_n "checking for long long ... $ac_c"
+echo $ac_n "checking for long long""... $ac_c" 1>&6
+echo "configure:2278: checking for long long" >&5
+if eval "test \"`echo '$''{'rsync_cv_have_longlong'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
 if test "$cross_compiling" = yes; then
-    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+  rsync_cv_have_longlong=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2072 "configure"
+#line 2287 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main() { long long x = 1000000; x *= x; exit(((x/1000000) == 1000000)? 0: 1); }
 EOF
-if { (eval echo configure:2077: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2292: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
-  echo yes;cat >> confdefs.h <<\EOF
-#define HAVE_LONGLONG 1
-EOF
-
+  rsync_cv_have_longlong=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
-  echo no
+  rsync_cv_have_longlong=no
 fi
 rm -fr conftest*
 fi
 
+fi
+
+echo "$ac_t""$rsync_cv_have_longlong" 1>&6
+if test x"$rsync_cv_have_longlong" = x"yes"; then
+    cat >> confdefs.h <<\EOF
+#define HAVE_LONGLONG 1
+EOF
+
+fi
 
-echo $ac_n "checking for off64_t ... $ac_c"
+echo $ac_n "checking for off64_t""... $ac_c" 1>&6
+echo "configure:2315: checking for off64_t" >&5
+if eval "test \"`echo '$''{'rsync_cv_HAVE_OFF64_T'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
 if test "$cross_compiling" = yes; then
-    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+  rsync_cv_HAVE_OFF64_T=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2098 "configure"
+#line 2324 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #include <sys/stat.h>
-main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) return 1; exit((lstat64("/dev/null", &st)==0)?0:1); }
+main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) exit(1); exit((lstat64("/dev/null", &st)==0)?0:1); }
 EOF
-if { (eval echo configure:2104: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2330: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
-  echo yes;cat >> confdefs.h <<\EOF
-#define HAVE_OFF64_T 1
-EOF
-
+  rsync_cv_HAVE_OFF64_T=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
-  echo no
+  rsync_cv_HAVE_OFF64_T=no
 fi
 rm -fr conftest*
 fi
 
+fi
+
+echo "$ac_t""$rsync_cv_HAVE_OFF64_T" 1>&6
+if test x"$rsync_cv_HAVE_OFF64_T" = x"yes"; then
+    cat >> confdefs.h <<\EOF
+#define HAVE_OFF64_T 1
+EOF
+
+fi
 
 echo $ac_n "checking for short ino_t ... $ac_c"
 if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2125 "configure"
+#line 2357 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 main() { if (sizeof(ino_t) < sizeof(unsigned int)) return 0; return 1; }
 EOF
-if { (eval echo configure:2132: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2364: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   echo yes;cat >> confdefs.h <<\EOF
 #define HAVE_SHORT_INO_T 1
 EOF
 
 else
@@ -2141,166 +2373,253 @@
   echo no
 fi
 rm -fr conftest*
 fi
 
 
-echo $ac_n "checking for unsigned char ... $ac_c"
+echo $ac_n "checking for unsigned char""... $ac_c" 1>&6
+echo "configure:2381: checking for unsigned char" >&5
+if eval "test \"`echo '$''{'rsync_cv_HAVE_UNSIGNED_CHAR'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
 if test "$cross_compiling" = yes; then
-    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+  rsync_cv_HAVE_UNSIGNED_CHAR=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2153 "configure"
+#line 2390 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main() { char c; c=250; exit((c > 0)?0:1); }
 EOF
-if { (eval echo configure:2158: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2395: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
-  echo yes;cat >> confdefs.h <<\EOF
-#define HAVE_UNSIGNED_CHAR 1
-EOF
-
+  rsync_cv_HAVE_UNSIGNED_CHAR=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
-  echo no
+  rsync_cv_HAVE_UNSIGNED_CHAR=no
 fi
 rm -fr conftest*
 fi
 
+fi
+
+echo "$ac_t""$rsync_cv_HAVE_UNSIGNED_CHAR" 1>&6
+if test x"$rsync_cv_HAVE_UNSIGNED_CHAR" = x"yes"; then
+    cat >> confdefs.h <<\EOF
+#define HAVE_UNSIGNED_CHAR 1
+EOF
+
+fi
 
-echo $ac_n "checking for broken readdir ... $ac_c"
+echo $ac_n "checking for broken readdir""... $ac_c" 1>&6
+echo "configure:2418: checking for broken readdir" >&5
+if eval "test \"`echo '$''{'rsync_cv_HAVE_BROKEN_READDIR'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
 if test "$cross_compiling" = yes; then
-    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+  rsync_cv_HAVE_BROKEN_READDIR=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2179 "configure"
+#line 2427 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <dirent.h>
 main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
 if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
-di->d_name[0] == 0) return 0; return 1;} 
+di->d_name[0] == 0) exit(0); exit(1);} 
 EOF
-if { (eval echo configure:2187: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2435: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
-  echo yes - you are using the broken /usr/ucb/cc;cat >> confdefs.h <<\EOF
-#define HAVE_BROKEN_READDIR 1
-EOF
-
+  rsync_cv_HAVE_BROKEN_READDIR=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
-  echo no
+  rsync_cv_HAVE_BROKEN_READDIR=no
 fi
 rm -fr conftest*
 fi
 
+fi
 
-echo $ac_n "checking for utimbuf ... $ac_c"
+echo "$ac_t""$rsync_cv_HAVE_BROKEN_READDIR" 1>&6
+if test x"$rsync_cv_HAVE_BROKEN_READDIR" = x"yes"; then
+    cat >> confdefs.h <<\EOF
+#define HAVE_BROKEN_READDIR 1
+EOF
+
+fi
+
+echo $ac_n "checking for utimbuf""... $ac_c" 1>&6
+echo "configure:2458: checking for utimbuf" >&5
+if eval "test \"`echo '$''{'rsync_cv_HAVE_UTIMBUF'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
 cat > conftest.$ac_ext <<EOF
-#line 2205 "configure"
+#line 2464 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <utime.h>
 int main() {
-struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; return utime("foo.c",&tbuf);
+struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));
 ; return 0; }
 EOF
-if { (eval echo configure:2213: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2472: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
-  echo yes;cat >> confdefs.h <<\EOF
+  rsync_cv_HAVE_UTIMBUF=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  rsync_cv_HAVE_UTIMBUF=no
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$rsync_cv_HAVE_UTIMBUF" 1>&6
+if test x"$rsync_cv_HAVE_UTIMBUF" = x"yes"; then
+    cat >> confdefs.h <<\EOF
 #define HAVE_UTIMBUF 1
 EOF
 
+fi
+
+echo $ac_n "checking for broken inet_ntoa""... $ac_c" 1>&6
+echo "configure:2493: checking for broken inet_ntoa" >&5
+if eval "test \"`echo '$''{'rsync_cv_REPLACE_INET_NTOA'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  
+if test "$cross_compiling" = yes; then
+  rsync_cv_REPLACE_INET_NTOA=cross
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2502 "configure"
+#include "confdefs.h"
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+main() { struct in_addr ip; ip.s_addr = 0x12345678;
+if (strcmp(inet_ntoa(ip),"18.52.86.120") &&
+    strcmp(inet_ntoa(ip),"120.86.52.18")) { exit(0); } 
+exit(1);}
+EOF
+if { (eval echo configure:2514: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  rsync_cv_REPLACE_INET_NTOA=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  echo no
+  rm -fr conftest*
+  rsync_cv_REPLACE_INET_NTOA=no
+fi
+rm -fr conftest*
+fi
+
+fi
+
+echo "$ac_t""$rsync_cv_REPLACE_INET_NTOA" 1>&6
+if test x"$rsync_cv_REPLACE_INET_NTOA" = x"yes"; then
+    cat >> confdefs.h <<\EOF
+#define REPLACE_INET_NTOA 1
+EOF
+
 fi
-rm -f conftest*
 
 # The following test taken from the cvs sources
 # If we can't find connect, try looking in -lsocket, -lnsl, and -linet.
 # The Irix 5 libc.so has connect and gethostbyname, but Irix 5 also has
 # libsocket.so which has a bad implementation of gethostbyname (it
 # only looks in /etc/hosts), so we only look for -lsocket if we need
 # it.
-echo $ac_n "checking for connect""... $ac_c" 1>&6
-echo "configure:2234: checking for connect" >&5
-if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
+for ac_func in connect
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2545: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2239 "configure"
+#line 2550 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char connect(); below.  */
+    which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
-char connect();
+char $ac_func();
 
 int main() {
 
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
-#if defined (__stub_connect) || defined (__stub___connect)
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-connect();
+$ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2262: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2573: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
-  eval "ac_cv_func_connect=yes"
+  eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
-  eval "ac_cv_func_connect=no"
+  eval "ac_cv_func_$ac_func=no"
 fi
 rm -f conftest*
 fi
 
-if eval "test \"`echo '$ac_cv_func_'connect`\" = yes"; then
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
   echo "$ac_t""yes" 1>&6
-  :
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
 else
   echo "$ac_t""no" 1>&6
-case "$LIBS" in
-*-lnsl*) ;;
-*) echo $ac_n "checking for printf in -lnsl_s""... $ac_c" 1>&6
-echo "configure:2282: checking for printf in -lnsl_s" >&5
+fi
+done
+
+if test x"$ac_cv_func_connect" = x"no"; then
+    case "$LIBS" in
+    *-lnsl*) ;;
+    *) echo $ac_n "checking for printf in -lnsl_s""... $ac_c" 1>&6
+echo "configure:2601: checking for printf in -lnsl_s" >&5
 ac_lib_var=`echo nsl_s'_'printf | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl_s  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2290 "configure"
+#line 2609 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char printf();
 
 int main() {
 printf()
 ; return 0; }
 EOF
-if { (eval echo configure:2301: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2620: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2321,36 +2640,36 @@
   LIBS="-lnsl_s $LIBS"
 
 else
   echo "$ac_t""no" 1>&6
 fi
  ;;
-esac
-case "$LIBS" in
-*-lnsl*) ;;
-*) echo $ac_n "checking for printf in -lnsl""... $ac_c" 1>&6
-echo "configure:2332: checking for printf in -lnsl" >&5
+    esac
+    case "$LIBS" in
+    *-lnsl*) ;;
+    *) echo $ac_n "checking for printf in -lnsl""... $ac_c" 1>&6
+echo "configure:2651: checking for printf in -lnsl" >&5
 ac_lib_var=`echo nsl'_'printf | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2340 "configure"
+#line 2659 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char printf();
 
 int main() {
 printf()
 ; return 0; }
 EOF
-if { (eval echo configure:2351: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2670: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2371,36 +2690,36 @@
   LIBS="-lnsl $LIBS"
 
 else
   echo "$ac_t""no" 1>&6
 fi
  ;;
-esac
-case "$LIBS" in
-*-lsocket*) ;;
-*) echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
-echo "configure:2382: checking for connect in -lsocket" >&5
+    esac
+    case "$LIBS" in
+    *-lsocket*) ;;
+    *) echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
+echo "configure:2701: checking for connect in -lsocket" >&5
 ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2390 "configure"
+#line 2709 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char connect();
 
 int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:2401: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2720: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2421,36 +2740,36 @@
   LIBS="-lsocket $LIBS"
 
 else
   echo "$ac_t""no" 1>&6
 fi
  ;;
-esac
-case "$LIBS" in
-*-linet*) ;;
-*) echo $ac_n "checking for connect in -linet""... $ac_c" 1>&6
-echo "configure:2432: checking for connect in -linet" >&5
+    esac
+    case "$LIBS" in
+    *-linet*) ;;
+    *) echo $ac_n "checking for connect in -linet""... $ac_c" 1>&6
+echo "configure:2751: checking for connect in -linet" >&5
 ac_lib_var=`echo inet'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-linet  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2440 "configure"
+#line 2759 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char connect();
 
 int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:2451: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2770: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2471,22 +2790,47 @@
   LIBS="-linet $LIBS"
 
 else
   echo "$ac_t""no" 1>&6
 fi
  ;;
-esac
-if test "$ac_cv_lib_socket_connect" = "yes" || 
-   test "$ac_cv_lib_inet_connect" = "yes"; then
-  ac_cv_func_connect=yes
-  cat >> confdefs.h <<\EOF
+    esac
+            if test x"$ac_cv_lib_socket_connect" = x"yes" || 
+       test x"$ac_cv_lib_inet_connect" = x"yes"; then
+        # ac_cv_func_connect=yes
+        # don't!  it would cause AC_CHECK_FUNC to succeed next time configure is run
+        cat >> confdefs.h <<\EOF
 #define HAVE_CONNECT 1
 EOF
 
+    fi
 fi
+
+#
+# The following test was mostly taken from the tcl/tk plus patches
+#
+echo $ac_n "checking whether -c -o works ... $ac_c"
+rm -rf conftest*
+cat > conftest.$ac_ext <<EOF
+int main() { return 0; }
+EOF
+${CC-cc} -c -o conftest..o conftest.$ac_ext
+if test -f conftest..o; then
+    OBJ_SAVE="#"
+    OBJ_RESTORE="#"
+    CC_SHOBJ_FLAG='-o $@'
+    echo yes
+else
+    OBJ_SAVE='	@b=`basename $@ .o`;rm -f $$b.o.sav;if test -f $$b.o; then mv $$b.o $$b.o.sav;fi;'
+    OBJ_RESTORE='	@b=`basename $@ .o`;if test "$$b.o" != "$@"; then mv $$b.o $@; if test -f $$b.o.sav; then mv $$b.o.sav $$b.o; fi; fi'
+    CC_SHOBJ_FLAG=""
+    echo no
 fi
+rm -rf conftest*
+
+
 
 
 
 trap '' 1 2 15
 cat > confcache <<\EOF
 # This file is a shell script that caches the results of configure
@@ -2615,19 +2959,37 @@
 s%@localstatedir@%$localstatedir%g
 s%@libdir@%$libdir%g
 s%@includedir@%$includedir%g
 s%@oldincludedir@%$oldincludedir%g
 s%@infodir@%$infodir%g
 s%@mandir@%$mandir%g
+s%@host@%$host%g
+s%@host_alias@%$host_alias%g
+s%@host_cpu@%$host_cpu%g
+s%@host_vendor@%$host_vendor%g
+s%@host_os@%$host_os%g
+s%@target@%$target%g
+s%@target_alias@%$target_alias%g
+s%@target_cpu@%$target_cpu%g
+s%@target_vendor@%$target_vendor%g
+s%@target_os@%$target_os%g
+s%@build@%$build%g
+s%@build_alias@%$build_alias%g
+s%@build_cpu@%$build_cpu%g
+s%@build_vendor@%$build_vendor%g
+s%@build_os@%$build_os%g
 s%@CC@%$CC%g
 s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
 s%@INSTALL_DATA@%$INSTALL_DATA%g
 s%@SHELL@%$SHELL%g
 s%@HAVE_REMSH@%$HAVE_REMSH%g
 s%@CPP@%$CPP%g
 s%@LIBOBJS@%$LIBOBJS%g
+s%@OBJ_SAVE@%$OBJ_SAVE%g
+s%@OBJ_RESTORE@%$OBJ_RESTORE%g
+s%@CC_SHOBJ_FLAG@%$CC_SHOBJ_FLAG%g
 
 CEOF
 EOF
 
 cat >> $CONFIG_STATUS <<\EOF
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/configure.in	1998-09-09 15:06:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/configure.in	1998-11-04 06:00:45.000000000 +0800
@@ -1,18 +1,22 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_INIT(byteorder.h)
 AC_CONFIG_HEADER(config.h)
 
+AC_CANONICAL_SYSTEM
+AC_VALIDATE_CACHE_SYSTEM_TYPE
+
 dnl Checks for programs.
 AC_PROG_CC
 AC_PROG_INSTALL
 AC_SUBST(SHELL)
 
 AC_CHECK_PROG(HAVE_REMSH, remsh, 1, 0)
 AC_DEFINE_UNQUOTED(HAVE_REMSH, $HAVE_REMSH)
 
+AC_C_BIGENDIAN
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h unistd.h utime.h grp.h)
 AC_CHECK_HEADERS(compat.h sys/param.h ctype.h sys/wait.h sys/ioctl.h)
 AC_CHECK_HEADERS(sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h)
@@ -30,99 +34,154 @@
 AC_TYPE_OFF_T
 AC_TYPE_SIZE_T
 AC_TYPE_PID_T
 AC_STRUCT_ST_RDEV
 AC_CHECK_TYPE(ino_t,unsigned)
 
-echo $ac_n "checking for errno in errno.h... $ac_c"
-AC_TRY_COMPILE([#include <errno.h>],[int i = errno],
-echo yes; AC_DEFINE(HAVE_ERRNO_DECL),
-echo no)
+AC_CACHE_CHECK([for errno in errno.h],rsync_cv_errno, [
+    AC_TRY_COMPILE([#include <errno.h>],[int i = errno],
+	rsync_cv_errno=yes,rsync_cv_have_errno_decl=no)])
+if test x"$rsync_cv_errno" = x"yes"; then
+   AC_DEFINE(HAVE_ERRNO_DECL)
+fi
 
 AC_FUNC_MEMCMP
 AC_FUNC_UTIME_NULL
 AC_CHECK_FUNCS(mmap munmap waitpid getcwd strdup strerror chown chmod mknod)
 AC_CHECK_FUNCS(fchmod fstat strchr readlink link utime utimes strftime)
-AC_CHECK_FUNCS(memmove getopt_long lchown vsnprintf setsid glob strpbrk)
+AC_CHECK_FUNCS(memmove getopt_long lchown vsnprintf snprintf setsid glob strpbrk)
 
 echo $ac_n "checking for working fnmatch... $ac_c"
 AC_TRY_RUN([#include <fnmatch.h>
 main() { exit(fnmatch("*.o", "x.o", 0) == 0? 0: 1); }],
 echo yes;AC_DEFINE(HAVE_FNMATCH), 
 echo no)
 
-echo $ac_n "checking for long long ... $ac_c"
+AC_CACHE_CHECK([for long long],rsync_cv_have_longlong,[
 AC_TRY_RUN([#include <stdio.h>
 main() { long long x = 1000000; x *= x; exit(((x/1000000) == 1000000)? 0: 1); }],
-echo yes;AC_DEFINE(HAVE_LONGLONG), 
-echo no)
+rsync_cv_have_longlong=yes,rsync_cv_have_longlong=no,rsync_cv_have_longlong=cross)])
+if test x"$rsync_cv_have_longlong" = x"yes"; then
+    AC_DEFINE(HAVE_LONGLONG)
+fi
 
-echo $ac_n "checking for off64_t ... $ac_c"
+AC_CACHE_CHECK([for off64_t],rsync_cv_HAVE_OFF64_T,[
 AC_TRY_RUN([#include <stdio.h>
 #include <sys/stat.h>
-main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) return 1; exit((lstat64("/dev/null", &st)==0)?0:1); }],
-echo yes;AC_DEFINE(HAVE_OFF64_T), 
-echo no)
+main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) exit(1); exit((lstat64("/dev/null", &st)==0)?0:1); }],
+rsync_cv_HAVE_OFF64_T=yes,rsync_cv_HAVE_OFF64_T=no,rsync_cv_HAVE_OFF64_T=cross)])
+if test x"$rsync_cv_HAVE_OFF64_T" = x"yes"; then
+    AC_DEFINE(HAVE_OFF64_T)
+fi
 
 echo $ac_n "checking for short ino_t ... $ac_c"
 AC_TRY_RUN([#include <stdio.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 main() { if (sizeof(ino_t) < sizeof(unsigned int)) return 0; return 1; }],
 echo yes;AC_DEFINE(HAVE_SHORT_INO_T), 
 echo no)
 
-echo $ac_n "checking for unsigned char ... $ac_c"
+AC_CACHE_CHECK([for unsigned char],rsync_cv_HAVE_UNSIGNED_CHAR,[
 AC_TRY_RUN([#include <stdio.h>
 main() { char c; c=250; exit((c > 0)?0:1); }],
-echo yes;AC_DEFINE(HAVE_UNSIGNED_CHAR), 
-echo no)
+rsync_cv_HAVE_UNSIGNED_CHAR=yes,rsync_cv_HAVE_UNSIGNED_CHAR=no,rsync_cv_HAVE_UNSIGNED_CHAR=cross)])
+if test x"$rsync_cv_HAVE_UNSIGNED_CHAR" = x"yes"; then
+    AC_DEFINE(HAVE_UNSIGNED_CHAR)
+fi
 
-echo $ac_n "checking for broken readdir ... $ac_c"
+AC_CACHE_CHECK([for broken readdir],rsync_cv_HAVE_BROKEN_READDIR,[
 AC_TRY_RUN([#include <sys/types.h>
 #include <dirent.h>
 main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
 if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
-di->d_name[0] == 0) return 0; return 1;} ],
-echo yes - you are using the broken /usr/ucb/cc;AC_DEFINE(HAVE_BROKEN_READDIR), 
-echo no)
+di->d_name[0] == 0) exit(0); exit(1);} ],
+rsync_cv_HAVE_BROKEN_READDIR=yes,rsync_cv_HAVE_BROKEN_READDIR=no,rsync_cv_HAVE_BROKEN_READDIR=cross)])
+if test x"$rsync_cv_HAVE_BROKEN_READDIR" = x"yes"; then
+    AC_DEFINE(HAVE_BROKEN_READDIR)
+fi
 
-echo $ac_n "checking for utimbuf ... $ac_c"
+AC_CACHE_CHECK([for utimbuf],rsync_cv_HAVE_UTIMBUF,[
 AC_TRY_COMPILE([#include <sys/types.h>
 #include <utime.h>],
-[struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; return utime("foo.c",&tbuf);],
-echo yes;AC_DEFINE(HAVE_UTIMBUF), 
-echo no)
+[struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));],
+rsync_cv_HAVE_UTIMBUF=yes,rsync_cv_HAVE_UTIMBUF=no,rsync_cv_HAVE_UTIMBUF=cross)])
+if test x"$rsync_cv_HAVE_UTIMBUF" = x"yes"; then
+    AC_DEFINE(HAVE_UTIMBUF)
+fi
+
+AC_CACHE_CHECK([for broken inet_ntoa],rsync_cv_REPLACE_INET_NTOA,[
+AC_TRY_RUN([
+#include <stdio.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+main() { struct in_addr ip; ip.s_addr = 0x12345678;
+if (strcmp(inet_ntoa(ip),"18.52.86.120") &&
+    strcmp(inet_ntoa(ip),"120.86.52.18")) { exit(0); } 
+exit(1);}],
+           rsync_cv_REPLACE_INET_NTOA=yes,rsync_cv_REPLACE_INET_NTOA=no,rsync_cv_REPLACE_INET_NTOA=cross)])
+if test x"$rsync_cv_REPLACE_INET_NTOA" = x"yes"; then
+    AC_DEFINE(REPLACE_INET_NTOA)
+fi
 
 # The following test taken from the cvs sources
 # If we can't find connect, try looking in -lsocket, -lnsl, and -linet.
 # The Irix 5 libc.so has connect and gethostbyname, but Irix 5 also has
 # libsocket.so which has a bad implementation of gethostbyname (it
 # only looks in /etc/hosts), so we only look for -lsocket if we need
 # it.
-AC_CHECK_FUNC(connect, :, 
-[case "$LIBS" in
-*-lnsl*) ;;
-*) AC_CHECK_LIB(nsl_s, printf) ;;
-esac
-case "$LIBS" in
-*-lnsl*) ;;
-*) AC_CHECK_LIB(nsl, printf) ;;
-esac
-case "$LIBS" in
-*-lsocket*) ;;
-*) AC_CHECK_LIB(socket, connect) ;;
-esac
-case "$LIBS" in
-*-linet*) ;;
-*) AC_CHECK_LIB(inet, connect) ;;
-esac
-dnl We can't just call AC_CHECK_FUNCS(connect) here, because the value
-dnl has been cached.
-if test "$ac_cv_lib_socket_connect" = "yes" || 
-   test "$ac_cv_lib_inet_connect" = "yes"; then
-  ac_cv_func_connect=yes
-  AC_DEFINE(HAVE_CONNECT)
-fi])
+AC_CHECK_FUNCS(connect)
+if test x"$ac_cv_func_connect" = x"no"; then
+    case "$LIBS" in
+    *-lnsl*) ;;
+    *) AC_CHECK_LIB(nsl_s, printf) ;;
+    esac
+    case "$LIBS" in
+    *-lnsl*) ;;
+    *) AC_CHECK_LIB(nsl, printf) ;;
+    esac
+    case "$LIBS" in
+    *-lsocket*) ;;
+    *) AC_CHECK_LIB(socket, connect) ;;
+    esac
+    case "$LIBS" in
+    *-linet*) ;;
+    *) AC_CHECK_LIB(inet, connect) ;;
+    esac
+    dnl We can't just call AC_CHECK_FUNCS(connect) here, because the value
+    dnl has been cached.
+    if test x"$ac_cv_lib_socket_connect" = x"yes" || 
+       test x"$ac_cv_lib_inet_connect" = x"yes"; then
+        # ac_cv_func_connect=yes
+        # don't!  it would cause AC_CHECK_FUNC to succeed next time configure is run
+        AC_DEFINE(HAVE_CONNECT)
+    fi
+fi
+
+#
+# The following test was mostly taken from the tcl/tk plus patches
+#
+echo $ac_n "checking whether -c -o works ... $ac_c"
+rm -rf conftest*
+cat > conftest.$ac_ext <<EOF
+int main() { return 0; }
+EOF
+${CC-cc} -c -o conftest..o conftest.$ac_ext
+if test -f conftest..o; then
+    OBJ_SAVE="#"
+    OBJ_RESTORE="#"
+    CC_SHOBJ_FLAG='-o $@'
+    echo yes
+else
+    OBJ_SAVE='	@b=`basename $@ .o`;rm -f $$b.o.sav;if test -f $$b.o; then mv $$b.o $$b.o.sav;fi;'
+    OBJ_RESTORE='	@b=`basename $@ .o`;if test "$$b.o" != "$@"; then mv $$b.o $@; if test -f $$b.o.sav; then mv $$b.o.sav $$b.o; fi; fi'
+    CC_SHOBJ_FLAG=""
+    echo no
+fi
+rm -rf conftest*
+AC_SUBST(OBJ_SAVE)
+AC_SUBST(OBJ_RESTORE)
+AC_SUBST(CC_SHOBJ_FLAG)
 
 
 AC_OUTPUT(Makefile lib/dummy zlib/dummy)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/cvs.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/cvs.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/cvs.log	1998-09-09 15:07:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/cvs.log	1998-11-04 06:01:20.000000000 +0800
@@ -6693,6 +6693,875 @@
 
 Modified Files:
 	rsync.spec 
 Log Message:
 preparing for release of 2.1.1
 
+
+****************************************
+Date:	Tuesday October 27, 1998 @ 8:42
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv5607
+
+Modified Files:
+	generator.c options.c proto.h receiver.c rsync.1 rsync.yo 
+	util.c 
+Log Message:
+Add --compare-dest option which enables specifying an additional destination
+for comparisons when syncing.  Useful for syncing into a scratch area and
+doing a flash-cutover when it is completed.
+
+
+
+****************************************
+Date:	Tuesday October 27, 1998 @ 8:45
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv10116
+
+Modified Files:
+	exclude.c flist.c proto.h 
+Log Message:
+Optimize server for special case of a long list of includes ("+") followed
+by a match-all exclude "- *".
+
+
+
+****************************************
+Date:	Tuesday October 27, 1998 @ 8:51
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv581
+
+Modified Files:
+	cleanup.c clientserver.c loadparm.c main.c proto.h 
+	rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+Add "use chroot" and "pid file" rsyncd.conf options.  The former allows one
+to disable the use of chroot so rsync --daemon can be run as a non-root
+user (if a non-privileged --port is used).  The latter allows one to
+specify a file in which to write the process id of the daemon, which is
+useful when rsync --daemon is not run from inetd.
+
+
+
+****************************************
+Date:	Tuesday October 27, 1998 @ 9:03
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv5957
+
+Modified Files:
+	exclude.c 
+Log Message:
+Fix bug in --include and --include-from which didn't work as advertised;
+could only include files before if "+ " was explicitly prefixed on files
+from any exclude or include option.  Also simplified the code by removing
+the "orig" exclude_struct element, and reduced the number of bytes
+transferred from client to server by never including "- " prefixes in the
+transmitted exclude list because exclusion is the default.
+
+
+
+****************************************
+Date:	Tuesday October 27, 1998 @ 10:23
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv7580
+
+Modified Files:
+	Makefile.in config.h.in configure configure.in util.c 
+Log Message:
+added a vsnprintf() implementation from cvslock. See the notes on the
+license at the top of lib/snprintf.c
+
+
+
+****************************************
+Date:	Tuesday October 27, 1998 @ 10:23
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv9921
+
+Added Files:
+	snprintf.c 
+Log Message:
+added a vsnprintf() implementation from cvslock. See the notes on the
+license at the top of lib/snprintf.c
+
+
+
+****************************************
+Date:	Wednesday October 28, 1998 @ 1:09
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv14761
+
+Modified Files:
+	flist.c rsync.h 
+Log Message:
+handle OSes (such as Unicos) which use a different value for S_IFLNK
+
+
+
+****************************************
+Date:	Wednesday October 28, 1998 @ 1:19
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16807
+
+Modified Files:
+	md4.c 
+Log Message:
+fixed a typecast
+
+
+
+
+****************************************
+Date:	Wednesday October 28, 1998 @ 3:07
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv10701
+
+Modified Files:
+	Makefile.in 
+Log Message:
+- Define bindir and mandir as per gnu makefile standards
+- Add install-strip target as per gnu makefile standards
+Contributed by Fred Sanchez <wsanchez@apple.com>
+
+
+
+****************************************
+Date:	Wednesday October 28, 1998 @ 4:30
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv27879
+
+Modified Files:
+	rsync.1 rsync.yo 
+Log Message:
+Document the fact that --numeric-ids is implied if the source system is
+a daemon using chroot.
+
+
+
+****************************************
+Date:	Wednesday October 28, 1998 @ 14:28
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv18784
+
+Modified Files:
+	loadparm.c log.c main.c proto.h receiver.c rsync.1 rsync.h 
+	rsyncd.conf.5 rsyncd.conf.yo sender.c socket.c 
+Log Message:
+and I thought I wasn't going to do any rsync coding for a while ...
+
+Jason Andrade convinced me to add ftpd style logging of transfers,
+enabled with a "transfer logging" option in rsyncd.conf
+
+you can customise the format in log.c
+
+
+
+
+****************************************
+Date:	Wednesday October 28, 1998 @ 14:37
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20402
+
+Modified Files:
+	rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+fixed a typo
+
+
+
+****************************************
+Date:	Wednesday October 28, 1998 @ 15:06
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv19709
+
+Modified Files:
+	snprintf.c 
+Log Message:
+fixed handling of %.0f in replacement snprintf.c
+
+
+
+
+****************************************
+Date:	Wednesday October 28, 1998 @ 21:43
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv3947
+
+Modified Files:
+	cleanup.c clientserver.c log.c 
+Log Message:
+syslog support in rsync daemon has been broken since I added the "log
+file" option. I wonder why noone reported it? Or did everyone just use
+"log file" ?
+
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 16:01
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv12266
+
+Modified Files:
+	Makefile.in checksum.c configure configure.in io.c receiver.c 
+	rsync.h 
+Added Files:
+	aclocal.m4 config.guess config.sub 
+Log Message:
+changes to get rsync working on a CRAY J90. This machine doesn't have
+a 4 byte integer type (short is 8 bytes). I needed to use a new md4
+implementation (I used the portable one I wrote for Samba).
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 16:01
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv4639
+
+Added Files:
+	mdfour.c mdfour.h 
+Log Message:
+changes to get rsync working on a CRAY J90. This machine doesn't have
+a 4 byte integer type (short is 8 bytes). I needed to use a new md4
+implementation (I used the portable one I wrote for Samba).
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 16:06
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4012
+
+Modified Files:
+	checksum.c 
+Log Message:
+kfixed char* casts
+
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 16:48
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16302
+
+Modified Files:
+	io.c 
+Log Message:
+final change needed to get rsync working on a CRAY J90 
+
+
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 17:10
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv18988
+
+Modified Files:
+	sender.c 
+Log Message:
+a change I made yesterday corrupted the displayed filename in some
+cases. cosmetic fix.
+
+
+
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 17:39
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/data/local/src/rsync
+
+Modified Files:
+	flist.c rsync.h 
+Log Message:
+some minor optimisations
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 17:39
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/data/local/src/rsync/lib
+
+Modified Files:
+	mdfour.c 
+Log Message:
+some minor optimisations
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 22:11
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv22414
+
+Modified Files:
+	cleanup.c log.c main.c 
+Log Message:
+put the pid on each line of the log file to facilitate
+auto-parsing. Requested by Jarkko Hietaniemi (jhi@iki.fi)
+
+
+
+****************************************
+Date:	Thursday October 29, 1998 @ 22:16
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv26892
+
+Modified Files:
+	log.c 
+Log Message:
+put the pid on each line of the log file to facilitate
+auto-parsing. Requested by Jarkko Hietaniemi (jhi@iki.fi)
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 9:28
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv28680
+
+Modified Files:
+	Makefile.in configure configure.in proto.h 
+Log Message:
+Fix for systems such as Unixware that have a cc that does not support -o
+with -c.
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 10:44
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4931
+
+Modified Files:
+	config.h.in configure configure.in 
+Log Message:
+fixed cacheing of some values (using code from Samba)
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 13:23
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4469
+
+Modified Files:
+	flist.c 
+Log Message:
+hanle null strings in -vvv output
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 13:24
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8091
+
+Modified Files:
+	loadparm.c log.c proto.h rsync.h rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+added "log format" option to allow admins to choose the format for
+rsyncd log file entries
+
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 13:32
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4364
+
+Modified Files:
+	log.c 
+Log Message:
+hopefuly fix logging of "transfer interrupted" messages
+
+
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 13:36
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv6796
+
+Modified Files:
+	log.c 
+Log Message:
+get null termination right in logging
+
+
+
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 13:43
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv528
+
+Modified Files:
+	log.c 
+Log Message:
+get null termination right in logging
+
+
+
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 13:50
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv9041
+
+Modified Files:
+	acconfig.h config.h.in configure configure.in rsync.h 
+Log Message:
+check for a broken inet_ntoa() on IRIX
+
+
+
+
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 13:50
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv6373
+
+Modified Files:
+	compat.c 
+Log Message:
+check for a broken inet_ntoa() on IRIX
+
+
+
+
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 13:52
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv12297
+
+Modified Files:
+	config.h.in configure configure.in 
+Log Message:
+need BIG_ENDIAN test for inet_ntoa replacement
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 16:53
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv13741
+
+Modified Files:
+	clientserver.c loadparm.c log.c rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+added %m, %P and %u options to logging
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 17:12
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21214
+
+Modified Files:
+	loadparm.c rsyncd.conf.5 rsyncd.conf.yo 
+Added Files:
+	rsyncstats 
+Log Message:
+added a perl script to summarise the rsyncd log format
+
+
+
+
+****************************************
+Date:	Friday October 30, 1998 @ 22:18
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv26663
+
+Modified Files:
+	log.c 
+Log Message:
+move the time init before the logfile opening.
+
+
+
+
+
+****************************************
+Date:	Saturday October 31, 1998 @ 10:03
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv27730
+
+Modified Files:
+	log.c 
+Log Message:
+fixed perms on rsyncd log file
+
+
+
+
+
+
+****************************************
+Date:	Saturday October 31, 1998 @ 10:50
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv3506
+
+Modified Files:
+	log.c 
+Log Message:
+use the orig_umask when choosing perms for the log file.
+
+
+
+
+
+
+
+****************************************
+Date:	Saturday October 31, 1998 @ 11:12
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv5914
+
+Modified Files:
+	rsyncstats 
+Log Message:
+get the date comparison the right way around
+
+
+
+
+
+
+
+
+****************************************
+Date:	Saturday October 31, 1998 @ 15:35
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv19525
+
+Modified Files:
+	snprintf.c 
+Log Message:
+added copyright notice from Patrick Powell
+
+
+
+****************************************
+Date:	Monday November 2, 1998 @ 11:52
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20886
+
+Modified Files:
+	flist.c generator.c log.c main.c options.c proto.h rsync.1 
+	rsync.h rsync.yo util.c 
+Log Message:
+if no local destination is provided for the transfer then provide
+a "ls -l" style listing of the files that would be transferred
+
+
+
+****************************************
+Date:	Monday November 2, 1998 @ 11:55
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16629
+
+Modified Files:
+	rsync.yo 
+Log Message:
+- document the rsync:// URL format
+
+
+
+****************************************
+Date:	Monday November 2, 1998 @ 15:17
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv26710
+
+Modified Files:
+	io.c log.c proto.h receiver.c rsync.1 rsyncd.conf.5 
+	rsyncd.conf.yo sender.c 
+Log Message:
+Jason told me that's its very important for his site to log exactly
+how many bytes were needed to be transferred for each file. I added %b
+and %c log format options to cover this. See the man page for details.
+
+
+
+
+
+****************************************
+Date:	Monday November 2, 1998 @ 17:40
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv2516
+
+Modified Files:
+	log.c 
+Log Message:
+the logging wasn't showing the full prefix for filenames
+
+
+
+****************************************
+Date:	Monday November 2, 1998 @ 18:26
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv721
+
+Modified Files:
+	rsyncstats 
+Log Message:
+remove double / from filenames in display
+
+
+
+
+****************************************
+Date:	Tuesday November 3, 1998 @ 14:48
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv9579
+
+Modified Files:
+	log.c options.c rsync.yo rsyncd.conf.yo 
+Log Message:
+added the --log-format option to allow users to request arbitrary
+per-file logging of interactive rsync sessions.
+
+
+
+****************************************
+Date:	Tuesday November 3, 1998 @ 16:09
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8352
+
+Modified Files:
+	rsync.1 rsyncd.conf.5 
+Log Message:
+I'd forgotten to run "make man"
+
+
+
+
+****************************************
+Date:	Tuesday November 3, 1998 @ 16:14
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv17968
+
+Modified Files:
+	rsync.1 rsync.yo 
+Log Message:
+documented --delete disabling on IO errors
+
+
+
+
+
+****************************************
+Date:	Tuesday November 3, 1998 @ 18:08
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16099
+
+Modified Files:
+	clientserver.c compat.c exclude.c fileio.c flist.c io.c 
+	loadparm.c log.c main.c options.c receiver.c rsync.c rsync.h 
+	sender.c socket.c token.c util.c 
+Added Files:
+	errcode.h 
+Log Message:
+patch from Alberto Accomazzi <aaccomazzi@cfa.harvard.edu> to add
+different exit codes for different conditions.
+
+
+
+****************************************
+Date:	Wednesday November 4, 1998 @ 8:17
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv72
+
+Modified Files:
+	main.c options.c rsync.1 rsync.yo 
+Log Message:
+Add support for optional ":PORT" in rsync URL.
+
+
+
+****************************************
+Date:	Wednesday November 4, 1998 @ 8:49
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20918
+
+Modified Files:
+	util.c 
+Log Message:
+Call clean_fname() in sanitize_path() to catch some more strange but
+legal file name syntaxes.
+
+
+
+****************************************
+Date:	Wednesday November 4, 1998 @ 8:58
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21262
+
+Modified Files:
+	options.c rsync.1 rsync.yo 
+Log Message:
+Document the fact that you can use [USER@] in an rsync URL.
+Note: the same thing works for ftp and http URLs in netscape.
+
+
+
+****************************************
+Date:	Wednesday November 4, 1998 @ 9:00
+Author:	rsync-bu
+
+Update of /data/cvs/rsync
+In directory samba:/data/people/rsync-bugs/rsync
+
+Modified Files:
+	version.h 
+Log Message:
+preparing for release of 2.2.0
+
+
+****************************************
+Date:	Wednesday November 4, 1998 @ 9:00
+Author:	rsync-bu
+
+Update of /data/cvs/rsync/packaging/redhat/5.0
+In directory samba:/data/people/rsync-bugs/rsync/packaging/redhat/5.0
+
+Modified Files:
+	rsync.spec 
+Log Message:
+preparing for release of 2.2.0
+
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0: errcode.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/exclude.c	1998-05-29 10:29:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/exclude.c	1998-11-04 06:00:45.000000000 +0800
@@ -23,38 +23,86 @@
 #include "rsync.h"
 
 extern int verbose;
 
 static struct exclude_struct **exclude_list;
 
+/*
+ * Optimization for special case when all included files are explicitly
+ *   listed without wildcards in the "exclude" list followed by a "- *"
+ *   to exclude the rest.
+ * Contributed by Dave Dykstra <dwd@bell-labs.com>
+ */
+static int only_included_files = 1;
+static struct exclude_struct *exclude_the_rest;
+
+int send_included_file_names(int f,struct file_list *flist)
+{
+	struct exclude_struct *ex, **ex_list;
+	int n;
+	char *p;
+
+	if (!only_included_files || (exclude_the_rest == NULL))
+		return 0;
+
+	if (verbose > 1) {
+		rprintf(FINFO,"(using include-only optimization) ");
+	}
+
+	/* set exclude_list to NULL temporarily so check_exclude */
+	/*   will always return true */
+	ex_list = exclude_list;
+	exclude_list = NULL;
+	for (n=0; (ex = ex_list[n]) != NULL; n++) {
+		if (ex == exclude_the_rest)
+			break;
+		p = ex->pattern;
+		while (*p == '/') {
+			/* skip the allowed beginning slashes */
+			p++;
+		}
+		send_file_name(f,flist,p,0,0);
+	}
+	exclude_list = ex_list;
+	
+	return 1;
+}
+
 /* build an exclude structure given a exclude pattern */
 static struct exclude_struct *make_exclude(char *pattern, int include)
 {
 	struct exclude_struct *ret;
 
 	ret = (struct exclude_struct *)malloc(sizeof(*ret));
 	if (!ret) out_of_memory("make_exclude");
 
 	memset(ret, 0, sizeof(*ret));
 
-	ret->orig = strdup(pattern);
-
 	if (strncmp(pattern,"- ",2) == 0) {
 		pattern += 2;
 	} else if (strncmp(pattern,"+ ",2) == 0) {
 		ret->include = 1;
 		pattern += 2;
 	} else {
 		ret->include = include;
 	}
 
 	ret->pattern = strdup(pattern);
 
-	if (!ret->orig || !ret->pattern) out_of_memory("make_exclude");
+	if (!ret->pattern) out_of_memory("make_exclude");
 
-	if (strpbrk(pattern, "*[?")) ret->regular_exp = 1;
+	if (strpbrk(pattern, "*[?")) {
+	    if (!ret->include && (*pattern == '*') && (*(pattern+1) == '\0')) {
+		    exclude_the_rest = ret;
+	    } else {
+		    only_included_files = 0;
+	    }
+	    ret->regular_exp = 1;
+	} else if (!ret->include) {
+		only_included_files = 0;
+	}
 
 	if (strlen(pattern) > 1 && pattern[strlen(pattern)-1] == '/') {
 		ret->pattern[strlen(pattern)-1] = 0;
 		ret->directory = 1;
 	}
 
@@ -64,13 +112,12 @@
 
 	return ret;
 }
 
 static void free_exclude(struct exclude_struct *ex)
 {
-	free(ex->orig);
 	free(ex->pattern);
 	memset(ex,0,sizeof(*ex));
 	free(ex);
 }
 
 static int check_one_exclude(char *name,struct exclude_struct *ex,
@@ -140,12 +187,14 @@
 			rprintf(FINFO,"clearing exclude list\n");
 		while ((len)--) {
 			free_exclude((*list)[len]);
 		}
 		free((*list));
 		*list = NULL;
+		only_included_files = 1;
+		exclude_the_rest = NULL;
 		return;
 	}
 
 	*list = (struct exclude_struct **)Realloc(*list,sizeof(struct exclude_struct *)*(len+2));
 	
 	if (!*list || !((*list)[len] = make_exclude(pattern, include)))
@@ -169,13 +218,13 @@
 	struct exclude_struct **list=list1;
 	FILE *f = fopen(fname,"r");
 	char line[MAXPATHLEN];
 	if (!f) {
 		if (fatal) {
 			rprintf(FERROR,"%s : %s\n",fname,strerror(errno));
-			exit_cleanup(1);
+			exit_cleanup(RERR_FILEIO);
 		}
 		return list;
 	}
 
 	while (fgets(line,MAXPATHLEN,f)) {
 		int l = strlen(line);
@@ -204,29 +253,27 @@
 	if (!exclude_list) {
 		write_int(f,0);
 		return;
 	}
 
 	for (i=0;exclude_list[i];i++) {
-		char *pattern = exclude_list[i]->orig; 
+		char *pattern = exclude_list[i]->pattern; 
 		int l;
 
-		if (remote_version < 19) {
-			if (strncmp(pattern,"+ ", 2)==0) {
+		l = strlen(pattern);
+		if (l == 0) continue;
+		if (exclude_list[i]->include) {
+			if (remote_version < 19) {
 				rprintf(FERROR,"remote rsync does not support include syntax - aborting\n");
-				exit_cleanup(1);
-			}
-			
-			if (strncmp(pattern,"- ", 2) == 0) {
-				pattern += 2;
+				exit_cleanup(RERR_NOSUPPORT);
 			}
+			write_int(f,l+2);
+			write_buf(f,"+ ",2);
+		} else {
+			write_int(f,l);
 		}
-		
-		l = strlen(pattern);
-		if (l == 0) continue;
-		write_int(f,l);
 		write_buf(f,pattern,l);
 	}    
 
 	write_int(f,0);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/fileio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/fileio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/fileio.c	1998-05-27 20:37:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/fileio.c	1998-11-04 06:00:45.000000000 +0800
@@ -133,13 +133,13 @@
 		if (offset >= map->p_offset && 
 		    offset+len <= map->p_offset+map->p_len) {
 			return (map->map + (offset - map->p_offset));
 		}
 		if (munmap(map->map, map->p_len) != 0) {
 			rprintf(FERROR,"munmap failed : %s\n", strerror(errno));
-			exit_cleanup(1);
+			exit_cleanup(RERR_MALLOC);
 		}
 
 		/* align the mmap region on a nice boundary back a bit from
 		   where it is asked for to allow for some seeking */
 		if (offset > 2*CHUNK_SIZE) {
 			map->p_offset = offset - 2*CHUNK_SIZE;
@@ -183,13 +183,13 @@
 
 	map->p_offset = offset;
 	map->p_len = len;
 
 	if (do_lseek(map->fd,offset,SEEK_SET) != offset) {
 		rprintf(FERROR,"lseek failed in map_ptr\n");
-		exit_cleanup(1);
+		exit_cleanup(RERR_FILEIO);
 	}
 
 	if ((nread=read(map->fd,map->p,len)) != len) {		
 		if (nread < 0) nread = 0;
 		/* the best we can do is zero the buffer - the file
                    has changed mid transfer! */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/flist.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/flist.c	1998-11-04 06:00:45.000000000 +0800
@@ -48,12 +48,42 @@
 extern int io_error;
 
 static struct exclude_struct **local_exclude_list;
 
 static void clean_flist(struct file_list *flist, int strip_root);
 
+
+static void list_file_entry(struct file_struct *f)
+{
+	char perms[11] = "----------";
+	char *perm_map = "rwxrwxrwx";
+	int i;
+
+	for (i=0;i<9;i++) {
+		if (f->mode & (1<<i)) perms[9-i] = perm_map[8-i];
+	}
+	if (S_ISLNK(f->mode)) perms[0] = 'l';
+	if (S_ISDIR(f->mode)) perms[0] = 'd';
+	if (S_ISBLK(f->mode)) perms[0] = 'b';
+	if (S_ISCHR(f->mode)) perms[0] = 'c';
+	if (S_ISSOCK(f->mode)) perms[0] = 's';
+	if (S_ISFIFO(f->mode)) perms[0] = 'p';
+	
+	if (preserve_links && S_ISLNK(f->mode)) {
+		rprintf(FINFO,"%s %11.0f %s %s -> %s\n", 
+			perms, 
+			(double)f->length, timestring(f->modtime), 
+			f_name(f), f->link);
+	} else {
+		rprintf(FINFO,"%s %11.0f %s %s\n", 
+			perms, 
+			(double)f->length, timestring(f->modtime), f_name(f));
+	}
+}
+
+
 int link_stat(const char *Path, STRUCT_STAT *Buffer) 
 {
 #if SUPPORT_LINKS
     if (copy_links) {
 	return do_stat(Path, Buffer);
     } else {
@@ -86,12 +116,29 @@
   STRUCT_STAT st;
   if (link_stat(fname,&st) != 0) return;
   filesystem_dev = st.st_dev;
 }
 
 
+static int to_wire_mode(mode_t mode)
+{
+	if (S_ISLNK(mode) && (S_IFLNK != 0120000)) {
+		return (mode & ~(_S_IFMT)) | 0120000;
+	}
+	return (int)mode;
+}
+
+static mode_t from_wire_mode(int mode)
+{
+	if ((mode & (_S_IFMT)) == 0120000 && (S_IFLNK != 0120000)) {
+		return (mode & ~(_S_IFMT)) | S_IFLNK;
+	}
+	return (mode_t)mode;
+}
+
+
 static void send_directory(int f,struct file_list *flist,char *dir);
 
 static char *flist_dir;
 
 
 static void send_file_entry(struct file_struct *file,int f,unsigned base_flags)
@@ -144,13 +191,13 @@
 	write_buf(f,fname+l1,l2);
 
 	write_longint(f,file->length);
 	if (!(flags & SAME_TIME))
 		write_int(f,(int)file->modtime);
 	if (!(flags & SAME_MODE))
-		write_int(f,(int)file->mode);
+		write_int(f,to_wire_mode(file->mode));
 	if (preserve_uid && !(flags & SAME_UID)) {
 		add_uid(file->uid);
 		write_int(f,(int)file->uid);
 	}
 	if (preserve_gid && !(flags & SAME_GID)) {
 		add_gid(file->gid);
@@ -245,13 +292,13 @@
 	if (!file->basename) out_of_memory("receive_file_entry 1");
 
 
 	file->flags = flags;
 	file->length = read_longint(f);
 	file->modtime = (flags & SAME_TIME) ? last_time : (time_t)read_int(f);
-	file->mode = (flags & SAME_MODE) ? last_mode : (mode_t)read_int(f);
+	file->mode = (flags & SAME_MODE) ? last_mode : from_wire_mode(read_int(f));
 	if (preserve_uid)
 		file->uid = (flags & SAME_UID) ? last_uid : (uid_t)read_int(f);
 	if (preserve_gid)
 		file->gid = (flags & SAME_GID) ? last_gid : (gid_t)read_int(f);
 	if (preserve_devices && IS_DEVICE(file->mode))
 		file->rdev = (flags & SAME_RDEV) ? last_rdev : (dev_t)read_int(f);
@@ -429,13 +476,13 @@
 
 	return file;
 }
 
 
 
-static void send_file_name(int f,struct file_list *flist,char *fname,
+void send_file_name(int f,struct file_list *flist,char *fname,
 			   int recursive, unsigned base_flags)
 {
   struct file_struct *file;
 
   file = make_file(fname);
 
@@ -529,13 +576,13 @@
 
 
 struct file_list *send_file_list(int f,int argc,char *argv[])
 {
 	int i,l;
 	STRUCT_STAT st;
-	char *p,*dir;
+	char *p,*dir,*olddir;
 	char lastpath[MAXPATHLEN]="";
 	struct file_list *flist;
 	int64 start_write;
 
 	if (verbose && recurse && !am_server && f != -1) {
 		rprintf(FINFO,"building file list ... ");
@@ -577,12 +624,13 @@
 		if (S_ISDIR(st.st_mode) && !recurse) {
 			rprintf(FINFO,"skipping directory %s\n",fname);
 			continue;
 		}
 
 		dir = NULL;
+		olddir = NULL;
 
 		if (!relative_paths) {
 			p = strrchr(fname,'/');
 			if (p) {
 				*p = 0;
 				if (p == fname) 
@@ -612,37 +660,38 @@
 		}
 		
 		if (!*fname)
 			fname = ".";
 		
 		if (dir && *dir) {
-			char *olddir = push_dir(dir, 1);
+			olddir = push_dir(dir, 1);
 
 			if (!olddir) {
 				io_error=1;
 				rprintf(FERROR,"push_dir %s : %s\n",
 					dir,strerror(errno));
 				continue;
 			}
 
 			flist_dir = dir;
-			if (one_file_system)
-				set_filesystem(fname);
+		}
+		
+		if (one_file_system)
+			set_filesystem(fname);
+
+		if (!recurse || !send_included_file_names(f,flist))
 			send_file_name(f,flist,fname,recurse,FLAG_DELETE);
+
+		if (olddir != NULL) {
 			flist_dir = NULL;
 			if (pop_dir(olddir) != 0) {
 				rprintf(FERROR,"pop_dir %s : %s\n",
 					dir,strerror(errno));
-				exit_cleanup(1);
+				exit_cleanup(RERR_FILESELECT);
 			}
-			continue;
 		}
-		
-		if (one_file_system)
-			set_filesystem(fname);
-		send_file_name(f,flist,fname,recurse,FLAG_DELETE);
 	}
 
 	if (f != -1) {
 		send_file_entry(NULL,f,0);
 	}
 
@@ -677,12 +726,13 @@
 
 struct file_list *recv_file_list(int f)
 {
   struct file_list *flist;
   unsigned char flags;
   int64 start_read;
+  extern int list_only;
 
   if (verbose && recurse && !am_server) {
     rprintf(FINFO,"receiving file list ... ");
     rflush(FINFO);
   }
 
@@ -743,12 +793,20 @@
 
   /* if protocol version is >= 17 then recv the io_error flag */
   if (f != -1 && remote_version >= 17) {
 	  io_error |= read_int(f);
   }
 
+  if (list_only) {
+	  int i;
+	  for (i=0;i<flist->count;i++) {
+		  list_file_entry(flist->files[i]);
+	  }
+  }
+
+
   if (verbose > 2)
     rprintf(FINFO,"recv_file_list done\n");
 
   stats.flist_size = stats.total_read - start_read;
   stats.num_files = flist->count;
 
@@ -873,16 +931,16 @@
 
 	if (verbose <= 3) return;
 
 	for (i=0;i<flist->count;i++) {
 		rprintf(FINFO,"[%d] i=%d %s %s mode=0%o len=%d\n",
 			getpid(), i, 
-			flist->files[i]->dirname,
-			flist->files[i]->basename,
+			NS(flist->files[i]->dirname),
+			NS(flist->files[i]->basename),
 			flist->files[i]->mode,
-			flist->files[i]->length);
+			(int)flist->files[i]->length);
 	}
 }
 
 
 /*
  * return the full filename of a flist entry
@@ -895,13 +953,15 @@
 
 	if (!f || !f->basename) return NULL;
 
 	n = (n+1)%10;
 
 	if (f->dirname) {
-		slprintf(p, MAXPATHLEN-1, "%s/%s", f->dirname, f->basename);
+		strlcpy(p, f->dirname, MAXPATHLEN-1);
+		strlcat(p, "/", MAXPATHLEN-1);
+		strlcat(p, f->basename, MAXPATHLEN-1);
 	} else {
 		strlcpy(p, f->basename, MAXPATHLEN-1);
 	}
 
 	return p;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/generator.c	1998-07-25 10:25:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/generator.c	1998-11-04 06:00:45.000000000 +0800
@@ -159,12 +159,18 @@
 	int fd;
 	STRUCT_STAT st;
 	struct map_struct *buf;
 	struct sum_struct *s;
 	int statret;
 	struct file_struct *file = flist->files[i];
+	char *fnamecmp;
+	char fnamecmpbuf[MAXPATHLEN];
+	extern char *compare_dest;
+	extern int list_only;
+
+	if (list_only) return;
 
 	if (verbose > 2)
 		rprintf(FINFO,"recv_generator(%s,%d)\n",fname,i);
 
 	statret = link_stat(fname,&st);
 
@@ -259,12 +265,27 @@
 
 	if (!S_ISREG(file->mode)) {
 		rprintf(FINFO,"skipping non-regular file %s\n",fname);
 		return;
 	}
 
+	fnamecmp = fname;
+
+	if ((statret == -1) && (compare_dest != NULL)) {
+		/* try the file at compare_dest instead */
+		int saveerrno = errno;
+		slprintf(fnamecmpbuf,MAXPATHLEN-1,"%s/%s",compare_dest,fname);
+		statret = link_stat(fnamecmpbuf,&st);
+		if (!S_ISREG(st.st_mode))
+			statret = -1;
+		if (statret == -1)
+			errno = saveerrno;
+		else
+			fnamecmp = fnamecmpbuf;
+	}
+
 	if (statret == -1) {
 		if (errno == ENOENT) {
 			write_int(f_out,i);
 			if (!dry_run) send_sums(NULL,f_out);
 		} else {
 			if (verbose > 1)
@@ -281,13 +302,13 @@
 		/* now pretend the file didn't exist */
 		write_int(f_out,i);
 		if (!dry_run) send_sums(NULL,f_out);    
 		return;
 	}
 
-	if (update_only && st.st_mtime > file->modtime) {
+	if (update_only && st.st_mtime > file->modtime && fnamecmp == fname) {
 		if (verbose > 1)
 			rprintf(FINFO,"%s is newer\n",fname);
 		return;
 	}
 
 	if (skip_file(fname, file, &st)) {
@@ -304,28 +325,28 @@
 		write_int(f_out,i);
 		send_sums(NULL,f_out);    
 		return;
 	}
 
 	/* open the file */  
-	fd = open(fname,O_RDONLY);
+	fd = open(fnamecmp,O_RDONLY);
 
 	if (fd == -1) {
-		rprintf(FERROR,"failed to open %s : %s\n",fname,strerror(errno));
+		rprintf(FERROR,"failed to open %s : %s\n",fnamecmp,strerror(errno));
 		rprintf(FERROR,"skipping %s\n",fname);
 		return;
 	}
 
 	if (st.st_size > 0) {
 		buf = map_file(fd,st.st_size);
 	} else {
 		buf = NULL;
 	}
 
 	if (verbose > 3)
-		rprintf(FINFO,"gen mapped %s of size %d\n",fname,(int)st.st_size);
+		rprintf(FINFO,"gen mapped %s of size %d\n",fnamecmp,(int)st.st_size);
 
 	s = generate_sums(buf,st.st_size,adapt_block_size(file, block_size));
 
 	if (verbose > 2)
 		rprintf(FINFO,"sending sums for %d\n",i);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/io.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/io.c	1998-11-04 06:00:45.000000000 +0800
@@ -57,13 +57,13 @@
 
 	t = time(NULL);
 
 	if (last_io && io_timeout && (t-last_io) >= io_timeout) {
 		rprintf(FERROR,"io timeout after %d second - exiting\n", 
 			(int)(t-last_io));
-		exit_cleanup(1);
+		exit_cleanup(RERR_TIMEOUT);
 	}
 }
 
 
 static char *read_buffer;
 static char *read_buffer_p;
@@ -97,13 +97,12 @@
 			continue;
 		}
 
 		n = read(fd, buf, len);
 
 		if (n > 0) {
-			stats.total_read += n;
 			buf += n;
 			len -= n;
 			ret += n;
 			if (io_timeout)
 				last_io = time(NULL);
 			continue;
@@ -123,17 +122,17 @@
 		}
 
 		if (n == 0) {
 			if (eof_error) {
 				rprintf(FERROR,"unexpected EOF in read_timeout\n");
 			}
-			exit_cleanup(1);
+			exit_cleanup(RERR_STREAMIO);
 		}
 
 		rprintf(FERROR,"read error: %s\n", strerror(errno));
-		exit_cleanup(1);
+		exit_cleanup(RERR_STREAMIO);
 	}
 
 	return ret;
 }
 
 /* continue trying to read len bytes - don't return until len
@@ -179,19 +178,19 @@
 		if (tag == MPLEX_BASE) continue;
 
 		tag -= MPLEX_BASE;
 
 		if (tag != FERROR && tag != FINFO) {
 			rprintf(FERROR,"unexpected tag %d\n", tag);
-			exit_cleanup(1);
+			exit_cleanup(RERR_STREAMIO);
 		}
 
 		if (remaining > sizeof(line)-1) {
 			rprintf(FERROR,"multiplexing overflow %d\n\n", 
 				remaining);
-			exit_cleanup(1);
+			exit_cleanup(RERR_STREAMIO);
 		}
 
 		read_loop(fd, line, remaining);
 		line[remaining] = 0;
 
 		rprintf(tag,"%s", line);
@@ -261,34 +260,42 @@
 		io_flush();
 		no_flush_read--;
 
 		ret = read_unbuffered(fd,buffer + total,N-total);
 		total += ret;
 	}
+
+	stats.total_read += total;
 }
 
 
 int32 read_int(int f)
 {
 	char b[4];
+	int32 ret;
+
 	readfd(f,b,4);
-	return IVAL(b,0);
+	ret = IVAL(b,0);
+	if (ret == (int32)0xffffffff) return -1;
+	return ret;
 }
 
 int64 read_longint(int f)
 {
 	extern int remote_version;
 	int64 ret;
 	char b[8];
 	ret = read_int(f);
 
-	if ((int32)ret != (int32)0xffffffff) return ret;
+	if ((int32)ret != (int32)0xffffffff) {
+		return ret;
+	}
 
 #ifdef NO_INT64
 	rprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
-	exit_cleanup(1);
+	exit_cleanup(RERR_UNSUPPORTED);
 #else
 	if (remote_version >= 16) {
 		readfd(f,b,8);
 		ret = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
 	}
 #endif
@@ -376,18 +383,17 @@
 				blocked++;
 				continue;
 			}
 
 			if (ret <= 0) {
 				rprintf(FERROR,"erroring writing %d bytes - exiting\n", len);
-				exit_cleanup(1);
+				exit_cleanup(RERR_STREAMIO);
 			}
 
 			blocked = 0;
 			total += ret;
-			stats.total_written += ret;
 
 			if (io_timeout)
 				last_io = time(NULL);
 		}
 	}
 
@@ -432,12 +438,14 @@
 		io_buffer = NULL;
 	}
 }
 
 static void writefd(int fd,char *buf,int len)
 {
+	stats.total_written += len;
+
 	if (!io_buffer) {
 		writefd_unbuffered(fd, buf, len);
 		return;
 	}
 
 	while (len) {
@@ -468,13 +476,13 @@
 
 	if (remote_version < 16 || x <= 0x7FFFFFFF) {
 		write_int(f, (int)x);
 		return;
 	}
 
-	write_int(f, -1);
+	write_int(f, (int32)0xFFFFFFFF);
 	SIVAL(b,0,(x&0xFFFFFFFF));
 	SIVAL(b,4,((x>>32)&0xFFFFFFFF));
 
 	writefd(f,b,8);
 }
 
@@ -530,13 +538,13 @@
 	int len;
 	
 	va_start(ap, format);
 	len = vslprintf(buf, sizeof(buf)-1, format, ap);
 	va_end(ap);
 
-	if (len < 0) exit_cleanup(1);
+	if (len < 0) exit_cleanup(RERR_STREAMIO);
 
 	write_sbuf(fd, buf);
 }
 
 
 /* setup for multiplexing an error stream with the data stream */
@@ -552,13 +560,13 @@
 void io_start_multiplex_in(int fd)
 {
 	multiplex_in_fd = fd;
 	io_flush();
 	if (read_buffer_len) {
 		fprintf(stderr,"ERROR: data in read buffer at mplx start\n");
-		exit_cleanup(1);
+		exit_cleanup(RERR_STREAMIO);
 	}
 
 	io_multiplexing_in = 1;
 }
 
 /* write an message to the error stream */
@@ -568,12 +576,14 @@
 
 	io_flush();
 
 	SIVAL(io_buffer-4, 0, ((MPLEX_BASE + f)<<24) + len);
 	memcpy(io_buffer, buf, len);
 
+	stats.total_written += (len+4);
+
 	writefd_unbuffered(multiplex_out_fd, io_buffer-4, len+4);
 	return 1;
 }
 
 void io_close_input(int fd)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/lib/compat.c	1998-06-18 18:30:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib/compat.c	1998-11-04 06:00:46.000000000 +0800
@@ -73,6 +73,22 @@
 		++s;
 	}
 
 	return NULL;
 }
 #endif
+
+#ifdef REPLACE_INET_NTOA
+char *rep_inet_ntoa(struct in_addr ip)
+{
+	unsigned char *p = (unsigned char *)&ip.s_addr;
+	static char buf[18];
+#if WORDS_BIGENDIAN
+	slprintf(buf, 17, "%d.%d.%d.%d", 
+		 (int)p[0], (int)p[1], (int)p[2], (int)p[3]);
+#else
+	slprintf(buf, 17, "%d.%d.%d.%d", 
+		 (int)p[3], (int)p[2], (int)p[1], (int)p[0]);
+#endif
+	return buf;
+}
+#endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib: mdfour.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib: mdfour.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib: snprintf.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/loadparm.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/loadparm.c	1998-11-04 06:00:45.000000000 +0800
@@ -96,12 +96,13 @@
  */
 typedef struct
 {
 	char *motd_file;
 	char *lock_file;
 	char *log_file;
+	char *pid_file;
 	int syslog_facility;
 	int max_connections;
 	char *socket_options;
 } global;
 
 static global Globals;
@@ -115,39 +116,45 @@
 {
 	char *name;
 	char *path;
 	char *comment;
 	BOOL read_only;
 	BOOL list;
+	BOOL use_chroot;
+	BOOL transfer_logging;
 	char *uid;
 	char *gid;
 	char *hosts_allow;
 	char *hosts_deny;
 	char *auth_users;
 	char *secrets_file;
 	char *exclude;
 	char *exclude_from;
+	char *log_format;
 } service;
 
 
 /* This is a default service used to prime a services structure */
 static service sDefault = 
 {
 	NULL,    /* name */
 	NULL,    /* path */
 	NULL,    /* comment */
 	True,    /* read only */
 	True,    /* list */
+	True,    /* use chroot */
+	False,   /* transfer logging */
 	"nobody",/* uid */
 	"nobody",/* gid */
 	NULL,    /* hosts allow */
 	NULL,    /* hosts deny */
 	NULL,    /* auth users */
 	NULL,    /* secrets file */
 	NULL,    /* exclude */
 	NULL,    /* exclude from */
+	"%o %h [%a] %m (%u) %f %l",    /* log format */
 };
 
 
 
 /* local variables */
 static service **ServicePtrs = NULL;
@@ -230,26 +237,30 @@
   {"max connections",  P_INTEGER, P_GLOBAL, &Globals.max_connections,NULL, 0},
   {"motd file",        P_STRING,  P_GLOBAL, &Globals.motd_file,    NULL,   0},
   {"lock file",        P_STRING,  P_GLOBAL, &Globals.lock_file,    NULL,   0},
   {"syslog facility",  P_ENUM,    P_GLOBAL, &Globals.syslog_facility, enum_facilities,0},
   {"socket options",   P_STRING,  P_GLOBAL, &Globals.socket_options,NULL,  0},
   {"log file",         P_STRING,  P_GLOBAL, &Globals.log_file,      NULL,  0},
+  {"pid file",         P_STRING,  P_GLOBAL, &Globals.pid_file,      NULL,  0},
 
   {"name",             P_STRING,  P_LOCAL,  &sDefault.name,        NULL,   0},
   {"comment",          P_STRING,  P_LOCAL,  &sDefault.comment,     NULL,   0},
   {"path",             P_STRING,  P_LOCAL,  &sDefault.path,        NULL,   0},
   {"read only",        P_BOOL,    P_LOCAL,  &sDefault.read_only,   NULL,   0},
   {"list",             P_BOOL,    P_LOCAL,  &sDefault.list,        NULL,   0},
+  {"use chroot",       P_BOOL,    P_LOCAL,  &sDefault.use_chroot,  NULL,   0},
   {"uid",              P_STRING,  P_LOCAL,  &sDefault.uid,         NULL,   0},
   {"gid",              P_STRING,  P_LOCAL,  &sDefault.gid,         NULL,   0},
   {"hosts allow",      P_STRING,  P_LOCAL,  &sDefault.hosts_allow, NULL,   0},
   {"hosts deny",       P_STRING,  P_LOCAL,  &sDefault.hosts_deny,  NULL,   0},
   {"auth users",       P_STRING,  P_LOCAL,  &sDefault.auth_users,  NULL,   0},
   {"secrets file",     P_STRING,  P_LOCAL,  &sDefault.secrets_file,NULL,   0},
   {"exclude",          P_STRING,  P_LOCAL,  &sDefault.exclude,     NULL,   0},
   {"exclude from",     P_STRING,  P_LOCAL,  &sDefault.exclude_from,NULL,   0},
+  {"transfer logging", P_BOOL,    P_LOCAL,  &sDefault.transfer_logging,NULL,0},
+  {"log format",       P_STRING,  P_LOCAL,  &sDefault.log_format,  NULL,   0},
   {NULL,               P_BOOL,    P_NONE,   NULL,                  NULL,   0}
 };
 
 
 /***************************************************************************
 Initialise the global parameter structure.
@@ -295,29 +306,33 @@
  int fn_name(int i) {return(LP_SNUM_OK(i)? pSERVICE(i)->val : sDefault.val);}
 
 
 FN_GLOBAL_STRING(lp_motd_file, &Globals.motd_file)
 FN_GLOBAL_STRING(lp_lock_file, &Globals.lock_file)
 FN_GLOBAL_STRING(lp_log_file, &Globals.log_file)
+FN_GLOBAL_STRING(lp_pid_file, &Globals.pid_file)
 FN_GLOBAL_STRING(lp_socket_options, &Globals.socket_options)
 FN_GLOBAL_INTEGER(lp_max_connections, &Globals.max_connections)
 FN_GLOBAL_INTEGER(lp_syslog_facility, &Globals.syslog_facility)
 
 FN_LOCAL_STRING(lp_name, name)
 FN_LOCAL_STRING(lp_comment, comment)
 FN_LOCAL_STRING(lp_path, path)
 FN_LOCAL_BOOL(lp_read_only, read_only)
 FN_LOCAL_BOOL(lp_list, list)
+FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
+FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
 FN_LOCAL_STRING(lp_uid, uid)
 FN_LOCAL_STRING(lp_gid, gid)
 FN_LOCAL_STRING(lp_hosts_allow, hosts_allow)
 FN_LOCAL_STRING(lp_hosts_deny, hosts_deny)
 FN_LOCAL_STRING(lp_auth_users, auth_users)
 FN_LOCAL_STRING(lp_secrets_file, secrets_file)
 FN_LOCAL_STRING(lp_exclude, exclude)
 FN_LOCAL_STRING(lp_exclude_from, exclude_from)
+FN_LOCAL_STRING(lp_log_format, log_format)
 
 /* local prototypes */
 static int    strwicmp( char *psz1, char *psz2 );
 static int    map_parameter( char *parmname);
 static BOOL   set_boolean( BOOL *pb, char *parmvalue );
 static int    getservicebyname(char *name, service *pserviceDest);
@@ -340,13 +355,13 @@
 {
 	if (!v) {
 		*s = NULL;
 		return;
 	}
 	*s = strdup(v);
-	if (!*s) exit_cleanup(1);
+	if (!*s) exit_cleanup(RERR_MALLOC);
 }
 
 
 /***************************************************************************
 add a new service to the services array initialising it with the given 
 service
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/log.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/log.c	1998-11-04 06:00:45.000000000 +0800
@@ -23,55 +23,46 @@
   */
 #include "rsync.h"
 
 static FILE *logfile;
 
 
-/****************************************************************************
-  return the date and time as a string
-****************************************************************************/
-static char *timestring(void )
-{
-	static char TimeBuf[200];
-	time_t t = time(NULL);
-	struct tm *tm = localtime(&t);
-
-#ifdef HAVE_STRFTIME
-	strftime(TimeBuf,sizeof(TimeBuf)-1,"%Y/%m/%d %T",tm);
-#else
-	strlcpy(TimeBuf, asctime(tm), sizeof(TimeBuf)-1);
-#endif
-
-	if (TimeBuf[strlen(TimeBuf)-1] == '\n') {
-		TimeBuf[strlen(TimeBuf)-1] = 0;
-	}
-
-	return(TimeBuf);
-}
-
 static void logit(int priority, char *buf)
 {
 	if (logfile) {
-		fprintf(logfile,"%s  %s", timestring(), buf);
+		fprintf(logfile,"%s [%d] %s", 
+			timestring(time(NULL)), (int)getpid(), buf);
 		fflush(logfile);
 	} else {
 		syslog(priority, "%s", buf);
 	}
 }
 
 void log_open(void)
 {
 	static int initialised;
 	int options = LOG_PID;
 	time_t t;
+	char *logf;
 
 	if (initialised) return;
 	initialised = 1;
 
-	if (lp_log_file()) {
-		logfile = fopen(lp_log_file(), "a");
+	/* this looks pointless, but it is needed in order for the
+	   C library on some systems to fetch the timezone info
+	   before the chroot */
+	t = time(NULL);
+	localtime(&t);
+
+	/* optionally use a log file instead of syslog */
+	logf = lp_log_file();
+	if (logf && *logf) {
+		extern int orig_umask;
+		int old_umask = umask(022 | orig_umask);
+		logfile = fopen(logf, "a");
+		umask(old_umask);
 		return;
 	}
 
 #ifdef LOG_NDELAY
 	options |= LOG_NDELAY;
 #endif
@@ -82,50 +73,49 @@
 	openlog("rsyncd", options);
 #endif
 
 #ifndef LOG_NDELAY
 	logit(LOG_INFO,"rsyncd started\n");
 #endif
-
-	/* this looks pointless, but it is needed in order for the
-	   C library on some systems to fetch the timezone info
-	   before the chroot */
-	t = time(NULL);
-	localtime(&t);
 }
 		
 
-/* this is the rsync debugging function. Call it with FINFO or FERROR */
-void rprintf(int fd, const char *format, ...)
+/* this is the rsync debugging function. Call it with FINFO, FERROR or FLOG */
+ void rprintf(int fd, const char *format, ...)
 {
 	va_list ap;  
 	char buf[1024];
 	int len;
 	FILE *f=NULL;
 	extern int am_daemon;
 	/* recursion can happen with certain fatal conditions */
-	static int depth;
-
-	if (depth) return;
-
-	depth++;
 
 	va_start(ap, format);
 	len = vslprintf(buf, sizeof(buf)-1, format, ap);
 	va_end(ap);
 
-	if (len < 0) exit_cleanup(1);
+	if (len < 0) exit_cleanup(RERR_MESSAGEIO);
 
-	if (len > sizeof(buf)-1) exit_cleanup(1);
+	if (len > sizeof(buf)-1) exit_cleanup(RERR_MESSAGEIO);
 
 	buf[len] = 0;
 
+	if (fd == FLOG) {
+		if (am_daemon) logit(LOG_INFO, buf);
+		return;
+	}
+
 	if (am_daemon) {
+		static int depth;
 		int priority = LOG_INFO;
 		if (fd == FERROR) priority = LOG_WARNING;
 
+		if (depth) return;
+
+		depth++;
+
 		log_open();
 		if (!io_multiplex_write(fd, buf, strlen(buf))) {
 			logit(priority, buf);
 		}
 
 		depth--;
@@ -141,40 +131,194 @@
 		if (am_server) 
 			f = stderr;
 		else
 			f = stdout;
 	} 
 
-	if (!f) exit_cleanup(1);
+	if (!f) exit_cleanup(RERR_MESSAGEIO);
 
-	if (fwrite(buf, len, 1, f) != 1) exit_cleanup(1);
+	if (fwrite(buf, len, 1, f) != 1) exit_cleanup(RERR_MESSAGEIO);
 
 	if (buf[len-1] == '\r' || buf[len-1] == '\n') fflush(f);
-
-	depth--;
 }
 
 void rflush(int fd)
 {
 	FILE *f = NULL;
 	extern int am_daemon;
 	
 	if (am_daemon) {
 		return;
 	}
 
+	if (fd == FLOG) {
+		return;
+	} 
+
 	if (fd == FERROR) {
 		f = stderr;
 	} 
 
 	if (fd == FINFO) {
 		extern int am_server;
 		if (am_server) 
 			f = stderr;
 		else
 			f = stdout;
 	} 
 
-	if (!f) exit_cleanup(1);
+	if (!f) exit_cleanup(RERR_MESSAGEIO);
 	fflush(f);
 }
 
+
+
+/* a generic logging routine for send/recv, with parameter
+   substitiution */
+static void log_formatted(int fd,
+			  char *format, char *op, struct file_struct *file,
+			  struct stats *initial_stats)
+{
+	extern int module_id;
+	extern char *auth_user;
+	char buf[1024];
+	char buf2[1024];
+	char *p, *s, *n;
+	int l;
+	extern struct stats stats;		
+	extern int am_sender;
+	int64 b;
+
+	strlcpy(buf, format, sizeof(buf)-1);
+	
+	for (s=&buf[0]; 
+	     s && (p=strchr(s,'%')); ) {
+		n = NULL;
+		s = p + 1;
+
+		switch (p[1]) {
+		case 'h': n = client_name(0); break;
+		case 'a': n = client_addr(0); break;
+		case 'l': 
+			slprintf(buf2,sizeof(buf2)-1,"%.0f", 
+				 (double)file->length); 
+			n = buf2;
+			break;
+		case 'p': 
+			slprintf(buf2,sizeof(buf2)-1,"%d", 
+				 (int)getpid()); 
+			n = buf2;
+			break;
+		case 'o': n = op; break;
+		case 'f': 
+			slprintf(buf2, sizeof(buf2)-1, "%s/%s", 
+				 file->basedir?file->basedir:"", 
+				 f_name(file));
+			clean_fname(buf2);
+			n = buf2; 
+			if (*n == '/') n++;
+			break;
+		case 'm': n = lp_name(module_id); break;
+		case 't': n = timestring(time(NULL)); break;
+		case 'P': n = lp_path(module_id); break;
+		case 'u': n = auth_user; break;
+		case 'b': 
+			if (am_sender) {
+				b = stats.total_written - 
+					initial_stats->total_written;
+			} else {
+				b = stats.total_read - 
+					initial_stats->total_read;
+			}
+			slprintf(buf2,sizeof(buf2)-1,"%.0f", (double)b); 
+			n = buf2;
+			break;
+		case 'c': 
+			if (!am_sender) {
+				b = stats.total_written - 
+					initial_stats->total_written;
+			} else {
+				b = stats.total_read - 
+					initial_stats->total_read;
+			}
+			slprintf(buf2,sizeof(buf2)-1,"%.0f", (double)b); 
+			n = buf2;
+			break;
+		}
+
+		if (!n) continue;
+
+		l = strlen(n);
+
+		if ((l-1) + ((int)(s - &buf[0])) > sizeof(buf)) {
+			rprintf(FERROR,"buffer overflow expanding %%%c - exiting\n",
+				p[0]);
+			exit_cleanup(RERR_MESSAGEIO);
+		}
+
+		if (l != 2) {
+			memmove(s+(l-1), s+1, strlen(s+1)+1);
+		}
+		memcpy(p, n, l);
+
+		s = p+l;
+	}
+
+	rprintf(fd,"%s\n", buf);
+}
+
+/* log the outgoing transfer of a file */
+void log_send(struct file_struct *file, struct stats *initial_stats)
+{
+	extern int module_id;
+	extern int am_server;
+	extern char *log_format;
+
+	if (lp_transfer_logging(module_id)) {
+		log_formatted(FLOG, lp_log_format(module_id), "send", file, initial_stats);
+	} else if (log_format && !am_server) {
+		log_formatted(FINFO, log_format, "send", file, initial_stats);
+	}
+}
+
+/* log the incoming transfer of a file */
+void log_recv(struct file_struct *file, struct stats *initial_stats)
+{
+	extern int module_id;
+	extern int am_server;
+	extern char *log_format;
+
+	if (lp_transfer_logging(module_id)) {
+		log_formatted(FLOG, lp_log_format(module_id), "send", file, initial_stats);
+	} else if (log_format && !am_server) {
+		log_formatted(FINFO, log_format, "send", file, initial_stats);
+	}
+}
+
+/* called when the transfer is interrupted for some reason */
+void log_exit(int code)
+{
+	if (code == 0) {
+		extern struct stats stats;		
+		rprintf(FLOG,"wrote %.0f bytes  read %.0f bytes  total size %.0f\n",
+			(double)stats.total_written,
+			(double)stats.total_read,
+			(double)stats.total_size);
+	} else {
+		rprintf(FLOG,"transfer interrupted (code %d)\n", code);
+	}
+}
+
+/* log the incoming transfer of a file for interactive use, this
+   will be called at the end where the client was run 
+   
+   it i called when a file starts to be transferred
+*/
+void log_transfer(struct file_struct *file, char *fname)
+{
+	extern int verbose;
+
+	if (!verbose) return;
+
+	rprintf(FINFO,"%s\n", fname);
+}
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/main.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/main.c	1998-11-04 06:00:45.000000000 +0800
@@ -33,16 +33,13 @@
 	extern int am_server;
 	extern int am_sender;
 	extern int am_daemon;
 	extern int do_stats;
 
 	if (am_daemon) {
-		syslog(LOG_INFO,"wrote %.0f bytes  read %.0f bytes  total size %.0f\n",
-		       (double)stats.total_written,
-		       (double)stats.total_read,
-		       (double)stats.total_size);
+		log_exit(0);
 		if (f == -1 || !am_sender) return;
 	}
 
 	if (!verbose) return;
 
 	if (am_server && !am_sender) return;
@@ -178,41 +175,41 @@
 
 	if (do_stat(name,&st) == 0) {
 		if (S_ISDIR(st.st_mode)) {
 			if (!push_dir(name, 0)) {
 				rprintf(FERROR,"push_dir %s : %s (1)\n",
 					name,strerror(errno));
-				exit_cleanup(1);
+				exit_cleanup(RERR_FILESELECT);
 			}
 			return NULL;
 		}
 		if (flist->count > 1) {
 			rprintf(FERROR,"ERROR: destination must be a directory when copying more than 1 file\n");
-			exit_cleanup(1);
+			exit_cleanup(RERR_FILESELECT);
 		}
 		return name;
 	}
 
 	if (flist->count == 1)
 		return name;
 
 	if (!name) 
 		return NULL;
 
 	if (do_mkdir(name,0777 & ~orig_umask) != 0) {
 		rprintf(FERROR,"mkdir %s : %s (1)\n",name,strerror(errno));
-		exit_cleanup(1);
+		exit_cleanup(RERR_FILEIO);
 	} else {
 		if (verbose > 0)
 			rprintf(FINFO,"created directory %s\n",name);
 	}
 
 	if (!push_dir(name, 0)) {
 		rprintf(FERROR,"push_dir %s : %s (2)\n",
 			name,strerror(errno));
-		exit_cleanup(1);
+		exit_cleanup(RERR_FILESELECT);
 	}
 
 	return NULL;
 }
 
 
@@ -228,13 +225,13 @@
 
 	if (verbose > 2)
 		rprintf(FINFO,"server_sender starting pid=%d\n",(int)getpid());
   
 	if (!relative_paths && !push_dir(dir, 0)) {
 		rprintf(FERROR,"push_dir %s: %s (3)\n",dir,strerror(errno));
-		exit_cleanup(1);
+		exit_cleanup(RERR_FILESELECT);
 	}
 	argc--;
 	argv++;
   
 	if (strcmp(dir,".")) {
 		int l = strlen(dir);
@@ -275,13 +272,13 @@
 
 	if (preserve_hard_links)
 		init_hard_links(flist);
 
 	if (pipe(recv_pipe) < 0) {
 		rprintf(FERROR,"pipe failed in do_recv\n");
-		exit_cleanup(1);
+		exit_cleanup(RERR_SOCKETIO);
 	}
   
 	io_flush();
 
 	if ((pid=do_fork()) == 0) {
 		close(recv_pipe[0]);
@@ -330,23 +327,23 @@
 		dir = argv[0];
 		argc--;
 		argv++;
 		if (!am_daemon && !push_dir(dir, 0)) {
 			rprintf(FERROR,"push_dir %s : %s (4)\n",
 				dir,strerror(errno));
-			exit_cleanup(1);
+			exit_cleanup(RERR_FILESELECT);
 		}    
 	}
 
 	if (delete_mode)
 		recv_exclude_list(f_in);
 
 	flist = recv_file_list(f_in);
 	if (!flist || flist->count == 0) {
 		rprintf(FERROR,"server_recv: nothing to do\n");
-		exit_cleanup(1);
+		exit_cleanup(RERR_FILESELECT);
 	}
 	
 	if (argc > 0) {    
 		if (strcmp(dir,".")) {
 			argv[0] += strlen(dir);
 			if (argv[0][0] == '/') argv[0]++;
@@ -384,12 +381,13 @@
 int client_run(int f_in, int f_out, int pid, int argc, char *argv[])
 {
 	struct file_list *flist;
 	int status = 0, status2 = 0;
 	char *local_name = NULL;
 	extern int am_sender;
+	extern int list_only;
 
 	setup_protocol(f_out,f_in);
 	
 	if (am_sender) {
 		extern int cvs_exclude;
 		extern int delete_mode;
@@ -412,12 +410,14 @@
 			io_flush();
 			waitpid(pid, &status, 0);
 		}
 		report(-1);
 		exit_cleanup(status);
 	}
+
+	if (argc == 0) list_only = 1;
 	
 	send_exclude_list(f_out);
 	
 	flist = recv_file_list(f_in);
 	if (!flist || flist->count == 0) {
 		rprintf(FINFO,"client: nothing to do\n");
@@ -461,24 +461,44 @@
 	char *shell_user = NULL;
 	int pid, ret;
 	int f_in,f_out;
 	extern int local_server;
 	extern int am_sender;
 	extern char *shell_cmd;
+	extern int rsync_port;
+
+	if (strncasecmp(URL_PREFIX, argv[0], strlen(URL_PREFIX)) == 0) {
+		char *host, *path;
+
+		host = argv[0] + strlen(URL_PREFIX);
+		p = strchr(host,'/');
+		if (p) {
+			*p = 0;
+			path = p+1;
+		} else {
+			path="";
+		}
+		p = strchr(host,':');
+		if (p) {
+			rsync_port = atoi(p+1);
+			*p = 0;
+		}
+		return start_socket_client(host, path, argc-1, argv+1);
+	}
 
 	p = find_colon(argv[0]);
 
 	if (p) {
 		if (p[1] == ':') {
 			*p = 0;
 			return start_socket_client(argv[0], p+2, argc-1, argv+1);
 		}
 
-		if (argc < 2) {
+		if (argc < 1) {
 			usage(FERROR);
-			exit_cleanup(1);
+			exit_cleanup(RERR_SYNTAX);
 		}
 
 		am_sender = 0;
 		*p = 0;
 		shell_machine = argv[0];
 		shell_path = p+1;
@@ -494,13 +514,13 @@
 			*p = 0;
 			return start_socket_client(argv[argc-1], p+2, argc-1, argv);
 		}
 
 		if (argc < 2) {
 			usage(FERROR);
-			exit_cleanup(1);
+			exit_cleanup(RERR_SYNTAX);
 		}
 		
 		if (local_server) {
 			shell_machine = NULL;
 			shell_path = argv[argc-1];
 		} else {
@@ -525,15 +545,15 @@
 			shell_cmd?shell_cmd:"",
 			shell_machine?shell_machine:"",
 			shell_user?shell_user:"",
 			shell_path?shell_path:"");
 	}
 	
-	if (!am_sender && argc != 1) {
+	if (!am_sender && argc > 1) {
 		usage(FERROR);
-		exit_cleanup(1);
+		exit_cleanup(RERR_SYNTAX);
 	}
 	
 	pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,&f_in,&f_out);
 	
 	ret = client_run(f_in, f_out, pid, argc, argv);
 
@@ -542,13 +562,13 @@
 
 	return ret;
 }
 
 
 static RETSIGTYPE sigusr1_handler(int val) {
-	exit_cleanup(1);
+	exit_cleanup(RERR_SIGNAL);
 }
 
 int main(int argc,char *argv[])
 {       
 	extern int am_root;
 	extern int orig_umask;
@@ -562,48 +582,49 @@
 	am_root = (getuid() == 0);
 
 	memset(&stats, 0, sizeof(stats));
 
 	if (argc < 2) {
 		usage(FERROR);
-		exit_cleanup(1);
+		exit_cleanup(RERR_SYNTAX);
 	}
 
 	/* we set a 0 umask so that correct file permissions can be
 	   carried across */
 	orig_umask = (int)umask(0);
 
 	if (!parse_arguments(argc, argv)) {
-		exit_cleanup(1);
+		exit_cleanup(RERR_SYNTAX);
 	}
 
 	argc -= optind;
 	argv += optind;
 	optind = 0;
 
 	signal(SIGCHLD,SIG_IGN);
 	signal(SIGINT,SIGNAL_CAST sig_int);
 	signal(SIGPIPE,SIGNAL_CAST sig_int);
 	signal(SIGHUP,SIGNAL_CAST sig_int);
+	signal(SIGTERM,SIGNAL_CAST sig_int);
 
 	if (am_daemon) {
 		return daemon_main();
 	}
 
 	if (argc < 1) {
 		usage(FERROR);
-		exit_cleanup(1);
+		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (dry_run)
 		verbose = MAX(verbose,1);
 
 #ifndef SUPPORT_LINKS
 	if (!am_server && preserve_links) {
 		rprintf(FERROR,"ERROR: symbolic links not supported\n");
-		exit_cleanup(1);
+		exit_cleanup(RERR_UNSUPPORTED);
 	}
 #endif
 
 	if (am_server) {
 		start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/Makefile.in	1998-09-09 15:06:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/Makefile.in	1998-11-04 06:00:45.000000000 +0800
@@ -1,52 +1,57 @@
 # Makefile for rsync. This is processed by configure to produce the final
 # Makefile
 
 prefix=@prefix@
 exec_prefix=@exec_prefix@
-INSTALL_BIN=$(exec_prefix)/bin
-INSTALL_MAN=$(prefix)/man
+bindir=@bindir@
+mandir=@mandir@
 
 LIBS=@LIBS@
 CC=@CC@
 CFLAGS=@CFLAGS@
 
 INSTALLCMD=@INSTALL@
 
-VPATH=@srcdir@
 srcdir=@srcdir@
+VPATH=$(srcdir)
 SHELL=/bin/sh
 
 
 .SUFFIXES:
 .SUFFIXES: .c .o
 
-LIBOBJ=lib/getopt.o lib/fnmatch.o lib/compat.o
+LIBOBJ=lib/getopt.o lib/fnmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o
 ZLIBOBJ=zlib/deflate.o zlib/infblock.o zlib/infcodes.o zlib/inffast.o \
 	zlib/inflate.o zlib/inftrees.o zlib/infutil.o zlib/trees.o \
-	zlib/zutil.o zlib/adler32.o
-OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o md4.o main.o checksum.o match.o syscall.o log.o
+	zlib/zutil.o zlib/adler32.o 
+OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o main.o checksum.o match.o syscall.o log.o
 OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o fileio.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 OBJS=$(OBJS1) $(OBJS2) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ)
 
 # note that the -I. is needed to handle config.h when using VPATH
 .c.o:
-	$(CC) -I. -I$(srcdir) $(CFLAGS) -c $< -o $@
+@OBJ_SAVE@
+	$(CC) -I. -I$(srcdir) $(CFLAGS) -c $< @CC_SHOBJ_FLAG@
+@OBJ_RESTORE@
 
 all: rsync
 
 man: rsync.1 rsyncd.conf.5
 
 install: all
-	-mkdir -p ${INSTALL_BIN}
-	${INSTALLCMD} -m 755 rsync ${INSTALL_BIN}
-	-mkdir -p ${INSTALL_MAN}/man1
-	-mkdir -p ${INSTALL_MAN}/man5
-	${INSTALLCMD} -m 644 $(srcdir)/rsync.1 ${INSTALL_MAN}/man1
-	${INSTALLCMD} -m 644 $(srcdir)/rsyncd.conf.5 ${INSTALL_MAN}/man5
+	-mkdir -p ${bindir}
+	${INSTALLCMD} -m 755 rsync ${bindir}
+	-mkdir -p ${mandir}/man1
+	-mkdir -p ${mandir}/man5
+	${INSTALLCMD} -m 644 $(srcdir)/rsync.1 ${mandir}/man1
+	${INSTALLCMD} -m 644 $(srcdir)/rsyncd.conf.5 ${mandir}/man5
+
+install-strip:
+	$(MAKE) INSTALLCMD='$(INSTALLCMD) -s' install
 
 rsync: $(OBJS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o rsync $(OBJS) $(LIBS)
 
 rsync.1: rsync.yo
 	yodl2man -o rsync.1 rsync.yo
@@ -55,13 +60,13 @@
 	yodl2man -o rsyncd.conf.5 rsyncd.conf.yo
 
 proto:
 	cat *.c | awk -f mkproto.awk > proto.h
 
 clean:
-	rm -f *~ $(OBJS) rsync config.cache config.log config.status
+	rm -f *~ $(OBJS) rsync 
 
 
 # this target is really just for my use. It only works on a limited
 # range of machines and is used to produce a list of potentially
 # dead (ie. unused) functions in the code. (tridge)
 finddead:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/md4.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/md4.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/md4.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/md4.c	1998-11-04 06:00:45.000000000 +0800
@@ -222,13 +222,13 @@
        *p++ = tmp;
        tmp = tmp >> 8;
      }
    /* Process data */
    if (count == 512)
      { /* Full block of data to handle */
-       MDblock(MDp,(unsigned int *)X);
+       MDblock(MDp,(unsigned int32 *)X);
      }
    else if (count > 512) /* Check for count too large */
      { rprintf(FERROR,"\nError: MDupdate called with illegal count value %d."
               ,count);
        return;
      }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/options.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/options.c	1998-11-04 06:00:46.000000000 +0800
@@ -61,21 +61,23 @@
 int safe_symlinks=0;
 
 int block_size=BLOCK_SIZE;
 
 char *backup_suffix = BACKUP_SUFFIX;
 char *tmpdir = NULL;
+char *compare_dest = NULL;
 char *config_file = RSYNCD_CONF;
 char *shell_cmd = NULL;
+char *log_format = NULL;
 
 char *rsync_path = RSYNC_NAME;
 int rsync_port = RSYNC_PORT;
 
 int verbose = 0;
 int always_checksum = 0;
-
+int list_only = 0;
 
 void usage(int F)
 {
   rprintf(F,"rsync version %s Copyright Andrew Tridgell and Paul Mackerras\n\n",
 	  VERSION);
 
@@ -83,12 +85,13 @@
 
   rprintf(F,"Usage: rsync [OPTION]... SRC [USER@]HOST:DEST\n");
   rprintf(F,"  or   rsync [OPTION]... [USER@]HOST:SRC DEST\n");
   rprintf(F,"  or   rsync [OPTION]... SRC DEST\n");
   rprintf(F,"  or   rsync [OPTION]... [USER@]HOST::SRC DEST\n");
   rprintf(F,"  or   rsync [OPTION]... SRC [USER@]HOST::DEST\n");
+  rprintf(F,"  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC DEST\n");
   rprintf(F,"\nOptions\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
   rprintf(F," -c, --checksum              always checksum\n");
   rprintf(F," -a, --archive               archive mode\n");
   rprintf(F," -r, --recursive             recurse into directories\n");
   rprintf(F," -R, --relative              use relative path names\n");
@@ -115,24 +118,26 @@
   rprintf(F,"     --partial               keep partially transferred files\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
   rprintf(F,"     --timeout=TIME          set IO timeout in seconds\n");
   rprintf(F," -I, --ignore-times          don't exclude files that match length and time\n");
   rprintf(F," -T  --temp-dir=DIR          create temporary files in directory DIR\n");
+  rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F," -z, --compress              compress file data\n");
-  rprintf(F,"     --exclude=PATTERN       exclude file FILE\n");
+  rprintf(F,"     --exclude=PATTERN       exclude files matching PATTERN\n");
   rprintf(F,"     --exclude-from=FILE     exclude patterns listed in FILE\n");
-  rprintf(F,"     --include=PATTERN       don't exclude file FILE\n");
+  rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
   rprintf(F,"     --include-from=FILE     don't exclude patterns listed in FILE\n");
   rprintf(F,"     --suffix=SUFFIX         override backup suffix\n");  
   rprintf(F,"     --version               print version number\n");  
   rprintf(F,"     --daemon                run as a rsync daemon\n");  
   rprintf(F,"     --config=FILE           specify alternate rsyncd.conf file\n");  
   rprintf(F,"     --port=PORT             specify alternate rsyncd port number\n");
   rprintf(F,"     --stats                 give some file transfer stats\n");  
   rprintf(F,"     --progress              show progress during transfer\n");  
+  rprintf(F,"     --log-format=FORMAT     log file transfers using specified format\n");  
   rprintf(F," -h, --help                  show this help screen\n");
 
   rprintf(F,"\n");
   rprintf(F,"the backup suffix defaults to %s\n",BACKUP_SUFFIX);
   rprintf(F,"the block size defaults to %d\n",BLOCK_SIZE);  
 
@@ -141,13 +146,13 @@
 }
 
 enum {OPT_VERSION,OPT_SUFFIX,OPT_SENDER,OPT_SERVER,OPT_EXCLUDE,
       OPT_EXCLUDE_FROM,OPT_DELETE,OPT_NUMERIC_IDS,OPT_RSYNC_PATH,
       OPT_FORCE,OPT_TIMEOUT,OPT_DAEMON,OPT_CONFIG,OPT_PORT,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_STATS, OPT_PARTIAL, OPT_PROGRESS,
-      OPT_SAFE_LINKS};
+      OPT_SAFE_LINKS, OPT_COMPARE_DEST, OPT_LOG_FORMAT};
 
 static char *short_options = "oblLWHpguDCtcahvrRIxnSe:B:T:z";
 
 static struct option long_options[] = {
   {"version",     0,     0,    OPT_VERSION},
   {"server",      0,     0,    OPT_SERVER},
@@ -185,19 +190,21 @@
   {"times",       0,     0,    't'},
   {"rsh",         1,     0,    'e'},
   {"suffix",      1,     0,    OPT_SUFFIX},
   {"block-size",  1,     0,    'B'},
   {"timeout",     1,     0,    OPT_TIMEOUT},
   {"temp-dir",    1,     0,    'T'},
+  {"compare-dest", 1,    0,    OPT_COMPARE_DEST},
   {"compress",	  0,	 0,    'z'},
   {"daemon",      0,     0,    OPT_DAEMON},
   {"stats",       0,     0,    OPT_STATS},
   {"progress",    0,     0,    OPT_PROGRESS},
   {"partial",     0,     0,    OPT_PARTIAL},
   {"config",      1,     0,    OPT_CONFIG},
   {"port",        1,     0,    OPT_PORT},
+  {"log-format",  1,     0,    OPT_LOG_FORMAT},
   {0,0,0,0}};
 
 
 int parse_arguments(int argc, char *argv[])
 {
 	int opt;
@@ -352,13 +359,13 @@
 			am_server = 1;
 			break;
 
 		case OPT_SENDER:
 			if (!am_server) {
 				usage(FERROR);
-				exit_cleanup(1);
+				exit_cleanup(RERR_SYNTAX);
 			}
 			am_sender = 1;
 			break;
 
 		case 'r':
 			recurse = 1;
@@ -381,12 +388,16 @@
 			break;
 
 		case 'T':
 			tmpdir = optarg;
 			break;
 
+		case OPT_COMPARE_DEST:
+			compare_dest = optarg;
+			break;
+
 		case 'z':
 			do_compression = 1;
 			break;
 
 		case OPT_DAEMON:
 			am_daemon = 1;
@@ -409,12 +420,16 @@
 			break;
 
 		case OPT_PORT:
 			rsync_port = atoi(optarg);
 			break;
 
+		case OPT_LOG_FORMAT:
+			log_format = optarg;
+			break;
+
 		default:
 			return 0;
 		}
 	}
 	return 1;
 }
@@ -513,9 +528,19 @@
 
 	if (tmpdir) {
 		args[ac++] = "--temp-dir";
 		args[ac++] = tmpdir;
 	}
 
+	if (compare_dest && am_sender) {
+		/* the server only needs this option if it is not the sender,
+		 *   and it may be an older version that doesn't know this
+		 *   option, so don't send it if client is the sender.
+		 */
+		args[ac++] = "--compare-dest";
+		args[ac++] = compare_dest;
+	}
+
+
 	*argc = ac;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/packaging/redhat/5.0/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/packaging/redhat/5.0/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/packaging/redhat/5.0/rsync.spec	1998-09-09 15:07:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/packaging/redhat/5.0/rsync.spec	1998-11-04 06:00:53.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.1.1
+Version: 2.2.0
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.1.1.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.2.0.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/proto.h	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/proto.h	1998-11-04 06:00:46.000000000 +0800
@@ -11,16 +11,18 @@
 void sum_update(char *p,int len);
 void sum_end(char *sum);
 void exit_cleanup(int code);
 void cleanup_disable(void);
 void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
 		 struct map_struct *buf, int fd1, int fd2);
+void cleanup_set_pid(int pid);
 int start_socket_client(char *host, char *path, int argc, char *argv[]);
 int daemon_main(void);
 void setup_protocol(int f_out,int f_in);
 int claim_connection(char *fname,int max_connections);
+int send_included_file_names(int f,struct file_list *flist);
 int check_exclude(char *name,struct exclude_struct **local_exclude_list,
 		  STRUCT_STAT *st);
 void add_exclude_list(char *pattern,struct exclude_struct ***list, int include);
 void add_exclude(char *pattern, int include);
 struct exclude_struct **make_exclude_list(char *fname,
 					  struct exclude_struct **list1,
@@ -33,12 +35,14 @@
 int sparse_end(int f);
 int write_file(int f,char *buf,int len);
 struct map_struct *map_file(int fd,OFF_T len);
 char *map_ptr(struct map_struct *map,OFF_T offset,int len);
 void unmap_file(struct map_struct *map);
 int link_stat(const char *Path, STRUCT_STAT *Buffer) ;
+void send_file_name(int f,struct file_list *flist,char *fname,
+			   int recursive, unsigned base_flags);
 struct file_list *send_file_list(int f,int argc,char *argv[]);
 struct file_list *recv_file_list(int f);
 int file_compare(struct file_struct **f1,struct file_struct **f2);
 int flist_find(struct file_list *flist,struct file_struct *f);
 void flist_free(struct file_list *flist);
 char *f_name(struct file_struct *f);
@@ -66,34 +70,41 @@
 void io_start_multiplex_in(int fd);
 int io_multiplex_write(int f, char *buf, int len);
 void io_close_input(int fd);
 char *lp_motd_file(void);
 char *lp_lock_file(void);
 char *lp_log_file(void);
+char *lp_pid_file(void);
 char *lp_socket_options(void);
 int lp_max_connections(void);
 int lp_syslog_facility(void);
 char *lp_name(int );
 char *lp_comment(int );
 char *lp_path(int );
 BOOL lp_read_only(int );
 BOOL lp_list(int );
+BOOL lp_use_chroot(int );
+BOOL lp_transfer_logging(int );
 char *lp_uid(int );
 char *lp_gid(int );
 char *lp_hosts_allow(int );
 char *lp_hosts_deny(int );
 char *lp_auth_users(int );
 char *lp_secrets_file(int );
 char *lp_exclude(int );
 char *lp_exclude_from(int );
+char *lp_log_format(int );
 BOOL lp_load(char *pszFname, int globals_only);
 int lp_numservices(void);
 int lp_number(char *name);
 void log_open(void);
-void rprintf(int fd, const char *format, ...);
 void rflush(int fd);
+void log_send(struct file_struct *file, struct stats *initial_stats);
+void log_recv(struct file_struct *file, struct stats *initial_stats);
+void log_exit(int code);
+void log_transfer(struct file_struct *file, char *fname);
 void start_server(int f_in, int f_out, int argc, char *argv[]);
 int client_run(int f_in, int f_out, int pid, int argc, char *argv[]);
 int main(int argc,char *argv[]);
 void match_sums(int f,struct sum_struct *s,struct map_struct *buf,OFF_T len);
 void match_report(void);
 void usage(int F);
@@ -167,6 +178,8 @@
 char *push_dir(char *dir, int save);
 int pop_dir(char *dir);
 int u_strcmp(const char *cs1, const char *cs2);
 void end_progress(void);
 void show_progress(OFF_T ofs, OFF_T size);
 int unsafe_symlink(char *dest, char *src);
+char *sanitize_path(char *p);
+char *timestring(time_t t);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/receiver.c	1998-09-09 14:23:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/receiver.c	1998-11-04 06:00:46.000000000 +0800
@@ -29,12 +29,13 @@
 extern int am_server;
 extern int relative_paths;
 extern int preserve_hard_links;
 extern int cvs_exclude;
 extern int io_error;
 extern char *tmpdir;
+extern char *compare_dest;
 
 
 static struct delete_list {
 	dev_t dev;
 	INO_T inode;
 } *delete_list;
@@ -219,13 +220,13 @@
 			cleanup_got_literal = 1;
       
 			sum_update(data,i);
 
 			if (fd != -1 && write_file(fd,data,i) != i) {
 				rprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
-				exit_cleanup(1);
+				exit_cleanup(RERR_FILEIO);
 			}
 			offset += i;
 			continue;
 		} 
 
 		i = -(i+1);
@@ -245,23 +246,23 @@
 		see_token(map, len);
 		sum_update(map,len);
 		
 		if (fd != -1 && write_file(fd,map,len) != len) {
 			rprintf(FERROR,"write failed on %s : %s\n",
 				fname,strerror(errno));
-			exit_cleanup(1);
+			exit_cleanup(RERR_FILEIO);
 		}
 		offset += len;
 	}
 
 	end_progress();
 
 	if (fd != -1 && offset > 0 && sparse_end(fd) != 0) {
 		rprintf(FERROR,"write failed on %s : %s\n",
 			fname,strerror(errno));
-		exit_cleanup(1);
+		exit_cleanup(RERR_FILEIO);
 	}
 
 	sum_end(file_sum1);
 
 	if (remote_version >= 14) {
 		read_buf(f_in,file_sum2,MD4_SUM_LENGTH);
@@ -281,18 +282,22 @@
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen)
 {  
 	int fd1,fd2;
 	STRUCT_STAT st;
 	char *fname;
 	char fnametmp[MAXPATHLEN];
+	char *fnamecmp;
+	char fnamecmpbuf[MAXPATHLEN];
 	struct map_struct *buf;
 	int i;
 	struct file_struct *file;
 	int phase=0;
 	int recv_ok;
-	
+	extern struct stats stats;		
+	struct stats initial_stats;
+
 	if (verbose > 2) {
 		rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
 	}
 
 	if (recurse && delete_mode && !local_name && flist->count>0) {
 		delete_files(flist);
@@ -314,54 +319,67 @@
 			break;
 		}
 
 		if (i < 0 || i >= flist->count) {
 			rprintf(FERROR,"Invalid file index %d in recv_files (count=%d)\n", 
 				i, flist->count);
-			exit_cleanup(1);
+			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		file = flist->files[i];
 		fname = f_name(file);
 
 		stats.num_transferred_files++;
 		stats.total_transferred_size += file->length;
 
 		if (local_name)
 			fname = local_name;
 
 		if (dry_run) {
-			if (!am_server && verbose)
-				rprintf(FINFO,"%s\n",fname);
+			if (!am_server) {
+				log_transfer(file, fname);
+			}
 			continue;
 		}
 
+		initial_stats = stats;
+
 		if (verbose > 2)
 			rprintf(FINFO,"recv_files(%s)\n",fname);
 
+		fnamecmp = fname;
+
 		/* open the file */  
-		fd1 = open(fname,O_RDONLY);
+		fd1 = open(fnamecmp,O_RDONLY);
+
+		if ((fd1 == -1) && (compare_dest != NULL)) {
+			/* try the file at compare_dest instead */
+			slprintf(fnamecmpbuf,MAXPATHLEN-1,"%s/%s",
+						compare_dest,fname);
+			fnamecmp = fnamecmpbuf;
+			fd1 = open(fnamecmp,O_RDONLY);
+		}
 
 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
-			rprintf(FERROR,"fstat %s : %s\n",fname,strerror(errno));
+			rprintf(FERROR,"fstat %s : %s\n",fnamecmp,strerror(errno));
 			receive_data(f_in,NULL,-1,NULL,file->length);
 			close(fd1);
 			continue;
 		}
 
 		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
-			rprintf(FERROR,"%s : not a regular file (recv_files)\n",fname);
+			rprintf(FERROR,"%s : not a regular file (recv_files)\n",fnamecmp);
 			receive_data(f_in,NULL,-1,NULL,file->length);
 			close(fd1);
 			continue;
 		}
 
 		if (fd1 != -1 && st.st_size > 0) {
 			buf = map_file(fd1,st.st_size);
 			if (verbose > 2)
-				rprintf(FINFO,"recv mapped %s of size %d\n",fname,(int)st.st_size);
+				rprintf(FINFO,"recv mapped %s of size %d\n",fnamecmp,(int)st.st_size);
 		} else {
 			buf = NULL;
 		}
 
 		if (!get_tmpname(fnametmp,fname)) {
 			if (buf) unmap_file(buf);
@@ -397,17 +415,20 @@
 			if (fd1 != -1) close(fd1);
 			continue;
 		}
       
 		cleanup_set(fnametmp, fname, file, buf, fd1, fd2);
 
-		if (!am_server && verbose)
-			rprintf(FINFO,"%s\n",fname);
-		
+		if (!am_server) {
+			log_transfer(file, fname);
+		}
+
 		/* recv file data */
 		recv_ok = receive_data(f_in,buf,fd2,fname,file->length);
+
+		log_recv(file, &initial_stats);
 		
 		if (buf) unmap_file(buf);
 		if (fd1 != -1) {
 			close(fd1);
 		}
 		close(fd2);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsync.1	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.1	1998-11-04 06:00:46.000000000 +0800
@@ -10,12 +10,14 @@
 rsync [options] path path
 .PP 
 rsync [options] [user@]host::module[/path] path
 .PP 
 rsync [options] path [user@]host::module[/path]
 .PP 
+rsync [options] rsync://[user@]host[:port]/module/path path
+.PP 
 .SH "DESCRIPTION" 
 .PP 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speedup file transfers when the destination file already
 exists\&.
@@ -42,13 +44,13 @@
 .IP o 
 support for anonymous or authenticated rsync servers (ideal for
 mirroring)
 .PP 
 .SH "GENERAL" 
 .PP 
-There are five different ways of using rsync\&. They are:
+There are six different ways of using rsync\&. They are:
 .PP 
 .IP o 
 for copying local files\&. This is invoked when neither
 source nor destination path contains a : separator
 .IP 
 .IP o 
@@ -62,18 +64,24 @@
 using a remote shell program\&. This is invoked when the local path
 contains a : separator\&.
 .IP 
 .IP o 
 for copying from a remote rsync server to the local
 machine\&. This is invoked when the source path contains a ::
-separator\&. 
+separator\&. You can also use a rsync:// URL if no username
+is required\&.
 .IP 
 .IP o 
 for copying from the local machine to a remote rsync
 server\&. This is invoked when the destination path contains a ::
 separator\&. 
+.IP 
+.IP o 
+for listing files on a remote machine\&. This is done the
+same way as rsync transfers except that you leave off the
+local destination\&.  
 .PP 
 Note that in all cases at least one of the source and destination
 paths must be local\&.
 .PP 
 .SH "SETUP" 
 .PP 
@@ -152,12 +160,16 @@
 the remote server may print a message of the day when you
 connect
 .IP 
 .IP o 
 if you specify no path name on the remote server then the
 list of accessible paths on the server will be shown\&.
+.IP 
+.IP o 
+if you specify no local destination then a listing of the
+specified files on the remote server is provided
 .PP 
 Some paths on the remote server may require authentication\&. If so then
 you will receive a password prompt when you connect\&. You can avoid the
 password prompt by setting the environment variable RSYNC_PASSWORD to
 the password you want to use\&. This may be useful when scripting rsync\&.
 .PP 
@@ -220,12 +232,13 @@
 
 Usage: rsync [OPTION]\&.\&.\&. SRC [USER@]HOST:DEST
   or   rsync [OPTION]\&.\&.\&. [USER@]HOST:SRC DEST
   or   rsync [OPTION]\&.\&.\&. SRC DEST
   or   rsync [OPTION]\&.\&.\&. [USER@]HOST::SRC DEST
   or   rsync [OPTION]\&.\&.\&. SRC [USER@]HOST::DEST
+  or   rsync [OPTION]\&.\&.\&. rsync://[USER@]HOST[:PORT]/SRC DEST
 
 Options
  -v, --verbose               increase verbosity
  -c, --checksum              always checksum
  -a, --archive               archive mode
  -r, --recursive             recurse into directories
@@ -253,24 +266,26 @@
      --partial               keep partially transferred files
      --force                 force deletion of directories even if not empty
      --numeric-ids           don\'t map uid/gid values by user/group name
      --timeout=TIME          set IO timeout in seconds
  -I, --ignore-times          don\'t exclude files that match length and time
  -T  --temp-dir=DIR          create temporary files in directory DIR
+     --compare-dest=DIR      also compare destination files relative to DIR
  -z, --compress              compress file data
-     --exclude=PATTERN       exclude file FILE
-     --exclude-from=PATTERN  exclude files listed in FILE
-     --include=PATTERN       don\'t exclude file FILE
-     --include-from=PATTERN  don\'t exclude files listed in FILE
+     --exclude=PATTERN       exclude files matching PATTERN
+     --exclude-from=FILE     exclude files listed in FILE
+     --include=PATTERN       don\'t exclude files matching PATTERN
+     --include-from=FILE     don\'t exclude files listed in FILE
      --suffix=SUFFIX         override backup suffix
      --version               print version number
      --daemon                run as a rsync daemon
      --config=FILE           specify alternate rsyncd\&.conf file
      --port=PORT             specify alternate rsyncd port number
      --stats                 give some file transfer stats
      --progress              show progress during transfer
+     --log-format=FORMAT     log file transfers using specified format
  -h, --help                  show this help screen
 
 .DE 
  
 
 .PP 
@@ -398,17 +413,21 @@
 This option causes rsync to update the remote
 permissions to be the same as the local permissions\&.
 .IP 
 .IP "\fB-o, --owner\fP" 
 This option causes rsync to update the  remote  owner
 of the  file to be the same as the local owner\&. This is only available
-to the super-user\&.
+to the super-user\&.  Note that if the source system is a daemon using chroot,
+the --numeric-ids option is implied because the source system cannot get
+access to the user names\&.
 .IP 
 .IP "\fB-g, --group\fP" 
 This option causes rsync to update the  remote  group
-of the file to be the same as the local group\&.
+of the file to be the same as the local group\&.  Note that if the source
+system is a daemon using chroot, the --numeric-ids option is implied because
+the source system cannot get access to the group names\&.
 .IP 
 .IP "\fB-D, --devices\fP" 
 This option causes rsync to transfer character and
 block device information to the remote system to recreate these
 devices\&. This option is only available to the super-user\&.
 .IP 
@@ -448,15 +467,17 @@
 these directories are deleted\&.
 .IP 
 Still, it is probably easy to get burnt with this option\&.  The moral
 of the story is to use the -n option until you get used to the
 behavior of --delete\&.
 .IP 
-NOTE: It also may delete files on the destination if the sending side
-can\'t open them or stat them\&. This is a bug that hopefully will be
-fixed in a future release\&.
+If the sending side detects any IO errors then the deletion of any
+files at the destination will be automatically disabled\&. This is to
+prevent temporary filesystem failures (such as NFS errors) on the
+sending side causing a massive deletion of files on the
+destination\&. 
 .IP 
 .IP "\fB--force\fP" 
 This options tells rsync to delete directories even if
 they are not empty\&.  This applies to both the --delete option and to
 cases where rsync tries to copy a normal file but the destination
 contains a directory of the same name\&. Normally rsync will refuse to
@@ -552,17 +573,28 @@
 Current versions of rsync actually use an adaptive algorithm for the
 checksum length by default, using a 16 byte file checksum to determine
 if a 2nd pass is required with a longer block checksum\&. Only use this
 option if you have read the source code and know what you are doing\&.
 .IP 
 .IP "\fB-T, --temp-dir DIR\fP" 
-This options instructs rsync to use DIR as a
-scratch directory when creating a temporary copies of the files
+This option instructs rsync to use DIR as a
+scratch directory when creating temporary copies of the files
 transferred on the receiving side\&.  The default behavior is to create
 the temporary files in the receiving directory\&.
 .IP 
+.IP "\fB--compare-dest DIR\fP" 
+This option instructs rsync to use DIR as an
+additional directory to compare destination files against when doing
+transfers\&.  This is useful for doing transfers to a new destination while
+leaving existing files intact, and then doing a flash-cutover when all
+files have been successfully transfered (for example by moving directories
+around and removing the old directory)\&.  This option increases the
+usefulness of --partial because partially transferred files will remain in
+the new temporary destination until they have a chance to be completed\&.
+If DIR is a relative path, it is relative to the destination directory\&.
+.IP 
 .IP "\fB-z, --compress\fP" 
 With this option, rsync compresses any data from
 the source file(s) which it sends to the destination machine\&.  This
 option is useful on slow links\&.  The compression method used is the
 same method that gzip uses\&.
 .IP 
@@ -578,14 +610,15 @@
 .IP 
 By default rsync will use the user name and group name to determine
 what ownership to give files\&. The special uid 0 and the special group
 0 and never mapped via user/group names even if the --numeric-ids
 option is not specified\&.
 .IP 
-If a user or group name does not exist on the destination system then
-the numeric id from the source system is used instead\&.
+If the source system is a daemon using chroot, or if a user or group name
+does not exist on the destination system, then the numeric id from the
+source system is used instead\&.
 .IP 
 .IP "\fB--timeout=TIMEOUT\fP" 
 This option allows you to set a maximum IO
 timeout in seconds\&. If no data is transferred for the specified time
 then rsync will exit\&. The default is 0, which means no timeout\&.
 .IP 
@@ -604,12 +637,18 @@
 specified\&. 
 .IP 
 .IP "\fB--port PORT\fP" 
 This specifies an alternate TCP port number to use
 rather than the default port 873\&. 
 .IP 
+.IP "\fB--log-format=FORMAT\fP" 
+Normally rsync just logs filenames as
+they are transferred\&. This allows you to specify exactly what gets
+logged on a per file basis\&. The log format is specified using the same
+format conventions as the log format option in rsyncd\&.conf\&.
+.IP 
 .IP "\fB--stats\fP" 
 This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data\&. This option only works in conjunction with
 the -v (verbose) option\&.
 .IP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsync.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.c	1998-11-04 06:00:46.000000000 +0800
@@ -185,13 +185,13 @@
 	return updated;
 }
 
 
 void sig_int(void)
 {
-	exit_cleanup(1);
+	exit_cleanup(RERR_SIGNAL);
 }
 
 
 /* finish off a file transfer, renaming the file and setting the permissions
    and ownership */
 void finish_transfer(char *fname, char *fnametmp, struct file_struct *file)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsyncd.conf.5	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncd.conf.5	1998-11-04 06:00:46.000000000 +0800
@@ -98,23 +98,72 @@
 exceeded\&. The default is \f(CW/var/run/rsyncd\&.lock\fP\&.
 .IP 
 .IP "\fBlog file\fP" 
 The "log file" option tells the rsync daemon to log
 messages to that file rather than using syslog\&. This is particularly
 useful on systems (such as AIX) where syslog() doesn\'t work for
-chrooted programs like rsync\&.
+chrooted programs\&.
+.IP 
+.IP "\fBpid file\fP" 
+The "pid file" option tells the rsync daemon to write
+its process id to that file\&.
 .IP 
 .IP "\fBsyslog facility\fP" 
 The "syslog facility" option allows you to
 specify the syslog facility name to use when logging messages from the
 rsync server\&. You may use any standard syslog facility name which is
 defined on your system\&. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
 local1, local2, local3, local4, local5, local6 and local7\&. The default
 is daemon\&. 
 .IP 
+.IP "\fBtransfer logging\fP" 
+The "transfer logging" option enables per-file 
+logging of downloads and uploads in a format somewhat similar to that
+used by ftp daemons\&. If you want to customise the log formats look at
+log_send, log_recv and log_transfer in log\&.c
+.IP 
+.IP "\fBlog format\fP" 
+The "log format" option allows you to specify the
+format used for logging file transfers when transfer logging is
+enabled\&. The format is a text string containing embedded single
+character escape sequences prefixed with a percent (%) character\&.
+.IP 
+The prefixes that are understood are:
+.IP 
+.IP o 
+%h for the remote host name
+.IP o 
+%a for the remote IP address
+.IP o 
+%l for the length of the file in bytes
+.IP o 
+%p for the process id of this rsync session
+.IP o 
+%o for the operation, which is either "send" or "recv"
+.IP o 
+%f for the filename
+.IP o 
+%P for the module path
+.IP o 
+%m for the module name
+.IP o 
+%t for the current time
+.IP o 
+%u for the authenticated username (or the null string)
+.IP o 
+%b for the number of bytes actually transferred 
+.IP o 
+%c when sending files this gives the number of checksum bytes
+received for this file
+.IP 
+The default log format is "%o %h [%a] %m (%u) %f %l"
+.IP 
+A perl script called rsyncstats to summarise this format is included
+in the rsync source code distribution\&.
+.IP 
 .IP "\fBsocket options\fP" 
 This option can provide endless fun for people
 who like to tune their systems to the utmost degree\&. You can set all
 sorts of socket options which may make transfers faster (or
 slower!)\&. Read the man page for the setsockopt() system call for
 details on some of the options you may be able to set\&. By default no
@@ -133,15 +182,22 @@
 The "comment" option specifies a description string
 that is displayed next to the module name when clients obtain a list
 of available modules\&. The default is no comment\&.
 .IP 
 .IP "\fBpath\fP" 
 The "path" option specifies the directory in the servers
-filesystem to make available in this module\&. The rsync server will
-chroot to this path before starting the file transfer with the
-client\&. You must specify this option for each module in \f(CW/etc/rsyncd\&.conf\fP\&.
+filesystem to make available in this module\&.  You must specify this option
+for each module in \f(CW/etc/rsyncd\&.conf\fP\&.
+.IP 
+.IP "\fBuse chroot\fP" 
+If "use chroot" is true, the rsync server will chroot
+to the "path" before starting the file transfer with the client\&.  This has
+the advantage of extra protection against possible implementation security
+holes, but it has the disadvantages of requiring super-user privileges and
+of not being able to follow symbolic links outside of the new root path\&.
+The default is to use chroot\&.
 .IP 
 .IP "\fBread only\fP" 
 The "read only" option determines whether clients
 will be able to upload files or not\&. If "read only" is true then any
 attempted uploads will fail\&. If "read only" is false then uploads will
 be possible if file permissions on the server allow them\&. The default
@@ -296,16 +352,19 @@
 A more sophisticated example would be:
 .PP 
 uid = nobody 
 .br 
 gid = nobody 
 .br 
+use chroot = no 
+.br 
 max connections = 4 
 .br 
 syslog facility = local5 
 .br 
+pid file = /etc/rsyncd\&.pid
 .PP 
 
 .DS 
  
 [ftp]
         path = /var/ftp/pub
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsyncd.conf.yo	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncd.conf.yo	1998-11-04 06:00:46.000000000 +0800
@@ -91,22 +91,58 @@
 locking on this file to ensure that the max connections limit is not
 exceeded. The default is tt(/var/run/rsyncd.lock).
 
 dit(bf(log file)) The "log file" option tells the rsync daemon to log
 messages to that file rather than using syslog. This is particularly
 useful on systems (such as AIX) where syslog() doesn't work for
-chrooted programs like rsync.
+chrooted programs.
+
+dit(bf(pid file)) The "pid file" option tells the rsync daemon to write
+its process id to that file.
 
 dit(bf(syslog facility)) The "syslog facility" option allows you to
 specify the syslog facility name to use when logging messages from the
 rsync server. You may use any standard syslog facility name which is
 defined on your system. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
 local1, local2, local3, local4, local5, local6 and local7. The default
 is daemon. 
 
+dit(bf(transfer logging)) The "transfer logging" option enables per-file 
+logging of downloads and uploads in a format somewhat similar to that
+used by ftp daemons. If you want to customise the log formats look at
+log_send, log_recv and log_transfer in log.c
+
+dit(bf(log format)) The "log format" option allows you to specify the
+format used for logging file transfers when transfer logging is
+enabled. The format is a text string containing embedded single
+character escape sequences prefixed with a percent (%) character.
+
+The prefixes that are understood are:
+
+itemize(
+  it() %h for the remote host name
+  it() %a for the remote IP address
+  it() %l for the length of the file in bytes
+  it() %p for the process id of this rsync session
+  it() %o for the operation, which is either "send" or "recv"
+  it() %f for the filename
+  it() %P for the module path
+  it() %m for the module name
+  it() %t for the current time
+  it() %u for the authenticated username (or the null string)
+  it() %b for the number of bytes actually transferred 
+  it() %c when sending files this gives the number of checksum bytes
+    received for this file
+)
+
+The default log format is "%o %h [%a] %m (%u) %f %l"
+
+A perl script called rsyncstats to summarise this format is included
+in the rsync source code distribution.
+
 dit(bf(socket options)) This option can provide endless fun for people
 who like to tune their systems to the utmost degree. You can set all
 sorts of socket options which may make transfers faster (or
 slower!). Read the man page for the setsockopt() system call for
 details on some of the options you may be able to set. By default no
 special socket options are set.
@@ -125,15 +161,21 @@
 
 dit(bf(comment)) The "comment" option specifies a description string
 that is displayed next to the module name when clients obtain a list
 of available modules. The default is no comment.
 
 dit(bf(path)) The "path" option specifies the directory in the servers
-filesystem to make available in this module. The rsync server will
-chroot to this path before starting the file transfer with the
-client. You must specify this option for each module in tt(/etc/rsyncd.conf).
+filesystem to make available in this module.  You must specify this option
+for each module in tt(/etc/rsyncd.conf).
+
+dit(bf(use chroot)) If "use chroot" is true, the rsync server will chroot
+to the "path" before starting the file transfer with the client.  This has
+the advantage of extra protection against possible implementation security
+holes, but it has the disadvantages of requiring super-user privileges and
+of not being able to follow symbolic links outside of the new root path.
+The default is to use chroot.
 
 dit(bf(read only)) The "read only" option determines whether clients
 will be able to upload files or not. If "read only" is true then any
 attempted uploads will fail. If "read only" is false then uploads will
 be possible if file permissions on the server allow them. The default
 is for all modules to be read only.
@@ -269,14 +311,16 @@
 
 
 A more sophisticated example would be:
 
 uid = nobody nl()
 gid = nobody nl()
+use chroot = no nl()
 max connections = 4 nl()
 syslog facility = local5 nl()
+pid file = /etc/rsyncd.pid
 
 verb([ftp]
         path = /var/ftp/pub
         comment = whole ftp area (approx 6.1 GB)
 
 [sambaftp]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsync.h	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.h	1998-11-04 06:00:46.000000000 +0800
@@ -20,12 +20,14 @@
 #define BLOCK_SIZE 700
 #define RSYNC_RSH_ENV "RSYNC_RSH"
 
 #define RSYNC_NAME "rsync"
 #define RSYNCD_CONF "/etc/rsyncd.conf"
 
+#define URL_PREFIX "rsync://"
+
 #define BACKUP_SUFFIX "~"
 
 /* a non-zero CHAR_OFFSET makes the rolling sum stronger, but is
    imcompatible with older versions :-( */
 #define CHAR_OFFSET 0
 
@@ -56,12 +58,15 @@
 
 #define MAX_ARGS 1000
 
 #define MPLEX_BASE 7
 #define FERROR 1
 #define FINFO 2
+#define FLOG 3
+
+#include "errcode.h"
 
 #include "config.h"
 
 #if HAVE_REMSH
 #define RSYNC_RSH "remsh"
 #else
@@ -201,20 +206,12 @@
 
 #ifdef HAVE_COMPAT_H
 #include <compat.h>
 #endif
 
 
-#ifndef S_IFLNK
-#define S_IFLNK  0120000
-#endif
-
-#ifndef S_ISLNK
-#define S_ISLNK(mode) (((mode) & S_IFLNK) == S_IFLNK)
-#endif
-
 #define BOOL int
 
 #ifndef uchar
 #define uchar unsigned char
 #endif
 
@@ -228,12 +225,16 @@
 #if (SIZEOF_INT == 4)
 #define int32 int
 #elif (SIZEOF_LONG == 4)
 #define int32 long
 #elif (SIZEOF_SHORT == 4)
 #define int32 short
+#else
+/* I hope this works */
+#define int32 int
+#define LARGE_INT32
 #endif
 #endif
 
 #ifndef uint32
 #define uint32 unsigned int32
 #endif
@@ -361,13 +362,13 @@
 	return i;
 }
 
 #include "byteorder.h"
 #include "version.h"
 #include "proto.h"
-#include "md4.h"
+#include "lib/mdfour.h"
 
 #if !HAVE_STRERROR
 extern char *sys_errlist[];
 #define strerror(i) sys_errlist[i]
 #endif
 
@@ -406,12 +407,24 @@
 #endif
 
 #ifndef S_IWUSR
 #define S_IWUSR 0200
 #endif
 
+#ifndef _S_IFMT
+#define _S_IFMT        0170000
+#endif
+
+#ifndef _S_IFLNK
+#define _S_IFLNK  0120000
+#endif
+
+#ifndef S_ISLNK
+#define S_ISLNK(mode) (((mode) & (_S_IFMT)) == (_S_IFLNK))
+#endif
+
 #ifndef S_ISBLK
 #define S_ISBLK(mode) (((mode) & (_S_IFMT)) == (_S_IFBLK))
 #endif
 
 #ifndef S_ISCHR
 #define S_ISCHR(mode) (((mode) & (_S_IFMT)) == (_S_IFCHR))
@@ -444,6 +457,20 @@
 
 #define IS_DEVICE(mode) (S_ISCHR(mode) || S_ISBLK(mode) || S_ISSOCK(mode) || S_ISFIFO(mode))
 
 #ifndef ACCESSPERMS
 #define ACCESSPERMS 0777
 #endif
+
+/* handler for null strings in printf format */
+#define NS(s) ((s)?(s):"<NULL>")
+
+/* use magic gcc attributes to catch format errors */
+ void rprintf(int , const char *, ...)
+#ifdef __GNUC__
+     __attribute__ ((format (printf, 2, 3)))
+#endif
+;
+
+#ifdef REPLACE_INET_NTOA
+#define inet_ntoa rep_inet_ntoa
+#endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0: rsyncstats
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/rsync.yo	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.yo	1998-11-04 06:00:46.000000000 +0800
@@ -10,12 +10,14 @@
 rsync [options] path path
 
 rsync [options] [user@]host::module[/path] path
 
 rsync [options] path [user@]host::module[/path]
 
+rsync [options] rsync://[user@]host[:port]/module/path path
+
 manpagedescription()
 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speedup file transfers when the destination file already
 exists.
@@ -37,13 +39,13 @@
   it() support for anonymous or authenticated rsync servers (ideal for
        mirroring)
 )
 
 manpagesection(GENERAL)
 
-There are five different ways of using rsync. They are:
+There are six different ways of using rsync. They are:
 
 itemize(
 	it() for copying local files. This is invoked when neither
 	     source nor destination path contains a : separator
 
 	it() for copying from the local machine to a remote machine using
@@ -54,17 +56,22 @@
 	it() for copying from a remote machine to the local machine
 	using a remote shell program. This is invoked when the local path
 	contains a : separator.
 
 	it() for copying from a remote rsync server to the local
 	machine. This is invoked when the source path contains a ::
-	separator. 
+	separator. You can also use a rsync:// URL if no username
+	is required.
 
 	it() for copying from the local machine to a remote rsync
 	server. This is invoked when the destination path contains a ::
 	separator. 
+
+	it() for listing files on a remote machine. This is done the
+	same way as rsync transfers except that you leave off the
+	local destination.  
 )
 
 Note that in all cases at least one of the source and destination
 paths must be local.
 
 manpagesection(SETUP)
@@ -137,12 +144,15 @@
 
 	it() the remote server may print a message of the day when you
 	connect
 
 	it() if you specify no path name on the remote server then the
 	list of accessible paths on the server will be shown.
+	
+	it() if you specify no local destination then a listing of the
+	specified files on the remote server is provided
 )
 
 Some paths on the remote server may require authentication. If so then
 you will receive a password prompt when you connect. You can avoid the
 password prompt by setting the environment variable RSYNC_PASSWORD to
 the password you want to use. This may be useful when scripting rsync.
@@ -195,12 +205,13 @@
 verb(
 Usage: rsync [OPTION]... SRC [USER@]HOST:DEST
   or   rsync [OPTION]... [USER@]HOST:SRC DEST
   or   rsync [OPTION]... SRC DEST
   or   rsync [OPTION]... [USER@]HOST::SRC DEST
   or   rsync [OPTION]... SRC [USER@]HOST::DEST
+  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC DEST
 
 Options
  -v, --verbose               increase verbosity
  -c, --checksum              always checksum
  -a, --archive               archive mode
  -r, --recursive             recurse into directories
@@ -228,24 +239,26 @@
      --partial               keep partially transferred files
      --force                 force deletion of directories even if not empty
      --numeric-ids           don't map uid/gid values by user/group name
      --timeout=TIME          set IO timeout in seconds
  -I, --ignore-times          don't exclude files that match length and time
  -T  --temp-dir=DIR          create temporary files in directory DIR
+     --compare-dest=DIR      also compare destination files relative to DIR
  -z, --compress              compress file data
-     --exclude=PATTERN       exclude file FILE
-     --exclude-from=PATTERN  exclude files listed in FILE
-     --include=PATTERN       don't exclude file FILE
-     --include-from=PATTERN  don't exclude files listed in FILE
+     --exclude=PATTERN       exclude files matching PATTERN
+     --exclude-from=FILE     exclude files listed in FILE
+     --include=PATTERN       don't exclude files matching PATTERN
+     --include-from=FILE     don't exclude files listed in FILE
      --suffix=SUFFIX         override backup suffix
      --version               print version number
      --daemon                run as a rsync daemon
      --config=FILE           specify alternate rsyncd.conf file
      --port=PORT             specify alternate rsyncd port number
      --stats                 give some file transfer stats
      --progress              show progress during transfer
+     --log-format=FORMAT     log file transfers using specified format
  -h, --help                  show this help screen
 )
 
 manpageoptions()
 
 rsync uses the GNU long options package. Many of the command line
@@ -341,16 +354,20 @@
 
 dit(bf(-p, --perms)) This option causes rsync to update the remote
 permissions to be the same as the local permissions.
 
 dit(bf(-o, --owner)) This option causes rsync to update the  remote  owner
 of the  file to be the same as the local owner. This is only available
-to the super-user.
+to the super-user.  Note that if the source system is a daemon using chroot,
+the --numeric-ids option is implied because the source system cannot get
+access to the user names.
 
 dit(bf(-g, --group)) This option causes rsync to update the  remote  group
-of the file to be the same as the local group.
+of the file to be the same as the local group.  Note that if the source
+system is a daemon using chroot, the --numeric-ids option is implied because
+the source system cannot get access to the group names.
 
 dit(bf(-D, --devices)) This option causes rsync to transfer character and
 block device information to the remote system to recreate these
 devices. This option is only available to the super-user.
 
 dit(bf(-t, --times)) This tells rsync to transfer modification times along
@@ -384,15 +401,17 @@
 these directories are deleted.
 
 Still, it is probably easy to get burnt with this option.  The moral
 of the story is to use the -n option until you get used to the
 behavior of --delete.
 
-NOTE: It also may delete files on the destination if the sending side
-can't open them or stat them. This is a bug that hopefully will be
-fixed in a future release.
+If the sending side detects any IO errors then the deletion of any
+files at the destination will be automatically disabled. This is to
+prevent temporary filesystem failures (such as NFS errors) on the
+sending side causing a massive deletion of files on the
+destination. 
 
 dit(bf(--force)) This options tells rsync to delete directories even if
 they are not empty.  This applies to both the --delete option and to
 cases where rsync tries to copy a normal file but the destination
 contains a directory of the same name. Normally rsync will refuse to
 do a recursive directory deletion in such cases, by using --force
@@ -474,17 +493,27 @@
 
 Current versions of rsync actually use an adaptive algorithm for the
 checksum length by default, using a 16 byte file checksum to determine
 if a 2nd pass is required with a longer block checksum. Only use this
 option if you have read the source code and know what you are doing.
 
-dit(bf(-T, --temp-dir DIR)) This options instructs rsync to use DIR as a
-scratch directory when creating a temporary copies of the files
+dit(bf(-T, --temp-dir DIR)) This option instructs rsync to use DIR as a
+scratch directory when creating temporary copies of the files
 transferred on the receiving side.  The default behavior is to create
 the temporary files in the receiving directory.
 
+dit(bf(--compare-dest DIR)) This option instructs rsync to use DIR as an
+additional directory to compare destination files against when doing
+transfers.  This is useful for doing transfers to a new destination while
+leaving existing files intact, and then doing a flash-cutover when all
+files have been successfully transfered (for example by moving directories
+around and removing the old directory).  This option increases the
+usefulness of --partial because partially transferred files will remain in
+the new temporary destination until they have a chance to be completed.
+If DIR is a relative path, it is relative to the destination directory.
+
 dit(bf(-z, --compress)) With this option, rsync compresses any data from
 the source file(s) which it sends to the destination machine.  This
 option is useful on slow links.  The compression method used is the
 same method that gzip uses.
 
 Note this this option typically achieves better compression ratios
@@ -498,14 +527,15 @@
 
 By default rsync will use the user name and group name to determine
 what ownership to give files. The special uid 0 and the special group
 0 and never mapped via user/group names even if the --numeric-ids
 option is not specified.
 
-If a user or group name does not exist on the destination system then
-the numeric id from the source system is used instead.
+If the source system is a daemon using chroot, or if a user or group name
+does not exist on the destination system, then the numeric id from the
+source system is used instead.
 
 dit(bf(--timeout=TIMEOUT)) This option allows you to set a maximum IO
 timeout in seconds. If no data is transferred for the specified time
 then rsync will exit. The default is 0, which means no timeout.
 
 dit(bf(--daemon)) This tells rsync that it is to run as a rsync
@@ -520,12 +550,17 @@
 the default /etc/rsyncd.conf. This is only relevant when --daemon is
 specified. 
 
 dit(bf(--port PORT)) This specifies an alternate TCP port number to use
 rather than the default port 873. 
 
+dit(bf(--log-format=FORMAT)) Normally rsync just logs filenames as
+they are transferred. This allows you to specify exactly what gets
+logged on a per file basis. The log format is specified using the same
+format conventions as the log format option in rsyncd.conf.
+
 dit(bf(--stats)) This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data. This option only works in conjunction with
 the -v (verbose) option.
 
 dit(bf(--progress)) This option tells rsync to print information
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/sender.c	1998-07-25 10:25:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/sender.c	1998-11-04 06:00:46.000000000 +0800
@@ -88,12 +88,14 @@
 	struct map_struct *buf;
 	STRUCT_STAT st;
 	char fname[MAXPATHLEN];  
 	int i;
 	struct file_struct *file;
 	int phase = 0;
+	extern struct stats stats;		
+	struct stats initial_stats;
 
 	if (verbose > 2)
 		rprintf(FINFO,"send_files starting\n");
 
 	setup_readbuffer(f_in);
 
@@ -113,13 +115,13 @@
 			break;
 		}
 
 		if (i < 0 || i >= flist->count) {
 			rprintf(FERROR,"Invalid file index %d (count=%d)\n", 
 				i, flist->count);
-			exit_cleanup(1);
+			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		file = flist->files[i];
 
 		stats.num_transferred_files++;
 		stats.total_transferred_size += file->length;
@@ -139,18 +141,21 @@
 		strlcat(fname,f_name(file),MAXPATHLEN-strlen(fname));
 	  
 		if (verbose > 2) 
 			rprintf(FINFO,"send_files(%d,%s)\n",i,fname);
 	  
 		if (dry_run) {	
-			if (!am_server && verbose)
-				rprintf(FINFO,"%s\n",fname);
+			if (!am_server) {
+				log_transfer(file, fname+offset);
+			}
 			write_int(f_out,i);
 			continue;
 		}
 
+		initial_stats = stats;
+
 		s = receive_sums(f_in);
 		if (!s) {
 			io_error = 1;
 			rprintf(FERROR,"receive_sums failed\n");
 			return;
 		}
@@ -179,27 +184,30 @@
 			buf = NULL;
 		}
 	  
 		if (verbose > 2)
 			rprintf(FINFO,"send_files mapped %s of size %d\n",
 				fname,(int)st.st_size);
-	  
+
 		write_int(f_out,i);
 	  
 		write_int(f_out,s->count);
 		write_int(f_out,s->n);
 		write_int(f_out,s->remainder);
 	  
 		if (verbose > 2)
 			rprintf(FINFO,"calling match_sums %s\n",fname);
 	  
-		if (!am_server && verbose)
-			rprintf(FINFO,"%s\n",fname+offset);
+		if (!am_server) {
+			log_transfer(file, fname+offset);
+		}
 	  
 		match_sums(f_out,s,buf,st.st_size);
-	  
+
+		log_send(file, &initial_stats);
+	  	  
 		if (buf) unmap_file(buf);
 		close(fd);
 	  
 		free_sums(s);
 	  
 		if (verbose > 2)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/socket.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/socket.c	1998-11-04 06:00:46.000000000 +0800
@@ -122,18 +122,18 @@
 {
 	int s;
 
 	/* open an incoming socket */
 	s = open_socket_in(SOCK_STREAM, port);
 	if (s == -1)
-		exit_cleanup(1);
+		exit_cleanup(RERR_SOCKETIO);
 
 	/* ready to listen */
 	if (listen(s, 5) == -1) {
 		close(s);
-		exit_cleanup(1);
+		exit_cleanup(RERR_SOCKETIO);
 	}
 
 
 	/* now accept incoming connections - forking a new process
 	   for each incoming connection */
 	while (1) {
@@ -317,19 +317,23 @@
 char *client_addr(int fd)
 {
 	struct sockaddr sa;
 	struct sockaddr_in *sockin = (struct sockaddr_in *) (&sa);
 	int     length = sizeof(sa);
 	static char addr_buf[100];
+	static int initialised;
+
+	if (initialised) return addr_buf;
+
+	initialised = 1;
 
 	if (getpeername(fd, &sa, &length)) {
-		exit_cleanup(1);
+		exit_cleanup(RERR_SOCKETIO);
 	}
-
+	
 	strlcpy(addr_buf,(char *)inet_ntoa(sockin->sin_addr), sizeof(addr_buf)-1);
-
 	return addr_buf;
 }
 
 
 /*******************************************************************
  return the DNS name of the client 
@@ -340,17 +344,22 @@
 	struct sockaddr_in *sockin = (struct sockaddr_in *) (&sa);
 	int     length = sizeof(sa);
 	static char name_buf[100];
 	struct hostent *hp;
 	char **p;
 	char *def = "UNKNOWN";
+	static int initialised;
+
+	if (initialised) return name_buf;
+
+	initialised = 1;
 
 	strcpy(name_buf,def);
 
 	if (getpeername(fd, &sa, &length)) {
-		exit_cleanup(1);
+		exit_cleanup(RERR_SOCKETIO);
 	}
 
 	/* Look up the remote host name. */
 	if ((hp = gethostbyaddr((char *) &sockin->sin_addr,
 				sizeof(sockin->sin_addr),
 				AF_INET))) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/token.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/token.c	1998-11-04 06:00:46.000000000 +0800
@@ -105,13 +105,13 @@
 			tx_strm.zalloc = NULL;
 			tx_strm.zfree = NULL;
 			if (deflateInit2(&tx_strm, Z_DEFAULT_COMPRESSION,
 					 Z_DEFLATED, -15, 8,
 					 Z_DEFAULT_STRATEGY) != Z_OK) {
 				rprintf(FERROR, "compression init failed\n");
-				exit_cleanup(1);
+				exit_cleanup(RERR_STREAMIO);
 			}
 			if ((obuf = malloc(MAX_DATA_COUNT+2)) == NULL)
 				out_of_memory("send_deflated_token");
 			init_done = 1;
 		} else
 			deflateReset(&tx_strm);
@@ -175,13 +175,13 @@
 			}
 			if (nb == 0 && token != -2)
 				flush = Z_SYNC_FLUSH;
 			r = deflate(&tx_strm, flush);
 			if (r != Z_OK) {
 				rprintf(FERROR, "deflate returned %d\n", r);
-				exit_cleanup(1);
+				exit_cleanup(RERR_STREAMIO);
 			}
 			if (nb == 0 || tx_strm.avail_out == 0) {
 				n = MAX_DATA_COUNT - tx_strm.avail_out;
 				if (flush != Z_NO_FLUSH) {
 					/*
 					 * We have to trim off the last 4
@@ -212,13 +212,13 @@
 		tx_strm.next_out = (Bytef *) obuf;
 		tx_strm.avail_out = MAX_DATA_COUNT;
 		r = deflate(&tx_strm, Z_INSERT_ONLY);
 		if (r != Z_OK || tx_strm.avail_in != 0) {
 			rprintf(FERROR, "deflate on token returned %d (%d bytes left)\n",
 				r, tx_strm.avail_in);
-			exit_cleanup(1);
+			exit_cleanup(RERR_STREAMIO);
 		}
 	}
 }
 
 
 /* tells us what the receiver is in the middle of doing */
@@ -247,13 +247,13 @@
 			if (!init_done) {
 				rx_strm.next_out = NULL;
 				rx_strm.zalloc = NULL;
 				rx_strm.zfree = NULL;
 				if (inflateInit2(&rx_strm, -15) != Z_OK) {
 					rprintf(FERROR, "inflate init failed\n");
-					exit_cleanup(1);
+					exit_cleanup(RERR_STREAMIO);
 				}
 				if ((cbuf = malloc(MAX_DATA_COUNT)) == NULL
 				    || (dbuf = malloc(CHUNK_SIZE)) == NULL)
 					out_of_memory("recv_deflated_token");
 				init_done = 1;
 			} else {
@@ -290,13 +290,13 @@
 				 * made, i.e. the decompressor didn't have
 				 * any pending output for us.
 				 */
 				if (r != Z_OK && r != Z_BUF_ERROR) {
 					rprintf(FERROR, "inflate flush returned %d (%d bytes)\n",
 						r, n);
-					exit_cleanup(1);
+					exit_cleanup(RERR_STREAMIO);
 				}
 				if (n != 0 && r != Z_BUF_ERROR) {
 					/* have to return some more data and
 					   save the flag for later. */
 					saved_flag = flag + 0x10000;
 					*data = dbuf;
@@ -305,13 +305,13 @@
 				/*
 				 * At this point the decompressor should
 				 * be expecting to see the 0, 0, ff, ff bytes.
 				 */
 				if (!inflateSyncPoint(&rx_strm)) {
 					rprintf(FERROR, "decompressor lost sync!\n");
-					exit_cleanup(1);
+					exit_cleanup(RERR_STREAMIO);
 				}
 				rx_strm.avail_in = 4;
 				rx_strm.next_in = (Bytef *)cbuf;
 				cbuf[0] = cbuf[1] = 0;
 				cbuf[2] = cbuf[3] = 0xff;
 				inflate(&rx_strm, Z_SYNC_FLUSH);
@@ -340,13 +340,13 @@
 			rx_strm.next_out = (Bytef *)dbuf;
 			rx_strm.avail_out = CHUNK_SIZE;
 			r = inflate(&rx_strm, Z_NO_FLUSH);
 			n = CHUNK_SIZE - rx_strm.avail_out;
 			if (r != Z_OK) {
 				rprintf(FERROR, "inflate returned %d (%d bytes)\n", r, n);
-				exit_cleanup(1);
+				exit_cleanup(RERR_STREAMIO);
 			}
 			if (rx_strm.avail_in == 0)
 				recv_state = r_inflated;
 			if (n != 0) {
 				*data = dbuf;
 				return n;
@@ -396,13 +396,13 @@
 		}
 		rx_strm.next_out = (Bytef *)dbuf;
 		rx_strm.avail_out = CHUNK_SIZE;
 		r = inflate(&rx_strm, Z_SYNC_FLUSH);
 		if (r != Z_OK) {
 			rprintf(FERROR, "inflate (token) returned %d\n", r);
-			exit_cleanup(1);
+			exit_cleanup(RERR_STREAMIO);
 		}
 	} while (len || rx_strm.avail_out == 0);
 }
 
 /*
  * transmit a verbatim buffer of length n followed by a token 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/util.c	1998-09-09 15:06:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/util.c	1998-11-04 06:00:46.000000000 +0800
@@ -58,45 +58,45 @@
   int to_child_pipe[2];
   int from_child_pipe[2];
 
   if (pipe(to_child_pipe) < 0 ||
       pipe(from_child_pipe) < 0) {
     rprintf(FERROR,"pipe: %s\n",strerror(errno));
-    exit_cleanup(1);
+    exit_cleanup(RERR_IPC);
   }
 
 
   pid = do_fork();
   if (pid < 0) {
     rprintf(FERROR,"fork: %s\n",strerror(errno));
-    exit_cleanup(1);
+    exit_cleanup(RERR_IPC);
   }
 
   if (pid == 0)
     {
       extern int orig_umask;
       if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 	  close(to_child_pipe[1]) < 0 ||
 	  close(from_child_pipe[0]) < 0 ||
 	  dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
 	rprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
-	exit_cleanup(1);
+	exit_cleanup(RERR_IPC);
       }
       if (to_child_pipe[0] != STDIN_FILENO) close(to_child_pipe[0]);
       if (from_child_pipe[1] != STDOUT_FILENO) close(from_child_pipe[1]);
       umask(orig_umask);
       execvp(command[0], command);
       rprintf(FERROR,"Failed to exec %s : %s\n",
 	      command[0],strerror(errno));
-      exit_cleanup(1);
+      exit_cleanup(RERR_IPC);
     }
 
   if (close(from_child_pipe[1]) < 0 ||
       close(to_child_pipe[0]) < 0) {
     rprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
-    exit_cleanup(1);
+    exit_cleanup(RERR_IPC);
   }
 
   *f_in = from_child_pipe[0];
   *f_out = to_child_pipe[1];
 
   set_nonblocking(*f_in);
@@ -111,20 +111,20 @@
 	int to_child_pipe[2];
 	int from_child_pipe[2];
 
 	if (pipe(to_child_pipe) < 0 ||
 	    pipe(from_child_pipe) < 0) {
 		rprintf(FERROR,"pipe: %s\n",strerror(errno));
-		exit_cleanup(1);
+		exit_cleanup(RERR_IPC);
 	}
 
 
 	pid = do_fork();
 	if (pid < 0) {
 		rprintf(FERROR,"fork: %s\n",strerror(errno));
-		exit_cleanup(1);
+		exit_cleanup(RERR_IPC);
 	}
 
 	if (pid == 0) {
 		extern int am_sender;
 		extern int am_server;
 
@@ -133,23 +133,23 @@
 
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
 			rprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
-			exit_cleanup(1);
+			exit_cleanup(RERR_IPC);
 		}
 		if (to_child_pipe[0] != STDIN_FILENO) close(to_child_pipe[0]);
 		if (from_child_pipe[1] != STDOUT_FILENO) close(from_child_pipe[1]);
 		start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
 	}
 
 	if (close(from_child_pipe[1]) < 0 ||
 	    close(to_child_pipe[0]) < 0) {
 		rprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
-		exit_cleanup(1);
+		exit_cleanup(RERR_IPC);
 	}
 
 	*f_in = from_child_pipe[0];
 	*f_out = to_child_pipe[1];
   
 	return pid;
@@ -157,19 +157,19 @@
 
 
 
 void out_of_memory(char *str)
 {
   rprintf(FERROR,"ERROR: out of memory in %s\n",str);
-  exit_cleanup(1);
+  exit_cleanup(RERR_MALLOC);
 }
 
 void overflow(char *str)
 {
   rprintf(FERROR,"ERROR: buffer overflow in %s\n",str);
-  exit_cleanup(1);
+  exit_cleanup(RERR_MALLOC);
 }
 
 
 
 int set_modtime(char *fname,time_t modtime)
 {
@@ -504,56 +504,19 @@
 
 /* this is like vsnprintf but the 'n' limit does not include
    the terminating null. So if you have a 1024 byte buffer then
    pass 1023 for n */
 int vslprintf(char *str, int n, const char *format, va_list ap)
 {
-#ifdef HAVE_VSNPRINTF
 	int ret = vsnprintf(str, n, format, ap);
 	if (ret > n || ret < 0) {
 		str[n] = 0;
 		return -1;
 	}
 	str[ret] = 0;
 	return ret;
-#else
-	static char *buf;
-	static int len=MAXPATHLEN*8;
-	int ret;
-
-	/* this code is NOT a proper vsnprintf() implementation. It
-	   relies on the fact that all calls to slprintf() in rsync
-	   pass strings which have already been checked to be less
-	   than MAXPATHLEN in length and never more than 2 strings are
-	   concatenated. This means the above buffer is absolutely
-	   ample and can never be overflowed.
-
-	   In the future we would like to replace this with a proper
-	   vsnprintf() implementation but right now we need a solution
-	   that is secure and portable. This is it.  */
-
-	if (!buf) {
-		buf = malloc(len);
-		if (!buf) {
-			/* can't call debug or we would recurse */
-			exit_cleanup(1);
-		}
-	}
-
-	vsprintf(buf, format, ap);
-	ret = strlen(buf);
-	if (ret > n) {
-		/* yikes! */
-		exit_cleanup(1);
-	}
-	buf[ret] = 0;
-	
-	memcpy(str, buf, ret+1);
-
-	return ret;
-#endif
 }
 
 
 /* like snprintf but always null terminates */
 int slprintf(char *str, int n, char *format, ...)
 {
@@ -613,12 +576,61 @@
 			modified = 1;
 			p[l-1] = 0;
 		}
 	}
 }
 
+/*
+ * Make path appear as if a chroot had occurred:
+ *    0. call clean_fname on it.
+ *    1. remove leading "/" (or replace with "." if at end)
+ *    2. remove leading ".." components
+ *    3. delete any other "<dir>/.." (recursively)
+ * Return a malloc'ed copy.
+ * Contributed by Dave Dykstra <dwd@bell-labs.com>
+ */
+
+char *sanitize_path(char *p)
+{
+	char *copy, *copyp;
+
+	clean_fname(p);
+
+	copy = (char *) malloc(strlen(p)+1);
+	copyp = copy;
+	while (*p != '\0') {
+		if ((*p == '/') && (copyp == copy)) {
+			/* remove leading slash */
+			p++;
+		}
+		else if ((*p == '.') && (*(p+1) == '.') &&
+			    ((*(p+2) == '/') || (*(p+2) == '\0'))) {
+			/* remove .. followed by slash or end */
+			p += 2;
+			if (copyp != copy) {
+				/* backup the copy one level */
+				while ((--copyp != copy) && (*copyp == '/'))
+					/* skip trailing slashes */
+					;
+				while ((copyp != copy) && (*copyp != '/'))
+					/* skip back through slash */
+					copyp--;
+			}
+		} else {
+			/* copy one component */
+			while (1) {
+				*copyp++ = *p++;
+				if ((*p == '\0') || (*(p-1) == '/'))
+					break;
+			}
+		}
+	}
+	*copyp = '\0';
+	return(copy);
+}
+
 
 static char curr_dir[MAXPATHLEN];
 
 /* like chdir() but can be reversed with pop_dir() if save is set. It
    is also much faster as it remembers where we have been */
 char *push_dir(char *dir, int save)
@@ -749,6 +761,29 @@
 		if (depth < 0) break;
 	}
 
 	free(dest);
 	return (depth < 0);
 }
+
+
+/****************************************************************************
+  return the date and time as a string
+****************************************************************************/
+char *timestring(time_t t)
+{
+	static char TimeBuf[200];
+	struct tm *tm = localtime(&t);
+
+#ifdef HAVE_STRFTIME
+	strftime(TimeBuf,sizeof(TimeBuf)-1,"%Y/%m/%d %T",tm);
+#else
+	strlcpy(TimeBuf, asctime(tm), sizeof(TimeBuf)-1);
+#endif
+
+	if (TimeBuf[strlen(TimeBuf)-1] == '\n') {
+		TimeBuf[strlen(TimeBuf)-1] = 0;
+	}
+
+	return(TimeBuf);
+}
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.1.1/version.h	1998-09-09 15:07:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/version.h	1998-11-04 06:00:51.000000000 +0800
@@ -1 +1 @@
-#define VERSION "2.1.1"
+#define VERSION "2.2.0"
