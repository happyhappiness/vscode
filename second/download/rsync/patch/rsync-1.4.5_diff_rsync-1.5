diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/checksum.c	1996-06-30 13:11:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/checksum.c	1996-07-03 16:19:02.000000000 +0800
@@ -21,12 +21,13 @@
 
 int csum_length=SUM_LENGTH;
 
 #define CSUM_CHUNK 64
 
 int checksum_seed = 0;
+extern int remote_version;
 
 /*
   a simple 32 bit checksum that can be upadted from either end
   (inspired by Mark Adler's Adler-32 checksum)
   */
 uint32 get_checksum1(char *buf,int len)
@@ -80,23 +81,24 @@
     len += 4;
   }
 
   for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
     MDupdate(&MD, buf1+i, CSUM_CHUNK*8);
   }
-  MDupdate(&MD, buf1+i, (len-i)*8);
+  if (len - i > 0)
+    MDupdate(&MD, buf1+i, (len-i)*8);
 
   sum_put(&MD,sum);
 }
 
 
 void file_checksum(char *fname,char *sum,off_t size)
 {
   int i;
   MDstruct MD;
-  char *buf;
+  struct map_struct *buf;
   int fd;
   int len = size;
   char tmpchunk[CSUM_CHUNK];
 
   bzero(sum,csum_length);
 
@@ -109,40 +111,83 @@
 
   for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
     bcopy(map_ptr(buf,i,CSUM_CHUNK),tmpchunk,CSUM_CHUNK);
     MDupdate(&MD, tmpchunk, CSUM_CHUNK*8);
   }
 
-  bcopy(map_ptr(buf,i,len-i),tmpchunk,len-i);
-  MDupdate(&MD, tmpchunk, (len-i)*8);
+  if (len - i > 0) {
+    bcopy(map_ptr(buf,i,len-i),tmpchunk,len-i);
+    MDupdate(&MD, tmpchunk, (len-i)*8);
+  }
 
   sum_put(&MD,sum);
 
   close(fd);
-  unmap_file(buf,size);
+  unmap_file(buf);
 }
 
 
 void checksum_init(void)
 {
+  if (remote_version >= 14)
+    csum_length = 2; /* adaptive */
+  else
+    csum_length = SUM_LENGTH;
 }
 
 
-#ifdef CHECKSUM_MAIN
- int main(int argc,char *argv[])
+
+static MDstruct sumMD;
+static int sumresidue;
+static char sumrbuf[CSUM_CHUNK];
+
+void sum_init(void)
 {
-  char sum[SUM_LENGTH];
-  int i,j;
+  char s[4];
+  MDbegin(&sumMD);  
+  sumresidue=0;
+  SIVAL(s,0,checksum_seed);
+  sum_update(s,4);
+}
 
-  checksum_init();
+void sum_update(char *p,int len)
+{
+  int i;
+  if (len + sumresidue < CSUM_CHUNK) {
+    bcopy(p,sumrbuf+sumresidue,len);
+    sumresidue += len;
+    return;
+  }
 
-  for (i=1;i<argc;i++) {
-    struct stat st;
-    if (stat(argv[i],&st) == 0) {
-      file_checksum(argv[i],sum,st.st_size);
-      for (j=0;j<SUM_LENGTH;j++)
-	printf("%02X",(unsigned char)sum[j]);
-      printf("  %s\n",argv[i]);
-    }
+  if (sumresidue) {
+    i = MIN(CSUM_CHUNK-sumresidue,len);
+    bcopy(p,sumrbuf+sumresidue,i);
+    MDupdate(&sumMD, sumrbuf, (i+sumresidue)*8);
+    len -= i;
+    p += i;
+  }
+
+  for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
+    bcopy(p+i,sumrbuf,CSUM_CHUNK);
+    MDupdate(&sumMD, sumrbuf, CSUM_CHUNK*8);
+  }
+
+  if (len - i > 0) {
+    sumresidue = len-i;
+    bcopy(p+i,sumrbuf,sumresidue);
+  } else {
+    sumresidue = 0;    
   }
 }
-#endif
+
+void sum_end(char *sum)
+{
+  if (sumresidue)
+    MDupdate(&sumMD, sumrbuf, sumresidue*8);
+
+  SIVAL(sum,0,sumMD.buffer[0]);
+  SIVAL(sum,4,sumMD.buffer[1]);
+  SIVAL(sum,8,sumMD.buffer[2]);
+  SIVAL(sum,12,sumMD.buffer[3]);  
+}
+
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/compat.c	1996-06-30 12:29:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/compat.c	1996-07-02 13:47:20.000000000 +0800
@@ -214,8 +214,10 @@
       checksum_seed = time(NULL);
       write_int(f_out,checksum_seed);
     } else {
       checksum_seed = read_int(f_in);
     }
   }
+
+  checksum_init();
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/flist.c	1996-06-30 12:29:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/flist.c	1996-07-03 14:24:58.000000000 +0800
@@ -107,13 +107,13 @@
 
   for (l1=0;lastname[l1] && file->name[l1] == lastname[l1];l1++) ;
   l2 = strlen(file->name) - l1;
 
   if (l1 > 0) flags |= SAME_NAME;
   if (l2 > 255) flags |= LONG_NAME;
-    
+
   write_byte(f,flags);  
   if (flags & SAME_NAME)
     write_byte(f,l1);
   if (flags & LONG_NAME)
     write_int(f,l2);
   else
@@ -162,13 +162,13 @@
 
 
 
 void receive_file_entry_v11(struct file_struct *file,
 			    unsigned char flags,int f)
 {
-  static mode_t last_time=0;
+  static time_t last_time=0;
   static mode_t last_mode=0;
   static dev_t last_rdev=0;
   static uid_t last_uid=0;
   static gid_t last_gid=0;
   static char lastname[MAXPATHLEN]="";
   int l1=0,l2=0;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5: foobar
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/io.c	1996-06-30 12:29:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/io.c	1996-07-03 14:24:58.000000000 +0800
@@ -126,37 +126,37 @@
 int read_int(int f)
 {
   int ret;
   char b[4];
   if ((ret=readfd(f,b,4)) != 4) {
     if (verbose > 1) 
-      fprintf(FERROR,"Error reading %d bytes : %s\n",
-	      4,ret==-1?strerror(errno):"EOF");
+      fprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
+	      getpid(),4,ret==-1?strerror(errno):"EOF");
     exit_cleanup(1);
   }
   total_read += 4;
   return IVAL(b,0);
 }
 
 void read_buf(int f,char *buf,int len)
 {
   int ret;
   if ((ret=readfd(f,buf,len)) != len) {
     if (verbose > 1) 
-      fprintf(FERROR,"Error reading %d bytes : %s\n",
-	      len,ret==-1?strerror(errno):"EOF");
+      fprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
+	      getpid(),len,ret==-1?strerror(errno):"EOF");
     exit_cleanup(1);
   }
   total_read += len;
 }
 
 unsigned char read_byte(int f)
 {
-  char c;
-  read_buf(f,&c,1);
-  return (unsigned char)c;
+  unsigned char c;
+  read_buf(f,(char *)&c,1);
+  return c;
 }
 
 
 static char last_byte=0;
 static int last_sparse = 0;
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/lib: zlib.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/lib: zlib.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/main.c	1996-06-30 12:29:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/main.c	1996-07-03 14:24:58.000000000 +0800
@@ -43,12 +43,14 @@
 int local_server=0;
 int ignore_times=0;
 int delete_mode=0;
 int one_file_system=0;
 int remote_version=0;
 int sparse_files=0;
+int do_compression=0;
+
 extern int csum_length;
 
 int am_server = 0;
 static int sender = 0;
 int recurse = 0;
 
@@ -88,13 +90,12 @@
 
 static void server_options(char **args,int *argc)
 {
   int ac = *argc;
   static char argstr[50];
   static char bsize[30];
-  static char slength[30];
   int i, x;
 
   args[ac++] = "--server";
 
   if (!sender)
     args[ac++] = "--sender";
@@ -132,26 +133,23 @@
   if (ignore_times)
     argstr[x++] = 'I';
   if (one_file_system)
     argstr[x++] = 'x';
   if (sparse_files)
     argstr[x++] = 'S';
+  if (do_compression)
+    argstr[x++] = 'z';
   argstr[x] = 0;
 
   if (x != 1) args[ac++] = argstr;
 
   if (block_size != BLOCK_SIZE) {
     sprintf(bsize,"-B%d",block_size);
     args[ac++] = bsize;
   }    
 
-  if (csum_length != SUM_LENGTH) {
-    sprintf(slength,"--csum-length=%d",csum_length);
-    args[ac++] = slength;
-  }    
-  
   if (delete_mode)
     args[ac++] = "--delete";
 
   *argc = ac;
 }
 
@@ -301,26 +299,33 @@
 
 
 static int do_recv(int f_in,int f_out,struct file_list *flist,char *local_name)
 {
   int pid;
   int status=0;
+  int recv_pipe[2];
 
   if (preserve_hard_links)
     init_hard_links(flist);
 
+  if (pipe(recv_pipe) < 0) {
+    fprintf(FERROR,"pipe failed in do_recv\n");
+    exit(1);
+  }
+  
+
   if ((pid=fork()) == 0) {
-    recv_files(f_in,flist,local_name);
+    recv_files(f_in,flist,local_name,recv_pipe[1]);
     if (preserve_hard_links)
       do_hard_links(flist);
     if (verbose > 2)
       fprintf(FERROR,"receiver read %d\n",read_total());
     exit_cleanup(0);
   }
 
-  generate_files(f_out,flist,local_name);
+  generate_files(f_out,flist,local_name,recv_pipe[0]);
 
   waitpid(pid, &status, 0);
 
   return status;
 }
 
@@ -393,37 +398,36 @@
   fprintf(f,"-B, --block-size SIZE    checksum blocking size\n");  
   fprintf(f,"-e, --rsh COMMAND        specify rsh replacement\n");
   fprintf(f,"    --rsync-path PATH    specify path to rsync on the remote machine\n");
   fprintf(f,"-C, --cvs-exclude        auto ignore files in the same way CVS does\n");
   fprintf(f,"    --delete             delete files that don't exist on the sending side\n");
   fprintf(f,"-I, --ignore-times       don't exclude files that match length and time\n");
+  fprintf(f,"-z, --compress           compress file data\n");
   fprintf(f,"    --exclude FILE       exclude file FILE\n");
   fprintf(f,"    --exclude-from FILE  exclude files listed in FILE\n");
   fprintf(f,"    --suffix SUFFIX      override backup suffix\n");  
-  fprintf(f,"    --csum-length LENGTH set the checksum length\n");  
   fprintf(f,"    --version            print version number\n");  
 
   fprintf(f,"\n");
   fprintf(f,"the backup suffix defaults to %s\n",BACKUP_SUFFIX);
   fprintf(f,"the block size defaults to %d\n",BLOCK_SIZE);  
 }
 
 enum {OPT_VERSION,OPT_SUFFIX,OPT_SENDER,OPT_SERVER,OPT_EXCLUDE,
-      OPT_EXCLUDE_FROM,OPT_DELETE,OPT_RSYNC_PATH,OPT_CSUM_LENGTH};
+      OPT_EXCLUDE_FROM,OPT_DELETE,OPT_RSYNC_PATH};
 
-static char *short_options = "oblHpguDCtcahvrIxnSe:B:";
+static char *short_options = "oblHpguDCtcahvrIxnSe:B:z";
 
 static struct option long_options[] = {
   {"version",     0,     0,    OPT_VERSION},
   {"server",      0,     0,    OPT_SERVER},
   {"sender",      0,     0,    OPT_SENDER},
   {"delete",      0,     0,    OPT_DELETE},
   {"exclude",     1,     0,    OPT_EXCLUDE},
   {"exclude-from",1,     0,    OPT_EXCLUDE_FROM},
   {"rsync-path",  1,     0,    OPT_RSYNC_PATH},
-  {"csum-length", 1,     0,    OPT_CSUM_LENGTH},
   {"one-file-system",0,  0,    'x'},
   {"ignore-times",0,     0,    'I'},
   {"help",        0,     0,    'h'},
   {"dry-run",     0,     0,    'n'},
   {"sparse",      0,     0,    'S'},
   {"cvs-exclude", 0,     0,    'C'},
@@ -440,12 +444,13 @@
   {"owner",       0,     0,    'o'},
   {"group",       0,     0,    'g'},
   {"times",       0,     0,    't'},
   {"rsh",         1,     0,    'e'},
   {"suffix",      1,     0,    OPT_SUFFIX},
   {"block-size",  1,     0,    'B'},
+  {"compress",	  0,	 0,    'z'},
   {0,0,0,0}};
 
 int main(int argc,char *argv[])
 {
     int pid, status, status2;
     int opt;
@@ -458,14 +463,12 @@
     int f_in,f_out;
     struct file_list *flist;
     char *local_name = NULL;
 
     starttime = time(NULL);
 
-    checksum_init();
-
     while ((opt = getopt_long(argc, argv, 
 			      short_options, long_options, &option_index)) 
 	   != -1) {
       switch (opt) 
 	{
 	case OPT_VERSION:
@@ -478,17 +481,12 @@
 	  break;
 
 	case OPT_RSYNC_PATH:
 	  rsync_path = optarg;
 	  break;
 
-	case OPT_CSUM_LENGTH:
-	  csum_length = atoi(optarg);
-	  csum_length = MIN(csum_length,SUM_LENGTH);
-	  break;
-
 	case 'I':
 	  ignore_times = 1;
 	  break;
 
 	case 'x':
 	  one_file_system=1;
@@ -615,14 +613,18 @@
 	  break;
 
 	case 'B':
 	  block_size = atoi(optarg);
 	  break;
 
+        case 'z':
+	  do_compression = 1;
+	  break;
+
 	default:
-	  fprintf(FERROR,"bad option -%c\n",opt);
+	  /* fprintf(FERROR,"bad option -%c\n",opt); */
 	  exit_cleanup(1);
 	}
     }
 
     while (optind--) {
       argc--;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/Makefile.in	1996-06-30 12:29:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/Makefile.in	1996-07-03 13:24:57.000000000 +0800
@@ -16,15 +16,15 @@
 SHELL=/bin/sh
 
 
 .SUFFIXES:
 .SUFFIXES: .c .o
 
-LIBOBJ=lib/getopt.o lib/fnmatch.o 
+LIBOBJ=lib/getopt.o lib/fnmatch.o lib/zlib.o
 OBJS1=rsync.o exclude.o util.o md4.o main.o checksum.o match.o 
-OBJS=$(OBJS1) flist.o io.o compat.o hlink.o $(LIBOBJ)
+OBJS=$(OBJS1) flist.o io.o compat.o hlink.o token.o $(LIBOBJ)
 
 .c.o:
 	$(CC) $(CFLAGS) -c $*.c -o $*.o
 
 all: rsync
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/match.c	1996-06-30 12:29:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/match.c	1996-07-02 11:14:03.000000000 +0800
@@ -21,12 +21,14 @@
 
 extern int csum_length;
 
 extern int verbose;
 extern int am_server;
 
+extern int remote_version;
+
 typedef unsigned short tag;
 
 #define TABLESIZE (1<<16)
 #define NULL_TAG ((tag)-1)
 
 static int false_alarms;
@@ -85,54 +87,82 @@
 }
 
 
 static off_t last_match;
 
 
-static void matched(int f,struct sum_struct *s,char *buf,off_t len,
+static void matched(int f,struct sum_struct *s,struct map_struct *buf,
+		    off_t len,
 		    int offset,int i)
 {
   int n = offset - last_match;
-  
+  int j;
+
   if (verbose > 2)
     if (i != -1)
       fprintf(FERROR,"match at %d last_match=%d j=%d len=%d n=%d\n",
 	      (int)offset,(int)last_match,i,(int)s->sums[i].len,n);
 
-  if (n > 0) {
-    int l = 0;
-    write_int(f,n);
-    while (l < n) {
-      int n1 = MIN(CHUNK_SIZE,n-l);
-      write_buf(f,map_ptr(buf,last_match+l,n1),n1);
-      l += n1;
-    }
-    data_transfer += n;
+  send_token(f,i,buf,last_match,n,i==-1?0:s->sums[i].len);
+  data_transfer += n;
+
+  if (n > 0)
+    write_flush(f);
+
+  if (i != -1)
+    n += s->sums[i].len;
+  
+  for (j=0;j<n;j+=CHUNK_SIZE) {
+    int n1 = MIN(CHUNK_SIZE,n-j);
+    sum_update(map_ptr(buf,last_match+j,n1),n1);
   }
-  write_int(f,-(i+1));
+
+
   if (i != -1)
     last_match = offset + s->sums[i].len;
-  if (n > 0)
-    write_flush(f);
+
+}
+
+
+static inline char *window_ptr(struct map_struct *buf,int off,int len)
+{
+  static char *p=NULL;
+  static int p_len = 0;
+  static int p_off = 0;  
+
+  if (off == 0) {
+    p_off = 0;
+    p_len = CHUNK_SIZE;
+    p = map_ptr(buf,p_off,p_len);    
+  }
+
+  while (off+len > p_off+p_len) {
+    p_off += CHUNK_SIZE;
+    p_len = CHUNK_SIZE;
+    p = map_ptr(buf,p_off,p_len);  
+  }
+
+  return(p + (off-p_off));
 }
 
 
-static void hash_search(int f,struct sum_struct *s,char *buf,off_t len)
+static void hash_search(int f,struct sum_struct *s,
+			struct map_struct *buf,off_t len)
 {
   int offset,j,k;
   int end;
   char sum2[SUM_LENGTH];
   uint32 s1, s2, sum; 
   char *map;
 
   if (verbose > 2)
     fprintf(FERROR,"hash search b=%d len=%d\n",s->n,(int)len);
 
   k = MIN(len, s->n);
 
-  map = map_ptr(buf,0,k);
+  map = window_ptr(buf,0,k);
 
   sum = get_checksum1(map, k);
   s1 = sum & 0xFFFF;
   s2 = sum >> 16;
   if (verbose > 3)
     fprintf(FERROR, "sum=%.8x k=%d\n", sum, k);
@@ -164,21 +194,21 @@
 	  if (verbose > 3)
 	    fprintf(FERROR,"potential match at %d target=%d %d sum=%08x\n",
 		    offset,j,i,sum);
 
 	  if (!done_csum2) {
 	    int l = MIN(s->n,len-offset);
-	    map = map_ptr(buf,offset,l);
+	    map = window_ptr(buf,offset,l);
 	    get_checksum2(map,l,sum2);
 	    done_csum2 = 1;
 	  }
 	  if (memcmp(sum2,s->sums[i].sum2,csum_length) == 0) {
 	    matched(f,s,buf,len,offset,i);
 	    offset += s->sums[i].len - 1;
 	    k = MIN((len-offset), s->n);
-	    map = map_ptr(buf,offset,k);
+	    map = window_ptr(buf,offset,k);
 	    sum = get_checksum1(map, k);
 	    s1 = sum & 0xFFFF;
 	    s2 = sum >> 16;
 	    ++matches;
 	    break;
 	  } else {
@@ -187,13 +217,13 @@
 	}
 	j++;
       } while (j<s->count && targets[j].t == t);
     }
 
     /* Trim off the first byte from the checksum */
-    map = map_ptr(buf,offset,k+1);
+    map = window_ptr(buf,offset,k+1);
     s1 -= map[0];
     s2 -= k * map[0];
 
     /* Add on the next byte (if there is one) to the checksum */
     if (k < (len-offset)) {
       s1 += map[k];
@@ -202,23 +232,28 @@
       --k;
     }
 
   } while (++offset < end);
 
   matched(f,s,buf,len,len,-1);
+  window_ptr(buf,len-1,1);
 }
 
 
-void match_sums(int f,struct sum_struct *s,char *buf,off_t len)
+void match_sums(int f,struct sum_struct *s,struct map_struct *buf,off_t len)
 {
+  char file_sum[SUM_LENGTH];
+
   last_match = 0;
   false_alarms = 0;
   tag_hits = 0;
   matches=0;
   data_transfer=0;
 
+  sum_init();
+
   if (len > 0 && s->count>0) {
     build_hash_table(s);
 
     if (verbose > 2) 
       fprintf(FERROR,"built hash table\n");
 
@@ -227,12 +262,20 @@
     if (verbose > 2) 
       fprintf(FERROR,"done hash search\n");
   } else {
     matched(f,s,buf,len,len,-1);
   }
 
+  sum_end(file_sum);
+
+  if (remote_version >= 14) {
+    if (verbose > 2)
+      fprintf(FERROR,"sending file_sum\n");
+    write_buf(f,file_sum,SUM_LENGTH);
+  }
+
   if (targets) {
     free(targets);
     targets=NULL;
   }
 
   if (verbose > 2)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/md4.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/md4.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/md4.c	1996-06-15 14:59:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/md4.c	1996-07-03 16:19:02.000000000 +0800
@@ -210,13 +210,13 @@
    /* return with no error if this is a courtesy close with count
    ** zero and MDp->done is true.
    */
    if (count == 0 && MDp->done) return;
    /* check to see if MD is already done and report error */
    if (MDp->done)
-          { printf("\nError: MDupdate MD already done."); return; }
+          { fprintf(FERROR,"\nError: MDupdate MD already done."); return; }
    /* Add count to MDp->count */
    tmp = count;
    p = MDp->count;
    while (tmp)
      { tmp += *p;
        *p++ = tmp;
@@ -225,13 +225,13 @@
    /* Process data */
    if (count == 512)
      { /* Full block of data to handle */
        MDblock(MDp,(unsigned int *)X);
      }
    else if (count > 512) /* Check for count too large */
-     { printf("\nError: MDupdate called with illegal count value %d."
+     { fprintf(FERROR,"\nError: MDupdate called with illegal count value %d."
               ,count);
        return;
      }
    else /* partial block -- must be last block so finish up */
      { /* Find out how many bytes and residual bits there are */
        byte = count >> 3;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/proto.h	1996-06-30 12:29:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/proto.h	1996-07-03 13:24:58.000000000 +0800
@@ -1,12 +1,15 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
 uint32 get_checksum1(char *buf,int len);
 void get_checksum2(char *buf,int len,char *sum);
 void file_checksum(char *fname,char *sum,off_t size);
 void checksum_init(void);
+void sum_init(void);
+void sum_update(char *p,int len);
+void sum_end(char *sum);
 void send_file_entry_v10(struct file_struct *file,int f);
 void receive_file_entry_v10(struct file_struct *file,
 			    unsigned char flags,int f);
 void setup_protocol(int f_out,int f_in);
 int check_exclude(char *name,char **local_exclude_list);
 void add_exclude_list(char *pattern,char ***list);
@@ -41,22 +44,26 @@
 void write_byte(int f,unsigned char c);
 void write_flush(int f);
 int do_cmd(char *cmd,char *machine,char *user,char *path,int *f_in,int *f_out);
 void do_server_sender(int argc,char *argv[]);
 void do_server_recv(int argc,char *argv[]);
 int main(int argc,char *argv[]);
-void match_sums(int f,struct sum_struct *s,char *buf,off_t len);
+void match_sums(int f,struct sum_struct *s,struct map_struct *buf,off_t len);
 void match_report(void);
 void recv_generator(char *fname,struct file_list *flist,int i,int f_out);
 void exit_cleanup(int code);
 void sig_int(void);
-int recv_files(int f_in,struct file_list *flist,char *local_name);
+int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen);
 off_t send_files(struct file_list *flist,int f_out,int f_in);
-void generate_files(int f,struct file_list *flist,char *local_name);
+void generate_files(int f,struct file_list *flist,char *local_name,int f_recv);
+void send_token(int f,int token,struct map_struct *buf,int offset,
+		int n,int toklen);
+int recv_token(int f,char **data);
+void see_token(char *data, int toklen);
 int num_waiting(int fd);
-char *map_file(int fd,off_t len);
-char *map_ptr(char *buf,off_t offset,int len);
-void unmap_file(char *buf,off_t len);
+struct map_struct *map_file(int fd,off_t len);
+char *map_ptr(struct map_struct *map,off_t offset,int len);
+void unmap_file(struct map_struct *map);
 int piped_child(char **command,int *f_in,int *f_out);
 void out_of_memory(char *str);
 int set_modtime(char *fname,time_t modtime);
 int set_blocking(int fd, int set);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/README	1996-06-30 12:29:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/README	1996-07-03 14:24:58.000000000 +0800
@@ -9,13 +9,13 @@
 sets of files are present at one of the ends of the link beforehand.
 At first glance this may seem impossible because the calculation of
 diffs between two files normally requires local access to both
 files. 
 
 A technical report describing the rsync algorithm is included with
-this package.
+this package. 
 
 
 USAGE
 -----
 
 Basically you use rsync just like rcp, but rsync has many additional options.
@@ -41,27 +41,27 @@
 -B, --block-size SIZE    checksum blocking size
 -e, --rsh COMMAND        specify rsh replacement
     --rsync-path PATH    specify path to rsync on the remote machine
 -C, --cvs-exclude        auto ignore files in the same way CVS does
     --delete             delete files that don't exist on the sending side
 -I, --ignore-times       don't exclude files that match length and time
+-z, --compress           compress file data
     --exclude FILE       exclude file FILE
     --exclude-from FILE  exclude files listed in FILE
     --suffix SUFFIX      override backup suffix
-    --csum-length LENGTH set the checksum length
     --version            print version number
 
 
 SETUP
 -----
 
 Rsync uses rsh or ssh for communication. It does not need to be setuid
 and requires no special privilages for installation. It does not
 require a inetd entry or a daemon. You must, however, have a working
-rsh or ssh system. Using ssh is recommended for its security and
-compression features.
+rsh or ssh system. Using ssh is recommended for its security
+features. 
 
 To install rsync, first run the "configure" script. This will create a
 Makefile and config.h appropriate for your system. Then type
 "make". 
 
 Once built put a copy of rsync in your search path on the local and
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/rsync.1	1996-06-30 12:29:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/rsync.1	1996-07-03 15:52:13.000000000 +0800
@@ -1,7 +1,7 @@
-.TH RSYNC 1 27/6/1996 rsync rsync
+.TH RSYNC 1 3/7/1996 rsync rsync
 .SH NAME
 rsync \- faster, flexible replacement for rcp
 .SH SYNOPSIS
    rsync [options] [user@]host:path path
 
 OR
@@ -43,13 +43,13 @@
 
 You can also specify a alternative to rsh, by either using the -e
 command line option, or by setting the RSYNC_RSH environment
 variable. 
 
 One common substitute is to use ssh, which offers a high degree of
-security, as well as good compression.
+security.
 
 .SH USAGE
 
 You use rsync in the same way you use rcp. You must specify a source
 and a destination, one of which must be remote. 
 
@@ -61,24 +61,58 @@
 this would transfer all files matching the pattern *.c from the
 current directory to the directory src on the machine foo. If any of
 the files already exist on the remote system then the rsync
 remote-update protocol is used to update the file by sending only the
 differences. See the tech report for details.
 
-	rsync -av foo:src/bar /data/tmp
+	rsync -avz foo:src/bar /data/tmp
 
 recursively transfer all files from the directory src/bar on the
 machine foo into the /data/tmp/bar directory on the local machine. The
 files are transferred in "archive" mode, which ensures that symbolic
 links, devices, attributes, permissions, ownerships etc are preserved
-in the transfer.
+in the transfer. Additionally compression will be used to reduce the
+size of data portions of the transfer.
 
 You can also use rsync in local-only mode, where both the source and
 destination don't have a ':' in the name. In this case it behaves like
 an improved copy command.
 
+.SH EXAMPLES
+
+Here are some examples of how I use rsync.
+
+To backup my wifes home directory, which consists of large MS
+word files and mail folders I use a cron job that runs 
+
+        rsync -Cavz . arvidsjaur:backup
+
+each night over a PPP link to a duplicate directory on my machine
+"arvidsjaur". 
+
+To synchronise my samba source trees I use the following Makefile
+targets:
+
+      get:
+       rsync -avuzb --exclude '*~' samba:samba/ .
+
+      put:
+       rsync -Cavuzb . samba:samba/
+
+      sync: get put
+
+this allows me to sync with a CVS directory at the other end of the
+link. I then do cvs operations on the remote machine, which saves a
+lot of time as the remote cvs protocol isn't very efficient.
+
+I mirror a directory between my "old" and "new" ftp sites with the command
+
+      rsync -az -e ssh --delete ~ftp/pub/samba/ nimbus:"~ftp/pub/tridge/samba" 
+
+this is launched from cron every few hours.
+
 .SH OPTIONS
 
 rsync uses the GNU long options package. Many of the command line
 options have two varients, one short and one long. These are shown
 below separated by commas. Some options only have a long varient.
 
@@ -210,18 +244,36 @@
 
 .B --delete
 .RS 3
 This tells rsync to delete any files on the receiving side that aren't
 on the sending side. This option can be dangerous if used incorrectly!
 
-It may be a good idea to run first using the dry run option to see
-what files would be deleted to make sure important files aren't
+It is a very good idea to run first using the dry run option (-n) to
+see what files would be deleted to make sure important files aren't
 listed.
 
-NOTE: It also may delete files if the sending side can't open them or stat
-them. This is a bug that hopefully will be fixed in a future release.
+For example, one user was burnt by the following command:
+
+  rsync -av --delete /usr/src remote:/tmp
+
+rsync happily transferred the contents of /usr/src to /tmp/src on the
+destination then deleted everything else in /tmp. Nasty! It would have
+been even nastier if he had used his home directory instead of /tmp.
+
+The correct way to achieve what this user probably wanted is this:
+
+  rsync -av --delete /usr/src/ remote:/tmp/src
+
+in this case the deletions only occur inside the tree /tmp/src.
+
+The moral of the story is to use the -n option until you get used to
+the behaviour of --delete.
+
+NOTE: It also may delete files on the destination if the sending side
+can't open them or stat them. This is a bug that hopefully will be
+fixed in a future release.
 .RE
 
 .B -B , --block_size BLOCKSIZE
 .RS 3
 This controls the block size used in the rsync algorithm. See the
 technical report for details.
@@ -229,13 +281,13 @@
 
 .B -e, --rsh COMMAND
 .RS 3
 This option allows you to choose an alternative remote shell program
 to use for communication between the local and remote copies of
 rsync. By default rsync will use rsh, but you may like to instead use
-ssh because of its high security and compression.
+ssh because of its high security.
 
 You can also choose the remote shell program using the RSYNC_RSH
 environment variable.
 .RE
 
 .B -e, --rsync-path PATH
@@ -308,12 +360,25 @@
 Note that if you use this option then you run the risk of ending up
 with a incorrect target file. The risk with a value of 16 is
 microscopic and can be safely ignored (the universe will probably end
 before it fails) but with smaller values the risk is higher.
 .RE
 
+.B -z, --compress
+.RS 3
+With this option, rsync compresses any data from the source file(s)
+which it sends to the destination machine.  This option is useful on
+slow links.  The compression method used is the same method that gzip
+uses.
+
+Note this this option typically achieves better compression ratios
+that can be achieved by using a compressing remote shell, or a
+compressing transport, as it takes advantage of the implicit
+information sent for matching data blocks.
+.RE
+
 .SH BUGS
 
 user ids and group ids are transferred using their numerical value
 
 times are transferred as unix time_t values
 
@@ -321,26 +386,29 @@
 values
 
 see also the comments on the -delete option 
 
 .SH VERSION
 
-This man page is current for version 1.4 of rsync
+This man page is current for version 1.5 of rsync
 
 .SH CREDITS
 
 rsync was written by Andrew Tridgell and Paul Mackerras. They may be
 contacted via email at Andrew.Tridgell@anu.edu.au and
-paulus@cs.anu.edu.au
+Paul.Mackerras@cs.anu.edu.au
 
 rsync is distributed under the GNU public license. See the file
 COPYING for details.
 
-The primary ftp site for rsync is ftp://samba.anu.edu.au/pub/rsync
+The primary ftp site for rsync is ftp://samba.anu.edu.au/pub/rsync.
 
 We would be delighted to hear from you if you like this program.
 
+This program uses the zlib compression library written by Jean-loup
+Gailly and Mark Adler.
+
 .SH THANKS
 
 Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
 and David Bell for helpful suggestions and testing of rsync. I've
 proabably missed some people, my apologies if I have.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/rsync.c	1996-06-30 12:29:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/rsync.c	1996-07-03 13:24:58.000000000 +0800
@@ -23,12 +23,14 @@
 
 extern int verbose;
 extern int am_server;
 extern int always_checksum;
 extern time_t starttime;
 
+extern int remote_version;
+
 extern char *backup_suffix;
 
 extern int block_size;
 extern int update_only;
 extern int make_backups;
 extern int preserve_links;
@@ -78,13 +80,13 @@
 
 /*
   generate a stream of signatures/checksums that describe a buffer
 
   generate approximately one checksum every n bytes
   */
-static struct sum_struct *generate_sums(char *buf,off_t len,int n)
+static struct sum_struct *generate_sums(struct map_struct *buf,off_t len,int n)
 {
   int i;
   struct sum_struct *s;
   int count;
   int block_len = n;
   int remainder = (len%block_len);
@@ -250,20 +252,20 @@
 
 
 void recv_generator(char *fname,struct file_list *flist,int i,int f_out)
 {  
   int fd;
   struct stat st;
-  char *buf;
+  struct map_struct *buf;
   struct sum_struct *s;
   char sum[SUM_LENGTH];
   int statret;
   struct file_struct *file = &flist->files[i];
 
   if (verbose > 2)
-    fprintf(FERROR,"recv_generator(%s)\n",fname);
+    fprintf(FERROR,"recv_generator(%s,%d)\n",fname,i);
 
   statret = lstat(fname,&st);
 
 #if SUPPORT_LINKS
   if (preserve_links && S_ISLNK(file->mode)) {
     char lnk[MAXPATHLEN];
@@ -378,44 +380,55 @@
     buf = map_file(fd,st.st_size);
   } else {
     buf = NULL;
   }
 
   if (verbose > 3)
-    fprintf(FERROR,"mapped %s of size %d\n",fname,(int)st.st_size);
+    fprintf(FERROR,"gen mapped %s of size %d\n",fname,(int)st.st_size);
 
   s = generate_sums(buf,st.st_size,block_size);
 
+  if (verbose > 2)
+    fprintf(FERROR,"sending sums for %d\n",i);
+
   write_int(f_out,i);
   send_sums(s,f_out);
   write_flush(f_out);
 
   close(fd);
-  unmap_file(buf,st.st_size);
+  if (buf) unmap_file(buf);
 
   free_sums(s);
 }
 
 
 
-static void receive_data(int f_in,char *buf,int fd,char *fname)
+static int receive_data(int f_in,struct map_struct *buf,int fd,char *fname)
 {
   int i,n,remainder,len,count;
   off_t offset = 0;
   off_t offset2;
+  char *data;
+  static char file_sum1[SUM_LENGTH];
+  static char file_sum2[SUM_LENGTH];
+  char *map=NULL;
 
   count = read_int(f_in);
   n = read_int(f_in);
   remainder = read_int(f_in);
 
-  for (i=read_int(f_in); i != 0; i=read_int(f_in)) {
+  sum_init();
+
+  for (i=recv_token(f_in,&data); i != 0; i=recv_token(f_in,&data)) {
     if (i > 0) {
       if (verbose > 3)
 	fprintf(FERROR,"data recv %d at %d\n",i,(int)offset);
 
-      if (read_write(f_in,fd,i) != i) {
+      sum_update(data,i);
+
+      if (write_sparse(fd,data,i) != i) {
 	fprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
 	exit_cleanup(1);
       }
       offset += i;
     } else {
       i = -(i+1);
@@ -425,24 +438,40 @@
 	len = remainder;
 
       if (verbose > 3)
 	fprintf(FERROR,"chunk[%d] of size %d at %d offset=%d\n",
 		i,len,(int)offset2,(int)offset);
 
-      if (write_sparse(fd,map_ptr(buf,offset2,len),len) != len) {
+      map = map_ptr(buf,offset2,len);
+
+      see_token(map, len);
+      sum_update(map,len);
+
+      if (write_sparse(fd,map,len) != len) {
 	fprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
 	exit_cleanup(1);
       }
       offset += len;
     }
   }
 
   if (offset > 0 && sparse_end(fd) != 0) {
     fprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
     exit_cleanup(1);
   }
+
+  sum_end(file_sum1);
+
+  if (remote_version >= 14) {
+    read_buf(f_in,file_sum2,SUM_LENGTH);
+    if (verbose > 2)
+      fprintf(FERROR,"got file_sum\n");
+    if (memcmp(file_sum1,file_sum2,SUM_LENGTH) != 0)
+      return 0;
+  }
+  return 1;
 }
 
 
 static void delete_one(struct file_struct *f)
 {
   if (!S_ISDIR(f->mode)) {
@@ -494,34 +523,47 @@
 void sig_int(void)
 {
   exit_cleanup(1);
 }
 
 
-int recv_files(int f_in,struct file_list *flist,char *local_name)
+int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen)
 {  
   int fd1,fd2;
   struct stat st;
   char *fname;
   char fnametmp[MAXPATHLEN];
-  char *buf;
+  struct map_struct *buf;
   int i;
   struct file_struct *file;
+  int phase=0;
+  int recv_ok;
 
   if (verbose > 2) {
     fprintf(FERROR,"recv_files(%d) starting\n",flist->count);
   }
 
   if (recurse && delete_mode && !local_name && flist->count>0) {
     delete_files(flist);
   }
 
   while (1) 
-    {
+    {      
       i = read_int(f_in);
-      if (i == -1) break;
+      if (i == -1) {
+	if (phase==0 && remote_version >= 13) {
+	  phase++;
+	  csum_length = SUM_LENGTH;
+	  if (verbose > 2)
+	    fprintf(FERROR,"recv_files phase=%d\n",phase);
+	  write_int(f_gen,-1);
+	  write_flush(f_gen);
+	  continue;
+	}
+	break;
+      }
 
       file = &flist->files[i];
       fname = file->name;
 
       if (local_name)
 	fname = local_name;
@@ -549,19 +591,18 @@
 	close(fd1);
 	return -1;
       }
 
       if (fd1 != -1 && st.st_size > 0) {
 	buf = map_file(fd1,st.st_size);
+	if (verbose > 2)
+	  fprintf(FERROR,"recv mapped %s of size %d\n",fname,(int)st.st_size);
       } else {
 	buf = NULL;
       }
 
-      if (verbose > 2)
-	fprintf(FERROR,"mapped %s of size %d\n",fname,(int)st.st_size);
-
       /* open tmp file */
       sprintf(fnametmp,"%s.XXXXXX",fname);
       if (NULL == mktemp(fnametmp)) {
 	fprintf(FERROR,"mktemp %s failed\n",fnametmp);
 	return -1;
       }
@@ -574,16 +615,16 @@
       cleanup_fname = fnametmp;
 
       if (!am_server && verbose)
 	printf("%s\n",fname);
 
       /* recv file data */
-      receive_data(f_in,buf,fd2,fname);
+      recv_ok = receive_data(f_in,buf,fd2,fname);
 
       if (fd1 != -1) {
-	unmap_file(buf,st.st_size);
+	if (buf) unmap_file(buf);
 	close(fd1);
       }
       close(fd2);
 
       if (verbose > 2)
 	fprintf(FERROR,"renaming %s to %s\n",fnametmp,fname);
@@ -603,12 +644,18 @@
 		fnametmp,fname,strerror(errno));
       }
 
       cleanup_fname = NULL;
 
       set_perms(fname,file,NULL,0);
+
+      if (!recv_ok) {
+	if (verbose > 1)
+	  fprintf(FERROR,"redoing %s(%d)\n",fname,i);
+	write_int(f_gen,i);
+      }
     }
 
   if (verbose > 2)
     fprintf(FERROR,"recv_files finished\n");
   
   return 0;
@@ -617,28 +664,40 @@
 
 
 off_t send_files(struct file_list *flist,int f_out,int f_in)
 { 
   int fd;
   struct sum_struct *s;
-  char *buf;
+  struct map_struct *buf;
   struct stat st;
   char fname[MAXPATHLEN];  
   off_t total=0;
   int i;
   struct file_struct *file;
+  int phase = 0;
 
   if (verbose > 2)
     fprintf(FERROR,"send_files starting\n");
 
   setup_nonblocking(f_in,f_out);
 
   while (1) 
     {
       i = read_int(f_in);
-      if (i == -1) break;
+      if (i == -1) {
+	if (phase==0 && remote_version >= 13) {
+	  phase++;
+	  csum_length = SUM_LENGTH;
+	  write_int(f_out,-1);
+	  write_flush(f_out);
+	  if (verbose > 2)
+	    fprintf(FERROR,"send_files phase=%d\n",phase);
+	  continue;
+	}
+	break;
+      }
 
       file = &flist->files[i];
 
       fname[0] = 0;
       if (file->dir) {
 	strcpy(fname,file->dir);
@@ -697,13 +756,13 @@
       if (!am_server && verbose)
 	printf("%s\n",fname);
       
       match_sums(f_out,s,buf,st.st_size);
       write_flush(f_out);
       
-      unmap_file(buf,st.st_size);
+      if (buf) unmap_file(buf);
       close(fd);
 
       free_sums(s);
 
       if (verbose > 2)
 	fprintf(FERROR,"sender finished %s\n",fname);
@@ -721,15 +780,16 @@
 
   return total;
 }
 
 
 
-void generate_files(int f,struct file_list *flist,char *local_name)
+void generate_files(int f,struct file_list *flist,char *local_name,int f_recv)
 {
   int i;
+  int phase=0;
 
   if (verbose > 2)
     fprintf(FERROR,"generator starting pid=%d count=%d\n",
 	    (int)getpid(),flist->count);
 
   for (i = 0; i < flist->count; i++) {
@@ -744,13 +804,38 @@
       }
       continue;
     }
     recv_generator(local_name?local_name:file->name,
 		   flist,i,f);
   }
+
+  phase++;
+  csum_length = SUM_LENGTH;
+  ignore_times=1;
+
+  if (verbose > 2)
+    fprintf(FERROR,"generate_files phase=%d\n",phase);
+
   write_int(f,-1);
   write_flush(f);
+
+  if (remote_version >= 13) {
+    for (i=read_int(f_recv); i != -1; i=read_int(f_recv)) {
+      struct file_struct *file = &flist->files[i];
+      recv_generator(local_name?local_name:file->name,
+		     flist,i,f);    
+    }
+
+    phase++;
+    if (verbose > 2)
+      fprintf(FERROR,"generate_files phase=%d\n",phase);
+
+    write_int(f,-1);
+    write_flush(f);
+  }
+
+
   if (verbose > 2)
     fprintf(FERROR,"generator wrote %d\n",write_total());
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/rsync.h	1996-06-30 12:52:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/rsync.h	1996-07-02 09:28:58.000000000 +0800
@@ -31,13 +31,13 @@
 #define SAME_DIR (1<<5)
 #define SAME_NAME SAME_DIR
 #define LONG_NAME (1<<6)
 #define SAME_TIME (1<<7)
 
 /* update this if you make incompatible changes */
-#define PROTOCOL_VERSION 12
+#define PROTOCOL_VERSION 14
 #define MIN_PROTOCOL_VERSION 10
 #define MAX_PROTOCOL_VERSION 20
 
 #define SPARSE_WRITE_SIZE (4*1024)
 #define WRITE_SIZE (32*1024)
 #define CHUNK_SIZE (32*1024)
@@ -210,12 +210,16 @@
   int count;			/* how many chunks */
   int remainder;		/* flength % block_length */
   int n;			/* block_length */
   struct sum_buf *sums;		/* points to info for each chunk */
 };
 
+struct map_struct {
+  char *map,*p;
+  int fd,size,p_size,p_offset,p_len;
+};
 
 #include "byteorder.h"
 #include "version.h"
 #include "proto.h"
 #include "md4.h"
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5: token.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/util.c	1996-06-30 12:29:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/util.c	1996-07-02 08:09:07.000000000 +0800
@@ -28,79 +28,80 @@
 {
   int len=0;
   ioctl(fd,FIONREAD,&len);
   return(len);
 }
 
-static int map_fd = -1;
-static off_t map_size = 0;
-static char *p = NULL;
-static int p_size = 0;
-static int p_offset = 0;
-static int p_len = 0;
 
-
-char *map_file(int fd,off_t len)
+struct map_struct *map_file(int fd,off_t len)
 {
-  char *ret = NULL;
+  struct map_struct *ret;
+  ret = (struct map_struct *)malloc(sizeof(*ret));
+  if (!ret) out_of_memory("map_file");
+
+  ret->map = NULL;
+  ret->fd = fd;
+  ret->size = len;
+  ret->p = NULL;
+  ret->p_size = 0;
+  ret->p_offset = 0;
+  ret->p_len = 0;
+
 #ifdef HAVE_MMAP
   if (len < MAX_MAP_SIZE)
-    ret = (char *)mmap(NULL,len,PROT_READ,MAP_SHARED,fd,0);
+    ret->map = (char *)mmap(NULL,len,PROT_READ,MAP_SHARED,fd,0);
 #endif
-  map_fd = fd;
-  map_size = len; 
   return ret;
 }
 
-char *map_ptr(char *buf,off_t offset,int len)
+char *map_ptr(struct map_struct *map,off_t offset,int len)
 {
-  if (buf)
-    return buf+offset;
+  if (map->map)
+    return map->map+offset;
 
   if (len == 0) 
     return NULL;
 
-  len = MIN(len,map_size-offset);
+  len = MIN(len,map->size-offset);
 
-  if (offset >= p_offset && 
-      offset+len <= p_offset+p_len) {
-    return (p + (offset - p_offset));
+  if (offset >= map->p_offset && 
+      offset+len <= map->p_offset+map->p_len) {
+    return (map->p + (offset - map->p_offset));
   }
 
   len = MAX(len,CHUNK_SIZE);
-  len = MIN(len,map_size - offset);  
+  len = MIN(len,map->size - offset);  
 
-  if (len > p_size) {
-    if (p) free(p);
-    p = (char *)malloc(len);
-    if (!p) out_of_memory("map_ptr");
-    p_size = len;
+  if (len > map->p_size) {
+    if (map->p) free(map->p);
+    map->p = (char *)malloc(len);
+    if (!map->p) out_of_memory("map_ptr");
+    map->p_size = len;
   }
 
-  if (lseek(map_fd,offset,SEEK_SET) != offset ||
-      read(map_fd,p,len) != len) {
+  if (lseek(map->fd,offset,SEEK_SET) != offset ||
+      read(map->fd,map->p,len) != len) {
     fprintf(FERROR,"EOF in map_ptr!\n");
     exit_cleanup(1);
   }
 
-  p_offset = offset;
-  p_len = len;
+  map->p_offset = offset;
+  map->p_len = len;
 
-  return p; 
+  return map->p; 
 }
 
 
-void unmap_file(char *buf,off_t len)
+void unmap_file(struct map_struct *map)
 {
 #ifdef HAVE_MMAP
-  if (len > 0 && buf)
-    munmap(buf,len);
+  if (map->map)
+    munmap(map->map,map->size);
 #endif
-  map_fd = -1;
-  map_size = 0;
-  p_len = 0;
+  if (map->p) free(map->p);
+  free(map);
 }
 
 
 /* this is taken from CVS */
 int piped_child(char **command,int *f_in,int *f_out)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.4.5/version.h	1996-06-30 12:30:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.5/version.h	1996-07-03 14:24:59.000000000 +0800
@@ -1 +1 @@
-#define VERSION "1.4.5"
+#define VERSION "1.5.0"
