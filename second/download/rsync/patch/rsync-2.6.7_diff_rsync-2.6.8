diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/clientserver.c	2006-02-24 09:56:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/clientserver.c	2006-04-11 08:28:02.000000000 +0800
@@ -725,25 +725,27 @@
 /* this is called when a connection is established to a client
    and we want to start talking. The setup of the system is done from
    here */
 int start_daemon(int f_in, int f_out)
 {
 	char line[1024];
-	char *motd;
-	char *addr = client_addr(f_in);
-	char *host = client_name(f_in);
+	char *motd, *addr, *host;
 	int i;
 
-	rprintf(FLOG, "connect from %s (%s)\n", host, addr);
-
 	io_set_sock_fds(f_in, f_out);
 
+	/* We must load the config file before calling any function that
+	 * might cause log-file output to occur.  This ensures that the
+	 * "log file" param gets honored for the 2 non-forked use-cases
+	 * (when rsync is run by init and run by a remote shell). */
 	if (!lp_load(config_file, 0))
 		exit_cleanup(RERR_SYNTAX);
 
-	log_init();
+	addr = client_addr(f_in);
+	host = client_name(f_in);
+	rprintf(FLOG, "connect from %s (%s)\n", host, addr);
 
 	if (!am_server) {
 		set_socket_options(f_in, "SO_KEEPALIVE");
 		if (sockopts)
 			set_socket_options(f_in, sockopts);
 		else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/config.h.in	2006-03-12 02:25:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/config.h.in	2006-04-18 01:54:00.000000000 +0800
@@ -1,8 +1,14 @@
 /* config.h.in.  Generated from configure.in by autoheader.  */
 
+/* Define to 1 if link() can hard-link special files. */
+#undef CAN_HARDLINK_SPECIAL
+
+/* Define to 1 if link() can hard-link symlinks. */
+#undef CAN_HARDLINK_SYMLINK
+
 /* Define to 1 if chown modifies symlinks. */
 #undef CHOWN_MODIFIES_SYMLINK
 
 /* Undefine if you don't want locale features. By default this is defined. */
 #undef CONFIG_LOCALE
 
@@ -436,18 +442,12 @@
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
-/* Define to 1 if inet_aton() needs to be replaced */
-#undef REPLACE_INET_ATON
-
-/* Define to 1 if inet_ntoa() needs to be replaced */
-#undef REPLACE_INET_NTOA
-
 /* Define as the return type of signal handlers (`int' or `void'). */
 #undef RETSIGTYPE
 
 /* location of configuration file for rsync server */
 #undef RSYNCD_SYSCONF
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/configure	2006-03-12 02:25:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/configure	2006-04-22 23:38:34.000000000 +0800
@@ -1311,13 +1311,13 @@
 
 
           ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=2.6.7
+RSYNC_VERSION=2.6.8
 
 { echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
 echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -11234,21 +11234,20 @@
 _ACEOF
 
 fi
 
 fi
 
-# Determine whether chown follows symlinks (it should).
-echo "$as_me:$LINENO: checking whether chown() dereferences symlinks" >&5
-echo $ECHO_N "checking whether chown() dereferences symlinks... $ECHO_C" >&6
-if test "${rsync_cv_chown_follows_symlink+set}" = set; then
+echo "$as_me:$LINENO: checking whether chown() modifies symlinks" >&5
+echo $ECHO_N "checking whether chown() modifies symlinks... $ECHO_C" >&6
+if test "${rsync_cv_chown_modifies_symlink+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
   if test "$cross_compiling" = yes; then
-  rsync_cv_chown_follows_symlink=yes
+  rsync_cv_chown_modifies_symlink=no
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
@@ -11260,14 +11259,14 @@
 #include <stdlib.h>
 #include <errno.h>
     main() {
 	char const *dangling_symlink = "conftest.dangle";
 	unlink(dangling_symlink);
 	if (symlink("conftest.no-such", dangling_symlink) < 0) abort();
-	if (chown(dangling_symlink, getuid(), getgid()) < 0 && errno == ENOENT) exit(0);
-	exit(1);
+	if (chown(dangling_symlink, getuid(), getgid()) < 0 && errno == ENOENT) exit(1);
+	exit(0);
     }
 _ACEOF
 rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
@@ -11275,34 +11274,158 @@
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  rsync_cv_chown_follows_symlink=yes
+  rsync_cv_chown_modifies_symlink=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-rsync_cv_chown_follows_symlink=no
+rsync_cv_chown_modifies_symlink=no
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
-echo "$as_me:$LINENO: result: $rsync_cv_chown_follows_symlink" >&5
-echo "${ECHO_T}$rsync_cv_chown_follows_symlink" >&6
-if test $rsync_cv_chown_follows_symlink = no; then
+echo "$as_me:$LINENO: result: $rsync_cv_chown_modifies_symlink" >&5
+echo "${ECHO_T}$rsync_cv_chown_modifies_symlink" >&6
+if test $rsync_cv_chown_modifies_symlink = yes; then
 
 cat >>confdefs.h <<\_ACEOF
 #define CHOWN_MODIFIES_SYMLINK 1
 _ACEOF
 
 fi
 
+echo "$as_me:$LINENO: checking whether link() can hard-link symlinks" >&5
+echo $ECHO_N "checking whether link() can hard-link symlinks... $ECHO_C" >&6
+if test "${rsync_cv_can_hardlink_symlink+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+  if test "$cross_compiling" = yes; then
+  rsync_cv_can_hardlink_symlink=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#include <stdlib.h>
+#include <errno.h>
+#define FILENAME "conftest.dangle"
+    main() {
+	unlink(FILENAME);
+	if (symlink("conftest.no-such", FILENAME) < 0) abort();
+	if (link(FILENAME, FILENAME "2") < 0) exit(1);
+	exit(0);
+    }
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  rsync_cv_can_hardlink_symlink=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+rsync_cv_can_hardlink_symlink=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $rsync_cv_can_hardlink_symlink" >&5
+echo "${ECHO_T}$rsync_cv_can_hardlink_symlink" >&6
+if test $rsync_cv_can_hardlink_symlink = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define CAN_HARDLINK_SYMLINK 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking whether link() can hard-link special files" >&5
+echo $ECHO_N "checking whether link() can hard-link special files... $ECHO_C" >&6
+if test "${rsync_cv_can_hardlink_special+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+  if test "$cross_compiling" = yes; then
+  rsync_cv_can_hardlink_special=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#include <stdlib.h>
+#include <errno.h>
+#define FILENAME "conftest.fifi"
+    main() {
+	unlink(FILENAME);
+	if (mkfifo(FILENAME, 0777) < 0) abort();
+	if (link(FILENAME, FILENAME "2") < 0) exit(1);
+	exit(0);
+    }
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  rsync_cv_can_hardlink_special=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+rsync_cv_can_hardlink_special=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $rsync_cv_can_hardlink_special" >&5
+echo "${ECHO_T}$rsync_cv_can_hardlink_special" >&6
+if test $rsync_cv_can_hardlink_special = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define CAN_HARDLINK_SPECIAL 1
+_ACEOF
+
+fi
+
 echo "$as_me:$LINENO: checking for working socketpair" >&5
 echo $ECHO_N "checking for working socketpair... $ECHO_C" >&6
 if test "${rsync_cv_HAVE_SOCKETPAIR+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
@@ -11831,127 +11954,12 @@
 
 	;;
     esac
 fi
 
 
-echo "$as_me:$LINENO: checking for broken inet_ntoa" >&5
-echo $ECHO_N "checking for broken inet_ntoa... $ECHO_C" >&6
-if test "${rsync_cv_REPLACE_INET_NTOA+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_REPLACE_INET_NTOA=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-main() { struct in_addr ip; ip.s_addr = 0x12345678;
-if (strcmp(inet_ntoa(ip),"18.52.86.120") &&
-    strcmp(inet_ntoa(ip),"120.86.52.18")) { exit(1); }
-exit(0);}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_REPLACE_INET_NTOA=no
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_REPLACE_INET_NTOA=yes
-fi
-rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
-echo "$as_me:$LINENO: result: $rsync_cv_REPLACE_INET_NTOA" >&5
-echo "${ECHO_T}$rsync_cv_REPLACE_INET_NTOA" >&6
-if test x"$rsync_cv_REPLACE_INET_NTOA" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define REPLACE_INET_NTOA 1
-_ACEOF
-
-fi
-
-
-echo "$as_me:$LINENO: checking for broken inet_aton" >&5
-echo $ECHO_N "checking for broken inet_aton... $ECHO_C" >&6
-if test "${rsync_cv_REPLACE_INET_ATON+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_REPLACE_INET_ATON=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <stdio.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-main() { struct in_addr ip;
-if (inet_aton("example", &ip) == 0) exit(0); exit(1);}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_REPLACE_INET_ATON=no
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_REPLACE_INET_ATON=yes
-fi
-rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
-echo "$as_me:$LINENO: result: $rsync_cv_REPLACE_INET_ATON" >&5
-echo "${ECHO_T}$rsync_cv_REPLACE_INET_ATON" >&6
-if test x"$rsync_cv_REPLACE_INET_ATON" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define REPLACE_INET_ATON 1
-_ACEOF
-
-fi
-
 echo "$as_me:$LINENO: checking if mknod creates FIFOs" >&5
 echo $ECHO_N "checking if mknod creates FIFOs... $ECHO_C" >&6
 if test "${rsync_cv_MKNOD_CREATES_FIFOS+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/configure.in	2006-03-12 02:25:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/configure.in	2006-04-22 23:38:34.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.59)
 
-RSYNC_VERSION=2.6.7
+RSYNC_VERSION=2.6.8
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -499,32 +499,69 @@
 
 AC_CHECK_FUNCS(getpgrp tcgetpgrp)
 if test $ac_cv_func_getpgrp = yes; then
     AC_FUNC_GETPGRP
 fi
 
-# Determine whether chown follows symlinks (it should).
-AC_CACHE_CHECK([whether chown() dereferences symlinks],rsync_cv_chown_follows_symlink,[
+AC_CACHE_CHECK([whether chown() modifies symlinks],rsync_cv_chown_modifies_symlink,[
   AC_TRY_RUN([
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif
 #include <stdlib.h>
 #include <errno.h>
     main() {
 	char const *dangling_symlink = "conftest.dangle";
 	unlink(dangling_symlink);
 	if (symlink("conftest.no-such", dangling_symlink) < 0) abort();
-	if (chown(dangling_symlink, getuid(), getgid()) < 0 && errno == ENOENT) exit(0);
-	exit(1);
+	if (chown(dangling_symlink, getuid(), getgid()) < 0 && errno == ENOENT) exit(1);
+	exit(0);
     }],
-  rsync_cv_chown_follows_symlink=yes,rsync_cv_chown_follows_symlink=no,rsync_cv_chown_follows_symlink=yes)])
-if test $rsync_cv_chown_follows_symlink = no; then
+  rsync_cv_chown_modifies_symlink=yes,rsync_cv_chown_modifies_symlink=no,rsync_cv_chown_modifies_symlink=no)])
+if test $rsync_cv_chown_modifies_symlink = yes; then
   AC_DEFINE(CHOWN_MODIFIES_SYMLINK, 1, [Define to 1 if chown modifies symlinks.])
 fi
 
+AC_CACHE_CHECK([whether link() can hard-link symlinks],rsync_cv_can_hardlink_symlink,[
+  AC_TRY_RUN([
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#include <stdlib.h>
+#include <errno.h>
+#define FILENAME "conftest.dangle"
+    main() {
+	unlink(FILENAME);
+	if (symlink("conftest.no-such", FILENAME) < 0) abort();
+	if (link(FILENAME, FILENAME "2") < 0) exit(1);
+	exit(0);
+    }],
+  rsync_cv_can_hardlink_symlink=yes,rsync_cv_can_hardlink_symlink=no,rsync_cv_can_hardlink_symlink=no)])
+if test $rsync_cv_can_hardlink_symlink = yes; then
+  AC_DEFINE(CAN_HARDLINK_SYMLINK, 1, [Define to 1 if link() can hard-link symlinks.])
+fi
+
+AC_CACHE_CHECK([whether link() can hard-link special files],rsync_cv_can_hardlink_special,[
+  AC_TRY_RUN([
+#if HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+#include <stdlib.h>
+#include <errno.h>
+#define FILENAME "conftest.fifi"
+    main() {
+	unlink(FILENAME);
+	if (mkfifo(FILENAME, 0777) < 0) abort();
+	if (link(FILENAME, FILENAME "2") < 0) exit(1);
+	exit(0);
+    }],
+  rsync_cv_can_hardlink_special=yes,rsync_cv_can_hardlink_special=no,rsync_cv_can_hardlink_special=no)])
+if test $rsync_cv_can_hardlink_special = yes; then
+    AC_DEFINE(CAN_HARDLINK_SPECIAL, 1, [Define to 1 if link() can hard-link special files.])
+fi
+
 AC_CACHE_CHECK([for working socketpair],rsync_cv_HAVE_SOCKETPAIR,[
 AC_TRY_RUN([
 #include <sys/types.h>
 #include <sys/socket.h>
 
 main() {
@@ -647,41 +684,12 @@
 	AC_DEFINE(HAVE_SECURE_MKSTEMP, 1, [Define to 1 if mkstemp() is available and works right])
 	;;
     esac
 fi
 
 
-AC_CACHE_CHECK([for broken inet_ntoa],rsync_cv_REPLACE_INET_NTOA,[
-AC_TRY_RUN([
-#include <stdio.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-main() { struct in_addr ip; ip.s_addr = 0x12345678;
-if (strcmp(inet_ntoa(ip),"18.52.86.120") &&
-    strcmp(inet_ntoa(ip),"120.86.52.18")) { exit(1); }
-exit(0);}],
-           rsync_cv_REPLACE_INET_NTOA=no,rsync_cv_REPLACE_INET_NTOA=yes,rsync_cv_REPLACE_INET_NTOA=cross)])
-if test x"$rsync_cv_REPLACE_INET_NTOA" = x"yes"; then
-    AC_DEFINE(REPLACE_INET_NTOA, 1, [Define to 1 if inet_ntoa() needs to be replaced])
-fi
-
-
-AC_CACHE_CHECK([for broken inet_aton],rsync_cv_REPLACE_INET_ATON,[
-AC_TRY_RUN([
-#include <stdio.h>
-#include <sys/types.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-main() { struct in_addr ip;
-if (inet_aton("example", &ip) == 0) exit(0); exit(1);}],
-           rsync_cv_REPLACE_INET_ATON=no,rsync_cv_REPLACE_INET_ATON=yes,rsync_cv_REPLACE_INET_ATON=cross)])
-if test x"$rsync_cv_REPLACE_INET_ATON" = x"yes"; then
-    AC_DEFINE(REPLACE_INET_ATON, 1, [Define to 1 if inet_aton() needs to be replaced])
-fi
-
 AC_CACHE_CHECK([if mknod creates FIFOs],rsync_cv_MKNOD_CREATES_FIFOS,[
 AC_TRY_RUN([
 #include <stdio.h>
 #include <sys/stat.h>
 #include <errno.h>
 main() { int rc, ec; char *fn = "fifo-test";
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/exclude.c	2006-01-28 08:14:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/exclude.c	2006-03-29 07:09:07.000000000 +0800
@@ -31,14 +31,12 @@
 extern int am_sender;
 extern int eol_nulls;
 extern int list_only;
 extern int recurse;
 extern int io_error;
 extern int local_server;
-extern int saw_delete_opt;
-extern int saw_delete_excluded_opt;
 extern int prune_empty_dirs;
 extern int delete_mode;
 extern int delete_excluded;
 extern int cvs_exclude;
 extern int sanitize_paths;
 extern int protocol_version;
@@ -559,13 +557,13 @@
 		if (wildmatch_array(pattern, strings, slash_handling))
 			return ret_match;
 	} else if (str_cnt > 1) {
 		if (litmatch_array(pattern, strings, slash_handling))
 			return ret_match;
 	} else if (anchored_match) {
-		if (strcmp(name,pattern) == 0)
+		if (strcmp(strings[0], pattern) == 0)
 			return ret_match;
 	} else {
 		int l1 = strlen(name);
 		int l2 = strlen(pattern);
 		if (l2 <= l1 &&
 		    strcmp(name+(l1-l2),pattern) == 0 &&
@@ -1182,14 +1180,14 @@
 /* This is only called by the server. */
 void recv_filter_list(int f_in)
 {
 	char line[BIGPATHBUFLEN];
 	int xflags = protocol_version >= 29 ? 0 : XFLG_OLD_PREFIXES;
 	int receiver_wants_list = prune_empty_dirs
-	    || (saw_delete_opt
-	     && (!saw_delete_excluded_opt || protocol_version >= 29));
+	    || (delete_mode
+	     && (!delete_excluded || protocol_version >= 29));
 	unsigned int len;
 
 	if (!local_server && (am_sender || receiver_wants_list)) {
 		while ((len = read_int(f_in)) != 0) {
 			if (len >= sizeof line)
 				overflow_exit("recv_rules");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/fileio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/fileio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/fileio.c	2005-09-22 01:37:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/fileio.c	2006-04-09 00:37:50.000000000 +0800
@@ -229,13 +229,12 @@
 			rsyserr(FERROR, errno, "lseek returned %.0f, not %.0f",
 				(double)ret, (double)read_start);
 			exit_cleanup(RERR_FILEIO);
 		}
 		map->p_fd_offset = read_start;
 	}
-	map->p_fd_offset += read_size;
 	map->p_offset = window_start;
 	map->p_len = window_size;
 
 	while (read_size > 0) {
 		nread = read(map->fd, map->p + read_offset, read_size);
 		if (nread <= 0) {
@@ -243,12 +242,13 @@
 				map->status = nread ? errno : ENODATA;
 			/* The best we can do is zero the buffer -- the file
 			 * has changed mid transfer! */
 			memset(map->p + read_offset, 0, read_size);
 			break;
 		}
+		map->p_fd_offset += nread;
 		read_offset += nread;
 		read_size -= nread;
 	}
 
 	return map->p;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/flist.c	2006-02-25 01:54:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/flist.c	2006-04-22 00:36:30.000000000 +0800
@@ -54,13 +54,12 @@
 extern int implied_dirs;
 extern int prune_empty_dirs;
 extern int copy_links;
 extern int copy_unsafe_links;
 extern int protocol_version;
 extern int sanitize_paths;
-extern const char *io_write_phase;
 extern struct stats stats;
 extern struct file_list *the_file_list;
 
 extern char curr_dir[MAXPATHLEN];
 
 extern struct chmod_mode_struct *chmod_modes;
@@ -331,14 +330,12 @@
 		rdev_major = 0;
 		uid = 0, gid = 0;
 		*lastname = '\0';
 		return;
 	}
 
-	io_write_phase = "send_file_entry";
-
 	f_name(file, fname);
 
 	flags = file->flags & XMIT_TOP_DIR;
 
 	if (file->mode == mode)
 		flags |= XMIT_SAME_MODE;
@@ -484,14 +481,12 @@
 			sum = empty_sum;
 		}
 		write_buf(f, sum, checksum_len);
 	}
 
 	strlcpy(lastname, fname, MAXPATHLEN);
-
-	io_write_phase = "unknown";
 }
 
 static struct file_struct *receive_file_entry(struct file_list *flist,
 					      unsigned short flags, int f)
 {
 	static time_t modtime;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/generator.c	2006-03-10 23:57:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/generator.c	2006-04-18 14:38:58.000000000 +0800
@@ -91,14 +91,12 @@
 extern char *backup_suffix;
 extern int backup_suffix_len;
 extern struct file_list *the_file_list;
 extern struct filter_list_struct server_filter_list;
 
 static int deletion_count = 0; /* used to implement --max-delete */
-static int can_link_symlinks = 1; /* start out optimistic */
-static int can_link_devices = 1;
 
 /* For calling delete_file() */
 #define DEL_FORCE_RECURSE	(1<<1) /* recurse even w/o --force */
 #define DEL_TERSE		(1<<3)
 
 
@@ -699,40 +697,58 @@
 	return FNAMECMP_BASIS_DIR_LOW + j;
 }
 
 /* This is only called for non-regular files.  We return -2 if we've finished
  * handling the file, or -1 if no dest-linking occurred. */
 static int try_dests_non(struct file_struct *file, char *fname, int ndx,
-			 int itemizing, int *possible_ptr,
-			 int maybe_ATTRS_REPORT, enum logcode code)
+			 int itemizing, int maybe_ATTRS_REPORT,
+			 enum logcode code)
 {
-	char fnamebuf[MAXPATHLEN], lnk[MAXPATHLEN];
+	char fnamebuf[MAXPATHLEN];
 	STRUCT_STAT st;
-	int len, i = 0;
+	int i = 0;
 
 	do {
 		pathjoin(fnamebuf, MAXPATHLEN, basis_dir[i], fname);
 		if (link_stat(fnamebuf, &st, 0) < 0 || S_ISDIR(st.st_mode)
 		 || !unchanged_attrs(file, &st))
 			continue;
 		if (S_ISLNK(file->mode)) {
 #ifdef SUPPORT_LINKS
+			char lnk[MAXPATHLEN];
+			int len;
 			if ((len = readlink(fnamebuf, lnk, MAXPATHLEN-1)) <= 0)
 				continue;
 			lnk[len] = '\0';
 			if (strcmp(lnk, file->u.link) != 0)
 #endif
 				continue;
-		} else {
+		} else if (IS_SPECIAL(file->mode)) {
+			if (!IS_SPECIAL(st.st_mode) || st.st_rdev != file->u.rdev)
+				continue;
+		} else if (IS_DEVICE(file->mode)) {
 			if (!IS_DEVICE(st.st_mode) || st.st_rdev != file->u.rdev)
 				continue;
-		}
-		if (link_dest) {
+		} else {
+			rprintf(FERROR,
+				"internal: try_dests_non() called with invalid mode (%o)\n",
+				file->mode);
+			exit_cleanup(RERR_UNSUPPORTED);
+		}
+		if (link_dest
+#ifndef CAN_HARDLINK_SYMLINK
+		 && !S_ISLNK(file->mode)
+#endif
+#ifndef CAN_HARDLINK_SPECIAL
+		 && !IS_SPECIAL(file->mode) && !IS_DEVICE(file->mode)
+#endif
+		) {
 			if (do_link(fnamebuf, fname) < 0) {
-				/* TODO improve this to be based on errno? */
-				*possible_ptr = 0;
+				rsyserr(FERROR, errno,
+					"failed to hard-link %s with %s",
+					fnamebuf, fname);
 				break;
 			}
 			if (preserve_hard_links && file->link_u.links)
 				hard_link_cluster(file, ndx, itemizing, code);
 		}
 		if (itemizing && log_format_has_i && verbose > 1) {
@@ -957,16 +973,20 @@
 			/* Not the right symlink (or not a symlink), so
 			 * delete it. */
 			if (delete_item(fname, st.st_mode, del_opts) < 0)
 				return;
 			if (!S_ISLNK(st.st_mode))
 				statret = -1;
-		} else if (basis_dir[0] != NULL && can_link_symlinks) {
+		} else if (basis_dir[0] != NULL) {
 			if (try_dests_non(file, fname, ndx, itemizing,
-					  &can_link_symlinks,
 					  maybe_ATTRS_REPORT, code) == -2) {
+#ifndef CAN_HARDLINK_SYMLINK
+				if (link_dest) {
+					/* Resort to --copy-dest behavior. */
+				} else
+#endif
 				if (!copy_dest)
 					return;
 				itemizing = code = 0;
 			}
 		}
 		if (preserve_hard_links && file->link_u.links
@@ -997,17 +1017,20 @@
 #endif
 		return;
 	}
 
 	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
 	 || (preserve_specials && IS_SPECIAL(file->mode))) {
-		if (statret != 0
-		 && (basis_dir[0] != NULL && can_link_devices)) {
+		if (statret != 0 && basis_dir[0] != NULL) {
 			if (try_dests_non(file, fname, ndx, itemizing,
-					  &can_link_devices,
 					  maybe_ATTRS_REPORT, code) == -2) {
+#ifndef CAN_HARDLINK_SPECIAL
+				if (link_dest) {
+					/* Resort to --copy-dest behavior. */
+				} else
+#endif
 				if (!copy_dest)
 					return;
 				itemizing = code = 0;
 			}
 		}
 		if (statret != 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/io.c	2006-02-27 11:12:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/io.c	2006-04-22 00:40:19.000000000 +0800
@@ -60,28 +60,12 @@
 
 const char phase_unknown[] = "unknown";
 int ignore_timeout = 0;
 int batch_fd = -1;
 int batch_gen_fd = -1;
 
-/**
- * The connection might be dropped at some point; perhaps because the
- * remote instance crashed.  Just giving the offset on the stream is
- * not very helpful.  So instead we try to make io_phase_name point to
- * something useful.
- *
- * For buffered/multiplexed I/O these names will be somewhat
- * approximate; perhaps for ease of support we would rather make the
- * buffer always flush when a single application-level I/O finishes.
- *
- * @todo Perhaps we want some simple stack functionality, but there's
- * no need to overdo it.
- **/
-const char *io_write_phase = phase_unknown;
-const char *io_read_phase = phase_unknown;
-
 /* Ignore an EOF error if non-zero. See whine_about_eof(). */
 int kluge_around_eof = 0;
 
 int msg_fd_in = -1;
 int msg_fd_out = -1;
 int sock_f_in = -1;
@@ -99,13 +83,13 @@
 static int io_filesfrom_f_in = -1;
 static int io_filesfrom_f_out = -1;
 static char io_filesfrom_buf[2048];
 static char *io_filesfrom_bp;
 static char io_filesfrom_lastchar;
 static int io_filesfrom_buflen;
-static size_t contiguous_write_len = 0;
+static int defer_forwarding_messages = 0;
 static int select_timeout = SELECT_TIMEOUT;
 static int active_filecnt = 0;
 static OFF_T active_bytecnt = 0;
 
 static void read_loop(int fd, char *buf, size_t len);
 
@@ -119,21 +103,21 @@
 };
 
 static struct flist_ndx_list redo_list, hlink_list;
 
 struct msg_list_item {
 	struct msg_list_item *next;
-	char *buf;
 	int len;
+	char buf[1];
 };
 
 struct msg_list {
 	struct msg_list_item *head, *tail;
 };
 
-static struct msg_list msg_list;
+static struct msg_list msg2genr, msg2sndr;
 
 static void flist_ndx_push(struct flist_ndx_list *lp, int ndx)
 {
 	struct flist_ndx_item *item;
 
 	if (!(item = new(struct flist_ndx_item)))
@@ -223,29 +207,28 @@
 {
 	msg_fd_out = fd;
 	set_nonblocking(msg_fd_out);
 }
 
 /* Add a message to the pending MSG_* list. */
-static void msg_list_add(int code, char *buf, int len)
+static void msg_list_add(struct msg_list *lst, int code, char *buf, int len)
 {
-	struct msg_list_item *ml;
+	struct msg_list_item *m;
+	int sz = len + 4 + sizeof m[0] - 1;
 
-	if (!(ml = new(struct msg_list_item)))
+	if (!(m = (struct msg_list_item *)new_array(char, sz)))
 		out_of_memory("msg_list_add");
-	ml->next = NULL;
-	if (!(ml->buf = new_array(char, len+4)))
-		out_of_memory("msg_list_add");
-	SIVAL(ml->buf, 0, ((code+MPLEX_BASE)<<24) | len);
-	memcpy(ml->buf+4, buf, len);
-	ml->len = len+4;
-	if (msg_list.tail)
-		msg_list.tail->next = ml;
+	m->next = NULL;
+	m->len = len + 4;
+	SIVAL(m->buf, 0, ((code+MPLEX_BASE)<<24) | len);
+	memcpy(m->buf + 4, buf, len);
+	if (lst->tail)
+		lst->tail->next = m;
 	else
-		msg_list.head = ml;
-	msg_list.tail = ml;
+		lst->head = m;
+	lst->tail = m;
 }
 
 /* Read a message from the MSG_* fd and handle it.  This is called either
  * during the early stages of being a local sender (up through the sending
  * of the file list) or when we're the generator (to fetch the messages
  * from the receiver). */
@@ -287,23 +270,29 @@
 	case MSG_DELETED:
 		if (len >= (int)sizeof buf || !am_generator) {
 			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
 			exit_cleanup(RERR_STREAMIO);
 		}
 		read_loop(fd, buf, len);
-		io_multiplex_write(MSG_DELETED, buf, len);
+		if (defer_forwarding_messages)
+			msg_list_add(&msg2sndr, MSG_DELETED, buf, len);
+		else
+			io_multiplex_write(MSG_DELETED, buf, len);
 		break;
 	case MSG_SUCCESS:
 		if (len != 4 || !am_generator) {
 			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
 			exit_cleanup(RERR_STREAMIO);
 		}
 		read_loop(fd, buf, len);
 		if (remove_sent_files) {
 			decrement_active_files(IVAL(buf,0));
-			io_multiplex_write(MSG_SUCCESS, buf, len);
+			if (defer_forwarding_messages)
+				msg_list_add(&msg2sndr, MSG_SUCCESS, buf, len);
+			else
+				io_multiplex_write(MSG_SUCCESS, buf, len);
 		}
 		if (preserve_hard_links)
 			flist_ndx_push(&hlink_list, IVAL(buf,0));
 		break;
 	case MSG_SOCKERR:
 		if (!am_generator) {
@@ -317,18 +306,22 @@
 	case MSG_LOG:
 		while (len) {
 			n = len;
 			if (n >= sizeof buf)
 				n = sizeof buf - 1;
 			read_loop(fd, buf, n);
-			rwrite((enum logcode)tag, buf, n);
+			if (am_generator && am_server && defer_forwarding_messages)
+				msg_list_add(&msg2sndr, tag, buf, n);
+			else
+				rwrite((enum logcode)tag, buf, n);
 			len -= n;
 		}
 		break;
 	default:
-		rprintf(FERROR, "unknown message %d:%d\n", tag, len);
+		rprintf(FERROR, "unknown message %d:%d [%s]\n",
+			tag, len, who_am_i());
 		exit_cleanup(RERR_STREAMIO);
 	}
 
 	msg_fd_in = fd;
 }
 
@@ -354,24 +347,24 @@
 	active_bytecnt -= the_file_list->files[ndx]->length;
 }
 
 /* Try to push messages off the list onto the wire.  If we leave with more
  * to do, return 0.  On error, return -1.  If everything flushed, return 1.
  * This is only active in the receiver. */
-static int msg_list_flush(int flush_it_all)
+static int msg2genr_flush(int flush_it_all)
 {
 	static int written = 0;
 	struct timeval tv;
 	fd_set fds;
 
 	if (msg_fd_out < 0)
 		return -1;
 
-	while (msg_list.head) {
-		struct msg_list_item *ml = msg_list.head;
-		int n = write(msg_fd_out, ml->buf + written, ml->len - written);
+	while (msg2genr.head) {
+		struct msg_list_item *m = msg2genr.head;
+		int n = write(msg_fd_out, m->buf + written, m->len - written);
 		if (n < 0) {
 			if (errno == EINTR)
 				continue;
 			if (errno != EWOULDBLOCK && errno != EAGAIN)
 				return -1;
 			if (!flush_it_all)
@@ -379,32 +372,31 @@
 			FD_ZERO(&fds);
 			FD_SET(msg_fd_out, &fds);
 			tv.tv_sec = select_timeout;
 			tv.tv_usec = 0;
 			if (!select(msg_fd_out+1, NULL, &fds, NULL, &tv))
 				check_timeout();
-		} else if ((written += n) == ml->len) {
-			free(ml->buf);
-			msg_list.head = ml->next;
-			if (!msg_list.head)
-				msg_list.tail = NULL;
-			free(ml);
+		} else if ((written += n) == m->len) {
+			msg2genr.head = m->next;
+			if (!msg2genr.head)
+				msg2genr.tail = NULL;
+			free(m);
 			written = 0;
 		}
 	}
 	return 1;
 }
 
 void send_msg(enum msgcode code, char *buf, int len)
 {
 	if (msg_fd_out < 0) {
 		io_multiplex_write(code, buf, len);
 		return;
 	}
-	msg_list_add(code, buf, len);
-	msg_list_flush(NORMAL_FLUSH);
+	msg_list_add(&msg2genr, code, buf, len);
+	msg2genr_flush(NORMAL_FLUSH);
 }
 
 int get_redo_num(int itemizing, enum logcode code)
 {
 	while (1) {
 		if (hlink_list.head)
@@ -495,13 +487,13 @@
 		int maxfd = fd;
 		int count;
 
 		FD_ZERO(&r_fds);
 		FD_ZERO(&w_fds);
 		FD_SET(fd, &r_fds);
-		if (msg_list.head) {
+		if (msg2genr.head) {
 			FD_SET(msg_fd_out, &w_fds);
 			if (msg_fd_out > maxfd)
 				maxfd = msg_fd_out;
 		}
 		if (io_filesfrom_f_out >= 0) {
 			int new_fd;
@@ -532,14 +524,14 @@
 			if (errno == EBADF)
 				exit_cleanup(RERR_SOCKETIO);
 			check_timeout();
 			continue;
 		}
 
-		if (msg_list.head && FD_ISSET(msg_fd_out, &w_fds))
-			msg_list_flush(NORMAL_FLUSH);
+		if (msg2genr.head && FD_ISSET(msg_fd_out, &w_fds))
+			msg2genr_flush(NORMAL_FLUSH);
 
 		if (io_filesfrom_f_out >= 0) {
 			if (io_filesfrom_buflen) {
 				if (FD_ISSET(io_filesfrom_f_out, &w_fds)) {
 					int l = write(io_filesfrom_f_out,
 						      io_filesfrom_bp,
@@ -1053,22 +1045,23 @@
  * application never calls this function directly. */
 static void writefd_unbuffered(int fd,char *buf,size_t len)
 {
 	size_t n, total = 0;
 	fd_set w_fds, r_fds;
 	int maxfd, count, cnt, using_r_fds;
+	int defer_save = defer_forwarding_messages;
 	struct timeval tv;
 
 	no_flush++;
 
 	while (total < len) {
 		FD_ZERO(&w_fds);
 		FD_SET(fd,&w_fds);
 		maxfd = fd;
 
-		if (msg_fd_in >= 0 && len-total >= contiguous_write_len) {
+		if (msg_fd_in >= 0) {
 			FD_ZERO(&r_fds);
 			FD_SET(msg_fd_in,&r_fds);
 			if (msg_fd_in > maxfd)
 				maxfd = msg_fd_in;
 			using_r_fds = 1;
 		} else
@@ -1110,75 +1103,89 @@
 			}
 
 			/* Don't try to write errors back across the stream. */
 			if (fd == sock_f_out)
 				close_multiplexing_out();
 			rsyserr(FERROR, errno,
-				"writefd_unbuffered failed to write %ld bytes: phase \"%s\" [%s]",
-				(long)len, io_write_phase, who_am_i());
+				"writefd_unbuffered failed to write %ld bytes [%s]",
+				(long)len, who_am_i());
 			/* If the other side is sending us error messages, try
 			 * to grab any messages they sent before they died. */
 			while (fd == sock_f_out && io_multiplexing_in) {
 				set_io_timeout(30);
 				ignore_timeout = 0;
 				readfd_unbuffered(sock_f_in, io_filesfrom_buf,
 						  sizeof io_filesfrom_buf);
 			}
 			exit_cleanup(RERR_STREAMIO);
 		}
 
 		total += cnt;
+		defer_forwarding_messages = 1;
 
 		if (fd == sock_f_out) {
 			if (io_timeout || am_generator)
 				last_io_out = time(NULL);
 			sleep_for_bwlimit(cnt);
 		}
 	}
 
+	defer_forwarding_messages = defer_save;
 	no_flush--;
 }
 
+static void msg2sndr_flush(void)
+{
+	if (defer_forwarding_messages)
+		return;
+
+	while (msg2sndr.head && io_multiplexing_out) {
+		struct msg_list_item *m = msg2sndr.head;
+		if (!(msg2sndr.head = m->next))
+			msg2sndr.tail = NULL;
+		stats.total_written += m->len;
+		defer_forwarding_messages = 1;
+		writefd_unbuffered(sock_f_out, m->buf, m->len);
+		defer_forwarding_messages = 0;
+		free(m);
+	}
+}
+
 /**
  * Write an message to a multiplexed stream. If this fails then rsync
  * exits.
  **/
 static void mplex_write(enum msgcode code, char *buf, size_t len)
 {
 	char buffer[1024];
 	size_t n = len;
 
 	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
 
-	/* When the generator reads messages from the msg_fd_in pipe, it can
-	 * cause output to occur down the socket.  Setting contiguous_write_len
-	 * prevents the reading of msg_fd_in once we actually start to write
-	 * this sequence of data (though we might read it before the start). */
-	if (am_generator && msg_fd_in >= 0)
-		contiguous_write_len = len + 4;
-
 	if (n > sizeof buffer - 4)
 		n = 0;
 	else
 		memcpy(buffer + 4, buf, n);
 
 	writefd_unbuffered(sock_f_out, buffer, n+4);
 
 	len -= n;
 	buf += n;
 
-	if (len)
+	if (len) {
+		defer_forwarding_messages = 1;
 		writefd_unbuffered(sock_f_out, buf, len);
-
-	if (am_generator && msg_fd_in >= 0)
-		contiguous_write_len = 0;
+		defer_forwarding_messages = 0;
+		msg2sndr_flush();
+	}
 }
 
 void io_flush(int flush_it_all)
 {
-	msg_list_flush(flush_it_all);
+	msg2genr_flush(flush_it_all);
+	msg2sndr_flush();
 
 	if (!iobuf_out_cnt || no_flush)
 		return;
 
 	if (io_multiplexing_out)
 		mplex_write(MSG_DATA, iobuf_out, iobuf_out_cnt);
@@ -1233,19 +1240,12 @@
 {
 	char b[4];
 	SIVAL(b,0,x);
 	writefd(f,b,4);
 }
 
-void write_int_named(int f, int32 x, const char *phase)
-{
-	io_write_phase = phase;
-	write_int(f, x);
-	io_write_phase = phase_unknown;
-}
-
 /*
  * Note: int64 may actually be a 32-bit type if ./configure couldn't find any
  * 64-bit types on this platform.
  */
 void write_longint(int f, int64 x)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/compat.c	2005-02-14 08:53:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/lib/compat.c	2006-04-14 00:52:15.000000000 +0800
@@ -147,55 +147,12 @@
 		d[len1+len2] = 0;
 	}
 	return ret;
 }
 #endif
 
-#ifdef REPLACE_INET_NTOA
- char *rep_inet_ntoa(struct in_addr ip)
-{
-	unsigned char *p = (unsigned char *)&ip.s_addr;
-	static char buf[18];
-#ifdef WORDS_BIGENDIAN
-	snprintf(buf, 18, "%d.%d.%d.%d", 
-		 (int)p[0], (int)p[1], (int)p[2], (int)p[3]);
-#else
-	snprintf(buf, 18, "%d.%d.%d.%d", 
-		 (int)p[3], (int)p[2], (int)p[1], (int)p[0]);
-#endif
-	return buf;
-}
-#endif
-
-#ifdef REPLACE_INET_ATON
- int inet_aton(const char *cp, struct in_addr *inp)
-{
-	unsigned int a1, a2, a3, a4;
-	unsigned long ret;
-
-	if (strcmp(cp, "255.255.255.255") == 0) {
-		inp->s_addr = (unsigned) -1;
-		return 0;
-	}
-
-	if (sscanf(cp, "%u.%u.%u.%u", &a1, &a2, &a3, &a4) != 4 ||
-	    a1 > 255 || a2 > 255 || a3 > 255 || a4 > 255) {
-		return 0;
-	}
-
-	ret = (a1 << 24) | (a2 << 16) | (a3 << 8) | a4;
-
-	inp->s_addr = htonl(ret);
-	
-	if (inp->s_addr == (unsigned) -1) {
-		return 0;
-	}
-	return 1;
-}
-#endif
-
 /* some systems don't take the 2nd argument */
 int sys_gettimeofday(struct timeval *tv)
 {
 #ifdef HAVE_GETTIMEOFDAY_TZ
 	return gettimeofday(tv, NULL);
 #else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/loadparm.c	2006-01-31 05:47:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/loadparm.c	2006-04-06 15:28:22.000000000 +0800
@@ -799,26 +799,25 @@
 Load the services array from the services file. Return True on success,
 False on failure.
 ***************************************************************************/
 BOOL lp_load(char *pszFname, int globals_only)
 {
 	extern int am_server;
-	extern int am_daemon;
 	extern int am_root;
 	pstring n2;
 	BOOL bRetval;
 
 	bRetval = False;
 
 	bInGlobalSection = True;
 
 	init_globals();
 
 	if (pszFname)
 	    pstrcpy(n2,pszFname);
-	else if (am_server && am_daemon && !am_root)
+	else if (am_server && !am_root)
 	    pstrcpy(n2,RSYNCD_USERCONF);
 	else
 	    pstrcpy(n2,RSYNCD_SYSCONF);
 
 	/* We get sections first, so have to start 'behind' to make up */
 	iServiceIndex = -1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/log.c	2006-02-24 09:56:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/log.c	2006-04-09 00:04:34.000000000 +0800
@@ -766,14 +766,14 @@
 		name = rerr_name(code);
 		if (!name)
 			name = "unexplained error";
 
 		/* VANISHED is not an error, only a warning */
 		if (code == RERR_VANISHED) {
-			rprintf(FINFO, "rsync warning: %s (code %d) at %s(%d) [%s]\n", 
-				name, code, file, line, who_am_i());
+			rprintf(FINFO, "rsync warning: %s (code %d) at %s(%d) [%s=%s]\n", 
+				name, code, file, line, who_am_i(), RSYNC_VERSION);
 		} else {
-			rprintf(FERROR, "rsync error: %s (code %d) at %s(%d) [%s]\n",
-				name, code, file, line, who_am_i());
+			rprintf(FERROR, "rsync error: %s (code %d) at %s(%d) [%s=%s]\n",
+				name, code, file, line, who_am_i(), RSYNC_VERSION);
 		}
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/Makefile.in	2006-02-06 12:54:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/Makefile.in	2006-04-18 01:37:13.000000000 +0800
@@ -88,19 +88,19 @@
 
 T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o t_stub.o lib/compat.o lib/snprintf.o
 t_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(T_UNSAFE_OBJ) $(LIBS)
 
 gen:
-	$(MAKE) -C $(srcdir) -f prepare-source.mak gen
+	cd $(srcdir) && $(MAKE) -f prepare-source.mak gen
 
 man:
-	$(MAKE) -C $(srcdir) -f prepare-source.mak man
+	cd $(srcdir) && $(MAKE) -f prepare-source.mak man
 
 proto:
-	$(MAKE) -C $(srcdir) -f prepare-source.mak proto.h
+	cd $(srcdir) && $(MAKE) -f prepare-source.mak proto.h
 
 clean: cleantests
 	rm -f *~ $(OBJS) $(TLS_OBJ) $(CHECK_PROGS) $(CHECK_OBJS)
 
 cleantests:
 	rm -rf ./testtmp*
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/NEWS	2006-03-12 02:25:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/NEWS	2006-04-22 23:38:34.000000000 +0800
@@ -1,320 +1,67 @@
-NEWS for rsync 2.6.7 (11 Mar 2006)
-
+NEWS for rsync 2.6.8 (22 Apr 2006)
 Protocol: 29 (unchanged)
-Changes since 2.6.6:
-
-  OUTPUT CHANGES:
-
-    - The letter 'D' in the itemized output was being used for both devices
-      (character or block) as well as other special files (such as fifos and
-      named sockets).  This has changed to separate non-device special files
-      under the 'S' designation (e.g. "cS+++++++ path/fifo").  See also the
-      "--specials" option, below.
-
-    - The way rsync escapes unreadable characters has changed.  First, rsync
-      now has support for recognizing valid multibyte character sequences in
-      your current locale, allowing it to escape fewer characters than before
-      for a locale such as UTF-8.  Second, it now uses an escape idiom of
-      "\#123", which is the literal string "\#" followed by exactly 3 octal
-      digits.  Rsync no longer doubles a backslash character in a filename
-      (e.g. it used to output "foo\\bar" when copying "foo\bar") -- now it only
-      escapes a backslash that is followed by a hash-sign and 3 digits (0-9)
-      (e.g. it will output "foo\#134#789" when copying "foo\#789").  See also
-      the --8-bit-output (-8) option, mentioned below.
-
-      Script writers: the local rsync is the one that outputs escaped names,
-      so if you need to support unescaping of filenames for older rsyncs, I'd
-      suggest that you parse the output of "rsync --version" and only use the
-      old unescaping rules for 2.6.5 and 2.6.6.
+Changes since 2.6.7:
 
   BUG FIXES:
 
-    - Fixed a really old bug that caused --checksum (-c) to checksum all the
-      files encountered during the delete scan (ouch).
-
-    - Fixed a potential hang in a remote generator:  when the receiver gets a
-      read-error on the socket, it now signals the generator about this so that
-      the generator does not try to send any of the terminating error messages
-      to the client (avoiding a potential hang in some setups).
-
-    - Made hard-links work with symlinks and devices again.
-
-    - If the sender gets an early EOF reading a source file, we propagate this
-      error to the receiver so that it can discard the file and try requesting
-      it again (which is the existing behavior for other kinds of read errors).
-
-    - If a device-file/special-file changes permissions, rsync now updates the
-      permissions without recreating the file.
-
-    - If the user specifies a remote-host for both the source and destination,
-      we now output a syntax error rather than trying to open the destination
-      hostspec as a filename.
-
-    - When --inplace creates a new destination file, rsync now creates it with
-      permissions 0600 instead of 0000 -- this makes restarting possible when
-      the transfer gets interrupted in the middle of sending a new file.
-
-    - Reject the combination of --inplace and --sparse since the sparse-output
-      algorithm doesn't work when overwriting existing data.
-
-    - Fixed the directory name in the error that is output when pop_dir()
-      fails.
-
-    - Really fixed the parsing of a "!" entry in .cvsignore files this time.
-
-    - If the generator gets a stat() error on a file, output it (this used to
-      require at least -vv for the error to be seen).
-
-    - If waitpid() fails or the child rsync didn't exit cleanly, we now handle
-      the exit status properly and generate a better error.
-
-    - Fixed some glitches in the double-verbose output when using --copy-dest,
-      --link-dest, or --compare-dest.  Also improved how the verbose output
-      handles hard-links (within the transfer) that had an up-to-date alternate
-      "dest" file, and copied files (via --copy-dest).
-
-    - Fixed the matching of the dont-compress items (e.g. *.gz) against files
-      that have a path component containing a slash.
-
-    - If code reading a filter/exclude file an EINTR error, rsync now clears
-      the error flag on the file handle so it can keep on reading.
-
-    - If --relative is active, the sending side cleans up trailing "/" or "/."
-      suffixes to avoid triggering a bug in older rsync versions.  Also, we now
-      reject a ".." dir if it would be sent as a relative dir.
-
-    - If a non-directory is in the way of a directory and rsync is run with
-      --dry-run and --delete, rsync no longer complains about not being able
-      to opendir() the not-yet present directory.
-
-    - When --list-only is used and a non-existent local destination dir was
-      also specified as a destination, rsync no longer generates a warning
-      about being unable to create the missing directory.
-
-    - Fixed some problems with --relative --no-implied-dirs when the
-      destination directory did not yet exist:  we can now create a symlink or
-      device when it is the first thing in the missing dir, and --fuzzy no
-      longer complains about being unable to open the missing dir.
-
-    - Fixed a bug where the --copy-links option would not affect implied
-      directories without --copy-unsafe-links (see --relative).
-
-    - Got rid of the need for --force to be used in some circumstances with
-      --delete-after (making it consistent with --delete-before/-during).
-
-    - Rsync now ignores the SIGXFSZ signal, just in case your OS sends this
-      when a file is too large (rsync handles the write error).
-
-    - Fixed a bug in the Proxy-Authorization header's base64-encoded value: it
-      was not properly padded with trailing '=' chars.  This only affects a
-      user that need to use a password-authenticated proxy for an outgoing
-      daemon-rsync connection.
-
-    - If we're transferring an empty directory to a new name, rsync no longer
-      forces S_IWUSR if it wasn't already set, nor does it accidentally leave
-      it set.
-
-    - Fixed a bug in the debug output (-vvvvv) that could mention the wrong
-      checksum for the current file offset.
-
-    - Rsync no longer allows a single directory to be copied over a non-
-      directory destination arg.
+    - Fixed a bug in the exclude code where an anchored exclude without any
+      wildcards fails to match an absolute source arg, but only when --relative
+      is in effect.
+
+    - Improved the I/O code for the generator to fix a potential hang when the
+      receiver gets an EOF on the socket but the generator's select() call
+      never indicates that the socket is writable for it to be notified about
+      the EOF.  (This can happen when using stunnel).
+
+    - Fixed a problem with the file-reading code where a failed read (such as
+      that caused by a bad sector) would not advance the file's read-position
+      beyond the failed read's data.
+
+    - Fixed a logging bug where the "log file" directive was not being honored
+      in a single-use daemon (one spawned by a remote-shell connection or by
+      init).
+
+    - If rsync cannot honor the --delete option, we output an error and exit
+      instead of silently ignoring the option.
+
+    - Fixed a bug in the --link-dest code that prevented special files (such as
+      fifos) from being linked.
+
+    - The ability to hard-link symlinks and special files is now determined at
+      configure time instead of at runtime.  This fixes a bug with --link-dest
+      creating a hard-link to a symlink's referent on a BSD system.
 
   ENHANCEMENTS:
 
-    - Added the --append option that makes rsync append data onto files that
-      are longer on the source than the destination (this includes new files).
-
-    - Added the --min-size=SIZE option to exclude small files from the
-      transfer.
-
-    - Added the --compress-level option to allow you to set how aggressive
-      rsync's compression should be (this option implies --compress).
-
-    - Enhanced the parsing of the SIZE value for --min-size and --max-size to
-      allow easy entry of multiples of 1000 (instead of just multiples of 1024)
-      and off-by-one values too (e.g. --max-size=8mb-1).
-
-    - Added the --8-bit-output (-8) option, which tells rsync to avoid escaping
-      high-bit characters that it thinks are unreadable in the current locale.
-
-    - The new option --human-readable (-h) changes the output of --progress,
-      --stats, and the end-of-run summary to be easier to read.  If repeated,
-      the units become powers of 1024 instead of powers of 1000.  (The old
-      meaning of -h, as a shorthand for --help, still works as long as you
-      just use it on its own, as in "rsync -h".)
-
-    - If lutimes() and/or lchmod() are around, use them to allow the
-      preservation of attributes on symlinks.
+    - In daemon mode, if rsync fails to bind to the requested port, the
+      error(s) returned by socket() and/or bind() are now logged.
 
-    - The --link-dest option now affects symlinks and devices (when possible).
+    - When we output a fatal error, we now output the version of rsync in the
+      message.
 
-    - Added two config items to the rsyncd.conf parsing:  "pre-xfer exec" and
-      "post-xfer exec".  These allow a command to be specified on a per-module
-      basis that will be run before and/or after a daemon-mode transfer.  (See
-      the man page for a list of the environment variables that are set with
-      information about the transfer.)
+    - Improved the documentation for the --owner and --group options.
 
-    - When using the --relative option, you can now insert a dot dir in
-      the source path to indicate where the replication of the source dirs
-      should start.  For example, if you specify a source path of
-      rsync://host/module/foo/bar/./baz/dir with -R, rsync will now only
-      replicate the "baz/dir" part of the source path (note: a trailing
-      dot dir is unaffected unless it also has a trailing slash).
+    - The rsyncstats script in "support" has an improved line-parsing regex
+      that is easier to read and also makes it to parse syslog-generated lines.
 
-    - Added some new --no-FOO options that make it easier to override unwanted
-      implied or default options.  For example, "-a --no-o" (aka "--archive
-      --no-owner") can be used to turn off the preservation of file ownership
-      that is implied by -a.
+    - A new script in "support": file-attr-restore, can be used to restore the
+      attributes of a file-set (the permissions, ownership, and group info)
+      taken from the cached output of a "find ARG... -ls" command.
 
-    - Added the --chmod=MODE option that allows the destination permissions to
-      be changed from the source permissions.  E.g. --chmod=g+w,o-rwx
-
-    - Added the "incoming chmod" and "outgoing chmod" daemon options that allow
-      a module to specify what permissions changes should be applied to all
-      files copied to and from the daemon.
-
-    - Allow the --temp-dir option to be specified when starting a daemon, which
-      sets the default temporary directory for incoming files.
-
-    - If --delete is combined with --dirs without --recursive, rsync will now
-      delete in any directory whose content is being synchronized.
-
-    - If --backup is combined with --delete without --backup-dir (and without
-      --delete-excluded), we add a "protect" filter-rule to ensure that files
-      with the backup suffix are not deleted.
-
-    - The file-count stats that are output by --progress were improved to
-      better indicate what the numbers mean.  For instance, the output:
-      "(xfer#5, to-check=8383/9999)" indicates that this was the fifth file
-      to be transferred, and we still need to check 8383 more files out of
-      a total of 9999.
-
-    - The include/exclude code now allows a dir/*** directive (with 3 trailing
-      stars) to match both the dir itself as well as all the content below the
-      dir (dir/** would not match the dir).
-
-    - Added the --prune-empty-dirs (-m) option that makes the receiving rsync
-      discard empty chains of directories from the file-list.  This makes it
-      easier to selectively copy files from a source hierarchy and end up with
-      just the directories needed to hold the resulting files.
-
-    - If the --itemize-changes (-i) option is repeated, rsync now includes
-      unchanged files in the itemized output (similar to -vv, but without all
-      the other verbose messages that can get in the way).  Of course, the
-      client must be version 2.6.7 for this to work, but the remote rsync only
-      needs to be 2.6.7 if you're pushing files.
-
-    - Added the --specials option to tell rsync to copy non-device special
-      files (which rsync now attempts even as a normal user).  The --devices
-      option now requests the copying of just devices (character and block).
-      The -D option still requests both (e.g. --devices and --specials), -a
-      still implies -D, and non-root users still get a silent downgrade that
-      omits device copying.
-
-    - Added the --super option to make the receiver always attempt super-user
-      activities.  This is useful for systems that allow things such as devices
-      to be created or ownership to be set without being UID 0, and is also
-      useful for someone who wants to ensure that errors will be output if the
-      receiving rsync isn't being run as root.
-
-    - Added the --sockopts option for those few who want to customize the TCP
-      options used to contact a daemon rsync.
-
-    - Added a way for the --temp-dir option to be combined with a partial-dir
-      setting that lets rsync avoid non-atomic updates (for those times when
-      --temp-dir is not being used because space is tight).
-
-    - A new support script, files-to-excludes, will transform a list of files
-      into a set of include/exclude directives that will copy those files.
-
-    - A new option, --executability (-E) can be used to preserve just the
-      execute bit on files, for those times when using the --perms option is
-      not desired.
-
-    - The daemon now logs each connection and also each module-list request
-      that it receives.
-
-    - New log-format options: %M (modtime), %U (uid), %G (gid), and %B
-      (permission bits, e.g. "rwxr-xrwt").
-
-    - The --dry-run option no longer forces the enabling of --verbose.
-
-    - The --remove-sent-files option now does a better job of incrementally
-      removing the sent files on the sending side (older versions tended to
-      clump up all the removals at the end).
-
-    - A daemon now supersedes its minimal SIGCHLD handler with the standard
-      PID-remembering version after forking.  This ensures that the generator
-      can get the child-exit status from the receiver.
-
-    - Use of the --bwlimit option no longer interferes with the remote rsync
-      sending error messages about invalid/refused options.
-
-    - Rsync no longer returns a usage error when used with one local source arg
-      and no destination: this now implies the --list-only option, just like
-      the comparable situation with a remote source arg.
-
-    - Added the --copy-dirlinks option, a more limited version of --copy-links.
-
-    - Various documentation improvements, including: a better synopsis, some
-      improved examples, a better discussion of the presence and absence of
-      --perms (including how it interacts with the new --executability and
-      --chmod options), an extended discussion of --temp-dir, an improved
-      discussion of --partial-dir, a better description of rsync's pattern
-      matching characters, an improved --no-implied-dirs section, and the
-      documenting of what the --stats option outputs.
-
-    - Various new and updated diffs in the patches dir, including: acls.diff,
-      xattrs.diff, atimes.diff, detect-renamed.diff, and slp.diff.
-
-  INTERNAL:
-
-    - We now use sigaction() and sigprocmask() if possible, and fall back on
-      signal() if not.  Using sigprocmask() ensures that rsync enables all the
-      signals that it needs, just in case it was started in a masked state.
-
-    - Some buffer sizes were expanded a bit, particularly on systems where
-      MAXPATHLEN is overly small (e.g. cygwin).
-
-    - If io_printf() tries to format more data than fits in the buffer, exit
-      with an error instead of transmitting a truncated buffer.
-
-    - If a va_copy macro is defined, lib/snprintf.c will use it when defining
-      the VA_COPY macro.
-
-    - Reduced the amount of stack memory needed for each level of directory
-      recursion by nearly MAXPATHLEN bytes.
-
-    - The wildmatch function was extended to allow an array of strings to be
-      supplied as the string to match.  This allows the exclude code to do less
-      string copying.
-
-    - Got rid of the safe_fname() function (and all the myriad calls) and
-      replaced it with a new function in the log.c code that filters all the
-      output going to the terminal.
+  DEVELOPER RELATED:
 
-    - Unified the f_name() and the f_name_to() functions.
+    - Removed the unused function write_int_named(), the unused variable
+      io_read_phase, and the rarely used variable io_write_phase.  This also
+      elides the confusing 'phase "unknown"' part of one error message.
 
-    - Improved the hash-table code the sender uses to handle checksums to make
-      it use slightly less memory and run just a little faster.
+    - Removed two unused configure checks and two related (also unused)
+      compatibility functions.
 
-  DEVELOPER RELATED:
+    - The xattrs.diff patch received a security fix that prevents a potential
+      buffer overflow in the receive_xattr() code.
 
-    - The diffs in the patches dir now require "patch -p1 <DIFF" instead of
-      the previous -p0.  Also, the version included in the release tar now
-      affect generated files (e.g. configure, rsync.1, proto.h, etc.), so
-      it is no longer necessary to run autoconf and/or yodl unless you're
-      applying a patch that was checked out from CVS.
-
-    - Several diffs in the patches dir now use the proper --enable-FOO
-      configure option instead of --with-FOO to turn on the inclusion of
-      the newly patched feature.
-
-    - There is a new script, "prepare-source" than can be used to update the
-      various generated files (proto.h, configure, etc.) even before configure
-      has created the Makefile (this is mainly useful when patching the source
-      with a patch that doesn't affect generated files).
+    - The acls.diff patch has been improved quite a bit, with more to come.
 
-    - The testsuite now sets HOME so that it won't be affected by a file such
-      as ~/.popt.
+    - A new patch was added: log-file.diff.  This contains an early version of
+      a future option, --log-file=FILE, that will allow any rsync to log its
+      actions to a file (something that only a daemon supports at present).
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/OLDNEWS	2006-03-12 02:25:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/OLDNEWS	2006-04-22 23:38:34.000000000 +0800
@@ -1,6 +1,327 @@
+NEWS for rsync 2.6.7 (11 Mar 2006)
+Protocol: 29 (unchanged)
+Changes since 2.6.6:
+
+  OUTPUT CHANGES:
+
+    - The letter 'D' in the itemized output was being used for both devices
+      (character or block) as well as other special files (such as fifos and
+      named sockets).  This has changed to separate non-device special files
+      under the 'S' designation (e.g. "cS+++++++ path/fifo").  See also the
+      "--specials" option, below.
+
+    - The way rsync escapes unreadable characters has changed.  First, rsync
+      now has support for recognizing valid multibyte character sequences in
+      your current locale, allowing it to escape fewer characters than before
+      for a locale such as UTF-8.  Second, it now uses an escape idiom of
+      "\#123", which is the literal string "\#" followed by exactly 3 octal
+      digits.  Rsync no longer doubles a backslash character in a filename
+      (e.g. it used to output "foo\\bar" when copying "foo\bar") -- now it only
+      escapes a backslash that is followed by a hash-sign and 3 digits (0-9)
+      (e.g. it will output "foo\#134#789" when copying "foo\#789").  See also
+      the --8-bit-output (-8) option, mentioned below.
+
+      Script writers: the local rsync is the one that outputs escaped names,
+      so if you need to support unescaping of filenames for older rsyncs, I'd
+      suggest that you parse the output of "rsync --version" and only use the
+      old unescaping rules for 2.6.5 and 2.6.6.
+
+  BUG FIXES:
+
+    - Fixed a really old bug that caused --checksum (-c) to checksum all the
+      files encountered during the delete scan (ouch).
+
+    - Fixed a potential hang in a remote generator:  when the receiver gets a
+      read-error on the socket, it now signals the generator about this so that
+      the generator does not try to send any of the terminating error messages
+      to the client (avoiding a potential hang in some setups).
+
+    - Made hard-links work with symlinks and devices again.
+
+    - If the sender gets an early EOF reading a source file, we propagate this
+      error to the receiver so that it can discard the file and try requesting
+      it again (which is the existing behavior for other kinds of read errors).
+
+    - If a device-file/special-file changes permissions, rsync now updates the
+      permissions without recreating the file.
+
+    - If the user specifies a remote-host for both the source and destination,
+      we now output a syntax error rather than trying to open the destination
+      hostspec as a filename.
+
+    - When --inplace creates a new destination file, rsync now creates it with
+      permissions 0600 instead of 0000 -- this makes restarting possible when
+      the transfer gets interrupted in the middle of sending a new file.
+
+    - Reject the combination of --inplace and --sparse since the sparse-output
+      algorithm doesn't work when overwriting existing data.
+
+    - Fixed the directory name in the error that is output when pop_dir()
+      fails.
+
+    - Really fixed the parsing of a "!" entry in .cvsignore files this time.
+
+    - If the generator gets a stat() error on a file, output it (this used to
+      require at least -vv for the error to be seen).
+
+    - If waitpid() fails or the child rsync didn't exit cleanly, we now handle
+      the exit status properly and generate a better error.
+
+    - Fixed some glitches in the double-verbose output when using --copy-dest,
+      --link-dest, or --compare-dest.  Also improved how the verbose output
+      handles hard-links (within the transfer) that had an up-to-date alternate
+      "dest" file, and copied files (via --copy-dest).
+
+    - Fixed the matching of the dont-compress items (e.g. *.gz) against files
+      that have a path component containing a slash.
+
+    - If code reading a filter/exclude file an EINTR error, rsync now clears
+      the error flag on the file handle so it can keep on reading.
+
+    - If --relative is active, the sending side cleans up trailing "/" or "/."
+      suffixes to avoid triggering a bug in older rsync versions.  Also, we now
+      reject a ".." dir if it would be sent as a relative dir.
+
+    - If a non-directory is in the way of a directory and rsync is run with
+      --dry-run and --delete, rsync no longer complains about not being able
+      to opendir() the not-yet present directory.
+
+    - When --list-only is used and a non-existent local destination dir was
+      also specified as a destination, rsync no longer generates a warning
+      about being unable to create the missing directory.
+
+    - Fixed some problems with --relative --no-implied-dirs when the
+      destination directory did not yet exist:  we can now create a symlink or
+      device when it is the first thing in the missing dir, and --fuzzy no
+      longer complains about being unable to open the missing dir.
+
+    - Fixed a bug where the --copy-links option would not affect implied
+      directories without --copy-unsafe-links (see --relative).
+
+    - Got rid of the need for --force to be used in some circumstances with
+      --delete-after (making it consistent with --delete-before/-during).
+
+    - Rsync now ignores the SIGXFSZ signal, just in case your OS sends this
+      when a file is too large (rsync handles the write error).
+
+    - Fixed a bug in the Proxy-Authorization header's base64-encoded value: it
+      was not properly padded with trailing '=' chars.  This only affects a
+      user that need to use a password-authenticated proxy for an outgoing
+      daemon-rsync connection.
+
+    - If we're transferring an empty directory to a new name, rsync no longer
+      forces S_IWUSR if it wasn't already set, nor does it accidentally leave
+      it set.
+
+    - Fixed a bug in the debug output (-vvvvv) that could mention the wrong
+      checksum for the current file offset.
+
+    - Rsync no longer allows a single directory to be copied over a non-
+      directory destination arg.
+
+  ENHANCEMENTS:
+
+    - Added the --append option that makes rsync append data onto files that
+      are longer on the source than the destination (this includes new files).
+
+    - Added the --min-size=SIZE option to exclude small files from the
+      transfer.
+
+    - Added the --compress-level option to allow you to set how aggressive
+      rsync's compression should be (this option implies --compress).
+
+    - Enhanced the parsing of the SIZE value for --min-size and --max-size to
+      allow easy entry of multiples of 1000 (instead of just multiples of 1024)
+      and off-by-one values too (e.g. --max-size=8mb-1).
+
+    - Added the --8-bit-output (-8) option, which tells rsync to avoid escaping
+      high-bit characters that it thinks are unreadable in the current locale.
+
+    - The new option --human-readable (-h) changes the output of --progress,
+      --stats, and the end-of-run summary to be easier to read.  If repeated,
+      the units become powers of 1024 instead of powers of 1000.  (The old
+      meaning of -h, as a shorthand for --help, still works as long as you
+      just use it on its own, as in "rsync -h".)
+
+    - If lutimes() and/or lchmod() are around, use them to allow the
+      preservation of attributes on symlinks.
+
+    - The --link-dest option now affects symlinks and devices (when possible).
+
+    - Added two config items to the rsyncd.conf parsing:  "pre-xfer exec" and
+      "post-xfer exec".  These allow a command to be specified on a per-module
+      basis that will be run before and/or after a daemon-mode transfer.  (See
+      the man page for a list of the environment variables that are set with
+      information about the transfer.)
+
+    - When using the --relative option, you can now insert a dot dir in
+      the source path to indicate where the replication of the source dirs
+      should start.  For example, if you specify a source path of
+      rsync://host/module/foo/bar/./baz/dir with -R, rsync will now only
+      replicate the "baz/dir" part of the source path (note: a trailing
+      dot dir is unaffected unless it also has a trailing slash).
+
+    - Added some new --no-FOO options that make it easier to override unwanted
+      implied or default options.  For example, "-a --no-o" (aka "--archive
+      --no-owner") can be used to turn off the preservation of file ownership
+      that is implied by -a.
+
+    - Added the --chmod=MODE option that allows the destination permissions to
+      be changed from the source permissions.  E.g. --chmod=g+w,o-rwx
+
+    - Added the "incoming chmod" and "outgoing chmod" daemon options that allow
+      a module to specify what permissions changes should be applied to all
+      files copied to and from the daemon.
+
+    - Allow the --temp-dir option to be specified when starting a daemon, which
+      sets the default temporary directory for incoming files.
+
+    - If --delete is combined with --dirs without --recursive, rsync will now
+      delete in any directory whose content is being synchronized.
+
+    - If --backup is combined with --delete without --backup-dir (and without
+      --delete-excluded), we add a "protect" filter-rule to ensure that files
+      with the backup suffix are not deleted.
+
+    - The file-count stats that are output by --progress were improved to
+      better indicate what the numbers mean.  For instance, the output:
+      "(xfer#5, to-check=8383/9999)" indicates that this was the fifth file
+      to be transferred, and we still need to check 8383 more files out of
+      a total of 9999.
+
+    - The include/exclude code now allows a dir/*** directive (with 3 trailing
+      stars) to match both the dir itself as well as all the content below the
+      dir (dir/** would not match the dir).
+
+    - Added the --prune-empty-dirs (-m) option that makes the receiving rsync
+      discard empty chains of directories from the file-list.  This makes it
+      easier to selectively copy files from a source hierarchy and end up with
+      just the directories needed to hold the resulting files.
+
+    - If the --itemize-changes (-i) option is repeated, rsync now includes
+      unchanged files in the itemized output (similar to -vv, but without all
+      the other verbose messages that can get in the way).  Of course, the
+      client must be version 2.6.7 for this to work, but the remote rsync only
+      needs to be 2.6.7 if you're pushing files.
+
+    - Added the --specials option to tell rsync to copy non-device special
+      files (which rsync now attempts even as a normal user).  The --devices
+      option now requests the copying of just devices (character and block).
+      The -D option still requests both (e.g. --devices and --specials), -a
+      still implies -D, and non-root users still get a silent downgrade that
+      omits device copying.
+
+    - Added the --super option to make the receiver always attempt super-user
+      activities.  This is useful for systems that allow things such as devices
+      to be created or ownership to be set without being UID 0, and is also
+      useful for someone who wants to ensure that errors will be output if the
+      receiving rsync isn't being run as root.
+
+    - Added the --sockopts option for those few who want to customize the TCP
+      options used to contact a daemon rsync.
+
+    - Added a way for the --temp-dir option to be combined with a partial-dir
+      setting that lets rsync avoid non-atomic updates (for those times when
+      --temp-dir is not being used because space is tight).
+
+    - A new support script, files-to-excludes, will transform a list of files
+      into a set of include/exclude directives that will copy those files.
+
+    - A new option, --executability (-E) can be used to preserve just the
+      execute bit on files, for those times when using the --perms option is
+      not desired.
+
+    - The daemon now logs each connection and also each module-list request
+      that it receives.
+
+    - New log-format options: %M (modtime), %U (uid), %G (gid), and %B
+      (permission bits, e.g. "rwxr-xrwt").
+
+    - The --dry-run option no longer forces the enabling of --verbose.
+
+    - The --remove-sent-files option now does a better job of incrementally
+      removing the sent files on the sending side (older versions tended to
+      clump up all the removals at the end).
+
+    - A daemon now supersedes its minimal SIGCHLD handler with the standard
+      PID-remembering version after forking.  This ensures that the generator
+      can get the child-exit status from the receiver.
+
+    - Use of the --bwlimit option no longer interferes with the remote rsync
+      sending error messages about invalid/refused options.
+
+    - Rsync no longer returns a usage error when used with one local source arg
+      and no destination: this now implies the --list-only option, just like
+      the comparable situation with a remote source arg.
+
+    - Added the --copy-dirlinks option, a more limited version of --copy-links.
+
+    - Various documentation improvements, including: a better synopsis, some
+      improved examples, a better discussion of the presence and absence of
+      --perms (including how it interacts with the new --executability and
+      --chmod options), an extended discussion of --temp-dir, an improved
+      discussion of --partial-dir, a better description of rsync's pattern
+      matching characters, an improved --no-implied-dirs section, and the
+      documenting of what the --stats option outputs.
+
+    - Various new and updated diffs in the patches dir, including: acls.diff,
+      xattrs.diff, atimes.diff, detect-renamed.diff, and slp.diff.
+
+  INTERNAL:
+
+    - We now use sigaction() and sigprocmask() if possible, and fall back on
+      signal() if not.  Using sigprocmask() ensures that rsync enables all the
+      signals that it needs, just in case it was started in a masked state.
+
+    - Some buffer sizes were expanded a bit, particularly on systems where
+      MAXPATHLEN is overly small (e.g. cygwin).
+
+    - If io_printf() tries to format more data than fits in the buffer, exit
+      with an error instead of transmitting a truncated buffer.
+
+    - If a va_copy macro is defined, lib/snprintf.c will use it when defining
+      the VA_COPY macro.
+
+    - Reduced the amount of stack memory needed for each level of directory
+      recursion by nearly MAXPATHLEN bytes.
+
+    - The wildmatch function was extended to allow an array of strings to be
+      supplied as the string to match.  This allows the exclude code to do less
+      string copying.
+
+    - Got rid of the safe_fname() function (and all the myriad calls) and
+      replaced it with a new function in the log.c code that filters all the
+      output going to the terminal.
+
+    - Unified the f_name() and the f_name_to() functions.
+
+    - Improved the hash-table code the sender uses to handle checksums to make
+      it use slightly less memory and run just a little faster.
+
+  DEVELOPER RELATED:
+
+    - The diffs in the patches dir now require "patch -p1 <DIFF" instead of
+      the previous -p0.  Also, the version included in the release tar now
+      affect generated files (e.g. configure, rsync.1, proto.h, etc.), so
+      it is no longer necessary to run autoconf and/or yodl unless you're
+      applying a patch that was checked out from CVS.
+
+    - Several diffs in the patches dir now use the proper --enable-FOO
+      configure option instead of --with-FOO to turn on the inclusion of
+      the newly patched feature.
+
+    - There is a new script, "prepare-source" than can be used to update the
+      various generated files (proto.h, configure, etc.) even before configure
+      has created the Makefile (this is mainly useful when patching the source
+      with a patch that doesn't affect generated files).
+
+    - The testsuite now sets HOME so that it won't be affected by a file such
+      as ~/.popt.
+
+
 NEWS for rsync 2.6.6 (28 Jul 2005)
 Protocol: 29 (unchanged)
 Changes since 2.6.5:
 
   SECURITY FIXES:
 
@@ -767,12 +1088,14 @@
       with an error instead of waiting for the connection to finish.
 
     - Fixed an ssh interaction that could cause output to be lost when the
       user chose to combine the output of rsync's stdout and stderr (e.g.
       using the "2>&1").
 
+    - Fixed an option-parsing bug when --files-from got passed to a daemon.
+
   ENHANCEMENTS:
 
     - Added the --partial-dir=DIR option that lets you specify where to
       (temporarily) put a partially transferred file (instead of over-
       writing the destination file).  E.g.  --partial-dir=.rsync-partial
       Also added support for the RSYNC_PARTIAL_DIR environment variable
@@ -1033,12 +1356,15 @@
       now has improved support for IPv6 addresses and a fix for systems
       that have a length field in their socket structs.
 
     - Fixed the ability to request an empty backup --suffix when sending
       files to an rsync daemon.
 
+    - Fixed an option-parsing bug when --files-from was sent to a server
+      sender.
+
   INTERNAL:
 
     - Most of the I/O is now buffered, which results in a pretty large
       speedup when running under MS Windows.  (Craig Barratt)
 
     - Optimizations to the name-handling/comparing code have made some
@@ -1684,12 +2010,13 @@
     * The existing test.sh script by Phil Hands has been merged into a
       test framework that works from both "make check" and the Samba
       build farm.
 
 Partial Protocol History
 	RELEASE DATE	VER.	DATE OF COMMIT*	PROTOCOL
+	22 Apr 2006	2.6.8			29
 	11 Mar 2006	2.6.7			29
 	28 Jul 2005	2.6.6			29
 	01 Jun 2005	2.6.5			29
 	30 Mar 2005	2.6.4	17 Jan 2005	29
 	30 Sep 2004	2.6.3			28
 	30 Apr 2004	2.6.2			28
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/options.c	2006-02-28 07:35:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/options.c	2006-03-29 07:09:36.000000000 +0800
@@ -55,14 +55,12 @@
 int omit_dir_times = 0;
 int update_only = 0;
 int cvs_exclude = 0;
 int dry_run = 0;
 int do_xfers = 1;
 int ignore_times = 0;
-int saw_delete_opt = 0;
-int saw_delete_excluded_opt = 0;
 int delete_mode = 0;
 int delete_during = 0;
 int delete_before = 0;
 int delete_after = 0;
 int delete_excluded = 0;
 int remove_sent_files = 0;
@@ -1175,17 +1173,16 @@
 		if (refused_delete_before) {
 			create_refuse_error(refused_delete_before);
 			return 0;
 		}
 		delete_mode = delete_before = 1;
 	}
-	saw_delete_opt = delete_mode;
-	saw_delete_excluded_opt = delete_excluded;
-	if (!xfer_dirs) {
-		delete_before = delete_during = delete_after = 0;
-		delete_mode = delete_excluded = 0;
+	if (!xfer_dirs && delete_mode) {
+		snprintf(err_buf, sizeof err_buf,
+			"--delete does not work without -r or -d.\n");
+		return 0;
 	}
 
 	if (delete_mode && refused_delete) {
 		create_refuse_error(refused_delete);
 		return 0;
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging/lsb/rsync.spec	2006-03-12 02:25:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/packaging/lsb/rsync.spec	2006-04-22 23:38:34.000000000 +0800
@@ -1,9 +1,9 @@
 Summary: A program for synchronizing files over a network.
 Name: rsync
-Version: 2.6.7
+Version: 2.6.8
 Release: 1
 Group: Applications/Internet
 Source:	ftp://rsync.samba.org/pub/rsync/rsync-%{version}.tar.gz
 URL: http://rsync.samba.org/
 
 Prefix: %{_prefix}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging/nightly-rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/packaging/nightly-rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging/nightly-rsync	2006-02-21 02:35:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/packaging/nightly-rsync	2006-04-09 00:36:57.000000000 +0800
@@ -95,13 +95,13 @@
 
 system "find . -name 'rsync-HEAD-*' -daystart -mtime +14 | xargs rm -f";
 system 'ls -ltr';
 
 if ($upload) {
     $ENV{RSYNC_PARTIAL_DIR} = ''; # The rsync on samba.org is OLD.
-    system "rsync -aviHP --delete . samba.org:/home/ftp/pub/rsync/nightly";
+    system "rsync -aviHP --delete-after . samba.org:/home/ftp/pub/rsync/nightly";
 }
 
 exit;
 
 sub usage
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging/release-rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/packaging/release-rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging/release-rsync	2006-03-04 16:21:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/packaging/release-rsync	2006-04-18 14:43:17.000000000 +0800
@@ -160,13 +160,13 @@
 	s/^(Version:) .*/$1 $version/m;
 	s/^(Release:) .*/$1 $release/m;
     } elsif ($fn =~ /\.yo/) {
 	s/^(manpage\([^)]+\)\(\d+\)\()[^)]+(\).*)/$1$today$2/m;
 	s/^(This man ?page is current for version) \S+ (of rsync)/$1 $version $2/m;
     } else {
-	s/^(NEWS for rsync \Q$version\E) \(UNRELEASED\)\s*$/$1 ($today)\n/m;
+	s/^(NEWS for rsync \Q$version\E) \(UNRELEASED\)\s*\n/$1 ($today)\n/m;
 	s/^\t\S\S\s\S\S\S\s\d\d\d\d(\t\Q$version\E)/\t$ztoday$1/m;
     }
     open(OUT, '>', $fn) or die $!;
     print OUT $_;
     close OUT;
 }
@@ -202,24 +202,27 @@
 
 if (!/skip/i) {
     print "\n", $break, $note, $break;
     system "patches/verify-patches -pun -an";
 }
 
-my $tar_file = "$dest/rsync-$version.tar.gz";
-my $diff_file = "$dest/rsync-$lastversion-$version.diffs.gz";
+my $tar_name = "rsync-$version.tar.gz";
+my $diff_name = "rsync-$lastversion-$version.diffs.gz";
+my $tar_file = "$dest/$tar_name";
+my $diff_file = "$dest/$diff_name";
 
 print $break, <<EOT;
 
 About to do the following in the samba-rsync-ftp dir:
     - move the old tar/diff files into the appropriate old-* dirs
-    - hard-link moved tar/diff files to old files on samba.org$skipping
-    - create release tar, "$tar_file"
-    - create release diffs, "$diff_file"
+    - copy the moved tar/diff files on samba.org$skipping
+    - create release tar, "$tar_name"
+    - create release diffs, "$diff_name"
     - update README, *NEWS, TODO, and cvs.log
     - update rsync*.html man pages
+    - gpg-sign the release files$skipping
 
 EOT
 print "<Press Enter to continue> ";
 $_ = <STDIN>;
 
 chdir($releasedir) or die $!;
@@ -256,18 +259,18 @@
 	    rename($fn, $new_fn) or die $!;
 	    push(@moved_files, $new_fn);
 	}
     }
 
     # Optimize our future upload (in the absence of --detect-renamed) by
-    # hard-linking the above moved files on the remote server.
+    # copying the above moved files on the remote server.
     if ($live) {
 	my $remote_cmd = '';
 	foreach (@moved_files) {
 	    my($path, $fn) = m#(.*)/([^/]+)$#;
-	    $remote_cmd .= "ln -f /home/ftp/pub/rsync/{$fn,$path};";
+	    $remote_cmd .= "cp -p /home/ftp/pub/rsync/{$fn,$path};";
 	}
 	system "ssh samba.org '$remote_cmd'";
     }
     foreach (glob("rsync*pre*.diffs.gz*")) {
 	unlink($_);
     }
@@ -303,15 +306,15 @@
 system "yodl2html -o $dest/rsyncd.conf.html rsync-$version/rsyncd.conf.yo";
 
 system "rm -rf rsync-*";
 
 if ($live) {
     chdir($dest) or die $!;
-    system "gpg -ba rsync-$version.tar.gz";
-    system "gpg -ba rsync-$lastversion-$version.diffs.gz";
-}
-
-print $break, <<EOT;
+    system "gpg -ba $tar_name; gpg -ba $diff_name";
+    print $break, <<EOT;
 
 All done.  Remember to announce the release on *BOTH*
 rsync-announce\@lists.samba.org and rsync\@lists.samba.org!
 EOT
+} else {
+    print $break, "All done.\n";
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/params.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/params.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/params.c	2006-01-14 05:17:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/params.c	2006-04-02 23:02:02.000000000 +0800
@@ -488,13 +488,13 @@
     return( NULL );
     }
 
   OpenedFile = fopen( FileName, "r" );
   if( NULL == OpenedFile )
     {
-    rsyserr(FERROR, errno, "rsync: unable to open configuration file \"%s\"",
+    rsyserr(FERROR, errno, "unable to open configuration file \"%s\"",
 	    FileName);
     }
 
   return( OpenedFile );
   } /* OpenConfFile */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/acls.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/acls.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/acls.diff	2006-03-12 02:44:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/acls.diff	2006-04-22 23:40:13.000000000 +0800
@@ -1,16 +1,22 @@
 After applying this patch, run these commands for a successful build:
 
     ./prepare-source
     ./configure --enable-acl-support
     make
 
-The program currently complains when the --acls (-A) option is used to copy
-from a disk that doesn't support ACLs.  This should be changed to silently 
-notice that no ACLs are available to copy.  Of course, trying to write out
-ACLs to a non-ACL-supporting disk should complain.
+See the --acls (-A) option in the revised man page for a note on using this
+latest ACL-enabling patch to send files to an older ACL-enabled rsync.
+
+TODO items:
+
+- The -i option does not yet itemize changes in ACL information.
+
+- The --link-dest option might link together two files that differ just
+  in their ACL info, and if that happens the file in the --link-dest dir
+  would get its ACLs updated.
 
 --- old/Makefile.in
 +++ new/Makefile.in
 @@ -25,15 +25,15 @@ VERSION=@VERSION@
  .SUFFIXES:
  .SUFFIXES: .c .o
@@ -29,16 +35,18 @@
 +	fileio.o batch.o clientname.o chmod.o acls.o
  OBJS3=progress.o pipe.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 --- old/acls.c
 +++ new/acls.c
-@@ -0,0 +1,1201 @@
+@@ -0,0 +1,1293 @@
 +/* -*- c-file-style: "linux" -*-
 +   Copyright (C) Andrew Tridgell 1996
 +   Copyright (C) Paul Mackerras 1996
++   Copyright (C) Matt McCutchen 2006
++   Copyright (C) Wayne Davison 2006
 +
 +   This program is free software; you can redistribute it and/or modify
 +   it under the terms of the GNU General Public License as published by
 +   the Free Software Foundation; either version 2 of the License, or
 +   (at your option) any later version.
 +
@@ -56,179 +64,261 @@
 +
 +#include "rsync.h"
 +#include "lib/sysacls.h"
 +
 +#ifdef SUPPORT_ACLS
 +
-+extern int preserve_acls;
 +extern int am_root;
 +extern int dry_run;
 +extern int orig_umask;
++extern int preserve_acls;
 +
 +typedef struct {
 +	id_t id;
 +	uchar access;
-+	SMB_ACL_TAG_T tag_type;
-+} rsync_ace;
++} id_access;
 +
 +typedef struct {
 +	size_t count;
 +	size_t malloced;
-+	rsync_ace *races;
++	id_access *idas;
++} ida_list;
++
++#define ACL_NO_ENTRY ((uchar)0x80)
++typedef struct {
++	ida_list users;
++	ida_list groups;
++	/* These will be ACL_NO_ENTRY if there's no such entry. */
++	uchar user_obj;
++	uchar group_obj;
++	uchar mask;
++	uchar other;
 +} rsync_acl;
 +
-+static const rsync_acl rsync_acl_initializer = { 0, 0, NULL };
++static const rsync_acl rsync_acl_initializer = {
++	{0, 0, NULL}, {0, 0, NULL},
++	ACL_NO_ENTRY, ACL_NO_ENTRY, ACL_NO_ENTRY, ACL_NO_ENTRY
++};
++
++#define OTHER_TYPE(t) (SMB_ACL_TYPE_ACCESS+SMB_ACL_TYPE_DEFAULT-(t))
++#define BUMP_TYPE(t) ((t = OTHER_TYPE(t)) == SMB_ACL_TYPE_DEFAULT)
++
++/* a few useful calculations */
++
++static int count_racl_entries(const rsync_acl *racl)
++{
++	return racl->users.count + racl->groups.count
++	     + (racl->user_obj != ACL_NO_ENTRY)
++	     + (racl->group_obj != ACL_NO_ENTRY)
++	     + (racl->mask != ACL_NO_ENTRY)
++	     + (racl->other != ACL_NO_ENTRY);
++}
++
++static int calc_sacl_entries(const rsync_acl *racl)
++{
++	return racl->users.count + racl->groups.count
++#ifdef ACLS_NEED_MASK
++	     + 4;
++#else
++	     + (racl->mask != ACL_NO_ENTRY) + 3;
++#endif
++}
++
++static int rsync_acl_get_perms(const rsync_acl *racl)
++{
++	/* Note that (ACL_NO_ENTRY & 7) is 0. */
++	return ((racl->user_obj & 7) << 6)
++	     + (((racl->mask != ACL_NO_ENTRY ? racl->mask : racl->group_obj) & 7) << 3)
++	     + (racl->other & 7);
++}
++
++static void rsync_acl_strip_perms(rsync_acl *racl)
++{
++	racl->user_obj = ACL_NO_ENTRY;
++	if (racl->mask == ACL_NO_ENTRY)
++		racl->group_obj = ACL_NO_ENTRY;
++	else
++		racl->mask = ACL_NO_ENTRY;
++	racl->other = ACL_NO_ENTRY;
++}
 +
-+static void expand_rsync_acl(rsync_acl *racl)
++static void expand_ida_list(ida_list *idal)
 +{
-+	/* First time through, 0 <= 0, so list is expanded.
-+	 * (Diabolical, rsync guys!) */
-+	if (racl->malloced <= racl->count) {
-+		rsync_ace *new_ptr;
-+		size_t new_size = racl->malloced + 10;
-+		new_ptr = realloc_array(racl->races, rsync_ace, new_size);
++	/* First time through, 0 <= 0, so list is expanded. */
++	if (idal->malloced <= idal->count) {
++		id_access *new_ptr;
++		size_t new_size = idal->malloced + 10;
++		new_ptr = realloc_array(idal->idas, id_access, new_size);
 +		if (verbose >= 4) {
 +			rprintf(FINFO, "expand rsync_acl to %.0f bytes, did%s move\n",
-+				(double) new_size * sizeof racl->races[0],
-+				racl->races ? "" : " not");
++				(double) new_size * sizeof idal->idas[0],
++				idal->idas ? "" : " not");
 +		}
 +
-+		racl->races = new_ptr;
-+		racl->malloced = new_size;
++		idal->idas = new_ptr;
++		idal->malloced = new_size;
 +
-+		if (!racl->races)
-+			out_of_memory("expand_rsync_acl");
++		if (!idal->idas)
++			out_of_memory("expand_ida_list");
 +	}
 +}
 +
++static void ida_list_free(ida_list *idal)
++{
++	free(idal->idas);
++	idal->idas = NULL;
++	idal->count = 0;
++	idal->malloced = 0;
++}
++
 +static void rsync_acl_free(rsync_acl *racl)
 +{
-+	free(racl->races);
-+	racl->races = NULL;
-+	racl->count = 0;
-+	racl->malloced = 0;
-+}
-+
-+static int rsync_ace_sorter(const void *r1, const void *r2)
-+{
-+	rsync_ace *race1 = (rsync_ace *)r1;
-+	SMB_ACL_TAG_T rtag1 = race1->tag_type;
-+	id_t rid1 = race1->id;
-+	rsync_ace *race2 = (rsync_ace *)r2;
-+	SMB_ACL_TAG_T rtag2 = race2->tag_type;
-+	id_t rid2 = race2->id;
-+	/* start at the extrema */
-+	if (rtag1 == SMB_ACL_USER_OBJ || rtag2 == SMB_ACL_MASK)
-+		return -1;
-+	if (rtag2 == SMB_ACL_USER_OBJ || rtag1 == SMB_ACL_MASK)
-+		return 1;
-+	/* work inwards */
-+	if (rtag1 == SMB_ACL_OTHER)
-+		return 1;
-+	if (rtag2 == SMB_ACL_OTHER)
-+		return -1;
-+	/* only SMB_ACL_USERs and SMB_ACL_GROUP*s left */
-+	if (rtag1 == SMB_ACL_USER) {
-+		switch (rtag2) {
-+		case SMB_ACL_GROUP:
-+		case SMB_ACL_GROUP_OBJ:
-+		case SMB_ACL_OTHER:
-+			return -1;
-+		}
-+		/* both USER */
-+		return rid1 == rid2 ? 0 : rid1 < rid2 ? -1 : 1;
-+	}
-+	if (rtag2 == SMB_ACL_USER)
-+		return 1;
-+	/* only SMB_ACL_GROUP*s to worry about; kick out GROUP_OBJs first */
-+	if (rtag1 == SMB_ACL_GROUP_OBJ)
-+		return -1;
-+	if (rtag2 == SMB_ACL_GROUP_OBJ)
-+		return 1;
-+	/* only SMB_ACL_GROUPs left */
++	ida_list_free(&racl->users);
++	ida_list_free(&racl->groups);
++}
++
++static int id_access_sorter(const void *r1, const void *r2)
++{
++	id_access *ida1 = (id_access *)r1;
++	id_access *ida2 = (id_access *)r2;
++	id_t rid1 = ida1->id, rid2 = ida2->id;
 +	return rid1 == rid2 ? 0 : rid1 < rid2 ? -1 : 1;
 +}
 +
-+static void sort_rsync_acl(rsync_acl *racl)
++static void sort_ida_list(ida_list *idal)
 +{
-+	if (!racl->count)
++	if (!idal->count)
 +		return;
-+	qsort((void **)racl->races, racl->count, sizeof racl->races[0],
-+	      &rsync_ace_sorter);
++	qsort((void **)idal->idas, idal->count, sizeof idal->idas[0],
++	      &id_access_sorter);
 +}
 +
 +static BOOL unpack_smb_acl(rsync_acl *racl, SMB_ACL_T sacl)
 +{
 +	SMB_ACL_ENTRY_T entry;
-+	int rc;
 +	const char *errfun;
++	int rc;
++
 +	*racl = rsync_acl_initializer;
 +	errfun = "sys_acl_get_entry";
 +	for (rc = sys_acl_get_entry(sacl, SMB_ACL_FIRST_ENTRY, &entry);
 +	     rc == 1;
 +	     rc = sys_acl_get_entry(sacl, SMB_ACL_NEXT_ENTRY, &entry)) {
++		SMB_ACL_TAG_T tag_type;
 +		SMB_ACL_PERMSET_T permset;
++		uchar access;
 +		void *qualifier;
-+		rsync_ace *race;
-+		expand_rsync_acl(racl);
-+		race = &racl->races[racl->count++];
-+		if ((rc = sys_acl_get_tag_type(entry, &race->tag_type))) {
++		id_access *ida;
++		ida_list *idal;
++		if ((rc = sys_acl_get_tag_type(entry, &tag_type))) {
 +			errfun = "sys_acl_get_tag_type";
 +			break;
 +		}
 +		if ((rc = sys_acl_get_permset(entry, &permset))) {
 +			errfun = "sys_acl_get_tag_type";
 +			break;
 +		}
-+		race->access = (sys_acl_get_perm(permset, SMB_ACL_READ) ? 4 : 0)
-+			     | (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? 2 : 0)
-+			     | (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? 1 : 0);
-+		switch (race->tag_type) {
++		access = (sys_acl_get_perm(permset, SMB_ACL_READ) ? 4 : 0)
++		       | (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? 2 : 0)
++		       | (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? 1 : 0);
++		/* continue == done with entry; break == store in given idal */
++		switch (tag_type) {
++		case SMB_ACL_USER_OBJ:
++			if (racl->user_obj == ACL_NO_ENTRY)
++				racl->user_obj = access;
++			else
++				rprintf(FINFO, "unpack_smb_acl: warning: duplicate USER_OBJ entry ignored\n");
++			continue;
 +		case SMB_ACL_USER:
++			idal = &racl->users;
++			break;
++		case SMB_ACL_GROUP_OBJ:
++			if (racl->group_obj == ACL_NO_ENTRY)
++				racl->group_obj = access;
++			else
++				rprintf(FINFO, "unpack_smb_acl: warning: duplicate GROUP_OBJ entry ignored\n");
++			continue;
 +		case SMB_ACL_GROUP:
++			idal = &racl->groups;
 +			break;
++		case SMB_ACL_MASK:
++			if (racl->mask == ACL_NO_ENTRY)
++				racl->mask = access;
++			else
++				rprintf(FINFO, "unpack_smb_acl: warning: duplicate MASK entry ignored\n");
++			continue;
++		case SMB_ACL_OTHER:
++			if (racl->other == ACL_NO_ENTRY)
++				racl->other = access;
++			else
++				rprintf(FINFO, "unpack_smb_acl: warning: duplicate OTHER entry ignored\n");
++			continue;
 +		default:
++			rprintf(FINFO, "unpack_smb_acl: warning: entry with unrecognized tag type ignored\n");
 +			continue;
 +		}
 +		if (!(qualifier = sys_acl_get_qualifier(entry))) {
 +			errfun = "sys_acl_get_tag_type";
 +			rc = EINVAL;
 +			break;
 +		}
-+		race->id = *((id_t *)qualifier);
-+		sys_acl_free_qualifier(qualifier, race->tag_type);
++		expand_ida_list(idal);
++		ida = &idal->idas[idal->count++];
++		ida->id = *((id_t *)qualifier);
++		ida->access = access;
++		sys_acl_free_qualifier(qualifier, tag_type);
 +	}
 +	if (rc) {
 +		rprintf(FERROR, "unpack_smb_acl: %s(): %s\n",
 +			errfun, strerror(errno));
 +		rsync_acl_free(racl);
 +		return False;
 +	}
-+	sort_rsync_acl(racl);
++
++	sort_ida_list(&racl->users);
++	sort_ida_list(&racl->groups);
++
 +	return True;
 +}
 +
-+static BOOL rsync_acls_equal(const rsync_acl *racl1, const rsync_acl *racl2)
++static BOOL ida_lists_equal(const ida_list *ial1, const ida_list *ial2)
 +{
-+	rsync_ace *race1, *race2;
-+	size_t count = racl1->count;
-+	if (count != racl2->count)
++	id_access *ida1, *ida2;
++	size_t count = ial1->count;
++	if (count != ial2->count)
 +		return False;
-+	race1 = racl1->races;
-+	race2 = racl2->races;
-+	for (; count--; race1++, race2++) {
-+		if (race1->tag_type != race2->tag_type
-+		 || race1->access != race2->access
-+		 || ((race1->tag_type == SMB_ACL_USER
-+		   || race1->tag_type == SMB_ACL_GROUP)
-+		  && race1->id != race2->id))
++	ida1 = ial1->idas;
++	ida2 = ial2->idas;
++	for (; count--; ida1++, ida2++) {
++		if (ida1->access != ida2->access || ida1->id != ida2->id)
 +			return False;
 +	}
 +	return True;
 +}
 +
++static BOOL rsync_acls_equal(const rsync_acl *racl1, const rsync_acl *racl2)
++{
++	return (racl1->user_obj == racl2->user_obj
++	     && racl1->group_obj == racl2->group_obj
++	     && racl1->mask == racl2->mask
++	     && racl1->other == racl2->other
++	     && ida_lists_equal(&racl1->users, &racl2->users)
++	     && ida_lists_equal(&racl1->groups, &racl2->groups));
++}
++
++static BOOL rsync_acl_extended_parts_equal(const rsync_acl *racl1, const rsync_acl *racl2)
++{
++	/* We ignore any differences that chmod() can take care of. */
++	if ((racl1->mask ^ racl2->mask) & ACL_NO_ENTRY)
++		return False;
++	if (racl1->mask != ACL_NO_ENTRY && racl1->group_obj != racl2->group_obj)
++		return False;
++	return ida_lists_equal(&racl1->users, &racl2->users)
++	    && ida_lists_equal(&racl1->groups, &racl2->groups);
++}
++
 +typedef struct {
 +	size_t count;
 +	size_t malloced;
 +	rsync_acl *racls;
 +} rsync_acl_list;
 +
@@ -236,20 +326,18 @@
 +	{ 0, 0, NULL }, /* SMB_ACL_TYPE_ACCESS */
 +	{ 0, 0, NULL }  /* SMB_ACL_TYPE_DEFAULT */
 +};
 +
 +static inline rsync_acl_list *rsync_acl_lists(SMB_ACL_TYPE_T type)
 +{
-+	return type == SMB_ACL_TYPE_ACCESS ? &_rsync_acl_lists[0]
-+	    : &_rsync_acl_lists[1];
++	return &_rsync_acl_lists[type != SMB_ACL_TYPE_ACCESS];
 +}
 +
 +static void expand_rsync_acl_list(rsync_acl_list *racl_list)
 +{
-+	/* First time through, 0 <= 0, so list is expanded.
-+	 * (Diabolical, rsync guys!) */
++	/* First time through, 0 <= 0, so list is expanded. */
 +	if (racl_list->malloced <= racl_list->count) {
 +		rsync_acl *new_ptr;
 +		size_t new_size;
 +		if (racl_list->malloced < 1000)
 +			new_size = racl_list->malloced + 1000;
 +		else
@@ -266,177 +354,168 @@
 +
 +		if (!racl_list->racls)
 +			out_of_memory("expand_rsync_acl_list");
 +	}
 +}
 +
-+#if 0
-+static void free_rsync_acl_list(rsync_acl_list *racl_list)
-+{
-+	/* Run this in reverse, so references are freed before referents,
-+	 * although not currently necessary. */
-+	while (racl_list->count--) {
-+		rsync_acl *racl = &racl_list->racls[racl_list->count];
-+		if (racl)
-+			rsync_acl_free(racl);
-+	}
-+	free(racl_list->racls);
-+	racl_list->racls = NULL;
-+	racl_list->malloced = 0;
-+}
-+#endif
-+
 +static int find_matching_rsync_acl(SMB_ACL_TYPE_T type,
 +				   const rsync_acl_list *racl_list,
 +				   const rsync_acl *racl)
 +{
 +	static int access_match = -1, default_match = -1;
-+	int *match = (type == SMB_ACL_TYPE_ACCESS) ?
-+			&access_match : &default_match;
++	int *match = type == SMB_ACL_TYPE_ACCESS ? &access_match : &default_match;
 +	size_t count = racl_list->count;
++
 +	/* If this is the first time through or we didn't match the last
 +	 * time, then start at the end of the list, which should be the
 +	 * best place to start hunting. */
 +	if (*match == -1)
 +		*match = racl_list->count - 1;
 +	while (count--) {
 +		if (rsync_acls_equal(&racl_list->racls[*match], racl))
 +			return *match;
 +		if (!(*match)--)
 +			*match = racl_list->count - 1;
 +	}
++
 +	*match = -1;
 +	return *match;
 +}
 +
 +/* The general strategy with the tag_type <-> character mapping is that
 + * lowercase implies that no qualifier follows, where uppercase does.
 + * A similar idiom for the acl type (access or default) itself, but
 + * lowercase in this instance means there's no ACL following, so the
 + * ACL is a repeat, so the receiver should reuse the last of the same
 + * type ACL. */
++static void send_ida_list(int f, const ida_list *idal, char tag_char)
++{
++	id_access *ida;
++	size_t count = idal->count;
++	for (ida = idal->idas; count--; ida++) {
++		write_byte(f, tag_char);
++		write_byte(f, ida->access);
++		write_int(f, ida->id);
++		/* FIXME: sorta wasteful: we should maybe buffer as
++		 * many ids as max(ACL_USER + ACL_GROUP) objects to
++		 * keep from making so many calls. */
++		if (tag_char == 'U')
++			add_uid(ida->id);
++		else
++			add_gid(ida->id);
++	}
++}
 +
 +static void send_rsync_acl(int f, const rsync_acl *racl)
 +{
-+	rsync_ace *race;
-+	size_t count = racl->count;
++	size_t count = count_racl_entries(racl);
 +	write_int(f, count);
-+	for (race = racl->races; count--; race++) {
-+		char ch;
-+		switch (race->tag_type) {
-+		case SMB_ACL_USER_OBJ:
-+			ch = 'u';
-+			break;
-+		case SMB_ACL_USER:
-+			ch = 'U';
-+			break;
-+		case SMB_ACL_GROUP_OBJ:
-+			ch = 'g';
-+			break;
-+		case SMB_ACL_GROUP:
-+			ch = 'G';
-+			break;
-+		case SMB_ACL_OTHER:
-+			ch = 'o';
-+			break;
-+		case SMB_ACL_MASK:
-+			ch = 'm';
-+			break;
-+		default:
-+			rprintf(FERROR,
-+				"send_rsync_acl: unknown tag_type (%02x) on ACE; disregarding\n",
-+				race->tag_type);
-+			continue;
-+		}
-+		write_byte(f, ch);
-+		write_byte(f, race->access);
-+		if (isupper((int)ch)) {
-+			write_int(f, race->id);
-+			/* FIXME: sorta wasteful: we should maybe buffer as
-+			 * many ids as max(ACL_USER + ACL_GROUP) objects to
-+			 * keep from making so many calls. */
-+			if (ch == 'U')
-+				add_uid(race->id);
-+			else
-+				add_gid(race->id);
-+		}
++	if (racl->user_obj != ACL_NO_ENTRY) {
++		write_byte(f, 'u');
++		write_byte(f, racl->user_obj);
++	}
++	send_ida_list(f, &racl->users, 'U');
++	if (racl->group_obj != ACL_NO_ENTRY) {
++		write_byte(f, 'g');
++		write_byte(f, racl->group_obj);
++	}
++	send_ida_list(f, &racl->groups, 'G');
++	if (racl->mask != ACL_NO_ENTRY) {
++		write_byte(f, 'm');
++		write_byte(f, racl->mask);
++	}
++	if (racl->other != ACL_NO_ENTRY) {
++		write_byte(f, 'o');
++		write_byte(f, racl->other);
 +	}
 +}
 +
 +static rsync_acl _curr_rsync_acls[2];
 +
-+
 +static const char *str_acl_type(SMB_ACL_TYPE_T type)
 +{
-+	return type == SMB_ACL_TYPE_ACCESS ? "SMB_ACL_TYPE_ACCESS" :
-+		type == SMB_ACL_TYPE_DEFAULT ? "SMB_ACL_TYPE_DEFAULT" :
-+		"unknown SMB_ACL_TYPE_T";
++	return type == SMB_ACL_TYPE_ACCESS ? "SMB_ACL_TYPE_ACCESS"
++	     : type == SMB_ACL_TYPE_DEFAULT ? "SMB_ACL_TYPE_DEFAULT"
++	     : "unknown SMB_ACL_TYPE_T";
 +}
 +
 +/* Generate the ACL(s) for this flist entry;
 + * ACL(s) are either sent or cleaned-up by send_acl() below. */
-+
 +int make_acl(const struct file_struct *file, const char *fname)
 +{
-+	SMB_ACL_TYPE_T *type,
-+		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
++	SMB_ACL_TYPE_T type;
 +	rsync_acl *curr_racl;
-+	if (!preserve_acls || S_ISLNK(file->mode))
++
++	if (S_ISLNK(file->mode))
 +		return 1;
-+	for (type = &types[0], curr_racl = &_curr_rsync_acls[0];
-+	     type < &types[0] + sizeof types / sizeof types[0]
-+		&& (*type == SMB_ACL_TYPE_ACCESS || S_ISDIR(file->mode));
-+	     type++, curr_racl++) {
++
++	curr_racl = &_curr_rsync_acls[0];
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
 +		SMB_ACL_T sacl;
 +		BOOL ok;
-+		*curr_racl = rsync_acl_initializer;
-+		if (!(sacl = sys_acl_get_file(fname, *type))) {
++		if ((sacl = sys_acl_get_file(fname, type)) != 0) {
++			ok = unpack_smb_acl(curr_racl, sacl);
++			sys_acl_free_acl(sacl);
++			if (!ok)
++				return -1;
++			/* Avoid sending a redundant group/mask value. */
++			if (curr_racl->group_obj == curr_racl->mask
++			 && (preserve_acls == 1
++			  || (!curr_racl->users.count
++			   && !curr_racl->groups.count)))
++				curr_racl->mask = ACL_NO_ENTRY;
++			/* Strip access ACLs of permission-bit entries. */
++			if (type == SMB_ACL_TYPE_ACCESS && preserve_acls == 1)
++				rsync_acl_strip_perms(curr_racl);
++		} else if (errno == ENOTSUP) {
++			/* ACLs are not supported. Leave list empty. */
++			*curr_racl = rsync_acl_initializer;
++		} else {
 +			rprintf(FERROR, "send_acl: sys_acl_get_file(%s, %s): %s\n",
-+				fname, str_acl_type(*type), strerror(errno));
++				fname, str_acl_type(type), strerror(errno));
 +			return -1;
 +		}
-+		ok = unpack_smb_acl(curr_racl, sacl);
-+		sys_acl_free_acl(sacl);
-+		if (!ok)
-+			return -1;
-+	}
++		curr_racl++;
++	} while (BUMP_TYPE(type) && S_ISDIR(file->mode));
++
 +	return 0;
 +}
 +
 +/* Send the make_acl()-generated ACLs for this flist entry,
 + * or clean up after an flist entry that's not being sent (f == -1). */
-+
 +void send_acl(const struct file_struct *file, int f)
 +{
-+	SMB_ACL_TYPE_T *type,
-+		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
++	SMB_ACL_TYPE_T type;
 +	rsync_acl *curr_racl;
-+	if (!preserve_acls || S_ISLNK(file->mode))
++
++	if (S_ISLNK(file->mode))
 +		return;
-+	for (type = &types[0], curr_racl = &_curr_rsync_acls[0];
-+	     type < &types[0] + sizeof types / sizeof types[0]
-+		&& (*type == SMB_ACL_TYPE_ACCESS || S_ISDIR(file->mode));
-+	     type++, curr_racl++) {
++
++	curr_racl = &_curr_rsync_acls[0];
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
 +		int index;
-+		rsync_acl_list *racl_list = rsync_acl_lists(*type);
++		rsync_acl_list *racl_list = rsync_acl_lists(type);
 +		if (f == -1) {
 +			rsync_acl_free(curr_racl);
 +			continue;
 +		}
-+		if ((index = find_matching_rsync_acl(*type, racl_list, curr_racl))
++		if ((index = find_matching_rsync_acl(type, racl_list, curr_racl))
 +		    != -1) {
-+			write_byte(f, *type == SMB_ACL_TYPE_ACCESS ? 'a' : 'd');
++			write_byte(f, type == SMB_ACL_TYPE_ACCESS ? 'a' : 'd');
 +			write_int(f, index);
 +			rsync_acl_free(curr_racl);
 +		} else {
-+			write_byte(f, *type == SMB_ACL_TYPE_ACCESS ? 'A' : 'D');
++			write_byte(f, type == SMB_ACL_TYPE_ACCESS ? 'A' : 'D');
 +			send_rsync_acl(f, curr_racl);
 +			expand_rsync_acl_list(racl_list);
 +			racl_list->racls[racl_list->count++] = *curr_racl;
 +		}
-+	}
++		curr_racl++;
++	} while (BUMP_TYPE(type) && S_ISDIR(file->mode));
 +}
 +
 +/* The below stuff is only used by the receiver: */
 +
 +/* structure to hold index to rsync_acl_list member corresponding to
 + * flist->files[i] */
@@ -446,61 +525,51 @@
 +	int aclidx;
 +} file_acl_index;
 +
 +typedef struct {
 +	size_t count;
 +	size_t malloced;
-+	file_acl_index *fileaclidxs;
++	file_acl_index *fais;
 +} file_acl_index_list;
 +
 +static file_acl_index_list _file_acl_index_lists[] = {
-+	{0, 0, NULL },/* SMB_ACL_TYPE_ACCESS */
-+	{0, 0, NULL } /* SMB_ACL_TYPE_DEFAULT */
++	{0, 0, NULL }, /* SMB_ACL_TYPE_ACCESS */
++	{0, 0, NULL }  /* SMB_ACL_TYPE_DEFAULT */
 +};
 +
 +static inline file_acl_index_list *file_acl_index_lists(SMB_ACL_TYPE_T type)
 +{
-+	return type == SMB_ACL_TYPE_ACCESS ?
-+		&_file_acl_index_lists[0] : &_file_acl_index_lists[1];
++	return &_file_acl_index_lists[type != SMB_ACL_TYPE_ACCESS];
 +}
 +
-+static void expand_file_acl_index_list(file_acl_index_list *fileaclidx_list)
++static void expand_file_acl_index_list(file_acl_index_list *flst)
 +{
-+	/* First time through, 0 <= 0, so list is expanded.
-+	 * (Diabolical, rsync guys!) */
-+	if (fileaclidx_list->malloced <= fileaclidx_list->count) {
++	/* First time through, 0 <= 0, so list is expanded. */
++	if (flst->malloced <= flst->count) {
 +		file_acl_index *new_ptr;
 +		size_t new_size;
-+		if (fileaclidx_list->malloced < 1000)
-+			new_size = fileaclidx_list->malloced + 1000;
++
++		if (flst->malloced < 1000)
++			new_size = flst->malloced + 1000;
 +		else
-+			new_size = fileaclidx_list->malloced * 2;
-+		new_ptr = realloc_array(fileaclidx_list->fileaclidxs, file_acl_index, new_size);
++			new_size = flst->malloced * 2;
++		new_ptr = realloc_array(flst->fais, file_acl_index, new_size);
 +		if (verbose >= 3) {
 +			rprintf(FINFO, "expand_file_acl_index_list to %.0f bytes, did%s move\n",
-+				(double) new_size * sizeof fileaclidx_list->fileaclidxs[0],
-+				fileaclidx_list->fileaclidxs ? "" : " not");
++				(double) new_size * sizeof flst->fais[0],
++				flst->fais ? "" : " not");
 +		}
 +
-+		fileaclidx_list->fileaclidxs = new_ptr;
-+		fileaclidx_list->malloced = new_size;
++		flst->fais = new_ptr;
++		flst->malloced = new_size;
 +
-+		if (!fileaclidx_list->fileaclidxs)
++		if (!flst->fais)
 +			out_of_memory("expand_file_acl_index_list");
 +	}
 +}
 +
-+#if 0
-+static void free_file_acl_index_list(file_acl_index_list *fileaclidx_list)
-+{
-+	free(fileaclidx_list->fileaclidxs);
-+	fileaclidx_list->fileaclidxs = NULL;
-+	fileaclidx_list->malloced = 0;
-+}
-+#endif
-+
 +/* lists to hold the SMB_ACL_Ts corresponding to the rsync_acl_list entries */
 +
 +typedef struct {
 +	size_t count;
 +	size_t malloced;
 +	SMB_ACL_T *sacls;
@@ -510,20 +579,18 @@
 +	{ 0, 0, NULL }, /* SMB_ACL_TYPE_ACCESS */
 +	{ 0, 0, NULL }  /* SMB_ACL_TYPE_DEFAULT */
 +};
 +
 +static inline smb_acl_list *smb_acl_lists(SMB_ACL_TYPE_T type)
 +{
-+	return type == SMB_ACL_TYPE_ACCESS ? &_smb_acl_lists[0] :
-+		&_smb_acl_lists[1];
++	return &_smb_acl_lists[type != SMB_ACL_TYPE_ACCESS];
 +}
 +
 +static void expand_smb_acl_list(smb_acl_list *sacl_list)
 +{
-+	/* First time through, 0 <= 0, so list is expanded.
-+	 * (Diabolical, rsync guys!) */
++	/* First time through, 0 <= 0, so list is expanded. */
 +	if (sacl_list->malloced <= sacl_list->count) {
 +		SMB_ACL_T *new_ptr;
 +		size_t new_size;
 +		if (sacl_list->malloced < 1000)
 +			new_size = sacl_list->malloced + 1000;
 +		else
@@ -540,366 +607,414 @@
 +
 +		if (!sacl_list->sacls)
 +			out_of_memory("expand_smb_acl_list");
 +	}
 +}
 +
-+#if 0
-+static void free_smb_acl_list(SMB_ACL_TYPE_T type)
++#define CALL_OR_ERROR(func,args,str) \
++	do { \
++		if (func args) { \
++			errfun = str; \
++			goto error_exit; \
++		} \
++	} while (0)
++
++#define COE(func,args) CALL_OR_ERROR(func,args,#func)
++#define COE2(func,args) CALL_OR_ERROR(func,args,NULL)
++
++static int store_access_in_entry(uchar access, SMB_ACL_ENTRY_T entry)
 +{
-+	smb_acl_list *sacl_list = smb_acl_lists(type);
-+	SMB_ACL_T *sacl = sacl_list->sacls;
-+	while (sacl_list->count--) {
-+		if (*sacl)
-+			sys_acl_free_acl(*sacl++);
-+	}
-+	free(sacl_list->sacls);
-+	sacl_list->sacls = NULL;
-+	sacl_list->malloced = 0;
++	const char *errfun = NULL;
++	SMB_ACL_PERMSET_T permset;
++
++	COE( sys_acl_get_permset,(entry, &permset) );
++	COE( sys_acl_clear_perms,(permset) );
++	if (access & 4)
++		COE( sys_acl_add_perm,(permset, SMB_ACL_READ) );
++	if (access & 2)
++		COE( sys_acl_add_perm,(permset, SMB_ACL_WRITE) );
++	if (access & 1)
++		COE( sys_acl_add_perm,(permset, SMB_ACL_EXECUTE) );
++	COE( sys_acl_set_permset,(entry, permset) );
++
++	return 0;
++
++  error_exit:
++	rprintf(FERROR, "store_access_in_entry %s(): %s\n", errfun,
++		strerror(errno));
++	return -1;
 +}
-+#endif
 +
 +/* build an SMB_ACL_T corresponding to an rsync_acl */
 +static BOOL pack_smb_acl(SMB_ACL_T *smb_acl, const rsync_acl *racl)
 +{
-+	size_t count = racl->count;
-+	rsync_ace *race = racl->races;
++	size_t count;
++	id_access *ida;
 +	const char *errfun = NULL;
-+	*smb_acl = sys_acl_init(count);
-+	if (!*smb_acl) {
-+		rprintf(FERROR, "pack_smb_acl: sys_acl_int(): %s\n",
++	SMB_ACL_ENTRY_T entry;
++
++	if (!(*smb_acl = sys_acl_init(calc_sacl_entries(racl)))) {
++		rprintf(FERROR, "pack_smb_acl: sys_acl_init(): %s\n",
 +			strerror(errno));
 +		return False;
 +	}
-+	for (; count--; race++) {
-+		SMB_ACL_ENTRY_T entry;
-+		SMB_ACL_PERMSET_T permset;
-+		if (sys_acl_create_entry(smb_acl, &entry)) {
-+			errfun = "sys_acl_create)";
++
++	COE( sys_acl_create_entry,(smb_acl, &entry) );
++	COE( sys_acl_set_tag_type,(entry, SMB_ACL_USER_OBJ) );
++	COE2( store_access_in_entry,(racl->user_obj & 7, entry) );
++
++	for (ida = racl->users.idas, count = racl->users.count;
++	     count--; ida++) {
++		COE( sys_acl_create_entry,(smb_acl, &entry) );
++		COE( sys_acl_set_tag_type,(entry, SMB_ACL_USER) );
++		COE( sys_acl_set_qualifier,(entry, (void*)&ida->id) );
++		COE2( store_access_in_entry,(ida->access, entry) );
++	}
++
++	COE( sys_acl_create_entry,(smb_acl, &entry) );
++	COE( sys_acl_set_tag_type,(entry, SMB_ACL_GROUP_OBJ) );
++	COE2( store_access_in_entry,(racl->group_obj & 7, entry) );
++
++	for (ida = racl->groups.idas, count = racl->groups.count;
++	     count--; ida++) {
++		COE( sys_acl_create_entry,(smb_acl, &entry) );
++		COE( sys_acl_set_tag_type,(entry, SMB_ACL_GROUP) );
++		COE( sys_acl_set_qualifier,(entry, (void*)&ida->id) );
++		COE2( store_access_in_entry,(ida->access, entry) );
++	}
++#ifndef ACLS_NEED_MASK
++	if (racl->mask != ACL_NO_ENTRY) {
++#endif
++		COE( sys_acl_create_entry,(smb_acl, &entry) );
++		COE( sys_acl_set_tag_type,(entry, SMB_ACL_MASK) );
++		COE2( store_access_in_entry,(racl->mask, entry) );
++#ifndef ACLS_NEED_MASK
++	}
++#endif
++
++	COE( sys_acl_create_entry,(smb_acl, &entry) );
++	COE( sys_acl_set_tag_type,(entry, SMB_ACL_OTHER) );
++	COE2( store_access_in_entry,(racl->other & 7, entry) );
++
++#ifdef DEBUG
++	if (sys_acl_valid(*smb_acl) < 0)
++		rprintf(FINFO, "pack_smb_acl: warning: system says the ACL I packed is invalid\n");
++#endif
++
++	return True;
++
++  error_exit:
++	if (errfun) {
++		rprintf(FERROR, "pack_smb_acl %s(): %s\n", errfun,
++			strerror(errno));
++	}
++	sys_acl_free_acl(*smb_acl);
++	return False;
++}
++
++static mode_t change_sacl_perms(SMB_ACL_T sacl, rsync_acl *racl, mode_t old_mode, mode_t mode)
++{
++	SMB_ACL_ENTRY_T entry;
++	const char *errfun;
++	int rc;
++
++	if (S_ISDIR(mode)) {
++		/* If the sticky bit is going on, it's not safe to allow all
++		 * the new ACLs to go into effect before it gets set. */
++#ifdef SMB_ACL_LOSES_SPECIAL_MODE_BITS
++		if (mode & S_ISVTX)
++			mode &= ~0077;
++#else
++		if (mode & S_ISVTX && !(old_mode & S_ISVTX))
++			mode &= ~0077;
++	} else {
++		/* If setuid or setgid is going off, it's not safe to allow all
++		 * the new ACLs to go into effect before they get cleared. */
++		if ((old_mode & S_ISUID && !(mode & S_ISUID))
++		 || (old_mode & S_ISGID && !(mode & S_ISGID)))
++			mode &= ~0077;
++#endif
++	}
++
++	errfun = "sys_acl_get_entry";
++	for (rc = sys_acl_get_entry(sacl, SMB_ACL_FIRST_ENTRY, &entry);
++	     rc == 1;
++	     rc = sys_acl_get_entry(sacl, SMB_ACL_NEXT_ENTRY, &entry)) {
++		SMB_ACL_TAG_T tag_type;
++		if ((rc = sys_acl_get_tag_type(entry, &tag_type))) {
++			errfun = "sys_acl_get_tag_type";
 +			break;
 +		}
-+		if (sys_acl_set_tag_type(entry, race->tag_type)) {
-+			errfun = "sys_acl_set_tag";
++		switch (tag_type) {
++		case SMB_ACL_USER_OBJ:
++			COE2( store_access_in_entry,((mode >> 6) & 7, entry) );
 +			break;
-+		}
-+		if (race->tag_type == SMB_ACL_USER ||
-+		    race->tag_type == SMB_ACL_GROUP)
-+			if (sys_acl_set_qualifier(entry, (void*)&race->id)) {
-+				errfun = "sys_acl_set_qualfier";
++		case SMB_ACL_GROUP_OBJ:
++			/* group is only empty when identical to group perms. */
++			if (racl->group_obj != ACL_NO_ENTRY)
 +				break;
-+			}
-+		if (sys_acl_get_permset(entry, &permset)) {
-+			errfun = "sys_acl_get_permset";
-+			break;
-+		}
-+		if (sys_acl_clear_perms(permset)) {
-+			errfun = "sys_acl_clear_perms";
++			COE2( store_access_in_entry,((mode >> 3) & 7, entry) );
 +			break;
-+		}
-+		if (race->access & 4)
-+			if (sys_acl_add_perm(permset, SMB_ACL_READ)) {
-+				errfun = "sys_acl_add_perm";
-+				break;
-+			}
-+		if (race->access & 2)
-+			if (sys_acl_add_perm(permset, SMB_ACL_WRITE)) {
-+				errfun = "sys_acl_add_perm";
-+				break;
-+			}
-+		if (race->access & 1)
-+			if (sys_acl_add_perm(permset, SMB_ACL_EXECUTE)) {
-+				errfun = "sys_acl_add_perm";
++		case SMB_ACL_MASK:
++#ifndef ACLS_NEED_MASK
++			/* mask is only empty when we don't need it. */
++			if (racl->mask == ACL_NO_ENTRY)
 +				break;
-+			}
-+		if (sys_acl_set_permset(entry, permset)) {
-+			errfun = "sys_acl_set_permset";
++#endif
++			COE2( store_access_in_entry,((mode >> 3) & 7, entry) );
++			break;
++		case SMB_ACL_OTHER:
++			COE2( store_access_in_entry,(mode & 7, entry) );
 +			break;
 +		}
 +	}
-+	if (errfun) {
-+		sys_acl_free_acl(*smb_acl);
-+		rprintf(FERROR, "pack_smb_acl %s(): %s\n", errfun,
-+			strerror(errno));
-+		return False;
++	if (rc) {
++	  error_exit:
++		if (errfun) {
++			rprintf(FERROR, "change_sacl_perms: %s(): %s\n",
++				errfun, strerror(errno));
++		}
++		return ~0u;
 +	}
-+	return True;
++
++#ifdef SMB_ACL_LOSES_SPECIAL_MODE_BITS
++	/* Ensure that chmod() will be called to restore any lost setid bits. */
++	if (old_mode & (S_ISUID | S_ISGID | S_ISVTX)
++	 && (old_mode & CHMOD_BITS) == (mode & CHMOD_BITS))
++		old_mode &= ~(S_ISUID | S_ISGID | S_ISVTX);
++#endif
++
++	/* Return the mode of the file on disk, as we will set them. */
++	return (old_mode & ~ACCESSPERMS) | (mode & ACCESSPERMS);
 +}
 +
-+static void receive_rsync_acl(rsync_acl *racl, int f)
++static void receive_rsync_acl(rsync_acl *racl, int f, SMB_ACL_TYPE_T type)
 +{
-+#if ACLS_NEED_MASK
-+	uchar required_mask_perm = 0;
-+#endif
-+	BOOL saw_mask = False;
-+	BOOL saw_user_obj = False, saw_group_obj = False,
-+		saw_other = False;
-+	size_t count = read_int(f);
-+	rsync_ace *race;
-+	if (!count)
++	uchar computed_mask_bits = 0;
++	ida_list *idal = NULL;
++	id_access *ida;
++	size_t count;
++
++	*racl = rsync_acl_initializer;
++
++	if (!(count = read_int(f)))
 +		return;
++
 +	while (count--) {
-+		uchar tag = read_byte(f);
-+		expand_rsync_acl(racl);
-+		race = &racl->races[racl->count++];
++		char tag = read_byte(f);
++		uchar access = read_byte(f);
++		if (access & ~ (4 | 2 | 1)) {
++			rprintf(FERROR, "receive_rsync_acl: bogus permset %o\n",
++				access);
++			exit_cleanup(RERR_STREAMIO);
++		}
 +		switch (tag) {
 +		case 'u':
-+			race->tag_type = SMB_ACL_USER_OBJ;
-+			saw_user_obj = True;
-+			break;
++			if (racl->user_obj != ACL_NO_ENTRY) {
++				rprintf(FERROR, "receive_rsync_acl: error: duplicate USER_OBJ entry\n");
++				exit_cleanup(RERR_STREAMIO);
++			}
++			racl->user_obj = access;
++			continue;
 +		case 'U':
-+			race->tag_type = SMB_ACL_USER;
++			idal = &racl->users;
 +			break;
 +		case 'g':
-+			race->tag_type = SMB_ACL_GROUP_OBJ;
-+			saw_group_obj = True;
-+			break;
++			if (racl->group_obj != ACL_NO_ENTRY) {
++				rprintf(FERROR, "receive_rsync_acl: error: duplicate GROUP_OBJ entry\n");
++				exit_cleanup(RERR_STREAMIO);
++			}
++			racl->group_obj = access;
++			continue;
 +		case 'G':
-+			race->tag_type = SMB_ACL_GROUP;
-+			break;
-+		case 'o':
-+			race->tag_type = SMB_ACL_OTHER;
-+			saw_other = True;
++			idal = &racl->groups;
 +			break;
 +		case 'm':
-+			race->tag_type = SMB_ACL_MASK;
-+			saw_mask = True;
-+			break;
++			if (racl->mask != ACL_NO_ENTRY) {
++				rprintf(FERROR, "receive_rsync_acl: error: duplicate MASK entry\n");
++				exit_cleanup(RERR_STREAMIO);
++			}
++			racl->mask = access;
++			continue;
++		case 'o':
++			if (racl->other != ACL_NO_ENTRY) {
++				rprintf(FERROR, "receive_rsync_acl: error: duplicate OTHER entry\n");
++				exit_cleanup(RERR_STREAMIO);
++			}
++			racl->other = access;
++			continue;
 +		default:
 +			rprintf(FERROR, "receive_rsync_acl: unknown tag %c\n",
 +				tag);
 +			exit_cleanup(RERR_STREAMIO);
 +		}
-+		race->access = read_byte(f);
-+		if (race->access & ~ (4 | 2 | 1)) {
-+			rprintf(FERROR, "receive_rsync_acl: bogus permset %o\n",
-+				race->access);
-+			exit_cleanup(RERR_STREAMIO);
-+		}
-+		if (race->tag_type == SMB_ACL_USER ||
-+		    race->tag_type == SMB_ACL_GROUP) {
-+			race->id = read_int(f);
-+#if ACLS_NEED_MASK
-+			required_mask_perm |= race->access;
-+#endif
-+		}
-+#if ACLS_NEED_MASK
-+		else if (race->tag_type == SMB_ACL_GROUP_OBJ)
-+			required_mask_perm |= race->access;
-+#endif
-+
-+	}
-+	if (!saw_user_obj) {
-+		expand_rsync_acl(racl);
-+		race = &racl->races[racl->count++];
-+		race->tag_type = SMB_ACL_USER_OBJ;
-+		race->access = 7;
-+	}
-+	if (!saw_group_obj) {
-+		expand_rsync_acl(racl);
-+		race = &racl->races[racl->count++];
-+		race->tag_type = SMB_ACL_GROUP_OBJ;
-+		race->access = 0;
-+	}
-+	if (!saw_other) {
-+		expand_rsync_acl(racl);
-+		race = &racl->races[racl->count++];
-+		race->tag_type = SMB_ACL_OTHER;
-+		race->access = 0;
-+	}
-+#if ACLS_NEED_MASK
-+	if (!saw_mask) {
-+		expand_rsync_acl(racl);
-+		race = &racl->races[racl->count++];
-+		race->tag_type = SMB_ACL_MASK;
-+		race->access = required_mask_perm;
++		expand_ida_list(idal);
++		ida = &idal->idas[idal->count++];
++		ida->access = access;
++		ida->id = read_int(f);
++		computed_mask_bits |= access;
 +	}
-+#else
-+	/* If we, a system without ACLS_NEED_MASK, received data from a
-+	 * system that has masks, throw away the extraneous CLASS_OBJs. */
-+	if (saw_mask && racl->count == 4) {
-+		rsync_ace *group_obj_race = NULL, *mask_race = NULL;
-+		rsync_ace *p;
-+		size_t i;
-+		for (i = 0, p = racl->races; i < racl->count; i++, p++) {
-+			if (p->tag_type == SMB_ACL_MASK)
-+				mask_race = p;
-+			else if (p->tag_type == SMB_ACL_GROUP_OBJ)
-+				group_obj_race = p;
-+		}
-+		if (mask_race == NULL || group_obj_race == NULL) {
-+			rprintf(FERROR, "receive_rsync_acl: have four ACES "
-+					"and one's ACL_MASK but missing "
-+					"either it or ACL_GROUP_OBJ, "
-+					"when pruning ACL\n");
-+		} else {
++
++	if (type == SMB_ACL_TYPE_DEFAULT) {
++		/* Ensure that these are never unset. */
++		if (racl->user_obj == ACL_NO_ENTRY)
++			racl->user_obj = 7;
++		if (racl->group_obj == ACL_NO_ENTRY)
++			racl->group_obj = 0;
++		if (racl->other == ACL_NO_ENTRY)
++			racl->other = 0;
++	}
++#ifndef ACLS_NEED_MASK
++	if (!racl->users.count && !racl->groups.count) {
++		/* If we, a system without ACLS_NEED_MASK, received a
++		 * superfluous mask, throw it away. */
++		if (racl->mask != ACL_NO_ENTRY) {
 +			/* mask off group perms with it first */
-+			group_obj_race->access &= mask_race->access;
-+			/* dump mask_race; re-slot any followers-on */
-+			racl->count--;
-+			if (mask_race != &racl->races[racl->count]) {
-+				*mask_race = racl->races[racl->count];
-+				saw_user_obj = False; /* force re-sort */
-+			}
++			racl->group_obj &= racl->mask | ACL_NO_ENTRY;
++			racl->mask = ACL_NO_ENTRY;
 +		}
-+	}
++	} else
 +#endif
-+#if ACLS_NEED_MASK
-+	if (!(saw_user_obj && saw_group_obj && saw_other && saw_mask))
-+#else
-+	if (!(saw_user_obj && saw_group_obj && saw_other))
-+#endif
-+		sort_rsync_acl(racl);
++	if (racl->mask == ACL_NO_ENTRY) /* Always non-empty when needed. */
++		racl->mask = computed_mask_bits | (racl->group_obj & 7);
 +}
 +
 +/* receive and build the rsync_acl_lists */
-+
 +void receive_acl(struct file_struct *file, int f)
 +{
-+	SMB_ACL_TYPE_T *type,
-+		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
++	SMB_ACL_TYPE_T type;
 +	char *fname;
-+	if (!preserve_acls || S_ISLNK(file->mode))
++
++	if (S_ISLNK(file->mode))
 +		return;
++
 +	fname = f_name(file, NULL);
-+	for (type = &types[0];
-+	     type < &types[0] + sizeof types / sizeof types[0]
-+		&& (*type == SMB_ACL_TYPE_ACCESS || S_ISDIR(file->mode));
-+	     type++) {
-+		file_acl_index_list *fileaclidx_list =
-+			file_acl_index_lists(*type);
-+		uchar tag;
-+		expand_file_acl_index_list(fileaclidx_list);
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
++		char tag;
++		file_acl_index_list *flst = file_acl_index_lists(type);
++
++		expand_file_acl_index_list(flst);
 +
 +		tag = read_byte(f);
 +		if (tag == 'A' || tag == 'a') {
-+			if (*type != SMB_ACL_TYPE_ACCESS) {
++			if (type != SMB_ACL_TYPE_ACCESS) {
 +				rprintf(FERROR, "receive_acl %s: duplicate access ACL\n",
 +					fname);
 +				exit_cleanup(RERR_STREAMIO);
 +			}
 +		} else if (tag == 'D' || tag == 'd') {
-+			if (*type == SMB_ACL_TYPE_ACCESS) {
++			if (type == SMB_ACL_TYPE_ACCESS) {
 +				rprintf(FERROR, "receive_acl %s: expecting access ACL; got default\n",
 +					fname);
 +				exit_cleanup(RERR_STREAMIO);
 +			}
 +		} else {
 +			rprintf(FERROR, "receive_acl %s: unknown ACL type tag: %c\n",
 +				fname, tag);
 +			exit_cleanup(RERR_STREAMIO);
 +		}
 +		if (tag == 'A' || tag == 'D') {
-+			rsync_acl racl = rsync_acl_initializer;
-+			rsync_acl_list *racl_list = rsync_acl_lists(*type);
-+			smb_acl_list *sacl_list = smb_acl_lists(*type);
-+			fileaclidx_list->fileaclidxs[fileaclidx_list->count].
-+				aclidx = racl_list->count;
-+			fileaclidx_list->fileaclidxs[fileaclidx_list->count++].
-+				file = file;
-+			receive_rsync_acl(&racl, f);
++			rsync_acl racl;
++			rsync_acl_list *racl_list = rsync_acl_lists(type);
++			smb_acl_list *sacl_list = smb_acl_lists(type);
++			flst->fais[flst->count].aclidx = racl_list->count;
++			flst->fais[flst->count++].file = file;
++			receive_rsync_acl(&racl, f, type);
 +			expand_rsync_acl_list(racl_list);
 +			racl_list->racls[racl_list->count++] = racl;
 +			expand_smb_acl_list(sacl_list);
 +			sacl_list->sacls[sacl_list->count++] = NULL;
 +		} else {
 +			int index = read_int(f);
-+			rsync_acl_list *racl_list = rsync_acl_lists(*type);
++			rsync_acl_list *racl_list = rsync_acl_lists(type);
 +			if ((size_t) index >= racl_list->count) {
 +				rprintf(FERROR, "receive_acl %s: %s ACL index %d out of range\n",
 +					fname,
-+					str_acl_type(*type),
++					str_acl_type(type),
 +					index);
 +				exit_cleanup(RERR_STREAMIO);
 +			}
-+			fileaclidx_list->fileaclidxs[fileaclidx_list->count].
-+				aclidx = index;
-+			fileaclidx_list->fileaclidxs[fileaclidx_list->count++].
-+				file = file;
++			flst->fais[flst->count].aclidx = index;
++			flst->fais[flst->count++].file = file;
 +		}
-+	}
++	} while (BUMP_TYPE(type) && S_ISDIR(file->mode));
 +}
 +
 +static int file_acl_index_list_sorter(const void *f1, const void *f2)
 +{
 +	const file_acl_index *fileaclidx1 = (const file_acl_index *)f1;
 +	const file_acl_index *fileaclidx2 = (const file_acl_index *)f2;
-+	return fileaclidx1->file == fileaclidx2->file ? 0 :
-+		fileaclidx1->file < fileaclidx2->file ? -1 : 1;
++	return fileaclidx1->file == fileaclidx2->file ? 0
++	     : fileaclidx1->file < fileaclidx2->file ? -1 : 1;
 +}
 +
 +void sort_file_acl_index_lists()
 +{
-+	SMB_ACL_TYPE_T *type,
-+		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
-+	if (!preserve_acls)
-+		return;
-+	for (type = &types[0];
-+	     type < &types[0] + sizeof types / sizeof types[0];
-+	     type++)
-+	{
-+		file_acl_index_list *fileaclidx_list =
-+			file_acl_index_lists(*type);
-+		if (!fileaclidx_list->count)
++	SMB_ACL_TYPE_T type;
++
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
++		file_acl_index_list *flst = file_acl_index_lists(type);
++
++		if (!flst->count)
 +			continue;
-+		qsort(fileaclidx_list->fileaclidxs, fileaclidx_list->count,
-+		      sizeof fileaclidx_list->fileaclidxs[0],
++
++		qsort(flst->fais, flst->count, sizeof flst->fais[0],
 +		      &file_acl_index_list_sorter);
-+	}
++	} while (BUMP_TYPE(type));
 +}
 +
-+static int find_file_acl_index(const file_acl_index_list *fileaclidx_list,
-+			       const struct file_struct *file) {
-+	int low = 0, high = fileaclidx_list->count;
++static int find_file_acl_index(const file_acl_index_list *flst,
++			       const struct file_struct *file)
++{
++	int low = 0, high = flst->count;
 +	const struct file_struct *file_mid;
++
 +	if (!high--)
 +		return -1;
 +	do {
 +		int mid = (high + low) / 2;
-+		file_mid = fileaclidx_list->fileaclidxs[mid].file;
++		file_mid = flst->fais[mid].file;
 +		if (file_mid == file)
-+			return fileaclidx_list->fileaclidxs[mid].aclidx;
++			return flst->fais[mid].aclidx;
 +		if (file_mid > file)
 +			high = mid - 1;
 +		else
 +			low = mid + 1;
 +	} while (low < high);
 +	if (low == high) {
-+		file_mid = fileaclidx_list->fileaclidxs[low].file;
++		file_mid = flst->fais[low].file;
 +		if (file_mid == file)
-+			return fileaclidx_list->fileaclidxs[low].aclidx;
++			return flst->fais[low].aclidx;
 +	}
 +	rprintf(FERROR,
 +		"find_file_acl_index: can't find entry for file in list\n");
 +	exit_cleanup(RERR_STREAMIO);
 +	return -1;
 +}
 +
 +/* for duplicating ACLs on backups when using backup_dir */
-+
 +int dup_acl(const char *orig, const char *bak, mode_t mode)
 +{
-+	SMB_ACL_TYPE_T *type,
-+		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
++	SMB_ACL_TYPE_T type;
 +	int ret = 0;
-+	if (!preserve_acls)
-+		return 1;
-+	for (type = &types[0];
-+	     type < &types[0] + sizeof types / sizeof types[0]
-+		 && (*type == SMB_ACL_TYPE_ACCESS || S_ISDIR(mode));
-+	     type++) {
++
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
 +		SMB_ACL_T sacl_orig, sacl_bak;
 +		rsync_acl racl_orig, racl_bak;
-+		if (!(sacl_orig = sys_acl_get_file(orig, *type))) {
++		if (!(sacl_orig = sys_acl_get_file(orig, type))) {
 +			rprintf(FERROR, "dup_acl: sys_acl_get_file(%s, %s): %s\n",
-+				orig, str_acl_type(*type), strerror(errno));
++				orig, str_acl_type(type), strerror(errno));
 +			ret = -1;
 +			continue;
 +		}
-+		if (!(sacl_bak = sys_acl_get_file(orig, *type))) {
++		if (!(sacl_bak = sys_acl_get_file(orig, type))) {
 +			rprintf(FERROR, "dup_acl: sys_acl_get_file(%s, %s): %s. ignoring\n",
-+				bak, str_acl_type(*type), strerror(errno));
++				bak, str_acl_type(type), strerror(errno));
 +			ret = -1;
 +			/* try to forge on through */
 +		}
 +		if (!unpack_smb_acl(&racl_orig, sacl_orig)) {
 +			ret = -1;
 +			goto out_with_sacls;
@@ -911,21 +1026,22 @@
 +			}
 +			if (rsync_acls_equal(&racl_orig, &racl_bak))
 +				goto out_with_all;
 +		} else {
 +			; /* presume they're unequal */
 +		}
-+		if (*type == SMB_ACL_TYPE_DEFAULT && !racl_orig.count) {
++		if (type == SMB_ACL_TYPE_DEFAULT
++		 && racl_orig.user_obj == ACL_NO_ENTRY) {
 +			if (sys_acl_delete_def_file(bak) < 0) {
 +				rprintf(FERROR, "dup_acl: sys_acl_delete_def_file(%s): %s\n",
 +					bak, strerror(errno));
 +				ret = -1;
 +			}
-+		} else if (sys_acl_set_file(bak, *type, sacl_bak) < 0) {
++		} else if (sys_acl_set_file(bak, type, sacl_bak) < 0) {
 +			rprintf(FERROR, "dup_acl: sys_acl_set_file(%s, %s): %s\n",
-+				bak, str_acl_type(*type), strerror(errno));
++				bak, str_acl_type(type), strerror(errno));
 +			ret = -1;
 +		}
 +		out_with_all:
 +			if (sacl_bak)
 +				rsync_acl_free(&racl_bak);
 +		out_with_one_racl:
@@ -933,13 +1049,14 @@
 +		out_with_sacls:
 +			if (sacl_bak)
 +				sys_acl_free_acl(sacl_bak);
 +		/* out_with_one_sacl: */
 +			if (sacl_orig)
 +				sys_acl_free_acl(sacl_orig);
-+	}
++	} while (BUMP_TYPE(type) && S_ISDIR(mode));
++
 +	return ret;
 +}
 +
 +/* Stuff for redirecting calls to set_acl() from set_file_attrs()
 + * for keep_backup(). */
 +static const struct file_struct *backup_orig_file = NULL;
@@ -948,145 +1065,163 @@
 +static const char *backup_dest_fname = null_string;
 +static SMB_ACL_T _backup_sacl[] = { NULL, NULL };
 +
 +void push_keep_backup_acl(const struct file_struct *file,
 +			  const char *orig, const char *dest)
 +{
-+	if (preserve_acls) {
-+		SMB_ACL_TYPE_T *type,
-+			types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
-+		SMB_ACL_T *sacl;
-+		backup_orig_file = file;
-+		backup_orig_fname = orig;
-+		backup_dest_fname = dest;
-+		for (type = &types[0], sacl = &_backup_sacl[0];
-+		     type < &types[0] + sizeof types / sizeof types[0];
-+		     type++) {
-+			if (*type == SMB_ACL_TYPE_DEFAULT && !S_ISDIR(file->mode))
-+				*sacl = NULL;
-+			else {
-+				if (!(*sacl = sys_acl_get_file(orig, *type))) {
-+					rprintf(FERROR, "push_keep_backup_acl: sys_acl_get_file(%s, %s): %s\n",
-+						orig, str_acl_type(*type),
-+						strerror(errno));
-+				}
-+			}
++	SMB_ACL_TYPE_T type;
++	SMB_ACL_T *sacl;
++
++	backup_orig_file = file;
++	backup_orig_fname = orig;
++	backup_dest_fname = dest;
++
++	sacl = &_backup_sacl[0];
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
++		if (type == SMB_ACL_TYPE_DEFAULT && !S_ISDIR(file->mode)) {
++			*sacl = NULL;
++			break;
 +		}
-+	}
++		if (!(*sacl = sys_acl_get_file(orig, type))) {
++			rprintf(FERROR,
++				"push_keep_backup_acl: sys_acl_get_file(%s, %s): %s\n",
++				orig, str_acl_type(type),
++				strerror(errno));
++		}
++	} while (BUMP_TYPE(type));
 +}
 +
 +static int set_keep_backup_acl()
 +{
-+	if (preserve_acls) {
-+		SMB_ACL_TYPE_T *type,
-+			types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
-+		SMB_ACL_T *sacl;
-+		int ret = 0;
-+		for (type = &types[0], sacl = &_backup_sacl[0];
-+		     type < &types[0] + sizeof types / sizeof types[0];
-+		     type++) {
-+			if (*sacl) {
-+				if (sys_acl_set_file(backup_dest_fname,
-+						     *type, *sacl) < 0) {
-+					rprintf(FERROR, "push_keep_backup_acl: sys_acl_get_file(%s, %s): %s\n",
-+						backup_dest_fname,
-+						str_acl_type(*type),
-+						strerror(errno));
-+					ret = -1;
-+				}
-+			}
++	SMB_ACL_TYPE_T type;
++	SMB_ACL_T *sacl;
++	int ret = 0;
++
++	sacl = &_backup_sacl[0];
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
++		if (*sacl
++		 && sys_acl_set_file(backup_dest_fname, type, *sacl) < 0) {
++			rprintf(FERROR,
++				"push_keep_backup_acl: sys_acl_get_file(%s, %s): %s\n",
++				backup_dest_fname,
++				str_acl_type(type),
++				strerror(errno));
++			ret = -1;
 +		}
-+		return ret;
-+	}
-+	return 1;
++	} while (BUMP_TYPE(type));
++
++	return ret;
 +}
 +
 +void cleanup_keep_backup_acl()
 +{
-+	if (preserve_acls) {
-+		SMB_ACL_TYPE_T *type,
-+			types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
-+		SMB_ACL_T *sacl;
-+		backup_orig_file = NULL;
-+		backup_orig_fname = null_string;
-+		backup_dest_fname = null_string;
-+		for (type = &types[0], sacl = &_backup_sacl[0];
-+		     type < &types[0] + sizeof types / sizeof types[0];
-+		     type++) {
-+			if (*sacl)
-+				sys_acl_free_acl(*sacl);
++	SMB_ACL_TYPE_T type;
++	SMB_ACL_T *sacl;
++
++	backup_orig_file = NULL;
++	backup_orig_fname = null_string;
++	backup_dest_fname = null_string;
++
++	sacl = &_backup_sacl[0];
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
++		if (*sacl) {
++			sys_acl_free_acl(*sacl);
 +			*sacl = NULL;
 +		}
-+	}
++	} while (BUMP_TYPE(type));
 +}
 +
-+/* set ACL on rsync-ed or keep_backup-ed file */
-+
-+int set_acl(const char *fname, const struct file_struct *file)
++/* set ACL on rsync-ed or keep_backup-ed file
++ *
++ * This sets extended access ACL entries and default ACLs.  If convenient,
++ * it sets permission bits along with the access ACLs and signals having
++ * done so by modifying mode_p, which should point into the stat buffer.
++ *
++ * returns: 1 for unchanged, 0 for changed, -1 for failed
++ * Pass NULL for mode_p to get the return code without changing anything. */
++int set_acl(const char *fname, const struct file_struct *file, mode_t *mode_p)
 +{
 +	int unchanged = 1;
-+	SMB_ACL_TYPE_T *type,
-+		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
-+	if (dry_run || !preserve_acls || S_ISLNK(file->mode))
++	SMB_ACL_TYPE_T type;
++
++	if (S_ISLNK(file->mode))
 +		return 1;
++
 +	if (file == backup_orig_file) {
 +		if (!strcmp(fname, backup_dest_fname))
 +			return set_keep_backup_acl();
 +	}
-+	for (type = &types[0];
-+	     type < &types[0] + sizeof  types / sizeof types[0]
-+		&& (*type == SMB_ACL_TYPE_ACCESS || S_ISDIR(file->mode));
-+	     type++) {
++	type = SMB_ACL_TYPE_ACCESS;
++	do {
++		BOOL ok;
 +		SMB_ACL_T sacl_orig, *sacl_new;
 +		rsync_acl racl_orig, *racl_new;
-+		int aclidx = find_file_acl_index(file_acl_index_lists(*type),
-+						 file);
-+		BOOL ok;
-+		racl_new = &(rsync_acl_lists(*type)->racls[aclidx]);
-+		sacl_new = &(smb_acl_lists(*type)->sacls[aclidx]);
-+		sacl_orig = sys_acl_get_file(fname, *type);
++		int aclidx = find_file_acl_index(file_acl_index_lists(type), file);
++
++		racl_new = &(rsync_acl_lists(type)->racls[aclidx]);
++		sacl_new = &(smb_acl_lists(type)->sacls[aclidx]);
++		sacl_orig = sys_acl_get_file(fname, type);
 +		if (!sacl_orig) {
 +			rprintf(FERROR, "set_acl: sys_acl_get_file(%s, %s): %s\n",
-+				fname, str_acl_type(*type), strerror(errno));
++				fname, str_acl_type(type), strerror(errno));
 +			unchanged = -1;
 +			continue;
 +		}
 +		ok = unpack_smb_acl(&racl_orig, sacl_orig);
 +		sys_acl_free_acl(sacl_orig);
 +		if (!ok) {
 +			unchanged = -1;
 +			continue;
 +		}
-+		ok = rsync_acls_equal(&racl_orig, racl_new);
++		if (type == SMB_ACL_TYPE_ACCESS)
++			ok = rsync_acl_extended_parts_equal(&racl_orig, racl_new);
++		else
++			ok = rsync_acls_equal(&racl_orig, racl_new);
 +		rsync_acl_free(&racl_orig);
 +		if (ok)
 +			continue;
-+		if (*type == SMB_ACL_TYPE_DEFAULT && !racl_new->count) {
-+			if (sys_acl_delete_def_file(fname) < 0) {
-+				rprintf(FERROR, "set_acl: sys_acl_delete_def_file(%s): %s\n",
-+					fname, strerror(errno));
-+				unchanged = -1;
-+				continue;
-+			}
-+		} else {
-+			if (!*sacl_new)
-+				if (!pack_smb_acl(sacl_new, racl_new)) {
++		if (!dry_run && mode_p) {
++			if (type == SMB_ACL_TYPE_DEFAULT
++			 && racl_new->user_obj == ACL_NO_ENTRY) {
++				if (sys_acl_delete_def_file(fname) < 0) {
++					rprintf(FERROR, "set_acl: sys_acl_delete_def_file(%s): %s\n",
++						fname, strerror(errno));
++					unchanged = -1;
++					continue;
++				}
++			} else {
++				mode_t cur_mode = *mode_p;
++				if (!*sacl_new
++				 && !pack_smb_acl(sacl_new, racl_new)) {
++					unchanged = -1;
++					continue;
++				}
++				if (type == SMB_ACL_TYPE_ACCESS) {
++					cur_mode = change_sacl_perms(*sacl_new, racl_new,
++								     cur_mode, file->mode);
++					if (cur_mode == ~0u)
++						continue;
++				}
++				if (sys_acl_set_file(fname, type, *sacl_new) < 0) {
++					rprintf(FERROR, "set_acl: sys_acl_set_file(%s, %s): %s\n",
++						fname, str_acl_type(type),
++						strerror(errno));
 +					unchanged = -1;
 +					continue;
 +				}
-+			if (sys_acl_set_file(fname, *type, *sacl_new) < 0) {
-+				rprintf(FERROR, "set_acl: sys_acl_set_file(%s, %s): %s\n",
-+					fname, str_acl_type(*type),
-+					strerror(errno));
-+				unchanged = -1;
-+				continue;
++				if (type == SMB_ACL_TYPE_ACCESS)
++					*mode_p = cur_mode;
 +			}
 +		}
 +		if (unchanged == 1)
 +			unchanged = 0;
-+	}
++	} while (BUMP_TYPE(type) && S_ISDIR(file->mode));
++
 +	return unchanged;
 +}
 +
 +/* Enumeration functions for uid mapping: */
 +
 +/* Context -- one and only one.  Should be cycled through once on uid
@@ -1094,85 +1229,65 @@
 +static rsync_acl_list *_enum_racl_lists[] = {
 +	&_rsync_acl_lists[0], &_rsync_acl_lists[1], NULL
 +};
 +
 +static rsync_acl_list **enum_racl_list = &_enum_racl_lists[0];
 +static size_t enum_racl_index = 0;
-+static size_t enum_race_index = 0;
++static size_t enum_ida_index = 0;
 +
 +/* This returns the next tag_type id from the given acl for the next entry,
 + * or it returns 0 if there are no more tag_type ids in the acl. */
-+
-+static id_t next_ace_id(SMB_ACL_TAG_T tag_type, const rsync_acl *racl)
++static id_t *next_ace_id(SMB_ACL_TAG_T tag_type, const rsync_acl *racl)
 +{
-+	for (; enum_race_index < racl->count; enum_race_index++) {
-+		rsync_ace *race = &racl->races[enum_race_index];
-+		if (race->tag_type == tag_type)
-+			return race->id;
++	const ida_list *idal = tag_type == SMB_ACL_USER ? &racl->users : &racl->groups;
++	if (enum_ida_index < idal->count) {
++		id_access *ida = &idal->idas[enum_ida_index++];
++		return &ida->id;
 +	}
-+	enum_race_index = 0;
-+	return 0;
++	enum_ida_index = 0;
++	return NULL;
 +}
 +
-+static id_t next_acl_id(SMB_ACL_TAG_T tag_type, const rsync_acl_list *racl_list)
++static id_t *next_acl_id(SMB_ACL_TAG_T tag_type, const rsync_acl_list *racl_list)
 +{
 +	for (; enum_racl_index < racl_list->count; enum_racl_index++) {
 +		rsync_acl *racl = &racl_list->racls[enum_racl_index];
-+		id_t id = next_ace_id(tag_type, racl);
++		id_t *id = next_ace_id(tag_type, racl);
 +		if (id)
 +			return id;
 +	}
 +	enum_racl_index = 0;
-+	return 0;
++	return NULL;
 +}
 +
-+static id_t next_acl_list_id(SMB_ACL_TAG_T tag_type)
++static id_t *next_acl_list_id(SMB_ACL_TAG_T tag_type)
 +{
 +	for (; *enum_racl_list; enum_racl_list++) {
-+		id_t id = next_acl_id(tag_type, *enum_racl_list);
++		id_t *id = next_acl_id(tag_type, *enum_racl_list);
 +		if (id)
 +			return id;
 +	}
 +	enum_racl_list = &_enum_racl_lists[0];
-+	return 0;
++	return NULL;
 +}
 +
-+id_t next_acl_uid()
++id_t *next_acl_uid()
 +{
 +	return next_acl_list_id(SMB_ACL_USER);
 +}
 +
-+id_t next_acl_gid()
++id_t *next_acl_gid()
 +{
 +	return next_acl_list_id(SMB_ACL_GROUP);
 +}
 +
-+/* referring to the global context enum_entry, sets the entry's id */
-+static void set_acl_id(id_t id)
-+{
-+	(*enum_racl_list)->racls[enum_racl_index].races[enum_race_index++].id = id;
-+}
-+
-+void acl_uid_map(id_t uid)
-+{
-+	set_acl_id(uid);
-+}
-+
-+void acl_gid_map(id_t gid)
-+{
-+	set_acl_id(gid);
-+}
-+
-+#define PERMS_SPLICE(perms,newbits,where) (((perms) & ~(7 << (where))) | ((newbits) << (where)))
-+
 +int default_perms_for_dir(const char *dir)
 +{
 +	rsync_acl racl;
 +	SMB_ACL_T sacl;
-+	BOOL ok, saw_mask = False;
-+	size_t i;
++	BOOL ok;
 +	int perms;
 +
 +	if (dir == NULL)
 +		dir = ".";
 +	perms = ACCESSPERMS & ~orig_umask;
 +	/* Read the directory's default ACL.  If it has none, this will successfully return an empty ACL. */
@@ -1202,70 +1317,64 @@
 +	sys_acl_free_acl(sacl);
 +	if (!ok) {
 +		rprintf(FERROR, "default_perms_for_dir: unpack_smb_acl failed, falling back on umask\n");
 +		return perms;
 +	}
 +
-+	/* Look at each default ACL entry and possibly modify three bits of `perms' accordingly.
-+	 * If there's "no" default ACL, there will be zero entries and the umask-based perms is unchanged. */
-+	for (i = 0; i < racl.count; i++) {
-+		switch (racl.races[i].tag_type) {
-+		case SMB_ACL_USER_OBJ:
-+			perms = PERMS_SPLICE(perms, racl.races[i].access, 6);
-+			break;
-+		case SMB_ACL_GROUP_OBJ:
-+			if (!saw_mask)
-+				perms = PERMS_SPLICE(perms, racl.races[i].access, 3);
-+			break;
-+		case SMB_ACL_MASK:
-+			saw_mask = True;
-+			perms = PERMS_SPLICE(perms, racl.races[i].access, 3);
-+			break;
-+		case SMB_ACL_OTHER:
-+			perms = PERMS_SPLICE(perms, racl.races[i].access, 0);
-+			break;
-+		default:
-+			break;
-+		}
++	/* Apply the permission-bit entries of the default ACL, if any. */
++	if (racl.user_obj != ACL_NO_ENTRY) {
++		perms = rsync_acl_get_perms(&racl);
++		if (verbose > 2)
++			rprintf(FINFO, "got ACL-based default perms %o for directory %s\n", perms, dir);
 +	}
++
 +	rsync_acl_free(&racl);
-+	if (verbose > 2)
-+		rprintf(FINFO, "got ACL-based default perms %o for directory %s\n", perms, dir);
 +	return perms;
 +}
 +
 +#endif /* SUPPORT_ACLS */
 --- old/backup.c
 +++ new/backup.c
-@@ -132,6 +132,9 @@ static int make_bak_dir(char *fullpath)
+@@ -28,6 +28,7 @@ extern char *backup_suffix;
+ extern char *backup_dir;
+ 
+ extern int am_root;
++extern int preserve_acls;
+ extern int preserve_devices;
+ extern int preserve_specials;
+ extern int preserve_links;
+@@ -132,6 +133,10 @@ static int make_bak_dir(char *fullpath)
  			} else {
  				do_lchown(fullpath, st.st_uid, st.st_gid);
  				do_chmod(fullpath, st.st_mode);
 +#ifdef SUPPORT_ACLS
-+				dup_acl(end, fullpath, st.st_mode);
++				if (preserve_acls)
++					dup_acl(end, fullpath, st.st_mode);
 +#endif
  			}
  		}
  		*p = '/';
-@@ -185,6 +188,10 @@ static int keep_backup(char *fname)
+@@ -185,6 +190,11 @@ static int keep_backup(char *fname)
  	if (!(buf = get_backup_name(fname)))
  		return 0;
  
 +#ifdef SUPPORT_ACLS
-+	push_keep_backup_acl(file, fname, buf);
++	if (preserve_acls)
++		push_keep_backup_acl(file, fname, buf);
 +#endif
 +
  	/* Check to see if this is a device file, or link */
  	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
  	 || (preserve_specials && IS_SPECIAL(file->mode))) {
-@@ -260,6 +267,9 @@ static int keep_backup(char *fname)
+@@ -260,6 +270,10 @@ static int keep_backup(char *fname)
  		}
  	}
  	set_file_attrs(buf, file, NULL, 0);
 +#ifdef SUPPORT_ACLS
-+	cleanup_keep_backup_acl();
++	if (preserve_acls)
++		cleanup_keep_backup_acl();
 +#endif
  	free(file);
  
  	if (verbose > 1) {
 --- old/configure.in
 +++ new/configure.in
@@ -1278,13 +1387,13 @@
 +    AC_CHECK_LIB(sec, aclsort)
 +fi
 +
  dnl At the moment we don't test for a broken memcmp(), because all we
  dnl need to do is test for equality, not comparison, and it seems that
  dnl every platform has a memcmp that can do at least that.
-@@ -738,6 +743,77 @@ AC_SUBST(OBJ_RESTORE)
+@@ -746,6 +751,78 @@ AC_SUBST(OBJ_RESTORE)
  AC_SUBST(CC_SHOBJ_FLAG)
  AC_SUBST(BUILD_POPT)
  
 +AC_CHECK_HEADERS(sys/acl.h)
 +AC_CHECK_FUNCS(_acl __acl _facl __facl)
 +#################################################
@@ -1298,13 +1407,13 @@
 +
 +		case "$host_os" in
 +		*sysv5*)
 +			AC_MSG_RESULT(Using UnixWare ACLs)
 +			AC_DEFINE(HAVE_UNIXWARE_ACLS, 1, [true if you have UnixWare ACLs])
 +			;;
-+		*solaris*)
++		*solaris*|*cygwin*)
 +			AC_MSG_RESULT(Using solaris ACLs)
 +			AC_DEFINE(HAVE_SOLARIS_ACLS, 1, [true if you have solaris ACLs])
 +			;;
 +		*hpux*)
 +			AC_MSG_RESULT(Using HPUX ACLs)
 +			AC_DEFINE(HAVE_HPUX_ACLS, 1, [true if you have HPUX ACLs])
@@ -1327,12 +1436,13 @@
 +		    AC_CHECK_LIB(acl,acl_get_file)
 +			AC_CACHE_CHECK([for ACL support],samba_cv_HAVE_POSIX_ACLS,[
 +			AC_TRY_LINK([#include <sys/types.h>
 +#include <sys/acl.h>],
 +[ acl_t acl; int entry_id; acl_entry_t *entry_p; return acl_get_entry( acl, entry_id, entry_p);],
 +samba_cv_HAVE_POSIX_ACLS=yes,samba_cv_HAVE_POSIX_ACLS=no)])
++			AC_MSG_CHECKING(ACL test results)
 +			if test x"$samba_cv_HAVE_POSIX_ACLS" = x"yes"; then
 +			    AC_MSG_RESULT(Using posix ACLs)
 +			    AC_DEFINE(HAVE_POSIX_ACLS, 1, [true if you have posix ACLs])
 +			    AC_CACHE_CHECK([for acl_get_perm_np],samba_cv_HAVE_ACL_GET_PERM_NP,[
 +				AC_TRY_LINK([#include <sys/types.h>
 +#include <sys/acl.h>],
@@ -1358,53 +1468,68 @@
 +
  AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
  AC_OUTPUT
  
 --- old/flist.c
 +++ new/flist.c
-@@ -966,6 +966,10 @@ static struct file_struct *send_file_nam
- 			 f == -2 ? SERVER_FILTERS : ALL_FILTERS);
- 	if (!file)
- 		return NULL;
+@@ -44,6 +44,7 @@ extern int filesfrom_fd;
+ extern int one_file_system;
+ extern int copy_dirlinks;
+ extern int keep_dirlinks;
++extern int preserve_acls;
+ extern int preserve_links;
+ extern int preserve_hard_links;
+ extern int preserve_devices;
+@@ -965,6 +966,11 @@ static struct file_struct *send_file_nam
+ 	if (chmod_modes && !S_ISLNK(file->mode))
+ 		file->mode = tweak_mode(file->mode, chmod_modes);
+ 
 +#ifdef SUPPORT_ACLS
-+	if (make_acl(file, fname) < 0)
++	if (preserve_acls && make_acl(file, fname) < 0)
 +		return NULL;
 +#endif
++
+ 	maybe_emit_filelist_progress(flist->count + flist_count_offset);
  
- 	if (chmod_modes && !S_ISLNK(file->mode))
- 		file->mode = tweak_mode(file->mode, chmod_modes);
-@@ -977,6 +981,12 @@ static struct file_struct *send_file_nam
+ 	flist_expand(flist);
+@@ -972,6 +978,16 @@ static struct file_struct *send_file_nam
  	if (file->basename[0]) {
  		flist->files[flist->count++] = file;
  		send_file_entry(file, f);
 +#ifdef SUPPORT_ACLS
-+		send_acl(file, f);
++		if (preserve_acls)
++			send_acl(file, f);
++#endif
 +	} else {
++#ifdef SUPPORT_ACLS
 +		/* Cleanup unsent ACL(s). */
-+		send_acl(file, -1);
++		if (preserve_acls)
++			send_acl(file, -1);
 +#endif
  	}
  	return file;
  }
-@@ -1365,6 +1375,10 @@ struct file_list *recv_file_list(int f)
+@@ -1360,6 +1376,11 @@ struct file_list *recv_file_list(int f)
  			flags |= read_byte(f) << 8;
  		file = receive_file_entry(flist, flags, f);
  
 +#ifdef SUPPORT_ACLS
-+		receive_acl(file, f);
++		if (preserve_acls)
++			receive_acl(file, f);
 +#endif
 +
  		if (S_ISREG(file->mode) || S_ISLNK(file->mode))
  			stats.total_size += file->length;
  
-@@ -1387,6 +1401,10 @@ struct file_list *recv_file_list(int f)
+@@ -1382,6 +1403,11 @@ struct file_list *recv_file_list(int f)
  
  	clean_flist(flist, relative_paths, 1);
  
 +#ifdef SUPPORT_ACLS
-+	sort_file_acl_index_lists();
++	if (preserve_acls)
++		sort_file_acl_index_lists();
 +#endif
 +
  	if (f >= 0) {
  		recv_uid_list(f, flist);
  
 --- old/generator.c
@@ -1414,53 +1539,70 @@
  extern int force_delete;
  extern int one_file_system;
 +extern mode_t orig_umask;
  extern struct stats stats;
  extern dev_t filesystem_dev;
  extern char *backup_dir;
-@@ -753,6 +754,7 @@ static int try_dests_non(struct file_str
+@@ -319,6 +320,8 @@ static void do_delete_pass(struct file_l
+ 
+ int unchanged_attrs(struct file_struct *file, STRUCT_STAT *st)
+ {
++	/* FIXME: Flag ACL changes. */
++
+ 	if (preserve_perms
+ 	 && (st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS))
+ 		return 0;
+@@ -353,6 +356,7 @@ void itemize(struct file_struct *file, i
+ 		if (preserve_gid && file->gid != GID_NONE
+ 		    && st->st_gid != file->gid)
+ 			iflags |= ITEM_REPORT_GROUP;
++		/* FIXME: Itemize ACL changes.  ITEM_REPORT_XATTR? */
+ 	} else
+ 		iflags |= ITEM_IS_NEW;
+ 
+@@ -769,6 +773,7 @@ static int try_dests_non(struct file_str
  }
  
  static int phase = 0;
 +static int dflt_perms;
  
  /* Acts on the_file_list->file's ndx'th item, whose name is fname.  If a dir,
   * make sure it exists, and has the right permissions/timestamp info.  For
-@@ -844,6 +846,10 @@ static void recv_generator(char *fname, 
+@@ -860,6 +865,10 @@ static void recv_generator(char *fname, 
  			}
  			if (fuzzy_basis)
  				need_fuzzy_dirlist = 1;
 +#ifdef SUPPORT_ACLS
 +			if (!preserve_perms)
 +				dflt_perms = default_perms_for_dir(dn);
 +#endif
  		}
  		parent_dirname = dn;
  
-@@ -871,7 +877,8 @@ static void recv_generator(char *fname, 
+@@ -887,7 +896,8 @@ static void recv_generator(char *fname, 
  	if (!preserve_perms) {
  		int exists = statret == 0
  			  && S_ISDIR(st.st_mode) == S_ISDIR(file->mode);
 -		file->mode = dest_mode(file->mode, st.st_mode, exists);
 +		file->mode = dest_mode(file->mode, st.st_mode, dflt_perms,
 +				       exists);
  	}
  
  	if (S_ISDIR(file->mode)) {
-@@ -1343,6 +1350,8 @@ void generate_files(int f_out, struct fi
+@@ -1366,6 +1376,8 @@ void generate_files(int f_out, struct fi
  	 * notice that and let us know via the redo pipe (or its closing). */
  	ignore_timeout = 1;
  
 +	dflt_perms = (ACCESSPERMS & ~orig_umask);
 +
  	for (i = 0; i < flist->count; i++) {
  		struct file_struct *file = flist->files[i];
  
 --- old/lib/sysacls.c
 +++ new/lib/sysacls.c
-@@ -0,0 +1,3242 @@
+@@ -0,0 +1,3240 @@
 +/* 
 +   Unix SMB/CIFS implementation.
 +   Samba system utilities for ACL support.
 +   Copyright (C) Jeremy Allison 2000.
 +   
 +   This program is free software; you can redistribute it and/or modify
@@ -2097,13 +2239,12 @@
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +
 +	for (i = 0; i < acl_d->count; i++) {
 +		struct acl	*ap	= &acl_d->acl[i];
-+		struct passwd	*pw;
 +		struct group	*gr;
 +		char		tagbuf[12];
 +		char		idbuf[12];
 +		char		*tag;
 +		char		*id	= "";
 +		char		perms[4];
@@ -2200,13 +2341,13 @@
 +	/*
 +	 * note that since the definition of the structure pointed
 +	 * to by the SMB_ACL_T includes the first element of the
 +	 * acl[] array, this actually allocates an ACL with room
 +	 * for (count+1) entries
 +	 */
-+	if ((a = SMB_MALLOC(sizeof(struct SMB_ACL_T) + count * sizeof(struct acl))) == NULL) {
++	if ((a = (SMB_ACL_T)SMB_MALLOC(sizeof(struct SMB_ACL_T) + count * sizeof(struct acl))) == NULL) {
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +
 +	a->size = count + 1;
 +	a->count = 0;
@@ -2443,13 +2584,13 @@
 +int sys_acl_free_acl(SMB_ACL_T acl_d) 
 +{
 +	SAFE_FREE(acl_d);
 +	return 0;
 +}
 +
-+int sys_acl_free_qualifier(void *qual, SMB_ACL_TAG_T tagtype)
++int sys_acl_free_qualifier(UNUSED(void *qual), UNUSED(SMB_ACL_TAG_T tagtype))
 +{
 +	return 0;
 +}
 +
 +#elif defined(HAVE_HPUX_ACLS)
 +#include <dl.h>
@@ -2728,13 +2869,12 @@
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +
 +	for (i = 0; i < acl_d->count; i++) {
 +		struct acl	*ap	= &acl_d->acl[i];
-+		struct passwd	*pw;
 +		struct group	*gr;
 +		char		tagbuf[12];
 +		char		idbuf[12];
 +		char		*tag;
 +		char		*id	= "";
 +		char		perms[4];
@@ -4749,70 +4889,71 @@
  int preserve_links = 0;
  int preserve_hard_links = 0;
 +int preserve_acls = 0;
  int preserve_perms = 0;
  int preserve_executability = 0;
  int preserve_devices = 0;
-@@ -194,6 +195,7 @@ static void print_rsync_version(enum log
+@@ -192,6 +193,7 @@ static void print_rsync_version(enum log
  	char const *got_socketpair = "no ";
  	char const *have_inplace = "no ";
  	char const *hardlinks = "no ";
 +	char const *acls = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
  	STRUCT_STAT *dumstat;
-@@ -210,6 +212,10 @@ static void print_rsync_version(enum log
+@@ -208,6 +210,10 @@ static void print_rsync_version(enum log
  	hardlinks = "";
  #endif
  
 +#ifdef SUPPORT_ACLS
 +	acls = "";
 +#endif
 +
  #ifdef SUPPORT_LINKS
  	links = "";
  #endif
-@@ -223,9 +229,9 @@ static void print_rsync_version(enum log
+@@ -221,9 +227,9 @@ static void print_rsync_version(enum log
  	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
  	rprintf(f, "<http://rsync.samba.org/>\n");
  	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
 -		"%shard links, %ssymlinks, batchfiles,\n",
 +		"%shard links, %sACLs, %ssymlinks, batchfiles,\n",
  		(int) (sizeof (OFF_T) * 8),
 -		got_socketpair, hardlinks, links);
 +		got_socketpair, hardlinks, acls, links);
  
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
-@@ -295,6 +301,9 @@ void usage(enum logcode F)
+@@ -293,6 +299,9 @@ void usage(enum logcode F)
    rprintf(F," -H, --hard-links            preserve hard links\n");
    rprintf(F," -p, --perms                 preserve permissions\n");
    rprintf(F," -E, --executability         preserve the file's executability\n");
 +#ifdef SUPPORT_ACLS
 +  rprintf(F," -A, --acls                  preserve ACLs (implies --perms)\n");
 +#endif
    rprintf(F,"     --chmod=CHMOD           change destination permissions\n");
    rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
    rprintf(F," -g, --group                 preserve group\n");
-@@ -410,6 +419,9 @@ static struct poptOption long_options[] 
+@@ -408,6 +417,9 @@ static struct poptOption long_options[] 
    {"no-perms",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
    {"no-p",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
    {"executability",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },
 +  {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
 +  {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
 +  {"no-A",             0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
    {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
    {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
    {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
-@@ -1068,6 +1080,23 @@ int parse_arguments(int *argc, const cha
+@@ -1066,6 +1078,24 @@ int parse_arguments(int *argc, const cha
  			usage(FINFO);
  			exit_cleanup(0);
  
 +		case 'A':
 +#ifdef SUPPORT_ACLS
-+			preserve_acls = preserve_perms = 1;
++			preserve_acls++;
++			preserve_perms = 1;
 +			break;
 +#else
 +			/* FIXME: this should probably be ignored with a
 + 			 * warning and then countermeasures taken to
 + 			 * restrict group and other access in the presence
 + 			 * of any more restrictive ACLs, but this is safe
@@ -4824,13 +4965,13 @@
 +#endif
 +
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1511,6 +1540,10 @@ void server_options(char **args,int *arg
+@@ -1508,6 +1538,10 @@ void server_options(char **args,int *arg
  
  	if (preserve_hard_links)
  		argstr[x++] = 'H';
 +#ifdef SUPPORT_ACLS
 +	if (preserve_acls)
 +		argstr[x++] = 'A';
@@ -4876,48 +5017,60 @@
 +					       dflt_perms, exists);
  		}
  
  		/* We now check to see if we are writing file "inplace" */
 --- old/rsync.c
 +++ new/rsync.c
-@@ -101,7 +101,8 @@ void free_sums(struct sum_struct *s)
+@@ -33,6 +33,7 @@
+ extern int verbose;
+ extern int dry_run;
+ extern int daemon_log_format_has_i;
++extern int preserve_acls;
+ extern int preserve_perms;
+ extern int preserve_executability;
+ extern int preserve_times;
+@@ -101,7 +102,8 @@ void free_sums(struct sum_struct *s)
  
  /* This is only called when we aren't preserving permissions.  Figure out what
   * the permissions should be and return them merged back into the mode. */
 -mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int exists)
 +mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int dflt_perms,
 +		 int exists)
  {
  	/* If the file already exists, we'll return the local permissions,
  	 * possibly tweaked by the --executability option. */
-@@ -116,7 +117,7 @@ mode_t dest_mode(mode_t flist_mode, mode
+@@ -116,7 +118,7 @@ mode_t dest_mode(mode_t flist_mode, mode
  				cur_mode |= (cur_mode & 0444) >> 2;
  		}
  	} else
 -		cur_mode = flist_mode & ACCESSPERMS & ~orig_umask;
 +		cur_mode = flist_mode & ACCESSPERMS & dflt_perms;
  	if (daemon_chmod_modes && !S_ISLNK(flist_mode))
  		cur_mode = tweak_mode(cur_mode, daemon_chmod_modes);
  	return (flist_mode & ~CHMOD_BITS) | (cur_mode & CHMOD_BITS);
-@@ -217,6 +218,13 @@ int set_file_attrs(char *fname, struct f
+@@ -203,6 +205,17 @@ int set_file_attrs(char *fname, struct f
+ 		updated = 1;
  	}
- #endif
  
 +#ifdef SUPPORT_ACLS
-+	/* It's fine to call set_acl() now; the generator will enable
-+	 * writability on the directory using chmod if necessary. */
-+	if (set_acl(fname, file) == 0)
++	/* It's OK to call set_acl() now, even for a dir, as the generator
++	 * will enable owner-writability using chmod, if necessary.
++	 * 
++	 * If set_acl changes permission bits in the process of setting
++	 * an access ACL, it changes st->st_mode so we know whether we
++	 * need to chmod. */
++	if (preserve_acls && set_acl(fname, file, &st->st_mode) == 0)
 +		updated = 1;
 +#endif
 +
- 	if (verbose > 1 && flags & ATTRS_REPORT) {
- 		enum logcode code = daemon_log_format_has_i || dry_run
- 				  ? FCLIENT : FINFO;
+ #ifdef HAVE_CHMOD
+ 	if ((st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS)) {
+ 		int ret = do_chmod(fname, file->mode);
 --- old/rsync.h
 +++ new/rsync.h
-@@ -658,6 +658,20 @@ struct chmod_mode_struct;
+@@ -660,6 +660,20 @@ struct chmod_mode_struct;
  
  #define UNUSED(x) x __attribute__((__unused__))
  
 +#if HAVE_POSIX_ACLS|HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|\
 +    HAVE_HPUX_ACLS|HAVE_IRIX_ACLS|HAVE_AIX_ACLS|HAVE_TRU64_ACLS
 +#define SUPPORT_ACLS 1
@@ -4968,26 +5121,31 @@
 +non-ACL-enabled) rsyncs use the umask even if default ACLs are present.
 +(Keep in mind that it is the version of the receiving rsync that affects
 +these behaviors.)
  
  dit(bf(-E, --executability)) This option causes rsync to preserve the
  executability (or non-executability) of regular files when bf(--perms) is
-@@ -793,6 +798,10 @@ quote(itemize(
+@@ -793,6 +798,15 @@ quote(itemize(
  
  If bf(--perms) is enabled, this option is ignored.
  
 +dit(bf(-A, --acls)) This option causes rsync to update the destination
 +ACLs to be the same as the source ACLs.  This nonstandard option only
 +works if the remote rsync also supports it.  bf(--acls) implies bf(--perms).
 +
++Note also that an optimization of the ACL-sending protocol used by this
++version makes it incompatible with sending files to an older ACL-enabled
++rsync unless you double the bf(--acls) option (e.g. bf(-AA)).  This
++doubling is not needed when pulling files from an older rsync.
++
  dit(bf(--chmod)) This option tells rsync to apply one or more
  comma-separated "chmod" strings to the permission of the files in the
  transfer.  The resulting value is treated as though it was the permissions
 --- old/smb_acls.h
 +++ new/smb_acls.h
-@@ -0,0 +1,277 @@
+@@ -0,0 +1,281 @@
 +/* 
 +   Unix SMB/Netbios implementation.
 +   Version 2.2.x
 +   Portable SMB ACL interface
 +   Copyright (C) Jeremy Allison 2000
 +   
@@ -5104,12 +5262,16 @@
 +#define SMB_ACL_FIRST_ENTRY	0
 +#define SMB_ACL_NEXT_ENTRY	1
 +
 +#define SMB_ACL_TYPE_ACCESS	0
 +#define SMB_ACL_TYPE_DEFAULT	1
 +
++#ifdef __CYGWIN__
++#define SMB_ACL_LOSES_SPECIAL_MODE_BITS
++#endif
++
 +#elif defined HAVE_HPUX_ACLS
 +
 +/*
 + * Based on the Solaris & UnixWare code.
 + */
 +
@@ -5259,34 +5421,81 @@
 +
 +#define SMB_ACL_TYPE_ACCESS	0
 +#define SMB_ACL_TYPE_DEFAULT	1
 +
 +#endif /* No ACLs. */
 +#endif /* _SMB_ACLS_H */
+--- old/testsuite/acls.test
++++ new/testsuite/acls.test
+@@ -0,0 +1,34 @@
++#! /bin/sh
++
++# This program is distributable under the terms of the GNU GPL (see
++# COPYING).
++
++# Test that rsync handles basic ACL preservation.
++
++. $srcdir/testsuite/rsync.fns
++
++$RSYNC --version | grep ", ACLs" >/dev/null || test_skipped "Rsync is configured without ACL support"
++case "$setfacl_nodef" in
++true) test_skipped "I don't know how to use your setfacl command" ;;
++esac
++
++makepath "$fromdir/foo"
++echo something >"$fromdir/file1"
++echo else >"$fromdir/file2"
++
++files='foo file1 file2'
++
++setfacl -m u:0:7 "$fromdir/foo" || test_skipped "Your filesystem has ACLs disabled"
++setfacl -m u:0:5 "$fromdir/file1"
++setfacl -m u:0:5 "$fromdir/file2"
++
++$RSYNC -avvA "$fromdir/" "$todir/"
++
++cd "$fromdir"
++getfacl $files >"$scratchdir/acls.txt"
++
++cd "$todir"
++getfacl $files | diff $diffopt "$scratchdir/acls.txt" -
++
++# The script would have aborted on error, so getting here means we've won.
++exit 0
 --- old/testsuite/default-acls.test
 +++ new/testsuite/default-acls.test
-@@ -0,0 +1,55 @@
+@@ -0,0 +1,65 @@
 +#! /bin/sh
 +
-+# This program is distributable under the terms of the GNU GPL see
++# This program is distributable under the terms of the GNU GPL (see
 +# COPYING).
 +
 +# Test that rsync obeys default ACLs. -- Matt McCutchen
 +
 +. $srcdir/testsuite/rsync.fns
 +
 +$RSYNC --version | grep ", ACLs" >/dev/null || test_skipped "Rsync is configured without ACL support"
-+setfacl -dm u::rwx,g::---,o::--- "$scratchdir" || test_skipped "Your filesystem has ACLs disabled"
++case "$setfacl_nodef" in
++true) test_skipped "I don't know how to use your setfacl command" ;;
++*-k*) opts='-dm u::7,g::5,o:5' ;;
++*) opts='-m d:u::7,d:g::5,d:o:5' ;;
++esac
++setfacl $opts "$scratchdir" || test_skipped "Your filesystem has ACLs disabled"
 +
 +# Call as: testit <dirname> <default-acl> <file-expected> <program-expected>
 +testit() {
 +    todir="$scratchdir/$1"
 +    mkdir "$todir"
-+    # FIXME This doesn't work on solaris...
-+    setfacl -k "$todir"
-+    [ "$2" ] && setfacl -dm "$2" "$todir"
++    $setfacl_nodef "$todir"
++    if [ "$2" ]; then
++	case "$setfacl_nodef" in
++	*-k*) opts="-dm $2" ;;
++	*) opts="-m `echo $2 | sed 's/\([ugom]:\)/d:\1/g'`"
++	esac
++	setfacl $opts "$todir"
++    fi
 +    # Make sure we obey ACLs when creating a directory to hold multiple transferred files,
 +    # even though the directory itself is outside the transfer
 +    $RSYNC -rvv "$scratchdir/dir" "$scratchdir/file" "$scratchdir/program" "$todir/to/"
 +    check_perms "$todir/to" $4 "Target $1"
 +    check_perms "$todir/to/dir" $4 "Target $1"
 +    check_perms "$todir/to/file" $3 "Target $1"
@@ -5305,16 +5514,16 @@
 +chmod 777 "$scratchdir/dir"
 +chmod 666 "$scratchdir/file"
 +chmod 777 "$scratchdir/program"
 +
 +# Test some target directories
 +umask 0077
-+testit da777 u::rwx,g::rwx,o::rwx rw-rw-rw- rwxrwxrwx
-+testit da775 u::rwx,g::rwx,o::r-x rw-rw-r-- rwxrwxr-x
-+testit da750 u::rwx,g::r-x,o::--- rw-r----- rwxr-x---
-+testit da770mask u::rwx,g::---,m::rwx,o::--- rw-rw---- rwxrwx---
++testit da777 u::7,g::7,o:7 rw-rw-rw- rwxrwxrwx
++testit da775 u::7,g::7,o:5 rw-rw-r-- rwxrwxr-x
++testit da750 u::7,g::5,o:0 rw-r----- rwxr-x---
++testit da770mask u::7,u:0:7,g::0,m:7,o:0 rw-rw---- rwxrwx---
 +testit noda1 '' rw------- rwx------
 +umask 0000
 +testit noda2 '' rw-rw-rw- rwxrwxrwx
 +umask 0022
 +testit noda3 '' rw-r--r-- rwxr-xr-x
 +
@@ -5363,55 +5572,51 @@
  
 -	if (preserve_gid && !numeric_ids) {
 +	if ((preserve_gid || preserve_acls) && !numeric_ids) {
  		/* read the gid list */
  		while ((id = read_int(f)) != 0) {
  			int len = read_byte(f);
-@@ -336,6 +337,18 @@ void recv_uid_list(int f, struct file_li
+@@ -336,6 +337,16 @@ void recv_uid_list(int f, struct file_li
  		}
  	}
  
 +#ifdef SUPPORT_ACLS
 +	if (preserve_acls && !numeric_ids) {
-+		id_t id;
-+		/* The enumerations don't return 0 except to flag the last
-+		 * entry, since uidlist doesn't munge 0 anyway. */
-+		while ((id = next_acl_uid(flist)) != 0)
-+			acl_uid_map(match_uid(id));
-+		while ((id = next_acl_gid(flist)) != 0)
-+			acl_gid_map(match_gid(id));
++		id_t *id;
++		while ((id = next_acl_uid(flist)) != NULL)
++			*id = match_uid(*id);
++		while ((id = next_acl_gid(flist)) != NULL)
++			*id = match_gid(*id);
 +	}
-+#endif /* SUPPORT_ACLS */
++#endif
 +
  	/* Now convert all the uids/gids from sender values to our values. */
  	if (am_root && preserve_uid && !numeric_ids) {
  		for (i = 0; i < flist->count; i++)
 --- old/proto.h
 +++ new/proto.h
-@@ -1,6 +1,20 @@
+@@ -1,6 +1,18 @@
  /* This file is automatically generated with "make proto". DO NOT EDIT */
  
  int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
 +int make_acl(const struct file_struct *file, const char *fname);
 +void send_acl(const struct file_struct *file, int f);
 +void receive_acl(struct file_struct *file, int f);
 +void sort_file_acl_index_lists();
 +int dup_acl(const char *orig, const char *bak, mode_t mode);
 +void push_keep_backup_acl(const struct file_struct *file,
 +			  const char *orig, const char *dest);
 +void cleanup_keep_backup_acl();
-+int set_acl(const char *fname, const struct file_struct *file);
-+id_t next_acl_uid();
-+id_t next_acl_gid();
-+void acl_uid_map(id_t uid);
-+void acl_gid_map(id_t gid);
++int set_acl(const char *fname, const struct file_struct *file, mode_t *mode_p);
++id_t *next_acl_uid();
++id_t *next_acl_gid();
 +int default_perms_for_dir(const char *dir);
  void base64_encode(char *buf, int len, char *out, int pad);
  char *auth_server(int f_in, int f_out, int module, char *host, char *addr,
  		  char *leader);
-@@ -224,7 +238,8 @@ void show_progress(OFF_T ofs, OFF_T size
+@@ -223,7 +235,8 @@ void show_progress(OFF_T ofs, OFF_T size
  int recv_files(int f_in, struct file_list *flist, char *local_name);
  void setup_iconv();
  void free_sums(struct sum_struct *s);
 -mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int exists);
 +mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int dflt_perms,
 +		 int exists);
@@ -5609,13 +5814,13 @@
 +fi
 +
 +
  echo "$as_me:$LINENO: checking whether utime accepts a null argument" >&5
  echo $ECHO_N "checking whether utime accepts a null argument... $ECHO_C" >&6
  if test "${ac_cv_func_utime_null+set}" = set; then
-@@ -12102,6 +12280,556 @@ fi
+@@ -12110,6 +12288,558 @@ fi
  
  
  
 +
 +for ac_header in sys/acl.h
 +do
@@ -5887,13 +6092,13 @@
 +
 +cat >>confdefs.h <<\_ACEOF
 +#define HAVE_UNIXWARE_ACLS 1
 +_ACEOF
 +
 +			;;
-+		*solaris*)
++		*solaris*|*cygwin*)
 +			echo "$as_me:$LINENO: result: Using solaris ACLs" >&5
 +echo "${ECHO_T}Using solaris ACLs" >&6
 +
 +cat >>confdefs.h <<\_ACEOF
 +#define HAVE_SOLARIS_ACLS 1
 +_ACEOF
@@ -6064,12 +6269,14 @@
 +fi
 +rm -f conftest.err conftest.$ac_objext \
 +      conftest$ac_exeext conftest.$ac_ext
 +fi
 +echo "$as_me:$LINENO: result: $samba_cv_HAVE_POSIX_ACLS" >&5
 +echo "${ECHO_T}$samba_cv_HAVE_POSIX_ACLS" >&6
++			echo "$as_me:$LINENO: checking ACL test results" >&5
++echo $ECHO_N "checking ACL test results... $ECHO_C" >&6
 +			if test x"$samba_cv_HAVE_POSIX_ACLS" = x"yes"; then
 +			    echo "$as_me:$LINENO: result: Using posix ACLs" >&5
 +echo "${ECHO_T}Using posix ACLs" >&6
 +
 +cat >>confdefs.h <<\_ACEOF
 +#define HAVE_POSIX_ACLS 1
@@ -6168,13 +6375,13 @@
 +
                                                    ac_config_files="$ac_config_files Makefile lib/dummy zlib/dummy popt/dummy shconfig"
  
  cat >confcache <<\_ACEOF
 --- old/config.h.in
 +++ new/config.h.in
-@@ -21,6 +21,15 @@
+@@ -27,6 +27,15 @@
  /* Define to 1 if the `getpgrp' function requires zero arguments. */
  #undef GETPGRP_VOID
  
 +/* Define to 1 if you have the `aclsort' function. */
 +#undef HAVE_ACLSORT
 +
@@ -6184,53 +6391,53 @@
 +/* true if you have AIX ACLs */
 +#undef HAVE_AIX_ACLS
 +
  /* Define to 1 if you have `alloca', as a function or macro. */
  #undef HAVE_ALLOCA
  
-@@ -113,6 +122,9 @@
+@@ -119,6 +128,9 @@
  /* Define to 1 if you have the <grp.h> header file. */
  #undef HAVE_GRP_H
  
 +/* true if you have HPUX ACLs */
 +#undef HAVE_HPUX_ACLS
 +
  /* Define to 1 if you have the <iconv.h> header file. */
  #undef HAVE_ICONV_H
  
-@@ -128,6 +140,9 @@
+@@ -134,6 +146,9 @@
  /* Define to 1 if you have the <inttypes.h> header file. */
  #undef HAVE_INTTYPES_H
  
 +/* true if you have IRIX ACLs */
 +#undef HAVE_IRIX_ACLS
 +
  /* Define to 1 if you have the <langinfo.h> header file. */
  #undef HAVE_LANGINFO_H
  
-@@ -137,6 +152,9 @@
+@@ -143,6 +158,9 @@
  /* Define to 1 if you have the `lchown' function. */
  #undef HAVE_LCHOWN
  
 +/* Define to 1 if you have the `acl' library (-lacl). */
 +#undef HAVE_LIBACL
 +
  /* Define to 1 if you have the <libcharset.h> header file. */
  #undef HAVE_LIBCHARSET_H
  
-@@ -155,6 +173,9 @@
+@@ -161,6 +179,9 @@
  /* Define to 1 if you have the `resolv' library (-lresolv). */
  #undef HAVE_LIBRESOLV
  
 +/* Define to 1 if you have the `sec' library (-lsec). */
 +#undef HAVE_LIBSEC
 +
  /* Define to 1 if you have the `socket' library (-lsocket). */
  #undef HAVE_LIBSOCKET
  
-@@ -216,9 +237,15 @@
+@@ -222,9 +243,15 @@
  /* Define to 1 if you have the `nl_langinfo' function. */
  #undef HAVE_NL_LANGINFO
  
 +/* true if you don't have ACLs */
 +#undef HAVE_NO_ACLS
 +
@@ -6240,33 +6447,33 @@
 +/* true if you have posix ACLs */
 +#undef HAVE_POSIX_ACLS
 +
  /* Define to 1 if you have the `putenv' function. */
  #undef HAVE_PUTENV
  
-@@ -270,6 +297,9 @@
+@@ -276,6 +303,9 @@
  /* Define to 1 if you have the "socketpair" function */
  #undef HAVE_SOCKETPAIR
  
 +/* true if you have solaris ACLs */
 +#undef HAVE_SOLARIS_ACLS
 +
  /* Define to 1 if you have the <stdint.h> header file. */
  #undef HAVE_STDINT_H
  
-@@ -315,6 +345,9 @@
+@@ -321,6 +351,9 @@
  /* Define to 1 if `st_rdev' is member of `struct stat'. */
  #undef HAVE_STRUCT_STAT_ST_RDEV
  
 +/* Define to 1 if you have the <sys/acl.h> header file. */
 +#undef HAVE_SYS_ACL_H
 +
  /* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
     */
  #undef HAVE_SYS_DIR_H
-@@ -365,9 +398,15 @@
+@@ -371,9 +404,15 @@
  /* Define to 1 if you have the `tcgetpgrp' function. */
  #undef HAVE_TCGETPGRP
  
 +/* true if you have Tru64 ACLs */
 +#undef HAVE_TRU64_ACLS
 +
@@ -6276,13 +6483,13 @@
 +/* true if you have UnixWare ACLs */
 +#undef HAVE_UNIXWARE_ACLS
 +
  /* Define to 1 if you have the "struct utimbuf" type */
  #undef HAVE_UTIMBUF
  
-@@ -398,6 +437,18 @@
+@@ -404,6 +443,18 @@
  /* Define to 1 if you have the `waitpid' function. */
  #undef HAVE_WAITPID
  
 +/* Define to 1 if you have the `_acl' function. */
 +#undef HAVE__ACL
 +
@@ -6331,18 +6538,23 @@
 +non-ACL-enabled) rsyncs use the umask even if default ACLs are present\&.
 +(Keep in mind that it is the version of the receiving rsync that affects
 +these behaviors\&.)
  .IP 
  .IP "\fB-E, --executability\fP" 
  This option causes rsync to preserve the
-@@ -903,6 +908,11 @@ has a corresponding \&'r\&' permission e
+@@ -903,6 +908,16 @@ has a corresponding \&'r\&' permission e
  .IP 
  If \fB--perms\fP is enabled, this option is ignored\&.
  .IP 
 +.IP "\fB-A, --acls\fP" 
 +This option causes rsync to update the destination
 +ACLs to be the same as the source ACLs\&.  This nonstandard option only
 +works if the remote rsync also supports it\&.  \fB--acls\fP implies \fB--perms\fP\&.
 +.IP 
++Note also that an optimization of the ACL-sending protocol used by this
++version makes it incompatible with sending files to an older ACL-enabled
++rsync unless you double the \fB--acls\fP option (e\&.g\&. \fB-AA\fP)\&.  This
++doubling is not needed when pulling files from an older rsync\&.
++.IP 
  .IP "\fB--chmod\fP" 
  This option tells rsync to apply one or more
  comma-separated "chmod" strings to the permission of the files in the
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/adaptec_acl_mods.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/adaptec_acl_mods.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/adaptec_acl_mods.diff	2006-02-09 10:05:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/adaptec_acl_mods.diff	2006-03-22 17:24:41.000000000 +0800
@@ -21,55 +21,102 @@
 > will allow you to preserve acls when copying between different Adaptec
 > based NAS units running SnapOS.
 
 I (Wayne) tweaked the patch for style and to avoid using SMB_* constants
 with literal values were needed.
 
+I've also updated it to apply to the updated version of the acls.diff,
+though I don't know if there might be some bits lost in the current
+algorithm when using the file's mode bits to reconstruct a stripped ACL
+entry.
+
 --- old/acls.c
 +++ new/acls.c
-@@ -146,6 +146,9 @@ static BOOL unpack_smb_acl(rsync_acl *ra
- 		}
- 		race->access = (sys_acl_get_perm(permset, SMB_ACL_READ) ? 4 : 0)
- 			     | (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? 2 : 0)
-+			     | (sys_acl_get_perm(permset, SMB_ACL_DELETE) ? 8 : 0)
-+			     | (sys_acl_get_perm(permset, SMB_ACL_CHMOD) ? 16 : 0)
-+			     | (sys_acl_get_perm(permset, SMB_ACL_CHOWN) ? 32 : 0)
- 			     | (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? 1 : 0);
- 		switch (race->tag_type) {
- 		case SMB_ACL_USER:
-@@ -575,6 +578,21 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
- 				errfun = "sys_acl_add_perm";
- 				break;
- 			}
-+		if (race->access & 8)
-+			if (sys_acl_add_perm(permset, SMB_ACL_DELETE)) {
-+				errfun = "sys_acl_add_perm";
-+				break;
-+			}
-+		if (race->access & 16)
-+			if (sys_acl_add_perm(permset, SMB_ACL_CHMOD)) {
-+				errfun = "sys_acl_add_perm";
-+				break;
-+			}
-+		if (race->access & 32)
-+			if (sys_acl_add_perm(permset, SMB_ACL_CHOWN)) {
-+				errfun = "sys_acl_add_perm";
-+				break;
-+			}
- 		if (sys_acl_set_permset(entry, permset)) {
- 			errfun = "sys_acl_set_permset";
- 			break;
-@@ -634,7 +652,7 @@ static void receive_rsync_acl(rsync_acl 
- 			exit_cleanup(RERR_STREAMIO);
+@@ -84,10 +84,10 @@ static int calc_sacl_entries(const rsync
+ 
+ static int rsync_acl_get_perms(const rsync_acl *racl)
+ {
+-	/* Note that (ACL_NO_ENTRY & 7) is 0. */
+-	return ((racl->user_obj & 7) << 6)
+-	     + (((racl->mask != ACL_NO_ENTRY ? racl->mask : racl->group_obj) & 7) << 3)
+-	     + (racl->other & 7);
++	/* Note that (ACL_NO_ENTRY & 077) is 0. */
++	return ((racl->user_obj & 077) << 6)
++	     + (((racl->mask != ACL_NO_ENTRY ? racl->mask : racl->group_obj) & 077) << 3)
++	     + (racl->other & 077);
+ }
+ 
+ static void rsync_acl_strip_perms(rsync_acl *racl)
+@@ -178,6 +178,9 @@ static BOOL unpack_smb_acl(rsync_acl *ra
  		}
- 		race->access = read_byte(f);
--		if (race->access & ~ (4 | 2 | 1)) {
-+		if (race->access & ~(32 | 16 | 8 | 4 | 2 | 1)) {
+ 		access = (sys_acl_get_perm(permset, SMB_ACL_READ) ? 4 : 0)
+ 		       | (sys_acl_get_perm(permset, SMB_ACL_WRITE) ? 2 : 0)
++		       | (sys_acl_get_perm(permset, SMB_ACL_DELETE) ? 8 : 0)
++		       | (sys_acl_get_perm(permset, SMB_ACL_CHMOD) ? 16 : 0)
++		       | (sys_acl_get_perm(permset, SMB_ACL_CHOWN) ? 32 : 0)
+ 		       | (sys_acl_get_perm(permset, SMB_ACL_EXECUTE) ? 1 : 0);
+ 		/* continue == done with entry; break == store in given idal */
+ 		switch (tag_type) {
+@@ -587,6 +590,12 @@ static int store_access_in_entry(uchar a
+ 
+ 	COE( sys_acl_get_permset,(entry, &permset) );
+ 	COE( sys_acl_clear_perms,(permset) );
++	if (access & 32)
++		COE( sys_acl_add_perm(permset, SMB_ACL_CHOWN) );
++	if (access & 16)
++		COE( sys_acl_add_perm(permset, SMB_ACL_CHMOD) );
++	if (access & 8)
++		COE( sys_acl_add_perm(permset, SMB_ACL_DELETE) );
+ 	if (access & 4)
+ 		COE( sys_acl_add_perm,(permset, SMB_ACL_READ) );
+ 	if (access & 2)
+@@ -619,7 +628,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
+ 
+ 	COE( sys_acl_create_entry,(smb_acl, &entry) );
+ 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_USER_OBJ) );
+-	COE2( store_access_in_entry,(racl->user_obj & 7, entry) );
++	COE2( store_access_in_entry,(racl->user_obj & 077, entry) );
+ 
+ 	for (ida = racl->users.idas, count = racl->users.count;
+ 	     count--; ida++) {
+@@ -631,7 +640,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
+ 
+ 	COE( sys_acl_create_entry,(smb_acl, &entry) );
+ 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_GROUP_OBJ) );
+-	COE2( store_access_in_entry,(racl->group_obj & 7, entry) );
++	COE2( store_access_in_entry,(racl->group_obj & 077, entry) );
+ 
+ 	for (ida = racl->groups.idas, count = racl->groups.count;
+ 	     count--; ida++) {
+@@ -652,7 +661,7 @@ static BOOL pack_smb_acl(SMB_ACL_T *smb_
+ 
+ 	COE( sys_acl_create_entry,(smb_acl, &entry) );
+ 	COE( sys_acl_set_tag_type,(entry, SMB_ACL_OTHER) );
+-	COE2( store_access_in_entry,(racl->other & 7, entry) );
++	COE2( store_access_in_entry,(racl->other & 077, entry) );
+ 
+ #ifdef DEBUG
+ 	if (sys_acl_valid(*smb_acl) < 0)
+@@ -761,7 +770,7 @@ static void receive_rsync_acl(rsync_acl 
+ 	while (count--) {
+ 		char tag = read_byte(f);
+ 		uchar access = read_byte(f);
+-		if (access & ~ (4 | 2 | 1)) {
++		if (access & ~(32 | 16 | 8 | 4 | 2 | 1)) {
  			rprintf(FERROR, "receive_rsync_acl: bogus permset %o\n",
- 				race->access);
+ 				access);
  			exit_cleanup(RERR_STREAMIO);
+@@ -834,7 +843,7 @@ static void receive_rsync_acl(rsync_acl 
+ 	} else
+ #endif
+ 	if (racl->mask == ACL_NO_ENTRY) /* Always non-empty when needed. */
+-		racl->mask = computed_mask_bits | (racl->group_obj & 7);
++		racl->mask = computed_mask_bits | (racl->group_obj & 077);
+ }
+ 
+ /* receive and build the rsync_acl_lists */
 --- old/smb_acls.h
 +++ new/smb_acls.h
 @@ -33,6 +33,11 @@
  #define SMB_ACL_READ		ACL_READ
  #define SMB_ACL_WRITE		ACL_WRITE
  #define SMB_ACL_EXECUTE		ACL_EXECUTE
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/atimes.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/atimes.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/atimes.diff	2006-03-12 02:44:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/atimes.diff	2006-04-22 23:40:38.000000000 +0800
@@ -12,13 +12,13 @@
  extern int preserve_uid;
  extern int preserve_gid;
 +extern int preserve_atimes;
  extern int relative_paths;
  extern int implied_dirs;
  extern int prune_empty_dirs;
-@@ -84,7 +85,13 @@ void init_flist(void)
+@@ -83,7 +84,13 @@ void init_flist(void)
  	struct file_struct f;
  
  	/* Figure out how big the file_struct is without trailing padding */
 -	file_struct_len = offsetof(struct file_struct, flags) + sizeof f.flags;
 +	if (preserve_atimes)
 +		file_struct_len = offsetof(struct file_struct, fl4g5);
@@ -27,13 +27,13 @@
 +	/* The "flags" uchar is no longer accessed directly, so I
 +	 * mangled the name to fl4g5 as a reminder. */
 +	file_struct_len += sizeof f.fl4g5;
  	checksum_len = protocol_version < 21 ? 2 : MD4_SUM_LENGTH;
  }
  
-@@ -140,16 +147,18 @@ static void list_file_entry(struct file_
+@@ -139,16 +146,18 @@ static void list_file_entry(struct file_
  
  #ifdef SUPPORT_LINKS
  	if (preserve_links && S_ISLNK(f->mode)) {
 -		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
 +		rprintf(FINFO, "%s %11.0f %s %s %s -> %s\n",
  			permbuf,
@@ -48,96 +48,96 @@
  			permbuf,
  			(double)f->length, timestring(f->modtime),
 +			preserve_atimes ? timestring(f->atime) : "",
  			f_name(f, NULL));
  	}
  }
-@@ -311,6 +320,7 @@ static void send_file_entry(struct file_
+@@ -310,6 +319,7 @@ static void send_file_entry(struct file_
  {
  	unsigned short flags;
  	static time_t modtime;
 +	static time_t atime;
  	static mode_t mode;
  	static int64 dev;
  	static dev_t rdev;
-@@ -326,7 +336,7 @@ static void send_file_entry(struct file_
+@@ -325,7 +335,7 @@ static void send_file_entry(struct file_
  
  	if (!file) {
  		write_byte(f, 0);
 -		modtime = 0, mode = 0;
 +		modtime = 0, atime = 0, mode = 0;
  		dev = 0, rdev = makedev(0, 0);
  		rdev_major = 0;
  		uid = 0, gid = 0;
-@@ -338,7 +348,7 @@ static void send_file_entry(struct file_
+@@ -335,7 +345,7 @@ static void send_file_entry(struct file_
  
  	f_name(file, fname);
  
 -	flags = file->flags & XMIT_TOP_DIR;
 +	flags = FFLAGS(file) & XMIT_TOP_DIR;
  
  	if (file->mode == mode)
  		flags |= XMIT_SAME_MODE;
-@@ -374,6 +384,12 @@ static void send_file_entry(struct file_
+@@ -371,6 +381,12 @@ static void send_file_entry(struct file_
  		flags |= XMIT_SAME_TIME;
  	else
  		modtime = file->modtime;
 +	if (preserve_atimes && !S_ISDIR(mode)) {
 +		if (file->atime == atime)
 +			flags |= XMIT_SAME_ATIME;
 +		else
 +			atime = file->atime;
 +	}
  
  #ifdef SUPPORT_HARD_LINKS
  	if (file->link_u.idev) {
-@@ -427,6 +443,8 @@ static void send_file_entry(struct file_
+@@ -424,6 +440,8 @@ static void send_file_entry(struct file_
  		write_int(f, modtime);
  	if (!(flags & XMIT_SAME_MODE))
  		write_int(f, to_wire_mode(mode));
 +	if (preserve_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
 +		write_int(f, atime);
  	if (preserve_uid && !(flags & XMIT_SAME_UID)) {
  		if (!numeric_ids)
  			add_uid(uid);
-@@ -495,6 +513,7 @@ static struct file_struct *receive_file_
+@@ -490,6 +508,7 @@ static struct file_struct *receive_file_
  					      unsigned short flags, int f)
  {
  	static time_t modtime;
 +	static time_t atime;
  	static mode_t mode;
  	static int64 dev;
  	static dev_t rdev;
-@@ -513,7 +532,7 @@ static struct file_struct *receive_file_
+@@ -508,7 +527,7 @@ static struct file_struct *receive_file_
  	struct file_struct *file;
  
  	if (!flist) {
 -		modtime = 0, mode = 0;
 +		modtime = 0, atime = 0, mode = 0;
  		dev = 0, rdev = makedev(0, 0);
  		rdev_major = 0;
  		uid = 0, gid = 0;
-@@ -569,6 +588,8 @@ static struct file_struct *receive_file_
+@@ -564,6 +583,8 @@ static struct file_struct *receive_file_
  		modtime = (time_t)read_int(f);
  	if (!(flags & XMIT_SAME_MODE))
  		mode = from_wire_mode(read_int(f));
 +	if (preserve_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
 +		atime = (time_t)read_int(f);
  
  	if (chmod_modes && !S_ISLNK(mode))
  		mode = tweak_mode(mode, chmod_modes);
-@@ -624,6 +645,8 @@ static struct file_struct *receive_file_
+@@ -619,6 +640,8 @@ static struct file_struct *receive_file_
  	file->mode = mode;
  	file->uid = uid;
  	file->gid = gid;
 +	if (preserve_atimes)
 +		file->atime = atime;
  
  	if (dirname_len) {
  		file->dirname = lastdir = bp;
-@@ -649,12 +672,12 @@ static struct file_struct *receive_file_
+@@ -644,12 +667,12 @@ static struct file_struct *receive_file_
  			    && lastname[del_hier_name_len-1] == '.'
  			    && lastname[del_hier_name_len-2] == '/')
  				del_hier_name_len -= 2;
 -			file->flags |= FLAG_TOP_DIR | FLAG_DEL_HERE;
 +			FFLAGS(file) |= FLAG_TOP_DIR | FLAG_DEL_HERE;
  		} else if (in_del_hier) {
@@ -146,13 +146,13 @@
  			  && lastname[del_hier_name_len] == '/'))
 -				file->flags |= FLAG_DEL_HERE;
 +				FFLAGS(file) |= FLAG_DEL_HERE;
  			else
  				in_del_hier = 0;
  		}
-@@ -870,12 +893,14 @@ struct file_struct *make_file(char *fnam
+@@ -865,12 +888,14 @@ struct file_struct *make_file(char *fnam
  	memset(bp, 0, file_struct_len);
  	bp += file_struct_len;
  
 -	file->flags = flags;
 +	FFLAGS(file) = flags;
  	file->modtime = st.st_mtime;
@@ -162,34 +162,34 @@
  	file->gid = st.st_gid;
 +	if (preserve_atimes)
 +		file->atime = st.st_atime;
  
  #ifdef SUPPORT_HARD_LINKS
  	if (flist && flist->hlink_pool) {
-@@ -988,7 +1013,7 @@ static void send_if_directory(int f, str
+@@ -983,7 +1008,7 @@ static void send_if_directory(int f, str
  	char is_dot_dir = fbuf[ol-1] == '.' && (ol == 1 || fbuf[ol-2] == '/');
  
  	if (S_ISDIR(file->mode)
 -	    && !(file->flags & FLAG_MOUNT_POINT) && f_name(file, fbuf)) {
 +	    && !(FFLAGS(file) & FLAG_MOUNT_POINT) && f_name(file, fbuf)) {
  		void *save_filters;
  		unsigned int len = strlen(fbuf);
  		if (len > 1 && fbuf[len-1] == '/')
-@@ -1594,8 +1619,9 @@ static void clean_flist(struct file_list
+@@ -1589,8 +1614,9 @@ static void clean_flist(struct file_list
  			}
  			/* Make sure we don't lose track of a user-specified
  			 * top directory. */
 -			flist->files[keep]->flags |= flist->files[drop]->flags
 -						   & (FLAG_TOP_DIR|FLAG_DEL_HERE);
 +			FFLAGS(flist->files[keep])
 +			    |= FFLAGS(flist->files[drop])
 +			     & (FLAG_TOP_DIR|FLAG_DEL_HERE);
  
  			clear_file(flist->files[drop], flist);
  
-@@ -1719,7 +1745,7 @@ static void output_flist(struct file_lis
+@@ -1714,7 +1740,7 @@ static void output_flist(struct file_lis
  			file->dirname ? file->dirname : "",
  			file->dirname ? "/" : "", NS(file->basename),
  			S_ISDIR(file->mode) ? "/" : "", (int)file->mode,
 -			(double)file->length, uidbuf, gidbuf, file->flags);
 +			(double)file->length, uidbuf, gidbuf, FFLAGS(file));
  	}
@@ -210,40 +210,40 @@
  extern char *backup_suffix;
  extern int backup_suffix_len;
 +extern unsigned int file_struct_len;
  extern struct file_list *the_file_list;
  extern struct filter_list_struct server_filter_list;
  
-@@ -184,7 +186,7 @@ static int delete_item(char *fname, int 
+@@ -182,7 +184,7 @@ static int delete_item(char *fname, int 
  	for (j = dirlist->count; j--; ) {
  		struct file_struct *fp = dirlist->files[j];
  
 -		if (fp->flags & FLAG_MOUNT_POINT)
 +		if (FFLAGS(fp) & FLAG_MOUNT_POINT)
  			continue;
  
  		strlcpy(p, fp->basename, remainder);
-@@ -262,7 +264,7 @@ static void delete_in_dir(struct file_li
+@@ -260,7 +262,7 @@ static void delete_in_dir(struct file_li
  	filt_array[cur_depth] = push_local_filters(fbuf, dlen);
  
  	if (one_file_system) {
 -		if (file->flags & FLAG_TOP_DIR)
 +		if (FFLAGS(file) & FLAG_TOP_DIR)
  			filesystem_dev = stp->st_dev;
  		else if (filesystem_dev != stp->st_dev)
  			return;
-@@ -274,7 +276,7 @@ static void delete_in_dir(struct file_li
+@@ -272,7 +274,7 @@ static void delete_in_dir(struct file_li
  	 * from the filesystem. */
  	for (i = dirlist->count; i--; ) {
  		struct file_struct *fp = dirlist->files[i];
 -		if (!fp->basename || fp->flags & FLAG_MOUNT_POINT)
 +		if (!fp->basename || FFLAGS(fp) & FLAG_MOUNT_POINT)
  			continue;
  		if (flist_find(flist, fp) < 0) {
  			f_name(fp, delbuf);
-@@ -300,11 +302,11 @@ static void do_delete_pass(struct file_l
+@@ -298,11 +300,11 @@ static void do_delete_pass(struct file_l
  	for (j = 0; j < flist->count; j++) {
  		struct file_struct *file = flist->files[j];
  
 -		if (!(file->flags & FLAG_DEL_HERE))
 +		if (!(FFLAGS(file) & FLAG_DEL_HERE))
  			continue;
@@ -251,50 +251,50 @@
  		f_name(file, fbuf);
 -		if (verbose > 1 && file->flags & FLAG_TOP_DIR)
 +		if (verbose > 1 && FFLAGS(file) & FLAG_TOP_DIR)
  			rprintf(FINFO, "deleting in %s\n", fbuf);
  
  		if (link_stat(fbuf, &st, keep_dirlinks) < 0
-@@ -348,6 +350,9 @@ void itemize(struct file_struct *file, i
+@@ -346,6 +348,9 @@ void itemize(struct file_struct *file, i
  		     && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
  		    || (keep_time && cmp_time(file->modtime, st->st_mtime) != 0))
  			iflags |= ITEM_REPORT_TIME;
 +		if (preserve_atimes && !S_ISDIR(file->mode) && !S_ISLNK(file->mode)
 +		 && cmp_time(file->atime, st->st_atime) != 0)
 +			iflags |= ITEM_REPORT_ATIME;
  		if ((file->mode & CHMOD_BITS) != (st->st_mode & CHMOD_BITS))
  			iflags |= ITEM_REPORT_PERMS;
  		if (preserve_uid && am_root && file->uid != st->st_uid)
-@@ -549,7 +554,7 @@ static int find_fuzzy(struct file_struct
+@@ -547,7 +552,7 @@ static int find_fuzzy(struct file_struct
  		uint32 dist;
  
  		if (!S_ISREG(fp->mode) || !fp->length
 -		    || fp->flags & FLAG_NO_FUZZY)
 +		    || FFLAGS(fp) & FLAG_NO_FUZZY)
  			continue;
  
  		name = fp->basename;
-@@ -658,6 +663,8 @@ static int try_dests_reg(struct file_str
+@@ -656,6 +661,8 @@ static int try_dests_reg(struct file_str
  					  itemizing && verbose > 1,
  					  code) < 0)
  				goto try_a_copy;
 +			if (preserve_atimes)
 +				set_file_attrs(fname, file, stp, 0);
  			if (preserve_hard_links && file->link_u.links)
  				hard_link_cluster(file, ndx, itemizing, code);
  		} else if (itemizing)
-@@ -906,7 +913,7 @@ static void recv_generator(char *fname, 
+@@ -922,7 +929,7 @@ static void recv_generator(char *fname, 
  		    && verbose && code && f_out != -1)
  			rprintf(code, "%s/\n", fname);
  		if (delete_during && f_out != -1 && !phase && dry_run < 2
 -		    && (file->flags & FLAG_DEL_HERE))
 +		    && (FFLAGS(file) & FLAG_DEL_HERE))
  			delete_in_dir(the_file_list, fname, file, &st);
  		return;
  	}
-@@ -1188,7 +1195,7 @@ static void recv_generator(char *fname, 
+@@ -1211,7 +1218,7 @@ static void recv_generator(char *fname, 
  	if (fuzzy_dirlist) {
  		int j = flist_find(fuzzy_dirlist, file);
  		if (j >= 0) /* don't use changing file as future fuzzy basis */
 -			fuzzy_dirlist->files[j]->flags |= FLAG_NO_FUZZY;
 +			FFLAGS(fuzzy_dirlist->files[j]) |= FLAG_NO_FUZZY;
  	}
@@ -378,35 +378,35 @@
  int preserve_times = 0;
  int omit_dir_times = 0;
 +int preserve_atimes = 0;
  int update_only = 0;
  int cvs_exclude = 0;
  int dry_run = 0;
-@@ -301,8 +302,9 @@ void usage(enum logcode F)
+@@ -299,8 +300,9 @@ void usage(enum logcode F)
    rprintf(F,"     --devices               preserve device files (super-user only)\n");
    rprintf(F,"     --specials              preserve special files\n");
    rprintf(F," -D                          same as --devices --specials\n");
 -  rprintf(F," -t, --times                 preserve times\n");
 -  rprintf(F," -O, --omit-dir-times        omit directories when preserving times\n");
 +  rprintf(F," -t, --times                 preserve modify times\n");
 +  rprintf(F," -O, --omit-dir-times        omit directories when preserving modify times\n");
 +  rprintf(F," -U, --atimes                preserve access (use) times\n");
    rprintf(F,"     --super                 receiver attempts super-user activities\n");
    rprintf(F," -S, --sparse                handle sparse files efficiently\n");
    rprintf(F," -n, --dry-run               show what would have been transferred\n");
-@@ -413,6 +415,9 @@ static struct poptOption long_options[] 
+@@ -411,6 +413,9 @@ static struct poptOption long_options[] 
    {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
    {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
    {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
 +  {"atimes",          'U', POPT_ARG_VAL,    &preserve_atimes, 1, 0, 0 },
 +  {"no-atimes",        0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
 +  {"no-k",             0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
    {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
    {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
    {"super",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },
-@@ -1519,6 +1524,8 @@ void server_options(char **args,int *arg
+@@ -1516,6 +1521,8 @@ void server_options(char **args,int *arg
  		argstr[x++] = 'D';
  	if (preserve_times)
  		argstr[x++] = 't';
 +	if (preserve_atimes)
 +		argstr[x++] = 'U';
  	if (preserve_perms)
@@ -482,21 +482,13 @@
  #define ATTRS_REPORT		(1<<0)
  #define ATTRS_SKIP_MTIME	(1<<1)
 +#define ATTRS_SKIP_ATIME	(1<<2)
  
  #define FULL_FLUSH	1
  #define NORMAL_FLUSH	0
-@@ -135,6 +137,7 @@
- #define FNAMECMP_FUZZY		0x83
- 
- /* For use by the itemize_changes code */
-+#define ITEM_REPORT_ATIME (1<<0)
- #define ITEM_REPORT_CHECKSUM (1<<1)
- #define ITEM_REPORT_SIZE (1<<2)
- #define ITEM_REPORT_TIME (1<<3)
-@@ -520,9 +523,12 @@ struct file_struct {
+@@ -522,9 +524,12 @@ struct file_struct {
  	uid_t uid;
  	gid_t gid;
  	mode_t mode;
 -	uchar flags;	/* this item MUST remain last */
 +	time_t atime;   /* this MUST be second to last */
 +	uchar fl4g5;	/* this item MUST remain last */
@@ -518,44 +510,44 @@
 + -t, --times                 preserve modify times
 + -O, --omit-dir-times        omit directories when preserving mod-times
 + -U, --atimes                preserve access (use) times
       --super                 receiver attempts super-user activities
   -S, --sparse                handle sparse files efficiently
   -n, --dry-run               show what would have been transferred
-@@ -851,6 +852,12 @@ it is preserving modification times (see
+@@ -858,6 +859,12 @@ it is preserving modification times (see
  the directories on the receiving side, it is a good idea to use bf(-O).
  This option is inferred if you use bf(--backup) without bf(--backup-dir).
  
 +dit(bf(-U, --atimes)) This tells rsync to set the access (use) times of the
 +destination files to the same value as the source files.  Note that the
 +reading of the source file may update the atime of the source files, so
 +repeated rsync runs with --atimes may be needed if you want to force the
 +access-time values to be 100% identical on the two systems.
 +
  dit(bf(--super)) This tells the receiving side to attempt super-user
  activities even if the receiving rsync wasn't run by the super-user.  These
  activities include: preserving users via the bf(--owner) option, preserving
-@@ -1366,7 +1373,7 @@ with older versions of rsync, but that a
+@@ -1373,7 +1380,7 @@ with older versions of rsync, but that a
  verbose messages).
  
  The "%i" escape has a cryptic output that is 9 letters long.  The general
 -format is like the string bf(YXcstpogz), where bf(Y) is replaced by the
 +format is like the string bf(YXcstpogu), where bf(Y) is replaced by the
  type of update being done, bf(X) is replaced by the file-type, and the
  other letters represent attributes that may be output if they are being
  modified.
-@@ -1406,7 +1413,7 @@ quote(itemize(
+@@ -1413,7 +1420,7 @@ quote(itemize(
    by the file transfer.
    it() A bf(t) means the modification time is different and is being updated
    to the sender's value (requires bf(--times)).  An alternate value of bf(T)
 -  means that the time will be set to the transfer time, which happens
 +  means that the modify time will be set to the transfer time, which happens
    anytime a symlink is transferred, or when a file or device is transferred
    without bf(--times).
    it() A bf(p) means the permissions are different and are being updated to
-@@ -1415,7 +1422,10 @@ quote(itemize(
+@@ -1422,7 +1429,10 @@ quote(itemize(
    sender's value (requires bf(--owner) and super-user privileges).
    it() A bf(g) means the group is different and is being updated to the
    sender's value (requires bf(--group) and the authority to set the group).
 -  it() The bf(z) slot is reserved for future use.
 +  it() A bf(u) means the access (use) time is different and is being updated to
 +  the sender's value (requires bf(--atimes)).  An alternate value of bf(U)
@@ -838,13 +830,13 @@
 +		t[0] = atime;
  		t[1] = modtime;
  		return utime(fname,t);
  #else
 --- old/proto.h
 +++ new/proto.h
-@@ -279,7 +279,7 @@ int fd_pair(int fd[2]);
+@@ -278,7 +278,7 @@ int fd_pair(int fd[2]);
  void print_child_argv(char **cmd);
  void out_of_memory(char *str);
  void overflow_exit(char *str);
 -int set_modtime(char *fname, time_t modtime, mode_t mode);
 +int set_times(char *fname, time_t modtime, time_t atime, mode_t mode);
  int mkdir_defmode(char *fname);
@@ -861,13 +853,13 @@
 + -t, --times                 preserve modify times
 + -O, --omit-dir-times        omit directories when preserving mod-times
 + -U, --atimes                preserve access (use) times
       --super                 receiver attempts super-user activities
   -S, --sparse                handle sparse files efficiently
   -n, --dry-run               show what would have been transferred
-@@ -971,6 +972,13 @@ it is preserving modification times (see
+@@ -978,6 +979,13 @@ it is preserving modification times (see
  the directories on the receiving side, it is a good idea to use \fB-O\fP\&.
  This option is inferred if you use \fB--backup\fP without \fB--backup-dir\fP\&.
  .IP 
 +.IP "\fB-U, --atimes\fP" 
 +This tells rsync to set the access (use) times of the
 +destination files to the same value as the source files\&.  Note that the
@@ -875,31 +867,31 @@
 +repeated rsync runs with --atimes may be needed if you want to force the
 +access-time values to be 100% identical on the two systems\&.
 +.IP 
  .IP "\fB--super\fP" 
  This tells the receiving side to attempt super-user
  activities even if the receiving rsync wasn\&'t run by the super-user\&.  These
-@@ -1552,7 +1560,7 @@ with older versions of rsync, but that a
+@@ -1559,7 +1567,7 @@ with older versions of rsync, but that a
  verbose messages)\&.
  .IP 
  The "%i" escape has a cryptic output that is 9 letters long\&.  The general
 -format is like the string \fBYXcstpogz\fP, where \fBY\fP is replaced by the
 +format is like the string \fBYXcstpogu\fP, where \fBY\fP is replaced by the
  type of update being done, \fBX\fP is replaced by the file-type, and the
  other letters represent attributes that may be output if they are being
  modified\&.
-@@ -1600,7 +1608,7 @@ by the file transfer\&.
+@@ -1607,7 +1615,7 @@ by the file transfer\&.
  .IP o 
  A \fBt\fP means the modification time is different and is being updated
  to the sender\&'s value (requires \fB--times\fP)\&.  An alternate value of \fBT\fP
 -means that the time will be set to the transfer time, which happens
 +means that the modify time will be set to the transfer time, which happens
  anytime a symlink is transferred, or when a file or device is transferred
  without \fB--times\fP\&.
  .IP o 
-@@ -1613,7 +1621,10 @@ sender\&'s value (requires \fB--owner\fP
+@@ -1620,7 +1628,10 @@ sender\&'s value (requires \fB--owner\fP
  A \fBg\fP means the group is different and is being updated to the
  sender\&'s value (requires \fB--group\fP and the authority to set the group)\&.
  .IP o 
 -The \fBz\fP slot is reserved for future use\&.
 +A \fBu\fP means the access (use) time is different and is being updated to
 +the sender\&'s value (requires \fB--atimes\fP)\&.  An alternate value of \fBU\fP
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/backup-dir-dels.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/backup-dir-dels.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/backup-dir-dels.diff	2006-03-12 02:44:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/backup-dir-dels.diff	2006-04-22 23:40:45.000000000 +0800
@@ -113,13 +113,13 @@
 +extern char *backup_dir_dels;
 +extern char *backup_suffix_dels;
 +extern int backup_suffix_dels_len;
  extern struct file_list *the_file_list;
  extern struct filter_list_struct server_filter_list;
  
-@@ -102,10 +105,14 @@ static int can_link_devices = 1;
+@@ -100,10 +103,14 @@ static int deletion_count = 0; /* used t
  #define DEL_TERSE		(1<<3)
  
  
 +/* Function now compares both backup_suffix and backup_suffix_dels. */
  static int is_backup_file(char *fn)
  {
@@ -129,24 +129,24 @@
 +		return 1;
 +	k += backup_suffix_len - backup_suffix_dels_len;
 +	return k > 0 && strcmp(fn+k, backup_suffix_dels) == 0;
  }
  
  
-@@ -126,8 +133,8 @@ static int delete_item(char *fname, int 
+@@ -124,8 +131,8 @@ static int delete_item(char *fname, int 
  	if (!S_ISDIR(mode)) {
  		if (max_delete && ++deletion_count > max_delete)
  			return 0;
 -		if (make_backups && (backup_dir || !is_backup_file(fname)))
 -			ok = make_backup(fname);
 +		if (make_backups && (backup_dir_dels || !is_backup_file(fname)))
 +			ok = safe_delete(fname);
  		else
  			ok = robust_unlink(fname) == 0;
  		if (ok) {
-@@ -149,9 +156,9 @@ static int delete_item(char *fname, int 
+@@ -147,9 +154,9 @@ static int delete_item(char *fname, int 
  	    || (dry_run && zap_dir)) {
  		ok = 0;
  		errno = ENOTEMPTY;
 -	} else if (make_backups && !backup_dir && !is_backup_file(fname)
 +	} else if (make_backups && !backup_dir_dels && !is_backup_file(fname)
  	    && !(flags & DEL_FORCE_RECURSE))
@@ -154,13 +154,13 @@
 +		ok = safe_delete(fname);
  	else
  		ok = do_rmdir(fname) == 0;
  	if (ok) {
 --- old/options.c
 +++ new/options.c
-@@ -138,10 +138,14 @@ int no_detach
+@@ -136,10 +136,14 @@ int no_detach
  int write_batch = 0;
  int read_batch = 0;
  int backup_dir_len = 0;
 +int backup_dir_dels_len = 0;	
  int backup_suffix_len;
 +int backup_suffix_dels_len;
@@ -169,51 +169,51 @@
  
  char *backup_suffix = NULL;
 +char *backup_suffix_dels = NULL;
  char *tmpdir = NULL;
  char *partial_dir = NULL;
  char *basis_dir[MAX_BASIS_DIRS+1];
-@@ -151,7 +155,9 @@ char *log_format = NULL;
+@@ -149,7 +153,9 @@ char *log_format = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
 +char *backup_dir_dels = NULL;
  char backup_dir_buf[MAXPATHLEN];
 +char backup_dir_dels_buf[MAXPATHLEN];
  char *sockopts = NULL;
  int rsync_port = 0;
  int compare_dest = 0;
-@@ -282,6 +288,8 @@ void usage(enum logcode F)
+@@ -280,6 +286,8 @@ void usage(enum logcode F)
    rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
    rprintf(F,"     --backup-dir=DIR        make backups into hierarchy based in DIR\n");
    rprintf(F,"     --suffix=SUFFIX         set backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
 +  rprintf(F,"     --backup-dir-dels       make backups of removed files into current dir\n");
 +  rprintf(F,"     --suffix-dels=SUFFIX    set removed-files suffix (defaults to --suffix)\n");
    rprintf(F," -u, --update                skip files that are newer on the receiver\n");
    rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
    rprintf(F,"     --append                append data onto shorter files\n");
-@@ -499,7 +507,9 @@ static struct poptOption long_options[] 
+@@ -497,7 +505,9 @@ static struct poptOption long_options[] 
    {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
    {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
    {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
 +  {"backup-dir-dels",  0,  POPT_ARG_STRING, &backup_dir_dels, 0, 0, 0 },
    {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
 +  {"suffix-dels",      0,  POPT_ARG_STRING, &backup_suffix_dels, 0, 0, 0 },
    {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
    {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
    {"write-batch",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },
-@@ -1214,6 +1224,8 @@ int parse_arguments(int *argc, const cha
+@@ -1211,6 +1221,8 @@ int parse_arguments(int *argc, const cha
  			partial_dir = sanitize_path(NULL, partial_dir, NULL, 0);
  		if (backup_dir)
  			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0);
 +		if (backup_dir_dels)							
 +			backup_dir_dels = sanitize_path(NULL, backup_dir_dels, NULL, 0);
  	}
  	if (server_filter_list.head && !am_sender) {
  		struct filter_list_struct *elp = &server_filter_list;
-@@ -1248,6 +1260,14 @@ int parse_arguments(int *argc, const cha
+@@ -1245,6 +1257,14 @@ int parse_arguments(int *argc, const cha
  				return 0;
  			}
  		}
 +		/* Clean backup_dir_dels same as for backup_dir */
 +		if (backup_dir_dels) {
 +			if (!*backup_dir_dels)
@@ -222,13 +222,13 @@
 +			if (check_filter(elp, backup_dir_dels, 1) < 0)
 +				goto options_rejected;
 +		}
  	}
  
  	if (!backup_suffix)
-@@ -1259,6 +1279,16 @@ int parse_arguments(int *argc, const cha
+@@ -1256,6 +1276,16 @@ int parse_arguments(int *argc, const cha
  			backup_suffix);
  		return 0;
  	}
 +	/* if backup_suffix_dels not supplied, default to backup_suffix */
 +	if (!backup_suffix_dels)
 +		backup_suffix_dels = backup_dir_dels ? "" : backup_suffix;
@@ -239,13 +239,13 @@
 +			backup_suffix_dels);	
 +		return 0;
 +	}
  	if (backup_dir) {
  		backup_dir_len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
  		backup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;
-@@ -1282,6 +1312,31 @@ int parse_arguments(int *argc, const cha
+@@ -1279,6 +1309,31 @@ int parse_arguments(int *argc, const cha
  			"P *%s", backup_suffix);
  		parse_rule(&filter_list, backup_dir_buf, 0, 0);
  	}
 +	/* If backup_dir_dels not supplied default to backup_dir if it has been supplied */
 +	if (backup_dir && !backup_dir_dels) {
 +		backup_dir_dels = backup_dir;
@@ -271,24 +271,24 @@
 +			"--suffix-dels cannot be a null string without --backup-dir-dels\n");
 +		return 0;
 +	}
  	if (make_backups && !backup_dir)
  		omit_dir_times = 1;
  
-@@ -1626,6 +1681,10 @@ void server_options(char **args,int *arg
+@@ -1623,6 +1678,10 @@ void server_options(char **args,int *arg
  		args[ac++] = "--backup-dir";
  		args[ac++] = backup_dir;
  	}
 +	if (backup_dir_dels && backup_dir_dels != backup_dir) {
 +		args[ac++] = "--backup-dir-dels";
 +		args[ac++] = backup_dir_dels;
 +	}
  
  	/* Only send --suffix if it specifies a non-default value. */
  	if (strcmp(backup_suffix, backup_dir ? "" : BACKUP_SUFFIX) != 0) {
-@@ -1634,7 +1693,13 @@ void server_options(char **args,int *arg
+@@ -1631,7 +1690,13 @@ void server_options(char **args,int *arg
  			goto oom;
  		args[ac++] = arg;
  	}
 -
 +	/* Only send --suffix-dels if it specifies a non-default value. */
 +	if (strcmp(backup_suffix_dels, backup_dir_dels ? "" : BACKUP_SUFFIX) != 0) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/catch_crash_signals.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/catch_crash_signals.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/catch_crash_signals.diff	2006-03-12 02:44:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/catch_crash_signals.diff	2006-04-22 23:40:51.000000000 +0800
@@ -94,13 +94,13 @@
 +	SIGACTMASK(SIGBUS, rsync_crash_handler);
  #endif
  
  	starttime = time(NULL);
 --- old/socket.c
 +++ new/socket.c
-@@ -435,7 +435,17 @@ int is_a_socket(int fd)
+@@ -459,7 +459,17 @@ int is_a_socket(int fd)
  static RETSIGTYPE sigchld_handler(UNUSED(int val))
  {
  #ifdef WNOHANG
 -	while (waitpid(-1, NULL, WNOHANG) > 0) {}
 +	int status;
 +	while (waitpid(-1, &status, WNOHANG) > 0) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/cvs-entries.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/cvs-entries.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/cvs-entries.diff	2006-02-06 14:32:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/cvs-entries.diff	2006-04-22 23:40:58.000000000 +0800
@@ -1,22 +1,22 @@
 This patch causes the --cvs-exclude option to prefix the names listed
 in each dir's CVS/Entries file as per-dir includes before the dir's list
 of excludes taken from the .cvsignore file.
 
 --- old/exclude.c
 +++ new/exclude.c
-@@ -221,6 +221,8 @@ static void add_rule(struct filter_list_
+@@ -219,6 +219,8 @@ static void add_rule(struct filter_list_
  		if (!(lp = new_array(struct filter_list_struct, 1)))
  			out_of_memory("add_rule");
  		lp->head = lp->tail = NULL;
 +		if (mflags & MATCHFLG_CVS_IGNORE)
 +			cp = "CVS";
  		if (asprintf(&lp->debug_type, " [per-dir %s]", cp) < 0)
  			out_of_memory("add_rule");
  		ret->u.mergelist = lp;
-@@ -454,6 +456,14 @@ void *push_local_filters(const char *dir
+@@ -452,6 +454,14 @@ void *push_local_filters(const char *dir
  				set_filter_dir(dir, dirlen);
  		}
  
 +		if (ex->match_flags & MATCHFLG_CVS_IGNORE
 +		    && strlcpy(dirbuf + dirbuf_len, "CVS/Entries",
 +			MAXPATHLEN - dirbuf_len) < MAXPATHLEN - dirbuf_len) {
@@ -25,21 +25,21 @@
 +				      MATCHFLG_NO_PREFIXES | MATCHFLG_INCLUDE,
 +				      XFLG_CVS_ENTRIES);
 +		}
  		if (strlcpy(dirbuf + dirbuf_len, ex->pattern,
  		    MAXPATHLEN - dirbuf_len) < MAXPATHLEN - dirbuf_len) {
  			parse_filter_file(lp, dirbuf, ex->match_flags,
-@@ -970,6 +980,7 @@ void parse_filter_file(struct filter_lis
+@@ -968,6 +978,7 @@ void parse_filter_file(struct filter_lis
  	char line[BIGPATHBUFLEN];
  	char *eob = line + sizeof line - 1;
  	int word_split = mflags & MATCHFLG_WORD_SPLIT;
 +	int slash_parse = xflags & XFLG_CVS_ENTRIES ? 1 : 0;
  
  	if (!fname || !*fname)
  		return;
-@@ -1016,6 +1027,24 @@ void parse_filter_file(struct filter_lis
+@@ -1014,6 +1025,24 @@ void parse_filter_file(struct filter_lis
  				}
  				break;
  			}
 +			switch (slash_parse) { /* CVS/Entries parsing: */
 +			case 1: /* Ignore starting chars until first slash. */
 +				if (ch == '/')
@@ -58,13 +58,13 @@
 +				}
 +				continue;
 +			}
  			if (word_split && isspace(ch))
  				break;
  			if (eol_nulls? !ch : (ch == '\n' || ch == '\r'))
-@@ -1025,13 +1054,15 @@ void parse_filter_file(struct filter_lis
+@@ -1023,13 +1052,15 @@ void parse_filter_file(struct filter_lis
  			else
  				overflow = 1;
  		}
 +	  end_the_line:
  		if (overflow) {
  			rprintf(FERROR, "discarding over-long filter: %s...\n", line);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/date-only.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/date-only.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/date-only.diff	2006-03-12 02:45:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/date-only.diff	2006-04-22 23:41:11.000000000 +0800
@@ -22,48 +22,48 @@
  extern int csum_length;
  extern int ignore_times;
 +extern int date_only;
  extern int size_only;
  extern OFF_T max_size;
  extern OFF_T min_size;
-@@ -378,6 +379,8 @@ void itemize(struct file_struct *file, i
+@@ -376,6 +377,8 @@ void itemize(struct file_struct *file, i
  /* Perform our quick-check heuristic for determining if a file is unchanged. */
  int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
  {
 +	if (date_only)
 +		return cmp_time(st->st_mtime, file->modtime) == 0;
  	if (st->st_size != file->length)
  		return 0;
  
 --- old/options.c
 +++ new/options.c
-@@ -99,6 +99,7 @@ int keep_partial = 0;
+@@ -97,6 +97,7 @@ int keep_partial = 0;
  int safe_symlinks = 0;
  int copy_unsafe_links = 0;
  int size_only = 0;
 +int date_only = 0;
  int daemon_bwlimit = 0;
  int bwlimit = 0;
  int fuzzy_basis = 0;
-@@ -333,6 +334,7 @@ void usage(enum logcode F)
+@@ -331,6 +332,7 @@ void usage(enum logcode F)
    rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
    rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
    rprintf(F,"     --size-only             skip files that match in size\n");
 +  rprintf(F,"     --date-only             skip files that match in mod-time\n");
    rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
    rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
    rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
-@@ -448,6 +450,7 @@ static struct poptOption long_options[] 
+@@ -446,6 +448,7 @@ static struct poptOption long_options[] 
    {"chmod",            0,  POPT_ARG_STRING, 0, OPT_CHMOD, 0, 0 },
    {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
    {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
 +  {"date-only",        0,  POPT_ARG_NONE,   &date_only, 0, 0, 0 },
    {"one-file-system", 'x', POPT_ARG_NONE,   0, 'x', 0, 0 },
    {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
    {"existing",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
-@@ -1656,6 +1659,9 @@ void server_options(char **args,int *arg
+@@ -1653,6 +1656,9 @@ void server_options(char **args,int *arg
  			args[ac++] = "--size-only";
  	}
  
 +	if (date_only)
 +		args[ac++] = "--date-only";
 +
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/detect-renamed.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/detect-renamed.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/detect-renamed.diff	2006-03-12 02:45:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/detect-renamed.diff	2006-04-22 23:41:20.000000000 +0800
@@ -38,23 +38,23 @@
  extern int prune_empty_dirs;
  extern int copy_links;
  extern int copy_unsafe_links;
 +extern int detect_renamed;
  extern int protocol_version;
  extern int sanitize_paths;
- extern const char *io_write_phase;
-@@ -73,6 +74,8 @@ int checksum_len;
+ extern struct stats stats;
+@@ -72,6 +73,8 @@ int checksum_len;
  dev_t filesystem_dev; /* used to implement -x */
  unsigned int file_struct_len;
  
 +struct file_list the_fattr_list;
 +
  static char empty_sum[MD4_SUM_LENGTH];
  static int flist_count_offset;
  
-@@ -259,6 +262,44 @@ static mode_t from_wire_mode(int mode)
+@@ -258,6 +261,44 @@ static mode_t from_wire_mode(int mode)
  	return (mode_t)mode;
  }
  
 +static int fattr_compare(struct file_struct **file1, struct file_struct **file2)
 +{
 +	struct file_struct *f1 = *file1;
@@ -93,13 +93,13 @@
 +	return u_strcmp(f1->dirname, f2->dirname);
 +}
 +
  static void send_directory(int f, struct file_list *flist,
  			   char *fbuf, int len);
  
-@@ -1387,6 +1428,25 @@ struct file_list *recv_file_list(int f)
+@@ -1382,6 +1423,25 @@ struct file_list *recv_file_list(int f)
  
  	clean_flist(flist, relative_paths, 1);
  
 +	if (detect_renamed) {
 +		int j = flist->count;
 +		the_fattr_list.count = j;
@@ -129,32 +129,30 @@
  extern int copy_dest;
  extern int link_dest;
 +extern int detect_renamed;
  extern int whole_file;
  extern int list_only;
  extern int read_batch;
-@@ -91,14 +92,17 @@ extern char *backup_dir;
+@@ -91,12 +92,15 @@ extern char *backup_dir;
  extern char *backup_suffix;
  extern int backup_suffix_len;
  extern struct file_list *the_file_list;
 +extern struct file_list the_fattr_list;
  extern struct filter_list_struct server_filter_list;
  
  static int deletion_count = 0; /* used to implement --max-delete */
 +static int unexplored_dirs = 1;
- static int can_link_symlinks = 1; /* start out optimistic */
- static int can_link_devices = 1;
  
 -/* For calling delete_file() */
 +/* For calling delete_item() and delete_in_dir() */
  #define DEL_FORCE_RECURSE	(1<<1) /* recurse even w/o --force */
 +#define DEL_NO_DELETIONS	(1<<2)
  #define DEL_TERSE		(1<<3)
  
  
-@@ -108,12 +112,120 @@ static int is_backup_file(char *fn)
+@@ -106,12 +110,120 @@ static int is_backup_file(char *fn)
  	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
  }
  
 +/* Search for a regular file that matches either (1) the size & modified
 + * time (plus the basename, if possible) or (2) the size & checksum.  If
 + * we find an exact match down to the dirname, return -1 because we found
@@ -269,49 +267,49 @@
   * a directory! (The buffer is used for recursion, but returned unchanged.)
 + *
 + * Also Note:  --detect-rename may use this routine with DEL_NO_DELETIONS set!
   */
  static int delete_item(char *fname, int mode, int flags)
  {
-@@ -124,6 +236,8 @@ static int delete_item(char *fname, int 
+@@ -122,6 +234,8 @@ static int delete_item(char *fname, int 
  	char *p;
  
  	if (!S_ISDIR(mode)) {
 +		if (flags & DEL_NO_DELETIONS)
 +			return 0;
  		if (max_delete && ++deletion_count > max_delete)
  			return 0;
  		if (make_backups && (backup_dir || !is_backup_file(fname)))
-@@ -146,6 +260,7 @@ static int delete_item(char *fname, int 
+@@ -144,6 +258,7 @@ static int delete_item(char *fname, int 
  
  	zap_dir = flags & DEL_FORCE_RECURSE || force_delete;
  	if ((max_delete && ++deletion_count > max_delete)
 +	    || flags & DEL_NO_DELETIONS
  	    || (dry_run && zap_dir)) {
  		ok = 0;
  		errno = ENOTEMPTY;
-@@ -188,6 +303,8 @@ static int delete_item(char *fname, int 
+@@ -186,6 +301,8 @@ static int delete_item(char *fname, int 
  			continue;
  
  		strlcpy(p, fp->basename, remainder);
 +		if (detect_renamed && S_ISREG(fp->mode))
 +			look_for_rename(fp, fname, dirlist->file_pool);
  		delete_item(fname, fp->mode, flags & ~DEL_TERSE);
  	}
  	flist_free(dirlist);
-@@ -196,7 +313,8 @@ static int delete_item(char *fname, int 
+@@ -194,7 +311,8 @@ static int delete_item(char *fname, int 
  
  	pop_local_filters(save_filters);
  
 -	if (max_delete && ++deletion_count > max_delete)
 +	if (flags & DEL_NO_DELETIONS
 +	 || (max_delete && ++deletion_count > max_delete))
  		return 0;
  
  	if (do_rmdir(fname) == 0) {
-@@ -216,15 +334,19 @@ static int delete_item(char *fname, int 
+@@ -214,15 +332,19 @@ static int delete_item(char *fname, int 
   * all the --delete-WHEN options.  Note that the fbuf pointer must point to a
   * MAXPATHLEN buffer with the name of the directory in it (the functions we
   * call will append names onto the end, but the old dir value will be restored
 - * on exit). */
 + * on exit).
 + *
@@ -328,22 +326,22 @@
 -	char delbuf[MAXPATHLEN];
 +	char *p, delbuf[MAXPATHLEN];
 +	unsigned remainder;
  	int dlen, i;
  
  	if (!flist) {
-@@ -238,6 +360,8 @@ static void delete_in_dir(struct file_li
+@@ -236,6 +358,8 @@ static void delete_in_dir(struct file_li
  	if (verbose > 2)
  		rprintf(FINFO, "delete_in_dir(%s)\n", fbuf);
  
 +	flags |= DEL_FORCE_RECURSE;
 +
  	if (allowed_lull)
  		maybe_send_keepalive();
  
-@@ -245,12 +369,14 @@ static void delete_in_dir(struct file_li
+@@ -243,12 +367,14 @@ static void delete_in_dir(struct file_li
  		return; /* Impossible... */
  
  	if (io_error && !(lp_ignore_errors(module_id) || ignore_errors)) {
 -		if (already_warned)
 +		if (!already_warned) {
 +			rprintf(FINFO,
@@ -357,23 +355,23 @@
 -		already_warned = 1;
 -		return;
 +		flags |= DEL_NO_DELETIONS;
  	}
  
  	while (cur_depth >= file->dir.depth && cur_depth >= min_depth)
-@@ -261,6 +387,9 @@ static void delete_in_dir(struct file_li
+@@ -259,6 +385,9 @@ static void delete_in_dir(struct file_li
  	dlen = strlen(fbuf);
  	filt_array[cur_depth] = push_local_filters(fbuf, dlen);
  
 +	if (detect_renamed)
 +		unexplored_dirs--;
 +
  	if (one_file_system) {
  		if (file->flags & FLAG_TOP_DIR)
  			filesystem_dev = stp->st_dev;
-@@ -270,18 +399,30 @@ static void delete_in_dir(struct file_li
+@@ -268,18 +397,30 @@ static void delete_in_dir(struct file_li
  
  	dirlist = get_dirlist(fbuf, dlen, 0);
  
 +	p = fbuf + dlen;
 +	if (dlen != 1 || *fbuf != '/')
 +		*p++ = '/';
@@ -400,33 +398,33 @@
  
 +	fbuf[dlen] = '\0';
 +
  	flist_free(dirlist);
  }
  
-@@ -311,9 +452,9 @@ static void do_delete_pass(struct file_l
+@@ -309,9 +450,9 @@ static void do_delete_pass(struct file_l
  		 || !S_ISDIR(st.st_mode))
  			continue;
  
 -		delete_in_dir(flist, fbuf, file, &st);
 +		delete_in_dir(flist, fbuf, file, &st, 0);
  	}
 -	delete_in_dir(NULL, NULL, NULL, NULL);
 +	delete_in_dir(NULL, NULL, NULL, NULL, 0);
  
  	if (do_progress && !am_server)
  		rprintf(FINFO, "                    \r");
-@@ -752,6 +893,7 @@ static int try_dests_non(struct file_str
+@@ -768,6 +909,7 @@ static int try_dests_non(struct file_str
  	return -1;
  }
  
 +static struct bitbag *delayed_bits = NULL;
  static int phase = 0;
  
  /* Acts on the_file_list->file's ndx'th item, whose name is fname.  If a dir,
-@@ -906,8 +1048,12 @@ static void recv_generator(char *fname, 
+@@ -922,8 +1064,12 @@ static void recv_generator(char *fname, 
  		    && verbose && code && f_out != -1)
  			rprintf(code, "%s/\n", fname);
  		if (delete_during && f_out != -1 && !phase && dry_run < 2
 -		    && (file->flags & FLAG_DEL_HERE))
 -			delete_in_dir(the_file_list, fname, file, &st);
 +		    && (file->flags & FLAG_DEL_HERE)) {
@@ -435,13 +433,13 @@
 +			delete_in_dir(the_file_list, fname, file, &st,
 +				      delete_during < 0 ? DEL_NO_DELETIONS : 0);
 +		}
  		return;
  	}
  
-@@ -1145,8 +1291,14 @@ static void recv_generator(char *fname, 
+@@ -1168,8 +1314,14 @@ static void recv_generator(char *fname, 
  		    && hard_link_check(file, ndx, fname, statret, &st,
  				       itemizing, code, HL_SKIP))
  			return;
 -		if (stat_errno == ENOENT)
 +		if (stat_errno == ENOENT) {
 +			if (detect_renamed && unexplored_dirs > 0
@@ -451,13 +449,13 @@
 +			}
  			goto notify_others;
 +		}
  		rsyserr(FERROR, stat_errno, "recv_generator: failed to stat %s",
  			full_fname(fname));
  		return;
-@@ -1324,11 +1476,17 @@ void generate_files(int f_out, struct fi
+@@ -1347,11 +1499,17 @@ void generate_files(int f_out, struct fi
  			(long)getpid(), flist->count);
  	}
  
 +	if (detect_renamed) {
 +		delayed_bits = bitbag_create(flist->count);
 +		if (!delete_before && !delete_during)
@@ -470,13 +468,13 @@
  
 -	if (append_mode || whole_file < 0)
 +	if (append_mode || detect_renamed || whole_file < 0)
  		whole_file = 0;
  	if (verbose >= 2) {
  		rprintf(FINFO, "delta-transmission %s\n",
-@@ -1383,7 +1541,23 @@ void generate_files(int f_out, struct fi
+@@ -1406,7 +1564,23 @@ void generate_files(int f_out, struct fi
  	}
  	recv_generator(NULL, NULL, 0, 0, 0, code, -1);
  	if (delete_during)
 -		delete_in_dir(NULL, NULL, NULL, NULL);
 +		delete_in_dir(NULL, NULL, NULL, NULL, 0);
 +
@@ -497,54 +495,54 @@
 +	}
  
  	phase++;
  	csum_length = SUM_LENGTH;
 --- old/options.c
 +++ new/options.c
-@@ -78,6 +78,7 @@ int am_generator = 0;
+@@ -76,6 +76,7 @@ int am_generator = 0;
  int am_starting_up = 1;
  int relative_paths = -1;
  int implied_dirs = 1;
 +int detect_renamed = 0;
  int numeric_ids = 0;
  int allow_8bit_chars = 0;
  int force_delete = 0;
-@@ -336,6 +337,7 @@ void usage(enum logcode F)
+@@ -334,6 +335,7 @@ void usage(enum logcode F)
    rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
    rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
    rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
 +  rprintf(F,"     --detect-renamed        try to find renamed files to speed up the transfer\n");
    rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
    rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
    rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
-@@ -483,6 +485,7 @@ static struct poptOption long_options[] 
+@@ -481,6 +483,7 @@ static struct poptOption long_options[] 
    {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
    {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
    {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
 +  {"detect-renamed",   0,  POPT_ARG_NONE,   &detect_renamed, 0, 0, 0 },
    {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
    {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
    {"compress-level",   0,  POPT_ARG_INT,    &def_compress_level, 'z', 0, 0 },
-@@ -1343,7 +1346,7 @@ int parse_arguments(int *argc, const cha
+@@ -1340,7 +1343,7 @@ int parse_arguments(int *argc, const cha
  		inplace = 1;
  	}
  
 -	if (delay_updates && !partial_dir)
 +	if ((delay_updates || detect_renamed) && !partial_dir)
  		partial_dir = tmp_partialdir;
  
  	if (inplace) {
-@@ -1352,6 +1355,7 @@ int parse_arguments(int *argc, const cha
+@@ -1349,6 +1352,7 @@ int parse_arguments(int *argc, const cha
  			snprintf(err_buf, sizeof err_buf,
  				 "--%s cannot be used with --%s\n",
  				 append_mode ? "append" : "inplace",
 +				 detect_renamed ? "detect-renamed" :
  				 delay_updates ? "delay-updates" : "partial-dir");
  			return 0;
  		}
-@@ -1654,6 +1658,8 @@ void server_options(char **args,int *arg
+@@ -1651,6 +1655,8 @@ void server_options(char **args,int *arg
  			args[ac++] = "--super";
  		if (size_only)
  			args[ac++] = "--size-only";
 +		if (detect_renamed)
 +			args[ac++] = "--detect-renamed";
  	}
@@ -557,13 +555,13 @@
   -T, --temp-dir=DIR          create temporary files in directory DIR
   -y, --fuzzy                 find similar file for basis if no dest file
 +     --detect-renamed        try to find renamed files to speed the xfer
       --compare-dest=DIR      also compare received files relative to DIR
       --copy-dest=DIR         ... and include copies of unchanged files
       --link-dest=DIR         hardlink to files in DIR when unchanged
-@@ -1240,6 +1241,15 @@ Note that the use of the bf(--delete) op
+@@ -1247,6 +1248,15 @@ Note that the use of the bf(--delete) op
  fuzzy-match files, so either use bf(--delete-after) or specify some
  filename exclusions if you need to prevent this.
  
 +dit(bf(--detect-renamed)) This option tells rsync to scan the receiving
 +side for files that have been renamed, and to use any that are found as
 +alternate basis files to help speed up the transfer.
@@ -610,13 +608,13 @@
 +
  /**
   * Determine if a symlink points outside the current directory tree.
   * This is considered "unsafe" because e.g. when mirroring somebody
 --- old/proto.h
 +++ new/proto.h
-@@ -304,6 +304,8 @@ int pop_dir(char *dir);
+@@ -303,6 +303,8 @@ int pop_dir(char *dir);
  char *full_fname(const char *fn);
  char *partial_dir_fname(const char *fname);
  int handle_partial_dir(const char *fname, int create);
 +int u_strcmp(const char *p1, const char *p2);
 +int u_memcmp(const void *p1, const void *p2, size_t len);
  int unsafe_symlink(const char *dest, const char *src);
@@ -629,13 +627,13 @@
   -T, --temp-dir=DIR          create temporary files in directory DIR
   -y, --fuzzy                 find similar file for basis if no dest file
 +     --detect-renamed        try to find renamed files to speed the xfer
       --compare-dest=DIR      also compare received files relative to DIR
       --copy-dest=DIR         \&.\&.\&. and include copies of unchanged files
       --link-dest=DIR         hardlink to files in DIR when unchanged
-@@ -1412,6 +1413,16 @@ Note that the use of the \fB--delete\fP 
+@@ -1419,6 +1420,16 @@ Note that the use of the \fB--delete\fP 
  fuzzy-match files, so either use \fB--delete-after\fP or specify some
  filename exclusions if you need to prevent this\&.
  .IP 
 +.IP "\fB--detect-renamed\fP" 
 +This option tells rsync to scan the receiving
 +side for files that have been renamed, and to use any that are found as
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/early-checksum.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/early-checksum.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/early-checksum.diff	2006-03-12 02:45:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/early-checksum.diff	2006-04-22 23:52:02.000000000 +0800
@@ -15,13 +15,13 @@
  extern int do_progress;
  extern int always_checksum;
 +extern int pre_checksum;
  extern int module_id;
  extern int ignore_errors;
  extern int numeric_ids;
-@@ -710,6 +711,16 @@ static struct file_struct *receive_file_
+@@ -705,6 +706,16 @@ static struct file_struct *receive_file_
  			sum = empty_sum;
  		}
  		read_buf(f, sum, checksum_len);
 +		if (pre_checksum) {
 +			char sum2[MD4_SUM_LENGTH];
 +			STRUCT_STAT st;
@@ -42,41 +42,41 @@
  extern int fuzzy_basis;
  extern int always_checksum;
 +extern int pre_checksum;
  extern int checksum_len;
  extern char *partial_dir;
  extern char *basis_dir[];
-@@ -376,7 +377,8 @@ void itemize(struct file_struct *file, i
+@@ -374,7 +375,8 @@ void itemize(struct file_struct *file, i
  
  
  /* Perform our quick-check heuristic for determining if a file is unchanged. */
 -int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
 +int unchanged_file(char *fn, int fnamecmp_type, struct file_struct *file,
 +		   STRUCT_STAT *st)
  {
  	if (st->st_size != file->length)
  		return 0;
-@@ -385,6 +387,8 @@ int unchanged_file(char *fn, struct file
+@@ -383,6 +385,8 @@ int unchanged_file(char *fn, struct file
  	   of the file time to determine whether to sync */
  	if (always_checksum && S_ISREG(st->st_mode)) {
  		char sum[MD4_SUM_LENGTH];
 +		if (pre_checksum && fnamecmp_type == FNAMECMP_FNAME)
 +			return !(file->flags & FLAG_SUM_DIFFERS);
  		file_checksum(fn, sum, st->st_size);
  		return memcmp(sum, file->u.sum, checksum_len) == 0;
  	}
-@@ -622,7 +626,7 @@ static int try_dests_reg(struct file_str
+@@ -620,7 +624,7 @@ static int try_dests_reg(struct file_str
  			match_level = 1;
  			/* FALL THROUGH */
  		case 1:
 -			if (!unchanged_file(cmpbuf, file, stp))
 +			if (!unchanged_file(cmpbuf, 0, file, stp))
  				continue;
  			best_match = j;
  			match_level = 2;
-@@ -1159,7 +1163,7 @@ static void recv_generator(char *fname, 
+@@ -1182,7 +1186,7 @@ static void recv_generator(char *fname, 
  		;
  	else if (fnamecmp_type == FNAMECMP_FUZZY)
  		;
 -	else if (unchanged_file(fnamecmp, file, &st)) {
 +	else if (unchanged_file(fnamecmp, fnamecmp_type, file, &st)) {
  		if (partialptr) {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches: flags.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/fsync.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/fsync.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/fsync.diff	2006-03-12 02:45:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/fsync.diff	2006-04-22 23:52:20.000000000 +0800
@@ -8,29 +8,29 @@
  int copy_dirlinks = 0;
  int copy_links = 0;
 +int do_fsync = 0;
  int preserve_links = 0;
  int preserve_hard_links = 0;
  int preserve_perms = 0;
-@@ -329,6 +330,7 @@ void usage(enum logcode F)
+@@ -327,6 +328,7 @@ void usage(enum logcode F)
    rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
    rprintf(F,"     --delay-updates         put all updated files into place at transfer's end\n");
    rprintf(F," -m, --prune-empty-dirs      prune empty directory chains from the file-list\n");
 +  rprintf(F,"     --fsync                 fsync every written file\n");
    rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
    rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
    rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
-@@ -506,6 +508,7 @@ static struct poptOption long_options[] 
+@@ -504,6 +506,7 @@ static struct poptOption long_options[] 
    {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
    {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
    {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
 +  {"fsync",            0,  POPT_ARG_NONE,   &do_fsync, 0, 0, 0 },
    {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
    {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
    {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
-@@ -1707,6 +1710,9 @@ void server_options(char **args,int *arg
+@@ -1704,6 +1707,9 @@ void server_options(char **args,int *arg
  		args[ac++] = tmpdir;
  	}
  
 +	if (do_fsync && am_sender)
 +		args[ac++] = "--fsync";
 +
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/id-pair.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/id-pair.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/id-pair.diff	2006-03-12 02:45:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/id-pair.diff	2006-04-22 23:52:26.000000000 +0800
@@ -7,21 +7,21 @@
 
 This probably needs a hashing algorithm to be added if the uid+gid list
 gets to be really large.
 
 --- old/flist.c
 +++ new/flist.c
-@@ -59,6 +59,7 @@ extern int protocol_version;
+@@ -58,6 +58,7 @@ extern int copy_unsafe_links;
+ extern int protocol_version;
  extern int sanitize_paths;
- extern const char *io_write_phase;
  extern struct stats stats;
 +extern struct id_pair *id_pairs;
  extern struct file_list *the_file_list;
  
  extern char curr_dir[MAXPATHLEN];
-@@ -362,14 +363,14 @@ static void send_file_entry(struct file_
+@@ -359,14 +360,14 @@ static void send_file_entry(struct file_
  		}
  	} else if (protocol_version < 28)
  		rdev = makedev(0, 0);
 -	if (file->uid == uid)
 +	if (id_pairs[file->id_ndx].uid == uid)
  		flags |= XMIT_SAME_UID;
@@ -34,52 +34,52 @@
  	else
 -		gid = file->gid;
 +		gid = id_pairs[file->id_ndx].gid;
  	if (file->modtime == modtime)
  		flags |= XMIT_SAME_TIME;
  	else
-@@ -622,8 +623,7 @@ static struct file_struct *receive_file_
+@@ -617,8 +618,7 @@ static struct file_struct *receive_file_
  	file->modtime = modtime;
  	file->length = file_length;
  	file->mode = mode;
 -	file->uid = uid;
 -	file->gid = gid;
 +	file->id_ndx = id_pair(uid, gid);
  
  	if (dirname_len) {
  		file->dirname = lastdir = bp;
-@@ -874,8 +874,7 @@ struct file_struct *make_file(char *fnam
+@@ -869,8 +869,7 @@ struct file_struct *make_file(char *fnam
  	file->modtime = st.st_mtime;
  	file->length = st.st_size;
  	file->mode = st.st_mode;
 -	file->uid = st.st_uid;
 -	file->gid = st.st_gid;
 +	file->id_ndx = id_pair(st.st_uid, st.st_gid);
  
  #ifdef SUPPORT_HARD_LINKS
  	if (flist && flist->hlink_pool) {
-@@ -943,8 +942,7 @@ struct file_struct *make_file(char *fnam
+@@ -938,8 +937,7 @@ struct file_struct *make_file(char *fnam
  			file->modtime = st2.st_mtime;
  			file->length = st2.st_size;
  			file->mode = st2.st_mode;
 -			file->uid = st2.st_uid;
 -			file->gid = st2.st_gid;
 +			file->id_ndx = id_pair(st2.st_uid, st2.st_gid);
  			file->u.link = NULL;
  		} else
  			file->mode = save_mode;
-@@ -1388,7 +1386,7 @@ struct file_list *recv_file_list(int f)
+@@ -1383,7 +1381,7 @@ struct file_list *recv_file_list(int f)
  	clean_flist(flist, relative_paths, 1);
  
  	if (f >= 0) {
 -		recv_uid_list(f, flist);
 +		recv_uid_list(f);
  
  		/* Recv the io_error flag */
  		if (lp_ignore_errors(module_id) || ignore_errors)
-@@ -1704,13 +1702,15 @@ static void output_flist(struct file_lis
+@@ -1699,13 +1697,15 @@ static void output_flist(struct file_lis
  
  	for (i = 0; i < flist->count; i++) {
  		file = flist->files[i];
 -		if ((am_root || am_sender) && preserve_uid)
 -			sprintf(uidbuf, " uid=%ld", (long)file->uid);
 -		else
@@ -105,13 +105,13 @@
  extern char *backup_suffix;
  extern int backup_suffix_len;
 +extern struct id_pair *id_pairs;
  extern struct file_list *the_file_list;
  extern struct filter_list_struct server_filter_list;
  
-@@ -325,10 +326,12 @@ int unchanged_attrs(struct file_struct *
+@@ -323,10 +324,12 @@ int unchanged_attrs(struct file_struct *
  	 && (st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS))
  		return 0;
  
 -	if (am_root && preserve_uid && st->st_uid != file->uid)
 +	if (am_root && preserve_uid
 +	 && st->st_uid != id_pairs[file->id_ndx].uid)
@@ -120,22 +120,22 @@
 -	if (preserve_gid && file->gid != GID_NONE && st->st_gid != file->gid)
 +	if (preserve_gid && id_pairs[file->id_ndx].gid != GID_NONE
 +	 && st->st_gid != id_pairs[file->id_ndx].gid)
  		return 0;
  
  	return 1;
-@@ -341,6 +344,8 @@ void itemize(struct file_struct *file, i
+@@ -339,6 +342,8 @@ void itemize(struct file_struct *file, i
  		int keep_time = !preserve_times ? 0
  		    : S_ISDIR(file->mode) ? !omit_dir_times
  		    : !S_ISLNK(file->mode);
 +		uid_t uid = id_pairs[file->id_ndx].uid;
 +		gid_t gid = id_pairs[file->id_ndx].gid;
  
  		if (S_ISREG(file->mode) && file->length != st->st_size)
  			iflags |= ITEM_REPORT_SIZE;
-@@ -350,10 +355,10 @@ void itemize(struct file_struct *file, i
+@@ -348,10 +353,10 @@ void itemize(struct file_struct *file, i
  			iflags |= ITEM_REPORT_TIME;
  		if ((file->mode & CHMOD_BITS) != (st->st_mode & CHMOD_BITS))
  			iflags |= ITEM_REPORT_PERMS;
 -		if (preserve_uid && am_root && file->uid != st->st_uid)
 +		if (preserve_uid && am_root && uid != st->st_uid)
  			iflags |= ITEM_REPORT_OWNER;
@@ -232,25 +232,25 @@
 +		    change_gid ? gid : st->st_gid) != 0) {
  			/* shouldn't have attempted to change uid or gid
  			 * unless have the privilege */
  			rsyserr(FERROR, errno, "%s %s failed",
 --- old/rsync.h
 +++ new/rsync.h
-@@ -493,6 +493,11 @@ struct hlink {
+@@ -495,6 +495,11 @@ struct hlink {
  	int hlindex;
  };
  
 +struct id_pair {
 +	uid_t uid;
 +	gid_t gid;
 +};
 +
  #define F_DEV	link_u.idev->dev
  #define F_INODE	link_u.idev->inode
  
-@@ -517,8 +522,7 @@ struct file_struct {
+@@ -519,8 +524,7 @@ struct file_struct {
  		struct hlink *links;
  	} link_u;
  	time_t modtime;
 -	uid_t uid;
 -	gid_t gid;
 +	int id_ndx;
@@ -330,13 +330,13 @@
 +	id_pairs[j].gid = gid;
 +
 +	return j;
 +}
 --- old/proto.h
 +++ new/proto.h
-@@ -272,7 +272,8 @@ void see_token(char *data, int32 toklen)
+@@ -271,7 +271,8 @@ void see_token(char *data, int32 toklen)
  void add_uid(uid_t uid);
  void add_gid(gid_t gid);
  void send_uid_list(int f);
 -void recv_uid_list(int f, struct file_list *flist);
 +void recv_uid_list(int f);
 +int id_pair(uid_t uid, gid_t gid);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/ignore-case.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/ignore-case.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/ignore-case.diff	2006-03-12 02:45:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/ignore-case.diff	2006-04-22 23:52:46.000000000 +0800
@@ -8,13 +8,13 @@
  extern int always_checksum;
  extern int module_id;
 +extern int ignore_case;
  extern int ignore_errors;
  extern int numeric_ids;
  extern int recurse;
-@@ -1800,7 +1801,14 @@ int f_name_cmp(struct file_struct *f1, s
+@@ -1795,7 +1796,14 @@ int f_name_cmp(struct file_struct *f1, s
  		return type1 == t_PATH ? 1 : -1;
  
  	while (1) {
 -		if ((dif = (int)*c1++ - (int)*c2++) != 0)
 +		if (ignore_case) {
 +			uchar ch1, ch2;
@@ -62,37 +62,37 @@
 +    return ret;
  }
  
  /* Match the "pattern" against the forced-to-lower-case "text" string. */
 --- old/options.c
 +++ new/options.c
-@@ -111,6 +111,7 @@ OFF_T max_size = 0;
+@@ -109,6 +109,7 @@ OFF_T max_size = 0;
  OFF_T min_size = 0;
  int ignore_errors = 0;
  int modify_window = 0;
 +int ignore_case = 0;
  int blocking_io = -1;
  int checksum_seed = 0;
  int inplace = 0;
-@@ -351,6 +352,7 @@ void usage(enum logcode F)
+@@ -349,6 +350,7 @@ void usage(enum logcode F)
    rprintf(F,"     --include-from=FILE     read include patterns from FILE\n");
    rprintf(F,"     --files-from=FILE       read list of source-file names from FILE\n");
    rprintf(F," -0, --from0                 all *-from/filter files are delimited by 0s\n");
 +  rprintf(F,"     --ignore-case           ignore case when comparing filenames\n");
    rprintf(F,"     --address=ADDRESS       bind address for outgoing socket to daemon\n");
    rprintf(F,"     --port=PORT             specify double-colon alternate port number\n");
    rprintf(F,"     --sockopts=OPTIONS      specify custom TCP options\n");
-@@ -506,6 +508,7 @@ static struct poptOption long_options[] 
+@@ -504,6 +506,7 @@ static struct poptOption long_options[] 
    {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
    {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
    {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
 +  {"ignore-case",      0,  POPT_ARG_NONE,   &ignore_case, 0, 0, 0 },
    {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
    {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
    {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
-@@ -1668,6 +1671,9 @@ void server_options(char **args,int *arg
+@@ -1665,6 +1668,9 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
  
 +	if (ignore_case)
 +		args[ac++] = "--ignore-case";
 +
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/last-match.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/last-match.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/last-match.diff	2006-02-06 14:32:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/last-match.diff	2006-04-22 23:52:53.000000000 +0800
@@ -3,58 +3,58 @@
 this line:
 
 [last-match]
 
 --- old/exclude.c
 +++ new/exclude.c
-@@ -76,6 +76,7 @@ static BOOL parent_dirscan = False;
+@@ -74,6 +74,7 @@ static BOOL parent_dirscan = False;
  static struct filter_struct **mergelist_parents;
  static int mergelist_cnt = 0;
  static int mergelist_size = 0;
 +static int reversing_rules = 0;
  
  /* Each filter_list_struct describes a singly-linked list by keeping track
   * of both the head and tail pointers.  The list is slightly unusual in that
-@@ -244,6 +245,9 @@ static void add_rule(struct filter_list_
+@@ -242,6 +243,9 @@ static void add_rule(struct filter_list_
  	if (!listp->tail) {
  		ret->next = listp->head;
  		listp->head = listp->tail = ret;
 +	} else if (reversing_rules) {
 +		ret->next = listp->head;
 +		listp->head = ret;
  	} else {
  		ret->next = listp->tail->next;
  		listp->tail->next = ret;
-@@ -970,6 +974,7 @@ void parse_filter_file(struct filter_lis
+@@ -968,6 +972,7 @@ void parse_filter_file(struct filter_lis
  	char line[BIGPATHBUFLEN];
  	char *eob = line + sizeof line - 1;
  	int word_split = mflags & MATCHFLG_WORD_SPLIT;
 +	int save_reversing_rules = reversing_rules;
  
  	if (!fname || !*fname)
  		return;
-@@ -1005,6 +1010,7 @@ void parse_filter_file(struct filter_lis
+@@ -1003,6 +1008,7 @@ void parse_filter_file(struct filter_lis
  	}
  	dirbuf[dirbuf_len] = '\0';
  
 +	reversing_rules = 0;
  	while (1) {
  		char *s = line;
  		int ch, overflow = 0;
-@@ -1030,6 +1036,10 @@ void parse_filter_file(struct filter_lis
+@@ -1028,6 +1034,10 @@ void parse_filter_file(struct filter_lis
  			s = line;
  		}
  		*s = '\0';
 +		if (*line == '[' && strcmp(line+1, "last-match]") == 0) {
 +			reversing_rules = 1;
 +			continue;
 +		}
  		/* Skip an empty token and (when line parsing) comments. */
  		if (*line && (word_split || (*line != ';' && *line != '#')))
  			parse_rule(listp, line, mflags, xflags);
-@@ -1037,6 +1047,7 @@ void parse_filter_file(struct filter_lis
+@@ -1035,6 +1045,7 @@ void parse_filter_file(struct filter_lis
  			break;
  	}
  	fclose(fp);
 +	reversing_rules = save_reversing_rules;
  }
  
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/link-by-hash.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/link-by-hash.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/link-by-hash.diff	2006-03-12 02:46:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/link-by-hash.diff	2006-04-22 23:53:02.000000000 +0800
@@ -364,46 +364,46 @@
 +	return rc;
 +}
 +
 +#endif
 --- old/options.c
 +++ new/options.c
-@@ -145,6 +145,7 @@ char *backup_suffix = NULL;
+@@ -143,6 +143,7 @@ char *backup_suffix = NULL;
  char *tmpdir = NULL;
  char *partial_dir = NULL;
  char *basis_dir[MAX_BASIS_DIRS+1];
 +char *link_by_hash_dir = NULL;
  char *config_file = NULL;
  char *shell_cmd = NULL;
  char *log_format = NULL;
-@@ -339,6 +340,7 @@ void usage(enum logcode F)
+@@ -337,6 +338,7 @@ void usage(enum logcode F)
    rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
    rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
    rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
 +  rprintf(F,"     --link-by-hash=DIR      create hardlinks by hash into DIR\n");
    rprintf(F," -z, --compress              compress file data during the transfer\n");
    rprintf(F,"     --compress-level=NUM    explicitly set compression level\n");
    rprintf(F," -C, --cvs-exclude           auto-ignore files the same way CVS does\n");
-@@ -385,7 +387,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
+@@ -383,7 +385,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
        OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
        OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
        OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
 -      OPT_NO_D,
 +      OPT_NO_D, OPT_LINK_BY_HASH,
        OPT_SERVER, OPT_REFUSED_BASE = 9000};
  
  static struct poptOption long_options[] = {
-@@ -483,6 +485,7 @@ static struct poptOption long_options[] 
+@@ -481,6 +483,7 @@ static struct poptOption long_options[] 
    {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
    {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
    {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
 +  {"link-by-hash",     0,  POPT_ARG_STRING, 0, OPT_LINK_BY_HASH, 0, 0},
    {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
    {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
    {"compress-level",   0,  POPT_ARG_INT,    &def_compress_level, 'z', 0, 0 },
-@@ -1068,6 +1071,21 @@ int parse_arguments(int *argc, const cha
+@@ -1066,6 +1069,21 @@ int parse_arguments(int *argc, const cha
  			usage(FINFO);
  			exit_cleanup(0);
  
 +                case OPT_LINK_BY_HASH:
 +#if HAVE_LINK
 +			arg = poptGetOptArg(pc);
@@ -419,13 +419,13 @@
 +			return 0;
 +#endif
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1719,6 +1737,11 @@ void server_options(char **args,int *arg
+@@ -1716,6 +1734,11 @@ void server_options(char **args,int *arg
  		}
  	}
  
 +	if (link_by_hash_dir && am_sender) {
 +		args[ac++] = "--link-by-hash";
 +		args[ac++] = link_by_hash_dir;
@@ -546,13 +546,13 @@
 +	}
  	if (ret < 0) {
  		rsyserr(FERROR, errno, "%s %s -> \"%s\"",
  			ret == -2 ? "copy" : "rename",
 --- old/rsync.h
 +++ new/rsync.h
-@@ -641,6 +641,14 @@ struct stats {
+@@ -643,6 +643,14 @@ struct stats {
  	int current_file_index;
  };
  
 +struct hashfile_struct {
 +	struct hashfile_struct *next;
 +	struct hashfile_struct *prev;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/links-depth.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/links-depth.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/links-depth.diff	2006-03-12 02:46:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/links-depth.diff	2006-04-22 23:53:12.000000000 +0800
@@ -13,13 +13,13 @@
  extern int keep_dirlinks;
  extern int preserve_links;
 +extern int follow_links_depth;
  extern int preserve_hard_links;
  extern int preserve_devices;
  extern int preserve_specials;
-@@ -715,6 +716,30 @@ static struct file_struct *receive_file_
+@@ -710,6 +711,30 @@ static struct file_struct *receive_file_
  	return file;
  }
  
 +#if SUPPORT_LINKS
 +static int links_depth(char *linkname, STRUCT_STAT *st_ptr)
 +{
@@ -44,13 +44,13 @@
 +}
 +#endif
 +
  /**
   * Create a file_struct for a named file by reading its stat()
   * information and performing extensive checks against global
-@@ -849,7 +874,13 @@ struct file_struct *make_file(char *fnam
+@@ -844,7 +869,13 @@ struct file_struct *make_file(char *fnam
  	basename_len = strlen(basename) + 1; /* count the '\0' */
  
  #ifdef SUPPORT_LINKS
 -	linkname_len = S_ISLNK(st.st_mode) ? strlen(linkname) + 1 : 0;
 +	if (S_ISLNK(st.st_mode)) {
 +		if (follow_links_depth && links_depth(linkname, &st))
@@ -69,21 +69,21 @@
  int copy_links = 0;
  int preserve_links = 0;
 +int follow_links_depth = 0;
  int preserve_hard_links = 0;
  int preserve_perms = 0;
  int preserve_executability = 0;
-@@ -287,6 +288,7 @@ void usage(enum logcode F)
+@@ -285,6 +286,7 @@ void usage(enum logcode F)
    rprintf(F,"     --append                append data onto shorter files\n");
    rprintf(F," -d, --dirs                  transfer directories without recursing\n");
    rprintf(F," -l, --links                 copy symlinks as symlinks\n");
 +  rprintf(F,"     --links-depth=NUM       follow symlinks up to NUM depth\n");
    rprintf(F," -L, --copy-links            transform symlink into referent file/dir\n");
    rprintf(F,"     --copy-unsafe-links     only \"unsafe\" symlinks are transformed\n");
    rprintf(F,"     --safe-links            ignore symlinks that point outside the source tree\n");
-@@ -432,6 +434,7 @@ static struct poptOption long_options[] 
+@@ -430,6 +432,7 @@ static struct poptOption long_options[] 
    {"links",           'l', POPT_ARG_VAL,    &preserve_links, 1, 0, 0 },
    {"no-links",         0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
    {"no-l",             0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
 +  {"links-depth",      0,  POPT_ARG_INT,    &follow_links_depth , 0, 0, 0 },
    {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
    {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches: log-file.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/md5.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/md5.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/md5.diff	2006-03-12 02:46:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/md5.diff	2006-04-22 23:53:27.000000000 +0800
@@ -550,37 +550,37 @@
 +void md5_update(md5_context *ctx, uchar *input, uint32 length);
 +void md5_finish(md5_context *ctx, uchar digest[16]);
 +
 +#endif /* md5.h */
 --- old/options.c
 +++ new/options.c
-@@ -117,6 +117,7 @@ int inplace = 0;
+@@ -115,6 +115,7 @@ int inplace = 0;
  int delay_updates = 0;
  long block_size = 0; /* "long" because popt can't set an int32. */
  
 +int use_md5 = 0;
  
  /** Network address family. **/
  #ifdef INET6
-@@ -369,6 +370,7 @@ void usage(enum logcode F)
+@@ -367,6 +368,7 @@ void usage(enum logcode F)
    rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
    rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
    rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
 +  rprintf(F,"     --md5                   use MD5 checksums instead of MD4\n");
  #ifdef INET6
    rprintf(F," -4, --ipv4                  prefer IPv4\n");
    rprintf(F," -6, --ipv6                  prefer IPv6\n");
-@@ -478,6 +480,7 @@ static struct poptOption long_options[] 
+@@ -476,6 +478,7 @@ static struct poptOption long_options[] 
    {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
    {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
    {"no-W",             0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
 +  {"md5",              0,  POPT_ARG_NONE,   &use_md5, 0, 0, 0 },
    {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
    {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
    {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
-@@ -1622,6 +1625,9 @@ void server_options(char **args,int *arg
+@@ -1619,6 +1622,9 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
  
 +	if (use_md5) 
 +		args[ac++] = "--md5";
 +
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/ODBC-dblog.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/ODBC-dblog.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/ODBC-dblog.diff	2006-03-12 02:46:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/ODBC-dblog.diff	2006-04-22 23:53:42.000000000 +0800
@@ -65,13 +65,13 @@
 +#endif
  		} else {
  			rprintf(FLOG, "rsync %s %s from %s (%s)\n",
  				am_sender ? "on" : "to",
 --- old/configure.in
 +++ new/configure.in
-@@ -540,6 +540,12 @@ if test x"$with_included_popt" != x"yes"
+@@ -577,6 +577,12 @@ if test x"$with_included_popt" != x"yes"
      AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])
  fi
  
 +AC_ARG_ENABLE(ODBC, AC_HELP_STRING([--enable-ODBC], [compile in support for ODBC database logging]),
 +    [ AC_CHECK_HEADERS(sql.h sqlext.h sqltypes.h)
 +    AC_CHECK_LIB(odbc,SQLExecDirect)
@@ -1237,13 +1237,13 @@
 +void db_log_exit(int code, const char *file, int line);
 +void db_log_delete(char *fname, int mode);
 +void db_log_error(enum logcode code, int errcode, const char *format,...);
  void set_filter_dir(const char *dir, unsigned int dirlen);
  void *push_local_filters(const char *dir, unsigned int dirlen);
  void pop_local_filters(void *mem);
-@@ -150,9 +158,16 @@ int lp_rsync_port(void);
+@@ -149,9 +157,16 @@ int lp_rsync_port(void);
  int lp_syslog_facility(void);
  char *lp_auth_users(int );
  char *lp_comment(int );
 +char *lp_custom_unique_id_select(int );
 +char *lp_database_datasource(int );
 +char *lp_database_password(int );
@@ -1254,13 +1254,13 @@
  char *lp_exclude(int );
  char *lp_exclude_from(int );
 +char *lp_exit_table_name(int );
  char *lp_filter(int );
  char *lp_gid(int );
  char *lp_hosts_allow(int );
-@@ -169,11 +184,17 @@ char *lp_postxfer_exec(int );
+@@ -168,11 +183,17 @@ char *lp_postxfer_exec(int );
  char *lp_prexfer_exec(int );
  char *lp_refuse_options(int );
  char *lp_secrets_file(int );
 +char *lp_sequence_name(int );
 +char *lp_session_table_name(int );
  char *lp_temp_dir(int );
@@ -1272,13 +1272,13 @@
  int lp_timeout(int );
 +BOOL lp_database_logging(int );
 +BOOL lp_get_custom_id_before_insert(int );
  BOOL lp_ignore_errors(int );
  BOOL lp_ignore_nonreadable(int );
  BOOL lp_list(int );
-@@ -185,6 +206,7 @@ BOOL lp_write_only(int );
+@@ -184,6 +205,7 @@ BOOL lp_write_only(int );
  BOOL lp_load(char *pszFname, int globals_only);
  int lp_numservices(void);
  int lp_number(char *name);
 +char const *rerr_name(int code);
  void log_init(void);
  void logfile_close(void);
@@ -1299,13 +1299,13 @@
    --disable-ipv6          don't even try to use IPv6
    --disable-locale        turn off locale features
 +  --enable-ODBC           compile in support for ODBC database logging
  
  Optional Packages:
    --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-@@ -11435,6 +11436,237 @@ fi
+@@ -11558,6 +11559,237 @@ fi
  
  fi
  
 +# Check whether --enable-ODBC or --disable-ODBC was given.
 +if test "${enable_ODBC+set}" = set; then
 +  enableval="$enable_ODBC"
@@ -1537,33 +1537,33 @@
 +
 +fi;
 +
  echo "$as_me:$LINENO: checking whether to use included libpopt" >&5
  echo $ECHO_N "checking whether to use included libpopt... $ECHO_C" >&6
  if test x"$with_included_popt" = x"yes"; then
-@@ -12747,6 +12979,7 @@ s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+@@ -12755,6 +12987,7 @@ s,@INSTALL_DATA@,$INSTALL_DATA,;t t
  s,@HAVE_REMSH@,$HAVE_REMSH,;t t
  s,@LIBOBJS@,$LIBOBJS,;t t
  s,@ALLOCA@,$ALLOCA,;t t
 +s,@EXTRA_OBJECT@,$EXTRA_OBJECT,;t t
  s,@OBJ_SAVE@,$OBJ_SAVE,;t t
  s,@OBJ_RESTORE@,$OBJ_RESTORE,;t t
  s,@CC_SHOBJ_FLAG@,$CC_SHOBJ_FLAG,;t t
 --- old/config.h.in
 +++ new/config.h.in
-@@ -149,6 +149,9 @@
+@@ -155,6 +155,9 @@
  /* Define to 1 if you have the `nsl_s' library (-lnsl_s). */
  #undef HAVE_LIBNSL_S
  
 +/* Define to 1 if you have the `odbc' library (-lodbc). */
 +#undef HAVE_LIBODBC
 +
  /* Define to 1 if you have the `popt' library (-lpopt). */
  #undef HAVE_LIBPOPT
  
-@@ -270,6 +273,15 @@
+@@ -276,6 +279,15 @@
  /* Define to 1 if you have the "socketpair" function */
  #undef HAVE_SOCKETPAIR
  
 +/* Define to 1 if you have the <sqlext.h> header file. */
 +#undef HAVE_SQLEXT_H
 +
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/openssl-support.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/openssl-support.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/openssl-support.diff	2006-03-12 02:47:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/openssl-support.diff	2006-04-22 23:53:50.000000000 +0800
@@ -163,23 +163,23 @@
  }
  
 +
  /* this is called when a connection is established to a client
     and we want to start talking. The setup of the system is done from
     here */
-@@ -778,6 +827,9 @@ int start_daemon(int f_in, int f_out)
+@@ -780,6 +829,9 @@ int start_daemon(int f_in, int f_out)
  	if (protocol_version > remote_protocol)
  		protocol_version = remote_protocol;
  
 +#if HAVE_OPENSSL
 +retry:
 +#endif
  	line[0] = 0;
  	if (!read_line(f_in, line, sizeof line - 1))
  		return -1;
-@@ -789,6 +841,20 @@ int start_daemon(int f_in, int f_out)
+@@ -791,6 +843,20 @@ int start_daemon(int f_in, int f_out)
  		return -1;
  	}
  
 +#if HAVE_OPENSSL
 +	if (use_ssl && strcmp(line, "#starttls") == 0) {
 +		io_printf(f_out, "@RSYNCD: starttls\n");
@@ -220,13 +220,13 @@
 +
  AC_MSG_CHECKING([whether to call shutdown on all sockets])
  case $host_os in
  	*cygwin* ) AC_MSG_RESULT(yes)
 --- old/options.c
 +++ new/options.c
-@@ -168,6 +168,14 @@ int log_format_has_o_or_i = 0;
+@@ -166,6 +166,14 @@ int log_format_has_o_or_i = 0;
  int always_checksum = 0;
  int list_only = 0;
  
 +#if HAVE_OPENSSL
 +int use_ssl = 0;
 +char *ssl_cert_path = NULL;
@@ -235,44 +235,44 @@
 +char *ssl_ca_path = NULL;
 +#endif
 +
  #define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
  char *batch_name = NULL;
  
-@@ -196,6 +204,7 @@ static void print_rsync_version(enum log
+@@ -194,6 +202,7 @@ static void print_rsync_version(enum log
  	char const *hardlinks = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
 +	char const *ssl = "no ";
  	STRUCT_STAT *dumstat;
  
  #ifdef HAVE_SOCKETPAIR
-@@ -218,6 +227,10 @@ static void print_rsync_version(enum log
+@@ -216,6 +225,10 @@ static void print_rsync_version(enum log
  	ipv6 = "";
  #endif
  
 +#if HAVE_OPENSSL
 +	ssl = "";
 +#endif
 +
  	rprintf(f, "%s  version %s  protocol version %d\n",
  		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
  	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
-@@ -230,9 +243,9 @@ static void print_rsync_version(enum log
+@@ -228,9 +241,9 @@ static void print_rsync_version(enum log
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
  	 * macros. */
 -	rprintf(f, "              %sinplace, %sIPv6, "
 +	rprintf(f, "              %sinplace, %sIPv6, %sSSL, "
  		"%d-bit system inums, %d-bit internal inums\n",
 -		have_inplace, ipv6,
 +		have_inplace, ipv6, ssl,
  		(int) (sizeof dumstat->st_ino * 8),
  		(int) (sizeof (int64) * 8));
  #ifdef MAINTAINER_MODE
-@@ -373,6 +386,13 @@ void usage(enum logcode F)
+@@ -371,6 +384,13 @@ void usage(enum logcode F)
    rprintf(F," -4, --ipv4                  prefer IPv4\n");
    rprintf(F," -6, --ipv6                  prefer IPv6\n");
  #endif
 +#if HAVE_OPENSSL
 +  rprintf(F,"     --ssl                   allow socket connections to use SSL\n");
 +  rprintf(F,"     --ssl-cert=FILE         path to daemon's SSL certificate\n");
@@ -280,22 +280,22 @@
 +  rprintf(F,"     --ssl-key-passwd=PASS   password for PEM-encoded private key\n");
 +  rprintf(F,"     --ssl-ca-certs=FILE     path to trusted CA certificates\n");
 +#endif
    rprintf(F,"     --version               print version number\n");
    rprintf(F,"(-h) --help                  show this help (-h works with no other options)\n");
  
-@@ -385,7 +405,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
+@@ -383,7 +403,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
        OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
        OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
        OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
 -      OPT_NO_D,
 +      OPT_NO_D, OPT_USE_SSL,
        OPT_SERVER, OPT_REFUSED_BASE = 9000};
  
  static struct poptOption long_options[] = {
-@@ -526,6 +546,13 @@ static struct poptOption long_options[] 
+@@ -524,6 +544,13 @@ static struct poptOption long_options[] 
    {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
    {"server",           0,  POPT_ARG_NONE,   0, OPT_SERVER, 0, 0 },
    {"sender",           0,  POPT_ARG_NONE,   0, OPT_SENDER, 0, 0 },
 +#if HAVE_OPENSSL
 +  {"ssl",              0,  POPT_ARG_NONE,   0, OPT_USE_SSL, 0, 0},
 +  {"ssl-cert",         0,  POPT_ARG_STRING, &ssl_cert_path, OPT_USE_SSL, 0, 0},
@@ -303,26 +303,26 @@
 +  {"ssl-key-passwd",   0,  POPT_ARG_STRING, &ssl_key_passwd, OPT_USE_SSL, 0, 0},
 +  {"ssl-ca-certs",     0,  POPT_ARG_STRING, &ssl_ca_path, OPT_USE_SSL, 0, 0},
 +#endif
    /* All the following options switch us into daemon-mode option-parsing. */
    {"config",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
    {"daemon",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
-@@ -1068,6 +1095,12 @@ int parse_arguments(int *argc, const cha
+@@ -1066,6 +1093,12 @@ int parse_arguments(int *argc, const cha
  			usage(FINFO);
  			exit_cleanup(0);
  
 +		case OPT_USE_SSL:
 +#if HAVE_OPENSSL
 +			use_ssl = 1;
 +#endif
 +			break;
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1346,6 +1379,17 @@ int parse_arguments(int *argc, const cha
+@@ -1343,6 +1376,17 @@ int parse_arguments(int *argc, const cha
  	if (delay_updates && !partial_dir)
  		partial_dir = tmp_partialdir;
  
 +#if HAVE_OPENSSL
 +	if (use_ssl) {
 +		if (init_tls()) {
@@ -334,13 +334,13 @@
 +	}
 +#endif
 +
  	if (inplace) {
  #ifdef HAVE_FTRUNCATE
  		if (partial_dir) {
-@@ -1759,11 +1803,28 @@ char *check_for_hostspec(char *s, char *
+@@ -1756,11 +1800,28 @@ char *check_for_hostspec(char *s, char *
  {
  	char *p;
  	int not_host;
 +	int url_prefix_len = sizeof URL_PREFIX - 1;
  
 -	if (port_ptr && strncasecmp(URL_PREFIX, s, strlen(URL_PREFIX)) == 0) {
@@ -375,13 +375,13 @@
  #define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
  #define URL_PREFIX "rsync://"
 +#define SSL_URL_PREFIX "rsyncs://"
  
  #define BACKUP_SUFFIX "~"
  
-@@ -410,6 +411,11 @@ enum msgcode {
+@@ -412,6 +413,11 @@ enum msgcode {
  # define SIZEOF_INT64 SIZEOF_OFF_T
  #endif
  
 +#if HAVE_OPENSSL
 +#include <openssl/ssl.h>
 +#include <openssl/err.h>
@@ -758,13 +758,13 @@
 +{
 +	if (ssl_pid > 0)
 +		kill(ssl_pid, SIGUSR1);
 +}
 --- old/proto.h
 +++ new/proto.h
-@@ -247,6 +247,12 @@ void start_accept_loop(int port, int (*f
+@@ -246,6 +246,12 @@ void start_accept_loop(int port, int (*f
  void set_socket_options(int fd, char *options);
  void become_daemon(void);
  int sock_exec(const char *prog);
 +int init_tls(void);
 +char *get_ssl_error(void);
 +int get_tls_rfd(void);
@@ -893,33 +893,33 @@
 +	fi
 +fi
 +
  echo "$as_me:$LINENO: checking whether to call shutdown on all sockets" >&5
  echo $ECHO_N "checking whether to call shutdown on all sockets... $ECHO_C" >&6
  case $host_os in
-@@ -12745,6 +12842,7 @@ s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t 
+@@ -12753,6 +12850,7 @@ s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t 
  s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
  s,@INSTALL_DATA@,$INSTALL_DATA,;t t
  s,@HAVE_REMSH@,$HAVE_REMSH,;t t
 +s,@SSL_OBJS@,$SSL_OBJS,;t t
  s,@LIBOBJS@,$LIBOBJS,;t t
  s,@ALLOCA@,$ALLOCA,;t t
  s,@OBJ_SAVE@,$OBJ_SAVE,;t t
 --- old/config.h.in
 +++ new/config.h.in
-@@ -158,6 +158,9 @@
+@@ -164,6 +164,9 @@
  /* Define to 1 if you have the `socket' library (-lsocket). */
  #undef HAVE_LIBSOCKET
  
 +/* Define to 1 if you have the `ssl' library (-lssl). */
 +#undef HAVE_LIBSSL
 +
  /* Define to 1 if you have the <limits.h> header file. */
  #undef HAVE_LIMITS_H
  
-@@ -219,6 +222,9 @@
+@@ -225,6 +228,9 @@
  /* Define to 1 if you have the `open64' function. */
  #undef HAVE_OPEN64
  
 +/* true if you want to use SSL. */
 +#undef HAVE_OPENSSL
 +
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/slow-down.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/slow-down.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/slow-down.diff	2006-03-12 02:47:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/slow-down.diff	2006-04-22 00:58:13.000000000 +0800
@@ -12,44 +12,44 @@
 +++ new/flist.c
 @@ -57,6 +57,7 @@ extern int copy_links;
  extern int copy_unsafe_links;
  extern int protocol_version;
  extern int sanitize_paths;
 +extern unsigned long sleep_asec;
- extern const char *io_write_phase;
  extern struct stats stats;
  extern struct file_list *the_file_list;
-@@ -1048,6 +1049,9 @@ static void send_directory(int f, struct
+ 
+@@ -1043,6 +1044,9 @@ static void send_directory(int f, struct
  		}
  
  		send_file_name(f, flist, fbuf, NULL, 0);
 +		/* Sleep for a bit, to avoid hammering the disk. */
 +		if (sleep_asec)
 +			usleep(sleep_asec);
  	}
  
  	fbuf[len] = '\0';
 --- old/options.c
 +++ new/options.c
-@@ -102,6 +102,7 @@ int size_only = 0;
+@@ -100,6 +100,7 @@ int size_only = 0;
  int daemon_bwlimit = 0;
  int bwlimit = 0;
  int fuzzy_basis = 0;
 +unsigned long sleep_asec = 0;
  size_t bwlimit_writemax = 0;
  int ignore_existing = 0;
  int ignore_non_existing = 0;
-@@ -365,6 +366,7 @@ void usage(enum logcode F)
+@@ -363,6 +364,7 @@ void usage(enum logcode F)
    rprintf(F,"     --password-file=FILE    read password from FILE\n");
    rprintf(F,"     --list-only             list the files instead of copying them\n");
    rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
 +  rprintf(F,"     --slow-down=USECs       sleep N usec while creating the filelist\n");
    rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
    rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
    rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
-@@ -497,6 +499,7 @@ static struct poptOption long_options[] 
+@@ -495,6 +497,7 @@ static struct poptOption long_options[] 
    {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
    {"itemize-changes", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },
    {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
 +  {"slow-down",        0,  POPT_ARG_LONG,   &sleep_asec, 0, 0, 0 },
    {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
    {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/slp.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/slp.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/slp.diff	2006-03-12 02:47:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/slp.diff	2006-04-22 23:54:09.000000000 +0800
@@ -37,13 +37,13 @@
 +	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS) $(LIBSLP)
  
  $(OBJS): $(HEADERS)
  
 --- old/clientserver.c
 +++ new/clientserver.c
-@@ -847,6 +847,13 @@ int daemon_main(void)
+@@ -849,6 +849,13 @@ int daemon_main(void)
  	 * address too.  In fact, why not just do inet_ntop on the
  	 * local address??? */
  
 +#ifdef HAVE_LIBSLP
 +	if (register_services()) {
 +		rprintf(FINFO,
@@ -53,14 +53,14 @@
 +
  	if (((pid_file = lp_pid_file()) != NULL) && (*pid_file != '\0')) {
  		char pidbuf[16];
  		int fd;
 --- old/configure.in
 +++ new/configure.in
-@@ -522,6 +522,29 @@ if test $rsync_cv_chown_follows_symlink 
-   AC_DEFINE(CHOWN_MODIFIES_SYMLINK, 1, [Define to 1 if chown modifies symlinks.])
+@@ -559,6 +559,29 @@ if test $rsync_cv_can_hardlink_special =
+     AC_DEFINE(CAN_HARDLINK_SPECIAL, 1, [Define to 1 if link() can hard-link special files.])
  fi
  
 +AC_ARG_ENABLE(slp, [  --disable-slp           turn off SLP support, defaults to on])
 +AC_ARG_WITH(openslp-libs, [  --with-openslp-libs     set directory for OpenSLP library],
 +    LDFLAGS="-L$withval $LDFLAGS"
 +    DSOFLAGS="-L$withval $DSOFLAGS",)
@@ -138,32 +138,32 @@
 +
  		if (shell_path) { /* source is remote */
  			char *dummy1;
  			int dummy2;
 --- old/options.c
 +++ new/options.c
-@@ -196,6 +196,7 @@ static void print_rsync_version(enum log
+@@ -194,6 +194,7 @@ static void print_rsync_version(enum log
  	char const *hardlinks = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
 +	char const *slp = "no ";
  	STRUCT_STAT *dumstat;
  
  #ifdef HAVE_SOCKETPAIR
-@@ -218,6 +219,10 @@ static void print_rsync_version(enum log
+@@ -216,6 +217,10 @@ static void print_rsync_version(enum log
  	ipv6 = "";
  #endif
  
 +#if HAVE_LIBSLP
 +	slp = "";
 +#endif
 +
  	rprintf(f, "%s  version %s  protocol version %d\n",
  		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
  	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
-@@ -230,9 +235,9 @@ static void print_rsync_version(enum log
+@@ -228,9 +233,9 @@ static void print_rsync_version(enum log
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
  	 * macros. */
 -	rprintf(f, "              %sinplace, %sIPv6, "
 +	rprintf(f, "              %sinplace, %sIPv6, %sSLP, "
  		"%d-bit system inums, %d-bit internal inums\n",
@@ -171,13 +171,13 @@
 +		have_inplace, ipv6, slp,
  		(int) (sizeof dumstat->st_ino * 8),
  		(int) (sizeof (int64) * 8));
  #ifdef MAINTAINER_MODE
 --- old/rsync.h
 +++ new/rsync.h
-@@ -154,6 +154,9 @@
+@@ -156,6 +156,9 @@
  #define SIGNIFICANT_ITEM_FLAGS (~(\
  	ITEM_BASIS_TYPE_FOLLOWS | ITEM_XNAME_FOLLOWS | ITEM_LOCAL_CHANGE))
  
 +/* this is the minimum we'll use, irrespective of config setting */
 +/* definately don't set to less than about 30 seconds */
 +#define SLP_MIN_TIMEOUT 120
@@ -231,13 +231,13 @@
 +slp refresh = 3600
  
  [ftp]
          path = /var/ftp/pub
 --- old/socket.c
 +++ new/socket.c
-@@ -447,6 +447,16 @@ void start_accept_loop(int port, int (*f
+@@ -471,6 +471,16 @@ void start_accept_loop(int port, int (*f
  {
  	fd_set deffds;
  	int *sp, maxfd, i;
 +#ifdef HAVE_LIBSLP
 +	time_t next_slp_refresh;
 +	short slp_timeout = lp_slp_refresh();
@@ -248,13 +248,13 @@
 +		slp_timeout -= 15;
 +	}
 +#endif
  
  #ifdef HAVE_SIGACTION
  	sigact.sa_flags = SA_NOCLDSTOP;
-@@ -475,14 +485,25 @@ void start_accept_loop(int port, int (*f
+@@ -499,14 +509,25 @@ void start_accept_loop(int port, int (*f
  			maxfd = sp[i];
  	}
  
 +#ifdef HAVE_LIBSLP
 +	next_slp_refresh = time(NULL) + slp_timeout;
 +#endif
@@ -274,13 +274,13 @@
 +		slp_tv.tv_sec = 10;
 +		slp_tv.tv_usec = 0;
 +#endif
  
  		/* close log file before the potentially very long select so
  		 * file can be trimmed by another process instead of growing
-@@ -494,8 +515,18 @@ void start_accept_loop(int port, int (*f
+@@ -518,8 +539,18 @@ void start_accept_loop(int port, int (*f
  #else
  		fds = deffds;
  #endif
 -
 -		if (select(maxfd + 1, &fds, NULL, NULL, NULL) != 1)
 +#ifdef HAVE_LIBSLP
@@ -534,21 +534,21 @@
 +
 +	/* refresh is done in main select loop */
 +	return 0;
 +}
 --- old/proto.h
 +++ new/proto.h
-@@ -147,6 +147,7 @@ char *lp_motd_file(void);
+@@ -146,6 +146,7 @@ char *lp_motd_file(void);
  char *lp_pid_file(void);
  char *lp_socket_options(void);
  int lp_rsync_port(void);
 +int lp_slp_refresh(void);
  int lp_syslog_facility(void);
  char *lp_auth_users(int );
  char *lp_comment(int );
-@@ -247,6 +248,8 @@ void start_accept_loop(int port, int (*f
+@@ -246,6 +247,8 @@ void start_accept_loop(int port, int (*f
  void set_socket_options(int fd, char *options);
  void become_daemon(void);
  int sock_exec(const char *prog);
 +int print_service_list(void);
 +int register_services(void);
  int do_unlink(const char *fname);
@@ -579,13 +579,13 @@
    --with-rsh=CMD          set remote shell command to CMD (default: ssh)
 +  --with-openslp-libs     set directory for OpenSLP library
 +  --with-openslp-includes set directory for OpenSLP includes
  
  Some influential environment variables:
    CC          C compiler command
-@@ -11300,6 +11303,249 @@ _ACEOF
+@@ -11423,6 +11426,249 @@ _ACEOF
  
  fi
  
 +# Check whether --enable-slp or --disable-slp was given.
 +if test "${enable_slp+set}" = set; then
 +  enableval="$enable_slp"
@@ -829,24 +829,24 @@
 +
 +
 +
  echo "$as_me:$LINENO: checking for working socketpair" >&5
  echo $ECHO_N "checking for working socketpair... $ECHO_C" >&6
  if test "${rsync_cv_HAVE_SOCKETPAIR+set}" = set; then
-@@ -12747,6 +12993,8 @@ s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+@@ -12755,6 +13001,8 @@ s,@INSTALL_DATA@,$INSTALL_DATA,;t t
  s,@HAVE_REMSH@,$HAVE_REMSH,;t t
  s,@LIBOBJS@,$LIBOBJS,;t t
  s,@ALLOCA@,$ALLOCA,;t t
 +s,@LIBSLP@,$LIBSLP,;t t
 +s,@SLPOBJ@,$SLPOBJ,;t t
  s,@OBJ_SAVE@,$OBJ_SAVE,;t t
  s,@OBJ_RESTORE@,$OBJ_RESTORE,;t t
  s,@CC_SHOBJ_FLAG@,$CC_SHOBJ_FLAG,;t t
 --- old/config.h.in
 +++ new/config.h.in
-@@ -155,6 +155,9 @@
+@@ -161,6 +161,9 @@
  /* Define to 1 if you have the `resolv' library (-lresolv). */
  #undef HAVE_LIBRESOLV
  
 +/* Define to 1 for SLP support */
 +#undef HAVE_LIBSLP
 +
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/source-filter_dest-filter.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/source-filter_dest-filter.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/source-filter_dest-filter.diff	2006-03-12 02:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/source-filter_dest-filter.diff	2006-04-23 00:11:09.000000000 +0800
@@ -36,13 +36,13 @@
  extern int csum_length;
  extern int ignore_times;
 +extern int times_only;
  extern int size_only;
  extern OFF_T max_size;
  extern OFF_T min_size;
-@@ -378,7 +379,7 @@ void itemize(struct file_struct *file, i
+@@ -376,7 +377,7 @@ void itemize(struct file_struct *file, i
  /* Perform our quick-check heuristic for determining if a file is unchanged. */
  int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
  {
 -	if (st->st_size != file->length)
 +	if (!times_only && st->st_size != file->length)
  		return 0;
@@ -58,64 +58,64 @@
 +void wait_process_with_flush(pid_t pid, int *exit_code_ptr)
  {
  	pid_t waited_pid;
  	int status;
 --- old/options.c
 +++ new/options.c
-@@ -99,6 +99,7 @@ int keep_partial = 0;
+@@ -97,6 +97,7 @@ int keep_partial = 0;
  int safe_symlinks = 0;
  int copy_unsafe_links = 0;
  int size_only = 0;
 +int times_only = 0;
  int daemon_bwlimit = 0;
  int bwlimit = 0;
  int fuzzy_basis = 0;
-@@ -148,6 +149,8 @@ char *basis_dir[MAX_BASIS_DIRS+1];
+@@ -146,6 +147,8 @@ char *basis_dir[MAX_BASIS_DIRS+1];
  char *config_file = NULL;
  char *shell_cmd = NULL;
  char *log_format = NULL;
 +char *source_filter = NULL;
 +char *dest_filter = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
-@@ -333,6 +336,7 @@ void usage(enum logcode F)
+@@ -331,6 +334,7 @@ void usage(enum logcode F)
    rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
    rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
    rprintf(F,"     --size-only             skip files that match in size\n");
 +  rprintf(F,"     --times-only            skip files that match in mod-time\n");
    rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
    rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
    rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
-@@ -368,6 +372,8 @@ void usage(enum logcode F)
+@@ -366,6 +370,8 @@ void usage(enum logcode F)
    rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
    rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
    rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
 +  rprintf(F,"     --source-filter=COMMAND filter file through COMMAND at source\n");
 +  rprintf(F,"     --dest-filter=COMMAND   filter file through COMMAND at destination\n");
    rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
  #ifdef INET6
    rprintf(F," -4, --ipv4                  prefer IPv4\n");
-@@ -448,6 +454,7 @@ static struct poptOption long_options[] 
+@@ -446,6 +452,7 @@ static struct poptOption long_options[] 
    {"chmod",            0,  POPT_ARG_STRING, 0, OPT_CHMOD, 0, 0 },
    {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
    {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
 +  {"times-only",       0,  POPT_ARG_NONE,   &times_only , 0, 0, 0 },
    {"one-file-system", 'x', POPT_ARG_NONE,   0, 'x', 0, 0 },
    {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
    {"existing",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
-@@ -522,6 +529,8 @@ static struct poptOption long_options[] 
+@@ -520,6 +527,8 @@ static struct poptOption long_options[] 
    {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
    {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
    {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
 +  {"source-filter",    0,  POPT_ARG_STRING, &source_filter, 0, 0, 0 },
 +  {"dest-filter",      0,  POPT_ARG_STRING, &dest_filter, 0, 0, 0 },
    {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
    {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
    {"server",           0,  POPT_ARG_NONE,   0, OPT_SERVER, 0, 0 },
-@@ -1391,6 +1400,16 @@ int parse_arguments(int *argc, const cha
+@@ -1388,6 +1397,16 @@ int parse_arguments(int *argc, const cha
  		}
  	}
  
 +	if (source_filter || dest_filter) {
 +		if (whole_file == 0) {
 +			snprintf(err_buf, sizeof err_buf,
@@ -126,13 +126,13 @@
 +		whole_file = 1;
 +	}
 +
  	if (files_from) {
  		char *h, *p;
  		int q;
-@@ -1656,6 +1675,25 @@ void server_options(char **args,int *arg
+@@ -1653,6 +1672,25 @@ void server_options(char **args,int *arg
  			args[ac++] = "--size-only";
  	}
  
 +	if (times_only && am_sender)
 +		args[ac++] = "--times-only";
 +
@@ -331,13 +331,13 @@
       --read-batch=FILE       read a batched update from FILE
 +     --source-filter=COMMAND filter file through COMMAND at source
 +     --dest-filter=COMMAND   filter file through COMMAND at destination
       --protocol=NUM          force an older protocol version to be used
       --checksum-seed=NUM     set block/file checksum seed (advanced)
   -4, --ipv4                  prefer IPv4
-@@ -1704,6 +1707,33 @@ file previously generated by bf(--write-
+@@ -1711,6 +1714,33 @@ file previously generated by bf(--write-
  If em(FILE) is bf(-), the batch data will be read from standard input.
  See the "BATCH MODE" section for details.
  
 +dit(bf(--source-filter=COMMAND)) This option allows the user to specify a
 +filter program that will be applied to the contents of all transferred
 +regular files before the data is sent to destination.  COMMAND will receive
@@ -455,21 +455,21 @@
 +			unlink(tmp);
  
  		free_sums(s);
  
 --- old/proto.h
 +++ new/proto.h
-@@ -200,6 +200,7 @@ void maybe_log_item(struct file_struct *
+@@ -199,6 +199,7 @@ void maybe_log_item(struct file_struct *
  void log_delete(char *fname, int mode);
  void log_exit(int code, const char *file, int line);
  pid_t wait_process(pid_t pid, int *status_ptr, int flags);
 +void wait_process_with_flush(pid_t pid, int *exit_code_ptr);
  int child_main(int argc, char *argv[]);
  void start_server(int f_in, int f_out, int argc, char *argv[]);
  int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[]);
-@@ -219,6 +220,8 @@ BOOL pm_process( char *FileName,
+@@ -218,6 +219,8 @@ BOOL pm_process( char *FileName,
  pid_t piped_child(char **command, int *f_in, int *f_out);
  pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
  		  int (*child_main)(int, char*[]));
 +pid_t run_filter(char *command[], int out, int *pipe_to_filter);
 +pid_t run_filter_on_file(char *command[], int out, int in);
  void end_progress(OFF_T size);
@@ -491,13 +491,13 @@
       --read-batch=FILE       read a batched update from FILE
 +     --source-filter=COMMAND filter file through COMMAND at source
 +     --dest-filter=COMMAND   filter file through COMMAND at destination
       --protocol=NUM          force an older protocol version to be used
       --checksum-seed=NUM     set block/file checksum seed (advanced)
   -4, --ipv4                  prefer IPv4
-@@ -1950,6 +1953,35 @@ file previously generated by \fB--write-
+@@ -1959,6 +1962,35 @@ file previously generated by \fB--write-
  If \fIFILE\fP is \fB-\fP, the batch data will be read from standard input\&.
  See the "BATCH MODE" section for details\&.
  .IP 
 +.IP "\fB--source-filter=COMMAND\fP" 
 +This option allows the user to specify a
 +filter program that will be applied to the contents of all transferred
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/threaded-receiver.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/threaded-receiver.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/threaded-receiver.diff	2006-03-12 02:47:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/threaded-receiver.diff	2006-04-23 00:11:16.000000000 +0800
@@ -84,81 +84,81 @@
  extern int allowed_lull;
  extern int sock_f_out;
 -extern int ignore_timeout;
  extern int protocol_version;
  extern int fuzzy_basis;
  extern int always_checksum;
-@@ -97,6 +96,11 @@ static int deletion_count = 0; /* used t
- static int can_link_symlinks = 1; /* start out optimistic */
- static int can_link_devices = 1;
+@@ -95,6 +94,11 @@ extern struct filter_list_struct server_
+ 
+ static int deletion_count = 0; /* used to implement --max-delete */
  
 +/* These vars are local copies so that the receiver can use the originals. */
 +static int GEN_append_mode;
 +static int GEN_make_backups;
 +static int GEN_csum_length;
 +
  /* For calling delete_file() */
  #define DEL_FORCE_RECURSE	(1<<1) /* recurse even w/o --force */
  #define DEL_TERSE		(1<<3)
-@@ -445,8 +449,8 @@ static void sum_sizes_sqroot(struct sum_
+@@ -443,8 +447,8 @@ static void sum_sizes_sqroot(struct sum_
  	}
  
  	if (protocol_version < 27) {
 -		s2length = csum_length;
 -	} else if (csum_length == SUM_LENGTH) {
 +		s2length = GEN_csum_length;
 +	} else if (GEN_csum_length == SUM_LENGTH) {
  		s2length = SUM_LENGTH;
  	} else {
  		int32 c;
-@@ -456,7 +460,7 @@ static void sum_sizes_sqroot(struct sum_
+@@ -454,7 +458,7 @@ static void sum_sizes_sqroot(struct sum_
  		for (c = blength; c >>= 1 && b; b--) {}
  		/* add a bit, subtract rollsum, round up. */
  		s2length = (b + 1 - 32 + 7) / 8; /* --optimize in compiler-- */
 -		s2length = MAX(s2length, csum_length);
 +		s2length = MAX(s2length, GEN_csum_length);
  		s2length = MIN(s2length, SUM_LENGTH);
  	}
  
-@@ -490,7 +494,7 @@ static void generate_and_send_sums(int f
+@@ -488,7 +492,7 @@ static void generate_and_send_sums(int f
  	sum_sizes_sqroot(&sum, len);
  	write_sum_head(f_out, &sum);
  
 -	if (append_mode > 0 && f_copy < 0)
 +	if (GEN_append_mode > 0 && f_copy < 0)
  		return;
  
  	if (len > 0)
-@@ -509,7 +513,7 @@ static void generate_and_send_sums(int f
+@@ -507,7 +511,7 @@ static void generate_and_send_sums(int f
  
  		if (f_copy >= 0) {
  			full_write(f_copy, map, n1);
 -			if (append_mode > 0)
 +			if (GEN_append_mode > 0)
  				continue;
  		}
  
-@@ -1152,7 +1156,7 @@ static void recv_generator(char *fname, 
+@@ -1175,7 +1179,7 @@ static void recv_generator(char *fname, 
  		return;
  	}
  
 -	if (append_mode && st.st_size > file->length)
 +	if (GEN_append_mode && st.st_size > file->length)
  		return;
  
  	if (fnamecmp_type <= FNAMECMP_BASIS_DIR_HIGH)
-@@ -1207,7 +1211,7 @@ static void recv_generator(char *fname, 
+@@ -1230,7 +1234,7 @@ static void recv_generator(char *fname, 
  		goto notify_others;
  	}
  
 -	if (inplace && make_backups && fnamecmp_type == FNAMECMP_FNAME) {
 +	if (inplace && GEN_make_backups && fnamecmp_type == FNAMECMP_FNAME) {
  		if (!(backupptr = get_backup_name(fname))) {
  			close(fd);
  			return;
-@@ -1298,9 +1302,12 @@ void generate_files(int f_out, struct fi
+@@ -1321,9 +1325,12 @@ void generate_files(int f_out, struct fi
  	int save_ignore_existing = ignore_existing;
  	int save_ignore_non_existing = ignore_non_existing;
  	int save_do_progress = do_progress;
 -	int save_make_backups = make_backups;
 +	int save_make_backups = GEN_make_backups = make_backups;
  	int dir_tweaking = !(list_only || local_name || dry_run);
@@ -166,35 +166,35 @@
 +	GEN_append_mode = append_mode;
 +	GEN_csum_length = csum_length;
 +
  	if (protocol_version >= 29) {
  		itemizing = 1;
  		maybe_ATTRS_REPORT = log_format_has_i ? 0 : ATTRS_REPORT;
-@@ -1328,7 +1335,7 @@ void generate_files(int f_out, struct fi
+@@ -1351,7 +1358,7 @@ void generate_files(int f_out, struct fi
  		do_delete_pass(flist);
  	do_progress = 0;
  
 -	if (append_mode || whole_file < 0)
 +	if (GEN_append_mode || whole_file < 0)
  		whole_file = 0;
  	if (verbose >= 2) {
  		rprintf(FINFO, "delta-transmission %s\n",
-@@ -1337,12 +1344,6 @@ void generate_files(int f_out, struct fi
+@@ -1360,12 +1367,6 @@ void generate_files(int f_out, struct fi
  			: "enabled");
  	}
  
 -	/* Since we often fill up the outgoing socket and then just sit around
 -	 * waiting for the other 2 processes to do their thing, we don't want
 -	 * to exit on a timeout.  If the data stops flowing, the receiver will
 -	 * notice that and let us know via the redo pipe (or its closing). */
 -	ignore_timeout = 1;
 -
  	for (i = 0; i < flist->count; i++) {
  		struct file_struct *file = flist->files[i];
  
-@@ -1386,23 +1387,34 @@ void generate_files(int f_out, struct fi
+@@ -1409,23 +1410,34 @@ void generate_files(int f_out, struct fi
  		delete_in_dir(NULL, NULL, NULL, NULL);
  
  	phase++;
 -	csum_length = SUM_LENGTH;
 +	GEN_csum_length = SUM_LENGTH; /* csum_length is set by the receiver */
  	max_size = min_size = ignore_existing = ignore_non_existing = 0;
@@ -229,13 +229,13 @@
 +			continue;
 +		}
 +		file = flist->files[i];
  		if (local_name)
  			strlcpy(fbuf, local_name, sizeof fbuf);
  		else
-@@ -1414,27 +1426,43 @@ void generate_files(int f_out, struct fi
+@@ -1437,27 +1449,43 @@ void generate_files(int f_out, struct fi
  	phase++;
  	ignore_non_existing = save_ignore_non_existing;
  	ignore_existing = save_ignore_existing;
 -	make_backups = save_make_backups;
 +	GEN_make_backups = save_make_backups;
  
@@ -303,21 +303,21 @@
  
  const char phase_unknown[] = "unknown";
 -int ignore_timeout = 0;
  int batch_fd = -1;
  int batch_gen_fd = -1;
  
-@@ -83,7 +80,6 @@ const char *io_read_phase = phase_unknow
+@@ -67,7 +64,6 @@ int batch_gen_fd = -1;
  int kluge_around_eof = 0;
  
  int msg_fd_in = -1;
 -int msg_fd_out = -1;
  int sock_f_in = -1;
  int sock_f_out = -1;
  
-@@ -110,27 +106,32 @@ static OFF_T active_bytecnt = 0;
+@@ -94,27 +90,31 @@ static OFF_T active_bytecnt = 0;
  static void read_loop(int fd, char *buf, size_t len);
  
  struct flist_ndx_item {
 -	struct flist_ndx_item *next;
 +	volatile struct flist_ndx_item *next;
  	int ndx;
@@ -333,30 +333,29 @@
 +static struct flist_ndx_list redo_list = { NULL, NULL, PTHREAD_MUTEX_INITIALIZER };
 +static struct flist_ndx_list hlink_list = { NULL, NULL, PTHREAD_MUTEX_INITIALIZER };
  
  struct msg_list_item {
 -	struct msg_list_item *next;
 +	volatile struct msg_list_item *next;
-+	pthread_mutex_t mutex;
- 	char *buf;
  	int len;
 +	enum msgcode code;
+ 	char buf[1];
  };
  
  struct msg_list {
 -	struct msg_list_item *head, *tail;
 +	volatile struct msg_list_item *head, *tail;
 +	pthread_mutex_t mutex;
  };
  
--static struct msg_list msg_list;
+-static struct msg_list msg2genr, msg2sndr;
 +static struct msg_list msg_list = { NULL, NULL, PTHREAD_MUTEX_INITIALIZER };
  
  static void flist_ndx_push(struct flist_ndx_list *lp, int ndx)
  {
-@@ -140,27 +141,31 @@ static void flist_ndx_push(struct flist_
+@@ -124,27 +124,31 @@ static void flist_ndx_push(struct flist_
  		out_of_memory("flist_ndx_push");
  	item->next = NULL;
  	item->ndx = ndx;
 +	pthread_mutex_lock(&redo_list.mutex);
  	if (lp->tail)
  		lp->tail->next = item;
@@ -388,22 +387,22 @@
  		lp->tail = NULL;
 +	pthread_mutex_unlock(&hlink_list.mutex);
 +	free(head);
  
  	return ndx;
  }
-@@ -169,7 +174,7 @@ static void check_timeout(void)
+@@ -153,7 +157,7 @@ static void check_timeout(void)
  {
  	time_t t;
  
 -	if (!io_timeout || ignore_timeout)
 +	if (!io_timeout)
  		return;
  
  	if (!last_io_in) {
-@@ -210,45 +215,40 @@ void set_io_timeout(int secs)
+@@ -194,44 +198,38 @@ void set_io_timeout(int secs)
  
  /* Setup the fd used to receive MSG_* messages.  Only needed during the
   * early stages of being a local sender (up through the sending of the
 - * file list) or when we're the generator (to fetch the messages from
 - * the receiver). */
 + * file list). */
@@ -418,50 +417,53 @@
 -{
 -	msg_fd_out = fd;
 -	set_nonblocking(msg_fd_out);
 -}
 -
  /* Add a message to the pending MSG_* list. */
- static void msg_list_add(int code, char *buf, int len)
+-static void msg_list_add(struct msg_list *lst, int code, char *buf, int len)
++static void msg_list_add(int code, char *buf, int len)
  {
- 	struct msg_list_item *ml;
+ 	struct msg_list_item *m;
+-	int sz = len + 4 + sizeof m[0] - 1;
++	int sz = len + sizeof m[0] - 1;
  
 +	assert(am_receiver());
- 	if (!(ml = new(struct msg_list_item)))
- 		out_of_memory("msg_list_add");
- 	ml->next = NULL;
--	if (!(ml->buf = new_array(char, len+4)))
-+	/* NOTE: the "+ 1" allows rwrite() to use the buf! */
-+	if (!(ml->buf = new_array(char, len + 1)))
+ 	if (!(m = (struct msg_list_item *)new_array(char, sz)))
  		out_of_memory("msg_list_add");
--	SIVAL(ml->buf, 0, ((code+MPLEX_BASE)<<24) | len);
--	memcpy(ml->buf+4, buf, len);
--	ml->len = len+4;
-+	memcpy(ml->buf, buf, len);
-+	ml->len = len;
-+	ml->code = code;
+ 	m->next = NULL;
+-	m->len = len + 4;
+-	SIVAL(m->buf, 0, ((code+MPLEX_BASE)<<24) | len);
+-	memcpy(m->buf + 4, buf, len);
+-	if (lst->tail)
+-		lst->tail->next = m;
++	m->len = len;
++	m->code = code;
++	memcpy(m->buf, buf, len);
 +
 +	pthread_mutex_lock(&msg_list.mutex);
- 	if (msg_list.tail)
- 		msg_list.tail->next = ml;
++	if (msg_list.tail)
++		msg_list.tail->next = m;
  	else
- 		msg_list.head = ml;
- 	msg_list.tail = ml;
+-		lst->head = m;
+-	lst->tail = m;
++		msg_list.head = m;
++	msg_list.tail = m;
 +	pthread_mutex_unlock(&msg_list.mutex);
  }
  
 -/* Read a message from the MSG_* fd and handle it.  This is called either
 +/* Read a message from the MSG_* fd and handle it.  This is only called
   * during the early stages of being a local sender (up through the sending
 - * of the file list) or when we're the generator (to fetch the messages
 - * from the receiver). */
 + * of the file list). */
  static void read_msg_fd(void)
  {
  	char buf[2048];
-@@ -267,51 +267,6 @@ static void read_msg_fd(void)
+@@ -250,57 +248,6 @@ static void read_msg_fd(void)
  	tag = (tag >> 24) - MPLEX_BASE;
  
  	switch (tag) {
 -	case MSG_DONE:
 -		if (len != 0 || !am_generator) {
 -			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
@@ -482,23 +484,29 @@
 -	case MSG_DELETED:
 -		if (len >= (int)sizeof buf || !am_generator) {
 -			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
 -			exit_cleanup(RERR_STREAMIO);
 -		}
 -		read_loop(fd, buf, len);
--		io_multiplex_write(MSG_DELETED, buf, len);
+-		if (defer_forwarding_messages)
+-			msg_list_add(&msg2sndr, MSG_DELETED, buf, len);
+-		else
+-			io_multiplex_write(MSG_DELETED, buf, len);
 -		break;
 -	case MSG_SUCCESS:
 -		if (len != 4 || !am_generator) {
 -			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
 -			exit_cleanup(RERR_STREAMIO);
 -		}
 -		read_loop(fd, buf, len);
 -		if (remove_sent_files) {
 -			decrement_active_files(IVAL(buf,0));
--			io_multiplex_write(MSG_SUCCESS, buf, len);
+-			if (defer_forwarding_messages)
+-				msg_list_add(&msg2sndr, MSG_SUCCESS, buf, len);
+-			else
+-				io_multiplex_write(MSG_SUCCESS, buf, len);
 -		}
 -		if (preserve_hard_links)
 -			flist_ndx_push(&hlink_list, IVAL(buf,0));
 -		break;
 -	case MSG_SOCKERR:
 -		if (!am_generator) {
@@ -507,35 +515,49 @@
 -		}
 -		close_multiplexing_out();
 -		/* FALL THROUGH */
  	case MSG_INFO:
  	case MSG_ERROR:
  	case MSG_LOG:
-@@ -354,71 +309,75 @@ void decrement_active_files(int ndx)
+@@ -309,10 +256,7 @@ static void read_msg_fd(void)
+ 			if (n >= sizeof buf)
+ 				n = sizeof buf - 1;
+ 			read_loop(fd, buf, n);
+-			if (am_generator && am_server && defer_forwarding_messages)
+-				msg_list_add(&msg2sndr, tag, buf, n);
+-			else
+-				rwrite((enum logcode)tag, buf, n);
++			rwrite((enum logcode)tag, buf, n);
+ 			len -= n;
+ 		}
+ 		break;
+@@ -347,70 +291,76 @@ void decrement_active_files(int ndx)
  	active_bytecnt -= the_file_list->files[ndx]->length;
  }
  
 -/* Try to push messages off the list onto the wire.  If we leave with more
 +/* Try to pop messages off the list onto the wire.  If we leave with more
   * to do, return 0.  On error, return -1.  If everything flushed, return 1.
 - * This is only active in the receiver. */
+-static int msg2genr_flush(int flush_it_all)
 + * This is only called by the generator. */
- static int msg_list_flush(int flush_it_all)
++static void msg_list_flush(void)
  {
 -	static int written = 0;
 -	struct timeval tv;
 -	fd_set fds;
--
++	assert(am_generator());
+ 
 -	if (msg_fd_out < 0)
 -		return -1;
--
-+	assert(am_generator());
-+	no_flush++;
- 	while (msg_list.head) {
--		struct msg_list_item *ml = msg_list.head;
--		int n = write(msg_fd_out, ml->buf + written, ml->len - written);
++	if (defer_forwarding_messages)
++		return;
+ 
+-	while (msg2genr.head) {
+-		struct msg_list_item *m = msg2genr.head;
+-		int n = write(msg_fd_out, m->buf + written, m->len - written);
 -		if (n < 0) {
 -			if (errno == EINTR)
 -				continue;
 -			if (errno != EWOULDBLOCK && errno != EAGAIN)
 -				return -1;
 -			if (!flush_it_all)
@@ -543,58 +565,57 @@
 -			FD_ZERO(&fds);
 -			FD_SET(msg_fd_out, &fds);
 -			tv.tv_sec = select_timeout;
 -			tv.tv_usec = 0;
 -			if (!select(msg_fd_out+1, NULL, &fds, NULL, &tv))
 -				check_timeout();
--		} else if ((written += n) == ml->len) {
--			free(ml->buf);
--			msg_list.head = ml->next;
--			if (!msg_list.head)
--				msg_list.tail = NULL;
--			free(ml);
+-		} else if ((written += n) == m->len) {
+-			msg2genr.head = m->next;
+-			if (!msg2genr.head)
+-				msg2genr.tail = NULL;
+-			free(m);
 -			written = 0;
-+		struct msg_list_item *ml = (struct msg_list_item *)msg_list.head;
-+		switch (ml->code) {
++	no_flush++;
++	defer_forwarding_messages = 1;
++	while (msg_list.head) {
++		struct msg_list_item *m = (struct msg_list_item *)msg_list.head;
++		pthread_mutex_lock(&msg_list.mutex);
++		if (!(msg_list.head = m->next))
++			msg_list.tail = NULL;
++		pthread_mutex_unlock(&msg_list.mutex);
++		switch (m->code) {
 +		case MSG_SOCKERR:
 +			close_multiplexing_out();
 +			/* FALL THROUGH */
 +		case MSG_INFO:
 +		case MSG_ERROR:
 +		case MSG_LOG:
-+			rwrite(ml->code, ml->buf, ml->len);
++			rwrite(m->code, m->buf, m->len);
 +			break;
 +		default:
-+			io_multiplex_write(ml->code, ml->buf, ml->len);
++			io_multiplex_write(m->code, m->buf, m->len);
 +			break;
  		}
-+		pthread_mutex_lock(&msg_list.mutex);
-+		if (!(msg_list.head = ml->next))
-+			msg_list.tail = NULL;
-+		pthread_mutex_unlock(&msg_list.mutex);
-+		free(ml->buf);
-+		free(ml);
-+		if (!flush_it_all)
-+			break;
++		free(m);
  	}
+-	return 1;
++	defer_forwarding_messages = 0;
 +	no_flush--;
-+
- 	return 1;
  }
  
  void send_msg(enum msgcode code, char *buf, int len)
  {
 -	if (msg_fd_out < 0) {
 +	if (am_receiver())
 +		msg_list_add(code, buf, len);
 +	else
  		io_multiplex_write(code, buf, len);
 -		return;
 -	}
--	msg_list_add(code, buf, len);
--	msg_list_flush(NORMAL_FLUSH);
+-	msg_list_add(&msg2genr, code, buf, len);
+-	msg2genr_flush(NORMAL_FLUSH);
  }
  
 -int get_redo_num(int itemizing, enum logcode code)
 +/* This is only used by the receiver. */
 +void push_redo_num(int ndx)
  {
@@ -627,114 +648,116 @@
  int get_hlink_num(void)
  {
 +	assert(am_generator());
  	return flist_ndx_pop(&hlink_list);
  }
  
-@@ -498,11 +457,6 @@ static int read_timeout(int fd, char *bu
+@@ -490,11 +440,6 @@ static int read_timeout(int fd, char *bu
  		FD_ZERO(&r_fds);
  		FD_ZERO(&w_fds);
  		FD_SET(fd, &r_fds);
--		if (msg_list.head) {
+-		if (msg2genr.head) {
 -			FD_SET(msg_fd_out, &w_fds);
 -			if (msg_fd_out > maxfd)
 -				maxfd = msg_fd_out;
 -		}
  		if (io_filesfrom_f_out >= 0) {
  			int new_fd;
  			if (io_filesfrom_buflen == 0) {
-@@ -535,9 +489,6 @@ static int read_timeout(int fd, char *bu
+@@ -527,9 +472,6 @@ static int read_timeout(int fd, char *bu
  			continue;
  		}
  
--		if (msg_list.head && FD_ISSET(msg_fd_out, &w_fds))
--			msg_list_flush(NORMAL_FLUSH);
+-		if (msg2genr.head && FD_ISSET(msg_fd_out, &w_fds))
+-			msg2genr_flush(NORMAL_FLUSH);
 -
  		if (io_filesfrom_f_out >= 0) {
  			if (io_filesfrom_buflen) {
  				if (FD_ISSET(io_filesfrom_f_out, &w_fds)) {
-@@ -859,6 +810,8 @@ static void readfd(int fd, char *buffer,
+@@ -851,6 +793,8 @@ static void readfd(int fd, char *buffer,
  	}
  
  	if (fd == write_batch_monitor_in) {
 +		if (am_generator())
 +		    rprintf(FINFO, "writing %d bytes to batch file from generator\n", total);
  		if ((size_t)write(batch_fd, buffer, total) != total)
  			exit_cleanup(RERR_FILEIO);
  	}
-@@ -1119,7 +1072,6 @@ static void writefd_unbuffered(int fd,ch
+@@ -1112,7 +1056,6 @@ static void writefd_unbuffered(int fd,ch
  			 * to grab any messages they sent before they died. */
  			while (fd == sock_f_out && io_multiplexing_in) {
  				set_io_timeout(30);
 -				ignore_timeout = 0;
  				readfd_unbuffered(sock_f_in, io_filesfrom_buf,
  						  sizeof io_filesfrom_buf);
  			}
-@@ -1129,7 +1081,7 @@ static void writefd_unbuffered(int fd,ch
- 		total += cnt;
+@@ -1123,7 +1066,7 @@ static void writefd_unbuffered(int fd,ch
+ 		defer_forwarding_messages = 1;
  
  		if (fd == sock_f_out) {
 -			if (io_timeout || am_generator)
 +			if (io_timeout || am_generator())
  				last_io_out = time(NULL);
  			sleep_for_bwlimit(cnt);
  		}
-@@ -1153,7 +1105,7 @@ static void mplex_write(enum msgcode cod
- 	 * cause output to occur down the socket.  Setting contiguous_write_len
- 	 * prevents the reading of msg_fd_in once we actually start to write
- 	 * this sequence of data (though we might read it before the start). */
--	if (am_generator && msg_fd_in >= 0)
-+	if (am_generator() && msg_fd_in >= 0)
- 		contiguous_write_len = len + 4;
- 
- 	if (n > sizeof buffer - 4)
-@@ -1169,31 +1121,29 @@ static void mplex_write(enum msgcode cod
- 	if (len)
- 		writefd_unbuffered(sock_f_out, buf, len);
+@@ -1133,23 +1076,6 @@ static void writefd_unbuffered(int fd,ch
+ 	no_flush--;
+ }
  
--	if (am_generator && msg_fd_in >= 0)
-+	if (am_generator() && msg_fd_in >= 0)
- 		contiguous_write_len = 0;
+-static void msg2sndr_flush(void)
+-{
+-	if (defer_forwarding_messages)
+-		return;
+-
+-	while (msg2sndr.head && io_multiplexing_out) {
+-		struct msg_list_item *m = msg2sndr.head;
+-		if (!(msg2sndr.head = m->next))
+-			msg2sndr.tail = NULL;
+-		stats.total_written += m->len;
+-		defer_forwarding_messages = 1;
+-		writefd_unbuffered(sock_f_out, m->buf, m->len);
+-		defer_forwarding_messages = 0;
+-		free(m);
+-	}
+-}
+-
+ /**
+  * Write an message to a multiplexed stream. If this fails then rsync
+  * exits.
+@@ -1175,14 +1101,15 @@ static void mplex_write(enum msgcode cod
+ 		defer_forwarding_messages = 1;
+ 		writefd_unbuffered(sock_f_out, buf, len);
+ 		defer_forwarding_messages = 0;
+-		msg2sndr_flush();
++		if (am_generator())
++			msg_list_flush();
+ 	}
  }
  
  void io_flush(int flush_it_all)
  {
--	msg_list_flush(flush_it_all);
--
--	if (!iobuf_out_cnt || no_flush)
-+	if (no_flush)
- 		return;
- 
--	if (io_multiplexing_out)
--		mplex_write(MSG_DATA, iobuf_out, iobuf_out_cnt);
--	else
--		writefd_unbuffered(sock_f_out, iobuf_out, iobuf_out_cnt);
--	iobuf_out_cnt = 0;
-+	if (iobuf_out_cnt) {
-+		if (io_multiplexing_out)
-+			mplex_write(MSG_DATA, iobuf_out, iobuf_out_cnt);
-+		else
-+			writefd_unbuffered(sock_f_out, iobuf_out, iobuf_out_cnt);
-+		iobuf_out_cnt = 0;
-+	}
-+
+-	msg2genr_flush(flush_it_all);
+-	msg2sndr_flush();
 +	if (am_generator())
-+		msg_list_flush(flush_it_all);
- }
++		msg_list_flush();
+ 
+ 	if (!iobuf_out_cnt || no_flush)
+ 		return;
+@@ -1196,11 +1123,6 @@ void io_flush(int flush_it_all)
  
  static void writefd(int fd,char *buf,size_t len)
  {
 -	if (fd == msg_fd_out) {
 -		rprintf(FERROR, "Internal error: wrong write used in receiver.\n");
 -		exit_cleanup(RERR_PROTOCOL);
 -	}
 -
  	if (fd == sock_f_out)
  		stats.total_written += len;
  
-@@ -1406,9 +1356,3 @@ void start_write_batch(int fd)
+@@ -1406,9 +1328,3 @@ void start_write_batch(int fd)
  	else
  		write_batch_monitor_in = fd;
  }
 -
 -void stop_write_batch(void)
 -{
@@ -1007,29 +1030,29 @@
 +			if (buf && recv_progress)
  				show_progress(last_match, buf->file_size);
  			sum_update(map_ptr(buf, last_match, len), len);
  			last_match = s->flength;
 --- old/options.c
 +++ new/options.c
-@@ -74,7 +74,6 @@ int def_compress_level = Z_DEFAULT_COMPR
+@@ -72,7 +72,6 @@ int def_compress_level = Z_DEFAULT_COMPR
  int am_root = 0;
  int am_server = 0;
  int am_sender = 0;
 -int am_generator = 0;
  int am_starting_up = 1;
  int relative_paths = -1;
  int implied_dirs = 1;
-@@ -95,6 +94,7 @@ int am_daemon = 0;
+@@ -93,6 +92,7 @@ int am_daemon = 0;
  int daemon_over_rsh = 0;
  int do_stats = 0;
  int do_progress = 0;
 +int recv_progress = 0;
  int keep_partial = 0;
  int safe_symlinks = 0;
  int copy_unsafe_links = 0;
-@@ -1301,6 +1301,7 @@ int parse_arguments(int *argc, const cha
+@@ -1298,6 +1298,7 @@ int parse_arguments(int *argc, const cha
  
  	if (do_progress && !verbose && !log_before_transfer && !am_server)
  		verbose = 1;
 +	recv_progress = do_progress;
  
  	if (dry_run)
@@ -1190,24 +1213,24 @@
  		return am_server ? "server" : "client";
 -	return am_sender ? "sender" : am_generator ? "generator" : "receiver";
 +	return am_sender ? "sender" : am_generator() ? "generator" : "receiver";
  }
 --- old/rsync.h
 +++ new/rsync.h
-@@ -166,10 +166,8 @@ enum msgcode {
+@@ -168,10 +168,8 @@ enum msgcode {
  	MSG_DATA=0,	/* raw data on the multiplexed stream */
  	MSG_ERROR=FERROR, MSG_INFO=FINFO, /* remote logging */
  	MSG_LOG=FLOG, MSG_SOCKERR=FSOCKERR, /* sibling logging */
 -	MSG_REDO=9,	/* reprocess indicated flist index */
  	MSG_SUCCESS=100,/* successfully updated indicated flist index */
  	MSG_DELETED=101,/* successfully deleted a file on receiving side */
 -	MSG_DONE=86	/* current phase is done */
  };
  
  #include "errcode.h"
-@@ -320,6 +318,7 @@ enum msgcode {
+@@ -322,6 +320,7 @@ enum msgcode {
  #endif
  
  #include <assert.h>
 +#include <pthread.h>
  
  #include "lib/pool_alloc.h"
@@ -1278,30 +1301,30 @@
 +void push_redo_num(int ndx);
 +int get_redo_num(void);
 +void push_hlink_num(int ndx);
  int get_hlink_num(void);
  void io_set_filesfrom_fds(int f_in, int f_out);
  int read_filesfrom_line(int fd, char *fname);
-@@ -140,7 +141,6 @@ int io_multiplex_write(enum msgcode code
+@@ -139,7 +140,6 @@ int io_multiplex_write(enum msgcode code
  void close_multiplexing_in(void);
  void close_multiplexing_out(void);
  void start_write_batch(int fd);
 -void stop_write_batch(void);
  char *lp_bind_address(void);
  char *lp_log_file(void);
  char *lp_motd_file(void);
-@@ -199,6 +199,8 @@ void maybe_log_item(struct file_struct *
+@@ -198,6 +198,8 @@ void maybe_log_item(struct file_struct *
  		    char *buf);
  void log_delete(char *fname, int mode);
  void log_exit(int code, const char *file, int line);
 +int am_generator();
 +int am_receiver();
  pid_t wait_process(pid_t pid, int *status_ptr, int flags);
  int child_main(int argc, char *argv[]);
  void start_server(int f_in, int f_out, int argc, char *argv[]);
-@@ -287,8 +289,6 @@ int copy_file(const char *source, const 
+@@ -286,8 +288,6 @@ int copy_file(const char *source, const 
  int robust_unlink(const char *fname);
  int robust_rename(char *from, char *to, char *partialptr,
  		  int mode);
 -pid_t do_fork(void);
 -void kill_all(int sig);
  int name_to_uid(char *name, uid_t *uid);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/time-limit.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/time-limit.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/time-limit.diff	2006-03-12 02:48:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/time-limit.diff	2006-04-23 00:11:57.000000000 +0800
@@ -10,13 +10,13 @@
  extern char *filesfrom_host;
  extern struct stats stats;
 +extern time_t stop_at_utime;
  extern struct file_list *the_file_list;
  
  const char phase_unknown[] = "unknown";
-@@ -169,16 +170,24 @@ static void check_timeout(void)
+@@ -153,16 +154,24 @@ static void check_timeout(void)
  {
  	time_t t;
  
 +	if ((!io_timeout || ignore_timeout) && !stop_at_utime)
 +		return;
 +
@@ -40,48 +40,48 @@
 -
  	if (t - last_io_in >= io_timeout) {
  		if (!am_server && !am_daemon) {
  			rprintf(FERROR, "io timeout after %d seconds -- exiting\n",
 --- old/options.c
 +++ new/options.c
-@@ -116,6 +116,7 @@ int checksum_seed = 0;
+@@ -114,6 +114,7 @@ int checksum_seed = 0;
  int inplace = 0;
  int delay_updates = 0;
  long block_size = 0; /* "long" because popt can't set an int32. */
 +time_t stop_at_utime = 0;
  
  
  /** Network address family. **/
-@@ -365,6 +366,8 @@ void usage(enum logcode F)
+@@ -363,6 +364,8 @@ void usage(enum logcode F)
    rprintf(F,"     --password-file=FILE    read password from FILE\n");
    rprintf(F,"     --list-only             list the files instead of copying them\n");
    rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
 +  rprintf(F,"     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute\n");
 +  rprintf(F,"     --time-limit=MINS       Stop rsync after MINS minutes have elapsed\n");
    rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
    rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
    rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
-@@ -385,7 +388,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
+@@ -383,7 +386,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
        OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
        OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
        OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
 -      OPT_NO_D,
 +      OPT_NO_D, OPT_STOP_AT, OPT_TIME_LIMIT,
        OPT_SERVER, OPT_REFUSED_BASE = 9000};
  
  static struct poptOption long_options[] = {
-@@ -497,6 +500,8 @@ static struct poptOption long_options[] 
+@@ -495,6 +498,8 @@ static struct poptOption long_options[] 
    {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
    {"itemize-changes", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },
    {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
 +  {"stop-at",          0,  POPT_ARG_STRING, 0, OPT_STOP_AT, 0, 0 },
 +  {"time-limit",       0,  POPT_ARG_STRING, 0, OPT_TIME_LIMIT, 0, 0 },
    {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
    {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
    {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
-@@ -1068,6 +1073,36 @@ int parse_arguments(int *argc, const cha
+@@ -1066,6 +1071,36 @@ int parse_arguments(int *argc, const cha
  			usage(FINFO);
  			exit_cleanup(0);
  
 +		case OPT_STOP_AT:
 +			arg = poptGetOptArg(pc);
 +			if ((stop_at_utime = parse_time(arg)) == (time_t)-1) {
@@ -112,13 +112,13 @@
 +			stop_at_utime += time(NULL);
 +			break;
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1622,6 +1657,15 @@ void server_options(char **args,int *arg
+@@ -1619,6 +1654,15 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
  
 +	if (stop_at_utime) {
 +		long mins = (stop_at_utime - time(NULL)) / 60;
 +		if (mins <= 0)
@@ -139,13 +139,13 @@
       --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
 +     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute
 +     --time-limit=MINS       Stop rsync after MINS minutes have elapsed
       --write-batch=FILE      write a batched update to FILE
       --only-write-batch=FILE like --write-batch but w/o updating dest
       --read-batch=FILE       read a batched update from FILE
-@@ -1678,6 +1680,19 @@ transfer was too fast, it will wait befo
+@@ -1685,6 +1687,19 @@ transfer was too fast, it will wait befo
  result is an average transfer rate equaling the specified limit. A value
  of zero specifies no limit.
  
 +dit(bf(--stop-at=y-m-dTh:m)) This option allows you to specify at what
 +time to stop rsync, in year-month-dayThour:minute numeric format (e.g.
 +2004-12-31T23:59).  You can specify a 2 or 4-digit year.  You can also
@@ -297,13 +297,13 @@
 +
  int set_modtime(char *fname, time_t modtime, mode_t mode)
  {
  #if !defined HAVE_LUTIMES || !defined HAVE_UTIMES
 --- old/proto.h
 +++ new/proto.h
-@@ -279,6 +279,7 @@ int fd_pair(int fd[2]);
+@@ -278,6 +278,7 @@ int fd_pair(int fd[2]);
  void print_child_argv(char **cmd);
  void out_of_memory(char *str);
  void overflow_exit(char *str);
 +time_t parse_time(const char *arg);
  int set_modtime(char *fname, time_t modtime, mode_t mode);
  int mkdir_defmode(char *fname);
@@ -316,13 +316,13 @@
       --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
 +     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute
 +     --time-limit=MINS       Stop rsync after MINS minutes have elapsed
       --write-batch=FILE      write a batched update to FILE
       --only-write-batch=FILE like --write-batch but w/o updating dest
       --read-batch=FILE       read a batched update from FILE
-@@ -1921,6 +1923,21 @@ transfer was too fast, it will wait befo
+@@ -1930,6 +1932,21 @@ transfer was too fast, it will wait befo
  result is an average transfer rate equaling the specified limit\&. A value
  of zero specifies no limit\&.
  .IP 
 +.IP "\fB--stop-at=y-m-dTh:m\fP" 
 +This option allows you to specify at what
 +time to stop rsync, in year-month-dayThour:minute numeric format (e\&.g\&.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/verify-patches /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/verify-patches
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/verify-patches	2006-02-28 08:38:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/verify-patches	2006-03-15 09:59:45.000000000 +0800
@@ -28,12 +28,13 @@
     die <<EOT;
 Please run this script from the root of the rsync dir or
 from inside the patches subdir.
 EOT
 }
 
+$ENV{'LC_COLLATE'} = 'C';
 $| = 1;
 my $CONF_OPTS = '-C';
 
 my($has_dependencies, @new, @rejects);
 
 END {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/xattrs.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/xattrs.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/xattrs.diff	2006-03-12 02:48:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/patches/xattrs.diff	2006-04-23 00:12:16.000000000 +0800
@@ -23,45 +23,56 @@
 +	fileio.o batch.o clientname.o chmod.o acls.o xattr.o
  OBJS3=progress.o pipe.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 --- old/backup.c
 +++ new/backup.c
-@@ -135,6 +135,9 @@ static int make_bak_dir(char *fullpath)
- #ifdef SUPPORT_ACLS
- 				dup_acl(end, fullpath, st.st_mode);
+@@ -29,6 +29,7 @@ extern char *backup_dir;
+ 
+ extern int am_root;
+ extern int preserve_acls;
++extern int preserve_xattrs;
+ extern int preserve_devices;
+ extern int preserve_specials;
+ extern int preserve_links;
+@@ -137,6 +138,10 @@ static int make_bak_dir(char *fullpath)
+ 				if (preserve_acls)
+ 					dup_acl(end, fullpath, st.st_mode);
  #endif
 +#ifdef SUPPORT_XATTRS
-+				dup_xattr(end, fullpath );
++				if (preserve_xattrs)
++					dup_xattr(end, fullpath );
 +#endif
  			}
  		}
  		*p = '/';
-@@ -191,6 +194,9 @@ static int keep_backup(char *fname)
- #ifdef SUPPORT_ACLS
- 	push_keep_backup_acl(file, fname, buf);
+@@ -194,6 +199,10 @@ static int keep_backup(char *fname)
+ 	if (preserve_acls)
+ 		push_keep_backup_acl(file, fname, buf);
  #endif
 +#ifdef SUPPORT_XATTRS
-+	push_keep_backup_xattr(file, fname, buf);
++	if (preserve_xattrs)
++		push_keep_backup_xattr(file, fname, buf);
 +#endif
  
  	/* Check to see if this is a device file, or link */
  	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
-@@ -270,6 +276,9 @@ static int keep_backup(char *fname)
- #ifdef SUPPORT_ACLS
- 	cleanup_keep_backup_acl();
+@@ -274,6 +283,10 @@ static int keep_backup(char *fname)
+ 	if (preserve_acls)
+ 		cleanup_keep_backup_acl();
  #endif
 +#ifdef SUPPORT_XATTRS
-+	cleanup_keep_backup_xattr();
++	if (preserve_xattrs)
++		cleanup_keep_backup_xattr();
 +#endif
  	free(file);
  
  	if (verbose > 1) {
 --- old/configure.in
 +++ new/configure.in
-@@ -814,6 +814,30 @@ samba_cv_HAVE_ACL_GET_PERM_NP=yes,samba_
+@@ -823,6 +823,30 @@ samba_cv_HAVE_ACL_GET_PERM_NP=yes,samba_
    AC_MSG_RESULT(no)
  )
  
 +AC_CHECK_HEADERS(attr/xattr.h)
 +AC_MSG_CHECKING(whether to support extended attributes)
 +AC_ARG_ENABLE(xattr-support,
@@ -88,58 +99,70 @@
 +
  AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
  AC_OUTPUT
  
 --- old/flist.c
 +++ new/flist.c
-@@ -970,6 +970,10 @@ static struct file_struct *send_file_nam
- 	if (make_acl(file, fname) < 0)
+@@ -45,6 +45,7 @@ extern int one_file_system;
+ extern int copy_dirlinks;
+ extern int keep_dirlinks;
+ extern int preserve_acls;
++extern int preserve_xattrs;
+ extern int preserve_links;
+ extern int preserve_hard_links;
+ extern int preserve_devices;
+@@ -970,6 +971,10 @@ static struct file_struct *send_file_nam
+ 	if (preserve_acls && make_acl(file, fname) < 0)
  		return NULL;
  #endif
 +#ifdef SUPPORT_XATTRS
-+	if (make_xattr(file, fname) < 0)
++	if (preserve_xattrs && make_xattr(file, fname) < 0)
 +		return NULL;
 +#endif
  
- 	if (chmod_modes && !S_ISLNK(file->mode))
- 		file->mode = tweak_mode(file->mode, chmod_modes);
-@@ -983,10 +987,18 @@ static struct file_struct *send_file_nam
- 		send_file_entry(file, f);
- #ifdef SUPPORT_ACLS
- 		send_acl(file, f);
-+#endif
+ 	maybe_emit_filelist_progress(flist->count + flist_count_offset);
+ 
+@@ -982,12 +987,20 @@ static struct file_struct *send_file_nam
+ 		if (preserve_acls)
+ 			send_acl(file, f);
+ #endif
 +#ifdef SUPPORT_XATTRS
-+		send_xattr(file, f);
++		if (preserve_xattrs)
++			send_xattr(file, f);
 +#endif
  	} else {
-+#ifdef SUPPORT_ACLS
+ #ifdef SUPPORT_ACLS
  		/* Cleanup unsent ACL(s). */
- 		send_acl(file, -1);
+ 		if (preserve_acls)
+ 			send_acl(file, -1);
  #endif
 +#ifdef SUPPORT_XATTRS
-+		send_xattr(file, -1);
++		if (preserve_xattrs)
++			send_xattr(file, -1);
 +#endif
  	}
  	return file;
  }
-@@ -1378,6 +1390,9 @@ struct file_list *recv_file_list(int f)
- #ifdef SUPPORT_ACLS
- 		receive_acl(file, f);
+@@ -1380,6 +1393,10 @@ struct file_list *recv_file_list(int f)
+ 		if (preserve_acls)
+ 			receive_acl(file, f);
  #endif
 +#ifdef SUPPORT_XATTRS
-+		receive_xattr(file, f );
++		if (preserve_xattrs)
++			receive_xattr(file, f );
 +#endif
  
  		if (S_ISREG(file->mode) || S_ISLNK(file->mode))
  			stats.total_size += file->length;
-@@ -1404,6 +1419,9 @@ struct file_list *recv_file_list(int f)
- #ifdef SUPPORT_ACLS
- 	sort_file_acl_index_lists();
+@@ -1407,6 +1424,10 @@ struct file_list *recv_file_list(int f)
+ 	if (preserve_acls)
+ 		sort_file_acl_index_lists();
  #endif
 +#ifdef SUPPORT_XATTRS
-+	sort_file_xattr_index_lists();
++	if (preserve_xattrs)
++		sort_file_xattr_index_lists();
 +#endif
  
  	if (f >= 0) {
  		recv_uid_list(f, flist);
 --- old/lib/sysxattr.c
 +++ new/lib/sysxattr.c
@@ -204,64 +227,64 @@
  int preserve_hard_links = 0;
  int preserve_acls = 0;
 +int preserve_xattrs = 0;
  int preserve_perms = 0;
  int preserve_executability = 0;
  int preserve_devices = 0;
-@@ -196,6 +197,7 @@ static void print_rsync_version(enum log
+@@ -194,6 +195,7 @@ static void print_rsync_version(enum log
  	char const *have_inplace = "no ";
  	char const *hardlinks = "no ";
  	char const *acls = "no ";
 +	char const *xattrs = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
  	STRUCT_STAT *dumstat;
-@@ -215,7 +217,9 @@ static void print_rsync_version(enum log
+@@ -213,7 +215,9 @@ static void print_rsync_version(enum log
  #ifdef SUPPORT_ACLS
  	acls = "";
  #endif
 -
 +#ifdef SUPPORT_XATTRS
 +	xattrs = "";
 +#endif
  #ifdef SUPPORT_LINKS
  	links = "";
  #endif
-@@ -229,9 +233,9 @@ static void print_rsync_version(enum log
+@@ -227,9 +231,9 @@ static void print_rsync_version(enum log
  	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
  	rprintf(f, "<http://rsync.samba.org/>\n");
  	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
 -		"%shard links, %sACLs, %ssymlinks, batchfiles,\n",
 +		"%shard links, %sACLs, %sxattrs, %ssymlinks, batchfiles,\n",
  		(int) (sizeof (OFF_T) * 8),
 -		got_socketpair, hardlinks, acls, links);
 +		got_socketpair, hardlinks, acls, xattrs, links);
  
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
-@@ -304,6 +308,9 @@ void usage(enum logcode F)
+@@ -302,6 +306,9 @@ void usage(enum logcode F)
  #ifdef SUPPORT_ACLS
    rprintf(F," -A, --acls                  preserve ACLs (implies --perms)\n");
  #endif
 +#ifdef SUPPORT_XATTRS
 +  rprintf(F," -X, --xattrs                preserve extended attributes (implies --perms)\n");
 +#endif
    rprintf(F,"     --chmod=CHMOD           change destination permissions\n");
    rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
    rprintf(F," -g, --group                 preserve group\n");
-@@ -422,6 +429,9 @@ static struct poptOption long_options[] 
+@@ -420,6 +427,9 @@ static struct poptOption long_options[] 
    {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
    {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
    {"no-A",             0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
 +  {"xattrs",          'X', POPT_ARG_NONE,   0, 'X', 0, 0 },
 +  {"no-xattrs",        0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
 +  {"no-X",             0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
    {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
    {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
    {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
-@@ -1096,6 +1106,17 @@ int parse_arguments(int *argc, const cha
+@@ -1095,6 +1105,17 @@ int parse_arguments(int *argc, const cha
  			return 0;
  #endif
  
 +		case 'X':
 +#ifdef SUPPORT_XATTRS
 +			preserve_xattrs = 1;
@@ -273,39 +296,47 @@
 +				 am_server ? "server" : "client");
 +			return 0;
 +#endif /* SUPPORT_XATTRS */
  
  		default:
  			/* A large opt value means that set_refuse_options()
-@@ -1544,6 +1565,10 @@ void server_options(char **args,int *arg
+@@ -1542,6 +1563,10 @@ void server_options(char **args,int *arg
  	if (preserve_acls)
  		argstr[x++] = 'A';
  #endif
 +#ifdef SUPPORT_XATTRS
 +	if (preserve_xattrs)
 +		argstr[x++] = 'X';
 +#endif
  	if (preserve_uid)
  		argstr[x++] = 'o';
  	if (preserve_gid)
 --- old/rsync.c
 +++ new/rsync.c
-@@ -224,6 +224,10 @@ int set_file_attrs(char *fname, struct f
- 	if (set_acl(fname, file) == 0)
+@@ -34,6 +34,7 @@ extern int verbose;
+ extern int dry_run;
+ extern int daemon_log_format_has_i;
+ extern int preserve_acls;
++extern int preserve_xattrs;
+ extern int preserve_perms;
+ extern int preserve_executability;
+ extern int preserve_times;
+@@ -215,6 +216,10 @@ int set_file_attrs(char *fname, struct f
+ 	if (preserve_acls && set_acl(fname, file, &st->st_mode) == 0)
  		updated = 1;
  #endif
 +#ifdef SUPPORT_XATTRS
-+	if (set_xattr(fname, file) == 0)
++	if (preserve_xattrs && set_xattr(fname, file) == 0)
 +		updated = 1;
 +#endif
  
- 	if (verbose > 1 && flags & ATTRS_REPORT) {
- 		enum logcode code = daemon_log_format_has_i || dry_run
+ #ifdef HAVE_CHMOD
+ 	if ((st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS)) {
 --- old/rsync.h
 +++ new/rsync.h
-@@ -672,6 +672,14 @@ struct chmod_mode_struct;
+@@ -674,6 +674,14 @@ struct chmod_mode_struct;
  #endif
  #include "smb_acls.h"
  
 +#ifdef HAVE_LINUX_XATTRS
 +#define SUPPORT_XATTRS 1
 +#endif
@@ -324,27 +355,27 @@
   -E, --executability         preserve executability
   -A, --acls                  preserve ACLs (implies -p) [non-standard]
 + -X, --xattrs                preserve extended attrs (implies -p) [n.s.]
       --chmod=CHMOD           change destination permissions
   -o, --owner                 preserve owner (super-user only)
   -g, --group                 preserve group
-@@ -802,6 +803,11 @@ dit(bf(-A, --acls)) This option causes r
- ACLs to be the same as the source ACLs.  This nonstandard option only
- works if the remote rsync also supports it.  bf(--acls) implies bf(--perms).
+@@ -807,6 +808,11 @@ version makes it incompatible with sendi
+ rsync unless you double the bf(--acls) option (e.g. bf(-AA)).  This
+ doubling is not needed when pulling files from an older rsync.
  
 +dit(bf(-X, --xattrs)) This option causes rsync to update the remote
 +extended attributes to be the same as the local ones.  This will work
 +only if the remote machine's rsync supports this option also. This is
 +a non-standard option.
 +
  dit(bf(--chmod)) This option tells rsync to apply one or more
  comma-separated "chmod" strings to the permission of the files in the
  transfer.  The resulting value is treated as though it was the permissions
 --- old/xattr.c
 +++ new/xattr.c
-@@ -0,0 +1,540 @@
+@@ -0,0 +1,523 @@
 +/* Extended Attribute support for rsync */
 +/* Copyright (C) 2004 Red Hat, Inc */
 +/* Written by Jay Fenlason, vaguely based on the ACLs patch */
 +
 +/* This program is free software; you can redistribute it and/or modify
 +   it under the terms of the GNU General Public License as published by
@@ -363,13 +394,12 @@
 +
 +#include "rsync.h"
 +#include "lib/sysxattr.h"
 +
 +#ifdef SUPPORT_XATTRS
 +
-+extern int preserve_xattrs;
 +extern int dry_run;
 +
 +#define RSYNC_XAL_INITIAL 5
 +#define RSYNC_XAL_LIST_INITIAL 100
 +
 +typedef struct {
@@ -573,17 +603,14 @@
 +}
 +
 +
 +/* generate the xattr(s) for this flist entry;
 + * xattr(s) are either sent or cleaned-up by send_xattr() below */
 +
-+int make_xattr(const struct file_struct *file, const char *fname)
++int make_xattr(UNUSED(const struct file_struct *file), const char *fname)
 +{
-+	if (!preserve_xattrs || !file)
-+		return 1;
-+
 +	rsync_xal_get(fname, &curr_rsync_xal);
 +	return 0; /* TODO:  This needs to return 1 if no xattrs changed! */
 +}
 +
 +static ssize_t rsync_xal_find_matching(void)
 +{
@@ -631,19 +658,16 @@
 +	curr_rsync_xal.alloc = 0;
 +}
 +
 +/* send the make_xattr()-generated xattr list for this flist entry,
 + * or clean up after an flist entry that's not being sent (f == -1) */
 +
-+void send_xattr(const struct file_struct *file, int f)
++void send_xattr(UNUSED(const struct file_struct *file), int f)
 +{
 +	ssize_t index;
 +
-+	if (!preserve_xattrs || !file)
-+		return;
-+
 +	if (f == -1) {
 +		rsync_xal_free(&curr_rsync_xal);
 +		return;
 +	}
 +	index = rsync_xal_find_matching();
 +	if (index != -1) {
@@ -673,14 +697,12 @@
 +
 +void receive_xattr(struct file_struct *file, int f)
 +{
 +	char *fname;
 +	int tag;
 +
-+	if (!preserve_xattrs)
-+		return;
 +	fname = f_name(file, NULL);
 +	tag = read_byte(f);
 +	if (tag != 'X' && tag != 'x') {
 +		rprintf(FERROR,
 +		    "%s: receive_xattr: unknown extended attribute type tag: %c\n",
 +		    fname, tag);
@@ -725,12 +747,14 @@
 +			size_t name_len;
 +			size_t datum_len;
 +			char *ptr;
 +
 +			name_len = read_int(f);
 +			datum_len = read_int(f);
++			if (name_len + datum_len < name_len)
++				out_of_memory("receive_xattr"); /* overflow */
 +			ptr = new_array(char, name_len + datum_len);
 +			if (!ptr)
 +				out_of_memory("receive_xattr");
 +			read_buf(f, ptr, name_len);
 +			read_buf(f, ptr + name_len, datum_len);
 +			curr_rsync_xal.rxas[i].name_len = name_len;
@@ -772,46 +796,36 @@
 +/* for duplicating xattrs on backups when using backup_dir */
 +
 +int dup_xattr(const char *orig, const char *bak)
 +{
 +	int ret;
 +
-+	if (!preserve_xattrs)
-+		return 1;
-+
 +	if (rsync_xal_get(orig, &backup_xal) < 0)
 +		ret = rsync_xal_set(bak, &backup_xal);
 +	else
 +		ret = 0;
 +	rsync_xal_free(&backup_xal);
++
 +	return ret;
 +}
 +
 +void push_keep_backup_xattr(const struct file_struct *file, const char *orig, const char *dest)
 +{
-+	if (!preserve_xattrs)
-+		return;
-+
 +	backup_orig_file = file;
 +	backup_orig_fname = orig;
 +	backup_dest_fname = dest;
 +	rsync_xal_get(orig, &backup_xal);
 +}
 +
 +static int set_keep_backup_xal(void)
 +{
-+	if (!preserve_xattrs)
-+		return 1;
 +	return rsync_xal_set(backup_dest_fname, &backup_xal);
 +}
 +
 +void cleanup_keep_backup_xattr(void)
 +{
-+	if (!preserve_xattrs)
-+		return;
-+
 +	backup_orig_file = NULL;
 +	backup_orig_fname = null_string;
 +	backup_dest_fname = null_string;
 +	rsync_xal_free(&backup_xal);
 +}
 +
@@ -824,14 +838,12 @@
 +	xa2 = x2;
 +	return xa1->file == xa2->file ? 0 : xa1->file < xa2->file ? -1 : 1;
 +}
 +
 +void sort_file_xattr_index_lists(void)
 +{
-+	if (!preserve_xattrs)
-+		return;
 +	qsort(fxil.filexalidxs, fxil.count, sizeof (file_xal_index), file_xal_index_compare);
 +}
 +
 +static int find_file_xal_index(const struct file_struct *file)
 +{
 +	int low = 0, high = fxil.count;
@@ -867,32 +879,34 @@
 +
 +int set_xattr(const char *fname, const struct file_struct *file)
 +{
 +	int xalidx;
 +	rsync_xal *x;
 +
-+	if (dry_run || !preserve_xattrs)
-+		return 1;
++	if (dry_run)
++		return 1; /* FIXME: --dry-run needs to compute this value */
++
 +	if (file == backup_orig_file) {
 +		if (!strcmp(fname, backup_dest_fname))
 +			return set_keep_backup_xal();
 +	}
 +	xalidx = find_file_xal_index(file);
 +	x = &(rsync_xal_l.rxals[xalidx]);
++
 +	return rsync_xal_set(fname, x);
 +}
 +
 +#endif /* SUPPORT_XATTRS */
 --- old/proto.h
 +++ new/proto.h
-@@ -335,4 +335,12 @@ void bitbag_set_bit(struct bitbag *bb, i
+@@ -332,4 +332,12 @@ void bitbag_set_bit(struct bitbag *bb, i
  void bitbag_clear_bit(struct bitbag *bb, int ndx);
  int bitbag_check_bit(struct bitbag *bb, int ndx);
  int bitbag_next_bit(struct bitbag *bb, int after);
-+int make_xattr(const struct file_struct *file, const char *fname);
-+void send_xattr(const struct file_struct *file, int f);
++int make_xattr(UNUSED(const struct file_struct *file), const char *fname);
++void send_xattr(UNUSED(const struct file_struct *file), int f);
 +void receive_xattr(struct file_struct *file, int f);
 +int dup_xattr(const char *orig, const char *bak);
 +void push_keep_backup_xattr(const struct file_struct *file, const char *orig, const char *dest);
 +void cleanup_keep_backup_xattr(void);
 +void sort_file_xattr_index_lists(void);
 +int set_xattr(const char *fname, const struct file_struct *file);
@@ -904,13 +918,13 @@
    --disable-locale        turn off locale features
    --enable-acl-support    Include ACL support (default=no)
 +  --enable-xattr-support  Include extended attribute support (default=no)
  
  Optional Packages:
    --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-@@ -12830,6 +12831,198 @@ echo "${ECHO_T}no" >&6
+@@ -12840,6 +12841,198 @@ echo "${ECHO_T}no" >&6
  
  fi;
  
 +
 +for ac_header in attr/xattr.h
 +do
@@ -1105,43 +1119,43 @@
 +
                                                    ac_config_files="$ac_config_files Makefile lib/dummy zlib/dummy popt/dummy shconfig"
  
  cat >confcache <<\_ACEOF
 --- old/config.h.in
 +++ new/config.h.in
-@@ -46,6 +46,9 @@
+@@ -52,6 +52,9 @@
  /* Define to 1 if you have the `asprintf' function. */
  #undef HAVE_ASPRINTF
  
 +/* Define to 1 if you have the <attr/xattr.h> header file. */
 +#undef HAVE_ATTR_XATTR_H
 +
  /* Define to 1 if readdir() is broken */
  #undef HAVE_BROKEN_READDIR
  
-@@ -185,6 +188,9 @@
+@@ -191,6 +194,9 @@
  /* Define to 1 if you have the `link' function. */
  #undef HAVE_LINK
  
 +/* True if you have Linux xattrs */
 +#undef HAVE_LINUX_XATTRS
 +
  /* Define to 1 if you have the `locale_charset' function. */
  #undef HAVE_LOCALE_CHARSET
  
-@@ -228,6 +234,9 @@
+@@ -234,6 +240,9 @@
  /* Define to 1 if you have the `mtrace' function. */
  #undef HAVE_MTRACE
  
 +/* True if you don't have extended attributes */
 +#undef HAVE_NA_XATTRS
 +
  /* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
  #undef HAVE_NDIR_H
  
-@@ -240,6 +249,9 @@
+@@ -246,6 +255,9 @@
  /* true if you don't have ACLs */
  #undef HAVE_NO_ACLS
  
 +/* True if you don't have extended attributes */
 +#undef HAVE_NO_XATTRL
 +
@@ -1155,15 +1169,15 @@
   -E, --executability         preserve executability
   -A, --acls                  preserve ACLs (implies -p) [non-standard]
 + -X, --xattrs                preserve extended attrs (implies -p) [n\&.s\&.]
       --chmod=CHMOD           change destination permissions
   -o, --owner                 preserve owner (super-user only)
   -g, --group                 preserve group
-@@ -913,6 +914,12 @@ This option causes rsync to update the d
- ACLs to be the same as the source ACLs\&.  This nonstandard option only
- works if the remote rsync also supports it\&.  \fB--acls\fP implies \fB--perms\fP\&.
+@@ -918,6 +919,12 @@ version makes it incompatible with sendi
+ rsync unless you double the \fB--acls\fP option (e\&.g\&. \fB-AA\fP)\&.  This
+ doubling is not needed when pulling files from an older rsync\&.
  .IP 
 +.IP "\fB-X, --xattrs\fP" 
 +This option causes rsync to update the remote
 +extended attributes to be the same as the local ones\&.  This will work
 +only if the remote machine\&'s rsync supports this option also\&. This is
 +a non-standard option\&.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/prepare-source /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/prepare-source
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/prepare-source	2006-02-15 00:44:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/prepare-source	2006-04-18 02:15:02.000000000 +0800
@@ -3,11 +3,10 @@
 # in the release.  This is typically used after applying a diff from
 # "patches" directory in CVS.
 #
 # NOTE:  if you use a diff from the "patches" directory in a release
 # tar, this is not needed (but doesn't hurt anything).
 dir=`dirname $0`
-if test x"$dir" = x -o x"$dir" = x.; then
-    make -f prepare-source.mak
-else
-    make -C "$dir" -f prepare-source.mak
+if test x"$dir" != x -o x"$dir" != x.; then
+    cd "$dir"
 fi
+make -f prepare-source.mak
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/proto.h	2006-03-12 02:25:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/proto.h	2006-04-22 23:38:34.000000000 +0800
@@ -123,13 +123,12 @@
 int read_vstring(int f, char *buf, int bufsize);
 void read_sum_head(int f, struct sum_struct *sum);
 void write_sum_head(int f, struct sum_struct *sum);
 void io_flush(int flush_it_all);
 void write_shortint(int f, int x);
 void write_int(int f,int32 x);
-void write_int_named(int f, int32 x, const char *phase);
 void write_longint(int f, int64 x);
 void write_buf(int f,char *buf,size_t len);
 void write_sbuf(int f, char *buf);
 void write_byte(int f, uchar c);
 void write_vstring(int f, char *str, int len);
 int read_line(int f, char *buf, size_t maxlen);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.1	2006-03-12 02:25:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsync.1	2006-04-22 23:38:37.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsync" "1" "11 Mar 2006" "" "" 
+.TH "rsync" "1" "22 Apr 2006" "" "" 
 .SH "NAME" 
 rsync \- faster, flexible replacement for rcp
 .SH "SYNOPSIS" 
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. DEST
 .PP 
@@ -296,13 +296,13 @@
 .SH "STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS" 
 .PP 
 In order to connect to an rsync daemon, the remote system needs to have a
 daemon already running (or it needs to have configured something like inetd
 to spawn an rsync daemon for incoming connections on a particular port)\&.
 For full information on how to start a daemon that will handling incoming
-socket connections, see the rsyncd\&.conf(5) man page -- that is the config
+socket connections, see the \fBrsyncd\&.conf\fP(5) man page -- that is the config
 file for the daemon, and it contains the full details for how to run the
 daemon (including stand-alone and inetd configurations)\&.
 .PP 
 If you\&'re using one of the remote-shell transports for the transfer, there is
 no need to manually start an rsync daemon\&.
 .PP 
@@ -924,27 +924,34 @@
 .IP 
 See the \fB--perms\fP and \fB--executability\fP options for how the resulting
 permission value can be applied to the files in the transfer\&.
 .IP 
 .IP "\fB-o, --owner\fP" 
 This option causes rsync to set the owner of the
-destination file to be the same as the source file\&.  By default, the
-preservation is done by name, but may fall back to using the ID number
-in some circumstances (see the \fB--numeric-ids\fP option for a full
-discussion)\&.
-This option has no effect if the receiving rsync is not run as the
-super-user and \fB--super\fP is not specified\&.
+destination file to be the same as the source file, but only if the
+receiving rsync is being run as the super-user (see also the \fB--super\fP
+option to force rsync to attempt super-user activities)\&.
+Without this option, the owner is set to the invoking user on the
+receiving side\&.
+.IP 
+The preservation of ownership will associate matching names by default, but
+may fall back to using the ID number in some circumstances (see also the
+\fB--numeric-ids\fP option for a full discussion)\&.
 .IP 
 .IP "\fB-g, --group\fP" 
 This option causes rsync to set the group of the
 destination file to be the same as the source file\&.  If the receiving
-program is not running as the super-user (or with the \fB--no-super\fP
-option), only groups that the
-receiver is a member of will be preserved\&.  By default, the preservation
-is done by name, but may fall back to using the ID number in some
-circumstances\&.  See the \fB--numeric-ids\fP option for a full discussion\&.
+program is not running as the super-user (or if \fB--no-super\fP was
+specified), only groups that the invoking user on the receiving side
+is a member of will be preserved\&.
+Without this option, the group is set to the default group of the invoking
+user on the receiving side\&.
+.IP 
+The preservation of group information will associate matching names by
+default, but may fall back to using the ID number in some circumstances
+(see also the \fB--numeric-ids\fP option for a full discussion)\&.
 .IP 
 .IP "\fB--devices\fP" 
 This option causes rsync to transfer character and
 block device files to the remote system to recreate these devices\&.
 This option has no effect if the receiving rsync is not run as the
 super-user and \fB--super\fP is not specified\&.
@@ -1225,13 +1232,13 @@
 files listed in the CVSIGNORE environment variable (all cvsignore names
 are delimited by whitespace)\&.
 .IP 
 Finally, any file is ignored if it is in the same directory as a
 \&.cvsignore file and matches one of the patterns listed therein\&.  Unlike
 rsync\&'s filter/exclude files, these patterns are split on whitespace\&.
-See the \fBcvs(1)\fP manual for more information\&.
+See the \fBcvs\fP(1) manual for more information\&.
 .IP 
 If you\&'re combining \fB-C\fP with your own \fB--filter\fP rules, you should
 note that these CVS excludes are appended at the end of your own rules,
 regardless of where the \fB-C\fP was placed on the command-line\&.  This makes them
 a lower priority than any rules you specified explicitly\&.  If you want to
 control where these CVS excludes get inserted into your filter rules, you
@@ -1526,13 +1533,13 @@
 option in the \fB--daemon\fP mode section\&.
 .IP 
 .IP "\fB--sockopts\fP" 
 This option can provide endless fun for people
 who like to tune their systems to the utmost degree\&. You can set all
 sorts of socket options which may make transfers faster (or
-slower!)\&. Read the man page for the setsockopt() system call for
+slower!)\&. Read the man page for the \f(CWsetsockopt()\fP system call for
 details on some of the options you may be able to set\&. By default no
 special socket options are set\&. This only affects direct socket
 connections to a remote rsync daemon\&.  This option also exists in the
 \fB--daemon\fP mode section\&.
 .IP 
 .IP "\fB--blocking-io\fP" 
@@ -1651,12 +1658,13 @@
 .IP "\fB--stats\fP" 
 This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data\&.
 .IP 
 The current statistics are as follows: 
+.RS 
 .IP o 
 \fBNumber of files\fP is the count of all "files" (in the generic
 sense), which includes directories, symlinks, etc\&.
 .IP o 
 \fBNumber of files transferred\fP is the count of normal files that
 were updated via the rsync algorithm, which does not include created
@@ -1691,12 +1699,13 @@
 from the client side to the server side\&.
 .IP o 
 \fBTotal bytes received\fP is the count of all non-message bytes that
 rsync received by the client side from the server side\&.  "Non-message"
 bytes means that we don\&'t count the bytes for a verbose message that the
 server sent to us, which makes the stats more consistent\&.
+.RE 
 .IP 
 .IP "\fB-8, --8-bit-output\fP" 
 This tells rsync to leave all high-bit characters
 unescaped in the output instead of trying to test them to see if they\&'re
 valid in the current locale and escaping the invalid ones\&.  All control
 characters (but never tabs) are always escaped, regardless of this option\&'s
@@ -1966,17 +1975,17 @@
 rsync daemon\&.  See also these options in the \fB--daemon\fP mode section\&.
 .IP 
 .IP "\fB--checksum-seed=NUM\fP" 
 Set the MD4 checksum seed to the integer
 NUM\&.  This 4 byte checksum seed is included in each block and file
 MD4 checksum calculation\&.  By default the checksum seed is generated
-by the server and defaults to the current time()\&.  This option
+by the server and defaults to the current \f(CWtime()\fP\&.  This option
 is used to set a specific checksum seed, which is useful for
 applications that want repeatable block and file checksums, or
 in the case where the user wants a more random checksum seed\&.
-Note that setting NUM to 0 causes rsync to use the default of time()
+Note that setting NUM to 0 causes rsync to use the default of \f(CWtime()\fP
 for checksum seed\&.
 .PP 
 .SH "DAEMON OPTIONS" 
 .PP 
 The options allowed when starting an rsync daemon are as follows:
 .PP 
@@ -1986,13 +1995,13 @@
 the \fBhost::module\fP or \fBrsync://host/module/\fP syntax\&.
 .IP 
 If standard input is a socket then rsync will assume that it is being
 run via inetd, otherwise it will detach from the current terminal and
 become a background daemon\&.  The daemon will read the config file
 (rsyncd\&.conf) on each connect made by a client and respond to
-requests accordingly\&.  See the rsyncd\&.conf(5) man page for more
+requests accordingly\&.  See the \fBrsyncd\&.conf\fP(5) man page for more
 details\&.
 .IP 
 .IP "\fB--address\fP" 
 By default rsync will bind to the wildcard address when
 run as a daemon with the \fB--daemon\fP option\&.  The \fB--address\fP option
 allows you to specify a specific IP address (or hostname) to bind to\&.  This
@@ -2145,13 +2154,12 @@
 named "sub"\&.  See the section on ANCHORING INCLUDE/EXCLUDE PATTERNS for
 a full discussion of how to specify a pattern that matches at the root
 of the transfer\&.
 .IP o 
 if the pattern ends with a / then it will only match a
 directory, not a file, link, or device\&.
-.IP 
 .IP o 
 rsync chooses between doing a simple string match and wildcard
 matching by checking if the pattern contains one of these three wildcard
 characters: \&'*\&', \&'?\&', and \&'[\&' \&.
 .IP o 
 a \&'*\&' matches any non-empty path component (it stops at slashes)\&.
@@ -2608,13 +2616,14 @@
 using the information stored in the batch file\&.
 .PP 
 For convenience, one additional file is creating when the write-batch
 option is used\&.  This file\&'s name is created by appending
 "\&.sh" to the batch filename\&.  The \&.sh file contains
 a command-line suitable for updating a destination tree using that
-batch file\&. It can be executed using a Bourne(-like) shell, optionally
+batch file\&. It can be executed using a Bourne (or Bourne-like) shell,
+optionally
 passing in an alternate destination tree pathname which is then used
 instead of the original path\&. This is useful when the destination tree
 path differs from the original destination tree path\&.
 .PP 
 Generating the batch file once saves having to perform the file
 status, checksum, and data block generation more than once when
@@ -2811,13 +2820,13 @@
 Errors with program diagnostics
 .IP "\fB14\fP" 
 Error in IPC code
 .IP "\fB20\fP" 
 Received SIGUSR1 or SIGINT
 .IP "\fB21\fP" 
-Some error returned by waitpid()
+Some error returned by \f(CWwaitpid()\fP
 .IP "\fB22\fP" 
 Error allocating core memory buffers
 .IP "\fB23\fP" 
 Partial transfer due to error
 .IP "\fB24\fP" 
 Partial transfer due to vanished source files
@@ -2856,13 +2865,13 @@
 .SH "FILES" 
 .PP 
 /etc/rsyncd\&.conf or rsyncd\&.conf
 .PP 
 .SH "SEE ALSO" 
 .PP 
-rsyncd\&.conf(5)
+\fBrsyncd\&.conf\fP(5)
 .PP 
 .SH "BUGS" 
 .PP 
 times are transferred as *nix time_t values
 .PP 
 When transferring to FAT filesystems rsync may re-sync
@@ -2876,13 +2885,13 @@
 .PP 
 Please report bugs! See the website at
 http://rsync\&.samba\&.org/
 .PP 
 .SH "VERSION" 
 .PP 
-This man page is current for version 2\&.6\&.7 of rsync\&.
+This man page is current for version 2\&.6\&.8 of rsync\&.
 .PP 
 .SH "CREDITS" 
 .PP 
 rsync is distributed under the GNU public license\&.  See the file
 COPYING for details\&.
 .PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsyncd.conf.5	2006-03-12 02:25:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsyncd.conf.5	2006-04-22 23:38:38.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsyncd\&.conf" "5" "11 Mar 2006" "" "" 
+.TH "rsyncd\&.conf" "5" "22 Apr 2006" "" "" 
 .SH "NAME" 
 rsyncd\&.conf \- configuration file for rsync in daemon mode
 .SH "SYNOPSIS" 
 .PP 
 rsyncd\&.conf
 .PP 
@@ -96,13 +96,13 @@
 usually contains site information and any legal notices\&. The default
 is no motd file\&.
 .IP 
 .IP "\fBlog file\fP" 
 The "log file" option tells the rsync daemon to log
 messages to that file rather than using syslog\&. This is particularly
-useful on systems (such as AIX) where syslog() doesn\&'t work for
+useful on systems (such as AIX) where \f(CWsyslog()\fP doesn\&'t work for
 chrooted programs\&.  If the daemon fails to open to specified file, it
 will fall back to using syslog and output an error about the failure\&.
 (Note that a failure to open the specified log file used to be a fatal
 error\&.)
 .IP 
 .IP "\fBpid file\fP" 
@@ -129,13 +129,13 @@
 being run by inetd, and is superseded by the \fB--address\fP command-line option\&.
 .IP 
 .IP "\fBsocket options\fP" 
 This option can provide endless fun for people
 who like to tune their systems to the utmost degree\&. You can set all
 sorts of socket options which may make transfers faster (or
-slower!)\&. Read the man page for the setsockopt() system call for
+slower!)\&. Read the man page for the \f(CWsetsockopt()\fP system call for
 details on some of the options you may be able to set\&. By default no
 special socket options are set\&.  These settings are superseded by the
 \fB--sockopts\fP command-line option\&.
 .IP 
 .PP 
 .SH "MODULE OPTIONS" 
@@ -169,13 +169,13 @@
 such as \fB--backup-dir\fP, \fB--compare-dest\fP, etc\&. interpret an absolute path as
 rooted in the module\&'s "path" dir, just as if chroot was specified)\&.
 The default for "use chroot" is true\&.
 .IP 
 In order to preserve usernames and groupnames, rsync needs to be able to
 use the standard library functions for looking up names and IDs (i\&.e\&.
-getpwuid(), getgrgid(), getpwname(), and getgrnam())\&.  This means a
+\f(CWgetpwuid()\fP, \f(CWgetgrgid()\fP, \f(CWgetpwname()\fP, and \f(CWgetgrnam()\fP)\&.  This means a
 process in the chroot namespace will need to have access to the resources
 used by these library functions (traditionally /etc/passwd and
 /etc/group)\&.  If these resources are not available, rsync will only be
 able to copy the IDs, just as if the \fB--numeric-ids\fP option had been
 specified\&.
 .IP 
@@ -325,13 +325,13 @@
 authentication protocol is used for this exchange\&. The plain text
 usernames and passwords are stored in the file specified by the
 "secrets file" option\&. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync")\&.
 .IP 
 See also the "CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL
-PROGRAM" section in rsync(1) for information on how handle an
+PROGRAM" section in \fBrsync\fP(1) for information on how handle an
 rsyncd\&.conf-level username that differs from the remote-shell-level
 username when using a remote shell to connect to an rsync daemon\&.
 .IP 
 .IP "\fBsecrets file\fP" 
 The "secrets file" option specifies the name of
 a file that contains the username:password pairs used for
@@ -578,13 +578,13 @@
 value contains a single period\&.
 .IP o 
 \fBRSYNC_EXIT_STATUS\fP: (post-xfer only) rsync\&'s exit value\&.  This will be 0 for a
 successful run, a positive value for an error that rsync returned
 (e\&.g\&. 23=partial xfer), or a -1 if rsync failed to exit properly\&.
 .IP o 
-\fBRSYNC_RAW_STATUS\fP: (post-xfer only) the raw exit value from waitpid()\&.
+\fBRSYNC_RAW_STATUS\fP: (post-xfer only) the raw exit value from \f(CWwaitpid()\fP\&.
 .RE 
 .IP 
 Even though the commands can be associated with a particular module, they
 are run using the permissions of the user that started the daemon (not the
 module\&'s uid/gid setting) without any chroot restrictions\&.
 .IP 
@@ -685,13 +685,13 @@
 .PP 
 Please report bugs! The rsync bug tracking system is online at
 http://rsync\&.samba\&.org/
 .PP 
 .SH "VERSION" 
 .PP 
-This man page is current for version 2\&.6\&.7 of rsync\&.
+This man page is current for version 2\&.6\&.8 of rsync\&.
 .PP 
 .SH "CREDITS" 
 .PP 
 rsync is distributed under the GNU public license\&.  See the file
 COPYING for details\&.
 .PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsyncd.conf.yo	2006-03-12 02:25:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsyncd.conf.yo	2006-04-22 23:38:34.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(11 Mar 2006)()()
+manpage(rsyncd.conf)(5)(22 Apr 2006)()()
 manpagename(rsyncd.conf)(configuration file for rsync in daemon mode)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -83,13 +83,13 @@
 "message of the day" to display to clients on each connect. This
 usually contains site information and any legal notices. The default
 is no motd file.
 
 dit(bf(log file)) The "log file" option tells the rsync daemon to log
 messages to that file rather than using syslog. This is particularly
-useful on systems (such as AIX) where syslog() doesn't work for
+useful on systems (such as AIX) where code(syslog()) doesn't work for
 chrooted programs.  If the daemon fails to open to specified file, it
 will fall back to using syslog and output an error about the failure.
 (Note that a failure to open the specified log file used to be a fatal
 error.)
 
 dit(bf(pid file)) The "pid file" option tells the rsync daemon to write
@@ -111,13 +111,13 @@
 will listen on by specifying this value.  This is ignored if the daemon is
 being run by inetd, and is superseded by the bf(--address) command-line option.
 
 dit(bf(socket options)) This option can provide endless fun for people
 who like to tune their systems to the utmost degree. You can set all
 sorts of socket options which may make transfers faster (or
-slower!). Read the man page for the setsockopt() system call for
+slower!). Read the man page for the code(setsockopt()) system call for
 details on some of the options you may be able to set. By default no
 special socket options are set.  These settings are superseded by the
 bf(--sockopts) command-line option.
 
 enddit()
 
@@ -151,13 +151,13 @@
 such as bf(--backup-dir), bf(--compare-dest), etc. interpret an absolute path as
 rooted in the module's "path" dir, just as if chroot was specified).
 The default for "use chroot" is true.
 
 In order to preserve usernames and groupnames, rsync needs to be able to
 use the standard library functions for looking up names and IDs (i.e.
-getpwuid(), getgrgid(), getpwname(), and getgrnam()).  This means a
+code(getpwuid()), code(getgrgid()), code(getpwname()), and code(getgrnam())).  This means a
 process in the chroot namespace will need to have access to the resources
 used by these library functions (traditionally /etc/passwd and
 /etc/group).  If these resources are not available, rsync will only be
 able to copy the IDs, just as if the bf(--numeric-ids) option had been
 specified.
 
@@ -291,13 +291,13 @@
 authentication protocol is used for this exchange. The plain text
 usernames and passwords are stored in the file specified by the
 "secrets file" option. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync").
 
 See also the "CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL
-PROGRAM" section in rsync(1) for information on how handle an
+PROGRAM" section in bf(rsync)(1) for information on how handle an
 rsyncd.conf-level username that differs from the remote-shell-level
 username when using a remote shell to connect to an rsync daemon.
 
 dit(bf(secrets file)) The "secrets file" option specifies the name of
 a file that contains the username:password pairs used for
 authenticating this module. This file is only consulted if the "auth
@@ -494,13 +494,13 @@
   it() bf(RSYNC_ARG#): (pre-xfer only) The pre-request arguments are set
   in these numbered values. RSYNC_ARG0 is always "rsyncd", and the last
   value contains a single period.
   it() bf(RSYNC_EXIT_STATUS): (post-xfer only) rsync's exit value.  This will be 0 for a
   successful run, a positive value for an error that rsync returned
   (e.g. 23=partial xfer), or a -1 if rsync failed to exit properly.
-  it() bf(RSYNC_RAW_STATUS): (post-xfer only) the raw exit value from waitpid().
+  it() bf(RSYNC_RAW_STATUS): (post-xfer only) the raw exit value from code(waitpid()).
 ))
 
 Even though the commands can be associated with a particular module, they
 are run using the permissions of the user that started the daemon (not the
 module's uid/gid setting) without any chroot restrictions.
 
@@ -588,13 +588,13 @@
 
 Please report bugs! The rsync bug tracking system is online at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 2.6.7 of rsync.
+This man page is current for version 2.6.8 of rsync.
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.h	2006-02-28 05:11:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsync.h	2006-04-14 00:53:15.000000000 +0800
@@ -132,19 +132,21 @@
 #define FNAMECMP_FNAME		0x80
 #define FNAMECMP_PARTIAL_DIR	0x81
 #define FNAMECMP_BACKUP 	0x82
 #define FNAMECMP_FUZZY		0x83
 
 /* For use by the itemize_changes code */
+#define ITEM_REPORT_ATIME (1<<0)
 #define ITEM_REPORT_CHECKSUM (1<<1)
 #define ITEM_REPORT_SIZE (1<<2)
 #define ITEM_REPORT_TIME (1<<3)
 #define ITEM_REPORT_PERMS (1<<4)
 #define ITEM_REPORT_OWNER (1<<5)
 #define ITEM_REPORT_GROUP (1<<6)
-#define ITEM_REPORT_XATTRS (1<<7)
+#define ITEM_REPORT_ACL (1<<7)
+#define ITEM_REPORT_XATTR (1<<8)
 #define ITEM_BASIS_TYPE_FOLLOWS (1<<11)
 #define ITEM_XNAME_FOLLOWS (1<<12)
 #define ITEM_IS_NEW (1<<13)
 #define ITEM_LOCAL_CHANGE (1<<14)
 #define ITEM_TRANSFER (1<<15)
 /* These are outside the range of the transmitted flags. */
@@ -827,16 +829,12 @@
 /* This is just like rprintf, but it also tries to print some
  * representation of the error code.  Normally errcode = errno. */
 void rsyserr(enum logcode, int, const char *, ...)
      __attribute__((format (printf, 3, 4)))
      ;
 
-#ifdef REPLACE_INET_NTOA
-#define inet_ntoa rep_inet_ntoa
-#endif
-
 /* Make sure that the O_BINARY flag is defined. */
 #ifndef O_BINARY
 #define O_BINARY 0
 #endif
 
 #ifndef HAVE_STRLCPY
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.yo	2006-03-12 02:25:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/rsync.yo	2006-04-22 23:38:34.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(11 Mar 2006)()()
+manpage(rsync)(1)(22 Apr 2006)()()
 manpagename(rsync)(faster, flexible replacement for rcp)
 manpagesynopsis()
 
 rsync [OPTION]... SRC [SRC]... DEST
 
 rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
@@ -251,13 +251,13 @@
 manpagesection(STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS)
 
 In order to connect to an rsync daemon, the remote system needs to have a
 daemon already running (or it needs to have configured something like inetd
 to spawn an rsync daemon for incoming connections on a particular port).
 For full information on how to start a daemon that will handling incoming
-socket connections, see the rsyncd.conf(5) man page -- that is the config
+socket connections, see the bf(rsyncd.conf)(5) man page -- that is the config
 file for the daemon, and it contains the full details for how to run the
 daemon (including stand-alone and inetd configurations).
 
 If you're using one of the remote-shell transports for the transfer, there is
 no need to manually start an rsync daemon.
 
@@ -810,26 +810,33 @@
 additional option is just appended to the list of changes to make.
 
 See the bf(--perms) and bf(--executability) options for how the resulting
 permission value can be applied to the files in the transfer.
 
 dit(bf(-o, --owner)) This option causes rsync to set the owner of the
-destination file to be the same as the source file.  By default, the
-preservation is done by name, but may fall back to using the ID number
-in some circumstances (see the bf(--numeric-ids) option for a full
-discussion).
-This option has no effect if the receiving rsync is not run as the
-super-user and bf(--super) is not specified.
+destination file to be the same as the source file, but only if the
+receiving rsync is being run as the super-user (see also the bf(--super)
+option to force rsync to attempt super-user activities).
+Without this option, the owner is set to the invoking user on the
+receiving side.
+
+The preservation of ownership will associate matching names by default, but
+may fall back to using the ID number in some circumstances (see also the
+bf(--numeric-ids) option for a full discussion).
 
 dit(bf(-g, --group)) This option causes rsync to set the group of the
 destination file to be the same as the source file.  If the receiving
-program is not running as the super-user (or with the bf(--no-super)
-option), only groups that the
-receiver is a member of will be preserved.  By default, the preservation
-is done by name, but may fall back to using the ID number in some
-circumstances.  See the bf(--numeric-ids) option for a full discussion.
+program is not running as the super-user (or if bf(--no-super) was
+specified), only groups that the invoking user on the receiving side
+is a member of will be preserved.
+Without this option, the group is set to the default group of the invoking
+user on the receiving side.
+
+The preservation of group information will associate matching names by
+default, but may fall back to using the ID number in some circumstances
+(see also the bf(--numeric-ids) option for a full discussion).
 
 dit(bf(--devices)) This option causes rsync to transfer character and
 block device files to the remote system to recreate these devices.
 This option has no effect if the receiving rsync is not run as the
 super-user and bf(--super) is not specified.
 
@@ -1075,13 +1082,13 @@
 files listed in the CVSIGNORE environment variable (all cvsignore names
 are delimited by whitespace).
 
 Finally, any file is ignored if it is in the same directory as a
 .cvsignore file and matches one of the patterns listed therein.  Unlike
 rsync's filter/exclude files, these patterns are split on whitespace.
-See the bf(cvs(1)) manual for more information.
+See the bf(cvs)(1) manual for more information.
 
 If you're combining bf(-C) with your own bf(--filter) rules, you should
 note that these CVS excludes are appended at the end of your own rules,
 regardless of where the bf(-C) was placed on the command-line.  This makes them
 a lower priority than any rules you specified explicitly.  If you want to
 control where these CVS excludes get inserted into your filter rules, you
@@ -1342,13 +1349,13 @@
 syntax has a way to specify the port as a part of the URL).  See also this
 option in the bf(--daemon) mode section.
 
 dit(bf(--sockopts)) This option can provide endless fun for people
 who like to tune their systems to the utmost degree. You can set all
 sorts of socket options which may make transfers faster (or
-slower!). Read the man page for the setsockopt() system call for
+slower!). Read the man page for the code(setsockopt()) system call for
 details on some of the options you may be able to set. By default no
 special socket options are set. This only affects direct socket
 connections to a remote rsync daemon.  This option also exists in the
 bf(--daemon) mode section.
 
 dit(bf(--blocking-io)) This tells rsync to use blocking I/O when launching
@@ -1450,13 +1457,13 @@
 (followed, of course, by the log-format output).
 
 dit(bf(--stats)) This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data.
 
-The current statistics are as follows: itemize(
+The current statistics are as follows: quote(itemize(
   it() bf(Number of files) is the count of all "files" (in the generic
   sense), which includes directories, symlinks, etc.
   it() bf(Number of files transferred) is the count of normal files that
   were updated via the rsync algorithm, which does not include created
   dirs, symlinks, etc.
   it() bf(Total file size) is the total sum of all file sizes in the transfer.
@@ -1480,13 +1487,13 @@
   it() bf(Total bytes sent) is the count of all the bytes that rsync sent
   from the client side to the server side.
   it() bf(Total bytes received) is the count of all non-message bytes that
   rsync received by the client side from the server side.  "Non-message"
   bytes means that we don't count the bytes for a verbose message that the
   server sent to us, which makes the stats more consistent.
-)
+))
 
 dit(bf(-8, --8-bit-output)) This tells rsync to leave all high-bit characters
 unescaped in the output instead of trying to test them to see if they're
 valid in the current locale and escaping the invalid ones.  All control
 characters (but never tabs) are always escaped, regardless of this option's
 setting.
@@ -1717,17 +1724,17 @@
 control over, such as the outgoing socket when directly contacting an
 rsync daemon.  See also these options in the bf(--daemon) mode section.
 
 dit(bf(--checksum-seed=NUM)) Set the MD4 checksum seed to the integer
 NUM.  This 4 byte checksum seed is included in each block and file
 MD4 checksum calculation.  By default the checksum seed is generated
-by the server and defaults to the current time().  This option
+by the server and defaults to the current code(time()).  This option
 is used to set a specific checksum seed, which is useful for
 applications that want repeatable block and file checksums, or
 in the case where the user wants a more random checksum seed.
-Note that setting NUM to 0 causes rsync to use the default of time()
+Note that setting NUM to 0 causes rsync to use the default of code(time())
 for checksum seed.
 enddit()
 
 manpagesection(DAEMON OPTIONS)
 
 The options allowed when starting an rsync daemon are as follows:
@@ -1738,13 +1745,13 @@
 the bf(host::module) or bf(rsync://host/module/) syntax.
 
 If standard input is a socket then rsync will assume that it is being
 run via inetd, otherwise it will detach from the current terminal and
 become a background daemon.  The daemon will read the config file
 (rsyncd.conf) on each connect made by a client and respond to
-requests accordingly.  See the rsyncd.conf(5) man page for more
+requests accordingly.  See the bf(rsyncd.conf)(5) man page for more
 details.
 
 dit(bf(--address)) By default rsync will bind to the wildcard address when
 run as a daemon with the bf(--daemon) option.  The bf(--address) option
 allows you to specify a specific IP address (or hostname) to bind to.  This
 makes virtual hosting possible in conjunction with the bf(--config) option.
@@ -2255,13 +2261,14 @@
 using the information stored in the batch file.
 
 For convenience, one additional file is creating when the write-batch
 option is used.  This file's name is created by appending
 ".sh" to the batch filename.  The .sh file contains
 a command-line suitable for updating a destination tree using that
-batch file. It can be executed using a Bourne(-like) shell, optionally
+batch file. It can be executed using a Bourne (or Bourne-like) shell,
+optionally
 passing in an alternate destination tree pathname which is then used
 instead of the original path. This is useful when the destination tree
 path differs from the original destination tree path.
 
 Generating the batch file once saves having to perform the file
 status, checksum, and data block generation more than once when
@@ -2432,13 +2439,13 @@
 dit(bf(10)) Error in socket I/O
 dit(bf(11)) Error in file I/O
 dit(bf(12)) Error in rsync protocol data stream
 dit(bf(13)) Errors with program diagnostics
 dit(bf(14)) Error in IPC code
 dit(bf(20)) Received SIGUSR1 or SIGINT
-dit(bf(21)) Some error returned by waitpid()
+dit(bf(21)) Some error returned by code(waitpid())
 dit(bf(22)) Error allocating core memory buffers
 dit(bf(23)) Partial transfer due to error
 dit(bf(24)) Partial transfer due to vanished source files
 dit(bf(25)) The --max-delete limit stopped deletions
 dit(bf(30)) Timeout in data send/receive
 enddit()
@@ -2469,13 +2476,13 @@
 manpagefiles()
 
 /etc/rsyncd.conf or rsyncd.conf
 
 manpageseealso()
 
-rsyncd.conf(5)
+bf(rsyncd.conf)(5)
 
 manpagebugs()
 
 times are transferred as *nix time_t values
 
 When transferring to FAT filesystems rsync may re-sync
@@ -2489,13 +2496,13 @@
 
 Please report bugs! See the website at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 2.6.7 of rsync.
+This man page is current for version 2.6.8 of rsync.
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/runtests.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/runtests.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/runtests.sh	2006-02-05 03:44:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/runtests.sh	2006-03-17 05:37:18.000000000 +0800
@@ -160,17 +160,19 @@
 if [ "x$preserve_scratch" = xyes ]; then
     echo "    preserve_scratch=yes"
 else
     echo "    preserve_scratch=no"
 fi    
 
-# We'll use setfacl if it's around and it supports the -k option.
+# Check if setfacl is around and if it supports the -k or -s option.
 if setfacl --help 2>/dev/null | grep ' -k,' >/dev/null; then
-    setfacl=setfacl
+    setfacl_nodef='setfacl -k'
+elif setfacl -s u::7,g::5,o:5 testsuite 2>/dev/null; then
+    setfacl_nodef='setfacl -s u::7,g::5,o:5'
 else
-    setfacl=true
+    setfacl_nodef=true
 fi
 
 if [ ! -f "$rsync_bin" ]; then
     echo "rsync_bin $rsync_bin is not a file" >&2
     exit 2
 fi
@@ -180,13 +182,13 @@
     exit 2
 fi
 
 RSYNC="$rsync_bin"
 #RSYNC="valgrind --tool=addrcheck $rsync_bin"
 
-export rsync_bin RSYNC
+export rsync_bin RSYNC setfacl_nodef
 
 skipped=0
 missing=0
 passed=0
 failed=0
 
@@ -201,13 +203,13 @@
 export scratchdir suitedir
 
 prep_scratch() {
     [ -d "$scratchdir" ] && rm -rf "$scratchdir"
     mkdir "$scratchdir"
     # Get rid of default ACLs and dir-setgid to avoid confusing some tests.
-    $setfacl -k "$scratchdir"
+    $setfacl_nodef "$scratchdir"
     chmod g-s "$scratchdir"
     return 0
 }
 
 maybe_discard_scratch() {
     [ x"$preserve_scratch" != xyes ] && [ -d "$scratchdir" ] && rm -rf "$scratchdir"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/socket.c	2006-03-07 16:46:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/socket.c	2006-04-11 08:48:28.000000000 +0800
@@ -29,12 +29,14 @@
  * interface, which supports IPv6 but is also supported on recent
  * IPv4-only machines.  On systems that don't have that interface, we
  * emulate it using the KAME implementation.
  **/
 
 #include "rsync.h"
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
 
 extern char *bind_address;
 extern int default_af_hint;
 
 #ifdef HAVE_SIGACTION
 static struct sigaction sigact;
@@ -330,15 +332,15 @@
  * default.
  **/
 static int *open_socket_in(int type, int port, const char *bind_addr,
 			   int af_hint)
 {
 	int one = 1;
-	int s, *socks, maxs, i;
+	int s, *socks, maxs, i, ecnt;
 	struct addrinfo hints, *all_ai, *resp;
-	char portbuf[10];
+	char portbuf[10], **errmsgs;
 	int error;
 
 	memset(&hints, 0, sizeof hints);
 	hints.ai_family = af_hint;
 	hints.ai_socktype = type;
 	hints.ai_flags = AI_PASSIVE;
@@ -350,23 +352,31 @@
 		return NULL;
 	}
 
 	/* Count max number of sockets we might open. */
 	for (maxs = 0, resp = all_ai; resp; resp = resp->ai_next, maxs++) {}
 
-	if (!(socks = new_array(int, maxs + 1)))
+	socks = new_array(int, maxs + 1);
+	errmsgs = new_array(char *, maxs);
+	if (!socks || !errmsgs)
 		out_of_memory("open_socket_in");
 
 	/* We may not be able to create the socket, if for example the
 	 * machine knows about IPv6 in the C library, but not in the
 	 * kernel. */
-	for (resp = all_ai, i = 0; resp; resp = resp->ai_next) {
+	for (resp = all_ai, i = ecnt = 0; resp; resp = resp->ai_next) {
 		s = socket(resp->ai_family, resp->ai_socktype,
 			   resp->ai_protocol);
 
 		if (s == -1) {
+			int r = asprintf(&errmsgs[ecnt++],
+				"socket(%d,%d,%d) failed: %s\n",
+				(int)resp->ai_family, (int)resp->ai_socktype,
+				(int)resp->ai_protocol, strerror(errno));
+			if (r < 0)
+				out_of_memory("open_socket_in");
 			/* See if there's another address that will work... */
 			continue;
 		}
 
 		setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
 			   (char *)&one, sizeof one);
@@ -382,23 +392,37 @@
 		}
 #endif
 
 		/* Now we've got a socket - we need to bind it. */
 		if (bind(s, resp->ai_addr, resp->ai_addrlen) < 0) {
 			/* Nope, try another */
+			int r = asprintf(&errmsgs[ecnt++],
+				"bind() failed: %s (address-family %d)\n",
+				strerror(errno), (int)resp->ai_family);
+			if (r < 0)
+				out_of_memory("open_socket_in");
 			close(s);
 			continue;
 		}
 
 		socks[i++] = s;
 	}
 	socks[i] = -1;
 
 	if (all_ai)
 		freeaddrinfo(all_ai);
 
+	/* Only output the socket()/bind() messages if we were totally
+	 * unsuccessful, or if the daemon is being run with -vv. */
+	for (s = 0; s < ecnt; s++) {
+		if (!i || verbose > 1)
+			rwrite(FLOG, errmsgs[s], strlen(errmsgs[s]));
+		free(errmsgs[s]);
+	}
+	free(errmsgs);
+
 	if (!i) {
 		rprintf(FERROR,
 			"unable to bind any inbound sockets on port %d\n",
 			port);
 		free(socks);
 		return NULL;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/support: file-attr-restore
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/support/rsyncstats /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/support/rsyncstats
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/support/rsyncstats	2006-02-02 18:20:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/support/rsyncstats	2006-03-14 00:45:24.000000000 +0800
@@ -49,15 +49,28 @@
     print "Transfer Totals include the '$only_section' section only.\n";
     print "All other sections are filtered out for this report.\n\n";
 }
 
 line: while (<LOG>) {
 
+my $syslog_prefix = '\w\w\w +\d+ \d\d:\d\d:\d\d \S+ rsyncd';
+my $rsyncd_prefix = '\d\d\d\d/\d\d/\d\d \d\d:\d\d:\d\d ';
+
    next unless ($day,$time,$op,$host,$module,$file,$bytes)
-      = m#^ (\d+/\d\d/\d\d)\s+(\d\d:\d\d:\d\d)\s+\[\d+\]\s+(send|recv|[<>]f\S+)\s+
-          (\S+)\s+\[\d+\.\d+\.\d+\.\d+\]\s+(\S+)\s+\(\S*\)\s+(.*)\s+(\d+) $ #x;
+      = m{^
+	  ( \w\w\w\s+\d+ | \d+/\d\d/\d\d ) \s+ # day
+	  (\d\d:\d\d:\d\d) \s+                 # time
+	  [^[]* \[\d+\]:? \s+                  # pid (ignored)
+	  (send|recv|[<>]f\S+) \s+             # op (%o or %i)
+	  (\S+) \s+                            # host
+	  \[\d+\.\d+\.\d+\.\d+\] \s+           # IP (ignored)
+	  (\S+) \s+                            # module
+	  \(\S*\) \s+                          # user (ignored)
+	  (.*) \s+                             # file name
+	  (\d+)                                # file length in bytes
+	  $ }x;
 
    # TODO actually divide the data by into send/recv categories
    if ($op =~ /^>/) {
       $op = 'send';
    } elsif ($op =~ /^</) {
       $op = 'recv';
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/exclude.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/testsuite/exclude.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/exclude.test	2006-02-05 03:29:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.8/testsuite/exclude.test	2006-03-17 04:02:36.000000000 +0800
@@ -200,8 +200,16 @@
 $RSYNC -av --existing --filter='-! */' "$fromdir/" "$chkdir/"
 $RSYNC -av --delete-excluded --exclude='*' "$fromdir/" "$todir/"
 
 checkit "$RSYNC -avv -f dir-merge,-_.excl \
     \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
 
+relative_opts='--relative --chmod=Du+w --copy-unsafe-links'
+$RSYNC -av $relative_opts "$fromdir/foo" "$chkdir/"
+rm -rf "$chkdir$fromdir/foo/down"
+$RSYNC -av $relative_opts --existing --filter='-! */' "$fromdir/foo" "$chkdir/"
+
+checkit "$RSYNC -avv $relative_opts --exclude=\"$fromdir/foo/down\" \
+    \"$fromdir/foo\" \"$todir\"" "$chkdir$fromdir/foo" "$todir$fromdir/foo"
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
