diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/authenticate.c	2005-02-08 04:36:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/authenticate.c	2005-04-11 01:09:10.000000000 +0800
@@ -48,29 +48,32 @@
 			}
 		}
 		out[i] = b64[idx];
 	}
 }
 
-/* create a 16 byte challenge buffer */
+/* Generate a challenge buffer and return it base64-encoded. */
 static void gen_challenge(char *addr, char *challenge)
 {
 	char input[32];
+	char md4_out[MD4_SUM_LENGTH];
 	struct timeval tv;
 
 	memset(input, 0, sizeof input);
 
 	strlcpy((char *)input, addr, 17);
 	sys_gettimeofday(&tv);
 	SIVAL(input, 16, tv.tv_sec);
 	SIVAL(input, 20, tv.tv_usec);
 	SIVAL(input, 24, getpid());
 
 	sum_init(0);
 	sum_update(input, sizeof input);
-	sum_end(challenge);
+	sum_end(md4_out);
+
+	base64_encode(md4_out, MD4_SUM_LENGTH, challenge);
 }
 
 
 /* Return the secret for a user from the secret file, null terminated.
  * Maximum length is len (not counting the null). */
 static int get_secret(int module, char *user, char *secret, int len)
@@ -192,95 +195,102 @@
 			return strdup(p);
 	}
 
 	return NULL;
 }
 
-/* generate a 16 byte hash from a password and challenge */
+/* Generate an MD4 hash created from the combination of the password
+ * and the challenge string and return it base64-encoded. */
 static void generate_hash(char *in, char *challenge, char *out)
 {
-	char buf[16];
+	char buf[MD4_SUM_LENGTH];
 
 	sum_init(0);
 	sum_update(in, strlen(in));
 	sum_update(challenge, strlen(challenge));
 	sum_end(buf);
 
-	base64_encode(buf, 16, out);
+	base64_encode(buf, MD4_SUM_LENGTH, out);
 }
 
 /* Possibly negotiate authentication with the client.  Use "leader" to
  * start off the auth if necessary.
  *
  * Return NULL if authentication failed.  Return "" if anonymous access.
  * Otherwise return username.
  */
-char *auth_server(int f_in, int f_out, int module, char *addr, char *leader)
+char *auth_server(int f_in, int f_out, int module, char *host, char *addr,
+		  char *leader)
 {
 	char *users = lp_auth_users(module);
-	char challenge[16];
-	char b64_challenge[30];
+	char challenge[MD4_SUM_LENGTH*2];
 	char line[MAXPATHLEN];
-	static char user[100];
-	char secret[100];
-	char pass[30];
-	char pass2[30];
-	char *tok;
+	char secret[512];
+	char pass2[MD4_SUM_LENGTH*2];
+	char *tok, *pass;
 
 	/* if no auth list then allow anyone in! */
 	if (!users || !*users)
 		return "";
 
 	gen_challenge(addr, challenge);
 
-	base64_encode(challenge, 16, b64_challenge);
-
-	io_printf(f_out, "%s%s\n", leader, b64_challenge);
+	io_printf(f_out, "%s%s\n", leader, challenge);
 
-	if (!read_line(f_in, line, sizeof line - 1))
-		return NULL;
-
-	memset(user, 0, sizeof user);
-	memset(pass, 0, sizeof pass);
-
-	if (sscanf(line,"%99s %29s", user, pass) != 2)
+	if (!read_line(f_in, line, sizeof line - 1)
+	 || (pass = strchr(line, ' ')) == NULL) {
+		rprintf(FLOG, "auth failed on module %s from %s (%s): "
+			"invalid challenge response\n",
+			lp_name(module), host, addr);
 		return NULL;
+	}
+	*pass++ = '\0';
 
-	users = strdup(users);
-	if (!users)
-		return NULL;
+	if (!(users = strdup(users)))
+		out_of_memory("auth_server");
 
-	for (tok=strtok(users," ,\t"); tok; tok = strtok(NULL," ,\t")) {
-		if (wildmatch(tok, user))
+	for (tok = strtok(users, " ,\t"); tok; tok = strtok(NULL, " ,\t")) {
+		if (wildmatch(tok, line))
 			break;
 	}
 	free(users);
 
-	if (!tok)
+	if (!tok) {
+		rprintf(FLOG, "auth failed on module %s from %s (%s): "
+			"unauthorized user\n",
+			lp_name(module), host, addr);
 		return NULL;
+	}
 
 	memset(secret, 0, sizeof secret);
-	if (!get_secret(module, user, secret, sizeof secret - 1)) {
+	if (!get_secret(module, line, secret, sizeof secret - 1)) {
 		memset(secret, 0, sizeof secret);
+		rprintf(FLOG, "auth failed on module %s from %s (%s): "
+			"missing secret for user \"%s\"\n",
+			lp_name(module), host, addr, line);
 		return NULL;
 	}
 
-	generate_hash(secret, b64_challenge, pass2);
+	generate_hash(secret, challenge, pass2);
 	memset(secret, 0, sizeof secret);
 
-	if (strcmp(pass, pass2) == 0)
-		return user;
+	if (strcmp(pass, pass2) != 0) {
+		rprintf(FLOG, "auth failed on module %s from %s (%s): "
+			"password mismatch\n",
+			lp_name(module), host, addr);
+		return NULL;
+	}
 
-	return NULL;
+	return strdup(line);
 }
 
 
 void auth_client(int fd, char *user, char *challenge)
 {
 	char *pass;
-	char pass2[30];
+	char pass2[MD4_SUM_LENGTH*2];
 
 	if (!user || !*user)
 		user = "nobody";
 
 	if (!(pass = getpassf(password_file))
 	 && !(pass = getenv("RSYNC_PASSWORD"))) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/batch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/batch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/batch.c	2005-03-27 13:02:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/batch.c	2005-04-10 02:59:44.000000000 +0800
@@ -136,13 +136,13 @@
  * given the user's --write-batch args.  However, it doesn't really
  * understand most of the options, so it uses some overly simple
  * heuristics to munge the command line into something that will
  * (hopefully) work. */
 void write_batch_shell_file(int argc, char *argv[], int file_arg_cnt)
 {
-	int fd, i;
+	int fd, i, len;
 	char *p, filename[MAXPATHLEN];
 
 	stringjoin(filename, sizeof filename,
 		   batch_name, ".sh", NULL);
 	fd = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
 		     S_IRUSR | S_IWUSR | S_IEXEC);
@@ -172,17 +172,18 @@
 		}
 		if (strcmp(p, "-f") == 0) {
 			i++;
 			continue;
 		}
 		write(fd, " ", 1);
-		if (strncmp(p, "--write-batch", 13) == 0) {
+		if (strncmp(p, "--write-batch", len = 13) == 0
+		 || strncmp(p, "--only-write-batch", len = 18) == 0) {
 			write(fd, "--read-batch", 12);
-			if (p[13] == '=') {
+			if (p[len] == '=') {
 				write(fd, "=", 1);
-				write_arg(fd, p + 14);
+				write_arg(fd, p + len + 1);
 			}
 		} else
 			write_arg(fd, p);
 	}
 	if (!(p = check_for_hostspec(argv[argc - 1], &p, &i)))
 		p = argv[argc - 1];
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/clientserver.c	2005-03-31 08:21:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/clientserver.c	2005-05-19 16:52:19.000000000 +0800
@@ -38,13 +38,12 @@
 extern int daemon_over_rsh;
 extern int sanitize_paths;
 extern int filesfrom_fd;
 extern int remote_protocol;
 extern int protocol_version;
 extern int io_timeout;
-extern int select_timeout;
 extern int orig_umask;
 extern int no_detach;
 extern int default_af_hint;
 extern char *bind_address;
 extern struct filter_list_struct server_filter_list;
 extern char *config_file;
@@ -97,13 +96,13 @@
 				     default_af_hint);
 	if (fd == -1)
 		exit_cleanup(RERR_SOCKETIO);
 
 	ret = start_inband_exchange(user, path, fd, fd, argc);
 
-	return ret < 0? ret : client_run(fd, fd, -1, argc, argv);
+	return ret ? ret : client_run(fd, fd, -1, argc, argv);
 }
 
 int start_inband_exchange(char *user, char *path, int f_in, int f_out, 
 			  int argc)
 {
 	int i;
@@ -193,16 +192,16 @@
 		}
 
 		if (strncmp(line, "@ERROR", 6) == 0) {
 			rprintf(FERROR, "%s\n", line);
 			/* This is always fatal; the server will now
 			 * close the socket. */
-			return RERR_STARTCLIENT;
-		} else {
-			rprintf(FINFO,"%s\n", line);
+			return -1;
 		}
+
+		rprintf(FINFO, "%s\n", line);
 	}
 	kluge_around_eof = 0;
 
 	for (i = 0; i < sargc; i++) {
 		io_printf(f_out, "%s\n", sargs[i]);
 	}
@@ -265,17 +264,15 @@
 			io_printf(f_out, "@ERROR: max connections (%d) reached -- try again later\n",
 				lp_max_connections(i));
 		}
 		return -1;
 	}
 
-	auth_user = auth_server(f_in, f_out, i, addr, "@RSYNCD: AUTHREQD ");
+	auth_user = auth_server(f_in, f_out, i, host, addr, "@RSYNCD: AUTHREQD ");
 
 	if (!auth_user) {
-		rprintf(FLOG, "auth failed on module %s from %s (%s)\n",
-			name, host, addr);
 		io_printf(f_out, "@ERROR: auth failed on module %s\n", name);
 		return -1;
 	}
 
 	module_id = i;
 
@@ -318,19 +315,17 @@
 	 * that we change to some uid other than the current one, then
 	 * log a warning. */
 
 	/* TODO: Perhaps take a list of gids, and make them into the
 	 * supplementary groups. */
 
-	if (use_chroot) {
+	if (use_chroot || (module_dirlen = strlen(lp_path(i))) == 1) {
 		module_dirlen = 0;
 		set_filter_dir("/", 1);
-	} else {
-		module_dirlen = strlen(lp_path(i));
+	} else
 		set_filter_dir(lp_path(i), module_dirlen);
-	}
 
 	p = lp_filter(i);
 	parse_rule(&server_filter_list, p, MATCHFLG_WORD_SPLIT,
 		   XFLG_ANCHORED2ABS);
 
 	p = lp_include_from(i);
@@ -519,17 +514,14 @@
 	if (!ret) {
 		option_error();
 		msleep(400);
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
 
-	if (lp_timeout(i)) {
-		io_timeout = lp_timeout(i);
-		if (io_timeout < select_timeout)
-			select_timeout = io_timeout;
-	}
+	if (lp_timeout(i) && lp_timeout(i) > io_timeout)
+		set_io_timeout(lp_timeout(i));
 
 	start_server(f_in, f_out, argc, argp);
 
 	return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/config.h.in	2005-02-22 02:58:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/config.h.in	2005-05-28 00:41:32.000000000 +0800
@@ -1,11 +1,14 @@
 /* config.h.in.  Generated from configure.in by autoheader.  */
 
 /* Define to 1 if chown modifies symlinks. */
 #undef CHOWN_MODIFIES_SYMLINK
 
+/* Undefine if you don't want locale features. By default this is defined. */
+#undef CONFIG_LOCALE
+
 /* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
    systems. This function is required for `alloca.c' support on those systems.
    */
 #undef CRAY_STACKSEG_END
 
 /* Define to 1 if using `alloca.c'. */
@@ -140,16 +143,22 @@
 /* Define to 1 if you have the `socket' library (-lsocket). */
 #undef HAVE_LIBSOCKET
 
 /* Define to 1 if you have the `link' function. */
 #undef HAVE_LINK
 
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
 /* Define to 1 if long double works and has more range or precision than
    double. */
 #undef HAVE_LONG_DOUBLE
 
+/* Define to 1 if you have the `lseek64' function. */
+#undef HAVE_LSEEK64
+
 /* Define to 1 if you have the `mallinfo' function. */
 #undef HAVE_MALLINFO
 
 /* Define to 1 if you have the <malloc.h> header file. */
 #undef HAVE_MALLOC_H
 
@@ -183,21 +192,24 @@
 /* Define to 1 if you have the `open64' function. */
 #undef HAVE_OPEN64
 
 /* Define to 1 if you have the `readlink' function. */
 #undef HAVE_READLINK
 
-/* remote shell is remsh not rsh */
+/* Define to 1 if remote shell is remsh, not rsh */
 #undef HAVE_REMSH
 
 /* Define to 1 if mkstemp() is available and works right */
 #undef HAVE_SECURE_MKSTEMP
 
 /* Define to 1 if you have the `setgroups' function. */
 #undef HAVE_SETGROUPS
 
+/* Define to 1 if you have the `setlocale' function. */
+#undef HAVE_SETLOCALE
+
 /* Define to 1 if you have the `setmode' function. */
 #undef HAVE_SETMODE
 
 /* Define to 1 if you have the `setsid' function. */
 #undef HAVE_SETSID
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/configure	2005-03-31 11:14:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/configure	2005-06-02 11:54:45.000000000 +0800
@@ -849,12 +849,13 @@
                           yes)
   --enable-profile        turn on CPU profiling (default no)
   --enable-maintainer-mode
                           turn on extra debug features
   --disable-largefile     omit support for large files
   --disable-ipv6          don't even try to use IPv6
+  --disable-locale        turn off locale features
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-included-popt    use bundled popt library, not from system
   --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)
@@ -1311,13 +1312,13 @@
 
 
           ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=2.6.4
+RSYNC_VERSION=2.6.5
 
 { echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
 echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -2855,17 +2856,19 @@
 echo "${ECHO_T}$HAVE_REMSH" >&6
 else
   echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
+if test x$HAVE_REMSH = x1; then
 
-cat >>confdefs.h <<_ACEOF
-#define HAVE_REMSH $HAVE_REMSH
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_REMSH 1
 _ACEOF
 
+fi
 
 if test x"$with_rsh" != x
 then
 	RSYNC_RSH="$with_rsh"
 else
 	RSYNC_RSH="ssh"
@@ -3322,12 +3325,31 @@
 # Check whether --enable-ipv6 or --disable-ipv6 was given.
 if test "${enable_ipv6+set}" = set; then
   enableval="$enable_ipv6"
 
 fi;
 
+
+
+# Check whether --enable-locale or --disable-locale was given.
+if test "${enable_locale+set}" = set; then
+  enableval="$enable_locale"
+  if test x$enableval = xyes; then
+  cat >>confdefs.h <<\_ACEOF
+#define CONFIG_LOCALE 1
+_ACEOF
+
+fi
+else
+  cat >>confdefs.h <<\_ACEOF
+#define CONFIG_LOCALE 1
+_ACEOF
+
+
+fi;
+
 if test "x$enable_ipv6" != xno
 then
 	echo "$as_me:$LINENO: checking ipv6 stack type" >&5
 echo $ECHO_N "checking ipv6 stack type... $ECHO_C" >&6
 	for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
 		case $i in
@@ -4601,16 +4623,17 @@
 
 
 
 
 
 
+
 for ac_header in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
-    sys/un.h glob.h mcheck.h arpa/inet.h arpa/nameser.h \
+    sys/un.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
     netdb.h malloc.h float.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
@@ -10740,17 +10763,19 @@
 
 
 
 
 
 
+
+
 for ac_func in waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo \
     fchmod fstat strchr readlink link utime utimes strftime mtrace ftruncate \
     memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
-    setmode open64 mkstemp64 va_copy __va_copy
+    setlocale setmode open64 lseek64 mkstemp64 va_copy __va_copy
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -11595,17 +11620,25 @@
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SECURE_MKSTEMP" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_SECURE_MKSTEMP" >&6
 if test x"$rsync_cv_HAVE_SECURE_MKSTEMP" = x"yes"; then
+    case $target_os in
+    hpux*)
+				{ echo "$as_me:$LINENO: WARNING: Skipping broken HP-UX mkstemp() -- using mktemp() instead" >&5
+echo "$as_me: WARNING: Skipping broken HP-UX mkstemp() -- using mktemp() instead" >&2;}
+	;;
+    *)
 
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_SECURE_MKSTEMP 1
 _ACEOF
 
+	;;
+    esac
 fi
 
 
 echo "$as_me:$LINENO: checking for broken inet_ntoa" >&5
 echo $ECHO_N "checking for broken inet_ntoa... $ECHO_C" >&6
 if test "${rsync_cv_REPLACE_INET_NTOA+set}" = set; then
@@ -13014,32 +13047,12 @@
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
   $ac_cs_success || { (exit 1); exit 1; }
 fi
 
 
-if test x"$with_rsh" = x; then
-	if test x"$HAVE_REMSH" = x1; then
-		rmsh1='remsh:'
-		rmsh2='=remsh'
-	else
-		rmsh1='rsh:  '
-		rmsh2='=rsh  '
-	fi
-	echo "$as_me:$LINENO: result: " >&5
-echo "${ECHO_T}" >&6
-	echo "$as_me:$LINENO: result:     **********************************************************************" >&5
-echo "${ECHO_T}    **********************************************************************" >&6
-	echo "$as_me:$LINENO: result:     *   As of v2.6.0, the default remote shell is ssh instead of rsh!!   *" >&5
-echo "${ECHO_T}    *   As of v2.6.0, the default remote shell is ssh instead of rsh!!   *" >&6
-	echo "$as_me:$LINENO: result:     *   To use previous default of $rmsh1 ./configure --with-rsh$rmsh2   *" >&5
-echo "${ECHO_T}    *   To use previous default of $rmsh1 ./configure --with-rsh$rmsh2   *" >&6
-	echo "$as_me:$LINENO: result:     **********************************************************************" >&5
-echo "${ECHO_T}    **********************************************************************" >&6
-fi
-
 echo "$as_me:$LINENO: result: " >&5
 echo "${ECHO_T}" >&6
 echo "$as_me:$LINENO: result:     rsync ${RSYNC_VERSION} configuration successful" >&5
 echo "${ECHO_T}    rsync ${RSYNC_VERSION} configuration successful" >&6
 echo "$as_me:$LINENO: result: " >&5
 echo "${ECHO_T}" >&6
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/configure.in	2005-03-31 11:14:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/configure.in	2005-06-02 11:54:45.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.59)
 
-RSYNC_VERSION=2.6.4
+RSYNC_VERSION=2.6.5
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -119,13 +119,15 @@
 AC_DEFINE_UNQUOTED(RSYNCD_SYSCONF, "$RSYNCD_SYSCONF", [location of configuration file for rsync server])
 
 AC_ARG_WITH(rsh,
 	AC_HELP_STRING([--with-rsh=CMD], [set remote shell command to CMD (default: ssh)]))
 
 AC_CHECK_PROG(HAVE_REMSH, remsh, 1, 0)
-AC_DEFINE_UNQUOTED(HAVE_REMSH, $HAVE_REMSH, [remote shell is remsh not rsh])
+if test x$HAVE_REMSH = x1; then
+	AC_DEFINE(HAVE_REMSH, 1, [Define to 1 if remote shell is remsh, not rsh])
+fi
 
 if test x"$with_rsh" != x
 then
 	RSYNC_RSH="$with_rsh"
 else
 	RSYNC_RSH="ssh"
@@ -178,12 +180,23 @@
 ipv6lib=none
 ipv6trylibc=yes
 
 AC_ARG_ENABLE(ipv6,
 	AC_HELP_STRING([--disable-ipv6], [don't even try to use IPv6]))
 
+dnl Do you want to disable use of locale functions
+AH_TEMPLATE([CONFIG_LOCALE],
+[Undefine if you don't want locale features.  By default this is defined.])
+AC_ARG_ENABLE([locale],
+	AC_HELP_STRING([--disable-locale], [turn off locale features]),
+[if test x$enableval = xyes; then
+  AC_DEFINE(CONFIG_LOCALE)
+fi],
+AC_DEFINE(CONFIG_LOCALE)
+)
+
 if test "x$enable_ipv6" != xno
 then
 	AC_MSG_CHECKING([ipv6 stack type])
 	for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
 		case $i in
 		inria)
@@ -284,13 +297,13 @@
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
-    sys/un.h glob.h mcheck.h arpa/inet.h arpa/nameser.h \
+    sys/un.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
     netdb.h malloc.h float.h)
 AC_HEADER_MAJOR
 
 AC_CHECK_SIZEOF(int)
 AC_CHECK_SIZEOF(long)
 AC_CHECK_SIZEOF(long long)
@@ -475,13 +488,13 @@
 AC_FUNC_UTIME_NULL
 AC_FUNC_ALLOCA
 AC_CHECK_FUNCS(waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo \
     fchmod fstat strchr readlink link utime utimes strftime mtrace ftruncate \
     memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
-    setmode open64 mkstemp64 va_copy __va_copy)
+    setlocale setmode open64 lseek64 mkstemp64 va_copy __va_copy)
 
 AC_CHECK_FUNCS(getpgrp tcgetpgrp)
 if test $ac_cv_func_getpgrp = yes; then
     AC_FUNC_GETPGRP
 fi
 
@@ -618,13 +631,23 @@
   exit(0);
 }],
 rsync_cv_HAVE_SECURE_MKSTEMP=yes,
 rsync_cv_HAVE_SECURE_MKSTEMP=no,
 rsync_cv_HAVE_SECURE_MKSTEMP=cross)])
 if test x"$rsync_cv_HAVE_SECURE_MKSTEMP" = x"yes"; then
-    AC_DEFINE(HAVE_SECURE_MKSTEMP, 1, [Define to 1 if mkstemp() is available and works right])
+    case $target_os in
+    hpux*)
+	dnl HP-UX has a broken mkstemp() implementation they refuse to fix,
+	dnl so we noisily skip using it.  See HP change request JAGaf34426
+	dnl for details. (sbonds)
+	AC_MSG_WARN(Skipping broken HP-UX mkstemp() -- using mktemp() instead)
+	;;
+    *)
+	AC_DEFINE(HAVE_SECURE_MKSTEMP, 1, [Define to 1 if mkstemp() is available and works right])
+	;;
+    esac
 fi
 
 
 AC_CACHE_CHECK([for broken inet_ntoa],rsync_cv_REPLACE_INET_NTOA,[
 AC_TRY_RUN([
 #include <stdio.h>
@@ -713,24 +736,9 @@
 AC_SUBST(CC_SHOBJ_FLAG)
 AC_SUBST(BUILD_POPT)
 
 AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
 AC_OUTPUT
 
-if test x"$with_rsh" = x; then
-	if test x"$HAVE_REMSH" = x1; then
-		rmsh1='remsh:'
-		rmsh2='=remsh'
-	else
-		rmsh1='rsh:  '
-		rmsh2='=rsh  '
-	fi
-	AC_MSG_RESULT()
-	AC_MSG_RESULT([    **********************************************************************])
-	AC_MSG_RESULT([    *   As of v2.6.0, the default remote shell is ssh instead of rsh!!   *])
-	AC_MSG_RESULT([    *   To use previous default of $rmsh1 ./configure --with-rsh$rmsh2   *])
-	AC_MSG_RESULT([    **********************************************************************])
-fi
-
 AC_MSG_RESULT()
 AC_MSG_RESULT([    rsync ${RSYNC_VERSION} configuration successful])
 AC_MSG_RESULT()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/COPYING /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/COPYING
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/COPYING	1996-06-22 13:04:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/COPYING	2005-04-17 16:25:50.000000000 +0800
@@ -1,11 +1,11 @@
 		    GNU GENERAL PUBLIC LICENSE
 		       Version 2, June 1991
 
  Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                          675 Mass Ave, Cambridge, MA 02139, USA
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
 			    Preamble
 
   The licenses for most software are designed to take away your
@@ -276,25 +276,25 @@
 YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGES.
 
 		     END OF TERMS AND CONDITIONS
 
-	Appendix: How to Apply These Terms to Your New Programs
+	    How to Apply These Terms to Your New Programs
 
   If you develop a new program, and you want it to be of the greatest
 possible use to the public, the best way to achieve this is to make it
 free software which everyone can redistribute and change under these terms.
 
   To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
 convey the exclusion of warranty; and each file should have at least
 the "copyright" line and a pointer to where the full notice is found.
 
     <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) 19yy  <name of author>
+    Copyright (C) <year>  <name of author>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
@@ -302,20 +302,21 @@
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
 
 Also add information on how to contact you by electronic and paper mail.
 
 If the program is interactive, make it output a short notice like this
 when it starts in an interactive mode:
 
-    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision version 69, Copyright (C) year name of author
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.
 
 The hypothetical commands `show w' and `show c' should show the appropriate
 parts of the General Public License.  Of course, the commands you use may
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/errcode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/errcode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/errcode.h	2005-03-16 07:23:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/errcode.h	2005-04-13 07:04:10.000000000 +0800
@@ -25,13 +25,12 @@
 #define RERR_OK         0
 #define RERR_SYNTAX     1       /* syntax or usage error */
 #define RERR_PROTOCOL   2       /* protocol incompatibility */
 #define RERR_FILESELECT 3       /* errors selecting input/output files, dirs */
 #define RERR_UNSUPPORTED 4      /* requested action not supported */
 #define RERR_STARTCLIENT 5      /* error starting client-server protocol */
-#define RERR_LOG_FAILURE 6      /* daemon unable to append to log-file */
 
 #define RERR_SOCKETIO   10      /* error in socket IO */
 #define RERR_FILEIO     11      /* error in file IO */
 #define RERR_STREAMIO   12      /* error in rsync protocol data stream */
 #define RERR_MESSAGEIO  13      /* errors with program diagnostics */
 #define RERR_IPC        14      /* error in IPC code */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/exclude.c	2005-02-27 15:34:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/exclude.c	2005-04-27 00:09:03.000000000 +0800
@@ -671,14 +671,13 @@
 		if (*s == '-' && s[1] == ' ') {
 			new_mflags &= ~MATCHFLG_INCLUDE;
 			s += 2;
 		} else if (*s == '+' && s[1] == ' ') {
 			new_mflags |= MATCHFLG_INCLUDE;
 			s += 2;
-		}
-		if (*s == '!')
+		} else if (*s == '!')
 			new_mflags |= MATCHFLG_CLEAR_LIST; /* Tentative! */
 	} else {
 		char ch = 0, *mods = "";
 		switch (*s) {
 		case 'c':
 			if ((s = RULE_STRCMP(s, "clear")) != NULL)
@@ -1104,15 +1102,15 @@
 		} else
 			prev = ent;
 		if (elide > 0)
 			continue;
 		if (ent->match_flags & MATCHFLG_CVS_IGNORE
 		    && !(ent->match_flags & MATCHFLG_MERGE_FILE)) {
-			int f = am_sender || protocol_version < 29 ? f_out : -1;
+			int f = am_sender || protocol_version < 29 ? f_out : -2;
 			send_rules(f, &cvs_filter_list);
-			if (f >= 0)
+			if (f == f_out)
 				continue;
 		}
 		p = get_rule_prefix(ent->match_flags, ent->pattern, 1, &plen);
 		if (!p) {
 			rprintf(FERROR,
 				"filter rules are too modern for remote rsync.\n");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/flist.c	2005-03-31 01:31:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/flist.c	2005-05-28 02:15:18.000000000 +0800
@@ -652,12 +652,15 @@
 	if (S_ISDIR(mode)) {
 		if (basename_len == 1+1 && *basename == '.') /* +1 for '\0' */
 			file->dir.depth--;
 		if (flags & XMIT_TOP_DIR) {
 			in_del_hier = 1;
 			del_hier_name_len = file->dir.depth == 0 ? 0 : l1 + l2;
+			if (relative_paths && del_hier_name_len > 2
+			    && basename_len == 1+1 && *basename == '.')
+				del_hier_name_len -= 2;
 			file->flags |= FLAG_TOP_DIR | FLAG_DEL_HERE;
 		} else if (in_del_hier) {
 			if (!relative_paths || !del_hier_name_len
 			 || (l1 >= del_hier_name_len
 			  && thisname[del_hier_name_len] == '/'))
 				file->flags |= FLAG_DEL_HERE;
@@ -1114,17 +1117,27 @@
 
 		l = strlen(fname);
 		if (!l || fname[l - 1] == '/') {
 			if (l == 2 && fname[0] == '.') {
 				/* Turn "./" into just "." rather than "./." */
 				fname[1] = '\0';
-			} else if (l < MAXPATHLEN) {
+			} else {
+				if (l + 1 >= MAXPATHLEN)
+					overflow("send_file_list");
 				fname[l++] = '.';
 				fname[l] = '\0';
 			}
 			is_dot_dir = 1;
+		} else if (l > 1 && fname[l-1] == '.' && fname[l-2] == '.'
+		    && (l == 2 || fname[l-3] == '/')) {
+			if (l + 2 >= MAXPATHLEN)
+				overflow("send_file_list");
+			fname[l++] = '/';
+			fname[l++] = '.';
+			fname[l] = '\0';
+			is_dot_dir = 1;
 		} else {
 			is_dot_dir = fname[l-1] == '.'
 				   && (l == 1 || fname[l-2] == '/');
 		}
 
 		if (link_stat(fname, &st, keep_dirlinks) != 0) {
@@ -1508,14 +1521,14 @@
 				rprintf(FINFO,
 					"removing duplicate name %s from file list (%d)\n",
 					safe_fname(f_name(file)), drop);
 			}
 			/* Make sure that if we unduplicate '.', that we don't
 			 * lose track of a user-specified top directory. */
-			if (flist->files[drop]->flags & FLAG_TOP_DIR)
-				flist->files[keep]->flags |= FLAG_TOP_DIR;
+			flist->files[keep]->flags |= flist->files[drop]->flags
+						   & (FLAG_TOP_DIR|FLAG_DEL_HERE);
 
 			clear_file(drop, flist);
 
 			if (keep == i) {
 				if (flist->low == drop) {
 					for (j = drop + 1;
@@ -1664,14 +1677,19 @@
 			case s_DIR:
 				state1 = s_SLASH;
 				c1 = (uchar*)"/";
 				break;
 			case s_SLASH:
 				type1 = S_ISDIR(f1->mode) ? t_path : t_ITEM;
-				state1 = s_BASE;
 				c1 = (uchar*)f1->basename;
+				if (type1 == t_PATH && *c1 == '.' && !c1[1]) {
+					type1 = t_ITEM;
+					state1 = s_TRAILING;
+					c1 = (uchar*)"";
+				} else
+					state1 = s_BASE;
 				break;
 			case s_BASE:
 				state1 = s_TRAILING;
 				if (type1 == t_PATH) {
 					c1 = (uchar*)"/";
 					break;
@@ -1689,14 +1707,19 @@
 			case s_DIR:
 				state2 = s_SLASH;
 				c2 = (uchar*)"/";
 				break;
 			case s_SLASH:
 				type2 = S_ISDIR(f2->mode) ? t_path : t_ITEM;
-				state2 = s_BASE;
 				c2 = (uchar*)f2->basename;
+				if (type2 == t_PATH && *c2 == '.' && !c2[1]) {
+					type2 = t_ITEM;
+					state2 = s_TRAILING;
+					c2 = (uchar*)"";
+				} else
+					state2 = s_BASE;
 				break;
 			case s_BASE:
 				state2 = s_TRAILING;
 				if (type2 == t_PATH) {
 					c2 = (uchar*)"/";
 					break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/generator.c	2005-03-31 00:33:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/generator.c	2005-05-23 04:52:32.000000000 +0800
@@ -22,12 +22,13 @@
 */
 
 #include "rsync.h"
 
 extern int verbose;
 extern int dry_run;
+extern int do_xfers;
 extern int log_format_has_i;
 extern int log_format_has_o_or_i;
 extern int daemon_log_format_has_i;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
@@ -55,14 +56,14 @@
 extern int inplace;
 extern int make_backups;
 extern int csum_length;
 extern int ignore_times;
 extern int size_only;
 extern OFF_T max_size;
-extern int io_timeout;
 extern int io_error;
+extern int allowed_lull;
 extern int sock_f_out;
 extern int ignore_timeout;
 extern int protocol_version;
 extern int fuzzy_basis;
 extern int always_checksum;
 extern char *partial_dir;
@@ -85,14 +86,12 @@
 extern char *backup_dir;
 extern char *backup_suffix;
 extern int backup_suffix_len;
 extern struct file_list *the_file_list;
 extern struct filter_list_struct server_filter_list;
 
-int allowed_lull = 0;
-
 static int deletion_count = 0; /* used to implement --max-delete */
 
 
 static int is_backup_file(char *fn)
 {
 	int k = strlen(fn) - backup_suffix_len;
@@ -148,13 +147,13 @@
 		return 0;
 	}
 	if (errno == ENOENT) {
 		deletion_count--;
 		return 0;
 	}
-	if (!zap_dir || (errno != ENOTEMPTY && errno != EEXIST)) {
+	if (!zap_dir) {
 		rsyserr(FERROR, errno, "delete_file: rmdir %s failed",
 			full_fname(fname));
 		return -1;
 	}
 	flags |= DEL_FORCE_RECURSE; /* mark subdir dels as not "in the way" */
 	deletion_count--;
@@ -167,28 +166,25 @@
 		struct file_struct *fp = dirlist->files[j];
 
 		if (fp->flags & FLAG_MOUNT_POINT)
 			continue;
 
 		f_name_to(fp, buf);
-		if (delete_item(buf, fp->mode, flags & ~DEL_TERSE) != 0) {
-			flist_free(dirlist);
-			return -1;
-		}
+		delete_item(buf, fp->mode, flags & ~DEL_TERSE);
 	}
 	flist_free(dirlist);
 
 	pop_local_filters(save_filters);
 
 	if (max_delete && ++deletion_count > max_delete)
 		return 0;
 
 	if (do_rmdir(fname) == 0) {
 		if (!(flags & DEL_TERSE))
 			log_delete(fname, mode);
-	} else if (errno != ENOTEMPTY && errno != ENOENT) {
+	} else if (errno != ENOTEMPTY && errno != EEXIST && errno != ENOENT) {
 		rsyserr(FERROR, errno, "delete_file: rmdir %s failed",
 			full_fname(fname));
 		return -1;
 	}
 
 	return 0;
@@ -245,27 +241,31 @@
 	dlen = strlen(fbuf);
 	filt_array[cur_depth] = push_local_filters(fbuf, dlen);
 
 	if (link_stat(fbuf, &st, keep_dirlinks) < 0)
 		return;
 
-	if (one_file_system && file->flags & FLAG_TOP_DIR)
-		filesystem_dev = st.st_dev;
+	if (one_file_system) {
+		if (file->flags & FLAG_TOP_DIR)
+			filesystem_dev = st.st_dev;
+		else if (filesystem_dev != st.st_dev)
+			return;
+	}
 
 	dirlist = get_dirlist(fbuf, dlen, 0);
 
 	/* If an item in dirlist is not found in flist, delete it
 	 * from the filesystem. */
 	for (i = dirlist->count; i--; ) {
-		if (!dirlist->files[i]->basename)
+		struct file_struct *fp = dirlist->files[i];
+		if (!fp->basename || fp->flags & FLAG_MOUNT_POINT)
 			continue;
-		if (flist_find(flist, dirlist->files[i]) < 0) {
-			int mode = dirlist->files[i]->mode;
-			f_name_to(dirlist->files[i], delbuf);
-			if (delete_item(delbuf, mode, DEL_FORCE_RECURSE) < 0)
-				break;
+		if (flist_find(flist, fp) < 0) {
+			int mode = fp->mode;
+			f_name_to(fp, delbuf);
+			delete_item(delbuf, mode, DEL_FORCE_RECURSE);
 		}
 	}
 
 	flist_free(dirlist);
 }
 
@@ -273,13 +273,14 @@
  * sending side.  This is used by --delete-before and --delete-after. */
 static void do_delete_pass(struct file_list *flist)
 {
 	char fbuf[MAXPATHLEN];
 	int j;
 
-	if (dry_run > 1) /* destination doesn't exist yet */
+	if (dry_run > 1 /* destination doesn't exist yet */
+	 || list_only)
 		return;
 
 	for (j = 0; j < flist->count; j++) {
 		struct file_struct *file = flist->files[j];
 
 		if (!(file->flags & FLAG_DEL_HERE))
@@ -288,12 +289,14 @@
 		f_name_to(file, fbuf);
 		if (verbose > 1 && file->flags & FLAG_TOP_DIR)
 			rprintf(FINFO, "deleting in %s\n", safe_fname(fbuf));
 
 		delete_in_dir(flist, fbuf, file);
 	}
+	if (do_progress && !am_server)
+		rprintf(FINFO, "                    \r");
 }
 
 static int unchanged_attrs(struct file_struct *file, STRUCT_STAT *st)
 {
 	if (preserve_perms
 	 && (st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS))
@@ -662,13 +665,14 @@
 		stat_errno = errno;
 	}
 
 	if (only_existing && statret == -1 && stat_errno == ENOENT) {
 		/* we only want to update existing files */
 		if (verbose > 1) {
-			rprintf(FINFO, "not creating new file \"%s\"\n",
+			rprintf(FINFO, "not creating new %s \"%s\"\n",
+				S_ISDIR(file->mode) ? "directory" : "file",
 				safe_fname(fname));
 		}
 		return;
 	}
 
 	if (statret == 0 && !preserve_perms
@@ -714,24 +718,18 @@
 		if (delete_during && f_out != -1 && !phase && dry_run < 2
 		    && (file->flags & FLAG_DEL_HERE))
 			delete_in_dir(the_file_list, fname, file);
 		return;
 	}
 
-	if (max_size && file->length > max_size) {
-		if (verbose > 1) {
-			rprintf(FINFO, "%s is over max-size\n",
-				safe_fname(fname));
-		}
-		return;
-	}
-
 	if (preserve_links && S_ISLNK(file->mode)) {
 #ifdef SUPPORT_LINKS
 		if (safe_symlinks && unsafe_symlink(file->u.link, fname)) {
 			if (verbose) {
+				if (the_file_list->count == 1)
+					fname = f_name(file);
 				rprintf(FINFO,
 					"ignoring unsafe symlink %s -> \"%s\"\n",
 					full_fname(fname),
 					safe_fname(file->u.link));
 			}
 			return;
@@ -818,21 +816,35 @@
 				itemize(file, ndx, statret, &st, 0, 0, NULL);
 			set_perms(fname, file, &st, maybe_PERMS_REPORT);
 		}
 		return;
 	}
 
-	if (preserve_hard_links && hard_link_check(file, ndx, HL_CHECK_MASTER))
+	if (preserve_hard_links
+	    && hard_link_check(file, ndx, fname, statret, &st,
+			       itemizing, code, HL_CHECK_MASTER))
 		return;
 
 	if (!S_ISREG(file->mode)) {
+		if (the_file_list->count == 1)
+			fname = f_name(file);
 		rprintf(FINFO, "skipping non-regular file \"%s\"\n",
 			safe_fname(fname));
 		return;
 	}
 
+	if (max_size && file->length > max_size) {
+		if (verbose > 1) {
+			if (the_file_list->count == 1)
+				fname = f_name(file);
+			rprintf(FINFO, "%s is over max-size\n",
+				safe_fname(fname));
+		}
+		return;
+	}
+
 	if (opt_ignore_existing && statret == 0) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s exists\n", safe_fname(fname));
 		return;
 	}
 
@@ -899,18 +911,20 @@
 			}
 #ifdef HAVE_LINK
 			if (link_dest && match_level == 3) {
 				if (hard_link_one(file, ndx, fname, -1, &st,
 						  fnamecmpbuf, 1,
 						  itemizing && verbose > 1,
-						  code) == 0)
+						  code) == 0) {
+					if (preserve_hard_links
+					    && file->link_u.links) {
+						hard_link_cluster(file, ndx,
+								  itemizing,
+								  code);
+					}
 					return;
-				if (verbose) {
-					rsyserr(FINFO, errno, "link %s => %s",
-						full_fname(fnamecmpbuf),
-						safe_fname(fname));
 				}
 				match_level = 2;
 			}
 #endif
 			if (match_level == 2) {
 				/* Copy the file locally. */
@@ -920,14 +934,31 @@
 							"copy_file %s => %s",
 							full_fname(fnamecmpbuf),
 							safe_fname(fname));
 					}
 					match_level = 0;
 					statret = -1;
-				} else
-					set_perms(fname, file, NULL, 0);
+				} else {
+					if (itemizing) {
+						itemize(file, ndx, 0, &st,
+							ITEM_LOCAL_CHANGE, 0,
+							NULL);
+					} else if (verbose && code) {
+						rprintf(code, "%s\n",
+							safe_fname(fname));
+					}
+					set_perms(fname, file, NULL,
+						  maybe_PERMS_REPORT);
+					if (preserve_hard_links
+					    && file->link_u.links) {
+						hard_link_cluster(file, ndx,
+								  itemizing,
+								  code);
+					}
+					return;
+				}
 			} else if (compare_dest || match_level == 1) {
 				fnamecmp = fnamecmpbuf;
 				fnamecmp_type = i;
 			}
 		}
 	}
@@ -957,13 +988,15 @@
 			fnamecmp = fnamecmpbuf;
 			fnamecmp_type = FNAMECMP_FUZZY;
 		}
 	}
 
 	if (statret != 0) {
-		if (preserve_hard_links && hard_link_check(file, ndx, HL_SKIP))
+		if (preserve_hard_links
+		    && hard_link_check(file, ndx, fname, statret, &st,
+				       itemizing, code, HL_SKIP))
 			return;
 		if (stat_errno == ENOENT)
 			goto notify_others;
 		if (verbose > 1) {
 			rsyserr(FERROR, stat_errno,
 				"recv_generator: failed to stat %s",
@@ -998,13 +1031,13 @@
 		st = partial_st;
 		fnamecmp = partialptr;
 		fnamecmp_type = FNAMECMP_PARTIAL_DIR;
 		statret = 0;
 	}
 
-	if (dry_run || read_batch || whole_file)
+	if (!do_xfers || read_batch || whole_file)
 		goto notify_others;
 
 	if (fuzzy_basis) {
 		int j = flist_find(fuzzy_dirlist, file);
 		if (j >= 0) /* don't use changing file as future fuzzy basis */
 			fuzzy_dirlist->files[j]->flags |= FLAG_NO_FUZZY;
@@ -1015,13 +1048,15 @@
 
 	if (fd == -1) {
 		rsyserr(FERROR, errno, "failed to open %s, continuing",
 			full_fname(fnamecmp));
 	    pretend_missing:
 		/* pretend the file didn't exist */
-		if (preserve_hard_links && hard_link_check(file, ndx, HL_SKIP))
+		if (preserve_hard_links
+		    && hard_link_check(file, ndx, fname, statret, &st,
+				       itemizing, code, HL_SKIP))
 			return;
 		statret = real_ret = -1;
 		goto notify_others;
 	}
 
 	if (inplace && make_backups && fnamecmp_type == FNAMECMP_FNAME) {
@@ -1070,13 +1105,13 @@
 		if (fnamecmp_type == FNAMECMP_FUZZY)
 			iflags |= ITEM_XNAME_FOLLOWS;
 		itemize(file, -1, real_ret, &real_st, iflags, fnamecmp_type,
 			fuzzy_file ? fuzzy_file->basename : NULL);
 	}
 
-	if (dry_run) {
+	if (!do_xfers) {
 		if (preserve_hard_links && file->link_u.links)
 			hard_link_cluster(file, ndx, itemizing, code);
 		return;
 	}
 	if (read_batch)
 		return;
@@ -1101,33 +1136,32 @@
 	close(fd);
 }
 
 
 void generate_files(int f_out, struct file_list *flist, char *local_name)
 {
-	int i, lull_mod;
+	int i;
 	char fbuf[MAXPATHLEN];
 	int itemizing, maybe_PERMS_REPORT;
 	enum logcode code;
+	int lull_mod = allowed_lull * 5;
 	int need_retouch_dir_times = preserve_times && !omit_dir_times;
 	int need_retouch_dir_perms = 0;
 	int save_only_existing = only_existing;
 	int save_opt_ignore_existing = opt_ignore_existing;
 	int save_do_progress = do_progress;
-
-	allowed_lull = read_batch ? 0 : (io_timeout + 1) / 2;
-	lull_mod = allowed_lull * 5;
+	int save_make_backups = make_backups;
 
 	if (protocol_version >= 29) {
 		itemizing = 1;
 		maybe_PERMS_REPORT = log_format_has_i ? 0 : PERMS_REPORT;
 		code = daemon_log_format_has_i ? 0 : FLOG;
 	} else if (am_daemon) {
-		itemizing = daemon_log_format_has_i && !dry_run;
+		itemizing = daemon_log_format_has_i && do_xfers;
 		maybe_PERMS_REPORT = PERMS_REPORT;
-		code = itemizing || dry_run ? FCLIENT : FINFO;
+		code = itemizing || !do_xfers ? FCLIENT : FINFO;
 	} else if (!am_server) {
 		itemizing = log_format_has_i;
 		maybe_PERMS_REPORT = log_format_has_i ? 0 : PERMS_REPORT;
 		code = itemizing ? 0 : FINFO;
 	} else {
 		itemizing = 0;
@@ -1150,14 +1184,17 @@
 		rprintf(FINFO, "delta-transmission %s\n",
 			whole_file
 			? "disabled for local transfer or --whole-file"
 			: "enabled");
 	}
 
-	if (protocol_version < 29)
-		ignore_timeout = 1;
+	/* Since we often fill up the outgoing socket and then just sit around
+	 * waiting for the other 2 processes to do their thing, we don't want
+	 * to exit on a timeout.  If the data stops flowing, the receiver will
+	 * notice that and let us know via the redo pipe (or its closing). */
+	ignore_timeout = 1;
 
 	for (i = 0; i < flist->count; i++) {
 		struct file_struct *file = flist->files[i];
 
 		if (!file->basename)
 			continue;
@@ -1166,13 +1203,14 @@
 			       file, i, itemizing, maybe_PERMS_REPORT, code,
 			       f_out);
 
 		/* We need to ensure that any dirs we create have writeable
 		 * permissions during the time we are putting files within
 		 * them.  This is then fixed after the transfer is done. */
-		if (!am_root && S_ISDIR(file->mode) && !(file->mode & S_IWUSR)) {
+		if (!am_root && S_ISDIR(file->mode) && !(file->mode & S_IWUSR)
+		    && !list_only) {
 			int mode = file->mode | S_IWUSR; /* user write */
 			char *fname = local_name ? local_name : fbuf;
 			if (do_chmod(fname, mode & CHMOD_BITS) < 0) {
 				rsyserr(FERROR, errno,
 					"failed to modify permissions on %s",
 					full_fname(fname));
@@ -1182,28 +1220,26 @@
 
 		if (preserve_hard_links)
 			check_for_finished_hlinks(itemizing, code);
 
 		if (allowed_lull && !(i % lull_mod))
 			maybe_send_keepalive();
+		else if (!(i % 200))
+			maybe_flush_socket();
 	}
 	recv_generator(NULL, NULL, 0, 0, 0, code, -1);
 	if (delete_during)
 		delete_in_dir(NULL, NULL, NULL);
 
 	phase++;
 	csum_length = SUM_LENGTH;
 	only_existing = max_size = opt_ignore_existing = 0;
 	update_only = always_checksum = size_only = 0;
 	ignore_times = 1;
 	make_backups = 0; /* avoid a duplicate backup for inplace processing */
 
-	/* We expect to just sit around now, so don't exit on a timeout.
-	 * If we really get a timeout then the other process should exit. */
-	ignore_timeout = 1;
-
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
 	write_int(f_out, -1);
 
 	/* files can cycle through the system more than once
@@ -1215,12 +1251,13 @@
 			       f_out);
 	}
 
 	phase++;
 	only_existing = save_only_existing;
 	opt_ignore_existing = save_opt_ignore_existing;
+	make_backups = save_make_backups;
 
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
 	write_int(f_out, -1);
 	/* Reduce round-trip lag-time for a useless delay-updates phase. */
@@ -1255,14 +1292,16 @@
 			if (!file->basename || !S_ISDIR(file->mode))
 				continue;
 			if (!need_retouch_dir_times && file->mode & S_IWUSR)
 				continue;
 			recv_generator(f_name(file), file, i, itemizing,
 				       maybe_PERMS_REPORT, code, -1);
-			if (allowed_lull && !(j++ % lull_mod))
+			if (allowed_lull && !(++j % lull_mod))
 				maybe_send_keepalive();
+			else if (!(j % 200))
+				maybe_flush_socket();
 		}
 	}
 	recv_generator(NULL, NULL, 0, 0, 0, code, -1);
 
 	if (max_delete > 0 && deletion_count > max_delete) {
 		rprintf(FINFO,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/hlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/hlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/hlink.c	2005-03-10 02:54:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/hlink.c	2005-04-24 01:48:34.000000000 +0800
@@ -24,12 +24,15 @@
 extern int verbose;
 extern int make_backups;
 extern struct file_list *the_file_list;
 
 #ifdef SUPPORT_HARD_LINKS
 
+#define SKIPPED_LINK (-1)
+#define FINISHED_LINK (-2)
+
 #define FPTR(i) (the_file_list->files[i])
 #define LINKED(p1,p2) (FPTR(p1)->F_DEV == FPTR(p2)->F_DEV \
 		    && FPTR(p1)->F_INODE == FPTR(p2)->F_INODE)
 
 static int hlink_compare(int *int1, int *int2)
 {
@@ -49,47 +52,47 @@
 static int hlink_count;
 
 /* Analyze the data in the hlink_list[], remove items that aren't multiply
  * linked, and replace the dev+inode data with the hlindex+next linked list. */
 static void link_idev_data(void)
 {
-	int head, from, to, start;
+	int cur, from, to, start;
 
 	alloc_pool_t hlink_pool;
 	alloc_pool_t idev_pool = the_file_list->hlink_pool;
 
 	hlink_pool = pool_create(128 * 1024, sizeof (struct hlink),
 	    out_of_memory, POOL_INTERN);
 
 	for (from = to = 0; from < hlink_count; from++) {
 		start = from;
-		head = hlink_list[start];
-		while (from < hlink_count-1
-		    && LINKED(hlink_list[from], hlink_list[from+1])) {
-			pool_free(idev_pool, 0, FPTR(hlink_list[from])->link_u.idev);
-			FPTR(hlink_list[from])->link_u.links = pool_talloc(hlink_pool,
+		while (1) {
+			cur = hlink_list[from];
+			if (from == hlink_count-1
+			    || !LINKED(cur, hlink_list[from+1]))
+				break;
+			pool_free(idev_pool, 0, FPTR(cur)->link_u.idev);
+			FPTR(cur)->link_u.links = pool_talloc(hlink_pool,
 			    struct hlink, 1, "hlink_list");
 
-			FPTR(hlink_list[from])->F_HLINDEX = to;
-			FPTR(hlink_list[from])->F_NEXT = hlink_list[from+1];
-			from++;
+			FPTR(cur)->F_HLINDEX = to;
+			FPTR(cur)->F_NEXT = hlink_list[++from];
 		}
+		pool_free(idev_pool, 0, FPTR(cur)->link_u.idev);
 		if (from > start) {
-			pool_free(idev_pool, 0, FPTR(hlink_list[from])->link_u.idev);
-			FPTR(hlink_list[from])->link_u.links = pool_talloc(hlink_pool,
+			int head = hlink_list[start];
+			FPTR(cur)->link_u.links = pool_talloc(hlink_pool,
 			    struct hlink, 1, "hlink_list");
 
 			FPTR(head)->flags |= FLAG_HLINK_TOL;
-			FPTR(hlink_list[from])->F_HLINDEX = to;
-			FPTR(hlink_list[from])->F_NEXT = head;
-			FPTR(hlink_list[from])->flags |= FLAG_HLINK_EOL;
+			FPTR(cur)->F_HLINDEX = to;
+			FPTR(cur)->F_NEXT = head;
+			FPTR(cur)->flags |= FLAG_HLINK_EOL;
 			hlink_list[to++] = head;
-		} else {
-			pool_free(idev_pool, 0, FPTR(head)->link_u.idev);
-			FPTR(head)->link_u.idev = NULL;
-		}
+		} else
+			FPTR(cur)->link_u.links = NULL;
 	}
 
 	if (!to) {
 		free(hlink_list);
 		hlink_list = NULL;
 		pool_destroy(hlink_pool);
@@ -107,15 +110,12 @@
 
 void init_hard_links(void)
 {
 #ifdef SUPPORT_HARD_LINKS
 	int i;
 
-	if (the_file_list->count < 2)
-		return;
-
 	if (hlink_list)
 		free(hlink_list);
 
 	if (!(hlink_list = new_array(int, the_file_list->count)))
 		out_of_memory("init_hard_links");
 
@@ -133,40 +133,93 @@
 		hlink_list = NULL;
 	} else
 		link_idev_data();
 #endif
 }
 
-int hard_link_check(struct file_struct *file, int ndx, int skip)
+#ifdef SUPPORT_HARD_LINKS
+static int maybe_hard_link(struct file_struct *file, int ndx,
+			   char *fname, int statret, STRUCT_STAT *st,
+			   char *toname, STRUCT_STAT *to_st,
+			   int itemizing, enum logcode code)
+{
+	if (statret == 0) {
+		if (st->st_dev == to_st->st_dev
+		 && st->st_ino == to_st->st_ino) {
+			if (itemizing) {
+				itemize(file, ndx, statret, st,
+					ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,
+					0, "");
+			}
+			return 0;
+		}
+		if (make_backups) {
+			if (!make_backup(fname))
+				return -1;
+		} else if (robust_unlink(fname)) {
+			rsyserr(FERROR, errno, "unlink %s failed",
+				full_fname(fname));
+			return -1;
+		}
+	}
+	return hard_link_one(file, ndx, fname, statret, st, toname,
+			     0, itemizing, code);
+}
+#endif
+
+int hard_link_check(struct file_struct *file, int ndx, char *fname,
+		    int statret, STRUCT_STAT *st, int itemizing,
+		    enum logcode code, int skip)
 {
 #ifdef SUPPORT_HARD_LINKS
-	if (!hlink_list || !file->link_u.links)
+	int head;
+	if (!file->link_u.links)
 		return 0;
 	if (skip && !(file->flags & FLAG_HLINK_EOL))
-		hlink_list[file->F_HLINDEX] = file->F_NEXT;
-	if (hlink_list[file->F_HLINDEX] != ndx) {
+		head = hlink_list[file->F_HLINDEX] = file->F_NEXT;
+	else
+		head = hlink_list[file->F_HLINDEX];
+	if (ndx != head) {
+		struct file_struct *head_file = FPTR(head);
 		if (verbose > 2) {
 			rprintf(FINFO, "\"%s\" is a hard link\n",
 				safe_fname(f_name(file)));
 		}
+		if (head_file->F_HLINDEX == FINISHED_LINK) {
+			STRUCT_STAT st2;
+			char *toname = f_name(head_file);
+			if (link_stat(toname, &st2, 0) < 0) {
+				rsyserr(FERROR, errno, "stat %s failed",
+					full_fname(toname));
+				return -1;
+			}
+			maybe_hard_link(file, ndx, fname, statret, st,
+					toname, &st2, itemizing, code);
+			file->F_HLINDEX = FINISHED_LINK;
+		} else
+			file->F_HLINDEX = SKIPPED_LINK;
 		return 1;
 	}
 #endif
 	return 0;
 }
 
 #ifdef SUPPORT_HARD_LINKS
 int hard_link_one(struct file_struct *file, int ndx, char *fname,
 		  int statret, STRUCT_STAT *st, char *toname, int terse,
 		  int itemizing, enum logcode code)
 {
 	if (do_link(toname, fname)) {
-		if (verbose) {
-			rsyserr(FERROR, errno, "link %s => %s failed",
-				full_fname(fname), safe_fname(toname));
-		}
+		if (terse) {
+			if (!verbose)
+				return -1;
+			code = FINFO;
+		} else
+			code = FERROR;
+		rsyserr(code, errno, "link %s => %s failed",
+			full_fname(fname), safe_fname(toname));
 		return -1;
 	}
 
 	if (itemizing) {
 		itemize(file, ndx, statret, st,
 			ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS, 0,
@@ -187,47 +240,28 @@
 #ifdef SUPPORT_HARD_LINKS
 	char hlink1[MAXPATHLEN];
 	char *hlink2;
 	STRUCT_STAT st1, st2;
 	int statret, ndx = master;
 
+	file->F_HLINDEX = FINISHED_LINK;
 	if (link_stat(f_name_to(file, hlink1), &st1, 0) < 0)
 		return;
 	if (!(file->flags & FLAG_HLINK_TOL)) {
 		while (!(file->flags & FLAG_HLINK_EOL)) {
 			ndx = file->F_NEXT;
 			file = FPTR(ndx);
 		}
 	}
 	do {
 		ndx = file->F_NEXT;
 		file = FPTR(ndx);
-		if (ndx == master)
+		if (file->F_HLINDEX != SKIPPED_LINK)
 			continue;
 		hlink2 = f_name(file);
-		if ((statret = link_stat(hlink2, &st2, 0)) == 0) {
-			if (st2.st_dev == st1.st_dev
-			    && st2.st_ino == st1.st_ino) {
-				if (itemizing) {
-					itemize(file, ndx, statret, &st2,
-						ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,
-						0, "");
-				}
-				continue;
-			}
-			if (make_backups) {
-				if (!make_backup(hlink2))
-					continue;
-			} else if (robust_unlink(hlink2)) {
-				if (verbose > 0) {
-					rsyserr(FINFO, errno,
-						"unlink %s failed",
-						full_fname(hlink2));
-				}
-				continue;
-			}
-		}
-		hard_link_one(file, ndx, hlink2, statret,
-			      &st2, hlink1, 0, itemizing, code);
+		statret = link_stat(hlink2, &st2, 0);
+		maybe_hard_link(file, ndx, hlink2, statret, &st2,
+				hlink1, &st1, itemizing, code);
+		file->F_HLINDEX = FINISHED_LINK;
 	} while (!(file->flags & FLAG_HLINK_EOL));
 #endif
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/io.c	2005-03-10 02:54:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/io.c	2005-05-19 16:52:13.000000000 +0800
@@ -46,23 +46,23 @@
 extern int allowed_lull;
 extern int am_server;
 extern int am_daemon;
 extern int am_sender;
 extern int am_generator;
 extern int eol_nulls;
+extern int read_batch;
 extern int csum_length;
 extern int checksum_seed;
 extern int protocol_version;
 extern int remove_sent_files;
 extern int preserve_hard_links;
 extern char *filesfrom_host;
 extern struct stats stats;
 extern struct file_list *the_file_list;
 
 const char phase_unknown[] = "unknown";
-int select_timeout = SELECT_TIMEOUT;
 int ignore_timeout = 0;
 int batch_fd = -1;
 int batch_gen_fd = -1;
 
 /**
  * The connection might be dropped at some point; perhaps because the
@@ -87,25 +87,27 @@
 int msg_fd_out = -1;
 int sock_f_in = -1;
 int sock_f_out = -1;
 
 static int io_multiplexing_out;
 static int io_multiplexing_in;
-static time_t last_io;
+static time_t last_io_in;
+static time_t last_io_out;
 static int no_flush;
 
 static int write_batch_monitor_in = -1;
 static int write_batch_monitor_out = -1;
 
 static int io_filesfrom_f_in = -1;
 static int io_filesfrom_f_out = -1;
 static char io_filesfrom_buf[2048];
 static char *io_filesfrom_bp;
 static char io_filesfrom_lastchar;
 static int io_filesfrom_buflen;
 static size_t contiguous_write_len = 0;
+static int select_timeout = SELECT_TIMEOUT;
 
 static void read_loop(int fd, char *buf, size_t len);
 
 struct flist_ndx_item {
 	struct flist_ndx_item *next;
 	int ndx;
@@ -163,23 +165,23 @@
 {
 	time_t t;
 
 	if (!io_timeout || ignore_timeout)
 		return;
 
-	if (!last_io) {
-		last_io = time(NULL);
+	if (!last_io_in) {
+		last_io_in = time(NULL);
 		return;
 	}
 
 	t = time(NULL);
 
-	if (t - last_io >= io_timeout) {
+	if (t - last_io_in >= io_timeout) {
 		if (!am_server && !am_daemon) {
 			rprintf(FERROR, "io timeout after %d seconds -- exiting\n",
-				(int)(t-last_io));
+				(int)(t-last_io_in));
 		}
 		exit_cleanup(RERR_TIMEOUT);
 	}
 }
 
 /* Note the fds used for the main socket (which might really be a pipe
@@ -187,12 +189,24 @@
 void io_set_sock_fds(int f_in, int f_out)
 {
 	sock_f_in = f_in;
 	sock_f_out = f_out;
 }
 
+void set_io_timeout(int secs)
+{
+	io_timeout = secs;
+
+	if (!io_timeout || io_timeout > SELECT_TIMEOUT)
+		select_timeout = SELECT_TIMEOUT;
+	else
+		select_timeout = io_timeout;
+
+	allowed_lull = read_batch ? 0 : (io_timeout + 1) / 2;
+}
+
 /* Setup the fd used to receive MSG_* messages.  Only needed during the
  * early stages of being a local sender (up through the sending of the
  * file list) or when we're the generator (to fetch the messages from
  * the receiver). */
 void set_msg_fd_in(int fd)
 {
@@ -571,14 +585,14 @@
 		}
 
 		buf += n;
 		len -= n;
 		ret += n;
 
-		if (io_timeout && fd == sock_f_in)
-			last_io = time(NULL);
+		if (fd == sock_f_in && io_timeout)
+			last_io_in = time(NULL);
 	}
 
 	return ret;
 }
 
 /**
@@ -662,15 +676,22 @@
 		free(iobuf_out);
 		iobuf_out = NULL;
 	}
 }
 
 
+void maybe_flush_socket(void)
+{
+	if (iobuf_out && iobuf_out_cnt && time(NULL) - last_io_out >= 5)
+		io_flush(NORMAL_FLUSH);
+}
+
+
 void maybe_send_keepalive(void)
 {
-	if (time(NULL) - last_io >= allowed_lull) {
+	if (time(NULL) - last_io_out >= allowed_lull) {
 		if (!iobuf_out || !iobuf_out_cnt) {
 			if (protocol_version < 29)
 				return; /* there's nothing we can do */
 			write_int(sock_f_out, the_file_list->count);
 			write_shortint(sock_f_out, ITEM_IS_NEW);
 		}
@@ -702,14 +723,19 @@
  * Never returns <= 0.
  */
 static int readfd_unbuffered(int fd, char *buf, size_t len)
 {
 	static size_t remaining;
 	static size_t iobuf_in_ndx;
+	size_t msg_bytes;
 	int tag, ret = 0;
-	char line[MAXPATHLEN+1];
+#if MAXPATHLEN < 4096
+	char line[4096+1024];
+#else
+	char line[MAXPATHLEN+1024];
+#endif
 
 	if (!iobuf_in || fd != sock_f_in)
 		return read_timeout(fd, buf, len);
 
 	if (!io_multiplexing_in && remaining == 0) {
 		remaining = read_timeout(fd, iobuf_in, iobuf_in_siz);
@@ -726,62 +752,58 @@
 			break;
 		}
 
 		read_loop(fd, line, 4);
 		tag = IVAL(line, 0);
 
-		remaining = tag & 0xFFFFFF;
+		msg_bytes = tag & 0xFFFFFF;
 		tag = (tag >> 24) - MPLEX_BASE;
 
 		switch (tag) {
 		case MSG_DATA:
-			if (remaining > iobuf_in_siz) {
+			if (msg_bytes > iobuf_in_siz) {
 				if (!(iobuf_in = realloc_array(iobuf_in, char,
-							       remaining)))
+							       msg_bytes)))
 					out_of_memory("readfd_unbuffered");
-				iobuf_in_siz = remaining;
+				iobuf_in_siz = msg_bytes;
 			}
-			read_loop(fd, iobuf_in, remaining);
+			read_loop(fd, iobuf_in, msg_bytes);
+			remaining = msg_bytes;
 			iobuf_in_ndx = 0;
 			break;
 		case MSG_DELETED:
-			if (remaining >= sizeof line) {
-				rprintf(FERROR, "invalid multi-message %d:%ld\n",
-					tag, (long)remaining);
-				exit_cleanup(RERR_STREAMIO);
-			}
-			read_loop(fd, line, remaining);
-			line[remaining] = '\0';
+			if (msg_bytes >= sizeof line)
+				goto overflow;
+			read_loop(fd, line, msg_bytes);
+			line[msg_bytes] = '\0';
 			/* A directory name was sent with the trailing null */
-			if (remaining > 0 && !line[remaining-1])
+			if (msg_bytes > 0 && !line[msg_bytes-1])
 				log_delete(line, S_IFDIR);
 			else
 				log_delete(line, S_IFREG);
-			remaining = 0;
 			break;
 		case MSG_SUCCESS:
-			if (remaining != 4) {
+			if (msg_bytes != 4) {
 				rprintf(FERROR, "invalid multi-message %d:%ld [%s]\n",
-					tag, (long)remaining, who_am_i());
+					tag, (long)msg_bytes, who_am_i());
 				exit_cleanup(RERR_STREAMIO);
 			}
-			read_loop(fd, line, remaining);
+			read_loop(fd, line, msg_bytes);
 			successful_send(IVAL(line, 0));
-			remaining = 0;
 			break;
 		case MSG_INFO:
 		case MSG_ERROR:
-			if (remaining >= sizeof line) {
+			if (msg_bytes >= sizeof line) {
+			    overflow:
 				rprintf(FERROR,
 					"multiplexing overflow %d:%ld [%s]\n",
-					tag, (long)remaining, who_am_i());
+					tag, (long)msg_bytes, who_am_i());
 				exit_cleanup(RERR_STREAMIO);
 			}
-			read_loop(fd, line, remaining);
-			rwrite((enum logcode)tag, line, remaining);
-			remaining = 0;
+			read_loop(fd, line, msg_bytes);
+			rwrite((enum logcode)tag, line, msg_bytes);
 			break;
 		default:
 			rprintf(FERROR, "unexpected tag %d [%s]\n",
 				tag, who_am_i());
 			exit_cleanup(RERR_STREAMIO);
 		}
@@ -1003,13 +1025,13 @@
  * This function underlies the multiplexing system.  The body of the
  * application never calls this function directly. */
 static void writefd_unbuffered(int fd,char *buf,size_t len)
 {
 	size_t n, total = 0;
 	fd_set w_fds, r_fds;
-	int maxfd, count, ret;
+	int maxfd, count, ret, using_r_fds;
 	struct timeval tv;
 
 	no_flush++;
 
 	while (total < len) {
 		FD_ZERO(&w_fds);
@@ -1018,34 +1040,31 @@
 
 		if (msg_fd_in >= 0 && len-total >= contiguous_write_len) {
 			FD_ZERO(&r_fds);
 			FD_SET(msg_fd_in,&r_fds);
 			if (msg_fd_in > maxfd)
 				maxfd = msg_fd_in;
-		}
-		if (fd != sock_f_out && iobuf_out_cnt && no_flush == 1) {
-			FD_SET(sock_f_out, &w_fds);
-			if (sock_f_out > maxfd)
-				maxfd = sock_f_out;
-		}
+			using_r_fds = 1;
+		} else
+			using_r_fds = 0;
 
 		tv.tv_sec = select_timeout;
 		tv.tv_usec = 0;
 
 		errno = 0;
-		count = select(maxfd + 1, msg_fd_in >= 0 ? &r_fds : NULL,
+		count = select(maxfd + 1, using_r_fds ? &r_fds : NULL,
 			       &w_fds, NULL, &tv);
 
 		if (count <= 0) {
 			if (count < 0 && errno == EBADF)
 				exit_cleanup(RERR_SOCKETIO);
 			check_timeout();
 			continue;
 		}
 
-		if (msg_fd_in >= 0 && FD_ISSET(msg_fd_in, &r_fds))
+		if (using_r_fds && FD_ISSET(msg_fd_in, &r_fds))
 			read_msg_fd();
 
 		if (!FD_ISSET(fd, &w_fds))
 			continue;
 
 		n = len - total;
@@ -1069,25 +1088,25 @@
 			rsyserr(FERROR, errno,
 				"writefd_unbuffered failed to write %ld bytes: phase \"%s\" [%s]",
 				(long)len, io_write_phase, who_am_i());
 			/* If the other side is sending us error messages, try
 			 * to grab any messages they sent before they died. */
 			while (fd == sock_f_out && io_multiplexing_in) {
-				io_timeout = select_timeout = 30;
+				set_io_timeout(30);
 				ignore_timeout = 0;
 				readfd_unbuffered(sock_f_in, io_filesfrom_buf,
 						  sizeof io_filesfrom_buf);
 			}
 			exit_cleanup(RERR_STREAMIO);
 		}
 
 		total += ret;
 
 		if (fd == sock_f_out) {
-			if (io_timeout)
-				last_io = time(NULL);
+			if (io_timeout || am_generator)
+				last_io_out = time(NULL);
 			sleep_for_bwlimit(ret);
 		}
 	}
 
 	no_flush--;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/log.c	2005-03-31 11:01:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/log.c	2005-04-15 00:08:10.000000000 +0800
@@ -41,12 +41,13 @@
 extern int log_format_has_o_or_i;
 extern int daemon_log_format_has_o_or_i;
 extern char *auth_user;
 extern char *log_format;
 
 static int log_initialised;
+static int logfile_was_closed;
 static char *logfname;
 static FILE *logfile;
 struct stats stats;
 
 int log_got_error = 0;
 
@@ -56,13 +57,12 @@
 } const rerr_names[] = {
 	{ RERR_SYNTAX     , "syntax or usage error" },
 	{ RERR_PROTOCOL   , "protocol incompatibility" },
 	{ RERR_FILESELECT , "errors selecting input/output files, dirs" },
 	{ RERR_UNSUPPORTED, "requested action not supported" },
 	{ RERR_STARTCLIENT, "error starting client-server protocol" },
-	{ RERR_LOG_FAILURE, "daemon unable to append to log-file" },
 	{ RERR_SOCKETIO   , "error in socket IO" },
 	{ RERR_FILEIO     , "error in file IO" },
 	{ RERR_STREAMIO   , "error in rsync protocol data stream" },
 	{ RERR_MESSAGEIO  , "errors with program diagnostics" },
 	{ RERR_IPC        , "error in IPC code" },
 	{ RERR_SIGNAL     , "received SIGUSR1 or SIGINT" },
@@ -94,86 +94,102 @@
 	return NULL;
 }
 
 
 static void logit(int priority, char *buf)
 {
-	if (logfname) {
-		if (!logfile)
-			log_open();
+	if (logfile_was_closed)
+		logfile_reopen();
+	if (logfile) {
 		fprintf(logfile,"%s [%d] %s",
 			timestring(time(NULL)), (int)getpid(), buf);
 		fflush(logfile);
 	} else {
 		syslog(priority, "%s", buf);
 	}
 }
 
-void log_init(void)
+static void syslog_init()
 {
+	static int been_here = 0;
 	int options = LOG_PID;
-	time_t t;
 
-	if (log_initialised)
+	if (been_here)
 		return;
-	log_initialised = 1;
-
-	/* this looks pointless, but it is needed in order for the
-	 * C library on some systems to fetch the timezone info
-	 * before the chroot */
-	t = time(NULL);
-	localtime(&t);
-
-	/* optionally use a log file instead of syslog */
-	logfname = lp_log_file();
-	if (logfname) {
-		if (*logfname) {
-			log_open();
-			return;
-		}
-		logfname = NULL;
-	}
+	been_here = 1;
 
 #ifdef LOG_NDELAY
 	options |= LOG_NDELAY;
 #endif
 
 #ifdef LOG_DAEMON
 	openlog("rsyncd", options, lp_syslog_facility());
 #else
 	openlog("rsyncd", options);
 #endif
 
 #ifndef LOG_NDELAY
-	logit(LOG_INFO,"rsyncd started\n");
+	logit(LOG_INFO, "rsyncd started\n");
 #endif
 }
 
-void log_open(void)
+static void logfile_open(void)
 {
-	if (logfname && !logfile) {
-		extern int orig_umask;
-		int old_umask = umask(022 | orig_umask);
-		logfile = fopen(logfname, "a");
-		umask(old_umask);
-		if (!logfile) {
-			am_daemon = 0; /* avoid trying to log again */
-			rsyserr(FERROR, errno, "fopen() of log-file failed");
-			exit_cleanup(RERR_LOG_FAILURE);
-		}
+	extern int orig_umask;
+	int old_umask = umask(022 | orig_umask);
+	logfile = fopen(logfname, "a");
+	umask(old_umask);
+	if (!logfile) {
+		int fopen_errno = errno;
+		/* Rsync falls back to using syslog on failure. */
+		syslog_init();
+		rsyserr(FERROR, fopen_errno,
+			"failed to open log-file %s", logfname);
+		rprintf(FINFO, "Ignoring \"log file\" setting.\n");
 	}
 }
 
-void log_close(void)
+void log_init(void)
+{
+	time_t t;
+
+	if (log_initialised)
+		return;
+	log_initialised = 1;
+
+	/* this looks pointless, but it is needed in order for the
+	 * C library on some systems to fetch the timezone info
+	 * before the chroot */
+	t = time(NULL);
+	localtime(&t);
+
+	/* optionally use a log file instead of syslog */
+	logfname = lp_log_file();
+	if (logfname && *logfname)
+		logfile_open();
+	else
+		syslog_init();
+}
+
+void logfile_close(void)
 {
 	if (logfile) {
+		logfile_was_closed = 1;
 		fclose(logfile);
 		logfile = NULL;
 	}
 }
 
+void logfile_reopen(void)
+{
+	if (logfile_was_closed) {
+		logfile_was_closed = 0;
+		logfile_open();
+	}
+}
+
 /* this is the underlying (unformatted) rsync debugging function. Call
  * it with FINFO, FERROR or FLOG */
 void rwrite(enum logcode code, char *buf, int len)
 {
 	FILE *f = NULL;
 	/* recursion can happen with certain fatal conditions */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/main.c	2005-03-31 00:55:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/main.c	2005-05-12 15:43:14.000000000 +0800
@@ -17,12 +17,15 @@
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
+#if defined CONFIG_LOCALE && defined HAVE_LOCALE_H
+#include <locale.h>
+#endif
 
 extern int verbose;
 extern int dry_run;
 extern int list_only;
 extern int am_root;
 extern int am_server;
@@ -157,13 +160,15 @@
 		}
 		return;
 	}
 
 	/* this is the client */
 
-	if (!am_sender) {
+	if (f < 0 && !am_sender) /* e.g. when we got an empty file list. */
+		; 
+	else if (!am_sender) {
 		/* Read the first two in opposite order because the meaning of
 		 * read/write swaps when switching from sender to receiver. */
 		total_written = read_longint(f);
 		total_read = read_longint(f);
 		stats.total_size = read_longint(f);
 		if (protocol_version >= 29) {
@@ -178,13 +183,16 @@
 		write_longint(batch_fd, stats.total_size);
 		if (protocol_version >= 29) {
 			write_longint(batch_fd, stats.flist_buildtime);
 			write_longint(batch_fd, stats.flist_xfertime);
 		}
 	}
+}
 
+static void output_summary(void)
+{
 	if (do_stats) {
 		rprintf(FINFO,"\nNumber of files: %d\n", stats.num_files);
 		rprintf(FINFO,"Number of files transferred: %d\n",
 			stats.num_transferred_files);
 		rprintf(FINFO,"Total file size: %.0f bytes\n",
 			(double)stats.total_size);
@@ -206,18 +214,12 @@
 		rprintf(FINFO,"Total bytes sent: %.0f\n",
 			(double)total_written);
 		rprintf(FINFO,"Total bytes received: %.0f\n",
 			(double)total_read);
 	}
 
-	fflush(stdout);
-	fflush(stderr);
-}
-
-static void output_summary(void)
-{
 	if (verbose || do_stats) {
 		rprintf(FINFO,
 			"\nsent %.0f bytes  received %.0f bytes  %.2f bytes/sec\n",
 			(double)total_written, (double)total_read,
 			(total_written + total_read)/(0.5 + (endtime - starttime)));
 		rprintf(FINFO, "total size is %.0f  speedup is %.2f\n",
@@ -288,13 +290,13 @@
 		cmd = strdup(cmd);
 		if (!cmd)
 			goto oom;
 
 		for (tok = strtok(cmd, " "); tok; tok = strtok(NULL, " ")) {
 			/* Comparison leaves rooms for server_options(). */
-			if (argc >= MAX_ARGS - 100) {
+			if (argc >= MAX_ARGS - MAX_SERVER_ARGS) {
 				rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
 			args[argc++] = tok;
 		}
 
@@ -588,13 +590,13 @@
 		while (1)
 			msleep(20);
 	}
 
 	am_generator = 1;
 	close_multiplexing_in();
-	if (write_batch)
+	if (write_batch && !am_server)
 		stop_write_batch();
 
 	close(error_pipe[1]);
 	if (f_in != f_out)
 		close(f_in);
 
@@ -761,13 +763,13 @@
 		if (!filesfrom_host)
 			set_msg_fd_in(f_in);
 		send_filter_list(f_out);
 		if (filesfrom_host)
 			filesfrom_fd = f_in;
 
-		if (write_batch)
+		if (write_batch && !am_server)
 			start_write_batch(f_out);
 		flist = send_file_list(f_out, argc, argv);
 		set_msg_fd_in(-1);
 		if (verbose > 3)
 			rprintf(FINFO,"file list sent\n");
 		the_file_list = flist;
@@ -799,26 +801,25 @@
 
 	if (filesfrom_fd >= 0) {
 		io_set_filesfrom_fds(filesfrom_fd, f_out);
 		filesfrom_fd = -1;
 	}
 
-	if (write_batch)
+	if (write_batch && !am_server)
 		start_write_batch(f_in);
 	flist = recv_file_list(f_in);
-	if (!flist || flist->count == 0) {
-		rprintf(FINFO, "client: nothing to do: "
-			"perhaps you need to specify some filenames or "
-			"the --recursive option?\n");
-		exit_cleanup(0);
-	}
 	the_file_list = flist;
 
-	local_name = get_local_name(flist,argv[0]);
+	if (flist && flist->count > 0) {
+		local_name = get_local_name(flist, argv[0]);
 
-	status2 = do_recv(f_in,f_out,flist,local_name);
+		status2 = do_recv(f_in, f_out, flist, local_name);
+	} else {
+		handle_stats(-1);
+		output_summary();
+	}
 
 	if (pid != -1) {
 		if (verbose > 3)
 			rprintf(FINFO,"client_run2 waiting on %d\n", (int) pid);
 		io_flush(FULL_FLUSH);
 		wait_process(pid, &status);
@@ -1112,21 +1113,25 @@
 	signal(SIGTERM,SIGNAL_CAST sig_int);
 
 	/* Ignore SIGPIPE; we consistently check error codes and will
 	 * see the EPIPE. */
 	signal(SIGPIPE, SIG_IGN);
 
+#if defined CONFIG_LOCALE && defined HAVE_SETLOCALE
+	setlocale(LC_CTYPE, "");
+#endif
+
 	/* Initialize push_dir here because on some old systems getcwd
 	 * (implemented by forking "pwd" and reading its output) doesn't
 	 * work when there are other child processes.  Also, on all systems
 	 * that implement getcwd that way "pwd" can't be found after chroot. */
 	push_dir(NULL);
 
 	init_flist();
 
-	if (write_batch || read_batch) {
+	if ((write_batch || read_batch) && !am_server) {
 		if (write_batch)
 			write_batch_shell_file(orig_argc, orig_argv, argc);
 
 		if (read_batch && strcmp(batch_name, "-") == 0)
 			batch_fd = STDIN_FILENO;
 		else {
@@ -1139,12 +1144,14 @@
 				full_fname(batch_name));
 			exit_cleanup(RERR_FILEIO);
 		}
 		if (read_batch)
 			read_stream_flags(batch_fd);
 	}
+	if (write_batch < 0)
+		dry_run = 1;
 
 	if (am_daemon && !am_server)
 		return daemon_main();
 
 	if (argc < 1) {
 		usage(FERROR);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/NEWS	2005-03-31 03:41:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/NEWS	2005-06-02 11:54:45.000000000 +0800
@@ -1,384 +1,181 @@
-NEWS for rsync 2.6.4 (30 March 2005)
-Protocol: 29 (changed)
-Changes since 2.6.3:
+NEWS for rsync 2.6.5 (1 Jun 2005)
+Protocol: 29 (unchanged)
+Changes since 2.6.4:
 
   OUTPUT CHANGES:
 
-    - When rsync deletes a directory and outputs a verbose message about
-      it, it now appends a trailing slash to the name instead of (only
-      sometimes) outputting a preceding "directory " string.
-
-    - The --stats output will contain file-list time-statistics if both
-      sides are 2.6.4, or if the local side is 2.6.4 and the files are
-      being pushed (since the stats come from the sending side).
-      (Requires protocol 29 for a pull.)
-
-    - The "%o" (operation) log-format escape now has a third value (besides
-      "send" and "recv"):  "del." (with trailing dot to make it 4 chars).
-      This changes the way deletions are logged in the daemon's log file.
-
-    - When the --log-format option is combined with --verbose, rsync now
-      avoids outputting the name of the file twice in most circumstances.
-      As long as the --log-format item does not refer to any post-transfer
-      items (such as %b or %c), the --log-format message is output prior to
-      the transfer, so --verbose is now the equivalent of a --log-format of
-      '%n%L' (which outputs the name and any link info).  If the log output
-      must occur after the transfer to be complete, the only time the name
-      is also output prior to the transfer is when --progress was specified
-      (so that the name will precede the progress stats, and the full
-      --log-format output will come after).
-  
+    - Non-printable chars in filenames are now output using backslash-
+      escaped characters rather than '?'s.  Any non-printable character is
+      output using 3 digits of octal (e.g. "\n" -> "\012"), and a backslash
+      is now output as "\\".  Rsync also uses your locale setting, which
+      can make it treat fewer high-bit characters as non-printable.
+
+    - If rsync received an empty file-list when pulling files, it would
+      output a "nothing to do" message and exit with a 0 (success) exit
+      status, even if the remote rsync returned an error (it did not do
+      this under the same conditions when pushing files).  This was changed
+      to make the pulling behavior the same as the pushing behavior:  we
+      now do the normal end-of-run outputting (depending on options) and
+      exit with the appropriate exit status.
+
   BUG FIXES:
 
-    - Restore the list-clearing behavior of "!" in a .cvsignore file (2.6.3
-      was only treating it as a special token in an rsync include/exclude
-      file).
-
-    - The combination of --verbose and --dry-run now mentions the full list
-      of changes that would be output without --dry-run.
-
-    - Avoid a mkdir warning when removing a directory in the destination
-      that already exists in the --backup-dir.
-
-    - An OS that has a binary mode for its files (such as cygwin) needed
-      setmode(fd, O_BINARY) called on the temp-file we opened with
-      mkstemp().  (Fix derived from the cygwin's 2.6.3 rsync package.)
-
-    - Fixed a potential hang when verbosity is high, the client side is
-      the sender, and the file-list is large.
-
-    - Fixed a potential protocol-corrupting bug where the generator could
-      merge a message from the receiver into the middle of a multiplexed
-      packet of data if only part of that data had been written out to the
-      socket when the message from the generator arrived.
-
-    - We now check if the OS doesn't support using mknod() for creating
-      FIFOs and sockets, and compile-in some compatibility code using
-      mkfifo() and socket() when necessary.
-
-    - Fixed an off-by-one error in the handling of --max-delete=N.  Also,
-      if the --max-delete limit is exceeded during a run, we now output a
-      warning about this at the end of the run and exit with a new error
-      code (25).
-
-    - One place in the code wasn't checking if fork() failed.
-
-    - The "ignore nonreadable" daemon parameter used to erroneously affect
-      readable symlinks that pointed to a non-existent file.
-
-    - If the OS does not have lchown() and a chown() of a symlink will
-      affect the referent of a symlink (as it should), we no longer try
-      to set the user and group of a symlink.
-
-    - The generator now properly runs the hard-link loop and the dir-time
-      rewriting loop after we're sure that the redo phase is complete.
-
-    - When --backup was specified with --partial-dir=DIR, where DIR is a
-      relative path, the backup code was erroneously trying to backup a
-      file that was put into the partial-dir.
-
-    - If a file gets resent in a single transfer and the --backup option is
-      enabled along with --inplace, rsync no longer performs a duplicate
-      backup (it used to overwrite the first backup with the failed file).
-
-    - One call to flush_write_file() was not being checked for an error.
-
-    - The --no-relative option was not being sent from the client to a
-      server sender.
-
-    - If an rsync daemon specified "dont compress = ..." for a file and the
-      client tried to specify --compress, the libz code was not handling a
-      compression level of 0 properly.  This could cause a transfer failure
-      if the block-size for a file was large enough (e.g. rsync might have
-      exited with an error for large files).
-
-    - Fixed a bug that would sometimes surface when using --compress and
-      sending a file with a block-size larger than 64K (either manually
-      specified, or computed due to the file being really large).  Prior
-      versions of rsync would sometimes fail to decompress the data
-      properly, and thus the transferred file would fail its verification.
-
-    - If a daemon can't open the specified log file (i.e. syslog is not
-      being used), die without crashing.  We also output an error about
-      the failure on stderr (which will only be seen if --no-detach was
-      specified) and exit with a new error code (6).
-
-    - A local transfer no longer duplicates all its include/exclude options
-      (since the forked process already has a copy of the exclude list,
-      there's no need to send them a set of duplicates).
-
-    - When --progress is specified, the output of items that the generator
-      is creating (e.g. dirs, symlinks) is now integrated into the progress
-      output without overlapping it.  (Requires protocol 29.)
-
-    - When --timeout is specified, lulls that occur in the transfer while
-      the generator is doing work that does not generate socket traffic
-      (looking for changed files, deleting files, doing directory-time
-      touch-ups, etc.) will cause a new keep-alive packet to be sent that
-      should keep the transfer going as long as the generator continues to
-      make progress.  (Requires protocol 29.)
-
-    - The stat size of a device is not added to the total file size of the
-      items in the transfer (the size might be undefined on some OSes).
-
-    - Fixed a problem with refused-option messages sometimes not making it
-      back to the client side when a remote --files-from was in effect and
-      the daemon was the receiver.
-
-    - The --compare-dest option was not updating a file that differred in
-      (the preserved) attributes from the version in the compare-dest DIR.
-
-    - When rsync is copying files into a write-protected directory, fixed
-      the change-report output for the directory so that we don't report
-      an identical directory as changed.
+    - A crash bug was fixed when a daemon had its "path" set to "/", did
+      not have chroot enabled, and used some anchored excludes in the
+      rsyncd.conf file.
 
-  ENHANCEMENTS:
+    - Fixed a bug in the transfer of a single file when -H is specified
+      (rsync would either infinite loop or perhaps crash).
 
-    - Rsync now supports popt's option aliases, which means that you can
-      use /etc/popt and/or ~/.popt to create your own option aliases.
+    - Fixed a case where the generator might try (and fail) to tweak the
+      write-permissions of a read-only directory in list-only mode (this
+      only caused an annoying warning message).
 
-    - Added the --delete-during (--del) option which will delete files
-      from the receiving side incrementally as each directory in the
-      transfer is being processed.  This makes it more efficient than the
-      default, before-the-transfer behavior, which is now also available as
-      --delete-before (and is still the default --delete-WHEN option that
-      will be chosen if --delete or --delete-excluded is specified without
-      a --delete-WHEN choice).  All the --del* options infer --delete, so
-      an rsync daemon that refuses "delete" will still refuse to allow any
-      file-deleting options (including the new --remove-sent-files option).
-
-    - All the --delete-WHEN options are now more memory efficient:
-      Previously an duplicate set of file-list objects was created on the
-      receiving side for the entire destination hierarchy.  The new
-      algorithm only creates one directory of objects at a time (for files
-      inside the transfer).
-
-    - Added the --copy-dest option, which works like --link-dest except
-      that it locally copies identical files instead of hard-linking them.
-
-    - Added support for specifying multiple --compare-dest, --copy-dest, or
-      --link-dest options, but only of a single type. (Promoted from the
-      patches dir and enhanced.) (Requires protocol 29.)
-
-    - Added the --max-size option. (Promoted from the patches dir.)
-
-    - The daemon-mode options are now separated from the normal rsync
-      options so that they can't be mixed together.  This makes it
-      impossible to start a daemon that has improper default option values
-      (which could cause problems when a client connects, such as hanging
-      or crashing).
-
-    - The --bwlimit option may now be used in combination with --daemon
-      to specify both a default value for the daemon side and a value
-      that cannot be exceeded by a user-specified --bwlimit option.
-
-    - Added the "port" parameter to the rsyncd.conf file. (Promoted from
-      the patches dir.)  Also added "address".  The command-line options
-      take precedence over a config-file option, as expected.
-
-    - In _exit_cleanup(): when we are exiting with a partially-received
-      file, we now flush any data in the write-cache before closing the
-      partial file.
-
-    - The --inplace support was enhanced to work with --compare-dest,
-      --link-dest, and (the new) --copy-dest options. (Requires protocol
-      29.)
-
-    - Added the --dirs (-d) option for an easier way to copy directories
-      without recursion.
-
-    - Added the --list-only option, which is mainly a way for the client to
-      put the server into listing mode without needing to resort to any
-      internal option kluges (e.g. the age-old use of "-r --exclude="/*/*"
-      for a non-recursive listing).  This option is used automatically
-      (behind the scenes) when a modern rsync speaks to a modern daemon,
-      but may also be specified manually if you want to force the use of
-      the --list-only option over a remote-shell connection.
-
-    - Added the --omit-dir-times (-O) option, which will avoid updating
-      the modified time for directories when --times was specified.  This
-      option will avoid an extra pass through the file-list at the end of
-      the transfer (to tweak all the directory times), which may provide
-      an appreciable speedup for a really large transfer. (Promoted from
-      the patches dir.)
-
-    - Added the --filter (-f) option and its helper option, -F.  Filter
-      rules are an extension to the existing include/exclude handling
-      that also supports nested filter files as well as per-directory
-      filter files (like .cvsignore, but with full filter-rule parsing).
-      This new option was chosen in order to ensure that all existing
-      include/exclude processing remained 100% compatible with older
-      versions.  Protocol 29 is needed for full filter-rule support, but
-      backward-compatible rules work with earlier protocol versions.
-      (Promoted from the patches dir and enhanced.)
-
-    - Added the --delay-updates option that puts all updated files into
-      a temporary directory (by default ".~tmp~", but settable via the
-      --partial-dir=DIR option) until the end of the transfer.  This
-      makes the updates a little more atomic for a large transfer.
-
-    - If rsync is put into the background, any output from --progress is
-      reduced.
-
-    - Documented the "max verbosity" setting for rsyncd.conf.  (This
-      setting was added a couple releases ago, but left undocumented.)
-
-    - The sender and the generator now double-check the file-list index
-      they are given, and refuse to try to do a file transfer on a
-      non-file index (since that would indicate that something had gone
-      very wrong).
-
-    - Added the --itemize-changes (-i) option, which is a way to output a
-      more detailed list of what files changed and in what way.  The effect
-      is the same as specifying a --log-format of "%i %n%L" (see both the
-      rsync and rsyncd.conf manpages).  Works with --dry-run too.
-
-    - Added the --fuzzy (-y) option, which attempts to find a basis file
-      for a file that is being created from scratch.  The current algorithm
-      only looks in the destination directory for the created file, but it
-      does attempt to find a match based on size/mod-time (in case the file
-      was renamed with no other changes) as well as based on a fuzzy
-      name-matching algorithm.  This option requires protocol 29 because it
-      needs the new file-sorting order.  (Promoted from patches dir and
-      enhanced.) (Requires protocol 29.)
-
-    - Added the --remove-sent-files option, which lets you move files
-      between systems.
-
-    - The hostname in HOST:PATH or HOST::PATH may now be an IPv6 literal
-      enclosed in '[' and ']' (e.g. "[::1]").  (We already allowed IPv6
-      literals in the rsync://HOST:PORT/PATH format.)
-
-    - When rsync recurses to build the file list, it no longer keeps open
-      one or more directory handles from the dir's parent dirs.
-
-    - When building under windows, the default for --daemon is now to
-      avoid detaching, requiring the new --detach option to force rsync
-      to detach.
-
-    - The --dry-run option can now be combined with either --write-batch or
-      --read-batch, allowing you to run a do-nothing test command to see
-      what would happen without --dry-run.
-
-    - The daemon's "read only" config item now sets an internal read_only
-      variable that makes extra sure that no write/delete calls on the
-      read-only side can succeed.
-
-    - The log-format % escapes can now have a numeric field width in
-      between the % and the escape letter (e.g. "%-40n %08p").
-
-    - Improved the option descriptions in the --help text.
-
-  SUPPORT FILES:
-
-    - Added atomic-rsync to the support dir: a perl script that will
-      transfer some files using rsync, and then move the updated files into
-      place all at once at the end of the transfer.  Only works when
-      pulling, and uses --link-dest and a parallel hierarchy of files to
-      effect its update.
-
-    - Added mnt-excl to the support dir: a perl script that takes the
-      /proc/mounts file and translates it into a set of excludes that will
-      exclude all mount points (even mapped mounts to the same disk).  The
-      excludes are made relative to the specified source dir and properly
-      anchored.
-
-    - Added savetransfer.c to the support dir: a C program that can make
-      a copy of all the data that flows over the wire.  This lets you test
-      for data corruption (by saving the data on both the sending side and
-      the receiving side) and provides one way to debug a protocol error.
-
-    - Added rrsync to the support dir: this is an updated version of Joe
-      Smith's restricted rsync perl script.  This helps to ensure that only
-      certain rsync commands can be run by an ssh invocation.
+    - If --compare-dest or --link-dest uses a locally-copied file as the
+      basis for an updated version, log this better when --verbose or -i
+      is in effect.
 
-  INTERNAL:
+    - Fixed the accidental disabling of --backup during the --delete-after
+      processing.
+
+    - Restored the ability to use the --address option in client mode (in
+      addition to its use in daemon mode).
+
+    - Make sure that some temporary progress information from the delete
+      processing does not get left on the screen when it is followed by a
+      newline.
+
+    - When --existing skips a directory with extra verbosity, refer to it
+      as a "directory", not a "file".
+
+    - When transferring a single file to a different-named file, any
+      generator messages that are source-file related no longer refer to
+      the file by the destination filename.
+
+    - Fixed a bug where hard-linking a group of files might fail if the
+      generator hasn't created a needed destination directory yet.
+
+    - Fixed a bug where a hard-linked group of files that is newly-linked
+      to a file in a --link-dest dir doesn't link the files from the rest
+      of the cluster.
+
+    - When deleting files with the --one-file-system (-x) option set, rsync
+      no longer tries to remove files from inside a mount-point on the
+      receiving side.  Also, we don't complain about being unable to remove
+      the mount-point dir.
+
+    - Fixed a compatibility problem when using --cvs-ignore (-C) and
+      sending files to an older rsync without using --delete.
+
+    - Make sure that a "- !" or "+ !" include/exclude pattern does not
+      trigger the list-clearing action that is reserved for "!".
+
+    - Avoid a timeout in the generator when the sender/receiver aren't
+      handling the generator's checksum output quickly enough.
+
+    - Fixed the omission of some directories in the delete processing when
+      --relative (-R) was combined with a source path that had a trailing
+      slash.
+
+    - Fixed a case where rsync would erroneously delete some files and then
+      re-transfer them when the options --relative (-R) and --recursive
+      (-r) were both enabled (along with --delete) and a source path had a
+      trailing slash.
+
+    - Make sure that --max-size doesn't affect a device or a symlink.
 
-    - Added better checking of the checksum-header values that come over
-      the socket.
+    - Make sure that a system with a really small MAXPATHLEN does not cause
+      the buffers in readfd_unbuffered() to be too small to receive normal
+      messages.  (This mainly affected Cygwin.)
 
-    - Merged a variety of file-deleting functions into a single function so
-      that it is easier to maintain.
+    - If a source pathname ends with a filename of "..", treat it as if
+      "../" had been specified (so that we don't copy files to the parent
+      dir of the destination).
 
-    - Improved the type of some variables (particularly blocksize vars) for
-      consistency and proper size.
+    - If --delete is combined with a file-listing rsync command (i.e. no
+      transfer is happening), avoid outputting a warning that we couldn't
+      delete anything.
 
-    - Got rid of the uint64 type (which we didn't need).
-
-    - Use a slightly more compatible set of core #include directives.
-
-    - Defined int32 in a way that ensures that the build dies if we can't
-      find a variable with at least 32 bits.
-
-  PROTOCOL DIFFERENCES FOR VERSION 29:
-
-    - A 16-bit flag-word is transmitted after every file-list index.  This
-      indicates what is changing between the sender and the receiver.  The
-      generator now transmits an index and a flag-word to indicate when
-      dirs and symlinks have changed (instead of producing a message),
-      which makes the outputting of the information more consistent and
-      less prone to screen corruption (because the local receiver/sender is
-      now outputting all the file-change info messages).
-
-    - If a file is being hard-linked, the ITEM_XNAME_FOLLOWS bit is enabled
-      in the flag-word and the name of the file that was linked immediately
-      follows in vstring format (see below).
-
-    - If a file is being transferred with an alternate-basis file, the
-      ITEM_BASIS_TYPE_FOLLOWS bit is enabled in the flag-word and a single
-      byte follows, indicating what type of basis file was chosen.  If that
-      indicates that a fuzzy-match was selected, the ITEM_XNAME_FOLLOWS bit
-      is set in the flag-word and the name of the match in vstring format
-      follows the basis byte.  A vstring is a variable length string that
-      has its size written prior to the string, and no terminating null.
-      If the string is from 1-127 bytes, the length is a single byte.  If
-      it is from 128-32767 bytes, the length is written as ((len >> 8) |
-      0x80) followed by (len % 0x100).
-
-    - The sending of exclude names is done using filter-rule syntax.  This
-      means that all names have a prefixed rule indicator, even excludes
-      (which used to be sent as a bare pattern, when possible).  The -C
-      option will include the per-dir .cvsignore merge file in the list of
-      filter rules so it is positioned correctly (unlike in some older
-      transfer scenarios).
-
-    - Rsync sorts the filename list in a different way: it sorts the subdir
-      names after the non-subdir names for each dir's contents, and it
-      always puts a dir's contents immediately after the dir's name in the
-      list.  (Previously an item named "foo.txt" would sort in between
-      directory "foo/" and "foo/bar".)
-
-    - When talking to a protocol 29 rsync daemon, a list-only request
-      is able to note this before the options are sent over the wire and
-      the new --list-only option is included in the options.
-
-    - When the --stats bytes are sent over the wire (or stored in a batch),
-      they now include two elapsed-time values: one for how long it took to
-      build the file-list, and one for how long it took to send it over the
-      wire (each expressed in thousandths of a second).
-
-    - When --delete-excluded is specified with some filter rules (AKA
-      excludes), a client sender will now initiate a send of the rules to
-      the receiver (older protocols used to omit the sending of excludes in
-      this situation since there were no receiver-specific rules that
-      survived --delete-excluded back then).  Note that, as with all the
-      filter-list sending, only items that are significant to the other
-      side will actually be sent over the wire, so the filter-rule list
-      that is sent in this scenario is often empty.
-
-    - An index equal to the file-list count is sent as a keep-alive packet
-      from the generator to the sender, which then forwards it on to the
-      receiver.  This normally invalid index is only a valid keep-alive
-      packet if the 16-bit flag-word that follows it contains a single bit
-      (ITEM_IS_NEW, which is normally an illegal flag to appear alone).
-
-    - A protocol-29 batch file includes a bit for the setting of the --dirs
-      option and for the setting of the --compress option.  Also, the shell
-      script created by --write-batch will use the --filter option instead
-      of --exclude-from to capture any filter rules.
+    - If --stats is specified with --delete-after, ensure that all the
+      "deleting" messages are output before the statistics.
+
+    - Improved one "if" in the deletion code that was only checking errno
+      for ENOTEMPTY when it should have also been checking for EEXIST (for
+      compatibility with OS variations).
+
+  ENHANCEMENTS:
+
+    - Added the --only-write-batch=FILE option that may be used (instead
+      of --write-batch=FILE) to create a batch file without doing any
+      actual updating of the destination.  This allows you to divert all
+      the file-updating data away from a slow data link (as long as you
+      are pushing the data to the remote server when creating the batch).
+
+    - When the generator is taking a long time to fill up its output buffer
+      (e.g. if the transferred files are few, small, or missing), it now
+      periodically flushes the output buffer so that the sender/receiver
+      can get started on the files sooner rather than later.
+
+    - Improved the keep-alive code to handle a long silence between the
+      sender and the receiver that can occur when the sender is receiving
+      the checksum data for a large file.
+
+    - Improved the auth-errors that are logged by the daemon to include
+      some information on why the authorization failed:  wrong user,
+      password mismatch, etc.  (The client-visible message is unchanged!)
+
+    - Improved the client's handling of an "@ERROR" from a daemon so that
+      it does not complain about an unexpectedly closed socket (since we
+      really did expect the socket to close).
+
+    - If the daemon can't open the log-file specified in rsyncd.conf, fall
+      back to using syslog and log an appropriate warning.  This is better
+      than what was typically a totally silent (and fatal) failure (since a
+      daemon is not usually run with the --no-detach option that was
+      necessary to see the error on stderr).
+
+    - The man pages now consistently refer to an rsync daemon as a "daemon"
+      instead of a "server" (to distinguish it from the server process in a
+      non-daemon transfer).
+
+    - Made a small change to the rrsync script (restricted rsync -- in the
+      support dir) to make a read-only server reject all --remove-* options
+      when sending files (to future-proof it against the possibility of
+      other similar options being added at some point).
+
+  INTERNAL:
+
+    - Rsync now calls setlocale(LC_CTYPE, "").  This enables isprint() to
+      better discern which filename characters need to be escaped in
+      messages (which should result in fewer escaped characters in some
+      locales).
+
+    - Improved the naming of the log-file open/reopen/close functions.
+
+    - Removed some protocol-compatibility code that was only needed to help
+      someone running a pre-release of 2.6.4.
 
   BUILD CHANGES:
 
-    - Handle an operating system that use mkdev() in place of makedev().
+    - Added configure option "--disable-locale" to disable any use of
+      setlocale() in the binary.
+
+    - Fixed a bug in the SUPPORT{,_HARD}_LINKS #defines which prevented
+      rsync from being built without symlink or hard-link support.
+
+    - Only #define HAVE_REMSH if it is going to be set to 1.
+
+    - Configure now disables the use of mkstemp() under HP-UX (since they
+      refuse to fix its broken handling of large files).
+
+    - Configure now explicitly checks for the lseek64() function so that
+      the code can use HAVE_LSEEK64 instead of inferring lseek64()'s
+      presence based on the presence of the off64_t type.
+
+    - Configure no longer mentions the change in the default remote-shell
+      (from rsh to ssh) that occurred for the 2.6.0 release.
+
+    - Some minor enhancements to the test scripts.
 
-    - Improved configure to better handle cross-compiling.
+    - Added a few new *.diff files to the patches dir, including a patch
+      that enables the optional copying of extended attributes.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/OLDNEWS	2005-03-29 14:15:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/OLDNEWS	2005-06-02 11:54:45.000000000 +0800
@@ -1,6 +1,397 @@
+NEWS for rsync 2.6.4 (30 March 2005)
+Protocol: 29 (changed)
+Changes since 2.6.3:
+
+  OUTPUT CHANGES:
+
+    - When rsync deletes a directory and outputs a verbose message about
+      it, it now appends a trailing slash to the name instead of (only
+      sometimes) outputting a preceding "directory " string.
+
+    - The --stats output will contain file-list time-statistics if both
+      sides are 2.6.4, or if the local side is 2.6.4 and the files are
+      being pushed (since the stats come from the sending side).
+      (Requires protocol 29 for a pull.)
+
+    - The "%o" (operation) log-format escape now has a third value (besides
+      "send" and "recv"):  "del." (with trailing dot to make it 4 chars).
+      This changes the way deletions are logged in the daemon's log file.
+
+    - When the --log-format option is combined with --verbose, rsync now
+      avoids outputting the name of the file twice in most circumstances.
+      As long as the --log-format item does not refer to any post-transfer
+      items (such as %b or %c), the --log-format message is output prior to
+      the transfer, so --verbose is now the equivalent of a --log-format of
+      '%n%L' (which outputs the name and any link info).  If the log output
+      must occur after the transfer to be complete, the only time the name
+      is also output prior to the transfer is when --progress was specified
+      (so that the name will precede the progress stats, and the full
+      --log-format output will come after).
+
+    - Non-printable characters in filenames are replaced with a '?' to
+      avoid corrupting the screen or generating empty lines in the output.
+  
+  BUG FIXES:
+
+    - Restore the list-clearing behavior of "!" in a .cvsignore file (2.6.3
+      was only treating it as a special token in an rsync include/exclude
+      file).
+
+    - The combination of --verbose and --dry-run now mentions the full list
+      of changes that would be output without --dry-run.
+
+    - Avoid a mkdir warning when removing a directory in the destination
+      that already exists in the --backup-dir.
+
+    - An OS that has a binary mode for its files (such as cygwin) needed
+      setmode(fd, O_BINARY) called on the temp-file we opened with
+      mkstemp().  (Fix derived from the cygwin's 2.6.3 rsync package.)
+
+    - Fixed a potential hang when verbosity is high, the client side is
+      the sender, and the file-list is large.
+
+    - Fixed a potential protocol-corrupting bug where the generator could
+      merge a message from the receiver into the middle of a multiplexed
+      packet of data if only part of that data had been written out to the
+      socket when the message from the generator arrived.
+
+    - We now check if the OS doesn't support using mknod() for creating
+      FIFOs and sockets, and compile-in some compatibility code using
+      mkfifo() and socket() when necessary.
+
+    - Fixed an off-by-one error in the handling of --max-delete=N.  Also,
+      if the --max-delete limit is exceeded during a run, we now output a
+      warning about this at the end of the run and exit with a new error
+      code (25).
+
+    - One place in the code wasn't checking if fork() failed.
+
+    - The "ignore nonreadable" daemon parameter used to erroneously affect
+      readable symlinks that pointed to a non-existent file.
+
+    - If the OS does not have lchown() and a chown() of a symlink will
+      affect the referent of a symlink (as it should), we no longer try
+      to set the user and group of a symlink.
+
+    - The generator now properly runs the hard-link loop and the dir-time
+      rewriting loop after we're sure that the redo phase is complete.
+
+    - When --backup was specified with --partial-dir=DIR, where DIR is a
+      relative path, the backup code was erroneously trying to backup a
+      file that was put into the partial-dir.
+
+    - If a file gets resent in a single transfer and the --backup option is
+      enabled along with --inplace, rsync no longer performs a duplicate
+      backup (it used to overwrite the first backup with the failed file).
+
+    - One call to flush_write_file() was not being checked for an error.
+
+    - The --no-relative option was not being sent from the client to a
+      server sender.
+
+    - If an rsync daemon specified "dont compress = ..." for a file and the
+      client tried to specify --compress, the libz code was not handling a
+      compression level of 0 properly.  This could cause a transfer failure
+      if the block-size for a file was large enough (e.g. rsync might have
+      exited with an error for large files).
+
+    - Fixed a bug that would sometimes surface when using --compress and
+      sending a file with a block-size larger than 64K (either manually
+      specified, or computed due to the file being really large).  Prior
+      versions of rsync would sometimes fail to decompress the data
+      properly, and thus the transferred file would fail its verification.
+
+    - If a daemon can't open the specified log file (i.e. syslog is not
+      being used), die without crashing.  We also output an error about
+      the failure on stderr (which will only be seen if --no-detach was
+      specified) and exit with a new error code (6).
+
+    - A local transfer no longer duplicates all its include/exclude options
+      (since the forked process already has a copy of the exclude list,
+      there's no need to send them a set of duplicates).
+
+    - When --progress is specified, the output of items that the generator
+      is creating (e.g. dirs, symlinks) is now integrated into the progress
+      output without overlapping it.  (Requires protocol 29.)
+
+    - When --timeout is specified, lulls that occur in the transfer while
+      the generator is doing work that does not generate socket traffic
+      (looking for changed files, deleting files, doing directory-time
+      touch-ups, etc.) will cause a new keep-alive packet to be sent that
+      should keep the transfer going as long as the generator continues to
+      make progress.  (Requires protocol 29.)
+
+    - The stat size of a device is not added to the total file size of the
+      items in the transfer (the size might be undefined on some OSes).
+
+    - Fixed a problem with refused-option messages sometimes not making it
+      back to the client side when a remote --files-from was in effect and
+      the daemon was the receiver.
+
+    - The --compare-dest option was not updating a file that differed in
+      (the preserved) attributes from the version in the compare-dest DIR.
+
+    - When rsync is copying files into a write-protected directory, fixed
+      the change-report output for the directory so that we don't report
+      an identical directory as changed.
+
+  ENHANCEMENTS:
+
+    - Rsync now supports popt's option aliases, which means that you can
+      use /etc/popt and/or ~/.popt to create your own option aliases.
+
+    - Added the --delete-during (--del) option which will delete files
+      from the receiving side incrementally as each directory in the
+      transfer is being processed.  This makes it more efficient than the
+      default, before-the-transfer behavior, which is now also available as
+      --delete-before (and is still the default --delete-WHEN option that
+      will be chosen if --delete or --delete-excluded is specified without
+      a --delete-WHEN choice).  All the --del* options infer --delete, so
+      an rsync daemon that refuses "delete" will still refuse to allow any
+      file-deleting options (including the new --remove-sent-files option).
+
+    - All the --delete-WHEN options are now more memory efficient:
+      Previously an duplicate set of file-list objects was created on the
+      receiving side for the entire destination hierarchy.  The new
+      algorithm only creates one directory of objects at a time (for files
+      inside the transfer).
+
+    - Added the --copy-dest option, which works like --link-dest except
+      that it locally copies identical files instead of hard-linking them.
+
+    - Added support for specifying multiple --compare-dest, --copy-dest, or
+      --link-dest options, but only of a single type. (Promoted from the
+      patches dir and enhanced.) (Requires protocol 29.)
+
+    - Added the --max-size option. (Promoted from the patches dir.)
+
+    - The daemon-mode options are now separated from the normal rsync
+      options so that they can't be mixed together.  This makes it
+      impossible to start a daemon that has improper default option values
+      (which could cause problems when a client connects, such as hanging
+      or crashing).
+
+    - The --bwlimit option may now be used in combination with --daemon
+      to specify both a default value for the daemon side and a value
+      that cannot be exceeded by a user-specified --bwlimit option.
+
+    - Added the "port" parameter to the rsyncd.conf file. (Promoted from
+      the patches dir.)  Also added "address".  The command-line options
+      take precedence over a config-file option, as expected.
+
+    - In _exit_cleanup(): when we are exiting with a partially-received
+      file, we now flush any data in the write-cache before closing the
+      partial file.
+
+    - The --inplace support was enhanced to work with --compare-dest,
+      --link-dest, and (the new) --copy-dest options. (Requires protocol
+      29.)
+
+    - Added the --dirs (-d) option for an easier way to copy directories
+      without recursion.  Any directories that are encountered are created
+      on the destination.  Specifying a directory with a trailing slash
+      copies its immediate contents to the destination.
+
+    - The --files-from option now implies --dirs (-d).
+
+    - Added the --list-only option, which is mainly a way for the client to
+      put the server into listing mode without needing to resort to any
+      internal option kluges (e.g. the age-old use of "-r --exclude="/*/*"
+      for a non-recursive listing).  This option is used automatically
+      (behind the scenes) when a modern rsync speaks to a modern daemon,
+      but may also be specified manually if you want to force the use of
+      the --list-only option over a remote-shell connection.
+
+    - Added the --omit-dir-times (-O) option, which will avoid updating
+      the modified time for directories when --times was specified.  This
+      option will avoid an extra pass through the file-list at the end of
+      the transfer (to tweak all the directory times), which may provide
+      an appreciable speedup for a really large transfer. (Promoted from
+      the patches dir.)
+
+    - Added the --filter (-f) option and its helper option, -F.  Filter
+      rules are an extension to the existing include/exclude handling
+      that also supports nested filter files as well as per-directory
+      filter files (like .cvsignore, but with full filter-rule parsing).
+      This new option was chosen in order to ensure that all existing
+      include/exclude processing remained 100% compatible with older
+      versions.  Protocol 29 is needed for full filter-rule support, but
+      backward-compatible rules work with earlier protocol versions.
+      (Promoted from the patches dir and enhanced.)
+
+    - Added the --delay-updates option that puts all updated files into
+      a temporary directory (by default ".~tmp~", but settable via the
+      --partial-dir=DIR option) until the end of the transfer.  This
+      makes the updates a little more atomic for a large transfer.
+
+    - If rsync is put into the background, any output from --progress is
+      reduced.
+
+    - Documented the "max verbosity" setting for rsyncd.conf.  (This
+      setting was added a couple releases ago, but left undocumented.)
+
+    - The sender and the generator now double-check the file-list index
+      they are given, and refuse to try to do a file transfer on a
+      non-file index (since that would indicate that something had gone
+      very wrong).
+
+    - Added the --itemize-changes (-i) option, which is a way to output a
+      more detailed list of what files changed and in what way.  The effect
+      is the same as specifying a --log-format of "%i %n%L" (see both the
+      rsync and rsyncd.conf manpages).  Works with --dry-run too.
+
+    - Added the --fuzzy (-y) option, which attempts to find a basis file
+      for a file that is being created from scratch.  The current algorithm
+      only looks in the destination directory for the created file, but it
+      does attempt to find a match based on size/mod-time (in case the file
+      was renamed with no other changes) as well as based on a fuzzy
+      name-matching algorithm.  This option requires protocol 29 because it
+      needs the new file-sorting order.  (Promoted from patches dir and
+      enhanced.) (Requires protocol 29.)
+
+    - Added the --remove-sent-files option, which lets you move files
+      between systems.
+
+    - The hostname in HOST:PATH or HOST::PATH may now be an IPv6 literal
+      enclosed in '[' and ']' (e.g. "[::1]").  (We already allowed IPv6
+      literals in the rsync://HOST:PORT/PATH format.)
+
+    - When rsync recurses to build the file list, it no longer keeps open
+      one or more directory handles from the dir's parent dirs.
+
+    - When building under windows, the default for --daemon is now to
+      avoid detaching, requiring the new --detach option to force rsync
+      to detach.
+
+    - The --dry-run option can now be combined with either --write-batch or
+      --read-batch, allowing you to run a do-nothing test command to see
+      what would happen without --dry-run.
+
+    - The daemon's "read only" config item now sets an internal read_only
+      variable that makes extra sure that no write/delete calls on the
+      read-only side can succeed.
+
+    - The log-format % escapes can now have a numeric field width in
+      between the % and the escape letter (e.g. "%-40n %08p").
+
+    - Improved the option descriptions in the --help text.
+
+  SUPPORT FILES:
+
+    - Added atomic-rsync to the support dir: a perl script that will
+      transfer some files using rsync, and then move the updated files into
+      place all at once at the end of the transfer.  Only works when
+      pulling, and uses --link-dest and a parallel hierarchy of files to
+      effect its update.
+
+    - Added mnt-excl to the support dir: a perl script that takes the
+      /proc/mounts file and translates it into a set of excludes that will
+      exclude all mount points (even mapped mounts to the same disk).  The
+      excludes are made relative to the specified source dir and properly
+      anchored.
+
+    - Added savetransfer.c to the support dir: a C program that can make
+      a copy of all the data that flows over the wire.  This lets you test
+      for data corruption (by saving the data on both the sending side and
+      the receiving side) and provides one way to debug a protocol error.
+
+    - Added rrsync to the support dir: this is an updated version of Joe
+      Smith's restricted rsync perl script.  This helps to ensure that only
+      certain rsync commands can be run by an ssh invocation.
+
+  INTERNAL:
+
+    - Added better checking of the checksum-header values that come over
+      the socket.
+
+    - Merged a variety of file-deleting functions into a single function so
+      that it is easier to maintain.
+
+    - Improved the type of some variables (particularly blocksize vars) for
+      consistency and proper size.
+
+    - Got rid of the uint64 type (which we didn't need).
+
+    - Use a slightly more compatible set of core #include directives.
+
+    - Defined int32 in a way that ensures that the build dies if we can't
+      find a variable with at least 32 bits.
+
+  PROTOCOL DIFFERENCES FOR VERSION 29:
+
+    - A 16-bit flag-word is transmitted after every file-list index.  This
+      indicates what is changing between the sender and the receiver.  The
+      generator now transmits an index and a flag-word to indicate when
+      dirs and symlinks have changed (instead of producing a message),
+      which makes the outputting of the information more consistent and
+      less prone to screen corruption (because the local receiver/sender is
+      now outputting all the file-change info messages).
+
+    - If a file is being hard-linked, the ITEM_XNAME_FOLLOWS bit is enabled
+      in the flag-word and the name of the file that was linked immediately
+      follows in vstring format (see below).
+
+    - If a file is being transferred with an alternate-basis file, the
+      ITEM_BASIS_TYPE_FOLLOWS bit is enabled in the flag-word and a single
+      byte follows, indicating what type of basis file was chosen.  If that
+      indicates that a fuzzy-match was selected, the ITEM_XNAME_FOLLOWS bit
+      is set in the flag-word and the name of the match in vstring format
+      follows the basis byte.  A vstring is a variable length string that
+      has its size written prior to the string, and no terminating null.
+      If the string is from 1-127 bytes, the length is a single byte.  If
+      it is from 128-32767 bytes, the length is written as ((len >> 8) |
+      0x80) followed by (len % 0x100).
+
+    - The sending of exclude names is done using filter-rule syntax.  This
+      means that all names have a prefixed rule indicator, even excludes
+      (which used to be sent as a bare pattern, when possible).  The -C
+      option will include the per-dir .cvsignore merge file in the list of
+      filter rules so it is positioned correctly (unlike in some older
+      transfer scenarios).
+
+    - Rsync sorts the filename list in a different way: it sorts the subdir
+      names after the non-subdir names for each dir's contents, and it
+      always puts a dir's contents immediately after the dir's name in the
+      list.  (Previously an item named "foo.txt" would sort in between
+      directory "foo/" and "foo/bar".)
+
+    - When talking to a protocol 29 rsync daemon, a list-only request
+      is able to note this before the options are sent over the wire and
+      the new --list-only option is included in the options.
+
+    - When the --stats bytes are sent over the wire (or stored in a batch),
+      they now include two elapsed-time values: one for how long it took to
+      build the file-list, and one for how long it took to send it over the
+      wire (each expressed in thousandths of a second).
+
+    - When --delete-excluded is specified with some filter rules (AKA
+      excludes), a client sender will now initiate a send of the rules to
+      the receiver (older protocols used to omit the sending of excludes in
+      this situation since there were no receiver-specific rules that
+      survived --delete-excluded back then).  Note that, as with all the
+      filter-list sending, only items that are significant to the other
+      side will actually be sent over the wire, so the filter-rule list
+      that is sent in this scenario is often empty.
+
+    - An index equal to the file-list count is sent as a keep-alive packet
+      from the generator to the sender, which then forwards it on to the
+      receiver.  This normally invalid index is only a valid keep-alive
+      packet if the 16-bit flag-word that follows it contains a single bit
+      (ITEM_IS_NEW, which is normally an illegal flag to appear alone).
+
+    - A protocol-29 batch file includes a bit for the setting of the --dirs
+      option and for the setting of the --compress option.  Also, the shell
+      script created by --write-batch will use the --filter option instead
+      of --exclude-from to capture any filter rules.
+
+  BUILD CHANGES:
+
+    - Handle an operating system that use mkdev() in place of makedev().
+
+    - Improved configure to better handle cross-compiling.
 NEWS for rsync 2.6.3 (30 Sep 2004)
 Protocol: 28 (unchanged)
 Changes since 2.6.2:
 
   SECURITY FIXES:
 
@@ -1040,12 +1431,13 @@
     * The existing test.sh script by Phil Hands has been merged into a
       test framework that works from both "make check" and the Samba
       build farm.
 
 Partial Protocol History
 	RELEASE DATE	VER.	DATE OF COMMIT*	PROTOCOL
+	01 Jun 2005	2.6.5			29
 	30 Mar 2005	2.6.4	17 Jan 2005	29
 	30 Sep 2004	2.6.3			28
 	30 Apr 2004	2.6.2			28
 	26 Apr 2004	2.6.1	08 Jan 2004	28
 	01 Jan 2004	2.6.0	10 Apr 2003	27 (MAX=40)
 	04 Dec 2003	2.5.7			26
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/options.c	2005-03-31 08:21:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/options.c	2005-05-19 16:52:17.000000000 +0800
@@ -20,13 +20,12 @@
 
 #include "rsync.h"
 #include "popt.h"
 
 extern int module_id;
 extern int sanitize_paths;
-extern int select_timeout;
 extern struct filter_list_struct filter_list;
 extern struct filter_list_struct server_filter_list;
 
 int make_backups = 0;
 
 /**
@@ -50,12 +49,13 @@
 int preserve_gid = 0;
 int preserve_times = 0;
 int omit_dir_times = 0;
 int update_only = 0;
 int cvs_exclude = 0;
 int dry_run = 0;
+int do_xfers = 1;
 int ignore_times = 0;
 int delete_mode = 0;
 int delete_during = 0;
 int delete_before = 0;
 int delete_after = 0;
 int delete_excluded = 0;
@@ -72,12 +72,13 @@
 int orig_umask = 0;
 int relative_paths = -1;
 int implied_dirs = 1;
 int numeric_ids = 0;
 int force_delete = 0;
 int io_timeout = 0;
+int allowed_lull = 0;
 char *files_from = NULL;
 int filesfrom_fd = -1;
 char *filesfrom_host = NULL;
 int eol_nulls = 0;
 int recurse = 0;
 int xfer_dirs = 0;
@@ -247,13 +248,13 @@
 {
   print_rsync_version(F);
 
   rprintf(F,"\nrsync is a file transfer program capable of efficient remote update\nvia a fast differencing algorithm.\n\n");
 
   rprintf(F,"Usage: rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST\n");
-  rprintf(F,"  or   rsync [OPTION]... [USER@]HOST:SRC DEST\n");
+  rprintf(F,"  or   rsync [OPTION]... [USER@]HOST:SRC [DEST]\n");
   rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... DEST\n");
   rprintf(F,"  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]\n");
   rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\n");
   rprintf(F,"  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n");
   rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\n");
   rprintf(F,"SRC on single-colon remote HOST will be expanded by remote shell\n");
@@ -327,43 +328,45 @@
   rprintf(F,"                             repeated: --filter='- .rsync-filter'\n");
   rprintf(F,"     --exclude=PATTERN       exclude files matching PATTERN\n");
   rprintf(F,"     --exclude-from=FILE     read exclude patterns from FILE\n");
   rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
   rprintf(F,"     --include-from=FILE     read include patterns from FILE\n");
   rprintf(F,"     --files-from=FILE       read list of source-file names from FILE\n");
-  rprintf(F," -0, --from0                 all *-from file lists are delimited by nulls\n");
-  rprintf(F,"     --version               print version number\n");
+  rprintf(F," -0, --from0                 all *-from/filter files are delimited by 0s\n");
+  rprintf(F,"     --address=ADDRESS       bind address for outgoing socket to daemon\n");
   rprintf(F,"     --port=PORT             specify double-colon alternate port number\n");
   rprintf(F,"     --blocking-io           use blocking I/O for the remote shell\n");
   rprintf(F,"     --no-blocking-io        turn off blocking I/O when it is the default\n");
   rprintf(F,"     --stats                 give some file-transfer stats\n");
   rprintf(F,"     --progress              show progress during transfer\n");
   rprintf(F," -P                          same as --partial --progress\n");
   rprintf(F," -i, --itemize-changes       output a change-summary for all updates\n");
-  rprintf(F,"     --log-format=FORMAT     log file-transfers using specified format\n");
+  rprintf(F,"     --log-format=FORMAT     output filenames using the specified format\n");
   rprintf(F,"     --password-file=FILE    read password from FILE\n");
   rprintf(F,"     --list-only             list the files instead of copying them\n");
   rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
   rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
+  rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
   rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
   rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
 #ifdef INET6
   rprintf(F," -4, --ipv4                  prefer IPv4\n");
   rprintf(F," -6, --ipv6                  prefer IPv6\n");
 #endif
+  rprintf(F,"     --version               print version number\n");
   rprintf(F," -h, --help                  show this help screen\n");
 
   rprintf(F,"\nUse \"rsync --daemon --help\" to see the daemon-mode command-line options.\n");
   rprintf(F,"Please see the rsync(1) and rsyncd.conf(5) man pages for full documentation.\n");
   rprintf(F,"See http://rsync.samba.org/ for updates, bug reports, and answers\n");
 }
 
 enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
-      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT, OPT_MAX_SIZE,
+      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
       OPT_REFUSED_BASE = 9000};
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"version",          0,  POPT_ARG_NONE,   0, OPT_VERSION, 0, 0},
   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
@@ -421,13 +424,13 @@
   {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
   {"no-relative",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
   {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
   {"max-size",         0,  POPT_ARG_STRING, &max_size_arg,  OPT_MAX_SIZE, 0, 0 },
-  {"timeout",          0,  POPT_ARG_INT,    &io_timeout, OPT_TIMEOUT, 0, 0 },
+  {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
   {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
   /* TODO: Should this take an optional int giving the compression level? */
@@ -439,31 +442,32 @@
   {"delay-updates",    0,  POPT_ARG_NONE,   &delay_updates, 0, 0, 0 },
   {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
   {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
   {0,                 'F', POPT_ARG_NONE,   0, 'F', 0, 0 },
   {0,                 'P', POPT_ARG_NONE,   0, 'P', 0, 0 },
+  {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
   {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
   {"itemize-changes", 'i', POPT_ARG_NONE,   &itemize_changes, 0, 0, 0 },
   {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
   {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
   {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
   {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
   {"write-batch",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },
+  {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
   {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
   {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
   {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
   {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
   {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
 #ifdef INET6
   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
 #endif
   /* All these options switch us into daemon-mode option-parsing. */
-  {"address",          0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
   {"config",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
   {"daemon",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
   {"detach",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
   {"no-detach",        0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
   {0,0,0,0, 0, 0, 0}
 };
@@ -614,12 +618,41 @@
 	}
 
 	return i;
 }
 
 
+static OFF_T parse_size_arg(const char *size_arg)
+{
+	const char *arg;
+	OFF_T size;
+
+	for (arg = size_arg; isdigit(*(uchar*)arg); arg++) {}
+	if (*arg == '.')
+		for (arg++; isdigit(*(uchar*)arg); arg++) {}
+	switch (*arg) {
+	case 'k': case 'K':
+		size = atof(size_arg) * 1024;
+		break;
+	case 'm': case 'M':
+		size = atof(size_arg) * 1024*1024;
+		break;
+	case 'g': case 'G':
+		size = atof(size_arg) * 1024*1024*1024;
+		break;
+	case '\0':
+		size = atof(size_arg);
+		break;
+	default:
+		size = 0;
+		break;
+	}
+	return size;
+}
+
+
 static void create_refuse_error(int which)
 {
 	/* The "which" value is the index + OPT_REFUSED_BASE. */
 	struct poptOption *op = &long_options[which - OPT_REFUSED_BASE];
 	int n = snprintf(err_buf, sizeof err_buf,
 			 "The server is configured to refuse --%s\n",
@@ -788,51 +821,31 @@
 
 		case OPT_WRITE_BATCH:
 			/* batch_name is already set */
 			write_batch = 1;
 			break;
 
+		case OPT_ONLY_WRITE_BATCH:
+			/* batch_name is already set */
+			write_batch = -1;
+			break;
+
 		case OPT_READ_BATCH:
 			/* batch_name is already set */
 			read_batch = 1;
 			break;
 
 		case OPT_MAX_SIZE:
-			for (arg = max_size_arg; isdigit(*(uchar*)arg); arg++) {}
-			if (*arg == '.')
-				for (arg++; isdigit(*(uchar*)arg); arg++) {}
-			switch (*arg) {
-			case 'k': case 'K':
-				max_size = atof(max_size_arg) * 1024;
-				break;
-			case 'm': case 'M':
-				max_size = atof(max_size_arg) * 1024*1024;
-				break;
-			case 'g': case 'G':
-				max_size = atof(max_size_arg) * 1024*1024*1024;
-				break;
-			case '\0':
-				max_size = atof(max_size_arg);
-				break;
-			default:
-				max_size = 0;
-				break;
-			}
-			if (max_size <= 0) {
+			if ((max_size = parse_size_arg(max_size_arg)) <= 0) {
 				snprintf(err_buf, sizeof err_buf,
 					"--max-size value is invalid: %s\n",
 					max_size_arg);
 				return 0;
 			}
 			break;
 
-		case OPT_TIMEOUT:
-			if (io_timeout && io_timeout < select_timeout)
-				select_timeout = io_timeout;
-			break;
-
 		case OPT_LINK_DEST:
 #ifdef HAVE_LINK
 			link_dest = 1;
 			dest_option = "--link-dest";
 			goto set_dest_dir;
 #else
@@ -898,13 +911,13 @@
 
 	if (write_batch && read_batch) {
 		snprintf(err_buf, sizeof err_buf,
 			"--write-batch and --read-batch can not be used together\n");
 		return 0;
 	}
-	if (write_batch || read_batch) {
+	if (write_batch > 0 || read_batch) {
 		if (am_server) {
 			rprintf(FINFO,
 				"ignoring --%s-batch option sent to server\n",
 				write_batch ? "write" : "read");
 			/* We don't actually exit_cleanup(), so that we can
 			 * still service older version clients that still send
@@ -1090,12 +1103,17 @@
 	}
 
 	if ((do_progress || dry_run) && !verbose && !log_before_transfer
 	    && !am_server)
 		verbose = 1;
 
+	if (dry_run)
+		do_xfers = 0;
+
+	set_io_timeout(io_timeout);
+
 	if (verbose && !log_format) {
 		log_format = "%n%L";
 		log_before_transfer = !am_server;
 	}
 	if (log_format_has_i || log_format_has(log_format, 'o'))
 		log_format_has_o_or_i = 1;
@@ -1211,13 +1229,13 @@
  * This involves setting options that will tell the server how to
  * behave, and also filtering out options that are processed only
  * locally.
  **/
 void server_options(char **args,int *argc)
 {
-	static char argstr[50+MAX_BASIS_DIRS*2];
+	static char argstr[64];
 	int ac = *argc;
 	char *arg;
 
 	int i, x;
 
 	if (blocking_io == -1)
@@ -1242,13 +1260,13 @@
 
 	/* the -q option is intentionally left out */
 	if (make_backups)
 		argstr[x++] = 'b';
 	if (update_only)
 		argstr[x++] = 'u';
-	if (dry_run)
+	if (!do_xfers) /* NOT "dry_run"! */
 		argstr[x++] = 'n';
 	if (preserve_links)
 		argstr[x++] = 'l';
 	if (copy_links)
 		argstr[x++] = 'L';
 	if (xfer_dirs > 1)
@@ -1370,12 +1388,14 @@
 		if (delete_during)
 			args[ac++] = "--delete-during";
 		if (delete_after)
 			args[ac++] = "--delete-after";
 		if (force_delete)
 			args[ac++] = "--force";
+		if (write_batch < 0)
+			args[ac++] = "--only-write-batch=X";
 	}
 
 	if (size_only)
 		args[ac++] = "--size-only";
 
 	if (modify_window_set) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/packaging/lsb/rsync.spec	2005-03-31 11:14:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/packaging/lsb/rsync.spec	2005-06-02 11:54:45.000000000 +0800
@@ -1,9 +1,9 @@
 Summary: A program for synchronizing files over a network.
 Name: rsync
-Version: 2.6.4
+Version: 2.6.5
 Release: 1
 Group: Applications/Internet
 Source:	ftp://rsync.samba.org/pub/rsync/rsync-%{version}.tar.gz
 URL: http://rsync.samba.org/
 
 Prefix: %{_prefix}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/acls.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/acls.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/acls.diff	2005-03-31 11:13:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/acls.diff	2005-06-02 00:22:41.000000000 +0800
@@ -30,14 +30,14 @@
  OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
 -	fileio.o batch.o clientname.o
 +	fileio.o batch.o clientname.o acls.o
  OBJS3=progress.o pipe.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
---- orig/acls.c	2004-10-20 06:36:04
-+++ acls.c	2004-10-20 06:36:04
+--- orig/acls.c	2005-05-12 23:30:45
++++ acls.c	2005-05-12 23:30:45
 @@ -0,0 +1,1130 @@
 +/* -*- c-file-style: "linux" -*-
 +   Copyright (C) Andrew Tridgell 1996
 +   Copyright (C) Paul Mackerras 1996
 +
 +   This program is free software; you can redistribute it and/or modify
@@ -57,13 +57,13 @@
 +
 +/* handle passing ACLs between systems */
 +
 +#include "rsync.h"
 +#include "lib/sysacls.h"
 +
-+#if SUPPORT_ACLS
++#ifdef SUPPORT_ACLS
 +
 +extern int preserve_acls;
 +extern int am_root;
 +extern int dry_run;
 +
 +typedef struct {
@@ -79,14 +79,14 @@
 +} rsync_acl;
 +
 +static const rsync_acl rsync_acl_initializer = { 0, 0, NULL };
 +
 +static void expand_rsync_acl(rsync_acl *racl)
 +{
-+	/* first time through, 0 <= 0, so list is expanded:
-+	 * diabolical, rsync guys! */
++	/* First time through, 0 <= 0, so list is expanded.
++	 * (Diabolical, rsync guys!) */
 +	if (racl->malloced <= racl->count) {
 +		rsync_ace *new_ptr;
 +		size_t new_size = racl->malloced + 10;
 +		new_ptr = realloc_array(racl->races, rsync_ace, new_size);
 +		if (verbose >= 4) {
 +			rprintf(FINFO, "expand rsync_acl to %.0f bytes, did%s move\n",
@@ -244,14 +244,14 @@
 +	return type == SMB_ACL_TYPE_ACCESS ? &_rsync_acl_lists[0]
 +	    : &_rsync_acl_lists[1];
 +}
 +
 +static void expand_rsync_acl_list(rsync_acl_list *racl_list)
 +{
-+	/* first time through, 0 <= 0, so list is expanded:
-+	 * diabolical, rsync guys! */
++	/* First time through, 0 <= 0, so list is expanded.
++	 * (Diabolical, rsync guys!) */
 +	if (racl_list->malloced <= racl_list->count) {
 +		rsync_acl *new_ptr;
 +		size_t new_size;
 +		if (racl_list->malloced < 1000)
 +			new_size = racl_list->malloced + 1000;
 +		else
@@ -271,14 +271,14 @@
 +	}
 +}
 +
 +#if 0
 +static void free_rsync_acl_list(rsync_acl_list *racl_list)
 +{
-+	/* run this in reverse, so references are freed before referents, */
-+	/* although not currently necessary */
++	/* Run this in reverse, so references are freed before referents,
++	 * although not currently necessary. */
 +	while (racl_list->count--) {
 +		rsync_acl *racl = &racl_list->racls[racl_list->count];
 +		if (racl)
 +			rsync_acl_free(racl);
 +	}
 +	free(racl_list->racls);
@@ -292,33 +292,33 @@
 +				   const rsync_acl *racl)
 +{
 +	static int access_match = -1, default_match = -1;
 +	int *match = (type == SMB_ACL_TYPE_ACCESS) ?
 +			&access_match : &default_match;
 +	size_t count = racl_list->count;
-+	/* if this is the first time through or we didn't match the last
++	/* If this is the first time through or we didn't match the last
 +	 * time, then start at the end of the list, which should be the
-+	 * best place to start hunting */
++	 * best place to start hunting. */
 +	if (*match == -1)
 +		*match = racl_list->count - 1;
 +	while (count--) {
 +		if (rsync_acls_equal(&racl_list->racls[*match], racl))
 +			return *match;
 +		if (!(*match)--)
 +			*match = racl_list->count - 1;
 +	}
 +	*match = -1;
 +	return *match;
 +}
 +
-+/* the general strategy with the tag_type <-> character mapping is that
++/* The general strategy with the tag_type <-> character mapping is that
 + * lowercase implies that no qualifier follows, where uppercase does.
-+ * same sorta thing for the acl type (access or default) itself, but
++ * A similar idiom for the acl type (access or default) itself, but
 + * lowercase in this instance means there's no ACL following, so the
 + * ACL is a repeat, so the receiver should reuse the last of the same
-+ * type ACL */
++ * type ACL. */
 +
 +static void send_rsync_acl(int f, const rsync_acl *racl)
 +{
 +	rsync_ace *race;
 +	size_t count = racl->count;
 +	write_int(f, count);
@@ -350,15 +350,15 @@
 +			continue;
 +		}
 +		write_byte(f, ch);
 +		write_byte(f, race->access);
 +		if (isupper((int)ch)) {
 +			write_int(f, race->id);
-+			/* FIXME: sorta wasteful. we should maybe buffer as
++			/* FIXME: sorta wasteful: we should maybe buffer as
 +			 * many ids as max(ACL_USER + ACL_GROUP) objects to
-+			 * keep from making so many calls */
++			 * keep from making so many calls. */
 +			if (ch == 'U')
 +				add_uid(race->id);
 +			else
 +				add_gid(race->id);
 +		}
 +	}
@@ -371,14 +371,14 @@
 +{
 +	return type == SMB_ACL_TYPE_ACCESS ? "SMB_ACL_TYPE_ACCESS" :
 +		type == SMB_ACL_TYPE_DEFAULT ? "SMB_ACL_TYPE_DEFAULT" :
 +		"unknown SMB_ACL_TYPE_T";
 +}
 +
-+/* generate the ACL(s) for this flist entry;
-+ * ACL(s) are either sent or cleaned-up by send_acl() below */
++/* Generate the ACL(s) for this flist entry;
++ * ACL(s) are either sent or cleaned-up by send_acl() below. */
 +
 +BOOL make_acl(const struct file_struct *file, const char *fname)
 +{
 +	SMB_ACL_TYPE_T *type,
 +		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
 +	rsync_acl *curr_racl;
@@ -401,14 +401,14 @@
 +		if (!ok)
 +			return False;
 +	}
 +	return True;
 +}
 +
-+/* send the make_acl()-generated ACLs for this flist entry,
-+ * or clean up after an flist entry that's not being sent (f == -1) */
++/* Send the make_acl()-generated ACLs for this flist entry,
++ * or clean up after an flist entry that's not being sent (f == -1). */
 +
 +void send_acl(const struct file_struct *file, int f)
 +{
 +	SMB_ACL_TYPE_T *type,
 +		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
 +	rsync_acl *curr_racl;
@@ -435,13 +435,13 @@
 +			expand_rsync_acl_list(racl_list);
 +			racl_list->racls[racl_list->count++] = *curr_racl;
 +		}
 +	}
 +}
 +
-+/* the below stuff is only used by the receiver */
++/* The below stuff is only used by the receiver: */
 +
 +/* structure to hold index to rsync_acl_list member corresponding to
 + * flist->files[i] */
 +
 +typedef struct {
 +	const struct file_struct *file;
@@ -464,14 +464,14 @@
 +	return type == SMB_ACL_TYPE_ACCESS ?
 +		&_file_acl_index_lists[0] : &_file_acl_index_lists[1];
 +}
 +
 +static void expand_file_acl_index_list(file_acl_index_list *fileaclidx_list)
 +{
-+	/* first time through, 0 <= 0, so list is expanded:
-+	 * diabolical, rsync guys! */
++	/* First time through, 0 <= 0, so list is expanded.
++	 * (Diabolical, rsync guys!) */
 +	if (fileaclidx_list->malloced <= fileaclidx_list->count) {
 +		file_acl_index *new_ptr;
 +		size_t new_size;
 +		if (fileaclidx_list->malloced < 1000)
 +			new_size = fileaclidx_list->malloced + 1000;
 +		else
@@ -518,14 +518,14 @@
 +	return type == SMB_ACL_TYPE_ACCESS ? &_smb_acl_lists[0] :
 +		&_smb_acl_lists[1];
 +}
 +
 +static void expand_smb_acl_list(smb_acl_list *sacl_list)
 +{
-+	/* first time through, 0 <= 0, so list is expanded:
-+	 * diabolical, rsync guys! */
++	/* First time through, 0 <= 0, so list is expanded.
++	 * (Diabolical, rsync guys!) */
 +	if (sacl_list->malloced <= sacl_list->count) {
 +		SMB_ACL_T *new_ptr;
 +		size_t new_size;
 +		if (sacl_list->malloced < 1000)
 +			new_size = sacl_list->malloced + 1000;
 +		else
@@ -939,14 +939,14 @@
 +			if (sacl_orig)
 +				sys_acl_free_acl(sacl_orig);
 +	}
 +	return ret;
 +}
 +
-+/* stuff for redirecting calls to set_acl() from set_perms()
-+ * for keep_backup() */
++/* Stuff for redirecting calls to set_acl() from set_perms()
++ * for keep_backup(). */
 +static const struct file_struct *backup_orig_file = NULL;
 +static const char null_string[] = "";
 +static const char *backup_orig_fname = null_string;
 +static const char *backup_dest_fname = null_string;
 +static SMB_ACL_T _backup_sacl[] = { NULL, NULL };
 +
@@ -1087,26 +1087,26 @@
 +		if (!updated)
 +			updated = 1;
 +	}
 +	return updated;
 +}
 +
-+/* enumeration functions for uid mapping */
++/* Enumeration functions for uid mapping: */
 +
-+/* context -- one and only one. should be cycled through once on uid mapping
-+ * and once on gid mapping */
++/* Context -- one and only one.  Should be cycled through once on uid
++ * mapping and once on gid mapping. */
 +static rsync_acl_list *_enum_racl_lists[] = {
 +	&_rsync_acl_lists[0], &_rsync_acl_lists[1], NULL
 +};
 +
 +static rsync_acl_list **enum_racl_list = &_enum_racl_lists[0];
 +static size_t enum_racl_index = 0;
 +static size_t enum_race_index = 0;
 +
-+/* this returns the next tag_type id from the given acl for the next entry,
-+ * or it returns 0 if there are no more tag_type ids in the acl */
++/* This returns the next tag_type id from the given acl for the next entry,
++ * or it returns 0 if there are no more tag_type ids in the acl. */
 +
 +static id_t next_ace_id(SMB_ACL_TAG_T tag_type, const rsync_acl *racl)
 +{
 +	for (; enum_race_index < racl->count; enum_race_index++) {
 +		rsync_ace *race = &racl->races[enum_race_index];
 +		if (race->tag_type == tag_type)
@@ -1190,27 +1190,27 @@
  	}
  	set_perms(buf, file, NULL, 0);
 +	CLEANUP_KEEP_BACKUP_ACL();
  	free(file);
  
  	if (verbose > 1) {
---- orig/configure.in	2005-03-29 11:15:05
+--- orig/configure.in	2005-05-28 08:24:57
 +++ configure.in	2004-08-19 19:53:27
-@@ -467,6 +467,11 @@ if test x"$ac_cv_func_strcasecmp" = x"no
+@@ -480,6 +480,11 @@ if test x"$ac_cv_func_strcasecmp" = x"no
      AC_CHECK_LIB(resolv, strcasecmp)
  fi
  
 +AC_CHECK_FUNCS(aclsort)
 +if test x"$ac_cv_func_aclsort" = x"no"; then
 +    AC_CHECK_LIB(sec, aclsort)
 +fi
 +
  dnl At the moment we don't test for a broken memcmp(), because all we
  dnl need to do is test for equality, not comparison, and it seems that
  dnl every platform has a memcmp that can do at least that.
-@@ -713,6 +718,77 @@ AC_SUBST(OBJ_RESTORE)
+@@ -736,6 +741,77 @@ AC_SUBST(OBJ_RESTORE)
  AC_SUBST(CC_SHOBJ_FLAG)
  AC_SUBST(BUILD_POPT)
  
 +AC_CHECK_HEADERS(sys/acl.h)
 +AC_CHECK_FUNCS(_acl __acl _facl __facl)
 +#################################################
@@ -1282,68 +1282,68 @@
 +  AC_MSG_RESULT(no)
 +)
 +
  AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
  AC_OUTPUT
  
---- orig/flist.c	2005-03-30 17:31:41
+--- orig/flist.c	2005-05-28 08:24:57
 +++ flist.c	2005-03-16 02:24:11
-@@ -971,6 +971,8 @@ static struct file_struct *send_file_nam
+@@ -974,6 +974,8 @@ static struct file_struct *send_file_nam
  	file = make_file(fname, flist, f == -2 ? SERVER_FILTERS : ALL_FILTERS);
  	if (!file)
  		return NULL;
 +	if (!MAKE_ACL(file, fname))
-+		return;
++		return NULL;
  
  	maybe_emit_filelist_progress(flist->count + flist_count_offset);
  
-@@ -979,6 +981,10 @@ static struct file_struct *send_file_nam
+@@ -982,6 +984,10 @@ static struct file_struct *send_file_nam
  	if (file->basename[0]) {
  		flist->files[flist->count++] = file;
  		send_file_entry(file, f, base_flags);
 +		SEND_ACL(file, f);
 +	} else {
 +		/* Cleanup unsent ACL(s). */
 +		SEND_ACL(file, -1);
  	}
  	return file;
  }
-@@ -1305,6 +1311,8 @@ struct file_list *recv_file_list(int f)
+@@ -1318,6 +1324,8 @@ struct file_list *recv_file_list(int f)
  			flags |= read_byte(f) << 8;
  		file = receive_file_entry(flist, flags, f);
  
 +		RECEIVE_ACL(file, f);
 +
  		if (S_ISREG(file->mode))
  			stats.total_size += file->length;
  
-@@ -1327,6 +1335,8 @@ struct file_list *recv_file_list(int f)
+@@ -1340,6 +1348,8 @@ struct file_list *recv_file_list(int f)
  
  	clean_flist(flist, relative_paths, 1);
  
 +	SORT_FILE_ACL_INDEX_LISTS();
 +
  	if (f >= 0) {
  		/* Now send the uid/gid list. This was introduced in
  		 * protocol version 15 */
---- orig/generator.c	2005-03-30 16:35:08
-+++ generator.c	2005-03-11 11:18:22
-@@ -711,6 +711,10 @@ static void recv_generator(char *fname, 
+--- orig/generator.c	2005-05-22 20:53:34
++++ generator.c	2005-05-12 23:34:00
+@@ -715,6 +715,10 @@ static void recv_generator(char *fname, 
  		if (set_perms(fname, file, statret ? NULL : &st, 0)
  		    && verbose && code && f_out != -1)
  			rprintf(code, "%s/\n", safe_fname(fname));
-+#if SUPPORT_ACLS
++#ifdef SUPPORT_ACLS
 +		if (f_out == -1)
 +			SET_ACL(fname, file);
 +#endif
  		if (delete_during && f_out != -1 && !phase && dry_run < 2
  		    && (file->flags & FLAG_DEL_HERE))
  			delete_in_dir(the_file_list, fname, file);
---- orig/lib/sysacls.c	2004-10-20 15:35:58
-+++ lib/sysacls.c	2004-10-20 15:35:58
-@@ -0,0 +1,3217 @@
+--- orig/lib/sysacls.c	2005-05-16 23:27:53
++++ lib/sysacls.c	2005-05-16 23:27:53
+@@ -0,0 +1,3242 @@
 +/* 
 +   Unix SMB/CIFS implementation.
 +   Samba system utilities for ACL support.
 +   Copyright (C) Jeremy Allison 2000.
 +   
 +   This program is free software; you can redistribute it and/or modify
@@ -1359,14 +1359,15 @@
 +   You should have received a copy of the GNU General Public License
 +   along with this program; if not, write to the Free Software
 +   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 +*/
 +
 +#include "rsync.h"
-+#include "sysacls.h"
++#include "sysacls.h" /****** ADDED ******/
 +
++/****** EXTRAS -- THESE ITEMS ARE NOT FROM THE SAMBA SOURCE ******/
 +void SAFE_FREE(void *mem)
 +{
 +	if (mem)
 +		free(mem);
 +}
 +
@@ -1378,12 +1379,13 @@
 +	if ((pw = getpwuid(uid)) == NULL) {
 +		slprintf(idbuf, sizeof(idbuf)-1, "%ld", (long)uid);
 +		return idbuf;
 +	}
 +	return pw->pw_name;
 +}
++/****** EXTRAS -- END ******/
 +
 +/*
 + This file wraps all differing system ACL interfaces into a consistent
 + one based on the POSIX interface. It also returns the correct errors
 + for older UNIX systems that don't support ACLs.
 +
@@ -1542,13 +1544,13 @@
 +
 +int sys_acl_free_acl(SMB_ACL_T the_acl) 
 +{
 +	return acl_free(the_acl);
 +}
 +
-+int sys_acl_free_qualifier(void *qual, SMB_ACL_TAG_T tagtype)
++int sys_acl_free_qualifier(void *qual, UNUSED(SMB_ACL_TAG_T tagtype))
 +{
 +	return acl_free(qual);
 +}
 +
 +#elif defined(HAVE_TRU64_ACLS)
 +/*
@@ -1971,13 +1973,13 @@
 +	 * use an initial estimate of 20 bytes per ACL entry
 +	 * when allocating memory for the text representation
 +	 * of the ACL
 +	 */
 +	len	= 0;
 +	maxlen	= 20 * acl_d->count;
-+	if ((text = malloc(maxlen)) == NULL) {
++	if ((text = SMB_MALLOC(maxlen)) == NULL) {
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +
 +	for (i = 0; i < acl_d->count; i++) {
 +		struct acl	*ap	= &acl_d->acl[i];
@@ -2049,13 +2051,13 @@
 +		 */
 +		if ((len + nbytes) > maxlen) {
 +			char *oldtext = text;
 +
 +			maxlen += nbytes + 20 * (acl_d->count - i);
 +
-+			if ((text = Realloc(oldtext, maxlen)) == NULL) {
++			if ((text = SMB_REALLOC(oldtext, maxlen)) == NULL) {
 +				SAFE_FREE(oldtext);
 +				errno = ENOMEM;
 +				return NULL;
 +			}
 +		}
 +
@@ -2081,13 +2083,13 @@
 +	/*
 +	 * note that since the definition of the structure pointed
 +	 * to by the SMB_ACL_T includes the first element of the
 +	 * acl[] array, this actually allocates an ACL with room
 +	 * for (count+1) entries
 +	 */
-+	if ((a = malloc(sizeof(*a) + count * sizeof(struct acl))) == NULL) {
++	if ((a = SMB_MALLOC(sizeof(struct SMB_ACL_T) + count * sizeof(struct acl))) == NULL) {
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +
 +	a->size = count + 1;
 +	a->count = 0;
@@ -2245,13 +2247,13 @@
 +		}
 +
 +		/*
 +		 * allocate a temporary buffer for the complete ACL
 +		 */
 +		acl_count = acc_acl->count + def_acl->count;
-+		acl_p = acl_buf = malloc(acl_count * sizeof(acl_buf[0]));
++		acl_p = acl_buf = SMB_MALLOC_ARRAY(struct acl, acl_count);
 +
 +		if (acl_buf == NULL) {
 +			sys_acl_free_acl(tmp_acl);
 +			errno = ENOMEM;
 +			return -1;
 +		}
@@ -2602,13 +2604,13 @@
 +	 * use an initial estimate of 20 bytes per ACL entry
 +	 * when allocating memory for the text representation
 +	 * of the ACL
 +	 */
 +	len	= 0;
 +	maxlen	= 20 * acl_d->count;
-+	if ((text = malloc(maxlen)) == NULL) {
++	if ((text = SMB_MALLOC(maxlen)) == NULL) {
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +
 +	for (i = 0; i < acl_d->count; i++) {
 +		struct acl	*ap	= &acl_d->acl[i];
@@ -2680,13 +2682,13 @@
 +		 */
 +		if ((len + nbytes) > maxlen) {
 +			char *oldtext = text;
 +
 +			maxlen += nbytes + 20 * (acl_d->count - i);
 +
-+			if ((text = Realloc(oldtext, maxlen)) == NULL) {
++			if ((text = SMB_REALLOC(oldtext, maxlen)) == NULL) {
 +				free(oldtext);
 +				errno = ENOMEM;
 +				return NULL;
 +			}
 +		}
 +
@@ -2712,13 +2714,13 @@
 +	/*
 +	 * note that since the definition of the structure pointed
 +	 * to by the SMB_ACL_T includes the first element of the
 +	 * acl[] array, this actually allocates an ACL with room
 +	 * for (count+1) entries
 +	 */
-+	if ((a = malloc(sizeof(*a) + count * sizeof(struct acl))) == NULL) {
++	if ((a = SMB_MALLOC(sizeof(struct SMB_ACL_T) + count * sizeof(struct acl))) == NULL) {
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +
 +	a->size = count + 1;
 +	a->count = 0;
@@ -3178,13 +3180,13 @@
 +		}
 +
 +		/*
 +		 * allocate a temporary buffer for the complete ACL
 +		 */
 +		acl_count = acc_acl->count + def_acl->count;
-+		acl_p = acl_buf = malloc(acl_count * sizeof(acl_buf[0]));
++		acl_p = acl_buf = SMB_MALLOC_ARRAY(struct acl, acl_count);
 +
 +		if (acl_buf == NULL) {
 +			sys_acl_free_acl(tmp_acl);
 +			errno = ENOMEM;
 +			return -1;
 +		}
@@ -3341,13 +3343,13 @@
 +}
 +
 +SMB_ACL_T sys_acl_get_file(const char *path_p, SMB_ACL_TYPE_T type)
 +{
 +	SMB_ACL_T	a;
 +
-+	if ((a = malloc(sizeof(*a))) == NULL) {
++	if ((a = SMB_MALLOC_P(struct SMB_ACL_T)) == NULL) {
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +	if ((a->aclp = acl_get_file(path_p, type)) == NULL) {
 +		SAFE_FREE(a);
 +		return NULL;
@@ -3358,13 +3360,13 @@
 +}
 +
 +SMB_ACL_T sys_acl_get_fd(int fd)
 +{
 +	SMB_ACL_T	a;
 +
-+	if ((a = malloc(sizeof(*a))) == NULL) {
++	if ((a = SMB_MALLOC_P(struct SMB_ACL_T)) == NULL) {
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +	if ((a->aclp = acl_get_fd(fd)) == NULL) {
 +		SAFE_FREE(a);
 +		return NULL;
@@ -3415,13 +3417,13 @@
 +
 +	if (count < 0) {
 +		errno = EINVAL;
 +		return NULL;
 +	}
 +
-+	if ((a = malloc(sizeof(*a) + sizeof(struct acl))) == NULL) {
++	if ((a = SMB_MALLOC(sizeof(struct SMB_ACL_T) + sizeof(struct acl))) == NULL) {
 +		errno = ENOMEM;
 +		return NULL;
 +	}
 +
 +	a->next = -1;
 +	a->freeaclp = False;
@@ -3636,18 +3638,22 @@
 +	struct acl_entry_link *acl_entry_link;
 +	struct acl_entry_link *acl_entry_link_head;
 +	int i;
 +	int rc = 0;
 +	uid_t user_id;
 +
++	/* AIX has no DEFAULT */
++	if  ( type == SMB_ACL_TYPE_DEFAULT )
++		return NULL;
++
 +	/* Get the acl using statacl */
 + 
 +	DEBUG(10,("Entering sys_acl_get_file\n"));
 +	DEBUG(10,("path_p is %s\n",path_p));
 +
-+	file_acl = (struct acl *)malloc(BUFSIZ);
++	file_acl = (struct acl *)SMB_MALLOC(BUFSIZ);
 + 
 +	if(file_acl == NULL) {
 +		errno=ENOMEM;
 +		DEBUG(0,("Error in AIX sys_acl_get_file: %d\n",errno));
 +		return(NULL);
 +	}
@@ -3672,13 +3678,13 @@
 +	 * code.                                          */
 +
 +	acl_entry_link_head = acl_entry_link = sys_acl_init(0);
 +	if(acl_entry_link_head == NULL)
 +		return(NULL);
 +
-+	acl_entry_link->entryp = (struct new_acl_entry *)malloc(sizeof(struct new_acl_entry));
++	acl_entry_link->entryp = SMB_MALLOC_P(struct new_acl_entry);
 +	if(acl_entry_link->entryp == NULL) {
 +		SAFE_FREE(file_acl);
 +		errno = ENOMEM;
 +		DEBUG(0,("Error in AIX sys_acl_get_file is %d\n",errno));
 +		return(NULL);
 +	}
@@ -3707,25 +3713,24 @@
 +
 +			/* Check if this is the first entry in the linked list. *
 +			 * The first entry needs to keep prevp pointing to NULL *
 +			 * and already has entryp allocated.                  */
 +
 +			if(acl_entry_link_head->count != 0) {
-+				acl_entry_link->nextp = (struct acl_entry_link *)
-+											malloc(sizeof(struct acl_entry_link));
++				acl_entry_link->nextp = SMB_MALLOC_P(struct acl_entry_link);
 +
 +				if(acl_entry_link->nextp == NULL) {
 +					SAFE_FREE(file_acl);
 +					errno = ENOMEM;
 +					DEBUG(0,("Error in AIX sys_acl_get_file is %d\n",errno));
 +					return(NULL);
 +				}
 +
 +				acl_entry_link->nextp->prevp = acl_entry_link;
 +				acl_entry_link = acl_entry_link->nextp;
-+				acl_entry_link->entryp = (struct new_acl_entry *)malloc(sizeof(struct new_acl_entry));
++				acl_entry_link->entryp = SMB_MALLOC_P(struct new_acl_entry);
 +				if(acl_entry_link->entryp == NULL) {
 +					SAFE_FREE(file_acl);
 +					errno = ENOMEM;
 +					DEBUG(0,("Error in AIX sys_acl_get_file is %d\n",errno));
 +					return(NULL);
 +				}
@@ -3778,23 +3783,23 @@
 +	 * part of the acl entries in an acl, they must  *
 +	 * be dummied up to become part of the list.     */
 +
 +	for( i = 1; i < 4; i++) {
 +		DEBUG(10,("i is %d\n",i));
 +		if(acl_entry_link_head->count != 0) {
-+			acl_entry_link->nextp = (struct acl_entry_link *)malloc(sizeof(struct acl_entry_link));
++			acl_entry_link->nextp = SMB_MALLOC_P(struct acl_entry_link);
 +			if(acl_entry_link->nextp == NULL) {
 +				SAFE_FREE(file_acl);
 +				errno = ENOMEM;
 +				DEBUG(0,("Error in AIX sys_acl_get_file is %d\n",errno));
 +				return(NULL);
 +			}
 +
 +			acl_entry_link->nextp->prevp = acl_entry_link;
 +			acl_entry_link = acl_entry_link->nextp;
-+			acl_entry_link->entryp = (struct new_acl_entry *)malloc(sizeof(struct new_acl_entry));
++			acl_entry_link->entryp = SMB_MALLOC_P(struct new_acl_entry);
 +			if(acl_entry_link->entryp == NULL) {
 +				SAFE_FREE(file_acl);
 +				errno = ENOMEM;
 +				DEBUG(0,("Error in AIX sys_acl_get_file is %d\n",errno));
 +				return(NULL);
 +			}
@@ -3855,13 +3860,13 @@
 +	uid_t user_id;
 +
 +	/* Get the acl using fstatacl */
 +   
 +	DEBUG(10,("Entering sys_acl_get_fd\n"));
 +	DEBUG(10,("fd is %d\n",fd));
-+	file_acl = (struct acl *)malloc(BUFSIZ);
++	file_acl = (struct acl *)SMB_MALLOC(BUFSIZ);
 +
 +	if(file_acl == NULL) {
 +		errno=ENOMEM;
 +		DEBUG(0,("Error in sys_acl_get_fd is %d\n",errno));
 +		return(NULL);
 +	}
@@ -3888,13 +3893,13 @@
 +	acl_entry_link_head = acl_entry_link = sys_acl_init(0);
 +	if(acl_entry_link_head == NULL){
 +		SAFE_FREE(file_acl);
 +		return(NULL);
 +	}
 +
-+	acl_entry_link->entryp = (struct new_acl_entry *)malloc(sizeof(struct new_acl_entry));
++	acl_entry_link->entryp = SMB_MALLOC_P(struct new_acl_entry);
 +
 +	if(acl_entry_link->entryp == NULL) {
 +		errno = ENOMEM;
 +		DEBUG(0,("Error in sys_acl_get_fd is %d\n",errno));
 +		SAFE_FREE(file_acl);
 +		return(NULL);
@@ -3925,22 +3930,22 @@
 + 
 +			/* Check if this is the first entry in the linked list. *
 +			 * The first entry needs to keep prevp pointing to NULL *
 +			 * and already has entryp allocated.                 */
 +
 +			if(acl_entry_link_head->count != 0) {
-+				acl_entry_link->nextp = (struct acl_entry_link *)malloc(sizeof(struct acl_entry_link));
++				acl_entry_link->nextp = SMB_MALLOC_P(struct acl_entry_link);
 +				if(acl_entry_link->nextp == NULL) {
 +					errno = ENOMEM;
 +					DEBUG(0,("Error in sys_acl_get_fd is %d\n",errno));
 +					SAFE_FREE(file_acl);
 +					return(NULL);
 +				}
 +				acl_entry_link->nextp->prevp = acl_entry_link;
 +				acl_entry_link = acl_entry_link->nextp;
-+				acl_entry_link->entryp = (struct new_acl_entry *)malloc(sizeof(struct new_acl_entry));
++				acl_entry_link->entryp = SMB_MALLOC_P(struct new_acl_entry);
 +				if(acl_entry_link->entryp == NULL) {
 +					errno = ENOMEM;
 +					DEBUG(0,("Error in sys_acl_get_fd is %d\n",errno));
 +					SAFE_FREE(file_acl);
 +					return(NULL);
 +				}
@@ -3993,23 +3998,23 @@
 +	 * part of the acl entries in an acl, they must  *
 +	 * be dummied up to become part of the list.     */
 +
 +	for( i = 1; i < 4; i++) {
 +		DEBUG(10,("i is %d\n",i));
 +		if(acl_entry_link_head->count != 0){
-+			acl_entry_link->nextp = (struct acl_entry_link *)malloc(sizeof(struct acl_entry_link));
++			acl_entry_link->nextp = SMB_MALLOC_P(struct acl_entry_link);
 +			if(acl_entry_link->nextp == NULL) {
 +				errno = ENOMEM;
 +				DEBUG(0,("Error in sys_acl_get_fd is %d\n",errno));
 +				SAFE_FREE(file_acl);
 +				return(NULL);
 +			}
 +
 +			acl_entry_link->nextp->prevp = acl_entry_link;
 +			acl_entry_link = acl_entry_link->nextp;
-+			acl_entry_link->entryp = (struct new_acl_entry *)malloc(sizeof(struct new_acl_entry));
++			acl_entry_link->entryp = SMB_MALLOC_P(struct new_acl_entry);
 +
 +			if(acl_entry_link->entryp == NULL) {
 +				SAFE_FREE(file_acl);
 +				errno = ENOMEM;
 +				DEBUG(0,("Error in sys_acl_get_fd is %d\n",errno));
 +				return(NULL);
@@ -4082,13 +4087,13 @@
 +SMB_ACL_T sys_acl_init( int count)
 +{
 +	struct acl_entry_link *theacl = NULL;
 + 
 +	DEBUG(10,("Entering sys_acl_init\n"));
 +
-+	theacl = (struct acl_entry_link *)malloc(sizeof(struct acl_entry_link));
++	theacl = SMB_MALLOC_P(struct acl_entry_link);
 +	if(theacl == NULL) {
 +		errno = ENOMEM;
 +		DEBUG(0,("Error in sys_acl_init is %d\n",errno));
 +		return(NULL);
 +	}
 +
@@ -4117,25 +4122,25 @@
 +		DEBUG(10,("The acl_entryp is %d\n",acl_entryp));
 +		temp_entry = acl_entryp;
 +		acl_entryp = acl_entryp->nextp;
 +	}
 +
 +	if(theacl->count != 0){
-+		temp_entry->nextp = acl_entryp = (struct acl_entry_link *)malloc(sizeof(struct acl_entry_link));
++		temp_entry->nextp = acl_entryp = SMB_MALLOC_P(struct acl_entry_link);
 +		if(acl_entryp == NULL) {
 +			errno = ENOMEM;
 +			DEBUG(0,("Error in sys_acl_create_entry is %d\n",errno));
 +			return(-1);
 +		}
 +
 +		DEBUG(10,("The acl_entryp is %d\n",acl_entryp));
 +		acl_entryp->prevp = temp_entry;
 +		DEBUG(10,("The acl_entryp->prevp is %d\n",acl_entryp->prevp));
 +	}
 +
-+	*pentry = acl_entryp->entryp = (struct new_acl_entry *)malloc(sizeof(struct new_acl_entry));
++	*pentry = acl_entryp->entryp = SMB_MALLOC_P(struct new_acl_entry);
 +	if(*pentry == NULL) {
 +		errno = ENOMEM;
 +		DEBUG(0,("Error in sys_acl_create_entry is %d\n",errno));
 +		return(-1);
 +	}
 +
@@ -4219,13 +4224,13 @@
 + 
 +	/* AIX has no default ACL */
 +	if(acltype == SMB_ACL_TYPE_DEFAULT)
 +		return(0);
 +
 +	acl_length = BUFSIZ;
-+	file_acl = (struct acl *)malloc(BUFSIZ);
++	file_acl = (struct acl *)SMB_MALLOC(BUFSIZ);
 +
 +	if(file_acl == NULL) {
 +		errno = ENOMEM;
 +		DEBUG(0,("Error in sys_acl_set_file is %d\n",errno));
 +		return(-1);
 +	}
@@ -4252,13 +4257,13 @@
 +		case SMB_ACL_MASK:
 +			continue;
 +		}
 +
 +		if((file_acl->acl_len + sizeof(struct acl_entry)) > acl_length) {
 +			acl_length += sizeof(struct acl_entry);
-+			file_acl_temp = (struct acl *)malloc(acl_length);
++			file_acl_temp = (struct acl *)SMB_MALLOC(acl_length);
 +			if(file_acl_temp == NULL) {
 +				SAFE_FREE(file_acl);
 +				errno = ENOMEM;
 +				DEBUG(0,("Error in sys_acl_set_file is %d\n",errno));
 +				return(-1);
 +			}  
@@ -4307,13 +4312,13 @@
 +	uint user_id;
 +	uint acl_length;
 +	uint rc;
 + 
 +	DEBUG(10,("Entering sys_acl_set_fd\n"));
 +	acl_length = BUFSIZ;
-+	file_acl = (struct acl *)malloc(BUFSIZ);
++	file_acl = (struct acl *)SMB_MALLOC(BUFSIZ);
 +
 +	if(file_acl == NULL) {
 +		errno = ENOMEM;
 +		DEBUG(0,("Error in sys_acl_set_fd is %d\n",errno));
 +		return(-1);
 +	}
@@ -4341,13 +4346,13 @@
 +		case SMB_ACL_MASK:
 +			continue;
 +		}
 +
 +		if((file_acl->acl_len + sizeof(struct acl_entry)) > acl_length) {
 +			acl_length += sizeof(struct acl_entry);
-+			file_acl_temp = (struct acl *)malloc(acl_length);
++			file_acl_temp = (struct acl *)SMB_MALLOC(acl_length);
 +			if(file_acl_temp == NULL) {
 +				SAFE_FREE(file_acl);
 +				errno = ENOMEM;
 +				DEBUG(0,("Error in sys_acl_set_fd is %d\n",errno));
 +				return(-1);
 +			}
@@ -4422,149 +4427,172 @@
 +{
 +	return(0);
 +}
 +
 +#else /* No ACLs. */
 +
-+int sys_acl_get_entry( SMB_ACL_T the_acl, int entry_id, SMB_ACL_ENTRY_T *entry_p)
++int sys_acl_get_entry(UNUSED(SMB_ACL_T the_acl), UNUSED(int entry_id), UNUSED(SMB_ACL_ENTRY_T *entry_p))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_get_tag_type( SMB_ACL_ENTRY_T entry_d, SMB_ACL_TAG_T *tag_type_p)
++int sys_acl_get_tag_type(UNUSED(SMB_ACL_ENTRY_T entry_d), UNUSED(SMB_ACL_TAG_T *tag_type_p))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_get_permset( SMB_ACL_ENTRY_T entry_d, SMB_ACL_PERMSET_T *permset_p)
++int sys_acl_get_permset(UNUSED(SMB_ACL_ENTRY_T entry_d), UNUSED(SMB_ACL_PERMSET_T *permset_p))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+void *sys_acl_get_qualifier( SMB_ACL_ENTRY_T entry_d)
++void *sys_acl_get_qualifier(UNUSED(SMB_ACL_ENTRY_T entry_d))
 +{
 +	errno = ENOSYS;
 +	return NULL;
 +}
 +
-+SMB_ACL_T sys_acl_get_file( const char *path_p, SMB_ACL_TYPE_T type)
++SMB_ACL_T sys_acl_get_file(UNUSED(const char *path_p), UNUSED(SMB_ACL_TYPE_T type))
 +{
 +	errno = ENOSYS;
 +	return (SMB_ACL_T)NULL;
 +}
 +
-+SMB_ACL_T sys_acl_get_fd(int fd)
++SMB_ACL_T sys_acl_get_fd(UNUSED(int fd))
 +{
 +	errno = ENOSYS;
 +	return (SMB_ACL_T)NULL;
 +}
 +
-+int sys_acl_clear_perms(SMB_ACL_PERMSET_T permset)
++int sys_acl_clear_perms(UNUSED(SMB_ACL_PERMSET_T permset))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_add_perm( SMB_ACL_PERMSET_T permset, SMB_ACL_PERM_T perm)
++int sys_acl_add_perm( UNUSED(SMB_ACL_PERMSET_T permset), UNUSED(SMB_ACL_PERM_T perm))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
 +int sys_acl_get_perm( SMB_ACL_PERMSET_T permset, SMB_ACL_PERM_T perm)
 +{
 +	errno = ENOSYS;
 +	return (permset & perm) ? 1 : 0;
 +}
 +
-+char *sys_acl_to_text( SMB_ACL_T the_acl, ssize_t *plen)
++char *sys_acl_to_text(UNUSED(SMB_ACL_T the_acl), UNUSED(ssize_t *plen))
 +{
 +	errno = ENOSYS;
 +	return NULL;
 +}
 +
-+int sys_acl_free_text(char *text)
++int sys_acl_free_text(UNUSED(char *text))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+SMB_ACL_T sys_acl_init( int count)
++SMB_ACL_T sys_acl_init(UNUSED(int count))
 +{
 +	errno = ENOSYS;
 +	return NULL;
 +}
 +
-+int sys_acl_create_entry( SMB_ACL_T *pacl, SMB_ACL_ENTRY_T *pentry)
++int sys_acl_create_entry(UNUSED(SMB_ACL_T *pacl), UNUSED(SMB_ACL_ENTRY_T *pentry))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_set_tag_type( SMB_ACL_ENTRY_T entry, SMB_ACL_TAG_T tagtype)
++int sys_acl_set_tag_type(UNUSED(SMB_ACL_ENTRY_T entry), UNUSED(SMB_ACL_TAG_T tagtype))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_set_qualifier( SMB_ACL_ENTRY_T entry, void *qual)
++int sys_acl_set_qualifier(UNUSED(SMB_ACL_ENTRY_T entry), UNUSED(void *qual))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_set_permset( SMB_ACL_ENTRY_T entry, SMB_ACL_PERMSET_T permset)
++int sys_acl_set_permset(UNUSED(SMB_ACL_ENTRY_T entry), UNUSED(SMB_ACL_PERMSET_T permset))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_valid( SMB_ACL_T theacl )
++int sys_acl_valid(UNUSED(SMB_ACL_T theacl))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_set_file( const char *name, SMB_ACL_TYPE_T acltype, SMB_ACL_T theacl)
++int sys_acl_set_file(UNUSED(const char *name), UNUSED(SMB_ACL_TYPE_T acltype), UNUSED(SMB_ACL_T theacl))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_set_fd( int fd, SMB_ACL_T theacl)
++int sys_acl_set_fd(UNUSED(int fd), UNUSED(SMB_ACL_T theacl))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_delete_def_file(const char *name)
++int sys_acl_delete_def_file(UNUSED(const char *name))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_free_acl(SMB_ACL_T the_acl) 
++int sys_acl_free_acl(UNUSED(SMB_ACL_T the_acl))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
-+int sys_acl_free_qualifier(void *qual, SMB_ACL_TAG_T tagtype)
++int sys_acl_free_qualifier(UNUSED(void *qual), UNUSED(SMB_ACL_TAG_T tagtype))
 +{
 +	errno = ENOSYS;
 +	return -1;
 +}
 +
 +#endif /* No ACLs. */
---- orig/lib/sysacls.h	2004-10-20 15:31:22
-+++ lib/sysacls.h	2004-10-20 15:31:22
-@@ -0,0 +1,25 @@
-+#define Realloc(mem, cnt)	realloc_array((mem), char, (cnt))
++
++/************************************************************************
++ Deliberately outside the ACL defines. Return 1 if this is a "no acls"
++ errno, 0 if not.
++************************************************************************/
++
++int no_acl_syscall_error(int err)
++{
++#if defined(ENOSYS)
++	if (err == ENOSYS) {
++		return 1;
++	}
++#endif
++#if defined(ENOTSUP)
++	if (err == ENOTSUP) {
++		return 1;
++	}
++#endif
++	return 0;
++}
+--- orig/lib/sysacls.h	2005-05-16 23:25:51
++++ lib/sysacls.h	2005-05-16 23:25:51
+@@ -0,0 +1,28 @@
++#define SMB_MALLOC(cnt) new_array(char, cnt)
++#define SMB_MALLOC_P(obj) new_array(obj, 1)
++#define SMB_MALLOC_ARRAY(obj, cnt) new_array(obj, cnt)
++#define SMB_REALLOC(mem, cnt) realloc_array(mem, char, cnt)
 +#define slprintf snprintf
 +
 +int sys_acl_get_entry(SMB_ACL_T the_acl, int entry_id, SMB_ACL_ENTRY_T *entry_p);
 +int sys_acl_get_tag_type(SMB_ACL_ENTRY_T entry_d, SMB_ACL_TAG_T *tag_type_p);
 +int sys_acl_get_permset(SMB_ACL_ENTRY_T entry_d, SMB_ACL_PERMSET_T *permset_p);
 +void *sys_acl_get_qualifier(SMB_ACL_ENTRY_T entry_d);
@@ -4594,75 +4622,75 @@
  
 -!/^OFF_T|^size_t|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^uchar|^short|^struct|^BOOL|^void|^time|^const/ {
 +!/^OFF_T|^size_t|^off_t|^pid_t|^id_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^uchar|^short|^struct|^BOOL|^void|^time|^const/ {
    next;
  }
  
---- orig/options.c	2005-03-31 00:24:21
-+++ options.c	2005-02-14 02:46:05
-@@ -44,6 +44,7 @@ int keep_dirlinks = 0;
+--- orig/options.c	2005-05-19 08:52:42
++++ options.c	2005-05-12 23:34:38
+@@ -43,6 +43,7 @@ int keep_dirlinks = 0;
  int copy_links = 0;
  int preserve_links = 0;
  int preserve_hard_links = 0;
 +int preserve_acls = 0;
  int preserve_perms = 0;
  int preserve_devices = 0;
  int preserve_uid = 0;
-@@ -179,6 +180,7 @@ static void print_rsync_version(enum log
+@@ -180,6 +181,7 @@ static void print_rsync_version(enum log
  	char const *got_socketpair = "no ";
  	char const *have_inplace = "no ";
  	char const *hardlinks = "no ";
 +	char const *acls = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
  	STRUCT_STAT *dumstat;
-@@ -195,6 +197,10 @@ static void print_rsync_version(enum log
+@@ -196,6 +198,10 @@ static void print_rsync_version(enum log
  	hardlinks = "";
  #endif
  
 +#ifdef SUPPORT_ACLS
 +	acls = "";
 +#endif
 +
  #ifdef SUPPORT_LINKS
  	links = "";
  #endif
-@@ -209,9 +215,9 @@ static void print_rsync_version(enum log
+@@ -210,9 +216,9 @@ static void print_rsync_version(enum log
  		"Copyright (C) 1996-2005 by Andrew Tridgell and others\n");
  	rprintf(f, "<http://rsync.samba.org/>\n");
  	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
 -		"%shard links, %ssymlinks, batchfiles, \n",
 +		"%shard links, %sACLs, %ssymlinks, batchfiles, \n",
  		(int) (sizeof (OFF_T) * 8),
 -		got_socketpair, hardlinks, links);
 +		got_socketpair, hardlinks, acls, links);
  
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
-@@ -281,6 +287,7 @@ void usage(enum logcode F)
+@@ -282,6 +288,7 @@ void usage(enum logcode F)
    rprintf(F," -H, --hard-links            preserve hard links\n");
    rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
    rprintf(F," -p, --perms                 preserve permissions\n");
 +  rprintf(F," -A, --acls                  preserve ACLs (implies --perms)\n");
    rprintf(F," -o, --owner                 preserve owner (root only)\n");
    rprintf(F," -g, --group                 preserve group\n");
    rprintf(F," -D, --devices               preserve devices (root only)\n");
-@@ -405,6 +412,7 @@ static struct poptOption long_options[] 
+@@ -408,6 +415,7 @@ static struct poptOption long_options[] 
    {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
    {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
    {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
 +  {"acls",            'A', POPT_ARG_NONE,   0,              'A', 0, 0 },
    {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
    {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
    {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
-@@ -863,6 +871,24 @@ int parse_arguments(int *argc, const cha
+@@ -876,6 +884,24 @@ int parse_arguments(int *argc, const cha
  			basis_dir[basis_dir_cnt++] = (char *)arg;
  			break;
  
 +		case 'A':
-+#if SUPPORT_ACLS
++#ifdef SUPPORT_ACLS
 +			preserve_acls = 1;
 +			preserve_perms = 1;
 +#else
 +			/* FIXME: this should probably be ignored with a
 + 			 * warning and then countermeasures taken to
 + 			 * restrict group and other access in the presence
@@ -4676,13 +4704,13 @@
 +			break;
 +
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1264,6 +1290,8 @@ void server_options(char **args,int *arg
+@@ -1282,6 +1308,8 @@ void server_options(char **args,int *arg
  
  	if (preserve_hard_links)
  		argstr[x++] = 'H';
 +	if (preserve_acls)
 +		argstr[x++] = 'A';
  	if (preserve_uid)
@@ -4692,35 +4720,39 @@
 +++ rsync.c	2004-07-03 20:11:58
 @@ -137,6 +137,14 @@ int set_perms(char *fname,struct file_st
  	}
  #endif
  
 +	/* If this is a directory, SET_ACL() will be called on the cleanup
-+	 * receive_generator() pass--if we called it here, we might clobber
-+	 * writability on the directory. everything else is OK to do now. */
++	 * receive_generator() pass (if we called it here, we might clobber
++	 * writability on the directory). Everything else is OK to do now. */
 +	if (!S_ISDIR(st->st_mode)) {
 +		if (SET_ACL(fname, file) == 0)
 +			updated = 1;
 +	}
 +
  	if (verbose > 1 && flags & PERMS_REPORT) {
  		enum logcode code = daemon_log_format_has_i || dry_run
  				  ? FCLIENT : FINFO;
---- orig/rsync.h	2005-03-28 20:56:55
-+++ rsync.h	2004-07-03 20:11:58
-@@ -639,6 +639,40 @@ struct stats {
+--- orig/rsync.h	2005-05-03 17:11:01
++++ rsync.h	2005-05-12 23:32:56
+@@ -638,6 +638,44 @@ struct stats {
  #include "lib/permstring.h"
  #include "lib/addrinfo.h"
  
-+#define SUPPORT_ACLS HAVE_POSIX_ACLS|HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|\
-+		HAVE_HPUX_ACLS|HAVE_IRIX_ACLS|HAVE_AIX_ACLS|HAVE_TRU64_ACLS
++#if HAVE_POSIX_ACLS|HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|\
++    HAVE_HPUX_ACLS|HAVE_IRIX_ACLS|HAVE_AIX_ACLS|HAVE_TRU64_ACLS
++#define SUPPORT_ACLS 1
++#endif
 +
-+#define ACLS_NEED_MASK HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|HAVE_HPUX_ACLS
++#if HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|HAVE_HPUX_ACLS
++#define ACLS_NEED_MASK 1
++#endif
 +
-+#if SUPPORT_ACLS
-+#if HAVE_SYS_ACL_H
++#ifdef SUPPORT_ACLS
++#ifdef HAVE_SYS_ACL_H
 +#include <sys/acl.h>
 +#endif
 +#define MAKE_ACL(file, fname)			make_acl(file, fname)
 +#define SEND_ACL(file, f)			send_acl(file, f)
 +#define RECEIVE_ACL(file, f)			receive_acl(file, f)
 +#define SORT_FILE_ACL_INDEX_LISTS()		sort_file_acl_index_lists()
@@ -4745,24 +4777,24 @@
 +#endif /* SUPPORT_ACLS */
 +#include "smb_acls.h"
 +
  #include "proto.h"
  
  /* We have replacement versions of these if they're missing. */
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2004-07-03 20:11:58
-@@ -316,6 +316,7 @@ to the detailed description below for a 
+@@ -317,6 +317,7 @@ to the detailed description below for a 
   -H, --hard-links            preserve hard links
   -K, --keep-dirlinks         treat symlinked dir on receiver as dir
   -p, --perms                 preserve permissions
 + -A, --acls                  preserve ACLs (implies -p) [local option]
   -o, --owner                 preserve owner (root only)
   -g, --group                 preserve group
   -D, --devices               preserve devices (root only)
-@@ -625,6 +626,11 @@ source file's permissions and the umask 
- other files (including updated files) retain their existing permissions
+@@ -629,6 +630,11 @@ based on the source file's permissions, 
+ umask setting
  (which is the same behavior as other file-copy utilities, such as cp).
  
 +dit(bf(-A, --acls)) This option causes rsync to update the remote
 +ACLs to be the same as the local ACLs.  This will work only if the
 +remote machine's rsync supports this option also. This is a non-standard
 +option.
@@ -5097,20 +5129,20 @@
  		while ((id = read_int(f)) != 0) {
  			int len = read_byte(f);
 @@ -337,6 +338,18 @@ void recv_uid_list(int f, struct file_li
  		}
  	}
  
-+#if SUPPORT_ACLS
++#ifdef SUPPORT_ACLS
 +	if (preserve_acls && !numeric_ids) {
 +		id_t id;
-+		/* the enumerations don't return 0 except to flag the last
-+		 * entry, since uidlist doesn't munge 0 anyway */
-+		while ((id = next_acl_uid(flist)))
++		/* The enumerations don't return 0 except to flag the last
++		 * entry, since uidlist doesn't munge 0 anyway. */
++		while ((id = next_acl_uid(flist)) != 0)
 +			acl_uid_map(match_uid(id));
-+		while ((id = next_acl_gid(flist)))
++		while ((id = next_acl_gid(flist)) != 0)
 +			acl_gid_map(match_gid(id));
 +	}
 +#endif /* SUPPORT_ACLS */
 +
  	/* now convert the uid/gid of all files in the list to the mapped
  	 * uid/gid */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/append.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/append.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/append.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/append.diff	2005-06-02 00:22:41.000000000 +0800
@@ -1,20 +1,20 @@
 This patch adds the --append option, which works like a "resume" mode in
 an ftp client, appending new data onto the end of the files it updates.
 
---- orig/generator.c	2005-03-30 16:35:08
+--- orig/generator.c	2005-05-22 20:53:34
 +++ generator.c	2005-03-03 02:59:17
-@@ -53,6 +53,7 @@ extern int delay_updates;
+@@ -54,6 +54,7 @@ extern int delay_updates;
  extern int update_only;
  extern int opt_ignore_existing;
  extern int inplace;
 +extern int append_mode;
  extern int make_backups;
  extern int csum_length;
  extern int ignore_times;
-@@ -465,35 +466,42 @@ static void generate_and_send_sums(int f
+@@ -468,35 +469,42 @@ static void generate_and_send_sums(int f
  	OFF_T offset = 0;
  
  	sum_sizes_sqroot(&sum, len);
 +	write_sum_head(f_out, &sum);
 +
 +	if (append_mode > 0 && f_copy < 0)
@@ -58,40 +58,40 @@
  		write_buf(f_out, sum2, sum.s2length);
 -		len -= n1;
 -		offset += n1;
  	}
  
  	if (mapbuf)
-@@ -972,6 +980,9 @@ static void recv_generator(char *fname, 
+@@ -1005,6 +1013,9 @@ static void recv_generator(char *fname, 
  		return;
  	}
  
 +	if (append_mode && st.st_size > file->length)
 +		return;
 +
  	if (!compare_dest && fnamecmp_type <= FNAMECMP_BASIS_DIR_HIGH)
  		;
  	else if (fnamecmp_type == FNAMECMP_FUZZY)
-@@ -1144,7 +1155,7 @@ void generate_files(int f_out, struct fi
+@@ -1178,7 +1189,7 @@ void generate_files(int f_out, struct fi
  		do_delete_pass(flist);
  	do_progress = 0;
  
 -	if (whole_file < 0)
 +	if (append_mode || whole_file < 0)
  		whole_file = 0;
  	if (verbose >= 2) {
  		rprintf(FINFO, "delta-transmission %s\n",
-@@ -1195,6 +1206,8 @@ void generate_files(int f_out, struct fi
+@@ -1235,6 +1246,8 @@ void generate_files(int f_out, struct fi
  	only_existing = max_size = opt_ignore_existing = 0;
  	update_only = always_checksum = size_only = 0;
  	ignore_times = 1;
 +	if (append_mode)  /* resend w/o append mode */
 +		append_mode = -1; /* ... but only longer files */
  	make_backups = 0; /* avoid a duplicate backup for inplace processing */
  
- 	/* We expect to just sit around now, so don't exit on a timeout.
+ 	if (verbose > 2)
 --- orig/match.c	2005-03-05 17:51:23
 +++ match.c	2005-02-11 20:26:31
 @@ -23,6 +23,7 @@ extern int verbose;
  extern int am_server;
  extern int do_progress;
  extern int checksum_seed;
@@ -127,56 +127,56 @@
  		/* by doing this in pieces we avoid too many seeks */
 -		for (j = CHUNK_SIZE; j < len; j += CHUNK_SIZE)
 +		for (j = last_match + CHUNK_SIZE; j < len; j += CHUNK_SIZE)
  			matched(f, s, buf, j, -2);
  		matched(f, s, buf, len, -1);
  	}
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-03-11 11:21:34
-@@ -39,6 +39,7 @@ int make_backups = 0;
+@@ -38,6 +38,7 @@ int make_backups = 0;
   **/
  int whole_file = -1;
  
 +int append_mode = 0;
  int archive_mode = 0;
  int keep_dirlinks = 0;
  int copy_links = 0;
-@@ -165,6 +166,7 @@ static int modify_window_set;
+@@ -166,6 +167,7 @@ static int modify_window_set;
  static int itemize_changes = 0;
  static int refused_delete, refused_archive_part;
  static int refused_partial, refused_progress, refused_delete_before;
 +static int refused_inplace;
  static char *max_size_arg;
  static char partialdir_for_delayupdate[] = ".~tmp~";
  
-@@ -273,6 +275,7 @@ void usage(enum logcode F)
+@@ -274,6 +276,7 @@ void usage(enum logcode F)
    rprintf(F,"     --suffix=SUFFIX         set backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
    rprintf(F," -u, --update                skip files that are newer on the receiver\n");
    rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
 +  rprintf(F,"     --append                append data onto shorter files\n");
    rprintf(F," -d, --dirs                  transfer directories without recursing\n");
    rprintf(F," -l, --links                 copy symlinks as symlinks\n");
    rprintf(F," -L, --copy-links            transform symlink into referent file/dir\n");
-@@ -401,6 +404,7 @@ static struct poptOption long_options[] 
+@@ -404,6 +407,7 @@ static struct poptOption long_options[] 
    {"links",           'l', POPT_ARG_NONE,   &preserve_links, 0, 0, 0 },
    {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
    {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
 +  {"append",           0,  POPT_ARG_VAL,    &append_mode, 1, 0, 0 },
    {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
    {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
    {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
-@@ -575,6 +579,8 @@ static void set_refuse_options(char *bp)
+@@ -579,6 +583,8 @@ static void set_refuse_options(char *bp)
  						refused_partial = op->val;
  					else if (wildmatch("progress", op->longName))
  						refused_progress = op->val;
 +					else if (wildmatch("inplace", op->longName))
 +						refused_inplace = op->val;
  					break;
  				}
  				if (!is_wild)
-@@ -1108,6 +1114,14 @@ int parse_arguments(int *argc, const cha
+@@ -1126,6 +1132,14 @@ int parse_arguments(int *argc, const cha
  			bwlimit_writemax = 512;
  	}
  
 +	if (append_mode) {
 +		if (refused_inplace) {
 +			create_refuse_error(refused_inplace);
@@ -185,34 +185,34 @@
 +		inplace = 1;
 +	}
 +
  	if (delay_updates && !partial_dir)
  		partial_dir = partialdir_for_delayupdate;
  
-@@ -1418,7 +1432,9 @@ void server_options(char **args,int *arg
+@@ -1438,7 +1452,9 @@ void server_options(char **args,int *arg
  	if (opt_ignore_existing && am_sender)
  		args[ac++] = "--ignore-existing";
  
 -	if (inplace)
 +	if (append_mode)
 +		args[ac++] = "--append";
 +	else if (inplace)
  		args[ac++] = "--inplace";
  
  	if (tmpdir) {
---- orig/receiver.c	2005-03-29 22:39:37
+--- orig/receiver.c	2005-04-14 01:53:12
 +++ receiver.c	2005-02-11 20:26:32
-@@ -44,6 +44,7 @@ extern int remove_sent_files;
+@@ -45,6 +45,7 @@ extern int remove_sent_files;
  extern int module_id;
  extern int ignore_errors;
  extern int orig_umask;
 +extern int append_mode;
  extern int keep_partial;
  extern int checksum_seed;
  extern int inplace;
-@@ -211,6 +212,28 @@ static int receive_data(int f_in, char *
+@@ -212,6 +213,28 @@ static int receive_data(int f_in, char *
  
  	sum_init(checksum_seed);
  
 +	if (append_mode) {
 +		OFF_T j;
 +		sum.flength = (OFF_T)sum.count * sum.blength;
@@ -235,31 +235,31 @@
 +		}
 +	}
 +
  	while ((i = recv_token(f_in, &data)) != 0) {
  		if (do_progress)
  			show_progress(offset, total_size);
-@@ -416,6 +439,7 @@ int recv_files(int f_in, struct file_lis
+@@ -417,6 +440,7 @@ int recv_files(int f_in, struct file_lis
  			send_msg(MSG_DONE, "", 0);
  			if (keep_partial && !partial_dir)
  				make_backups = 0; /* prevents double backup */
 +			append_mode = 0;
  			continue;
  		}
  
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2005-02-11 20:36:38
-@@ -308,6 +308,7 @@ to the detailed description below for a 
+@@ -309,6 +309,7 @@ to the detailed description below for a 
       --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
   -u, --update                skip files that are newer on the receiver
       --inplace               update destination files in-place
 +     --append                append data onto shorter files
   -d, --dirs                  transfer directories without recursing
   -l, --links                 copy symlinks as symlinks
   -L, --copy-links            transform symlink into referent file/dir
-@@ -565,6 +566,14 @@ should not use this option to update fil
+@@ -568,6 +569,14 @@ should not use this option to update fil
  rsync will be unable to update a file in-place that is not writable by the
  receiving user.
  
 +dit(bf(--append)) This causes rsync to update a file by appending data onto
 +the end of the file, which presumes that the data that already exists on
 +the receiving side is identical with the start of the file on the sending
@@ -268,23 +268,23 @@
 +receiving side that is longer than a file on the sending side is skipped.
 +Implies bf(--inplace).
 +
  dit(bf(-d, --dirs)) Tell the sending side to include any directories that
  are encountered.  Unlike bf(--recursive), a directory's contents are not copied
  unless the directory was specified on the command-line as either "." or a
---- orig/sender.c	2005-03-28 20:56:55
-+++ sender.c	2005-03-16 02:25:18
-@@ -28,6 +28,7 @@ extern int log_format_has_i;
+--- orig/sender.c	2005-05-19 08:52:42
++++ sender.c	2005-05-19 08:53:05
+@@ -27,6 +27,7 @@ extern int log_before_transfer;
+ extern int log_format_has_i;
  extern int daemon_log_format_has_i;
  extern int csum_length;
- extern int io_error;
 +extern int append_mode;
+ extern int io_error;
+ extern int allowed_lull;
  extern int protocol_version;
- extern int remove_sent_files;
- extern int updating_basis_file;
-@@ -68,6 +69,13 @@ static struct sum_struct *receive_sums(i
+@@ -72,6 +73,13 @@ static struct sum_struct *receive_sums(i
  			(double)s->count, (long)s->blength, (long)s->remainder);
  	}
  
 +	if (append_mode) {
 +		s->flength = (OFF_T)s->count * s->blength;
 +		if (s->remainder)
@@ -292,13 +292,13 @@
 +		return s;
 +	}
 +
  	if (s->count == 0)
  		return(s);
  
-@@ -227,6 +235,7 @@ void send_files(struct file_list *flist,
+@@ -231,6 +239,7 @@ void send_files(struct file_list *flist,
  			/* For inplace: redo phase turns off the backup
  			 * flag so that we do a regular inplace send. */
  			make_backups = 0;
 +			append_mode = 0;
  			continue;
  		}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/backup-dir-dels.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/backup-dir-dels.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/backup-dir-dels.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/backup-dir-dels.diff	2005-06-02 00:22:41.000000000 +0800
@@ -103,25 +103,24 @@
 +	int ret;
 +	deleting = 1;
 +	ret = make_backup(fname);
 +	deleting = 0;
 +	return ret;
 +}
---- orig/generator.c	2005-03-30 16:35:08
+--- orig/generator.c	2005-05-22 20:53:34
 +++ generator.c	2005-03-11 11:22:38
-@@ -85,6 +85,9 @@ extern dev_t filesystem_dev;
+@@ -86,16 +86,23 @@ extern dev_t filesystem_dev;
  extern char *backup_dir;
  extern char *backup_suffix;
  extern int backup_suffix_len;
 +extern char *backup_dir_dels;
 +extern char *backup_suffix_dels;
 +extern int backup_suffix_dels_len;
  extern struct file_list *the_file_list;
  extern struct filter_list_struct server_filter_list;
  
-@@ -93,10 +96,14 @@ int allowed_lull = 0;
  static int deletion_count = 0; /* used to implement --max-delete */
  
  
 +/* Function now compares both backup_suffix and backup_suffix_dels. */
  static int is_backup_file(char *fn)
  {
@@ -131,38 +130,38 @@
 +		return 1;
 +	k += backup_suffix_len - backup_suffix_dels_len;
 +	return k > 0 && strcmp(fn+k, backup_suffix_dels) == 0;
  }
  
  
-@@ -113,8 +120,8 @@ static int delete_item(char *fname, int 
+@@ -112,8 +119,8 @@ static int delete_item(char *fname, int 
  	if (!S_ISDIR(mode)) {
  		if (max_delete && ++deletion_count > max_delete)
  			return 0;
 -		if (make_backups && (backup_dir || !is_backup_file(fname)))
 -			ok = make_backup(fname);
 +		if (make_backups && (backup_dir_dels || !is_backup_file(fname)))
 +			ok = safe_delete(fname);
  		else
  			ok = robust_unlink(fname) == 0;
  		if (ok) {
-@@ -137,9 +144,9 @@ static int delete_item(char *fname, int 
+@@ -136,9 +143,9 @@ static int delete_item(char *fname, int 
  	    || (dry_run && zap_dir)) {
  		ok = 0;
  		errno = ENOTEMPTY;
 -	} else if (make_backups && !backup_dir && !is_backup_file(fname)
 +	} else if (make_backups && !backup_dir_dels && !is_backup_file(fname)
  	    && !(flags & DEL_FORCE_RECURSE))
 -		ok = make_backup(fname);
 +		ok = safe_delete(fname);
  	else
  		ok = do_rmdir(fname) == 0;
  	if (ok) {
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-03-01 01:25:39
-@@ -127,10 +127,14 @@ int no_detach
+@@ -128,10 +128,14 @@ int no_detach
  int write_batch = 0;
  int read_batch = 0;
  int backup_dir_len = 0;
 +int backup_dir_dels_len = 0;	
  int backup_suffix_len;
 +int backup_suffix_dels_len;
@@ -171,57 +170,57 @@
  
  char *backup_suffix = NULL;
 +char *backup_suffix_dels = NULL;
  char *tmpdir = NULL;
  char *partial_dir = NULL;
  char *basis_dir[MAX_BASIS_DIRS+1];
-@@ -140,7 +144,9 @@ char *log_format = NULL;
+@@ -141,7 +145,9 @@ char *log_format = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
 +char *backup_dir_dels = NULL;
  char backup_dir_buf[MAXPATHLEN];
 +char backup_dir_dels_buf[MAXPATHLEN];
  int rsync_port = 0;
  int compare_dest = 0;
  int copy_dest = 0;
-@@ -271,6 +277,8 @@ void usage(enum logcode F)
+@@ -272,6 +278,8 @@ void usage(enum logcode F)
    rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
    rprintf(F,"     --backup-dir=DIR        make backups into hierarchy based in DIR\n");
    rprintf(F,"     --suffix=SUFFIX         set backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
 +  rprintf(F,"     --backup-dir-dels       make backups of removed files into current dir\n");
 +  rprintf(F,"     --suffix-dels=SUFFIX    set removed-files suffix (defaults to --suffix)\n");
    rprintf(F," -u, --update                skip files that are newer on the receiver\n");
    rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
    rprintf(F," -d, --dirs                  transfer directories without recursing\n");
-@@ -367,6 +375,7 @@ static struct poptOption long_options[] 
+@@ -370,6 +378,7 @@ static struct poptOption long_options[] 
    /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
    {"version",          0,  POPT_ARG_NONE,   0, OPT_VERSION, 0, 0},
    {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
 +  {"suffix-dels",      0,  POPT_ARG_STRING, &backup_suffix_dels, 0, 0, 0 },
    {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
    {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
    {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
-@@ -447,6 +456,7 @@ static struct poptOption long_options[] 
+@@ -451,6 +460,7 @@ static struct poptOption long_options[] 
    {"itemize-changes", 'i', POPT_ARG_NONE,   &itemize_changes, 0, 0, 0 },
    {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
    {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
 +  {"backup-dir-dels",  0,  POPT_ARG_STRING, &backup_dir_dels, 0, 0, 0 },
    {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
    {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
    {"write-batch",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },
-@@ -1008,6 +1018,8 @@ int parse_arguments(int *argc, const cha
+@@ -1021,6 +1031,8 @@ int parse_arguments(int *argc, const cha
  			partial_dir = sanitize_path(NULL, partial_dir, NULL, 0);
  		if (backup_dir)
  			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0);
 +		if (backup_dir_dels)							
 +			backup_dir_dels = sanitize_path(NULL, backup_dir_dels, NULL, 0);
  	}
  	if (server_filter_list.head && !am_sender) {
  		struct filter_list_struct *elp = &server_filter_list;
-@@ -1042,6 +1054,14 @@ int parse_arguments(int *argc, const cha
+@@ -1055,6 +1067,14 @@ int parse_arguments(int *argc, const cha
  				return 0;
  			}
  		}
 +		/* Clean backup_dir_dels same as for backup_dir */
 +		if (backup_dir_dels) {
 +			if (!*backup_dir_dels)
@@ -230,13 +229,13 @@
 +			if (check_filter(elp, backup_dir_dels, 1) < 0)
 +				goto options_rejected;
 +		}
  	}
  
  	if (!backup_suffix)
-@@ -1053,6 +1073,16 @@ int parse_arguments(int *argc, const cha
+@@ -1066,6 +1086,16 @@ int parse_arguments(int *argc, const cha
  			backup_suffix);
  		return 0;
  	}
 +	/* if backup_suffix_dels not supplied, default to backup_suffix */
 +	if (!backup_suffix_dels)
 +		backup_suffix_dels = backup_dir_dels ? "" : backup_suffix;
@@ -247,13 +246,13 @@
 +			backup_suffix_dels);	
 +		return 0;
 +	}
  	if (backup_dir) {
  		backup_dir_len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
  		backup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;
-@@ -1074,6 +1104,31 @@ int parse_arguments(int *argc, const cha
+@@ -1087,6 +1117,31 @@ int parse_arguments(int *argc, const cha
  			"--suffix cannot be a null string without --backup-dir\n");
  		return 0;
  	}
 +	/* If backup_dir_dels not supplied default to backup_dir if it has been supplied */
 +	if (backup_dir && !backup_dir_dels) {
 +		backup_dir_dels = backup_dir;
@@ -279,24 +278,24 @@
 +			"--suffix-dels cannot be a null string without --backup-dir-dels\n");
 +		return 0;
 +	}
  	if (make_backups && !backup_dir)
  		omit_dir_times = 1;
  
-@@ -1351,6 +1406,10 @@ void server_options(char **args,int *arg
+@@ -1369,6 +1424,10 @@ void server_options(char **args,int *arg
  		args[ac++] = "--backup-dir";
  		args[ac++] = backup_dir;
  	}
 +	if (backup_dir_dels) {
 +		args[ac++] = "--backup-dir-dels";
 +		args[ac++] = backup_dir_dels;
 +	}
  
  	/* Only send --suffix if it specifies a non-default value. */
  	if (strcmp(backup_suffix, backup_dir ? "" : BACKUP_SUFFIX) != 0) {
-@@ -1359,7 +1418,13 @@ void server_options(char **args,int *arg
+@@ -1377,7 +1436,13 @@ void server_options(char **args,int *arg
  			goto oom;
  		args[ac++] = arg;
  	}
 -
 +	/* Only send --suffix-dels if it specifies a non-default value. */
 +	if (strcmp(backup_suffix_dels, backup_dir_dels ? "" : BACKUP_SUFFIX) != 0) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/chmod-option.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/chmod-option.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/chmod-option.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/chmod-option.diff	2005-06-02 00:22:41.000000000 +0800
@@ -199,71 +199,71 @@
 +		next = chmod_modes->next;
 +		free(chmod_modes);
 +		chmod_modes = next;
 +	}
 +	return 0;
 +}
---- orig/flist.c	2005-03-30 17:31:41
+--- orig/flist.c	2005-05-28 08:24:57
 +++ flist.c	2004-09-18 01:51:11
 @@ -62,6 +62,8 @@ extern struct file_list *the_file_list;
  
  extern char curr_dir[MAXPATHLEN];
  
 +extern struct chmod_mode_struct *chmod_modes;
 +
  extern struct filter_list_struct filter_list;
  extern struct filter_list_struct server_filter_list;
  
-@@ -880,7 +882,10 @@ skip_filters:
+@@ -883,7 +885,10 @@ skip_filters:
  	file->flags = flags;
  	file->modtime = st.st_mtime;
  	file->length = st.st_size;
 -	file->mode = st.st_mode;
 +	if (chmod_modes && am_sender && (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode)))
 +		file->mode = tweak_mode(st.st_mode, chmod_modes);
 +	else
 +		file->mode = st.st_mode;
  	file->uid = st.st_uid;
  	file->gid = st.st_gid;
  
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-03-01 01:26:56
-@@ -140,6 +140,7 @@ char *log_format = NULL;
+@@ -141,6 +141,7 @@ char *log_format = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
 +char *chmod_mode = NULL;
  char backup_dir_buf[MAXPATHLEN];
  int rsync_port = 0;
  int compare_dest = 0;
-@@ -159,6 +160,8 @@ int list_only = 0;
+@@ -160,6 +161,8 @@ int list_only = 0;
  #define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
  char *batch_name = NULL;
  
 +struct chmod_mode_struct *chmod_modes = NULL;
 +
  static int daemon_opt;   /* sets am_daemon after option error-reporting */
  static int F_option_cnt = 0;
  static int modify_window_set;
-@@ -286,6 +289,7 @@ void usage(enum logcode F)
+@@ -287,6 +290,7 @@ void usage(enum logcode F)
    rprintf(F," -D, --devices               preserve devices (root only)\n");
    rprintf(F," -t, --times                 preserve times\n");
    rprintf(F," -O, --omit-dir-times        omit directories when preserving times\n");
 +  rprintf(F,"     --chmod=CHMOD           change destination permissions\n");
    rprintf(F," -S, --sparse                handle sparse files efficiently\n");
    rprintf(F," -n, --dry-run               show what would have been transferred\n");
    rprintf(F," -W, --whole-file            copy files whole (without rsync algorithm)\n");
-@@ -407,6 +411,7 @@ static struct poptOption long_options[] 
+@@ -410,6 +414,7 @@ static struct poptOption long_options[] 
    {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
    {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
    {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
 +  {"chmod",            0,  POPT_ARG_STRING, &chmod_mode, 0, 0, 0 },
    {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
    {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
    {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
-@@ -1077,6 +1082,13 @@ int parse_arguments(int *argc, const cha
+@@ -1090,6 +1095,13 @@ int parse_arguments(int *argc, const cha
  	if (make_backups && !backup_dir)
  		omit_dir_times = 1;
  
 +	if (chmod_mode && !(chmod_modes = parse_chmod(chmod_mode))) {
 +		snprintf(err_buf, sizeof err_buf,
 +		    "Invalid argument passed to chmod\n");
@@ -271,35 +271,35 @@
 +		return 0;
 +	}
 +
  	if (log_format) {
  		if (log_format_has(log_format, 'i'))
  			log_format_has_i = 1;
-@@ -1438,6 +1450,11 @@ void server_options(char **args,int *arg
+@@ -1458,6 +1470,11 @@ void server_options(char **args,int *arg
  		}
  	}
  
 +	if (chmod_mode && !am_sender) {
 +		args[ac++] = "--chmod";
 +		args[ac++] = chmod_mode;
 +	}
 +
  	if (files_from && (!am_sender || filesfrom_host)) {
  		if (filesfrom_host) {
  			args[ac++] = "--files-from";
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2005-01-24 01:48:43
-@@ -321,6 +321,7 @@ to the detailed description below for a 
+@@ -322,6 +322,7 @@ to the detailed description below for a 
   -D, --devices               preserve devices (root only)
   -t, --times                 preserve times
   -O, --omit-dir-times        omit directories when preserving times
 +     --chmod=CHMOD           change destination permissions
   -S, --sparse                handle sparse files efficiently
   -n, --dry-run               show what would have been transferred
   -W, --whole-file            copy files whole (without rsync algorithm)
-@@ -655,6 +656,14 @@ it is preserving modification times (see
+@@ -659,6 +660,14 @@ it is preserving modification times (see
  the directories on the receiving side, it is a good idea to use bf(-O).
  This option is inferred if you use bf(--backup) without bf(--backup-dir).
  
 +dit(bf(--chmod)) This options tells rsync to apply the listed "chmod" pattern
 +to the permission of the files on the destination.  In addition to the normal
 +parsing rules specified in the chmod manpage, you can specify an item that
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/copy-atimes.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/copy-atimes.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/copy-atimes.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/copy-atimes.diff	2005-06-02 00:22:41.000000000 +0800
@@ -1,24 +1,24 @@
 After applying this patch and running configure, you MUST run this
 command before "make":
 
     make proto
 
 
---- orig/batch.c	2005-03-27 05:13:14
+--- orig/batch.c	2005-04-09 18:00:28
 +++ batch.c	2004-07-03 20:15:41
-@@ -207,6 +207,8 @@ void show_flist(int index, struct file_s
+@@ -208,6 +208,8 @@ void show_flist(int index, struct file_s
  		rprintf(FINFO, "flist->flags=%#x\n", fptr[i]->flags);
  		rprintf(FINFO, "flist->modtime=%#lx\n",
  			(long unsigned) fptr[i]->modtime);
 +		rprintf(FINFO, "flist->atime=%#lx\n",
 +			(long unsigned) fptr[i]->atime);
  		rprintf(FINFO, "flist->length=%.0f\n",
  			(double) fptr[i]->length);
  		rprintf(FINFO, "flist->mode=%#o\n", (int) fptr[i]->mode);
---- orig/flist.c	2005-03-30 17:31:41
+--- orig/flist.c	2005-05-28 08:24:57
 +++ flist.c	2005-02-07 21:06:04
 @@ -54,6 +54,7 @@ extern int relative_paths;
  extern int implied_dirs;
  extern int copy_links;
  extern int copy_unsafe_links;
 +extern int copy_atimes;
@@ -116,67 +116,67 @@
  	file->flags = 0;
  	file->modtime = modtime;
 +	file->atime = atime;
  	file->length = file_length;
  	file->mode = mode;
  	file->uid = uid;
-@@ -879,6 +895,7 @@ skip_filters:
+@@ -882,6 +898,7 @@ skip_filters:
  
  	file->flags = flags;
  	file->modtime = st.st_mtime;
 +	file->atime = st.st_atime;
  	file->length = st.st_size;
  	file->mode = st.st_mode;
  	file->uid = st.st_uid;
---- orig/generator.c	2005-03-30 16:35:08
+--- orig/generator.c	2005-05-22 20:53:34
 +++ generator.c	2004-11-03 23:02:12
-@@ -372,7 +372,7 @@ static int unchanged_file(char *fn, stru
+@@ -375,7 +375,7 @@ static int unchanged_file(char *fn, stru
  	if (ignore_times)
  		return 0;
  
 -	return cmp_modtime(st->st_mtime, file->modtime) == 0;
 +	return cmp_time(st->st_mtime, file->modtime) == 0;
  }
  
  
-@@ -837,7 +837,7 @@ static void recv_generator(char *fname, 
+@@ -849,7 +849,7 @@ static void recv_generator(char *fname, 
  	}
  
  	if (update_only && statret == 0
 -	    && cmp_modtime(st.st_mtime, file->modtime) > 0) {
 +	    && cmp_time(st.st_mtime, file->modtime) > 0) {
  		if (verbose > 1)
  			rprintf(FINFO, "%s is newer\n", safe_fname(fname));
  		return;
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-02-21 10:53:28
-@@ -50,6 +50,7 @@ int preserve_uid = 0;
+@@ -49,6 +49,7 @@ int preserve_uid = 0;
  int preserve_gid = 0;
  int preserve_times = 0;
  int omit_dir_times = 0;
 +int copy_atimes = 0;
  int update_only = 0;
  int cvs_exclude = 0;
  int dry_run = 0;
-@@ -285,6 +286,7 @@ void usage(enum logcode F)
+@@ -286,6 +287,7 @@ void usage(enum logcode F)
    rprintf(F," -g, --group                 preserve group\n");
    rprintf(F," -D, --devices               preserve devices (root only)\n");
    rprintf(F," -t, --times                 preserve times\n");
 +  rprintf(F," -A, --copy-atimes           copy access times\n");
    rprintf(F," -O, --omit-dir-times        omit directories when preserving times\n");
    rprintf(F," -S, --sparse                handle sparse files efficiently\n");
    rprintf(F," -n, --dry-run               show what would have been transferred\n");
-@@ -410,6 +412,7 @@ static struct poptOption long_options[] 
+@@ -413,6 +415,7 @@ static struct poptOption long_options[] 
    {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
    {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
    {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
 +  {"copy-atimes",     'A', POPT_ARG_NONE,   &copy_atimes, 0, 0, 0 },
    {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
    {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
    {"quiet",           'q', POPT_ARG_NONE,   0, 'q', 0, 0 },
-@@ -1272,6 +1275,8 @@ void server_options(char **args,int *arg
+@@ -1290,6 +1293,8 @@ void server_options(char **args,int *arg
  		argstr[x++] = 'D';
  	if (preserve_times)
  		argstr[x++] = 't';
 +	if (copy_atimes)
 +		argstr[x++] = 'A';
  	if (omit_dir_times == 2 && am_sender)
@@ -231,13 +231,13 @@
 +		rsyserr(FERROR, errno, "failed to set times on %s",
 +			full_fname(fname));
 +		return 0;
  	}
  
  	change_uid = am_root && preserve_uid && st->st_uid != file->uid;
---- orig/rsync.h	2005-03-28 20:56:55
+--- orig/rsync.h	2005-05-03 17:11:01
 +++ rsync.h	2004-07-03 20:15:41
 @@ -54,6 +54,7 @@
  #define XMIT_HAS_IDEV_DATA (1<<9)
  #define XMIT_SAME_DEV (1<<10)
  #define XMIT_RDEV_MINOR_IS_SMALL (1<<11)
 +#define XMIT_SAME_ATIME (1<<12)
@@ -249,31 +249,31 @@
  #define PERMS_REPORT		(1<<0)
  #define PERMS_SKIP_MTIME	(1<<1)
 +#define PERMS_SKIP_ATIME	(1<<2)
  
  #define FULL_FLUSH	1
  #define NORMAL_FLUSH	0
-@@ -510,6 +512,7 @@ struct file_struct {
+@@ -509,6 +511,7 @@ struct file_struct {
  		struct hlink *links;
  	} link_u;
  	time_t modtime;
 +	time_t atime;
  	uid_t uid;
  	gid_t gid;
  	mode_t mode;
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2005-01-24 01:57:18
-@@ -321,6 +321,7 @@ to the detailed description below for a 
+@@ -322,6 +322,7 @@ to the detailed description below for a 
   -D, --devices               preserve devices (root only)
   -t, --times                 preserve times
   -O, --omit-dir-times        omit directories when preserving times
 + -A, --copy-atimes           copy access times
   -S, --sparse                handle sparse files efficiently
   -n, --dry-run               show what would have been transferred
   -W, --whole-file            copy files whole (without rsync algorithm)
-@@ -655,6 +656,11 @@ it is preserving modification times (see
+@@ -659,6 +660,11 @@ it is preserving modification times (see
  the directories on the receiving side, it is a good idea to use bf(-O).
  This option is inferred if you use bf(--backup) without bf(--backup-dir).
  
 +dit(bf(-A, --copy-atimes)) This tells rsync to transfer access times
 +along with the files and update them on the remote system.  Note that
 +reading the source file may update the atime and hence repeated rsync
@@ -466,13 +466,13 @@
 +	for (; *extra_args; extra_args++)
 +		list_file(*extra_args);
 +	poptFreeContext(pc);
  
  	return 0;
  }
---- orig/util.c	2005-03-30 20:45:02
+--- orig/util.c	2005-05-03 16:47:33
 +++ util.c	2005-02-07 21:09:12
 @@ -128,12 +128,17 @@ void overflow(char *str)
  
  
  
 -int set_modtime(char *fname, time_t modtime)
@@ -510,24 +510,24 @@
  		struct timeval t[2];
 -		t[0].tv_sec = time(NULL);
 +		t[0].tv_sec = atime;
  		t[0].tv_usec = 0;
  		t[1].tv_sec = modtime;
  		t[1].tv_usec = 0;
-@@ -1146,8 +1151,8 @@ int msleep(int t)
+@@ -1156,8 +1161,8 @@ int msleep(int t)
  
  
  /**
 - * Determine if two file modification times are equivalent (either
 - * exact or in the modification timestamp window established by
 + * Determine if two file  times are equivalent (either
 + * exact or in the timestamp window established by
   * --modify-window).
   *
   * @retval 0 if the times should be treated as the same
-@@ -1156,7 +1161,7 @@ int msleep(int t)
+@@ -1166,7 +1171,7 @@ int msleep(int t)
   *
   * @retval -1 if the 2nd is later
   **/
 -int cmp_modtime(time_t file1, time_t file2)
 +int cmp_time(time_t file1, time_t file2)
  {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches: cvs-entries.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/date-only.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/date-only.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/date-only.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/date-only.diff	2005-06-02 00:22:41.000000000 +0800
@@ -12,78 +12,78 @@
 
 Best Regards,
 Jeremy Bornstein
 
 [Patched update to have context and apply to latest CVS source.]
 
---- orig/generator.c	2005-03-30 16:35:08
+--- orig/generator.c	2005-05-22 20:53:34
 +++ generator.c	2004-11-11 22:15:27
-@@ -56,6 +56,7 @@ extern int inplace;
+@@ -57,6 +57,7 @@ extern int inplace;
  extern int make_backups;
  extern int csum_length;
  extern int ignore_times;
 +extern int date_only;
  extern int size_only;
  extern OFF_T max_size;
- extern int io_timeout;
-@@ -354,6 +355,8 @@ void itemize(struct file_struct *file, i
+ extern int io_error;
+@@ -357,6 +358,8 @@ void itemize(struct file_struct *file, i
  /* Perform our quick-check heuristic for determining if a file is unchanged. */
  static int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
  {
 +	if (date_only)
 +		return cmp_modtime(st->st_mtime, file->modtime) == 0;
  	if (st->st_size != file->length)
  		return 0;
  
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-01-28 19:14:15
-@@ -89,6 +89,7 @@ int keep_partial = 0;
+@@ -90,6 +90,7 @@ int keep_partial = 0;
  int safe_symlinks = 0;
  int copy_unsafe_links = 0;
  int size_only = 0;
 +int date_only = 0;
  int daemon_bwlimit = 0;
  int bwlimit = 0;
  int fuzzy_basis = 0;
-@@ -314,6 +315,7 @@ void usage(enum logcode F)
+@@ -315,6 +316,7 @@ void usage(enum logcode F)
    rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
    rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
    rprintf(F,"     --size-only             skip files that match in size\n");
 +  rprintf(F,"     --date-only             skip files that match in mod-time\n");
    rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
    rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
    rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
-@@ -371,6 +373,7 @@ static struct poptOption long_options[] 
+@@ -374,6 +376,7 @@ static struct poptOption long_options[] 
    {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
    {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
    {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
 +  {"date-only",        0,  POPT_ARG_NONE,   &date_only, 0, 0, 0 },
    {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
    {"one-file-system", 'x', POPT_ARG_NONE,   &one_file_system, 0, 0, 0 },
    {"existing",         0,  POPT_ARG_NONE,   &only_existing, 0, 0, 0 },
-@@ -1378,6 +1381,9 @@ void server_options(char **args,int *arg
+@@ -1398,6 +1401,9 @@ void server_options(char **args,int *arg
  	if (size_only)
  		args[ac++] = "--size-only";
  
 +	if (date_only)
 +		args[ac++] = "--date-only";
 +
  	if (modify_window_set) {
  		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
  			goto oom;
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2005-02-11 22:49:10
-@@ -349,6 +349,7 @@ to the detailed description below for a 
+@@ -350,6 +350,7 @@ to the detailed description below for a 
       --timeout=TIME          set I/O timeout in seconds
   -I, --ignore-times          don't skip files that match size and time
       --size-only             skip files that match in size
 +     --date-only             skip files that match in mod-time
       --modify-window=NUM     compare mod-times with reduced accuracy
   -T, --temp-dir=DIR          create temporary files in directory DIR
   -y, --fuzzy                 find similar file for basis if no dest file
-@@ -446,6 +447,12 @@ regardless of timestamp. This is useful 
+@@ -449,6 +450,12 @@ regardless of timestamp. This is useful 
  after using another mirroring system which may not preserve timestamps
  exactly.
  
 +dit(bf(--date-only)) Normally rsync will skip any files that are
 +already the same size and have the same modification time-stamp. With the
 +--date-only option, files will be skipped if they have the same
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/fname-convert.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/fname-convert.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/fname-convert.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/fname-convert.diff	2005-06-02 00:22:41.000000000 +0800
@@ -74,23 +74,23 @@
  	io_flush(FULL_FLUSH);
 +	if (fname_convert_cmd)
 +		cleanup_fname_convert();
  	if (cleanup_fname)
  		do_unlink(cleanup_fname);
  	if (code)
---- orig/errcode.h	2005-03-16 02:19:29
+--- orig/errcode.h	2005-04-13 02:59:47
 +++ errcode.h	2004-07-02 21:38:59
-@@ -35,6 +35,7 @@
+@@ -34,6 +34,7 @@
  #define RERR_STREAMIO   12      /* error in rsync protocol data stream */
  #define RERR_MESSAGEIO  13      /* errors with program diagnostics */
  #define RERR_IPC        14      /* error in IPC code */
 +#define RERR_FNAMECONV  15      /* error in filename conversion */
  
  #define RERR_SIGNAL     20      /* status returned when sent SIGUSR1, SIGINT */
  #define RERR_WAITCHILD  21      /* some error returned by waitpid() */
---- orig/flist.c	2005-03-30 17:31:41
+--- orig/flist.c	2005-05-28 08:24:57
 +++ flist.c	2005-03-05 00:29:08
 @@ -57,6 +57,7 @@ extern int copy_unsafe_links;
  extern int protocol_version;
  extern int sanitize_paths;
  extern int orig_umask;
 +extern char *fname_convert_cmd;
@@ -116,43 +116,43 @@
 +	if (fname_convert_cmd && !am_server) /* fname conversion always done on client */
 +		convert_fname(thisname, lastname, MAXPATHLEN);
 +
  	clean_fname(thisname, 0);
  
  	if (sanitize_paths)
-@@ -1082,6 +1089,9 @@ struct file_list *send_file_list(int f, 
+@@ -1085,6 +1092,9 @@ struct file_list *send_file_list(int f, 
  	start_write = stats.total_written;
  	gettimeofday(&start_tv, NULL);
  
 +	if (!am_server)
 +		init_fname_convert();
 +
  	flist = flist_new(WITH_HLINK, "send_file_list");
  
  	io_start_buffering_out();
-@@ -1266,6 +1276,9 @@ struct file_list *send_file_list(int f, 
+@@ -1279,6 +1289,9 @@ struct file_list *send_file_list(int f, 
  	stats.flist_size = stats.total_written - start_write;
  	stats.num_files = flist->count;
  
 +	if (fname_convert_cmd && !am_server)
 +		cleanup_fname_convert();
 +
  	if (verbose > 3)
  		output_flist(flist);
  
-@@ -1287,6 +1300,9 @@ struct file_list *recv_file_list(int f)
+@@ -1300,6 +1313,9 @@ struct file_list *recv_file_list(int f)
  
  	start_read = stats.total_read;
  
 +	if (fname_convert_cmd && !am_server)
 +		init_fname_convert();
 +
  	flist = flist_new(WITH_HLINK, "recv_file_list");
  
  	flist->count = 0;
-@@ -1339,6 +1355,9 @@ struct file_list *recv_file_list(int f)
+@@ -1352,6 +1368,9 @@ struct file_list *recv_file_list(int f)
  			io_error |= read_int(f);
  	}
  
 +	if (fname_convert_cmd && !am_server)
 +		cleanup_fname_convert();
 +
@@ -379,15 +379,15 @@
 +	if (*dest == '\n')
 +		memmove(dest, dest+1, destp-dest-1);
 +
 +	if (verbose > 2)
 +		rprintf(FINFO, "Converted filename: %s -> %s\n", src, dest);
 +}
---- orig/generator.c	2005-03-30 16:35:08
+--- orig/generator.c	2005-05-22 20:53:34
 +++ generator.c	2005-03-05 00:29:37
-@@ -580,7 +580,13 @@ static int phase = 0;
+@@ -583,7 +583,13 @@ static int phase = 0;
   * start sending checksums.
   *
   * Note that f_out is set to -1 when doing final directory-permission and
 - * modification-time repair. */
 + * modification-time repair.
 + *
@@ -396,91 +396,91 @@
 + * files are printf()ed here but regular files are rprintf()ed on the
 + * sender (unconverted). To solve the above, move all progress
 + * reporting to the sender. */
  static void recv_generator(char *fname, struct file_struct *file, int ndx,
  			   int itemizing, int maybe_PERMS_REPORT,
  			   enum logcode code, int f_out)
---- orig/log.c	2005-03-31 03:03:27
+--- orig/log.c	2005-04-15 07:08:03
 +++ log.c	2004-07-03 20:18:02
 @@ -65,6 +65,7 @@ struct {
  	{ RERR_STREAMIO   , "error in rsync protocol data stream" },
  	{ RERR_MESSAGEIO  , "errors with program diagnostics" },
  	{ RERR_IPC        , "error in IPC code" },
 +	{ RERR_FNAMECONV  , "error in filename conversion" },
  	{ RERR_SIGNAL     , "received SIGUSR1 or SIGINT" },
  	{ RERR_WAITCHILD  , "some error returned by waitpid()" },
  	{ RERR_MALLOC     , "error allocating core memory buffers" },
---- orig/main.c	2005-03-30 16:57:27
+--- orig/main.c	2005-05-12 07:51:58
 +++ main.c	2004-07-22 00:31:47
-@@ -371,7 +371,7 @@ static pid_t do_cmd(char *cmd, char *mac
+@@ -373,7 +373,7 @@ static pid_t do_cmd(char *cmd, char *mac
  			whole_file = 1;
  		ret = local_child(argc, args, f_in, f_out, child_main);
  	} else
 -		ret = piped_child(args,f_in,f_out);
 +		ret = piped_child(args, f_in, f_out, blocking_io, 1);
  
  	if (dir)
  		free(dir);
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-02-14 02:50:32
-@@ -137,6 +137,7 @@ char *basis_dir[MAX_BASIS_DIRS+1];
+@@ -138,6 +138,7 @@ char *basis_dir[MAX_BASIS_DIRS+1];
  char *config_file = NULL;
  char *shell_cmd = NULL;
  char *log_format = NULL;
 +char *fname_convert_cmd = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
-@@ -320,6 +321,7 @@ void usage(enum logcode F)
+@@ -321,6 +322,7 @@ void usage(enum logcode F)
    rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
    rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
    rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
 +  rprintf(F,"     --fname-convert=CMD     invoke CMD for filename conversion\n");
    rprintf(F," -z, --compress              compress file data during the transfer\n");
    rprintf(F," -C, --cvs-exclude           auto-ignore files the same way CVS does\n");
    rprintf(F," -f, --filter=RULE           add a file-filtering RULE\n");
-@@ -430,6 +432,7 @@ static struct poptOption long_options[] 
+@@ -433,6 +435,7 @@ static struct poptOption long_options[] 
    {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
    {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
    {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
 +  {"fname-convert",    0,  POPT_ARG_STRING, &fname_convert_cmd, 0, 0, 0 },
    /* TODO: Should this take an optional int giving the compression level? */
    {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
    {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
---- orig/pipe.c	2005-02-07 20:36:43
+--- orig/pipe.c	2005-04-09 18:00:29
 +++ pipe.c	2004-07-03 20:18:02
 @@ -23,7 +23,6 @@
  
  extern int am_sender;
  extern int am_server;
 -extern int blocking_io;
  extern int orig_umask;
- extern int write_batch;
  extern int filesfrom_fd;
-@@ -40,8 +39,10 @@ extern int filesfrom_fd;
+ 
+@@ -39,8 +38,10 @@ extern int filesfrom_fd;
   * If blocking_io is set then use blocking io on both fds. That can be
   * used to cope with badly broken rsh implementations like the one on
   * Solaris.
 + *
 + * If register_child is nonzero then the child is registered for autocleanup.
   **/
 -pid_t piped_child(char **command, int *f_in, int *f_out)
 +pid_t piped_child(char **command, int *f_in, int *f_out, int blocking_io, int register_child)
  {
  	pid_t pid;
  	int to_child_pipe[2];
-@@ -56,7 +57,7 @@ pid_t piped_child(char **command, int *f
+@@ -55,7 +56,7 @@ pid_t piped_child(char **command, int *f
  		exit_cleanup(RERR_IPC);
  	}
  
 -	pid = do_fork();
 +	pid = register_child ? do_fork() : fork();
  	if (pid == -1) {
  		rsyserr(FERROR, errno, "fork");
  		exit_cleanup(RERR_IPC);
---- orig/syscall.c	2005-02-14 00:58:10
+--- orig/syscall.c	2005-04-07 17:04:26
 +++ syscall.c	2004-07-02 21:39:00
 @@ -259,3 +259,34 @@ char *d_name(struct dirent *di)
  	return di->d_name;
  #endif
  }
 +
@@ -511,15 +511,15 @@
 +		--(timeout)->tv_sec;
 +		timeout->tv_usec += 1000000;
 +	}
 +
 +	return result;
 +}
---- orig/util.c	2005-03-30 20:45:02
+--- orig/util.c	2005-05-03 16:47:33
 +++ util.c	2004-07-03 20:18:02
-@@ -1328,3 +1328,55 @@ uint32 fuzzy_distance(const char *s1, in
+@@ -1338,3 +1338,55 @@ uint32 fuzzy_distance(const char *s1, in
  
  	return a[len2-1];
  }
 +
 +/**
 + * Blocks until one of the following happens:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/fsync.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/fsync.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/fsync.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/fsync.diff	2005-05-20 05:44:21.000000000 +0800
@@ -1,56 +1,56 @@
 This patch from Sami Farin lets you specify --fsync if you want fsync()
 to be called on every file we write.
 
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-01-28 19:30:47
-@@ -39,6 +39,7 @@ int make_backups = 0;
+@@ -38,6 +38,7 @@ int make_backups = 0;
   **/
  int whole_file = -1;
  
 +int do_fsync = 0;
  int archive_mode = 0;
  int keep_dirlinks = 0;
  int copy_links = 0;
-@@ -310,6 +311,7 @@ void usage(enum logcode F)
+@@ -311,6 +312,7 @@ void usage(enum logcode F)
    rprintf(F,"     --partial               keep partially transferred files\n");
    rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
    rprintf(F,"     --delay-updates         put all updated files into place at transfer's end\n");
 +  rprintf(F,"     --fsync                 fsync every written file\n");
    rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
    rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
    rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
-@@ -392,6 +394,7 @@ static struct poptOption long_options[] 
+@@ -395,6 +397,7 @@ static struct poptOption long_options[] 
    {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
    {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
    {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
 +  {"fsync",            0,  POPT_ARG_NONE,   &do_fsync, 0, 0, 0 },
    {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
    {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
    {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
-@@ -1426,6 +1429,9 @@ void server_options(char **args,int *arg
+@@ -1446,6 +1449,9 @@ void server_options(char **args,int *arg
  		args[ac++] = tmpdir;
  	}
  
 +	if (do_fsync && am_sender)
 +		args[ac++] = "--fsync";
 +
  	if (basis_dir[0] && am_sender) {
  		/* the server only needs this option if it is not the sender,
  		 *   and it may be an older version that doesn't know this
---- orig/receiver.c	2005-03-29 22:39:37
+--- orig/receiver.c	2005-04-14 01:53:12
 +++ receiver.c	2005-02-20 00:17:37
-@@ -37,6 +37,7 @@ extern int keep_dirlinks;
+@@ -38,6 +38,7 @@ extern int keep_dirlinks;
  extern int preserve_hard_links;
  extern int preserve_perms;
  extern int io_error;
 +extern int do_fsync;
  extern int basis_dir_cnt;
  extern int make_backups;
  extern int cleanup_got_literal;
-@@ -290,6 +291,12 @@ static int receive_data(int f_in, char *
+@@ -291,6 +292,12 @@ static int receive_data(int f_in, char *
  		exit_cleanup(RERR_FILEIO);
  	}
  
 +	if (do_fsync && fd != -1 && fsync(fd) != 0) {
 +		rsyserr(FERROR, errno, "fsync failed on %s",
 +			full_fname(fname));
@@ -67,13 +67,13 @@
  int modify_window = 0;
  int module_id = -1;
 +int do_fsync;
  char *partial_dir;
  struct filter_list_struct server_filter_list;
  
---- orig/util.c	2005-03-30 20:45:02
+--- orig/util.c	2005-05-03 16:47:33
 +++ util.c	2004-07-03 20:18:13
 @@ -33,6 +33,7 @@ extern int module_id;
  extern int modify_window;
  extern char *partial_dir;
  extern struct filter_list_struct server_filter_list;
 +extern int do_fsync;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/ignore-case.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/ignore-case.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/ignore-case.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/ignore-case.diff	2005-05-20 05:44:21.000000000 +0800
@@ -32,39 +32,39 @@
 +		}
 +	    }
 +	    return FALSE;
  	  case '?':
  	    /* Match anything but '/'. */
  	    if (*text == '/')
---- orig/options.c	2005-03-31 00:24:21
-+++ options.c	2004-10-14 17:22:51
-@@ -100,6 +100,7 @@ int max_delete = 0;
+--- orig/options.c	2005-05-19 08:52:42
++++ options.c	2005-05-03 16:47:52
+@@ -101,6 +101,7 @@ int max_delete = 0;
  OFF_T max_size = 0;
  int ignore_errors = 0;
  int modify_window = 0;
 +int ignore_case = 0;
  int blocking_io = -1;
  int checksum_seed = 0;
  int inplace = 0;
-@@ -331,6 +332,7 @@ void usage(enum logcode F)
+@@ -332,6 +333,7 @@ void usage(enum logcode F)
    rprintf(F,"     --include-from=FILE     read include patterns from FILE\n");
    rprintf(F,"     --files-from=FILE       read list of source-file names from FILE\n");
-   rprintf(F," -0, --from0                 all *-from file lists are delimited by nulls\n");
+   rprintf(F," -0, --from0                 all *-from/filter files are delimited by 0s\n");
 +  rprintf(F,"     --ignore-case           ignore case when comparing filenames\n");
-   rprintf(F,"     --version               print version number\n");
+   rprintf(F,"     --address=ADDRESS       bind address for outgoing socket to daemon\n");
    rprintf(F,"     --port=PORT             specify double-colon alternate port number\n");
    rprintf(F,"     --blocking-io           use blocking I/O for the remote shell\n");
-@@ -389,6 +391,7 @@ static struct poptOption long_options[] 
+@@ -392,6 +394,7 @@ static struct poptOption long_options[] 
    {"include",          0,  POPT_ARG_STRING, 0, OPT_INCLUDE, 0, 0 },
    {"exclude-from",     0,  POPT_ARG_STRING, 0, OPT_EXCLUDE_FROM, 0, 0 },
    {"include-from",     0,  POPT_ARG_STRING, 0, OPT_INCLUDE_FROM, 0, 0 },
 +  {"ignore-case",      0,  POPT_ARG_NONE,   &ignore_case, 0, 0, 0 },
    {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
    {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
    {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
-@@ -1390,6 +1393,9 @@ void server_options(char **args,int *arg
+@@ -1410,6 +1413,9 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
  
 +	if (ignore_case)
 +		args[ac++] = "--ignore-case";
 +
@@ -78,23 +78,23 @@
  int modify_window = 0;
  int module_id = -1;
 +int ignore_case = 0;
  char *partial_dir;
  struct filter_list_struct server_filter_list;
  
---- orig/util.c	2005-03-30 20:45:02
+--- orig/util.c	2005-05-03 16:47:33
 +++ util.c	2004-08-13 16:40:34
 @@ -31,6 +31,7 @@ extern int verbose;
  extern int dry_run;
  extern int module_id;
  extern int modify_window;
 +extern int ignore_case;
  extern char *partial_dir;
  extern struct filter_list_struct server_filter_list;
  
-@@ -1019,11 +1020,23 @@ int u_strcmp(const char *cs1, const char
+@@ -1029,11 +1030,23 @@ int u_strcmp(const char *cs1, const char
  {
  	const uchar *s1 = (const uchar *)cs1;
  	const uchar *s2 = (const uchar *)cs2;
 + 	
 +	if (ignore_case) {
 +		uchar c1, c2;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/last-match.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/last-match.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/last-match.diff	2005-03-16 10:28:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/last-match.diff	2005-05-04 00:53:30.000000000 +0800
@@ -1,13 +1,13 @@
 This adds the ability to put rules into a filter/include/exclude file
 in last-match-wins order.  All you need to do is to start the file with
 this line:
 
 [last-match]
 
---- orig/exclude.c	2005-02-27 07:34:27
+--- orig/exclude.c	2005-04-28 15:56:50
 +++ exclude.c	2005-02-26 03:22:20
 @@ -73,6 +73,7 @@ static BOOL parent_dirscan = False;
  static struct filter_struct **mergelist_parents;
  static int mergelist_cnt = 0;
  static int mergelist_size = 0;
 +static int reversing_rules = 0;
@@ -21,40 +21,40 @@
 +	} else if (reversing_rules) {
 +		ret->next = listp->head;
 +		listp->head = ret;
  	} else {
  		ret->next = listp->tail->next;
  		listp->tail->next = ret;
-@@ -959,6 +963,7 @@ void parse_filter_file(struct filter_lis
+@@ -957,6 +961,7 @@ void parse_filter_file(struct filter_lis
  	char line[MAXPATHLEN+MAX_RULE_PREFIX+1]; /* +1 for trailing slash. */
  	char *eob = line + sizeof line - 1;
  	int word_split = mflags & MATCHFLG_WORD_SPLIT;
 +	int save_reversing_rules = reversing_rules;
  
  	if (!fname || !*fname)
  		return;
-@@ -994,6 +999,7 @@ void parse_filter_file(struct filter_lis
+@@ -992,6 +997,7 @@ void parse_filter_file(struct filter_lis
  	}
  	dirbuf[dirbuf_len] = '\0';
  
 +	reversing_rules = 0;
  	while (1) {
  		char *s = line;
  		int ch, overflow = 0;
-@@ -1017,6 +1023,10 @@ void parse_filter_file(struct filter_lis
+@@ -1015,6 +1021,10 @@ void parse_filter_file(struct filter_lis
  			s = line;
  		}
  		*s = '\0';
 +		if (*line == '[' && strcmp(line+1, "last-match]") == 0) {
 +			reversing_rules = 1;
 +			continue;
 +		}
  		/* Skip an empty token and (when line parsing) comments. */
  		if (*line && (word_split || (*line != ';' && *line != '#')))
  			parse_rule(listp, line, mflags, xflags);
-@@ -1024,6 +1034,7 @@ void parse_filter_file(struct filter_lis
+@@ -1022,6 +1032,7 @@ void parse_filter_file(struct filter_lis
  			break;
  	}
  	fclose(fp);
 +	reversing_rules = save_reversing_rules;
  }
  
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/link-by-hash.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/link-by-hash.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/link-by-hash.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/link-by-hash.diff	2005-06-02 00:22:41.000000000 +0800
@@ -127,13 +127,13 @@
 +		/* We need to have the largest fnbr in case we need to store
 +		 * a new file. */
 +		this_fnbr = atol(di->d_name);
 +		if (this_fnbr > *fnbr)
 +			*fnbr = this_fnbr;
 +
-+		hashfile = (struct hashfile_struct*)malloc(sizeof(struct hashfile_struct));
++		hashfile = new_array(struct hashfile_struct, 1);
 +		asprintf(&hashfile->name,"%s/%s",hashname,
 +			 di->d_name);
 +		if (do_stat(hashfile->name,&st) == -1) {
 +			rsyserr(FERROR, errno, "stat failed: %s", hashfile->name);
 +			kill_hashfile(hashfile);
 +			continue;
@@ -362,48 +362,48 @@
 +	free(linkname);
 +	free(hashname);
 +	return rc;
 +}
 +
 +#endif
---- orig/options.c	2005-03-31 00:24:21
-+++ options.c	2005-03-01 01:27:55
-@@ -140,6 +140,7 @@ char *log_format = NULL;
+--- orig/options.c	2005-05-19 08:52:42
++++ options.c	2005-05-19 08:55:42
+@@ -141,6 +141,7 @@ char *log_format = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
 +char *link_by_hash_dir = NULL;
  char backup_dir_buf[MAXPATHLEN];
  int rsync_port = 0;
  int compare_dest = 0;
-@@ -320,6 +321,7 @@ void usage(enum logcode F)
+@@ -321,6 +322,7 @@ void usage(enum logcode F)
    rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
    rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
    rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
 +  rprintf(F,"     --link-by-hash=DIR      create hardlinks by hash into DIR\n");
    rprintf(F," -z, --compress              compress file data during the transfer\n");
    rprintf(F," -C, --cvs-exclude           auto-ignore files the same way CVS does\n");
    rprintf(F," -f, --filter=RULE           add a file-filtering RULE\n");
-@@ -360,7 +362,7 @@ void usage(enum logcode F)
+@@ -362,7 +364,7 @@ void usage(enum logcode F)
+ 
  enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
        OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST,
-       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
--      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT, OPT_MAX_SIZE,
-+      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT, OPT_MAX_SIZE, OPT_LINK_BY_HASH,
+-      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
++      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_LINK_BY_HASH,
+       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
        OPT_REFUSED_BASE = 9000};
  
- static struct poptOption long_options[] = {
-@@ -429,6 +431,7 @@ static struct poptOption long_options[] 
+@@ -432,6 +434,7 @@ static struct poptOption long_options[] 
    {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
    {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
    {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
 +  {"link-by-hash",     0,  POPT_ARG_STRING, 0, OPT_LINK_BY_HASH, 0, 0},
    {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
    /* TODO: Should this take an optional int giving the compression level? */
    {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
-@@ -863,6 +866,21 @@ int parse_arguments(int *argc, const cha
+@@ -876,6 +879,21 @@ int parse_arguments(int *argc, const cha
  			basis_dir[basis_dir_cnt++] = (char *)arg;
  			break;
  
 +                case OPT_LINK_BY_HASH:
 +#if HAVE_LINK
 +			arg = poptGetOptArg(pc);
@@ -419,35 +419,35 @@
 +			return 0;
 +#endif
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1438,6 +1456,11 @@ void server_options(char **args,int *arg
+@@ -1458,6 +1476,11 @@ void server_options(char **args,int *arg
  		}
  	}
  
 +	if (link_by_hash_dir && am_sender) {
 +		args[ac++] = "--link-by-hash";
 +		args[ac++] = link_by_hash_dir;
 +	}
 +
  	if (files_from && (!am_sender || filesfrom_host)) {
  		if (filesfrom_host) {
  			args[ac++] = "--files-from";
---- orig/receiver.c	2005-03-29 22:39:37
+--- orig/receiver.c	2005-04-14 01:53:12
 +++ receiver.c	2005-01-15 21:29:13
-@@ -51,6 +51,7 @@ extern int delay_updates;
+@@ -52,6 +52,7 @@ extern int delay_updates;
  extern struct stats stats;
  extern char *log_format;
  extern char *tmpdir;
 +extern char *link_by_hash_dir;
  extern char *partial_dir;
  extern char *basis_dir[];
  extern struct file_list *the_file_list;
-@@ -184,12 +185,13 @@ static int get_tmpname(char *fnametmp, c
+@@ -185,12 +186,13 @@ static int get_tmpname(char *fnametmp, c
  
  
  static int receive_data(int f_in, char *fname_r, int fd_r, OFF_T size_r,
 -			char *fname, int fd, OFF_T total_size)
 +			char *fname, int fd, OFF_T total_size, char *md4)
  {
@@ -456,65 +456,65 @@
  	struct map_struct *mapbuf;
  	struct sum_struct sum;
 +	struct mdfour mdfour_data;
  	int32 len;
  	OFF_T offset = 0;
  	OFF_T offset2;
-@@ -209,6 +211,9 @@ static int receive_data(int f_in, char *
+@@ -210,6 +212,9 @@ static int receive_data(int f_in, char *
  	} else
  		mapbuf = NULL;
  
 +	if (md4)
 +		mdfour_begin(&mdfour_data);
 +
  	sum_init(checksum_seed);
  
  	while ((i = recv_token(f_in, &data)) != 0) {
-@@ -225,6 +230,8 @@ static int receive_data(int f_in, char *
+@@ -226,6 +231,8 @@ static int receive_data(int f_in, char *
  			cleanup_got_literal = 1;
  
  			sum_update(data, i);
 +			if (md4)
 +				mdfour_update(&mdfour_data,data,i);
  
  			if (fd != -1 && write_file(fd,data,i) != i)
  				goto report_write_error;
-@@ -251,6 +258,8 @@ static int receive_data(int f_in, char *
+@@ -252,6 +259,8 @@ static int receive_data(int f_in, char *
  
  			see_token(map, len);
  			sum_update(map, len);
 +			if (md4)
 +				mdfour_update(&mdfour_data,map,len);
  		}
  
  		if (inplace) {
-@@ -291,6 +300,8 @@ static int receive_data(int f_in, char *
+@@ -292,6 +301,8 @@ static int receive_data(int f_in, char *
  	}
  
  	sum_end(file_sum1);
 +	if (md4)
 +		mdfour_result(&mdfour_data, (unsigned char*)md4);
  
  	if (mapbuf)
  		unmap_file(mapbuf);
-@@ -306,7 +317,7 @@ static int receive_data(int f_in, char *
+@@ -307,7 +318,7 @@ static int receive_data(int f_in, char *
  
  static void discard_receive_data(int f_in, OFF_T length)
  {
 -	receive_data(f_in, NULL, -1, 0, NULL, -1, length);
 +	receive_data(f_in, NULL, -1, 0, NULL, -1, length, NULL);
  }
  
  static void handle_delayed_updates(struct file_list *flist, char *local_name)
-@@ -628,8 +639,12 @@ int recv_files(int f_in, struct file_lis
+@@ -635,8 +646,12 @@ int recv_files(int f_in, struct file_lis
  			rprintf(FINFO, "%s\n", safe_fname(fname));
  
  		/* recv file data */
 +#if HAVE_LINK
 +		if (link_by_hash_dir)
-+			file->u.sum = (char*)malloc(MD4_SUM_LENGTH);
++			file->u.sum = new_array(char, MD4_SUM_LENGTH);
 +#endif
  		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
 -				       fname, fd2, file->length);
 +				       fname, fd2, file->length, file->u.sum);
  
  		if (!log_before_transfer)
@@ -540,15 +540,15 @@
 +	else
 +#endif
 +		ret = robust_rename(fnametmp, fname, file->mode & INITACCESSPERMS);
  	if (ret < 0) {
  		rsyserr(FERROR, errno, "%s %s -> \"%s\"",
  		    ret == -2 ? "copy" : "rename",
---- orig/rsync.h	2005-03-28 20:56:55
+--- orig/rsync.h	2005-05-03 17:11:01
 +++ rsync.h	2004-07-03 20:20:15
-@@ -632,6 +632,14 @@ struct stats {
+@@ -631,6 +631,14 @@ struct stats {
  	int current_file_index;
  };
  
 +struct hashfile_struct {
 +	struct hashfile_struct *next;
 +	struct hashfile_struct *prev;
@@ -557,15 +557,15 @@
 +	uint32 nlink;
 +};
 +
  
  #include "byteorder.h"
  #include "lib/mdfour.h"
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2005-02-13 06:58:47
-@@ -355,6 +355,7 @@ to the detailed description below for a 
+@@ -356,6 +356,7 @@ to the detailed description below for a 
       --compare-dest=DIR      also compare received files relative to DIR
       --copy-dest=DIR         ... and include copies of unchanged files
       --link-dest=DIR         hardlink to files in DIR when unchanged
 +     --link-by-hash=DIR      create hardlinks by hash into DIR
   -z, --compress              compress file data during the transfer
   -C, --cvs-exclude           auto-ignore files in the same way CVS does
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/links-depth.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/links-depth.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/links-depth.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/links-depth.diff	2005-06-02 00:22:41.000000000 +0800
@@ -3,23 +3,23 @@
 
 The patch has been heavily modified from its original form to work
 with the latest codebase, but even in its original form it didn't
 handle relative symlinks properly, and that has not yet been fixed
 in this modified version.
 
---- orig/flist.c	2005-03-30 17:31:41
+--- orig/flist.c	2005-05-28 08:24:57
 +++ flist.c	2004-07-16 16:58:04
 @@ -45,6 +45,7 @@ extern int filesfrom_fd;
  extern int one_file_system;
  extern int keep_dirlinks;
  extern int preserve_links;
 +extern int follow_links_depth;
  extern int preserve_hard_links;
  extern int preserve_perms;
  extern int preserve_devices;
-@@ -731,6 +732,30 @@ static struct file_struct *receive_file_
+@@ -734,6 +735,30 @@ static struct file_struct *receive_file_
  }
  
  
 +#if SUPPORT_LINKS
 +static int links_depth(char *linkname, STRUCT_STAT *st_ptr)
 +{
@@ -44,13 +44,13 @@
 +}
 +#endif
 +
  /**
   * Create a file_struct for a named file by reading its stat()
   * information and performing extensive checks against global
-@@ -856,7 +881,13 @@ skip_filters:
+@@ -859,7 +884,13 @@ skip_filters:
  	basename_len = strlen(basename) + 1; /* count the '\0' */
  
  #ifdef SUPPORT_LINKS
 -	linkname_len = S_ISLNK(st.st_mode) ? strlen(linkname) + 1 : 0;
 +	if (S_ISLNK(st.st_mode)) {
 +		if (follow_links_depth && links_depth(linkname, &st))
@@ -59,41 +59,41 @@
 +			linkname_len = strlen(linkname) + 1;
 +	} else
 +		linkname_len = 0;
  #else
  	linkname_len = 0;
  #endif
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-01-28 19:33:24
-@@ -43,6 +43,7 @@ int archive_mode = 0;
+@@ -42,6 +42,7 @@ int archive_mode = 0;
  int keep_dirlinks = 0;
  int copy_links = 0;
  int preserve_links = 0;
 +int follow_links_depth = 0;
  int preserve_hard_links = 0;
  int preserve_perms = 0;
  int preserve_devices = 0;
-@@ -275,6 +276,7 @@ void usage(enum logcode F)
+@@ -276,6 +277,7 @@ void usage(enum logcode F)
    rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
    rprintf(F," -d, --dirs                  transfer directories without recursing\n");
    rprintf(F," -l, --links                 copy symlinks as symlinks\n");
 +  rprintf(F,"     --links-depth=NUM       follow symlinks up to NUM depth\n");
    rprintf(F," -L, --copy-links            transform symlink into referent file/dir\n");
    rprintf(F,"     --copy-unsafe-links     only \"unsafe\" symlinks are transformed\n");
    rprintf(F,"     --safe-links            ignore symlinks that point outside the source tree\n");
-@@ -399,6 +401,7 @@ static struct poptOption long_options[] 
+@@ -402,6 +404,7 @@ static struct poptOption long_options[] 
    {"inplace",          0,  POPT_ARG_NONE,   &inplace, 0, 0, 0 },
    {"dirs",            'd', POPT_ARG_VAL,    &xfer_dirs, 2, 0, 0 },
    {"links",           'l', POPT_ARG_NONE,   &preserve_links, 0, 0, 0 },
 +  {"links-depth",      0,  POPT_ARG_INT,    &follow_links_depth , 0, 0, 0 },
    {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
    {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
    {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2005-01-28 19:33:40
-@@ -310,6 +310,7 @@ to the detailed description below for a 
+@@ -311,6 +311,7 @@ to the detailed description below for a 
       --inplace               update destination files in-place
   -d, --dirs                  transfer directories without recursing
   -l, --links                 copy symlinks as symlinks
 +     --links-depth=NUM       follow symlinks up to NUM depth
   -L, --copy-links            transform symlink into referent file/dir
       --copy-unsafe-links     only "unsafe" symlinks are transformed
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches: min-size.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/ODBC-dblog.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/ODBC-dblog.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/ODBC-dblog.diff	2005-03-31 11:13:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/ODBC-dblog.diff	2005-06-02 00:22:41.000000000 +0800
@@ -84,74 +84,84 @@
     If set to true, the "custom unique id select" statement will be executed
     BEFORE the session row is inserted into the database.  (as is done when a
     sequence is used for unique IDs).  If False the statement will be executed
     after the session row is inserted (as is done when the session ID is
     automatically generates unique IDs).  Defaults to True.
 
-
 --- orig/Makefile.in	2004-11-02 16:47:15
-+++ Makefile.in	2004-07-03 20:22:18
++++ Makefile.in	2005-05-23 23:31:30
 @@ -32,7 +32,7 @@ ZLIBOBJ=zlib/deflate.o zlib/infblock.o z
  	zlib/inflate.o zlib/inftrees.o zlib/infutil.o zlib/trees.o \
  	zlib/zutil.o zlib/adler32.o
  OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
 -	main.o checksum.o match.o syscall.o log.o backup.o
 +	main.o checksum.o match.o syscall.o log.o backup.o @EXTRA_OBJECT@
  OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
  	fileio.o batch.o clientname.o
  OBJS3=progress.o pipe.o
 --- orig/cleanup.c	2005-03-05 18:58:38
-+++ cleanup.c	2004-07-03 20:22:18
-@@ -144,8 +144,12 @@ void _exit_cleanup(int code, const char 
++++ cleanup.c	2005-05-23 23:28:28
+@@ -39,6 +39,10 @@ void close_all(void)
+ 	int ret;
+ 	STRUCT_STAT st;
+ 
++#ifdef HAVE_LIBODBC
++	db_log_close();
++#endif
++
+ 	max_fd = sysconf(_SC_OPEN_MAX) - 1;
+ 	for (fd = max_fd; fd >= 0; fd--) {
+ 		if ((ret = do_fstat(fd, &st)) == 0) {
+@@ -144,8 +148,12 @@ void _exit_cleanup(int code, const char 
  			code = RERR_PARTIAL;
  	}
  
 -	if (code)
 +	if (code) {
  		log_exit(code, file, line);
-+#if HAVE_LIBODBC
++#ifdef HAVE_LIBODBC
 +		db_log_exit(code,file,line);
 +#endif
 +	}
  
  	if (verbose > 2) {
  		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n",
---- orig/clientserver.c	2005-03-31 00:24:21
-+++ clientserver.c	2004-07-03 20:22:18
-@@ -351,6 +351,9 @@ static int rsync_module(int f_in, int f_
+--- orig/clientserver.c	2005-05-19 08:52:42
++++ clientserver.c	2005-05-23 23:29:31
+@@ -346,6 +346,9 @@ static int rsync_module(int f_in, int f_
  		   XFLG_ANCHORED2ABS | XFLG_OLD_PREFIXES);
  
  	log_init();
-+#if HAVE_LIBODBC
++#ifdef HAVE_LIBODBC
 +	db_log_open();
 +#endif
  
  	if (use_chroot) {
  		/*
-@@ -473,6 +476,9 @@ static int rsync_module(int f_in, int f_
+@@ -468,6 +471,9 @@ static int rsync_module(int f_in, int f_
  			rprintf(FLOG, "rsync %s %s from %s@%s (%s)\n",
  				am_sender ? "on" : "to",
  				request, auth_user, host, addr);
-+#if HAVE_LIBODBC
++#ifdef HAVE_LIBODBC
 +			db_log_session();
 +#endif
  		} else {
  			rprintf(FLOG, "rsync %s %s from %s (%s)\n",
  				am_sender ? "on" : "to",
---- orig/configure.in	2005-03-29 11:15:05
-+++ configure.in	2004-07-03 20:22:18
+--- orig/configure.in	2005-05-28 08:24:57
++++ configure.in	2005-05-23 23:32:21
 @@ -94,6 +94,8 @@ AC_ARG_WITH(rsync-path,
  	[  --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)],
  	[ RSYNC_PATH="$with_rsync_path" ],
  	[ RSYNC_PATH="rsync" ])
 +AC_ARG_WITH(ODBC,
 +	[  --with-ODBC             compile in support for ODBC database logging])
  
  AC_DEFINE_UNQUOTED(RSYNC_PATH, "$RSYNC_PATH", [location of rsync on remote machine])
  
-@@ -524,6 +526,14 @@ then
+@@ -537,6 +539,14 @@ then
      AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])
  fi
  
 +if test x"$with_ODBC" = x"yes"
 +then
 +    AC_CHECK_HEADERS(sql.h sqlext.h sqltypes.h)
@@ -160,14 +170,14 @@
 +    AC_SUBST(EXTRA_OBJECT)
 +fi
 +
  AC_MSG_CHECKING([whether to use included libpopt])
  if test x"$with_included_popt" = x"yes"
  then
---- orig/dblog-tables-mysql.sql	2004-07-02 21:35:58
-+++ dblog-tables-mysql.sql	2004-07-02 21:35:58
+--- orig/dblog-tables-mysql.sql	2005-05-23 23:28:40
++++ dblog-tables-mysql.sql	2005-05-23 23:28:40
 @@ -0,0 +1,43 @@
 +drop table transfer;
 +drop table exit;
 +drop table session;
 +
 +CREATE TABLE session (
@@ -182,13 +192,12 @@
 +);
 +
 +CREATE TABLE transfer (
 +	id			int auto_increment NOT NULL,
 +	session_id		int NOT NULL,
 +	date			timestamp NOT NULL,
-+	file_path		varchar(255) NOT NULL,
 +	file_name		varchar(255) NOT NULL,
 +	file_size		bigint NOT NULL,
 +	bytes_transferred	bigint NOT NULL,
 +	checksum_bytes_transferred bigint NOT NULL,
 +	operation		varchar(20),
 +	Primary Key (id),
@@ -203,17 +212,18 @@
 +	total_bytes_read	bigint NOT NULL,
 +	total_size		bigint NOT NULL,
 +	error_text		varchar(128) NOT NULL,
 +	error_code		int NOT NULL,
 +	error_file		varchar(64) NOT NULL,
 +	error_line		int NOT NULL,
++	process_id		int NOT NULL,
 +	Primary Key (id),
 +	foreign key (session_id) references session (id)
 +);
---- orig/dblog-tables-postgresql.sql	2004-07-02 21:35:58
-+++ dblog-tables-postgresql.sql	2004-07-02 21:35:58
+--- orig/dblog-tables-postgresql.sql	2005-05-23 23:28:48
++++ dblog-tables-postgresql.sql	2005-05-23 23:28:48
 @@ -0,0 +1,45 @@
 +drop table transfer;
 +drop table exit;
 +drop table session;
 +drop sequence session_id_seq;
 +create sequence session_id_seq;
@@ -230,13 +240,12 @@
 +);
 +
 +CREATE TABLE "transfer" (
 +	"id"			serial NOT NULL,
 +	"session_id"		int NOT NULL,
 +	"date"			timestamp NOT NULL default now(),
-+	"file_path"		varchar(512) NOT NULL,
 +	"file_name"		varchar(512) NOT NULL,
 +	"file_size"		bigint NOT NULL,
 +	"bytes_transferred"	bigint NOT NULL,
 +	"checksum_bytes_transferred" bigint NOT NULL,
 +	"operation"		varchar(20),
 +	Primary Key (id),
@@ -251,47 +260,48 @@
 +	"total_bytes_read"	bigint NOT NULL,
 +	"total_size"		bigint NOT NULL,
 +	"error_text"		varchar(128) NOT NULL,
 +	"error_code"		int NOT NULL,
 +	"error_file"		varchar(64) NOT NULL,
 +	"error_line"		int NOT NULL,
++	"process_id"		int NOT NULL,
 +	Primary Key (id),
 +	foreign key (session_id) references session (id)
 +);
---- orig/dblog.c	2004-07-02 21:35:58
-+++ dblog.c	2004-07-02 21:35:58
-@@ -0,0 +1,352 @@
+--- orig/dblog.c	2005-05-24 07:12:54
++++ dblog.c	2005-05-24 07:12:54
+@@ -0,0 +1,360 @@
 +/*
 + *  ODBC Database logging functions
 + *
 + *  Written by Steve Sether, April 2004
 + *  steve@vellmont.com
 + */
 +
 +#include "rsync.h"
 +
-+#if HAVE_SQL_H
++#ifdef HAVE_SQL_H
 +#include <sql.h>
 +#else
-+#if HAVE_ODBC_SQL_H
++#ifdef HAVE_ODBC_SQL_H
 +#include <odbc/sql.h>
 +#endif
 +#endif
 +
-+#if HAVE_SQLEXT_H
++#ifdef HAVE_SQLEXT_H
 +#include <sqlext.h>
 +#else
-+#if HAVE_ODBC_SQLEXT_H
++#ifdef HAVE_ODBC_SQLEXT_H
 +#include <odbc/sqlext.h>
 +#endif
 +#endif
 +
-+#if HAVE_SQLTYPES_H
++#ifdef HAVE_SQLTYPES_H
 +#include <sqltypes.h>
 +#else
-+#if HAVE_ODBC_SQLTYPES_H
++#ifdef HAVE_ODBC_SQLTYPES_H
 +#include <odbc/sqltypes.h>
 +#endif
 +#endif
 +
 +SQLHENV db_environ_handle;			/* Handle ODBC environment */
 +long result;					/* result of functions */
@@ -542,23 +552,31 @@
 +	}
 +}
 +
 +void db_log_transfer(struct file_struct *file,struct stats *initial_stats,char *operation)
 +{
 +	extern struct stats stats;
-+	char strSqlStatement[1024];
-+	char strFilePath[255];
-+	char strFileName[255];
++	char strSqlStatement[2048];
++	char strFileName[MAXPATHLEN];
++	char *strFileNamePtr;
 +	char strFileSize[255];
 +	int64 intBytesTransferred;
 +	int64 intCheckSumBytes;
 +
 +	if (lp_database_logging(module_id)) {
 +		if (db_handle != NULL) {
-+			snprintf(strFileName,sizeof(strFileName), "%s",f_name(file));
-+			snprintf(strFilePath, sizeof(strFilePath), "%s", file->basedir?file->basedir:"");
++			strFileNamePtr = safe_fname(f_name(file));
++			if (am_sender && file->dir.root) {
++				pathjoin(strFileName, sizeof strFileName,
++					 file->dir.root, strFileNamePtr);
++				strFileNamePtr = strFileName;
++			}
++			clean_fname(strFileNamePtr, 0);
++			if (*strFileNamePtr == '/')
++				strFileNamePtr++;
++
 +			snprintf(strFileSize,sizeof(strFileSize),"%.0f", (double)file->length);
 +			if (am_sender) {
 +				intBytesTransferred = stats.total_written - initial_stats->total_written;
 +			} else {
 +				intBytesTransferred = stats.total_read - initial_stats->total_read;
 +			}
@@ -566,13 +584,13 @@
 +			if (!am_sender) {
 +				intCheckSumBytes = stats.total_written - initial_stats->total_written;
 +			} else {
 +				intCheckSumBytes = stats.total_read - initial_stats->total_read;
 +			}
 +
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"INSERT INTO %s (session_id,date,file_path, file_name, file_size, bytes_transferred, checksum_bytes_transferred, operation) VALUES ('%ld','%s','%s','%s','%s','%Ld','%Ld','%s');",lp_transfer_table_name(module_id),session_id,timestring(time(NULL)),sanitizeSql(strFilePath),sanitizeSql(strFileName),strFileSize,intBytesTransferred,intCheckSumBytes,operation);
++			snprintf(strSqlStatement,sizeof(strSqlStatement),"INSERT INTO %s (session_id,date, file_name, file_size, bytes_transferred, checksum_bytes_transferred, operation) VALUES ('%ld','%s','%s','%s','%Ld','%Ld','%s');",lp_transfer_table_name(module_id),session_id,timestring(time(NULL)),sanitizeSql(strFileNamePtr),strFileSize,intBytesTransferred,intCheckSumBytes,operation);
 +			result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
 +			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
 +				SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
 +				rprintf(FERROR,"Error at db_log_transfer:  Error in Insert %s %s\n",strSqlStatement,V_OD_msg);
 +				if (result == SQL_INVALID_HANDLE)
 +					rprintf(FERROR,"INVALID HANDLE\n");
@@ -596,13 +614,13 @@
 +				if (!error_text) {
 +					error_text = "unexplained error";
 +				}
 +			} else {
 +				error_text = "";
 +			}
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"INSERT INTO %s (session_id, date, total_bytes_written,total_bytes_read,total_size,error_text,error_code,error_file,error_line) VALUES ('%ld','%s','%Ld','%Ld','%Ld','%s','%d','%s','%d');",lp_exit_table_name(module_id),session_id,timestring(time(NULL)),stats.total_written,stats.total_read,stats.total_size,error_text,code,file,line);
++			snprintf(strSqlStatement,sizeof(strSqlStatement),"INSERT INTO %s (session_id, date, total_bytes_written,total_bytes_read,total_size,error_text,error_code,error_file,error_line,process_id) VALUES ('%ld','%s','%Ld','%Ld','%Ld','%s','%d','%s','%d','%d');",lp_exit_table_name(module_id),session_id,timestring(time(NULL)),stats.total_written,stats.total_read,stats.total_size,error_text,code,file,line,getpid());
 +
 +			result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
 +
 +			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
 +				SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
 +				rprintf(FERROR,"Error at db_log_exit: Error in Insert %s %s\n",strSqlStatement,V_OD_msg);
@@ -610,13 +628,13 @@
 +		}
 +	} else {
 +		rprintf(FERROR,"Error at db_log_exit: Not connected to database!\n");
 +	}
 +}
 --- orig/loadparm.c	2005-02-19 17:38:51
-+++ loadparm.c	2004-07-03 20:22:18
++++ loadparm.c	2005-05-23 23:29:42
 @@ -125,6 +125,17 @@ typedef struct
  	BOOL list;
  	BOOL use_chroot;
  	BOOL transfer_logging;
 +	BOOL database_logging;
 +	char *database_datasource;
@@ -683,53 +701,53 @@
 +FN_LOCAL_STRING(lp_unique_id_method,unique_id_method)
 +FN_LOCAL_STRING(lp_custom_unique_id_select,custom_unique_id_select)
 +FN_LOCAL_BOOL(lp_get_custom_id_before_insert,get_custom_id_before_insert)
  FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
  FN_LOCAL_BOOL(lp_ignore_nonreadable, ignore_nonreadable)
  FN_LOCAL_STRING(lp_uid, uid)
---- orig/log.c	2005-03-31 03:03:27
-+++ log.c	2004-07-03 20:22:18
+--- orig/log.c	2005-04-15 07:08:03
++++ log.c	2005-05-23 23:29:54
 @@ -84,7 +84,7 @@ struct {
  /*
   * Map from rsync error code to name, or return NULL.
   */
 -static char const *rerr_name(int code)
 +char const *rerr_name(int code)
  {
  	int i;
  	for (i = 0; rerr_names[i].name; i++) {
---- orig/main.c	2005-03-30 16:57:27
-+++ main.c	2004-07-03 20:22:18
-@@ -141,6 +141,9 @@ static void handle_stats(int f)
+--- orig/main.c	2005-05-12 07:51:58
++++ main.c	2005-05-23 23:30:01
+@@ -144,6 +144,9 @@ static void handle_stats(int f)
  
  	if (am_daemon) {
  		log_exit(0, __FILE__, __LINE__);
-+#if HAVE_LIBODBC
++#ifdef HAVE_LIBODBC
 +		db_log_exit(0,__FILE__,__LINE__);
 +#endif
  		if (f == -1 || !am_sender)
  			return;
  	}
---- orig/receiver.c	2005-03-29 22:39:37
-+++ receiver.c	2005-03-05 00:31:00
-@@ -633,6 +633,9 @@ int recv_files(int f_in, struct file_lis
+--- orig/receiver.c	2005-04-14 01:53:12
++++ receiver.c	2005-05-23 23:30:07
+@@ -640,6 +640,9 @@ int recv_files(int f_in, struct file_lis
  
  		if (!log_before_transfer)
  			log_item(file, &initial_stats, iflags, NULL);
-+#if HAVE_LIBODBC
++#ifdef HAVE_LIBODBC
 +		db_log_transfer(file, &initial_stats, "receive");
 +#endif
  
  		if (fd1 != -1)
  			close(fd1);
---- orig/sender.c	2005-03-28 20:56:55
-+++ sender.c	2005-03-05 00:31:19
-@@ -343,6 +343,9 @@ void send_files(struct file_list *flist,
+--- orig/sender.c	2005-05-19 08:52:42
++++ sender.c	2005-05-23 23:30:15
+@@ -347,6 +347,9 @@ void send_files(struct file_list *flist,
  
  		if (!log_before_transfer)
  			log_item(file, &initial_stats, iflags, NULL);
-+#if HAVE_LIBODBC
++#ifdef HAVE_LIBODBC
 +		db_log_transfer(file, &initial_stats,"send");
 +#endif
  
  		if (mbuf) {
  			j = unmap_file(mbuf);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches: only-write-batch.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/openssl-support.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/openssl-support.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/openssl-support.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/openssl-support.diff	2005-06-02 00:22:41.000000000 +0800
@@ -17,13 +17,13 @@
 
   2. An SSL connection is established by the client issuing the
      command:
 
        #starttls
 
-     And, if the server allows SSL, it replies with
+     And, if the daemon allows SSL, it replies with
 
        @RSYNCD: starttls
 
      At which point both sides begin negotiating the SSL connection.
      Servers that can't or don't want to use SSL just treat it as a
      normal unknown command.
@@ -69,45 +69,45 @@
 +		end_tls();
 +#endif
 +
  	if (verbose > 3) {
  		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): entered\n",
  			code, safe_fname(file), line);
---- orig/clientserver.c	2005-03-31 00:24:21
-+++ clientserver.c	2004-10-08 20:44:59
-@@ -45,6 +45,9 @@ extern int select_timeout;
+--- orig/clientserver.c	2005-05-19 08:52:42
++++ clientserver.c	2005-04-09 17:39:57
+@@ -44,6 +44,9 @@ extern int io_timeout;
  extern int orig_umask;
  extern int no_detach;
  extern int default_af_hint;
 +#if HAVE_OPENSSL
 +extern int use_ssl;
 +#endif
  extern char *bind_address;
  extern struct filter_list_struct server_filter_list;
  extern char *config_file;
-@@ -99,8 +102,18 @@ int start_socket_client(char *host, char
+@@ -98,8 +101,18 @@ int start_socket_client(char *host, char
  		exit_cleanup(RERR_SOCKETIO);
  
  	ret = start_inband_exchange(user, path, fd, fd, argc);
-+	if (ret < 0)
++	if (ret)
 +		return ret;
 +
 +#if HAVE_OPENSSL
 +	if (use_ssl) {
 +		int f_in = get_tls_rfd();
 +		int f_out = get_tls_wfd();
 +		return client_run(f_in, f_out, -1, argc, argv);
 +	}
 +#endif
  
--	return ret < 0? ret : client_run(fd, fd, -1, argc, argv);
+-	return ret ? ret : client_run(fd, fd, -1, argc, argv);
 +	return client_run(fd, fd, -1, argc, argv);
  }
  
  int start_inband_exchange(char *user, char *path, int f_in, int f_out, 
-@@ -161,6 +174,33 @@ int start_inband_exchange(char *user, ch
+@@ -160,6 +173,33 @@ int start_inband_exchange(char *user, ch
  	if (verbose > 1)
  		print_child_argv(sargs);
  
 +#if HAVE_OPENSSL
 +	if (use_ssl) {
 +		io_printf(f_out, "#starttls\n");
@@ -135,53 +135,53 @@
 +	}
 +#endif
 +
  	p = strchr(path,'/');
  	if (p) *p = 0;
  	io_printf(f_out, "%s\n", path);
-@@ -189,6 +229,10 @@ int start_inband_exchange(char *user, ch
+@@ -188,6 +228,10 @@ int start_inband_exchange(char *user, ch
  			 * server to terminate the listing of modules.
  			 * We don't want to go on and transfer
  			 * anything; just exit. */
 +#if HAVE_OPENSSL
 +			if (use_ssl)
 +				end_tls();
 +#endif
  			exit(0);
  		}
  
-@@ -196,6 +240,10 @@ int start_inband_exchange(char *user, ch
+@@ -195,6 +239,10 @@ int start_inband_exchange(char *user, ch
  			rprintf(FERROR, "%s\n", line);
  			/* This is always fatal; the server will now
  			 * close the socket. */
 +#if HAVE_OPENSSL
 +			if (use_ssl)
 +				end_tls();
 +#endif
- 			return RERR_STARTCLIENT;
- 		} else {
- 			rprintf(FINFO,"%s\n", line);
-@@ -549,6 +597,7 @@ static void send_listing(int fd)
+ 			return -1;
+ 		}
+ 
+@@ -541,6 +589,7 @@ static void send_listing(int fd)
  		io_printf(fd,"@RSYNCD: EXIT\n");
  }
  
 +
  /* this is called when a connection is established to a client
     and we want to start talking. The setup of the system is done from
     here */
-@@ -598,6 +647,9 @@ int start_daemon(int f_in, int f_out)
+@@ -590,6 +639,9 @@ int start_daemon(int f_in, int f_out)
  	if (protocol_version > remote_protocol)
  		protocol_version = remote_protocol;
  
 +#if HAVE_OPENSSL
 +retry:
 +#endif
  	line[0] = 0;
  	if (!read_line(f_in, line, sizeof line - 1))
  		return -1;
-@@ -607,6 +659,20 @@ int start_daemon(int f_in, int f_out)
+@@ -599,6 +651,20 @@ int start_daemon(int f_in, int f_out)
  		return -1;
  	}
  
 +#if HAVE_OPENSSL
 +	if (use_ssl && strcmp(line, "#starttls") == 0) {
 +		io_printf(f_out, "@RSYNCD: starttls\n");
@@ -196,15 +196,15 @@
 +	}
 +#endif
 +
  	if (*line == '#') {
  		/* it's some sort of command that I don't understand */
  		io_printf(f_out, "@ERROR: Unknown command '%s'\n", line);
---- orig/configure.in	2005-03-29 11:15:05
+--- orig/configure.in	2005-05-28 08:24:57
 +++ configure.in	2004-07-03 20:22:28
-@@ -271,6 +271,21 @@ yes
+@@ -284,6 +284,21 @@ yes
  	AC_SEARCH_LIBS(getaddrinfo, inet6)
  fi
  
 +AC_ARG_ENABLE(openssl,
 +              AC_HELP_STRING([--enable-openssl], [compile SSL support with OpenSSL.]))
 +
@@ -220,15 +220,15 @@
 +	fi
 +fi
 +
  AC_MSG_CHECKING([whether to call shutdown on all sockets])
  case $host_os in
  	*cygwin* ) AC_MSG_RESULT(yes)
---- orig/options.c	2005-03-31 00:24:21
-+++ options.c	2005-03-01 01:34:42
-@@ -156,6 +156,14 @@ int log_format_has_o_or_i = 0;
+--- orig/options.c	2005-05-19 08:52:42
++++ options.c	2005-05-19 08:58:46
+@@ -157,6 +157,14 @@ int log_format_has_o_or_i = 0;
  int always_checksum = 0;
  int list_only = 0;
  
 +#if HAVE_OPENSSL
 +int use_ssl = 0;
 +char *ssl_cert_path = NULL;
@@ -237,95 +237,95 @@
 +char *ssl_ca_path = NULL;
 +#endif
 +
  #define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
  char *batch_name = NULL;
  
-@@ -181,6 +189,7 @@ static void print_rsync_version(enum log
+@@ -182,6 +190,7 @@ static void print_rsync_version(enum log
  	char const *hardlinks = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
 +	char const *ssl = "no ";
  	STRUCT_STAT *dumstat;
  
  #ifdef HAVE_SOCKETPAIR
-@@ -203,6 +212,10 @@ static void print_rsync_version(enum log
+@@ -204,6 +213,10 @@ static void print_rsync_version(enum log
  	ipv6 = "";
  #endif
  
 +#if HAVE_OPENSSL
 +	ssl = "";
 +#endif
 +
  	rprintf(f, "%s  version %s  protocol version %d\n",
  		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
  	rprintf(f,
-@@ -216,10 +229,10 @@ static void print_rsync_version(enum log
+@@ -217,10 +230,10 @@ static void print_rsync_version(enum log
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
  	 * macros. */
 -	rprintf(f, "              %sinplace, %sIPv6, %d-bit system inums, %d-bit internal inums\n",
 +	rprintf(f, "              %sinplace, %sIPv6, %d-bit system inums, %d-bit internal inums, %sssl\n",
  		have_inplace, ipv6,
  		(int) (sizeof dumstat->st_ino * 8),
 -		(int) (sizeof (int64) * 8));
 +		(int) (sizeof (int64) * 8), ssl);
  #ifdef MAINTAINER_MODE
  	rprintf(f, "              panic action: \"%s\"\n",
  		get_panic_action());
-@@ -350,6 +363,13 @@ void usage(enum logcode F)
+@@ -352,6 +365,13 @@ void usage(enum logcode F)
    rprintf(F," -4, --ipv4                  prefer IPv4\n");
    rprintf(F," -6, --ipv6                  prefer IPv6\n");
  #endif
 +#if HAVE_OPENSSL
 +  rprintf(F,"     --ssl                   allow socket connections to use SSL\n");
-+  rprintf(F,"     --ssl-cert=FILE         path to server's SSL certificate\n");
-+  rprintf(F,"     --ssl-key=FILE          path to server's SSL private key\n");
++  rprintf(F,"     --ssl-cert=FILE         path to daemon's SSL certificate\n");
++  rprintf(F,"     --ssl-key=FILE          path to daemon's SSL private key\n");
 +  rprintf(F,"     --ssl-key-passwd=PASS   password for PEM-encoded private key\n");
 +  rprintf(F,"     --ssl-ca-certs=FILE     path to trusted CA certificates\n");
 +#endif
+   rprintf(F,"     --version               print version number\n");
    rprintf(F," -h, --help                  show this help screen\n");
  
-   rprintf(F,"\nUse \"rsync --daemon --help\" to see the daemon-mode command-line options.\n");
-@@ -360,7 +380,7 @@ void usage(enum logcode F)
+@@ -362,7 +382,7 @@ void usage(enum logcode F)
+ 
  enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
        OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST,
-       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
--      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT, OPT_MAX_SIZE,
-+      OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT, OPT_MAX_SIZE, OPT_USE_SSL,
+-      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
++      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_USE_SSL,
+       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
        OPT_REFUSED_BASE = 9000};
  
- static struct poptOption long_options[] = {
-@@ -459,6 +479,13 @@ static struct poptOption long_options[] 
+@@ -464,6 +484,13 @@ static struct poptOption long_options[] 
    {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
    {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
  #endif
 +#if HAVE_OPENSSL
 +  {"ssl",              0,  POPT_ARG_NONE,   0, OPT_USE_SSL, 0, 0},
 +  {"ssl-cert",         0,  POPT_ARG_STRING, &ssl_cert_path, OPT_USE_SSL, 0, 0},
 +  {"ssl-key",          0,  POPT_ARG_STRING, &ssl_key_path, OPT_USE_SSL, 0, 0},
 +  {"ssl-key-passwd",   0,  POPT_ARG_STRING, &ssl_key_passwd, OPT_USE_SSL, 0, 0},
 +  {"ssl-ca-certs",     0,  POPT_ARG_STRING, &ssl_ca_path, OPT_USE_SSL, 0, 0},
 +#endif
    /* All these options switch us into daemon-mode option-parsing. */
-   {"address",          0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
    {"config",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
-@@ -863,6 +890,12 @@ int parse_arguments(int *argc, const cha
+   {"daemon",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
+@@ -876,6 +903,12 @@ int parse_arguments(int *argc, const cha
  			basis_dir[basis_dir_cnt++] = (char *)arg;
  			break;
  
 +		case OPT_USE_SSL:
 +#if HAVE_OPENSSL
 +			use_ssl = 1;
 +#endif
 +			break;
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1111,6 +1144,17 @@ int parse_arguments(int *argc, const cha
+@@ -1129,6 +1162,17 @@ int parse_arguments(int *argc, const cha
  	if (delay_updates && !partial_dir)
  		partial_dir = partialdir_for_delayupdate;
  
 +#if HAVE_OPENSSL
 +	if (use_ssl) {
 +		if (init_tls()) {
@@ -337,13 +337,13 @@
 +	}
 +#endif
 +
  	if (inplace) {
  #ifdef HAVE_FTRUNCATE
  		if (partial_dir) {
-@@ -1478,11 +1522,28 @@ char *check_for_hostspec(char *s, char *
+@@ -1498,11 +1542,28 @@ char *check_for_hostspec(char *s, char *
  {
  	char *p;
  	int not_host;
 +	int url_prefix_len = sizeof URL_PREFIX - 1;
  
 -	if (port_ptr && strncasecmp(URL_PREFIX, s, strlen(URL_PREFIX)) == 0) {
@@ -368,23 +368,23 @@
  		int hostlen;
 -		s += strlen(URL_PREFIX);
 +		s += url_prefix_len;
  		if ((p = strchr(s, '/')) != NULL) {
  			hostlen = p - s;
  			path = p + 1;
---- orig/rsync.h	2005-03-28 20:56:55
+--- orig/rsync.h	2005-05-03 17:11:01
 +++ rsync.h	2004-10-08 21:01:33
 @@ -32,6 +32,7 @@
  
  #define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
  #define URL_PREFIX "rsync://"
 +#define SSL_URL_PREFIX "rsyncs://"
  
  #define BACKUP_SUFFIX "~"
  
-@@ -411,6 +412,11 @@ enum msgcode {
+@@ -410,6 +411,11 @@ enum msgcode {
  # define SIZEOF_INT64 SIZEOF_OFF_T
  #endif
  
 +#if HAVE_OPENSSL
 +#include <openssl/ssl.h>
 +#include <openssl/err.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/owner-group-mod.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/owner-group-mod.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/owner-group-mod.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/owner-group-mod.diff	2005-05-20 05:44:21.000000000 +0800
@@ -31,26 +31,26 @@
 +		if (preserve_uid)
 +			preserve_uid = 2;
 +		if (preserve_gid)
 +			preserve_gid = 2;
 +	}
  }
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2004-09-09 01:59:08
-@@ -405,8 +405,8 @@ static struct poptOption long_options[] 
+@@ -408,8 +408,8 @@ static struct poptOption long_options[] 
    {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
    {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
    {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
 -  {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
 -  {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
 +  {"owner",           'o', POPT_ARG_NONE,   0,               'o', 0, 0 },
 +  {"group",           'g', POPT_ARG_NONE,   0,               'g', 0, 0 },
    {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
    {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
    {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
-@@ -748,6 +748,14 @@ int parse_arguments(int *argc, const cha
+@@ -781,6 +781,14 @@ int parse_arguments(int *argc, const cha
  			usage(FINFO);
  			exit_cleanup(0);
  
 +		case 'o':
 +			preserve_uid++;
 +			break;
@@ -59,24 +59,24 @@
 +			preserve_gid++;
 +			break;
 +
  		case 'v':
  			verbose++;
  			break;
-@@ -950,8 +958,8 @@ int parse_arguments(int *argc, const cha
+@@ -963,8 +971,8 @@ int parse_arguments(int *argc, const cha
  #endif
  		preserve_perms = 1;
  		preserve_times = 1;
 -		preserve_gid = 1;
 -		preserve_uid = 1;
 +		preserve_uid |= 1;
 +		preserve_gid |= 1;
  		preserve_devices = 1;
  	}
  
-@@ -1264,10 +1272,16 @@ void server_options(char **args,int *arg
+@@ -1282,10 +1290,16 @@ void server_options(char **args,int *arg
  
  	if (preserve_hard_links)
  		argstr[x++] = 'H';
 -	if (preserve_uid)
 +	if (preserve_uid) {
  		argstr[x++] = 'o';
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches: rsyncd-perm.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/soften-links.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/soften-links.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/soften-links.diff	2005-03-16 10:28:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/soften-links.diff	2005-05-04 00:53:30.000000000 +0800
@@ -6,13 +6,13 @@
 I run one of the debian mirrors, and I had to write this patch because
 my archive is split between more than one disk. Would you accept a more
 polished version of this patch for inclusion in rsync?
 
 [Updated to latest CVS source by Wayne Davison.]
 
---- orig/syscall.c	2005-02-14 00:58:10
+--- orig/syscall.c	2005-04-07 17:04:26
 +++ syscall.c	2004-04-22 23:48:45
 @@ -62,9 +62,14 @@ int do_symlink(char *fname1, char *fname
  #ifdef HAVE_LINK
  int do_link(char *fname1, char *fname2)
  {
 +	int st;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/source-cd.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/source-cd.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/source-cd.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/source-cd.diff	2005-06-02 00:22:41.000000000 +0800
@@ -3,23 +3,23 @@
 is outside of the transfer.  For instance:
 
 rsync -avR --source-cd=/usr local/bin host:/
 
 For two systems where one uses /usr/local/bin and the other /local/bin.
 
---- orig/flist.c	2005-03-30 17:31:41
+--- orig/flist.c	2005-05-28 08:24:57
 +++ flist.c	2005-03-05 00:31:42
 @@ -57,6 +57,7 @@ extern int copy_unsafe_links;
  extern int protocol_version;
  extern int sanitize_paths;
  extern int orig_umask;
 +extern char *source_cd;
  extern struct stats stats;
  extern struct file_list *the_file_list;
  
-@@ -1086,13 +1087,14 @@ struct file_list *send_file_list(int f, 
+@@ -1089,13 +1090,14 @@ struct file_list *send_file_list(int f, 
  
  	io_start_buffering_out();
  	if (filesfrom_fd >= 0) {
 -		if (argv[0] && !push_dir(argv[0])) {
 -			rsyserr(FERROR, errno, "push_dir %s failed",
 -				full_fname(argv[0]));
@@ -33,51 +33,51 @@
 +			full_fname(source_cd));
 +		exit_cleanup(RERR_FILESELECT);
 +	}
  
  	while (1) {
  		struct file_struct *file;
---- orig/options.c	2005-03-31 00:24:21
+--- orig/options.c	2005-05-19 08:52:42
 +++ options.c	2005-03-01 01:37:22
-@@ -81,6 +81,7 @@ char *filesfrom_host = NULL;
+@@ -82,6 +82,7 @@ char *filesfrom_host = NULL;
  int eol_nulls = 0;
  int recurse = 0;
  int xfer_dirs = 0;
 +char *source_cd = NULL;
  int am_daemon = 0;
  int daemon_over_rsh = 0;
  int do_stats = 0;
-@@ -268,6 +269,7 @@ void usage(enum logcode F)
+@@ -269,6 +270,7 @@ void usage(enum logcode F)
    rprintf(F," -R, --relative              use relative path names\n");
    rprintf(F,"     --no-relative           turn off --relative\n");
    rprintf(F,"     --no-implied-dirs       don't send implied dirs with -R\n");
 +  rprintf(F,"     --source-cd=DIR         a relative source path starts in this DIR\n");
    rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
    rprintf(F,"     --backup-dir=DIR        make backups into hierarchy based in DIR\n");
    rprintf(F,"     --suffix=SUFFIX         set backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
-@@ -420,6 +422,7 @@ static struct poptOption long_options[] 
+@@ -423,6 +425,7 @@ static struct poptOption long_options[] 
    {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
    {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
    {"no-relative",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
 +  {"source-cd",        0,  POPT_ARG_STRING, &source_cd, 0, 0, 0 },
    {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
    {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
    {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
-@@ -914,6 +917,11 @@ int parse_arguments(int *argc, const cha
+@@ -927,6 +930,11 @@ int parse_arguments(int *argc, const cha
  		} else if (dry_run)
  			write_batch = 0;
  	}
 +	if (source_cd && files_from) {
 +		snprintf(err_buf, sizeof err_buf,
 +			"--source-cd cannot be used with --files-from\n");
 +		return 0;
 +	}
  	if (read_batch && files_from) {
  		snprintf(err_buf, sizeof err_buf,
  			"--read-batch cannot be used with --files-from\n");
-@@ -1008,6 +1016,14 @@ int parse_arguments(int *argc, const cha
+@@ -1021,6 +1029,14 @@ int parse_arguments(int *argc, const cha
  			partial_dir = sanitize_path(NULL, partial_dir, NULL, 0);
  		if (backup_dir)
  			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0);
 +		if (source_cd)
 +			source_cd = sanitize_path(NULL, source_cd, NULL, 0);
 +	} else if (source_cd && am_daemon) {
@@ -86,35 +86,35 @@
 +			if ((*argv)[i][0] == '/')
 +				(*argv)[i]++;
 +		}
  	}
  	if (server_filter_list.head && !am_sender) {
  		struct filter_list_struct *elp = &server_filter_list;
-@@ -1400,6 +1416,11 @@ void server_options(char **args,int *arg
+@@ -1420,6 +1436,11 @@ void server_options(char **args,int *arg
  	} else if (keep_partial)
  		args[ac++] = "--partial";
  
 +	if (source_cd && !am_sender) {
 +		args[ac++] = "--source-cd";
 +		args[ac++] = source_cd;
 +	}
 +
  	if (ignore_errors)
  		args[ac++] = "--ignore-errors";
  
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2005-02-22 18:20:24
-@@ -303,6 +303,7 @@ to the detailed description below for a 
+@@ -304,6 +304,7 @@ to the detailed description below for a 
   -R, --relative              use relative path names
       --no-relative           turn off --relative
       --no-implied-dirs       don't send implied dirs with -R
 +     --source-cd=DIR         a relative source path starts in this DIR
   -b, --backup                make backups (see --suffix & --backup-dir)
       --backup-dir=DIR        make backups into hierarchy based in DIR
       --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
-@@ -511,6 +512,11 @@ the bf(--no-implied-dirs) option would o
+@@ -514,6 +515,11 @@ the bf(--no-implied-dirs) option would o
  which means that if "/path" was a real directory on one machine and a
  symlink of the other machine, rsync would not try to change this.
  
 +dit(bf(--source-cd=DIR)) Set the specified directory as the default dir for
 +the source side of the transfer.  This is most useful when combined with
 +the bf(--relative) option because it lets you move directories from the
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/time-limit.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/time-limit.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/time-limit.diff	2005-03-31 11:13:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/time-limit.diff	2005-06-02 00:22:41.000000000 +0800
@@ -1,22 +1,22 @@
 John Taylor's patch for implementing --time-limit and --stop-at, reworked
 to be simpler and more efficient by Wayne Davison.
 
 Do we need configure support for mktime()?
 
---- orig/io.c	2005-03-09 18:54:02
-+++ io.c	2005-03-05 00:32:06
-@@ -56,6 +56,7 @@ extern int remove_sent_files;
+--- orig/io.c	2005-05-19 08:52:42
++++ io.c	2005-05-19 09:01:27
+@@ -57,6 +57,7 @@ extern int remove_sent_files;
  extern int preserve_hard_links;
  extern char *filesfrom_host;
  extern struct stats stats;
 +extern time_t stop_at_utime;
  extern struct file_list *the_file_list;
  
  const char phase_unknown[] = "unknown";
-@@ -163,16 +164,24 @@ static void check_timeout(void)
+@@ -165,16 +166,24 @@ static void check_timeout(void)
  {
  	time_t t;
  
 +	if ((!io_timeout || ignore_timeout) && !stop_at_utime)
 +		return;
 +
@@ -27,60 +27,60 @@
 +		exit_cleanup(RERR_TIMEOUT);
 +	}
 +
  	if (!io_timeout || ignore_timeout)
  		return;
  
- 	if (!last_io) {
--		last_io = time(NULL);
-+		last_io = t;
+ 	if (!last_io_in) {
+-		last_io_in = time(NULL);
++		last_io_in = t;
  		return;
  	}
  
 -	t = time(NULL);
 -
- 	if (t - last_io >= io_timeout) {
+ 	if (t - last_io_in >= io_timeout) {
  		if (!am_server && !am_daemon) {
  			rprintf(FERROR, "io timeout after %d seconds -- exiting\n",
---- orig/options.c	2005-03-31 00:24:21
-+++ options.c	2005-01-28 19:35:23
-@@ -105,6 +105,7 @@ int checksum_seed = 0;
+--- orig/options.c	2005-05-19 08:52:42
++++ options.c	2005-05-19 09:01:55
+@@ -106,6 +106,7 @@ int checksum_seed = 0;
  int inplace = 0;
  int delay_updates = 0;
  long block_size = 0; /* "long" because popt can't set an int32. */
 +time_t stop_at_utime = 0;
  
  
  /** Network address family. **/
-@@ -343,6 +344,8 @@ void usage(enum logcode F)
+@@ -344,6 +345,8 @@ void usage(enum logcode F)
    rprintf(F,"     --password-file=FILE    read password from FILE\n");
    rprintf(F,"     --list-only             list the files instead of copying them\n");
    rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
 +  rprintf(F,"     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute\n");
 +  rprintf(F,"     --time-limit=MINS       Stop rsync after MINS minutes have elapsed\n");
    rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
+   rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
    rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
-   rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
-@@ -361,6 +364,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
+@@ -364,6 +367,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
        OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST,
        OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
-       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_TIMEOUT, OPT_MAX_SIZE,
+       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
 +      OPT_STOP_AT, OPT_TIME_LIMIT,
        OPT_REFUSED_BASE = 9000};
  
  static struct poptOption long_options[] = {
-@@ -446,6 +450,8 @@ static struct poptOption long_options[] 
+@@ -450,6 +454,8 @@ static struct poptOption long_options[] 
    {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
    {"itemize-changes", 'i', POPT_ARG_NONE,   &itemize_changes, 0, 0, 0 },
    {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
 +  {"stop-at",          0,  POPT_ARG_STRING, 0, OPT_STOP_AT, 0, 0 },
 +  {"time-limit",       0,  POPT_ARG_STRING, 0, OPT_TIME_LIMIT, 0, 0 },
    {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
    {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
    {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
-@@ -863,6 +869,36 @@ int parse_arguments(int *argc, const cha
+@@ -876,6 +882,36 @@ int parse_arguments(int *argc, const cha
  			basis_dir[basis_dir_cnt++] = (char *)arg;
  			break;
  
 +		case OPT_STOP_AT:
 +			arg = poptGetOptArg(pc);
 +			if ((stop_at_utime = parse_time(arg)) == (time_t)-1) {
@@ -111,13 +111,13 @@
 +			stop_at_utime += time(NULL);
 +			break;
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1347,6 +1383,15 @@ void server_options(char **args,int *arg
+@@ -1365,6 +1401,15 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
  
 +	if (stop_at_utime) {
 +		long mins = (stop_at_utime - time(NULL)) / 60;
 +		if (mins <= 0)
@@ -127,24 +127,24 @@
 +		args[ac++] = arg;
 +	}
 +
  	if (backup_dir) {
  		args[ac++] = "--backup-dir";
  		args[ac++] = backup_dir;
---- orig/rsync.yo	2005-03-30 16:57:29
+--- orig/rsync.yo	2005-05-22 20:53:34
 +++ rsync.yo	2005-02-01 10:46:35
-@@ -378,6 +378,8 @@ to the detailed description below for a 
+@@ -379,6 +379,8 @@ to the detailed description below for a 
       --password-file=FILE    read password from FILE
       --list-only             list the files instead of copying them
       --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
 +     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute
 +     --time-limit=MINS       Stop rsync after MINS minutes have elapsed
       --write-batch=FILE      write a batched update to FILE
+      --only-write-batch=FILE like --write-batch but w/o updating dest
       --read-batch=FILE       read a batched update from FILE
-      --protocol=NUM          force an older protocol version to be used
-@@ -1267,6 +1269,19 @@ transfer was too fast, it will wait befo
+@@ -1283,6 +1285,19 @@ transfer was too fast, it will wait befo
  result is an average transfer rate equaling the specified limit. A value
  of zero specifies no limit.
  
 +dit(bf(--stop-at=y-m-dTh:m)) This option allows you to specify at what
 +time to stop rsync, in year-month-dayThour:minute numeric format (e.g.
 +2004-12-31T23:59).  You can specify a 2 or 4-digit year.  You can also
@@ -157,14 +157,14 @@
 +
 +dit(bf(--time-limit=MINS)) This option allows you to specify the maximum
 +number of minutes rsync will run for.
 +
  dit(bf(--write-batch=FILE)) Record a file that can later be applied to
  another identical destination with bf(--read-batch). See the "BATCH MODE"
- section for details.
---- orig/util.c	2005-03-30 20:45:02
+ section for details, and also the bf(--only-write-batch) option.
+--- orig/util.c	2005-05-03 16:47:33
 +++ util.c	2004-07-03 20:23:22
 @@ -126,6 +126,132 @@ void overflow(char *str)
  	exit_cleanup(RERR_MALLOC);
  }
  
 +/* Allow the user to specify a time in the format yyyy-mm-ddThh:mm while
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/tru64.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/tru64.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/tru64.diff	2005-03-16 10:28:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/tru64.diff	2005-05-04 00:53:30.000000000 +0800
@@ -20,13 +20,13 @@
 +/****** End Zoong added here */
 +
 +
  #if defined(__KAME__) && defined(INET6)
  # define FAITH
  #endif
---- orig/syscall.c	2005-02-14 00:58:10
+--- orig/syscall.c	2005-04-07 17:04:26
 +++ syscall.c	2005-02-14 02:54:45
 @@ -27,6 +27,7 @@
  #include "rsync.h"
  
  #if !defined MKNOD_CREATES_SOCKETS && defined HAVE_SYS_UN_H
 +#define _SOCKADDR_LEN
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/verify-patches /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/verify-patches
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/patches/verify-patches	2005-03-24 01:58:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches/verify-patches	2005-05-13 08:25:25.000000000 +0800
@@ -260,24 +260,26 @@
 
 sub restore_cvsdir
 {
     return unless $has_dependencies;
     $has_dependencies = 0;
 
+    chdir('cvsdir') or die $!;
     foreach (glob('*.~[1-9]~'), glob('*/*.~[1-9]~')) {
 	my $fn;
 	($fn = $_) =~ s/\.~1~$//;
 	if ($fn eq $_) {
 	    unlink($_);
-	} elsif (-r $fn) {
-	    rename($_,  $fn);
+	} elsif (-r $_) {
+	    rename($_, $fn);
 	} else {
 	    unlink($_);
 	    unlink($fn);
 	}
     }
+    chdir('..') or die $!;
 }
 
 sub usage
 {
     die <<EOT;
 Usage: $0 [OPTS] [DIFF-FILE...]
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/patches: xattrs.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/pipe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/pipe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/pipe.c	2005-02-08 04:36:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/pipe.c	2005-04-10 02:59:42.000000000 +0800
@@ -22,13 +22,12 @@
 #include "rsync.h"
 
 extern int am_sender;
 extern int am_server;
 extern int blocking_io;
 extern int orig_umask;
-extern int write_batch;
 extern int filesfrom_fd;
 
 /**
  * Create a child connected to use on stdin/stdout.
  *
  * This is derived from CVS code
@@ -125,16 +124,12 @@
 	}
 
 	if (pid == 0) {
 		am_sender = !am_sender;
 		am_server = 1;
 
-		/* The server side never writes the batch, even if it
-		 * is local (it makes the logic easier elsewhere). */
-		write_batch = 0;
-
 		if (!am_sender)
 			filesfrom_fd = -1;
 
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/proto.h	2005-03-31 08:19:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/proto.h	2005-05-19 16:52:11.000000000 +0800
@@ -1,11 +1,12 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
 int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
 void base64_encode(char *buf, int len, char *out);
-char *auth_server(int f_in, int f_out, int module, char *addr, char *leader);
+char *auth_server(int f_in, int f_out, int module, char *host, char *addr,
+		  char *leader);
 void auth_client(int fd, char *user, char *challenge);
 char *get_backup_name(char *fname);
 int make_backup(char *fname);
 void write_stream_flags(int fd);
 void read_stream_flags(int fd);
 void write_batch_shell_file(int argc, char *argv[], int file_arg_cnt);
@@ -83,30 +84,34 @@
 			      int ignore_filter_rules);
 void itemize(struct file_struct *file, int ndx, int statret, STRUCT_STAT *st,
 	     int32 iflags, uchar fnamecmp_type, char *xname);
 void check_for_finished_hlinks(int itemizing, enum logcode code);
 void generate_files(int f_out, struct file_list *flist, char *local_name);
 void init_hard_links(void);
-int hard_link_check(struct file_struct *file, int ndx, int skip);
+int hard_link_check(struct file_struct *file, int ndx, char *fname,
+		    int statret, STRUCT_STAT *st, int itemizing,
+		    enum logcode code, int skip);
 int hard_link_one(struct file_struct *file, int ndx, char *fname,
 		  int statret, STRUCT_STAT *st, char *toname, int terse,
 		  int itemizing, enum logcode code);
 void hard_link_cluster(struct file_struct *file, int master, int itemizing,
 		       enum logcode code);
 void io_set_sock_fds(int f_in, int f_out);
+void set_io_timeout(int secs);
 void set_msg_fd_in(int fd);
 void set_msg_fd_out(int fd);
 void send_msg(enum msgcode code, char *buf, int len);
 int msg_list_push(int flush_it_all);
 int get_redo_num(int itemizing, enum logcode code);
 int get_hlink_num(void);
 void io_set_filesfrom_fds(int f_in, int f_out);
 int read_filesfrom_line(int fd, char *fname);
 void io_start_buffering_out(void);
 void io_start_buffering_in(void);
 void io_end_buffering(void);
+void maybe_flush_socket(void);
 void maybe_send_keepalive(void);
 int read_shortint(int f);
 int32 read_int(int f);
 int64 read_longint(int f);
 void read_buf(int f,char *buf,size_t len);
 void read_sbuf(int f,char *buf,size_t len);
@@ -169,14 +174,14 @@
 int lp_timeout(int );
 int lp_max_connections(int );
 BOOL lp_load(char *pszFname, int globals_only);
 int lp_numservices(void);
 int lp_number(char *name);
 void log_init(void);
-void log_open(void);
-void log_close(void);
+void logfile_close(void);
+void logfile_reopen(void);
 void rwrite(enum logcode code, char *buf, int len);
 void rprintf(enum logcode code, const char *format, ...);
 void rsyserr(enum logcode code, int errcode, const char *format, ...);
 void rflush(enum logcode code);
 int log_format_has(const char *format, char esc);
 void log_item(struct file_struct *file, struct stats *initial_stats,
@@ -216,16 +221,16 @@
 const char *who_am_i(void);
 void successful_send(int ndx);
 int read_item_attrs(int f_in, int f_out, int ndx, uchar *type_ptr,
 		    char *buf, int *len_ptr);
 void send_files(struct file_list *flist, int f_out, int f_in);
 int try_bind_local(int s, int ai_family, int ai_socktype,
-		   const char *bind_address);
-int open_socket_out(char *host, int port, const char *bind_address,
+		   const char *bind_addr);
+int open_socket_out(char *host, int port, const char *bind_addr,
 		    int af_hint);
-int open_socket_out_wrapped(char *host, int port, const char *bind_address,
+int open_socket_out_wrapped(char *host, int port, const char *bind_addr,
 			    int af_hint);
 int is_a_socket(int fd);
 void start_accept_loop(int port, int (*fn)(int, int));
 void set_socket_options(int fd, char *options);
 void become_daemon(void);
 int sock_exec(const char *prog);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/README	2005-02-21 08:16:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/README	2005-04-24 06:17:10.000000000 +0800
@@ -86,12 +86,15 @@
 
   http://mail-archive.com/rsync@lists.samba.org/
 
 To send a bug report, follow the instructions on the bug-tracking
 page of the web site.
 
+If you don't have web access, email your bug report to
+rsync@lists.samba.org.
+
 
 CVS TREE
 --------
 
 If you want to get the very latest version of rsync direct from the
 source code repository then you can use anonymous cvs. You will need a
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/receiver.c	2005-03-30 06:05:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/receiver.c	2005-04-14 09:42:13.000000000 +0800
@@ -18,21 +18,22 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int dry_run;
+extern int do_xfers;
 extern int am_daemon;
 extern int am_server;
 extern int do_progress;
 extern int log_before_transfer;
 extern int log_format_has_i;
 extern int daemon_log_format_has_i;
 extern int csum_length;
 extern int read_batch;
+extern int write_batch;
 extern int batch_gen_fd;
 extern int protocol_version;
 extern int relative_paths;
 extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int preserve_perms;
@@ -449,19 +450,25 @@
 		if (server_filter_list.head
 		    && check_filter(&server_filter_list, fname, 0) < 0) {
 			rprintf(FERROR, "attempt to hack rsync failed.\n");
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
-		if (dry_run) { /* log the transfer */
+		if (!do_xfers) { /* log the transfer */
 			if (!am_server && log_format)
 				log_item(file, &stats, iflags, NULL);
 			if (read_batch)
 				discard_receive_data(f_in, file->length);
 			continue;
 		}
+		if (write_batch < 0) {
+			log_item(file, &stats, iflags, NULL);
+			if (!am_server)
+				discard_receive_data(f_in, file->length);
+			continue;
+		}
 
 		if (read_batch) {
 			next_gen_i = get_next_gen_i(batch_gen_fd, next_gen_i, i);
 			if (i < next_gen_i) {
 				rprintf(FINFO, "(Skipping batched update for \"%s\")\n",
 					safe_fname(fname));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsync.1	2005-03-31 11:14:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsync.1	2005-06-02 11:54:47.000000000 +0800
@@ -1,14 +1,14 @@
-.TH "rsync" "1" "30 Mar 2005" "" "" 
+.TH "rsync" "1" "1 Jun 2005" "" "" 
 .SH "NAME" 
 rsync \- faster, flexible replacement for rcp
 .SH "SYNOPSIS" 
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST:DEST
 .PP 
-rsync [OPTION]\&.\&.\&. [USER@]HOST:SRC DEST
+rsync [OPTION]\&.\&.\&. [USER@]HOST:SRC [DEST]
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. DEST
 .PP 
 rsync [OPTION]\&.\&.\&. [USER@]HOST::SRC [DEST]
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST::DEST
@@ -41,58 +41,44 @@
 can use any transparent remote shell, including ssh or rsh
 .IP o 
 does not require root privileges
 .IP o 
 pipelining of file transfers to minimize latency costs
 .IP o 
-support for anonymous or authenticated rsync servers (ideal for
+support for anonymous or authenticated rsync daemons (ideal for
 mirroring)
 .PP 
 .SH "GENERAL" 
 .PP 
-There are eight different ways of using rsync\&. They are:
+Rsync copies files either to or from a remote host, or locally on the
+current host (it does not support copying files between two remote hosts)\&.
 .PP 
-.IP o 
-for copying local files\&. This is invoked when neither
-source nor destination path contains a : separator
-.IP o 
-for copying from the local machine to a remote machine using
-a remote shell program as the transport (such as ssh or
-rsh)\&. This is invoked when the destination path contains a
-single : separator\&.
-.IP o 
-for copying from a remote machine to the local machine
-using a remote shell program\&. This is invoked when the source
-contains a : separator\&.
-.IP o 
-for copying from a remote rsync server to the local
-machine\&. This is invoked when the source path contains a ::
-separator or an rsync:// URL\&.
-.IP o 
-for copying from the local machine to a remote rsync
-server\&. This is invoked when the destination path contains a ::
-separator or an rsync:// URL\&.
-.IP o 
-for copying from a remote machine using a remote shell
-program as the transport, using rsync server on the remote
-machine\&.  This is invoked when the source path contains a ::
-separator and the \fB--rsh=COMMAND\fP (aka "\fB-e COMMAND\fP") option is
-also provided\&.
-.IP o 
-for copying from the local machine to a remote machine
-using a remote shell program as the transport, using rsync
-server on the remote machine\&.  This is invoked when the
-destination path contains a :: separator and the
-\fB--rsh=COMMAND\fP option is also provided\&.
-.IP o 
-for listing files on a remote machine\&. This is done the
-same way as rsync transfers except that you leave off the
-local destination\&.
-.PP 
-Note that in all cases (other than listing) at least one of the source
-and destination paths must be local\&.
+There are two different ways for rsync to contact a remote system: using a
+remote-shell program as the transport (such as ssh or rsh) or contacting an
+rsync daemon directly via TCP\&.  The remote-shell transport is used whenever
+the source or destination path contains a single colon (:) separator after
+a host specification\&.  Contacting an rsync daemon directly happens when the
+source or destination path contains a double colon (::) separator after a
+host specification, OR when an rsync:// URL is specified\&.
+.PP 
+As a special case, if a remote source is specified without a destination,
+the remote files are listed in an output format similar to "ls -l"\&.
+.PP 
+As expected, if neither the source or destination path specify a remote
+host, the copy occurs locally (see also the \fB--list-only\fP option)\&.
+.PP 
+Finally, it is possible to use a remote-shell transport to contact a remote
+host and then to spawn a single-use rsync daemon\&.  This allows the use of
+some of the daemon features (such as named modules) without having to run a
+daemon as a service\&.  To achieve this, invoke rsync with an explicit
+\fB--rsh=COMMAND\fP (aka "\fB-e COMMAND\fP") option combined with either the
+source or destination path specified as an rsync daemon (i\&.e\&. either a ::
+separator or an rsync:// URL)\&.  In this case, rsync contacts the remote
+host specified using the specified remote shell, and then starts a
+single-use rsync daemon to deal with that copy request\&.  See the section
+"CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM" below\&.
 .PP 
 .SH "SETUP" 
 .PP 
 See the file README for installation instructions\&.
 .PP 
 Once installed, you can use rsync to any machine that you can access via
@@ -155,12 +141,23 @@
 \f(CWrsync -av /src/foo /dest\fP
 .br 
 \f(CWrsync -av /src/foo/ /dest/foo\fP
 .br 
 .RE 
 .PP 
+Note also that host and module references don\&'t require a trailing slash to
+copy the contents of the default directory\&.  For example, both of these
+copy the remote directory\&'s contents into "/dest":
+.PP 
+.RS 
+\f(CWrsync -av host: /dest\fP
+.br 
+\f(CWrsync -av host::module /dest\fP
+.br 
+.RE 
+.PP 
 You can also use rsync in local-only mode, where both the source and
 destination don\&'t have a \&':\&' in the name\&. In this case it behaves like
 an improved copy command\&.
 .PP 
 .RS 
 \f(CWrsync somehost\&.mydomain\&.com::\fP
@@ -202,16 +199,16 @@
 .br 
 .RE 
 .PP 
 This latter example assumes that your shell passes through unmatched
 wildcards\&.  If it complains about "no match", put the name in quotes\&.
 .PP 
-.SH "CONNECTING TO AN RSYNC SERVER" 
+.SH "CONNECTING TO AN RSYNC DAEMON" 
 .PP 
 It is also possible to use rsync without a remote shell as the
-transport\&. In this case you will connect to a remote rsync server
+transport\&. In this case you will connect to a remote rsync daemon
 running on TCP port 873\&.
 .PP 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
 your web proxy\&.  Note that your web proxy\&'s configuration must support
 proxy connections to port 873\&.
@@ -220,48 +217,48 @@
 that:
 .PP 
 .IP o 
 you either use a double colon :: instead of a single colon to
 separate the hostname from the path, or you use an rsync:// URL\&.
 .IP o 
-the remote server may print a message of the day when you
+the remote daemon may print a message of the day when you
 connect\&.
 .IP o 
-if you specify no path name on the remote server then the
-list of accessible paths on the server will be shown\&.
+if you specify no path name on the remote daemon then the
+list of accessible paths on the daemon will be shown\&.
 .IP o 
 if you specify no local destination then a listing of the
-specified files on the remote server is provided\&.
+specified files on the remote daemon is provided\&.
 .PP 
-Some paths on the remote server may require authentication\&. If so then
+Some paths on the remote daemon may require authentication\&. If so then
 you will receive a password prompt when you connect\&. You can avoid the
 password prompt by setting the environment variable RSYNC_PASSWORD to
 the password you want to use or using the \fB--password-file\fP option\&. This
 may be useful when scripting rsync\&.
 .PP 
 WARNING: On some systems environment variables are visible to all
 users\&. On those systems using \fB--password-file\fP is recommended\&.
 .PP 
-.SH "CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" 
+.SH "CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM" 
 .PP 
 It is sometimes useful to be able to set up file transfers using rsync
-server capabilities on the remote machine, while still using ssh or
+daemon capabilities on the remote machine, while still using ssh or
 rsh for transport\&.  This is especially useful when you want to connect
 to a remote machine via ssh (for encryption or to get through a
-firewall), but you still want to have access to the rsync server
-features (see RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM,
+firewall), but you still want to have access to the rsync daemon
+features (see RUNNING AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM,
 below)\&.
 .PP 
 From the user\&'s perspective, using rsync in this way is the same as
-using it to connect to an rsync server, except that you must
+using it to connect to an rsync daemon, except that you must
 explicitly set the remote shell program on the command line with
 \fB--rsh=COMMAND\fP\&.  (Setting RSYNC_RSH in the environment will not turn on
 this functionality\&.)
 .PP 
 In order to distinguish between the remote-shell user and the rsync
-server user, you can use \&'-l user\&' on your remote-shell command:
+daemon user, you can use \&'-l user\&' on your remote-shell command:
 .PP 
 
 .nf 
  
     rsync -av --rsh="ssh -l ssh-user" \e 
         rsync-user@host::module[/path] local-path
@@ -269,32 +266,32 @@
  
 
 .PP 
 The "ssh-user" will be used at the ssh level; the "rsync-user" will be
 used to check against the rsyncd\&.conf on the remote host\&.
 .PP 
-.SH "RUNNING AN RSYNC SERVER" 
+.SH "RUNNING AN RSYNC DAEMON" 
 .PP 
-An rsync server is configured using a configuration file\&.  Please see the
+An rsync daemon is configured using a configuration file\&.  Please see the
 rsyncd\&.conf(5) man page for more information\&.  By default the configuration
 file is called /etc/rsyncd\&.conf, unless rsync is running over a remote
 shell program and is not running as root; in that case, the default name
 is rsyncd\&.conf in the current directory on the remote computer
 (typically $HOME)\&.
 .PP 
-.SH "RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" 
+.SH "RUNNING AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM" 
 .PP 
 See the rsyncd\&.conf(5) man page for full information on the rsync
-server configuration file\&.
+daemon configuration file\&.
 .PP 
 Several configuration options will not be available unless the remote
 user is root (e\&.g\&. chroot, setuid/setgid, etc\&.)\&.  There is no need to
-configure inetd or the services map to include the rsync server port
-if you run an rsync server only via a remote shell program\&.
+configure inetd or the services map to include the rsync daemon port
+if you run an rsync daemon only via a remote shell program\&.
 .PP 
-To run an rsync server out of a single-use ssh key, see this section
+To run an rsync daemon out of a single-use ssh key, see this section
 in the rsyncd\&.conf(5) man page\&.
 .PP 
 .SH "EXAMPLES" 
 .PP 
 Here are some examples of how I use rsync\&.
 .PP 
@@ -408,31 +405,33 @@
                              repeated: --filter=\&'- \&.rsync-filter\&'
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     read exclude patterns from FILE
      --include=PATTERN       don\&'t exclude files matching PATTERN
      --include-from=FILE     read include patterns from FILE
      --files-from=FILE       read list of source-file names from FILE
- -0, --from0                 all *from file lists are delimited by nulls
-     --version               print version number
+ -0, --from0                 all *from/filter files are delimited by 0s
+     --address=ADDRESS       bind address for outgoing socket to daemon
      --port=PORT             specify double-colon alternate port number
      --blocking-io           use blocking I/O for the remote shell
      --no-blocking-io        turn off blocking I/O when it is default
      --stats                 give some file-transfer stats
      --progress              show progress during transfer
  -P                          same as --partial --progress
  -i, --itemize-changes       output a change-summary for all updates
-     --log-format=FORMAT     log file-transfers using specified format
+     --log-format=FORMAT     output filenames using the specified format
      --password-file=FILE    read password from FILE
      --list-only             list the files instead of copying them
      --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
      --write-batch=FILE      write a batched update to FILE
+     --only-write-batch=FILE like --write-batch but w/o updating dest
      --read-batch=FILE       read a batched update from FILE
      --protocol=NUM          force an older protocol version to be used
      --checksum-seed=NUM     set block/file checksum seed (advanced)
  -4, --ipv4                  prefer IPv4
  -6, --ipv6                  prefer IPv6
+     --version               print version number
  -h, --help                  show this help screen
 .fi 
  
 
 .PP 
 Rsync can also be run as a daemon, in which case the following options are
@@ -477,13 +476,13 @@
 information on what files are being skipped and slightly more
 information at the end\&. More than two \fB-v\fP flags should only be used if
 you are debugging rsync\&.
 .IP 
 Note that the names of the transferred files that are output are done using
 a default \fB--log-format\fP of "%n%L", which tells you just the name of the
-file and, if the item is a symlink, where it points\&.  At the single \fB-v\fP
+file and, if the item is a link, where it points\&.  At the single \fB-v\fP
 level of verbosity, this does not mention when a file gets its attributes
 changed\&.  If you ask for an itemized list of changed attributes (either
 \fB--itemize-changes\fP or adding "%i" to the \fB--log-format\fP setting), the
 output (on the client) increases to mention all items that are changed in
 any way\&.  See the \fB--log-format\fP option for more details\&.
 .IP 
@@ -705,15 +704,16 @@
 default\&.
 .IP 
 .IP "\fB-p, --perms\fP" 
 This option causes rsync to set the destination
 permissions to be the same as the source permissions\&.
 .IP 
-Without this option, each new file gets its permissions set based on the
-source file\&'s permissions and the umask at the receiving end, while all
-other files (including updated files) retain their existing permissions
+Without this option, all existing files (including updated files) retain
+their existing permissions, while each new file gets its permissions set
+based on the source file\&'s permissions, but masked by the receiving end\&'s
+umask setting
 (which is the same behavior as other file-copy utilities, such as cp)\&.
 .IP 
 .IP "\fB-o, --owner\fP" 
 This option causes rsync to set the owner of the
 destination file to be the same as the source file\&.  On most systems,
 only the super-user can set file ownership\&.  By default, the preservation
@@ -875,17 +875,17 @@
 This option allows you to choose an alternative
 remote shell program to use for communication between the local and
 remote copies of rsync\&. Typically, rsync is configured to use ssh by
 default, but you may prefer to use rsh on a local network\&.
 .IP 
 If this option is used with \fB[user@]host::module/path\fP, then the
-remote shell \fICOMMAND\fP will be used to run an rsync server on the
+remote shell \fICOMMAND\fP will be used to run an rsync daemon on the
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
-running rsync server on the remote host\&.  See the section "CONNECTING
-TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" above\&.
+running rsync daemon on the remote host\&.  See the section "CONNECTING
+TO AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM" above\&.
 .IP 
 Command-line arguments are permitted in COMMAND provided that COMMAND is
 presented to rsync as a single argument\&.  For example:
 .IP 
 .RS 
 \f(CW   -e "ssh -p 2234"\fP
@@ -1037,15 +1037,20 @@
 .IP 
 .RS 
 \f(CW   rsync -a --files-from=/tmp/foo /usr remote:/backup\fP
 .RE 
 .IP 
 If /tmp/foo contains the string "bin" (or even "/bin"), the /usr/bin
-directory will be created as /backup/bin on the remote host (but the
-contents of the /usr/bin dir would not be sent unless you specified \fB-r\fP
-or the names were explicitly listed in /tmp/foo)\&.  Also keep in mind
+directory will be created as /backup/bin on the remote host\&.  If it
+contains "bin/" (note the trailing slash), the immediate contents of
+the directory would also be sent (without needing to be explicitly
+mentioned in the file -- this began in version 2\&.6\&.4)\&.  In both cases,
+if the \fB-r\fP option was enabled, that dir\&'s entire hierarchy would
+also be transferred (keep in mind that \fB-r\fP needs to be specified
+explicitly with \fB--files-from\fP, since it is not implied by \fB-a\fP)\&.
+Also note
 that the effect of the (enabled by default) \fB--relative\fP option is to
 duplicate only the path info that is read from the file -- it does not
 force the duplication of the source-spec path (/usr in this case)\&.
 .IP 
 In addition, the \fB--files-from\fP file can be read from the remote host
 instead of the local host if you specify a "host:" in front of the file
@@ -1058,13 +1063,13 @@
 .RE 
 .IP 
 This would copy all the files specified in the /path/file-list file that
 was located on the remote "src" host\&.
 .IP 
 .IP "\fB-0, --from0\fP" 
-This tells rsync that the filenames it reads from a
+This tells rsync that the rules/filenames it reads from a
 file are terminated by a null (\&'\e0\&') character, not a NL, CR, or CR+LF\&.
 This affects \fB--exclude-from\fP, \fB--include-from\fP, \fB--files-from\fP, and any
 merged files specified in a \fB--filter\fP rule\&.
 It does not affect \fB--cvs-exclude\fP (since all names read from a \&.cvsignore
 file are split on whitespace)\&.
 .IP 
@@ -1177,12 +1182,18 @@
 .IP 
 .IP "\fB--timeout=TIMEOUT\fP" 
 This option allows you to set a maximum I/O
 timeout in seconds\&. If no data is transferred for the specified time
 then rsync will exit\&. The default is 0, which means no timeout\&.
 .IP 
+.IP "\fB--address\fP" 
+By default rsync will bind to the wildcard address when
+connecting to an rsync daemon\&.  The \fB--address\fP option allows you to
+specify a specific IP address (or hostname) to bind to\&.  See also this
+option in the \fB--daemon\fP mode section\&.
+.IP 
 .IP "\fB--port=PORT\fP" 
 This specifies an alternate TCP port number to use
 rather than the default of 873\&.  This is only needed if you are using the
 double-colon (::) syntax to connect with an rsync daemon (since the URL
 syntax has a way to specify the port as a part of the URL)\&.  See also this
 option in the \fB--daemon\fP mode section\&.
@@ -1216,13 +1227,13 @@
 A \fB<\fP means that a file is being transferred to the remote host
 (sent)\&.
 .IP o 
 A \fB>\fP means that a file is being transferred to the local host
 (received)\&.
 .IP o 
-A \fBc\fP means that a local change/creation is occuring for the item
+A \fBc\fP means that a local change/creation is occurring for the item
 (such as the creation of a directory or the changing of a symlink, etc\&.)\&.
 .IP o 
 A \fBh\fP means that the item is a hard-link to another item (requires
 \fB--hard-links\fP)\&.
 .IP o 
 A \fB\&.\fP means that the item is not being updated (though it might
@@ -1234,38 +1245,38 @@
 .IP 
 The other letters in the string above are the actual letters that
 will be output if the associated attribute for the item is being updated or
 a "\&." for no change\&.  Three exceptions to this are: (1) a newly created
 item replaces each letter with a "+", (2) an identical item replaces the
 dots with spaces, and (3) an unknown attribute replaces each letter with
-a "?" (this happens when talking to an older rsync)\&.
+a "?" (this can happen when talking to an older rsync)\&.
 .IP 
 The attribute that is associated with each letter is as follows:
 .IP 
 .RS 
 .IP o 
 A \fBc\fP means the checksum of the file is different and will be
-updated by the file transfer (requries \fB--checksum\fP)\&.
+updated by the file transfer (requires \fB--checksum\fP)\&.
 .IP o 
 A \fBs\fP means the size of the file is different and will be updated
 by the file transfer\&.
 .IP o 
 A \fBt\fP means the modification time is different and is being updated
-to the server\&'s value (requires \fB--times\fP)\&.  An alternate value of \fBT\fP
+to the sender\&'s value (requires \fB--times\fP)\&.  An alternate value of \fBT\fP
 means that the time will be set to the transfer time, which happens
 anytime a symlink is transferred, or when a file or device is transferred
 without \fB--times\fP\&.
 .IP o 
 A \fBp\fP means the permissions are different and are being updated to
-the server\&'s value (requires \fB--perms\fP)\&.
+the sender\&'s value (requires \fB--perms\fP)\&.
 .IP o 
 An \fBo\fP means the owner is different and is being updated to the
-server\&'s value (requires \fB--owner\fP and root privileges)\&.
+sender\&'s value (requires \fB--owner\fP and root privileges)\&.
 .IP o 
 A \fBg\fP means the group is different and is being updated to the
-server\&'s value (requires \fB--group\fP and the authority to set the group)\&.
+sender\&'s value (requires \fB--group\fP and the authority to set the group)\&.
 .IP o 
 The \fBa\fP is reserved for a future enhanced version that supports
 extended file attributes, such as ACLs\&.
 .RE 
 .IP 
 One other output is possible:  when deleting files, the "%i" will output
@@ -1282,13 +1293,13 @@
 option does not affect what a daemon logs to its logfile\&.)
 .IP 
 Specifying this option will mention each file, dir, etc\&. that gets updated
 in a significant way (a transferred file, a recreated symlink/device, or a
 touched directory) unless the itemized-changes escape (%i) is included in
 the string, in which case the logging of names increases to mention any
-item that is updated in any way (as long as the receiving side is version
+item that is changed in any way (as long as the receiving side is at least
 2\&.6\&.4)\&.  See the \fB--itemized-changes\fP option for a description of the
 output of "%i"\&.
 .IP 
 The \fB--verbose\fP option implies a format of "%n%L", but you can use
 \fB--log-format\fP without bv(--verbose) if you like, or you can override
 the format of its per-file output using this option\&.
@@ -1353,13 +1364,13 @@
 environment and then just use the \fB-P\fP option to turn on the use of the
 \&.rsync-tmp dir for partial transfers\&.  The only time that the \fB--partial\fP
 option does not look for this environment value is (1) when \fB--inplace\fP was
 specified (since \fB--inplace\fP conflicts with \fB--partial-dir\fP), or (2) when
 \fB--delay-updates\fP was specified (see below)\&.
 .IP 
-For the purposes of the server-config\&'s "refuse options" setting,
+For the purposes of the daemon-config\&'s "refuse options" setting,
 \fB--partial-dir\fP does \fInot\fP imply \fB--partial\fP\&.  This is so that a
 refusal of the \fB--partial\fP option can be used to disallow the overwriting
 of destination files with a partial transfer, while still allowing the
 safer idiom provided by \fB--partial-dir\fP\&.
 .IP 
 .IP "\fB--delay-updates\fP" 
@@ -1368,13 +1379,13 @@
 transfer, at which time all the files are renamed into place in rapid
 succession\&.  This attempts to make the updating of the files a little more
 atomic\&.  By default the files are placed into a directory named "\&.~tmp~" in
 each file\&'s destination directory, but you can override this by specifying
 the \fB--partial-dir\fP option\&.  (Note that RSYNC_PARTIAL_DIR has no effect
 on this value, nor is \fB--partial-dir\fP considered to be implied for the
-purposes of the server-config\&'s "refuse options" setting\&.)
+purposes of the daemon-config\&'s "refuse options" setting\&.)
 Conflicts with \fB--inplace\fP\&.
 .IP 
 This option uses more memory on the receiving side (one bit per file
 transferred) and also requires enough free disk space on the receiving
 side to hold an additional copy of all the updated files\&.  Note also that
 you should not use an absolute path to \fB--partial-dir\fP unless there is no
@@ -1427,25 +1438,27 @@
 The \fB-P\fP option is equivalent to \fB--partial\fP \fB--progress\fP\&.  Its
 purpose is to make it much easier to specify these two options for a long
 transfer that may be interrupted\&.
 .IP 
 .IP "\fB--password-file\fP" 
 This option allows you to provide a password
-in a file for accessing a remote rsync server\&. Note that this option
-is only useful when accessing an rsync server using the built in
+in a file for accessing a remote rsync daemon\&. Note that this option
+is only useful when accessing an rsync daemon using the built in
 transport, not when using a remote shell as the transport\&. The file
 must not be world readable\&. It should contain just the password as a
 single line\&.
 .IP 
 .IP "\fB--list-only\fP" 
 This option will cause the source files to be listed
 instead of transferred\&.  This option is inferred if there is no destination
 specified, so you don\&'t usually need to use it explicitly\&.  However, it can
-come in handy for a power user that wants to avoid the "\fB-r --exclude=\&'/*/*\&'\fP"
+come in handy for a user that wants to avoid the "\fB-r --exclude=\&'/*/*\&'\fP"
 options that rsync might use as a compatibility kluge when generating a
-non-recursive listing\&.
+non-recursive listing, or to list the files that are involved in a local
+copy (since the destination path is not optional for a local copy, you
+must specify this option explicitly and still include a destination)\&.
 .IP 
 .IP "\fB--bwlimit=KBPS\fP" 
 This option allows you to specify a maximum
 transfer rate in kilobytes per second\&. This option is most effective when
 using rsync with large files (several megabytes and up)\&. Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
@@ -1453,28 +1466,46 @@
 result is an average transfer rate equaling the specified limit\&. A value
 of zero specifies no limit\&.
 .IP 
 .IP "\fB--write-batch=FILE\fP" 
 Record a file that can later be applied to
 another identical destination with \fB--read-batch\fP\&. See the "BATCH MODE"
-section for details\&.
+section for details, and also the \fB--only-write-batch\fP option\&.
+.IP 
+.IP "\fB--only-write-batch=FILE\fP" 
+Works like \fB--write-batch\fP, except that
+no updates are made on the destination system when creating the batch\&.
+This lets you transport the changes to the destination system via some
+other means and then apply the changes via \fB--read-batch\fP\&.
+.IP 
+Note that you can feel free to write the batch directly to some portable
+media: if this media fills to capacity before the end of the transfer, you
+can just apply that partial transfer to the destination and repeat the
+whole process to get the rest of the changes (as long as you don\&'t mind a
+partially updated destination system while the multi-update cycle is
+happening)\&.
+.IP 
+Also note that you only save bandwidth when pushing changes to a remote
+system because this allows the batched data to be diverted from the sender
+into the batch file without having to flow over the wire to the receiver
+(when pulling, the sender is remote, and thus can\&'t write the batch)\&.
 .IP 
 .IP "\fB--read-batch=FILE\fP" 
 Apply all of the changes stored in FILE, a
 file previously generated by \fB--write-batch\fP\&.
 If \fIFILE\fP is "-" the batch data will be read from standard input\&.
 See the "BATCH MODE" section for details\&.
 .IP 
 .IP "\fB--protocol=NUM\fP" 
 Force an older protocol version to be used\&.  This
 is useful for creating a batch file that is compatible with an older
 version of rsync\&.  For instance, if rsync 2\&.6\&.4 is being used with the
 \fB--write-batch\fP option, but rsync 2\&.6\&.3 is what will be used to run the
-\fB--read-batch\fP option, you should use "--protocol=28" (when creating the
-batch file) to force the older protocol version to be used in the batch
-file (assuming you can\&'t upgrade the rsync on the reading system to 2\&.6\&.4)\&.
+\fB--read-batch\fP option, you should use "--protocol=28" when creating the
+batch file to force the older protocol version to be used in the batch
+file (assuming you can\&'t upgrade the rsync on the reading system)\&.
 .IP 
 .IP "\fB-4, --ipv4\fP or \fB-6, --ipv6\fP" 
 Tells rsync to prefer IPv4/IPv6
 when creating sockets\&.  This only affects sockets that rsync has direct
 control over, such as the outgoing socket when directly contacting an
 rsync daemon\&.  See also these options in the \fB--daemon\fP mode section\&.
@@ -1504,18 +1535,17 @@
 become a background daemon\&.  The daemon will read the config file
 (rsyncd\&.conf) on each connect made by a client and respond to
 requests accordingly\&.  See the rsyncd\&.conf(5) man page for more
 details\&.
 .IP 
 .IP "\fB--address\fP" 
-By default rsync will bind to the wildcard address
-when run as a daemon with the \fB--daemon\fP option or when connecting to a
-rsync server\&. The \fB--address\fP option allows you to specify a specific IP
-address (or hostname) to bind to\&. This makes virtual hosting possible
-in conjunction with the \fB--config\fP option\&.  See also the "address" global
-option in the rsyncd\&.conf manpage\&.
+By default rsync will bind to the wildcard address when
+run as a daemon with the \fB--daemon\fP option\&.  The \fB--address\fP option
+allows you to specify a specific IP address (or hostname) to bind to\&.  This
+makes virtual hosting possible in conjunction with the \fB--config\fP option\&.
+See also the "address" global option in the rsyncd\&.conf manpage\&.
 .IP 
 .IP "\fB--bwlimit=KBPS\fP" 
 This option allows you to specify a maximum
 transfer rate in kilobytes per second for the data the daemon sends\&.
 The client can still specify a smaller \fB--bwlimit\fP value, but their
 requested value will be rounded down if they try to exceed it\&.  See the
@@ -1799,13 +1829,13 @@
 .IP o 
 You may also specify any of the modifiers for the "+" or "-" rules
 (below) in order  to have the rules that are read-in from the file
 default to having that modifier set\&.  For instance, "merge,-/ \&.excl" would
 treat the contents of \&.excl as absolute-path excludes,
 while "dir-merge,s \&.filt" and ":sC" would each make all their
-per-directory rules apply only on the server side\&.
+per-directory rules apply only on the sending side\&.
 .PP 
 The following modifiers are accepted after a "+" or "-":
 .PP 
 .IP o 
 A "/" specifies that the include/exclude should be treated as an
 absolute path, relative to the root of the filesystem\&.  For example,
@@ -1822,13 +1852,13 @@
 .IP o 
 An \fBs\fP is used to indicate that the rule applies to the sending
 side\&.  When a rule affects the sending side, it prevents files from
 being transferred\&.  The default is for a rule to affect both sides
 unless \fB--delete-excluded\fP was specified, in which case default rules
 become sender-side only\&.  See also the hide (H) and show (S) rules,
-which are an alternate way to specify server-side includes/excludes\&.
+which are an alternate way to specify sending-side includes/excludes\&.
 .IP o 
 An \fBr\fP is used to indicate that the rule applies to the receiving
 side\&.  When a rule affects the receiving side, it prevents files from
 being deleted\&.  See the \fBs\fP modifier for more info\&.  See also the
 protect (P) and risk (R) rules, which are an alternate way to
 specify receiver-side includes/excludes\&.
@@ -2214,18 +2244,42 @@
 rsync also distinguishes "safe" and "unsafe" symbolic links\&.  An
 example where this might be used is a web site mirror that wishes
 ensure the rsync module they copy does not include symbolic links to
 \fB/etc/passwd\fP in the public section of the site\&.  Using
 \fB--copy-unsafe-links\fP will cause any links to be copied as the file
 they point to on the destination\&.  Using \fB--safe-links\fP will cause
-unsafe links to be omitted altogether\&.
+unsafe links to be omitted altogether\&.  (Note that you must specify
+\fB--links\fP for \fB--safe-links\fP to have any effect\&.)
 .PP 
 Symbolic links are considered unsafe if they are absolute symlinks
 (start with \fB/\fP), empty, or if they contain enough \fB"\&.\&."\fP
 components to ascend from the directory being copied\&.
 .PP 
+Here\&'s a summary of how the symlink options are interpreted\&.  The list is
+in order of precedence, so if your combination of options isn\&'t mentioned,
+use the first line that is a complete subset of your options:
+.PP 
+.IP "\fB--copy-links\fP" 
+Turn all symlinks into normal files (leaving no
+symlinks for any other options to affect)\&.
+.PP 
+.IP "\fB--links --copy-unsafe-links\fP" 
+Turn all unsafe symlinks into files
+and duplicate all safe symlinks\&.
+.PP 
+.IP "\fB--copy-unsafe-links\fP" 
+Turn all unsafe symlinks into files, noisily
+skip all safe symlinks\&.
+.PP 
+.IP "\fB--links --safe-links\fP" 
+Duplicate safe symlinks and skip unsafe
+ones\&.
+.PP 
+.IP "\fB--links\fP" 
+Duplicate all symlinks\&.
+.PP 
 .SH "DIAGNOSTICS" 
 .PP 
 rsync occasionally produces error messages that may seem a little
 cryptic\&. The one that seems to cause the most confusion is "protocol
 version mismatch -- is your shell clean?"\&.
 .PP 
@@ -2312,13 +2366,13 @@
 Setting RSYNC_PASSWORD to the required
 password allows you to run authenticated rsync connections to an rsync
 daemon without user intervention\&. Note that this does not supply a
 password to a shell transport such as ssh\&.
 .IP "\fBUSER\fP or \fBLOGNAME\fP" 
 The USER or LOGNAME environment variables
-are used to determine the default username sent to an rsync server\&.
+are used to determine the default username sent to an rsync daemon\&.
 If neither is set, the username defaults to "nobody"\&.
 .IP "\fBHOME\fP" 
 The HOME environment variable is used to find the user\&'s
 default \&.cvsignore file\&.
 .PP 
 .SH "FILES" 
@@ -2342,12 +2396,16 @@
 .PP 
 see also the comments on the \fB--delete\fP option
 .PP 
 Please report bugs! See the website at
 http://rsync\&.samba\&.org/
 .PP 
+.SH "VERSION" 
+.PP 
+This man page is current for version 2\&.6\&.5 of rsync\&.
+.PP 
 .SH "CREDITS" 
 .PP 
 rsync is distributed under the GNU public license\&.  See the file
 COPYING for details\&.
 .PP 
 A WEB site is available at
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsyncd.conf.5	2005-03-31 11:14:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsyncd.conf.5	2005-06-02 11:54:49.000000000 +0800
@@ -1,17 +1,17 @@
-.TH "rsyncd\&.conf" "5" "30 Mar 2005" "" "" 
+.TH "rsyncd\&.conf" "5" "1 Jun 2005" "" "" 
 .SH "NAME" 
-rsyncd\&.conf \- configuration file for rsync server
+rsyncd\&.conf \- configuration file for rsync in daemon mode
 .SH "SYNOPSIS" 
 .PP 
 rsyncd\&.conf
 .PP 
 .SH "DESCRIPTION" 
 .PP 
 The rsyncd\&.conf file is the runtime configuration file for rsync when
-run as an rsync server\&. 
+run as an rsync daemon\&. 
 .PP 
 The rsyncd\&.conf file controls authentication, access, logging and
 available modules\&.
 .PP 
 .SH "FILE FORMAT" 
 .PP 
@@ -50,13 +50,13 @@
 write the appropriate data, log, and lock files\&.
 .PP 
 You can launch it either via inetd, as a stand-alone daemon, or from
 an rsync client via a remote shell\&.  If run as a stand-alone daemon then
 just run the command "\fBrsync --daemon\fP" from a suitable startup script\&.
 If run from an rsync client via a remote shell (by specifying both the
-\fB--rsh\fP (\fB-e\fP) option and server mode with "::" or "rsync://"), the \fB--daemon\fP
+\fB--rsh\fP (\fB-e\fP) option and daemon mode with "::" or "rsync://"), the \fB--daemon\fP
 option is automatically passed to the remote side\&.
 .PP 
 When run via inetd you should add a line like this to /etc/services:
 .PP 
 
 .nf 
@@ -77,13 +77,13 @@
 
 .PP 
 Replace "/usr/bin/rsync" with the path to where you have rsync installed on
 your system\&.  You will then need to send inetd a HUP signal to tell it to
 reread its config file\&.
 .PP 
-Note that you should not send the rsync server a HUP signal to force
+Note that you should \fBnot\fP send the rsync daemon a HUP signal to force
 it to reread the \f(CWrsyncd\&.conf\fP file\&. The file is re-read on each client
 connection\&. 
 .PP 
 .SH "GLOBAL OPTIONS" 
 .PP 
 The first parameters in the file (before a [module] header) are the
@@ -100,27 +100,40 @@
 is no motd file\&.
 .IP 
 .IP "\fBlog file\fP" 
 The "log file" option tells the rsync daemon to log
 messages to that file rather than using syslog\&. This is particularly
 useful on systems (such as AIX) where syslog() doesn\&'t work for
-chrooted programs\&.
+chrooted programs\&.  If the daemon fails to open to specified file, it
+will fall back to using syslog and output an error about the failure\&.
+(Note that a failure to open the specified log file used to be a fatal
+error\&.)
 .IP 
 .IP "\fBpid file\fP" 
 The "pid file" option tells the rsync daemon to write
 its process ID to that file\&.
 .IP 
 .IP "\fBsyslog facility\fP" 
 The "syslog facility" option allows you to
 specify the syslog facility name to use when logging messages from the
-rsync server\&. You may use any standard syslog facility name which is
+rsync daemon\&. You may use any standard syslog facility name which is
 defined on your system\&. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
 local1, local2, local3, local4, local5, local6 and local7\&. The default
 is daemon\&. 
 .IP 
+.IP "\fBport\fP" 
+You can override the default port the daemon will listen on
+by specifying this value (defaults to 873)\&.  This is ignored if the daemon
+is being run by inetd, and is superseded by the \fB--port\fP command-line option\&.
+.IP 
+.IP "\fBaddress\fP" 
+You can override the default IP address the daemon
+will listen on by specifying this value\&.  This is ignored if the daemon is
+being run by inetd, and is superseded by the \fB--address\fP command-line option\&.
+.IP 
 .IP "\fBsocket options\fP" 
 This option can provide endless fun for people
 who like to tune their systems to the utmost degree\&. You can set all
 sorts of socket options which may make transfers faster (or
 slower!)\&. Read the man page for the setsockopt() system call for
 details on some of the options you may be able to set\&. By default no
@@ -138,18 +151,18 @@
 .IP "\fBcomment\fP" 
 The "comment" option specifies a description string
 that is displayed next to the module name when clients obtain a list
 of available modules\&. The default is no comment\&.
 .IP 
 .IP "\fBpath\fP" 
-The "path" option specifies the directory in the servers
+The "path" option specifies the directory in the daemon\&'s
 filesystem to make available in this module\&.  You must specify this option
 for each module in \f(CWrsyncd\&.conf\fP\&.
 .IP 
 .IP "\fBuse chroot\fP" 
-If "use chroot" is true, the rsync server will chroot
+If "use chroot" is true, the rsync daemon will chroot
 to the "path" before starting the file transfer with the client\&.  This has
 the advantage of extra protection against possible implementation security
 holes, but it has the disadvantages of requiring super-user privileges, 
 of not being able to follow symbolic links that are either absolute or outside
 of the new root path, and of complicating the preservation of usernames and groups
 (see below)\&.  When "use chroot" is false, for security reasons,
@@ -170,30 +183,20 @@
 .IP 
 Note that you are free to setup user/group information in the chroot area
 differently from your normal system\&.  For example, you could abbreviate
 the list of users and groups\&.  Also, you can protect this information from
 being downloaded/uploaded by adding an exclude rule to the rsync\&.conf file
 (e\&.g\&. "exclude = /etc/**")\&.  Note that having the exclusion affect uploads
-is a relatively new feature in rsync, so make sure your server is running
+is a relatively new feature in rsync, so make sure your daemon is
 at least 2\&.6\&.3 to effect this\&.  Also note that it is safest to exclude a
 directory and all its contents combining the rule "/some/dir/" with the
 rule "/some/dir/**" just to be sure that rsync will not allow deeper
 access to some of the excluded files inside the directory (rsync tries to
 do this automatically, but you might as well specify both to be extra
 sure)\&.
 .IP 
-.IP "\fBport\fP" 
-You can override the default port the daemon will listen on
-by specifying this value (defaults to 873)\&.  This is ignored if the daemon
-is being run by inetd, and is superseded by the \fB--port\fP command-line option\&.
-.IP 
-.IP "\fBaddress\fP" 
-You can override the default IP address the daemon
-will listen on by specifying this value\&.  This is ignored if the daemon is
-being run by inetd, and is superseded by the \fB--address\fP command-line option\&.
-.IP 
 .IP "\fBmax connections\fP" 
 The "max connections" option allows you to
 specify the maximum number of simultaneous connections you will allow\&.
 Any clients connecting when the maximum has been reached will receive a
 message telling them to try later\&.  The default is 0 which means no limit\&.
 See also the "lock file" option\&.
@@ -203,29 +206,29 @@
 the maximum amount of verbose information that you\&'ll allow the daemon to
 generate (since the information goes into the log file)\&. The default is 1,
 which allows the client to request one level of verbosity\&.
 .IP 
 .IP "\fBlock file\fP" 
 The "lock file" option specifies the file to use to
-support the "max connections" option\&. The rsync server uses record
+support the "max connections" option\&. The rsync daemon uses record
 locking on this file to ensure that the max connections limit is not
 exceeded for the modules sharing the lock file\&. 
 The default is \f(CW/var/run/rsyncd\&.lock\fP\&.
 .IP 
 .IP "\fBread only\fP" 
 The "read only" option determines whether clients
 will be able to upload files or not\&. If "read only" is true then any
 attempted uploads will fail\&. If "read only" is false then uploads will
-be possible if file permissions on the server allow them\&. The default
+be possible if file permissions on the daemon side allow them\&. The default
 is for all modules to be read only\&.
 .IP 
 .IP "\fBwrite only\fP" 
 The "write only" option determines whether clients
 will be able to download files or not\&. If "write only" is true then any
 attempted downloads will fail\&. If "write only" is false then downloads
-will be possible if file permissions on the server allow them\&.  The
+will be possible if file permissions on the daemon side allow them\&.  The
 default is for this option to be disabled\&.
 .IP 
 .IP "\fBlist\fP" 
 The "list" option determines if this module should be
 listed when the client asks for a listing of available modules\&. By
 setting this to false you can create hidden modules\&. The default is
@@ -243,55 +246,55 @@
 file transfers to and from that module should take place as when the daemon
 was run as root\&. This complements the "uid" option\&. The default is gid -2,
 which is normally the group "nobody"\&.
 .IP 
 .IP "\fBfilter\fP" 
 The "filter" option allows you to specify a space-separated
-list of filter rules that the server will not allow to be read or written\&.
+list of filter rules that the daemon will not allow to be read or written\&.
 This is only superficially equivalent to the client specifying these
 patterns with the \fB--filter\fP option\&.  Only one "filter" option may be
 specified, but it may contain as many rules as you like, including
 merge-file rules\&.  Note that per-directory merge-file rules do not provide
 as much protection as global rules, but they can be used to make \fB--delete\fP
-work better when a client downloads the server\&'s files (if the per-dir
+work better when a client downloads the daemon\&'s files (if the per-dir
 merge files are included in the transfer)\&.
 .IP 
 .IP "\fBexclude\fP" 
 The "exclude" option allows you to specify a
-space-separated list of patterns that the server will not allow to be read
+space-separated list of patterns that the daemon will not allow to be read
 or written\&.  This is only superficially equivalent to the client
 specifying these patterns with the \fB--exclude\fP option\&.  Only one "exclude"
 option may be specified, but you can use "-" and "+" before patterns to
 specify exclude/include\&.
 .IP 
 Because this exclude list is not passed to the client it only applies on
-the server: that is, it excludes files received by a client when receiving
-from a server and files deleted on a server when sending to a server, but
+the daemon: that is, it excludes files received by a client when receiving
+from a daemon and files deleted on a daemon when sending to a daemon, but
 it doesn\&'t exclude files from being deleted on a client when receiving
-from a server\&.  
+from a daemon\&.  
 .IP 
 .IP "\fBexclude from\fP" 
 The "exclude from" option specifies a filename
-on the server that contains exclude patterns, one per line\&.
+on the daemon that contains exclude patterns, one per line\&.
 This is only superficially equivalent
 to the client specifying the \fB--exclude-from\fP option with an equivalent file\&.
 See the "exclude" option above\&.
 .IP 
 .IP "\fBinclude\fP" 
 The "include" option allows you to specify a
 space-separated list of patterns which rsync should not exclude\&. This is
 only superficially equivalent to the client specifying these patterns with
-the \fB--include\fP option because it applies only on the server\&.  This is
+the \fB--include\fP option because it applies only on the daemon\&.  This is
 useful as it allows you to build up quite complex exclude/include rules\&.
 Only one "include" option may be specified, but you can use "+" and "-"
 before patterns to switch include/exclude\&.  See the "exclude" option
 above\&.
 .IP 
 .IP "\fBinclude from\fP" 
 The "include from" option specifies a filename
-on the server that contains include patterns, one per line\&. This is
+on the daemon that contains include patterns, one per line\&. This is
 only superficially equivalent to the client specifying the
 \fB--include-from\fP option with a equivalent file\&.
 See the "exclude" option above\&.
 .IP 
 .IP "\fBauth users\fP" 
 The "auth users" option specifies a comma and
@@ -302,16 +305,16 @@
 username and password to connect to the module\&. A challenge response
 authentication protocol is used for this exchange\&. The plain text
 usernames are passwords are stored in the file specified by the
 "secrets file" option\&. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync")\&.
 .IP 
-See also the \fBCONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL
-PROGRAM\fP section in rsync(1) for information on how handle an
+See also the "CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL
+PROGRAM" section in rsync(1) for information on how handle an
 rsyncd\&.conf-level username that differs from the remote-shell-level
-username when using a remote shell to connect to an rsync server\&.
+username when using a remote shell to connect to an rsync daemon\&.
 .IP 
 .IP "\fBsecrets file\fP" 
 The "secrets file" option specifies the name of
 a file that contains the username:password pairs used for
 authenticating this module\&. This file is only consulted if the "auth
 users" option is specified\&. The file is line based and contains
@@ -393,29 +396,29 @@
 rejected\&. See the "hosts allow" option for more information\&.
 .IP 
 The default is no "hosts deny" option, which means all hosts can connect\&.
 .IP 
 .IP "\fBignore errors\fP" 
 The "ignore errors" option tells rsyncd to
-ignore I/O errors on the server when deciding whether to run the delete
+ignore I/O errors on the daemon when deciding whether to run the delete
 phase of the transfer\&. Normally rsync skips the \fB--delete\fP step if any
 I/O errors have occurred in order to prevent disastrous deletion due
 to a temporary resource shortage or other I/O error\&. In some cases this
 test is counter productive so you can use this option to turn off this
 behavior\&. 
 .IP 
 .IP "\fBignore nonreadable\fP" 
-This tells the rsync server to completely
+This tells the rsync daemon to completely
 ignore files that are not readable by the user\&. This is useful for
 public archives that may have some non-readable files among the
 directories, and the sysadmin doesn\&'t want those files to be seen at all\&.
 .IP 
 .IP "\fBtransfer logging\fP" 
 The "transfer logging" option enables per-file 
 logging of downloads and uploads in a format somewhat similar to that
-used by ftp daemons\&.  The server always logs the transfer at the end, so
+used by ftp daemons\&.  The daemon always logs the transfer at the end, so
 if a transfer is aborted, no mention will be made in the log file\&.
 .IP 
 If you want to customize the log lines, see the "log format" option\&.
 .IP 
 .IP "\fBlog format\fP" 
 The "log format" option allows you to specify the
@@ -478,19 +481,19 @@
 .IP 
 .IP "\fBtimeout\fP" 
 The "timeout" option allows you to override the
 clients choice for I/O timeout for this module\&. Using this option you
 can ensure that rsync won\&'t wait on a dead client forever\&. The timeout
 is specified in seconds\&. A value of zero means no timeout and is the
-default\&. A good choice for anonymous rsync servers may be 600 (giving
+default\&. A good choice for anonymous rsync daemons may be 600 (giving
 a 10 minute timeout)\&.
 .IP 
 .IP "\fBrefuse options\fP" 
 The "refuse options" option allows you to
 specify a space-separated list of rsync command line options that will
-be refused by your rsync server\&.
+be refused by your rsync daemon\&.
 You may specify the full option name, its one-letter abbreviation, or a
 wild-card string that matches multiple options\&.
 For example, this would refuse \fB--checksum\fP (\fB-c\fP) and all the various
 delete options:
 .IP 
 .RS 
@@ -501,13 +504,13 @@
 \fB--delete\fP, and implied options are refused just like explicit options\&.
 As an additional safety feature, the refusal of "delete" also refuses
 \fBremove-sent-files\fP when the daemon is the sender; if you want the latter
 without the former, instead refuse "delete-*" -- that refuses all the
 delete modes without affecting \fB--remove-sent-files\fP\&.
 .IP 
-When an option is refused, the server prints an error message and exits\&.
+When an option is refused, the daemon prints an error message and exits\&.
 To prevent all compression, you can use "dont compress = *" (see below)
 instead of "refuse options = compress" to avoid returning an error to a
 client that requests compression\&.
 .IP 
 .IP "\fBdont compress\fP" 
 The "dont compress" option allows you to select
@@ -529,30 +532,30 @@
 challenge response system\&. Although I believe that no one has ever
 demonstrated a brute-force break of this sort of system you should
 realize that this is not a "military strength" authentication system\&.
 It should be good enough for most purposes but if you want really top
 quality security then I recommend that you run rsync over ssh\&.
 .PP 
-Also note that the rsync server protocol does not currently provide any
+Also note that the rsync daemon protocol does not currently provide any
 encryption of the data that is transferred over the connection\&. Only
 authentication is provided\&. Use ssh as the transport if you want
 encryption\&.
 .PP 
 Future versions of rsync may support SSL for better authentication and
 encryption, but that is still being investigated\&.
 .PP 
-.SH "RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" 
+.SH "RUNNING AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM" 
 .PP 
 If rsync is run with both the \fB--daemon\fP and \fB--rsh\fP (\fB-e\fP) options, it will
 spawn an rsync daemon using a remote shell connection\&.  Several
 configuration options will not be available unless the remote user is
 root (e\&.g\&. chroot, setuid/setgid, etc\&.)\&.  There is no need to configure
-inetd or the services map to include the rsync server port if you run an
-rsync server only via a remote shell program\&.
+inetd or the services map to include the rsync daemon port if you run an
+rsync daemon only via a remote shell program\&.
 .PP 
-ADVANCED: To run an rsync server out of a single-use ssh key, use the
+ADVANCED: To run an rsync daemon out of a single-use ssh key, use the
 "command=\fICOMMAND\fP" syntax in the remote user\&'s authorized_keys entry,
 where command would be
 .PP 
 .RS 
 \f(CWrsync --server --daemon \&.\fP
 .RE 
@@ -644,21 +647,18 @@
 rsync(1)
 .PP 
 .SH "DIAGNOSTICS" 
 .PP 
 .SH "BUGS" 
 .PP 
-The rsync server does not send all types of error messages to the
-client\&. this means a client may be mystified as to why a transfer
-failed\&. The error will have been logged by syslog on the server\&.
-.PP 
 Please report bugs! The rsync bug tracking system is online at
 http://rsync\&.samba\&.org/
 .PP 
 .SH "VERSION" 
-This man page is current for version 2\&.x of rsync\&.
+.PP 
+This man page is current for version 2\&.6\&.5 of rsync\&.
 .PP 
 .SH "CREDITS" 
 .PP 
 rsync is distributed under the GNU public license\&.  See the file
 COPYING for details\&.
 .PP 
@@ -673,13 +673,13 @@
 This program uses the zlib compression library written by Jean-loup
 Gailly and Mark Adler\&.
 .PP 
 .SH "THANKS" 
 .PP 
 Thanks to Warren Stanley for his original idea and patch for the rsync
-server\&. Thanks to Karsten Thygesen for his many suggestions and
+daemon\&. Thanks to Karsten Thygesen for his many suggestions and
 documentation! 
 .PP 
 .SH "AUTHOR" 
 .PP 
 rsync was written by Andrew Tridgell and Paul Mackerras\&.
 Many people have later contributed to it\&.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsyncd.conf.yo	2005-03-31 11:14:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsyncd.conf.yo	2005-06-02 11:54:45.000000000 +0800
@@ -1,17 +1,17 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(30 Mar 2005)()()
-manpagename(rsyncd.conf)(configuration file for rsync server)
+manpage(rsyncd.conf)(5)(1 Jun 2005)()()
+manpagename(rsyncd.conf)(configuration file for rsync in daemon mode)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
 
 The rsyncd.conf file is the runtime configuration file for rsync when
-run as an rsync server. 
+run as an rsync daemon. 
 
 The rsyncd.conf file controls authentication, access, logging and
 available modules.
 
 manpagesection(FILE FORMAT)
 
@@ -50,13 +50,13 @@
 write the appropriate data, log, and lock files.
 
 You can launch it either via inetd, as a stand-alone daemon, or from
 an rsync client via a remote shell.  If run as a stand-alone daemon then
 just run the command "bf(rsync --daemon)" from a suitable startup script.
 If run from an rsync client via a remote shell (by specifying both the
-bf(--rsh) (bf(-e)) option and server mode with "::" or "rsync://"), the bf(--daemon)
+bf(--rsh) (bf(-e)) option and daemon mode with "::" or "rsync://"), the bf(--daemon)
 option is automatically passed to the remote side.
 
 When run via inetd you should add a line like this to /etc/services:
 
 verb(  rsync           873/tcp)
 
@@ -65,13 +65,13 @@
 verb(  rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd --daemon)
 
 Replace "/usr/bin/rsync" with the path to where you have rsync installed on
 your system.  You will then need to send inetd a HUP signal to tell it to
 reread its config file.
 
-Note that you should not send the rsync server a HUP signal to force
+Note that you should bf(not) send the rsync daemon a HUP signal to force
 it to reread the tt(rsyncd.conf) file. The file is re-read on each client
 connection. 
 
 manpagesection(GLOBAL OPTIONS)
 
 The first parameters in the file (before a [module] header) are the
@@ -87,25 +87,36 @@
 usually contains site information and any legal notices. The default
 is no motd file.
 
 dit(bf(log file)) The "log file" option tells the rsync daemon to log
 messages to that file rather than using syslog. This is particularly
 useful on systems (such as AIX) where syslog() doesn't work for
-chrooted programs.
+chrooted programs.  If the daemon fails to open to specified file, it
+will fall back to using syslog and output an error about the failure.
+(Note that a failure to open the specified log file used to be a fatal
+error.)
 
 dit(bf(pid file)) The "pid file" option tells the rsync daemon to write
 its process ID to that file.
 
 dit(bf(syslog facility)) The "syslog facility" option allows you to
 specify the syslog facility name to use when logging messages from the
-rsync server. You may use any standard syslog facility name which is
+rsync daemon. You may use any standard syslog facility name which is
 defined on your system. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
 local1, local2, local3, local4, local5, local6 and local7. The default
 is daemon. 
 
+dit(bf(port)) You can override the default port the daemon will listen on
+by specifying this value (defaults to 873).  This is ignored if the daemon
+is being run by inetd, and is superseded by the bf(--port) command-line option.
+
+dit(bf(address)) You can override the default IP address the daemon
+will listen on by specifying this value.  This is ignored if the daemon is
+being run by inetd, and is superseded by the bf(--address) command-line option.
+
 dit(bf(socket options)) This option can provide endless fun for people
 who like to tune their systems to the utmost degree. You can set all
 sorts of socket options which may make transfers faster (or
 slower!). Read the man page for the setsockopt() system call for
 details on some of the options you may be able to set. By default no
 special socket options are set.
@@ -123,17 +134,17 @@
 startdit()
 
 dit(bf(comment)) The "comment" option specifies a description string
 that is displayed next to the module name when clients obtain a list
 of available modules. The default is no comment.
 
-dit(bf(path)) The "path" option specifies the directory in the servers
+dit(bf(path)) The "path" option specifies the directory in the daemon's
 filesystem to make available in this module.  You must specify this option
 for each module in tt(rsyncd.conf).
 
-dit(bf(use chroot)) If "use chroot" is true, the rsync server will chroot
+dit(bf(use chroot)) If "use chroot" is true, the rsync daemon will chroot
 to the "path" before starting the file transfer with the client.  This has
 the advantage of extra protection against possible implementation security
 holes, but it has the disadvantages of requiring super-user privileges, 
 of not being able to follow symbolic links that are either absolute or outside
 of the new root path, and of complicating the preservation of usernames and groups
 (see below).  When "use chroot" is false, for security reasons,
@@ -154,55 +165,47 @@
 
 Note that you are free to setup user/group information in the chroot area
 differently from your normal system.  For example, you could abbreviate
 the list of users and groups.  Also, you can protect this information from
 being downloaded/uploaded by adding an exclude rule to the rsync.conf file
 (e.g. "exclude = /etc/**").  Note that having the exclusion affect uploads
-is a relatively new feature in rsync, so make sure your server is running
+is a relatively new feature in rsync, so make sure your daemon is
 at least 2.6.3 to effect this.  Also note that it is safest to exclude a
 directory and all its contents combining the rule "/some/dir/" with the
 rule "/some/dir/**" just to be sure that rsync will not allow deeper
 access to some of the excluded files inside the directory (rsync tries to
 do this automatically, but you might as well specify both to be extra
 sure).
 
-dit(bf(port)) You can override the default port the daemon will listen on
-by specifying this value (defaults to 873).  This is ignored if the daemon
-is being run by inetd, and is superseded by the bf(--port) command-line option.
-
-dit(bf(address)) You can override the default IP address the daemon
-will listen on by specifying this value.  This is ignored if the daemon is
-being run by inetd, and is superseded by the bf(--address) command-line option.
-
 dit(bf(max connections)) The "max connections" option allows you to
 specify the maximum number of simultaneous connections you will allow.
 Any clients connecting when the maximum has been reached will receive a
 message telling them to try later.  The default is 0 which means no limit.
 See also the "lock file" option.
 
 dit(bf(max verbosity)) The "max verbosity" option allows you to control
 the maximum amount of verbose information that you'll allow the daemon to
 generate (since the information goes into the log file). The default is 1,
 which allows the client to request one level of verbosity.
 
 dit(bf(lock file)) The "lock file" option specifies the file to use to
-support the "max connections" option. The rsync server uses record
+support the "max connections" option. The rsync daemon uses record
 locking on this file to ensure that the max connections limit is not
 exceeded for the modules sharing the lock file. 
 The default is tt(/var/run/rsyncd.lock).
 
 dit(bf(read only)) The "read only" option determines whether clients
 will be able to upload files or not. If "read only" is true then any
 attempted uploads will fail. If "read only" is false then uploads will
-be possible if file permissions on the server allow them. The default
+be possible if file permissions on the daemon side allow them. The default
 is for all modules to be read only.
 
 dit(bf(write only)) The "write only" option determines whether clients
 will be able to download files or not. If "write only" is true then any
 attempted downloads will fail. If "write only" is false then downloads
-will be possible if file permissions on the server allow them.  The
+will be possible if file permissions on the daemon side allow them.  The
 default is for this option to be disabled.
 
 dit(bf(list)) The "list" option determines if this module should be
 listed when the client asks for a listing of available modules. By
 setting this to false you can create hidden modules. The default is
 for modules to be listable.
@@ -216,51 +219,51 @@
 dit(bf(gid)) The "gid" option specifies the group name or group ID that
 file transfers to and from that module should take place as when the daemon
 was run as root. This complements the "uid" option. The default is gid -2,
 which is normally the group "nobody".
 
 dit(bf(filter)) The "filter" option allows you to specify a space-separated
-list of filter rules that the server will not allow to be read or written.
+list of filter rules that the daemon will not allow to be read or written.
 This is only superficially equivalent to the client specifying these
 patterns with the bf(--filter) option.  Only one "filter" option may be
 specified, but it may contain as many rules as you like, including
 merge-file rules.  Note that per-directory merge-file rules do not provide
 as much protection as global rules, but they can be used to make bf(--delete)
-work better when a client downloads the server's files (if the per-dir
+work better when a client downloads the daemon's files (if the per-dir
 merge files are included in the transfer).
 
 dit(bf(exclude)) The "exclude" option allows you to specify a
-space-separated list of patterns that the server will not allow to be read
+space-separated list of patterns that the daemon will not allow to be read
 or written.  This is only superficially equivalent to the client
 specifying these patterns with the bf(--exclude) option.  Only one "exclude"
 option may be specified, but you can use "-" and "+" before patterns to
 specify exclude/include.
 
 Because this exclude list is not passed to the client it only applies on
-the server: that is, it excludes files received by a client when receiving
-from a server and files deleted on a server when sending to a server, but
+the daemon: that is, it excludes files received by a client when receiving
+from a daemon and files deleted on a daemon when sending to a daemon, but
 it doesn't exclude files from being deleted on a client when receiving
-from a server.  
+from a daemon.  
 
 dit(bf(exclude from)) The "exclude from" option specifies a filename
-on the server that contains exclude patterns, one per line.
+on the daemon that contains exclude patterns, one per line.
 This is only superficially equivalent
 to the client specifying the bf(--exclude-from) option with an equivalent file.
 See the "exclude" option above.
 
 dit(bf(include)) The "include" option allows you to specify a
 space-separated list of patterns which rsync should not exclude. This is
 only superficially equivalent to the client specifying these patterns with
-the bf(--include) option because it applies only on the server.  This is
+the bf(--include) option because it applies only on the daemon.  This is
 useful as it allows you to build up quite complex exclude/include rules.
 Only one "include" option may be specified, but you can use "+" and "-"
 before patterns to switch include/exclude.  See the "exclude" option
 above.
 
 dit(bf(include from)) The "include from" option specifies a filename
-on the server that contains include patterns, one per line. This is
+on the daemon that contains include patterns, one per line. This is
 only superficially equivalent to the client specifying the
 bf(--include-from) option with a equivalent file.
 See the "exclude" option above.
 
 dit(bf(auth users)) The "auth users" option specifies a comma and
 space-separated list of usernames that will be allowed to connect to
@@ -270,16 +273,16 @@
 username and password to connect to the module. A challenge response
 authentication protocol is used for this exchange. The plain text
 usernames are passwords are stored in the file specified by the
 "secrets file" option. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync").
 
-See also the bf(CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL
-PROGRAM) section in rsync(1) for information on how handle an
+See also the "CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL
+PROGRAM" section in rsync(1) for information on how handle an
 rsyncd.conf-level username that differs from the remote-shell-level
-username when using a remote shell to connect to an rsync server.
+username when using a remote shell to connect to an rsync daemon.
 
 dit(bf(secrets file)) The "secrets file" option specifies the name of
 a file that contains the username:password pairs used for
 authenticating this module. This file is only consulted if the "auth
 users" option is specified. The file is line based and contains
 username:password pairs separated by a single colon. Any line starting
@@ -348,27 +351,27 @@
 hostname and IP address. If the pattern matches then the connection is
 rejected. See the "hosts allow" option for more information.
 
 The default is no "hosts deny" option, which means all hosts can connect.
 
 dit(bf(ignore errors)) The "ignore errors" option tells rsyncd to
-ignore I/O errors on the server when deciding whether to run the delete
+ignore I/O errors on the daemon when deciding whether to run the delete
 phase of the transfer. Normally rsync skips the bf(--delete) step if any
 I/O errors have occurred in order to prevent disastrous deletion due
 to a temporary resource shortage or other I/O error. In some cases this
 test is counter productive so you can use this option to turn off this
 behavior. 
 
-dit(bf(ignore nonreadable)) This tells the rsync server to completely
+dit(bf(ignore nonreadable)) This tells the rsync daemon to completely
 ignore files that are not readable by the user. This is useful for
 public archives that may have some non-readable files among the
 directories, and the sysadmin doesn't want those files to be seen at all.
 
 dit(bf(transfer logging)) The "transfer logging" option enables per-file 
 logging of downloads and uploads in a format somewhat similar to that
-used by ftp daemons.  The server always logs the transfer at the end, so
+used by ftp daemons.  The daemon always logs the transfer at the end, so
 if a transfer is aborted, no mention will be made in the log file.
 
 If you want to customize the log lines, see the "log format" option.
 
 dit(bf(log format)) The "log format" option allows you to specify the
 format used for logging file transfers when transfer logging is enabled.
@@ -414,18 +417,18 @@
 messages prior to rsync 2.6.4.
 
 dit(bf(timeout)) The "timeout" option allows you to override the
 clients choice for I/O timeout for this module. Using this option you
 can ensure that rsync won't wait on a dead client forever. The timeout
 is specified in seconds. A value of zero means no timeout and is the
-default. A good choice for anonymous rsync servers may be 600 (giving
+default. A good choice for anonymous rsync daemons may be 600 (giving
 a 10 minute timeout).
 
 dit(bf(refuse options)) The "refuse options" option allows you to
 specify a space-separated list of rsync command line options that will
-be refused by your rsync server.
+be refused by your rsync daemon.
 You may specify the full option name, its one-letter abbreviation, or a
 wild-card string that matches multiple options.
 For example, this would refuse bf(--checksum) (bf(-c)) and all the various
 delete options:
 
 quote(tt(    refuse options = c delete))
@@ -434,13 +437,13 @@
 bf(--delete), and implied options are refused just like explicit options.
 As an additional safety feature, the refusal of "delete" also refuses
 bf(remove-sent-files) when the daemon is the sender; if you want the latter
 without the former, instead refuse "delete-*" -- that refuses all the
 delete modes without affecting bf(--remove-sent-files).
 
-When an option is refused, the server prints an error message and exits.
+When an option is refused, the daemon prints an error message and exits.
 To prevent all compression, you can use "dont compress = *" (see below)
 instead of "refuse options = compress" to avoid returning an error to a
 client that requests compression.
 
 dit(bf(dont compress)) The "dont compress" option allows you to select
 filenames based on wildcard patterns that should not be compressed
@@ -462,30 +465,30 @@
 challenge response system. Although I believe that no one has ever
 demonstrated a brute-force break of this sort of system you should
 realize that this is not a "military strength" authentication system.
 It should be good enough for most purposes but if you want really top
 quality security then I recommend that you run rsync over ssh.
 
-Also note that the rsync server protocol does not currently provide any
+Also note that the rsync daemon protocol does not currently provide any
 encryption of the data that is transferred over the connection. Only
 authentication is provided. Use ssh as the transport if you want
 encryption.
 
 Future versions of rsync may support SSL for better authentication and
 encryption, but that is still being investigated.
 
-manpagesection(RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM)
+manpagesection(RUNNING AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM)
 
 If rsync is run with both the bf(--daemon) and bf(--rsh) (bf(-e)) options, it will
 spawn an rsync daemon using a remote shell connection.  Several
 configuration options will not be available unless the remote user is
 root (e.g. chroot, setuid/setgid, etc.).  There is no need to configure
-inetd or the services map to include the rsync server port if you run an
-rsync server only via a remote shell program.
+inetd or the services map to include the rsync daemon port if you run an
+rsync daemon only via a remote shell program.
 
-ADVANCED: To run an rsync server out of a single-use ssh key, use the
+ADVANCED: To run an rsync daemon out of a single-use ssh key, use the
 "command=em(COMMAND)" syntax in the remote user's authorized_keys entry,
 where command would be
 
 quote(tt(rsync --server --daemon .))
 
 NOTE: rsync's argument parsing expects the trailing ".", so make sure
@@ -559,21 +562,18 @@
 rsync(1)
 
 manpagediagnostics()
 
 manpagebugs()
 
-The rsync server does not send all types of error messages to the
-client. this means a client may be mystified as to why a transfer
-failed. The error will have been logged by syslog on the server.
-
 Please report bugs! The rsync bug tracking system is online at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
-This man page is current for version 2.x of rsync.
+
+This man page is current for version 2.6.5 of rsync.
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
@@ -588,13 +588,13 @@
 This program uses the zlib compression library written by Jean-loup
 Gailly and Mark Adler.
 
 manpagesection(THANKS)
 
 Thanks to Warren Stanley for his original idea and patch for the rsync
-server. Thanks to Karsten Thygesen for his many suggestions and
+daemon. Thanks to Karsten Thygesen for his many suggestions and
 documentation! 
 
 manpageauthor()
 
 rsync was written by Andrew Tridgell and Paul Mackerras.
 Many people have later contributed to it.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsync.h	2005-03-29 01:08:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsync.h	2005-05-04 01:00:47.000000000 +0800
@@ -100,14 +100,14 @@
 
 #define IOERR_GENERAL	(1<<0) /* For backward compatibility, this must == 1 */
 #define IOERR_VANISHED	(1<<1)
 #define IOERR_DEL_LIMIT (1<<2)
 
 #define MAX_ARGS 1000
-
 #define MAX_BASIS_DIRS 20
+#define MAX_SERVER_ARGS (MAX_BASIS_DIRS*2 + 100)
 
 #define MPLEX_BASE 7
 
 #define NO_FILTERS	0
 #define SERVER_FILTERS	1
 #define ALL_FILTERS	2
@@ -136,13 +136,12 @@
 /* For calling delete_file() */
 #define DEL_NO_RECURSE		(1<<1)
 #define DEL_FORCE_RECURSE	(1<<2) /* recurse even w/o --force */
 #define DEL_TERSE		(1<<3)
 
 /* For use by the itemize_changes code */
-#define ITEM_DUMMY_BIT (1<<0)
 #define ITEM_REPORT_CHECKSUM (1<<1)
 #define ITEM_REPORT_SIZE (1<<2)
 #define ITEM_REPORT_TIME (1<<3)
 #define ITEM_REPORT_PERMS (1<<4)
 #define ITEM_REPORT_OWNER (1<<5)
 #define ITEM_REPORT_GROUP (1<<6)
@@ -672,14 +671,18 @@
 #endif
 
 #ifndef HAVE_ERRNO_DECL
 extern int errno;
 #endif
 
-#define SUPPORT_LINKS HAVE_READLINK
-#define SUPPORT_HARD_LINKS HAVE_LINK
+#ifdef HAVE_READLINK
+#define SUPPORT_LINKS 1
+#endif
+#ifdef HAVE_LINK
+#define SUPPORT_HARD_LINKS 1
+#endif
 
 #define SIGNAL_CAST (RETSIGTYPE (*)())
 
 #ifndef EWOULDBLOCK
 #define EWOULDBLOCK EAGAIN
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/rsync.yo	2005-03-31 11:14:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/rsync.yo	2005-06-02 11:54:45.000000000 +0800
@@ -1,14 +1,14 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(30 Mar 2005)()()
+manpage(rsync)(1)(1 Jun 2005)()()
 manpagename(rsync)(faster, flexible replacement for rcp)
 manpagesynopsis()
 
 rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
 
-rsync [OPTION]... [USER@]HOST:SRC DEST
+rsync [OPTION]... [USER@]HOST:SRC [DEST]
 
 rsync [OPTION]... SRC [SRC]... DEST
 
 rsync [OPTION]... [USER@]HOST::SRC [DEST]
 
 rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST
@@ -35,53 +35,45 @@
   it() support for copying links, devices, owners, groups, and permissions
   it() exclude and exclude-from options similar to GNU tar
   it() a CVS exclude mode for ignoring the same files that CVS would ignore
   it() can use any transparent remote shell, including ssh or rsh
   it() does not require root privileges
   it() pipelining of file transfers to minimize latency costs
-  it() support for anonymous or authenticated rsync servers (ideal for
+  it() support for anonymous or authenticated rsync daemons (ideal for
        mirroring)
 )
 
 manpagesection(GENERAL)
 
-There are eight different ways of using rsync. They are:
+Rsync copies files either to or from a remote host, or locally on the
+current host (it does not support copying files between two remote hosts).
 
-itemize(
-	it() for copying local files. This is invoked when neither
-	     source nor destination path contains a : separator
-	it() for copying from the local machine to a remote machine using
-	a remote shell program as the transport (such as ssh or
-	rsh). This is invoked when the destination path contains a
-	single : separator.
-	it() for copying from a remote machine to the local machine
-	using a remote shell program. This is invoked when the source
-	contains a : separator.
-	it() for copying from a remote rsync server to the local
-	machine. This is invoked when the source path contains a ::
-	separator or an rsync:// URL.
-	it() for copying from the local machine to a remote rsync
-	server. This is invoked when the destination path contains a ::
-	separator or an rsync:// URL.
-	it() for copying from a remote machine using a remote shell
-	program as the transport, using rsync server on the remote
-	machine.  This is invoked when the source path contains a ::
-	separator and the bf(--rsh=COMMAND) (aka "bf(-e COMMAND)") option is
-	also provided.
-	it() for copying from the local machine to a remote machine
-	using a remote shell program as the transport, using rsync
-	server on the remote machine.  This is invoked when the
-	destination path contains a :: separator and the
-	bf(--rsh=COMMAND) option is also provided.
-	it() for listing files on a remote machine. This is done the
-	same way as rsync transfers except that you leave off the
-	local destination.
-)
-
-Note that in all cases (other than listing) at least one of the source
-and destination paths must be local.
+There are two different ways for rsync to contact a remote system: using a
+remote-shell program as the transport (such as ssh or rsh) or contacting an
+rsync daemon directly via TCP.  The remote-shell transport is used whenever
+the source or destination path contains a single colon (:) separator after
+a host specification.  Contacting an rsync daemon directly happens when the
+source or destination path contains a double colon (::) separator after a
+host specification, OR when an rsync:// URL is specified.
+
+As a special case, if a remote source is specified without a destination,
+the remote files are listed in an output format similar to "ls -l".
+
+As expected, if neither the source or destination path specify a remote
+host, the copy occurs locally (see also the bf(--list-only) option).
+
+Finally, it is possible to use a remote-shell transport to contact a remote
+host and then to spawn a single-use rsync daemon.  This allows the use of
+some of the daemon features (such as named modules) without having to run a
+daemon as a service.  To achieve this, invoke rsync with an explicit
+bf(--rsh=COMMAND) (aka "bf(-e COMMAND)") option combined with either the
+source or destination path specified as an rsync daemon (i.e. either a ::
+separator or an rsync:// URL).  In this case, rsync contacts the remote
+host specified using the specified remote shell, and then starts a
+single-use rsync daemon to deal with that copy request.  See the section
+"CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM" below.
 
 manpagesection(SETUP)
 
 See the file README for installation instructions.
 
 Once installed, you can use rsync to any machine that you can access via
@@ -136,12 +128,21 @@
 
 quote(
 tt(rsync -av /src/foo /dest)nl()
 tt(rsync -av /src/foo/ /dest/foo)nl()
 )
 
+Note also that host and module references don't require a trailing slash to
+copy the contents of the default directory.  For example, both of these
+copy the remote directory's contents into "/dest":
+
+quote(
+tt(rsync -av host: /dest)nl()
+tt(rsync -av host::module /dest)nl()
+)
+
 You can also use rsync in local-only mode, where both the source and
 destination don't have a ':' in the name. In this case it behaves like
 an improved copy command.
 
 quote(tt(rsync somehost.mydomain.com::))
 
@@ -175,16 +176,16 @@
 tt(rsync -av host:file?name?with?spaces /dest)nl()
 )
 
 This latter example assumes that your shell passes through unmatched
 wildcards.  If it complains about "no match", put the name in quotes.
 
-manpagesection(CONNECTING TO AN RSYNC SERVER)
+manpagesection(CONNECTING TO AN RSYNC DAEMON)
 
 It is also possible to use rsync without a remote shell as the
-transport. In this case you will connect to a remote rsync server
+transport. In this case you will connect to a remote rsync daemon
 running on TCP port 873.
 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
 your web proxy.  Note that your web proxy's configuration must support
 proxy connections to port 873.
@@ -192,74 +193,74 @@
 Using rsync in this way is the same as using it with a remote shell except
 that:
 
 itemize(
 	it() you either use a double colon :: instead of a single colon to
 	separate the hostname from the path, or you use an rsync:// URL.
-	it() the remote server may print a message of the day when you
+	it() the remote daemon may print a message of the day when you
 	connect.
-	it() if you specify no path name on the remote server then the
-	list of accessible paths on the server will be shown.
+	it() if you specify no path name on the remote daemon then the
+	list of accessible paths on the daemon will be shown.
 	it() if you specify no local destination then a listing of the
-	specified files on the remote server is provided.
+	specified files on the remote daemon is provided.
 )
 
-Some paths on the remote server may require authentication. If so then
+Some paths on the remote daemon may require authentication. If so then
 you will receive a password prompt when you connect. You can avoid the
 password prompt by setting the environment variable RSYNC_PASSWORD to
 the password you want to use or using the bf(--password-file) option. This
 may be useful when scripting rsync.
 
 WARNING: On some systems environment variables are visible to all
 users. On those systems using bf(--password-file) is recommended.
 
-manpagesection(CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM)
+manpagesection(CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM)
 
 It is sometimes useful to be able to set up file transfers using rsync
-server capabilities on the remote machine, while still using ssh or
+daemon capabilities on the remote machine, while still using ssh or
 rsh for transport.  This is especially useful when you want to connect
 to a remote machine via ssh (for encryption or to get through a
-firewall), but you still want to have access to the rsync server
-features (see RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM,
+firewall), but you still want to have access to the rsync daemon
+features (see RUNNING AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM,
 below).
 
 From the user's perspective, using rsync in this way is the same as
-using it to connect to an rsync server, except that you must
+using it to connect to an rsync daemon, except that you must
 explicitly set the remote shell program on the command line with
 bf(--rsh=COMMAND).  (Setting RSYNC_RSH in the environment will not turn on
 this functionality.)
 
 In order to distinguish between the remote-shell user and the rsync
-server user, you can use '-l user' on your remote-shell command:
+daemon user, you can use '-l user' on your remote-shell command:
 
 verb(    rsync -av --rsh="ssh -l ssh-user" \ 
         rsync-user@host::module[/path] local-path)
 
 The "ssh-user" will be used at the ssh level; the "rsync-user" will be
 used to check against the rsyncd.conf on the remote host.
 
-manpagesection(RUNNING AN RSYNC SERVER)
+manpagesection(RUNNING AN RSYNC DAEMON)
 
-An rsync server is configured using a configuration file.  Please see the
+An rsync daemon is configured using a configuration file.  Please see the
 rsyncd.conf(5) man page for more information.  By default the configuration
 file is called /etc/rsyncd.conf, unless rsync is running over a remote
 shell program and is not running as root; in that case, the default name
 is rsyncd.conf in the current directory on the remote computer
 (typically $HOME).
 
-manpagesection(RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM)
+manpagesection(RUNNING AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM)
 
 See the rsyncd.conf(5) man page for full information on the rsync
-server configuration file.
+daemon configuration file.
 
 Several configuration options will not be available unless the remote
 user is root (e.g. chroot, setuid/setgid, etc.).  There is no need to
-configure inetd or the services map to include the rsync server port
-if you run an rsync server only via a remote shell program.
+configure inetd or the services map to include the rsync daemon port
+if you run an rsync daemon only via a remote shell program.
 
-To run an rsync server out of a single-use ssh key, see this section
+To run an rsync daemon out of a single-use ssh key, see this section
 in the rsyncd.conf(5) man page.
 
 manpagesection(EXAMPLES)
 
 Here are some examples of how I use rsync.
 
@@ -362,31 +363,33 @@
                              repeated: --filter='- .rsync-filter'
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     read exclude patterns from FILE
      --include=PATTERN       don't exclude files matching PATTERN
      --include-from=FILE     read include patterns from FILE
      --files-from=FILE       read list of source-file names from FILE
- -0, --from0                 all *from file lists are delimited by nulls
-     --version               print version number
+ -0, --from0                 all *from/filter files are delimited by 0s
+     --address=ADDRESS       bind address for outgoing socket to daemon
      --port=PORT             specify double-colon alternate port number
      --blocking-io           use blocking I/O for the remote shell
      --no-blocking-io        turn off blocking I/O when it is default
      --stats                 give some file-transfer stats
      --progress              show progress during transfer
  -P                          same as --partial --progress
  -i, --itemize-changes       output a change-summary for all updates
-     --log-format=FORMAT     log file-transfers using specified format
+     --log-format=FORMAT     output filenames using the specified format
      --password-file=FILE    read password from FILE
      --list-only             list the files instead of copying them
      --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
      --write-batch=FILE      write a batched update to FILE
+     --only-write-batch=FILE like --write-batch but w/o updating dest
      --read-batch=FILE       read a batched update from FILE
      --protocol=NUM          force an older protocol version to be used
      --checksum-seed=NUM     set block/file checksum seed (advanced)
  -4, --ipv4                  prefer IPv4
  -6, --ipv6                  prefer IPv6
+     --version               print version number
  -h, --help                  show this help screen)
 
 Rsync can also be run as a daemon, in which case the following options are
 accepted: verb(
      --daemon                run as an rsync daemon
      --address=ADDRESS       bind to the specified address
@@ -420,13 +423,13 @@
 information on what files are being skipped and slightly more
 information at the end. More than two bf(-v) flags should only be used if
 you are debugging rsync.
 
 Note that the names of the transferred files that are output are done using
 a default bf(--log-format) of "%n%L", which tells you just the name of the
-file and, if the item is a symlink, where it points.  At the single bf(-v)
+file and, if the item is a link, where it points.  At the single bf(-v)
 level of verbosity, this does not mention when a file gets its attributes
 changed.  If you ask for an itemized list of changed attributes (either
 bf(--itemize-changes) or adding "%i" to the bf(--log-format) setting), the
 output (on the client) increases to mention all items that are changed in
 any way.  See the bf(--log-format) option for more details.
 
@@ -617,15 +620,16 @@
 dit(bf(--no-whole-file)) Turn off bf(--whole-file), for use when it is the
 default.
 
 dit(bf(-p, --perms)) This option causes rsync to set the destination
 permissions to be the same as the source permissions.
 
-Without this option, each new file gets its permissions set based on the
-source file's permissions and the umask at the receiving end, while all
-other files (including updated files) retain their existing permissions
+Without this option, all existing files (including updated files) retain
+their existing permissions, while each new file gets its permissions set
+based on the source file's permissions, but masked by the receiving end's
+umask setting
 (which is the same behavior as other file-copy utilities, such as cp).
 
 dit(bf(-o, --owner)) This option causes rsync to set the owner of the
 destination file to be the same as the source file.  On most systems,
 only the super-user can set file ownership.  By default, the preservation
 is done by name, but may fall back to using the ID number in some
@@ -766,17 +770,17 @@
 dit(bf(-e, --rsh=COMMAND)) This option allows you to choose an alternative
 remote shell program to use for communication between the local and
 remote copies of rsync. Typically, rsync is configured to use ssh by
 default, but you may prefer to use rsh on a local network.
 
 If this option is used with bf([user@]host::module/path), then the
-remote shell em(COMMAND) will be used to run an rsync server on the
+remote shell em(COMMAND) will be used to run an rsync daemon on the
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
-running rsync server on the remote host.  See the section "CONNECTING
-TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" above.
+running rsync daemon on the remote host.  See the section "CONNECTING
+TO AN RSYNC DAEMON OVER A REMOTE SHELL PROGRAM" above.
 
 Command-line arguments are permitted in COMMAND provided that COMMAND is
 presented to rsync as a single argument.  For example:
 
 quote(tt(   -e "ssh -p 2234"))
 
@@ -902,15 +906,20 @@
 allowed to go higher than the source dir.  For example, take this
 command:
 
 quote(tt(   rsync -a --files-from=/tmp/foo /usr remote:/backup))
 
 If /tmp/foo contains the string "bin" (or even "/bin"), the /usr/bin
-directory will be created as /backup/bin on the remote host (but the
-contents of the /usr/bin dir would not be sent unless you specified bf(-r)
-or the names were explicitly listed in /tmp/foo).  Also keep in mind
+directory will be created as /backup/bin on the remote host.  If it
+contains "bin/" (note the trailing slash), the immediate contents of
+the directory would also be sent (without needing to be explicitly
+mentioned in the file -- this began in version 2.6.4).  In both cases,
+if the bf(-r) option was enabled, that dir's entire hierarchy would
+also be transferred (keep in mind that bf(-r) needs to be specified
+explicitly with bf(--files-from), since it is not implied by bf(-a)).
+Also note
 that the effect of the (enabled by default) bf(--relative) option is to
 duplicate only the path info that is read from the file -- it does not
 force the duplication of the source-spec path (/usr in this case).
 
 In addition, the bf(--files-from) file can be read from the remote host
 instead of the local host if you specify a "host:" in front of the file
@@ -920,13 +929,13 @@
 
 quote(tt(   rsync -a --files-from=:/path/file-list src:/ /tmp/copy))
 
 This would copy all the files specified in the /path/file-list file that
 was located on the remote "src" host.
 
-dit(bf(-0, --from0)) This tells rsync that the filenames it reads from a
+dit(bf(-0, --from0)) This tells rsync that the rules/filenames it reads from a
 file are terminated by a null ('\0') character, not a NL, CR, or CR+LF.
 This affects bf(--exclude-from), bf(--include-from), bf(--files-from), and any
 merged files specified in a bf(--filter) rule.
 It does not affect bf(--cvs-exclude) (since all names read from a .cvsignore
 file are split on whitespace).
 
@@ -1029,12 +1038,17 @@
 users and groups and what you can do about it.
 
 dit(bf(--timeout=TIMEOUT)) This option allows you to set a maximum I/O
 timeout in seconds. If no data is transferred for the specified time
 then rsync will exit. The default is 0, which means no timeout.
 
+dit(bf(--address)) By default rsync will bind to the wildcard address when
+connecting to an rsync daemon.  The bf(--address) option allows you to
+specify a specific IP address (or hostname) to bind to.  See also this
+option in the bf(--daemon) mode section.
+
 dit(bf(--port=PORT)) This specifies an alternate TCP port number to use
 rather than the default of 873.  This is only needed if you are using the
 double-colon (::) syntax to connect with an rsync daemon (since the URL
 syntax has a way to specify the port as a part of the URL).  See also this
 option in the bf(--daemon) mode section.
 
@@ -1061,13 +1075,13 @@
 
 quote(itemize(
   it() A bf(<) means that a file is being transferred to the remote host
   (sent).
   it() A bf(>) means that a file is being transferred to the local host
   (received).
-  it() A bf(c) means that a local change/creation is occuring for the item
+  it() A bf(c) means that a local change/creation is occurring for the item
   (such as the creation of a directory or the changing of a symlink, etc.).
   it() A bf(h) means that the item is a hard-link to another item (requires
   bf(--hard-links)).
   it() A bf(.) means that the item is not being updated (though it might
   have attributes that are being modified).
 ))
@@ -1077,32 +1091,32 @@
 
 The other letters in the string above are the actual letters that
 will be output if the associated attribute for the item is being updated or
 a "." for no change.  Three exceptions to this are: (1) a newly created
 item replaces each letter with a "+", (2) an identical item replaces the
 dots with spaces, and (3) an unknown attribute replaces each letter with
-a "?" (this happens when talking to an older rsync).
+a "?" (this can happen when talking to an older rsync).
 
 The attribute that is associated with each letter is as follows:
 
 quote(itemize(
   it() A bf(c) means the checksum of the file is different and will be
-  updated by the file transfer (requries bf(--checksum)).
+  updated by the file transfer (requires bf(--checksum)).
   it() A bf(s) means the size of the file is different and will be updated
   by the file transfer.
   it() A bf(t) means the modification time is different and is being updated
-  to the server's value (requires bf(--times)).  An alternate value of bf(T)
+  to the sender's value (requires bf(--times)).  An alternate value of bf(T)
   means that the time will be set to the transfer time, which happens
   anytime a symlink is transferred, or when a file or device is transferred
   without bf(--times).
   it() A bf(p) means the permissions are different and are being updated to
-  the server's value (requires bf(--perms)).
+  the sender's value (requires bf(--perms)).
   it() An bf(o) means the owner is different and is being updated to the
-  server's value (requires bf(--owner) and root privileges).
+  sender's value (requires bf(--owner) and root privileges).
   it() A bf(g) means the group is different and is being updated to the
-  server's value (requires bf(--group) and the authority to set the group).
+  sender's value (requires bf(--group) and the authority to set the group).
   it() The bf(a) is reserved for a future enhanced version that supports
   extended file attributes, such as ACLs.
 ))
 
 One other output is possible:  when deleting files, the "%i" will output
 the string "*deleting" for each item that is being removed (assuming that
@@ -1117,13 +1131,13 @@
 option does not affect what a daemon logs to its logfile.)
 
 Specifying this option will mention each file, dir, etc. that gets updated
 in a significant way (a transferred file, a recreated symlink/device, or a
 touched directory) unless the itemized-changes escape (%i) is included in
 the string, in which case the logging of names increases to mention any
-item that is updated in any way (as long as the receiving side is version
+item that is changed in any way (as long as the receiving side is at least
 2.6.4).  See the bf(--itemized-changes) option for a description of the
 output of "%i".
 
 The bf(--verbose) option implies a format of "%n%L", but you can use
 bf(--log-format) without bv(--verbose) if you like, or you can override
 the format of its per-file output using this option.
@@ -1185,13 +1199,13 @@
 environment and then just use the bf(-P) option to turn on the use of the
 .rsync-tmp dir for partial transfers.  The only time that the bf(--partial)
 option does not look for this environment value is (1) when bf(--inplace) was
 specified (since bf(--inplace) conflicts with bf(--partial-dir)), or (2) when
 bf(--delay-updates) was specified (see below).
 
-For the purposes of the server-config's "refuse options" setting,
+For the purposes of the daemon-config's "refuse options" setting,
 bf(--partial-dir) does em(not) imply bf(--partial).  This is so that a
 refusal of the bf(--partial) option can be used to disallow the overwriting
 of destination files with a partial transfer, while still allowing the
 safer idiom provided by bf(--partial-dir).
 
 dit(bf(--delay-updates)) This option puts the temporary file from each
@@ -1199,13 +1213,13 @@
 transfer, at which time all the files are renamed into place in rapid
 succession.  This attempts to make the updating of the files a little more
 atomic.  By default the files are placed into a directory named ".~tmp~" in
 each file's destination directory, but you can override this by specifying
 the bf(--partial-dir) option.  (Note that RSYNC_PARTIAL_DIR has no effect
 on this value, nor is bf(--partial-dir) considered to be implied for the
-purposes of the server-config's "refuse options" setting.)
+purposes of the daemon-config's "refuse options" setting.)
 Conflicts with bf(--inplace).
 
 This option uses more memory on the receiving side (one bit per file
 transferred) and also requires enough free disk space on the receiving
 side to hold an additional copy of all the updated files.  Note also that
 you should not use an absolute path to bf(--partial-dir) unless there is no
@@ -1243,49 +1257,68 @@
 
 dit(bf(-P)) The bf(-P) option is equivalent to bf(--partial) bf(--progress).  Its
 purpose is to make it much easier to specify these two options for a long
 transfer that may be interrupted.
 
 dit(bf(--password-file)) This option allows you to provide a password
-in a file for accessing a remote rsync server. Note that this option
-is only useful when accessing an rsync server using the built in
+in a file for accessing a remote rsync daemon. Note that this option
+is only useful when accessing an rsync daemon using the built in
 transport, not when using a remote shell as the transport. The file
 must not be world readable. It should contain just the password as a
 single line.
 
 dit(bf(--list-only)) This option will cause the source files to be listed
 instead of transferred.  This option is inferred if there is no destination
 specified, so you don't usually need to use it explicitly.  However, it can
-come in handy for a power user that wants to avoid the "bf(-r --exclude='/*/*')"
+come in handy for a user that wants to avoid the "bf(-r --exclude='/*/*')"
 options that rsync might use as a compatibility kluge when generating a
-non-recursive listing.
+non-recursive listing, or to list the files that are involved in a local
+copy (since the destination path is not optional for a local copy, you
+must specify this option explicitly and still include a destination).
 
 dit(bf(--bwlimit=KBPS)) This option allows you to specify a maximum
 transfer rate in kilobytes per second. This option is most effective when
 using rsync with large files (several megabytes and up). Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
 transfer was too fast, it will wait before sending the next data block. The
 result is an average transfer rate equaling the specified limit. A value
 of zero specifies no limit.
 
 dit(bf(--write-batch=FILE)) Record a file that can later be applied to
 another identical destination with bf(--read-batch). See the "BATCH MODE"
-section for details.
+section for details, and also the bf(--only-write-batch) option.
+
+dit(bf(--only-write-batch=FILE)) Works like bf(--write-batch), except that
+no updates are made on the destination system when creating the batch.
+This lets you transport the changes to the destination system via some
+other means and then apply the changes via bf(--read-batch).
+
+Note that you can feel free to write the batch directly to some portable
+media: if this media fills to capacity before the end of the transfer, you
+can just apply that partial transfer to the destination and repeat the
+whole process to get the rest of the changes (as long as you don't mind a
+partially updated destination system while the multi-update cycle is
+happening).
+
+Also note that you only save bandwidth when pushing changes to a remote
+system because this allows the batched data to be diverted from the sender
+into the batch file without having to flow over the wire to the receiver
+(when pulling, the sender is remote, and thus can't write the batch).
 
 dit(bf(--read-batch=FILE)) Apply all of the changes stored in FILE, a
 file previously generated by bf(--write-batch).
 If em(FILE) is "-" the batch data will be read from standard input.
 See the "BATCH MODE" section for details.
 
 dit(bf(--protocol=NUM)) Force an older protocol version to be used.  This
 is useful for creating a batch file that is compatible with an older
 version of rsync.  For instance, if rsync 2.6.4 is being used with the
 bf(--write-batch) option, but rsync 2.6.3 is what will be used to run the
-bf(--read-batch) option, you should use "--protocol=28" (when creating the
-batch file) to force the older protocol version to be used in the batch
-file (assuming you can't upgrade the rsync on the reading system to 2.6.4).
+bf(--read-batch) option, you should use "--protocol=28" when creating the
+batch file to force the older protocol version to be used in the batch
+file (assuming you can't upgrade the rsync on the reading system).
 
 dit(bf(-4, --ipv4) or bf(-6, --ipv6)) Tells rsync to prefer IPv4/IPv6
 when creating sockets.  This only affects sockets that rsync has direct
 control over, such as the outgoing socket when directly contacting an
 rsync daemon.  See also these options in the bf(--daemon) mode section.
 
@@ -1313,18 +1346,17 @@
 run via inetd, otherwise it will detach from the current terminal and
 become a background daemon.  The daemon will read the config file
 (rsyncd.conf) on each connect made by a client and respond to
 requests accordingly.  See the rsyncd.conf(5) man page for more
 details.
 
-dit(bf(--address)) By default rsync will bind to the wildcard address
-when run as a daemon with the bf(--daemon) option or when connecting to a
-rsync server. The bf(--address) option allows you to specify a specific IP
-address (or hostname) to bind to. This makes virtual hosting possible
-in conjunction with the bf(--config) option.  See also the "address" global
-option in the rsyncd.conf manpage.
+dit(bf(--address)) By default rsync will bind to the wildcard address when
+run as a daemon with the bf(--daemon) option.  The bf(--address) option
+allows you to specify a specific IP address (or hostname) to bind to.  This
+makes virtual hosting possible in conjunction with the bf(--config) option.
+See also the "address" global option in the rsyncd.conf manpage.
 
 dit(bf(--bwlimit=KBPS)) This option allows you to specify a maximum
 transfer rate in kilobytes per second for the data the daemon sends.
 The client can still specify a smaller bf(--bwlimit) value, but their
 requested value will be rounded down if they try to exceed it.  See the
 client version of this option (above) for some extra details.
@@ -1564,13 +1596,13 @@
   also disabled).
   it() You may also specify any of the modifiers for the "+" or "-" rules
   (below) in order  to have the rules that are read-in from the file
   default to having that modifier set.  For instance, "merge,-/ .excl" would
   treat the contents of .excl as absolute-path excludes,
   while "dir-merge,s .filt" and ":sC" would each make all their
-  per-directory rules apply only on the server side.
+  per-directory rules apply only on the sending side.
 )
 
 The following modifiers are accepted after a "+" or "-":
 
 itemize(
   it() A "/" specifies that the include/exclude should be treated as an
@@ -1585,13 +1617,13 @@
   follow.
   it() An bf(s) is used to indicate that the rule applies to the sending
   side.  When a rule affects the sending side, it prevents files from
   being transferred.  The default is for a rule to affect both sides
   unless bf(--delete-excluded) was specified, in which case default rules
   become sender-side only.  See also the hide (H) and show (S) rules,
-  which are an alternate way to specify server-side includes/excludes.
+  which are an alternate way to specify sending-side includes/excludes.
   it() An bf(r) is used to indicate that the rule applies to the receiving
   side.  When a rule affects the receiving side, it prevents files from
   being deleted.  See the bf(s) modifier for more info.  See also the
   protect (P) and risk (R) rules, which are an alternate way to
   specify receiver-side includes/excludes.
 )
@@ -1919,18 +1951,37 @@
 rsync also distinguishes "safe" and "unsafe" symbolic links.  An
 example where this might be used is a web site mirror that wishes
 ensure the rsync module they copy does not include symbolic links to
 bf(/etc/passwd) in the public section of the site.  Using
 bf(--copy-unsafe-links) will cause any links to be copied as the file
 they point to on the destination.  Using bf(--safe-links) will cause
-unsafe links to be omitted altogether.
+unsafe links to be omitted altogether.  (Note that you must specify
+bf(--links) for bf(--safe-links) to have any effect.)
 
 Symbolic links are considered unsafe if they are absolute symlinks
 (start with bf(/)), empty, or if they contain enough bf("..")
 components to ascend from the directory being copied.
 
+Here's a summary of how the symlink options are interpreted.  The list is
+in order of precedence, so if your combination of options isn't mentioned,
+use the first line that is a complete subset of your options:
+
+dit(bf(--copy-links)) Turn all symlinks into normal files (leaving no
+symlinks for any other options to affect).
+
+dit(bf(--links --copy-unsafe-links)) Turn all unsafe symlinks into files
+and duplicate all safe symlinks.
+
+dit(bf(--copy-unsafe-links)) Turn all unsafe symlinks into files, noisily
+skip all safe symlinks.
+
+dit(bf(--links --safe-links))  Duplicate safe symlinks and skip unsafe
+ones.
+
+dit(bf(--links)) Duplicate all symlinks.
+
 manpagediagnostics()
 
 rsync occasionally produces error messages that may seem a little
 cryptic. The one that seems to cause the most confusion is "protocol
 version mismatch -- is your shell clean?".
 
@@ -1994,13 +2045,13 @@
 rsync daemon. You should set RSYNC_PROXY to a hostname:port pair.
 dit(bf(RSYNC_PASSWORD)) Setting RSYNC_PASSWORD to the required
 password allows you to run authenticated rsync connections to an rsync
 daemon without user intervention. Note that this does not supply a
 password to a shell transport such as ssh.
 dit(bf(USER) or bf(LOGNAME)) The USER or LOGNAME environment variables
-are used to determine the default username sent to an rsync server.
+are used to determine the default username sent to an rsync daemon.
 If neither is set, the username defaults to "nobody".
 dit(bf(HOME)) The HOME environment variable is used to find the user's
 default .cvsignore file.
 enddit()
 
 manpagefiles()
@@ -2024,12 +2075,16 @@
 
 see also the comments on the bf(--delete) option
 
 Please report bugs! See the website at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
+manpagesection(VERSION)
+
+This man page is current for version 2.6.5 of rsync.
+
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
 A WEB site is available at
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/sender.c	2005-03-29 01:29:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/sender.c	2005-05-19 16:52:24.000000000 +0800
@@ -17,26 +17,29 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int dry_run;
+extern int do_xfers;
 extern int am_server;
 extern int am_daemon;
 extern int log_before_transfer;
 extern int log_format_has_i;
 extern int daemon_log_format_has_i;
 extern int csum_length;
 extern int io_error;
+extern int allowed_lull;
 extern int protocol_version;
 extern int remove_sent_files;
 extern int updating_basis_file;
 extern int make_backups;
 extern int do_progress;
 extern int inplace;
+extern int batch_fd;
+extern int write_batch;
 extern struct stats stats;
 extern struct file_list *the_file_list;
 extern char *log_format;
 
 
 /**
@@ -51,12 +54,13 @@
  * Receive the checksums for a buffer
  **/
 static struct sum_struct *receive_sums(int f)
 {
 	struct sum_struct *s;
 	int32 i;
+	int lull_mod = allowed_lull * 5;
 	OFF_T offset = 0;
 
 	if (!(s = new(struct sum_struct)))
 		out_of_memory("receive_sums");
 
 	read_sum_head(f, s);
@@ -84,12 +88,15 @@
 		if (i == s->count-1 && s->remainder != 0)
 			s->sums[i].len = s->remainder;
 		else
 			s->sums[i].len = s->blength;
 		offset += s->sums[i].len;
 
+		if (allowed_lull && !(i % lull_mod))
+			maybe_send_keepalive();
+
 		if (verbose > 3) {
 			rprintf(FINFO,
 				"chunk[%d] len=%d offset=%.0f sum1=%08x\n",
 				i, s->sums[i].len, (double)s->sums[i].offset,
 				s->sums[i].sum1);
 		}
@@ -170,16 +177,12 @@
 	} else {
 		*buf = '\0';
 		len = -1;
 	}
 	*len_ptr = len;
 
-	/* Temporary handling of 2.6.4pre3 */
-	if (iflags & ITEM_DUMMY_BIT && iflags & (ITEM_LOCAL_CHANGE|ITEM_TRANSFER))
-		iflags &= ~ITEM_DUMMY_BIT;
-
 	if (iflags & ITEM_TRANSFER) {
 		if (!S_ISREG(the_file_list->files[ndx]->mode)) {
 			rprintf(FERROR,
 				"received request to transfer non-regular file: %d [%s]\n",
 				ndx, who_am_i());
 			exit_cleanup(RERR_PROTOCOL);
@@ -205,12 +208,13 @@
 	struct file_struct *file;
 	int phase = 0, max_phase = protocol_version >= 29 ? 2 : 1;
 	struct stats initial_stats;
 	int save_make_backups = make_backups;
 	int itemizing = am_daemon ? daemon_log_format_has_i
 		      : !am_server && log_format_has_i;
+	int f_xfer = write_batch < 0 ? batch_fd : f_out;
 	int i, j;
 
 	if (verbose > 2)
 		rprintf(FINFO, "send_files starting\n");
 
 	while (1) {
@@ -263,13 +267,13 @@
 			? fnamecmp_type == FNAMECMP_FNAME : !make_backups);
 
 		stats.current_file_index = i;
 		stats.num_transferred_files++;
 		stats.total_transferred_size += file->length;
 
-		if (dry_run) { /* log the transfer */
+		if (!do_xfers) { /* log the transfer */
 			if (!am_server && log_format)
 				log_item(file, &stats, iflags, NULL);
 			write_ndx_and_attrs(f_out, i, iflags, fnamecmp_type,
 					    xname, xlen);
 			continue;
 		}
@@ -320,13 +324,13 @@
 			rprintf(FINFO, "send_files mapped %s of size %.0f\n",
 				safe_fname(fname), (double)st.st_size);
 		}
 
 		write_ndx_and_attrs(f_out, i, iflags, fnamecmp_type,
 				    xname, xlen);
-		write_sum_head(f_out, s);
+		write_sum_head(f_xfer, s);
 
 		if (verbose > 2) {
 			rprintf(FINFO, "calling match_sums %s\n",
 				safe_fname(fname));
 		}
 
@@ -334,13 +338,13 @@
 			log_item(file, &initial_stats, iflags, NULL);
 		else if (!am_server && verbose && do_progress)
 			rprintf(FINFO, "%s\n", safe_fname(fname2));
 
 		set_compression(fname);
 
-		match_sums(f_out, s, mbuf, st.st_size);
+		match_sums(f_xfer, s, mbuf, st.st_size);
 		if (do_progress)
 			end_progress(st.st_size);
 
 		if (!log_before_transfer)
 			log_item(file, &initial_stats, iflags, NULL);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/socket.c	2005-03-01 11:39:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/socket.c	2005-04-15 00:08:12.000000000 +0800
@@ -124,24 +124,24 @@
 
 /**
  * Try to set the local address for a newly-created socket.  Return -1
  * if this fails.
  **/
 int try_bind_local(int s, int ai_family, int ai_socktype,
-		   const char *bind_address)
+		   const char *bind_addr)
 {
 	int error;
 	struct addrinfo bhints, *bres_all, *r;
 
 	memset(&bhints, 0, sizeof bhints);
 	bhints.ai_family = ai_family;
 	bhints.ai_socktype = ai_socktype;
 	bhints.ai_flags = AI_PASSIVE;
-	if ((error = getaddrinfo(bind_address, NULL, &bhints, &bres_all))) {
+	if ((error = getaddrinfo(bind_addr, NULL, &bhints, &bres_all))) {
 		rprintf(FERROR, RSYNC_NAME ": getaddrinfo %s: %s\n",
-			bind_address, gai_strerror(error));
+			bind_addr, gai_strerror(error));
 		return -1;
 	}
 
 	for (r = bres_all; r; r = r->ai_next) {
 		if (bind(s, r->ai_addr, r->ai_addrlen) == -1)
 			continue;
@@ -169,18 +169,18 @@
  * try to open a connection.
  *
  * The loop allows for machines with some addresses which may not be
  * reachable, perhaps because we can't e.g. route ipv6 to that network
  * but we can get ip4 packets through.
  *
- * @param bind_address Local address to use.  Normally NULL to bind
+ * @param bind_addr Local address to use.  Normally NULL to bind
  * the wildcard address.
  *
  * @param af_hint Address family, e.g. AF_INET or AF_INET6.
  **/
-int open_socket_out(char *host, int port, const char *bind_address,
+int open_socket_out(char *host, int port, const char *bind_addr,
 		    int af_hint)
 {
 	int type = SOCK_STREAM;
 	int error, s;
 	struct addrinfo hints, *res0, *res;
 	char portbuf[10];
@@ -250,15 +250,15 @@
 	 * address record tells us what protocol to use to try to connect. */
 	for (res = res0; res; res = res->ai_next) {
 		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
 		if (s < 0)
 			continue;
 
-		if (bind_address
+		if (bind_addr
 		 && try_bind_local(s, res->ai_family, type,
-				   bind_address) == -1) {
+				   bind_addr) == -1) {
 			close(s);
 			s = -1;
 			continue;
 		}
 		if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
 			close(s);
@@ -290,27 +290,27 @@
  *
  * We use this primarily in testing to detect TCP flow bugs, but not
  * cause security problems by really opening remote connections.
  *
  * This is based on the Samba LIBSMB_PROG feature.
  *
- * @param bind_address Local address to use.  Normally NULL to get the stack default.
+ * @param bind_addr Local address to use.  Normally NULL to get the stack default.
  **/
-int open_socket_out_wrapped(char *host, int port, const char *bind_address,
+int open_socket_out_wrapped(char *host, int port, const char *bind_addr,
 			    int af_hint)
 {
 	char *prog = getenv("RSYNC_CONNECT_PROG");
 
 	if (verbose >= 2) {
 		rprintf(FINFO, "%sopening tcp connection to %s port %d\n",
 			prog ? "Using RSYNC_CONNECT_PROG instead of " : "",
 			host, port);
 	}
 	if (prog)
 		return sock_exec(prog);
-	return open_socket_out(host, port, bind_address, af_hint);
+	return open_socket_out(host, port, bind_addr, af_hint);
 }
 
 
 
 /**
  * Open one or more sockets for incoming data using the specified type,
@@ -319,16 +319,16 @@
  * The getaddrinfo() call may return several address results, e.g. for
  * the machine's IPv4 and IPv6 name.
  *
  * We return an array of file-descriptors to the sockets, with a trailing
  * -1 value to indicate the end of the list.
  *
- * @param bind_address Local address to bind, or NULL to allow it to
+ * @param bind_addr Local address to bind, or NULL to allow it to
  * default.
  **/
-static int *open_socket_in(int type, int port, const char *bind_address,
+static int *open_socket_in(int type, int port, const char *bind_addr,
 			   int af_hint)
 {
 	int one = 1;
 	int s, *socks, maxs, i;
 	struct addrinfo hints, *all_ai, *resp;
 	char portbuf[10];
@@ -336,16 +336,16 @@
 
 	memset(&hints, 0, sizeof hints);
 	hints.ai_family = af_hint;
 	hints.ai_socktype = type;
 	hints.ai_flags = AI_PASSIVE;
 	snprintf(portbuf, sizeof portbuf, "%d", port);
-	error = getaddrinfo(bind_address, portbuf, &hints, &all_ai);
+	error = getaddrinfo(bind_addr, portbuf, &hints, &all_ai);
 	if (error) {
 		rprintf(FERROR, RSYNC_NAME ": getaddrinfo: bind address %s: %s\n",
-			bind_address, gai_strerror(error));
+			bind_addr, gai_strerror(error));
 		return NULL;
 	}
 
 	/* Count max number of sockets we might open. */
 	for (maxs = 0, resp = all_ai; resp; resp = resp->ai_next, maxs++) {}
 
@@ -475,13 +475,13 @@
 		struct sockaddr_storage addr;
 		socklen_t addrlen = sizeof addr;
 
 		/* close log file before the potentially very long select so
 		 * file can be trimmed by another process instead of growing
 		 * forever */
-		log_close();
+		logfile_close();
 
 #ifdef FD_COPY
 		FD_COPY(&deffds, &fds);
 #else
 		fds = deffds;
 #endif
@@ -504,14 +504,14 @@
 
 		if ((pid = fork()) == 0) {
 			int ret;
 			for (i = 0; sp[i] >= 0; i++)
 				close(sp[i]);
 			/* Re-open log file in child before possibly giving
-			 * up privileges (see log_close() above). */
-			log_open();
+			 * up privileges (see logfile_close() above). */
+			logfile_reopen();
 			ret = fn(fd, fd);
 			close_all();
 			_exit(ret);
 		} else if (pid < 0) {
 			rsyserr(FERROR, errno,
 				"could not create child server process");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/support/atomic-rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/support/atomic-rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/support/atomic-rsync	2005-01-15 03:23:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/support/atomic-rsync	2005-05-27 02:00:09.000000000 +0800
@@ -1,12 +1,12 @@
 #!/usr/bin/perl
 #
 # This script lets you update a hierarchy of files in an atomic way by
-# first creating a new hierarchy using --link-dest to rsync, and then
-# swapping the hierarchy into place.  See the usage message for more
-# details and some important caveats!
+# first creating a new hierarchy using rsync's --link-dest option, and
+# then swapping the hierarchy into place.  **See the usage message for
+# more details and some important caveats!**
 
 use strict;
 use Cwd 'abs_path';
 
 my $RSYNC_PROG = '/usr/bin/rsync';
 my $RM_PROG = '/bin/rm';
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/support: cvs2includes
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/support/mnt-excl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/support/mnt-excl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/support/mnt-excl	2005-02-23 05:24:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/support/mnt-excl	2005-05-19 07:59:12.000000000 +0800
@@ -17,13 +17,13 @@
 # NOTE:  This script expects /proc/mounts to exist, but could be
 # easily adapted to read /etc/mtab or similar.
 #
 # ADDENDUM:  The addition of the --filter option (which has support for
 # absolute-anchored excludes) has made this script less useful than it
 # was.  Beginning with 2.6.4, you can achieve the effect of this script
-# though this command:
+# through this command:
 #
 # awk '{print $2}' /proc/mounts | rsync -f 'merge,/- -' host:/dir /dest/
 
 use strict;
 use Cwd 'abs_path';
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/support/rrsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/support/rrsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/support/rrsync	2005-02-20 09:04:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/support/rrsync	2005-04-25 00:19:16.000000000 +0800
@@ -28,14 +28,14 @@
 
 my $command = $ENV{SSH_ORIGINAL_COMMAND};
 die "Not invoked via sshd\n$Usage"	unless defined $command;
 die "SSH_ORIGINAL_COMMAND='$command' is not rsync\n" unless $command =~ /^rsync\s/;
 die "$0 -ro: sending to read-only server not allowed\n"
 	if $ro and $command !~ /^rsync --server --sender /;
-die "$0 -ro: use of --remove-sent-files with read-only server not allowed\n"
-	if $ro and $command =~ /\s--remove-sent-files/;
+die "$0 -ro: use of $1 with read-only server not allowed\n"
+	if $ro and $command =~ /\s(--remove-\S+)/;
 
 my ($cmd,$dir) = $command =~ /^(rsync\s+(?:-[-a-zA-Z]+\s+)+\.) ?("[^"]*"|[^\s"]*)$/;
 die "$0: invalid rsync-command syntax or options\n" if !defined $cmd;
 
 # Enforce default of $subdir instead of the normal $HOME default.
 my $orig = $dir;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/syscall.c	2005-02-14 08:58:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/syscall.c	2005-04-06 10:08:21.000000000 +0800
@@ -240,13 +240,13 @@
 	return fstat(fd, st);
 #endif
 }
 
 OFF_T do_lseek(int fd, OFF_T offset, int whence)
 {
-#if SIZEOF_OFF64_T
+#ifdef HAVE_LSEEK64
 	off64_t lseek64();
 	return lseek64(fd, offset, whence);
 #else
 	return lseek(fd, offset, whence);
 #endif
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/testsuite/backup.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/testsuite/backup.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/testsuite/backup.test	2004-09-21 03:50:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/testsuite/backup.test	2005-04-07 17:09:17.000000000 +0800
@@ -32,21 +32,26 @@
     grep "backed up $fn to $fn~" "$outfile" >/dev/null || test_fail "no backup message output for $fn"
     diff $diffopt "$fromdir/$fn" "$todir" || test_fail "copy of $fn failed"
     diff $diffopt "$chkdir/$fn" "$todir/$fn~" || test_fail "backup of $fn to $fn~ failed"
     mv "$todir/$fn~" "$todir/$fn"
 done
 
-checkit "$RSYNC -avv --no-whole-file --backup --backup-dir=\"$bakdir\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
+echo deleted-file >"$todir/dname"
+cp -p "$todir/dname" "$chkdir"
+
+checkit "$RSYNC -avv --no-whole-file --delete-after \
+    --backup --backup-dir=\"$bakdir\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
     | tee "$outfile"
 
 for fn in name1 name2; do
     grep "backed up $fn to .*/$fn$" "$outfile" >/dev/null || test_fail "no backup message output for $fn"
 done
 diff -r $diffopt "$chkdir" "$bakdir" || test_fail "backup dir contents are bogus"
+rm "$bakdir/dname"
 
-checkit "$RSYNC -avv \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
+checkit "$RSYNC -avv --del \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
 cat $srcdir/[efgr]*.[ch] > "$name1"
 cat $srcdir/[ew]*.[ch] > "$name2"
 
 checkit "$RSYNC -avv --inplace --no-whole-file --backup --backup-dir=\"$bakdir\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
     | tee "$outfile"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/testsuite/hands.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/testsuite/hands.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/testsuite/hands.test	2004-05-18 08:41:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/testsuite/hands.test	2005-04-24 02:17:25.000000000 +0800
@@ -17,13 +17,13 @@
 runtest "hard links" 'checkit "$RSYNC -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 rm "$todir/text"
 runtest "one file" 'checkit "$RSYNC -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 echo "extra line" >> "$todir/text"
-runtest "extra data" 'checkit "$RSYNC -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
+runtest "extra data" 'checkit "$RSYNC -avH --no-whole-file \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 cp "$fromdir/text" "$todir/ThisShouldGo"
 runtest " --delete" 'checkit "$RSYNC --delete -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/testsuite/hardlinks.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/testsuite/hardlinks.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/testsuite/hardlinks.test	2005-03-05 08:23:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/testsuite/hardlinks.test	2005-04-27 00:25:01.000000000 +0800
@@ -27,11 +27,37 @@
 name3="$fromdir/name3"
 name4="$fromdir/name4"
 echo "This is the file" > "$name1"
 ln "$name1" "$name2" || fail "Can't create hardlink"
 ln "$name2" "$name3" || fail "Can't create hardlink"
 cp "$name2" "$name4" || fail "Can't copy file"
+cat $srcdir/*.c >"$fromdir/text"
 
 checkit "$RSYNC -aHivv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
+echo "extra extra" >>"$todir/name1"
+
+checkit "$RSYNC -aHivv --no-whole-file \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+
+# Add a new link in a new subdirectory to test that we don't try to link
+# the files before the directory gets created.
+mkdir "$fromdir/subdir"
+ln "$name1" "$fromdir/subdir/new-file"
+rm "$todir/text"
+
+checkit "$RSYNC -aHivv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+
+# Do some duplicate copies using --link-dest and --copy-dest to test that
+# we hard-link all locally-inherited items.
+checkit "$RSYNC -aHivv --link-dest=\"$todir\" \"$fromdir/\" \"$chkdir/\"" "$todir" "$chkdir"
+
+rm -rf "$chkdir"
+checkit "$RSYNC -aHivv --copy-dest=\"$todir\" \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
+
+# Make sure there's nothing wrong with sending a single file with -H
+# enabled (this has broken twice so far, so we need this test).
+rm -rf "$todir"
+$RSYNC -aHivv "$name1" "$todir/"
+diff $diffopt "$name1" "$todir" || test_fail "solo copy of name1 failed"
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/testsuite: relative.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.4/util.c	2005-03-31 03:34:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.5/util.c	2005-05-04 00:44:47.000000000 +0800
@@ -874,33 +874,43 @@
 	if (curr_dir_len >= sizeof curr_dir)
 		curr_dir_len = sizeof curr_dir - 1;
 
 	return 1;
 }
 
-/* Return the filename, turning any non-printable characters into '?'s.
- * This ensures that outputting it on a line of its own cannot generate an
- * empty line.  This function can return only MAX_SAFE_NAMES values at a
- * time!  The returned value can be longer than MAXPATHLEN (because we
- * may be trying to output an error about a too-long filename)! */
+/* Return the filename, turning any non-printable characters into escaped
+ * characters (e.g. \n -> \012, \ -> \\).  This ensures that outputting it
+ * cannot generate an empty line nor corrupt the screen.  This function can
+ * return only MAX_SAFE_NAMES values at a time!  The returned value can be
+ * longer than MAXPATHLEN (because we may be trying to output an error about
+ * a too-long filename)! */
 char *safe_fname(const char *fname)
 {
 #define MAX_SAFE_NAMES 4
 	static char fbuf[MAX_SAFE_NAMES][MAXPATHLEN*2];
 	static int ndx = 0;
 	int limit = sizeof fbuf / MAX_SAFE_NAMES - 1;
 	char *t;
 
 	ndx = (ndx + 1) % MAX_SAFE_NAMES;
 	for (t = fbuf[ndx]; *fname; fname++) {
-		if (!isprint(*(uchar*)fname))
-			*t++ = '?';
-		else
+		if (*fname == '\\') {
+			if ((limit -= 2) < 0)
+				break;
+			*t++ = '\\';
+			*t++ = '\\';
+		} else if (!isprint(*(uchar*)fname)) {
+			if ((limit -= 4) < 0)
+				break;
+			sprintf(t, "\\%03o", *(uchar*)fname);
+			t += 4;
+		} else {
+			if (--limit < 0)
+				break;
 			*t++ = *fname;
-		if (--limit == 0)
-			break;
+		}
 	}
 	*t = '\0';
 
 	return fbuf[ndx];
 }
 
