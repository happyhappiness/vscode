Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2: backup.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/checksum.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/checksum.c	1999-11-08 21:14:59.000000000 +0800
@@ -88,15 +88,15 @@
 	struct map_struct *buf;
 	int fd;
 	OFF_T len = size;
 	char tmpchunk[CSUM_CHUNK];
 	struct mdfour m;
 	
-	memset(sum,0,csum_length);
+	memset(sum,0,MD4_SUM_LENGTH);
 	
-	fd = open(fname,O_RDONLY);
+	fd = do_open(fname, O_RDONLY, 0);
 	if (fd == -1) return;
 	
 	buf = map_file(fd,size);
 	
 	mdfour_begin(&m);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/clientserver.c	1999-04-06 23:04:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/clientserver.c	1999-11-08 21:14:59.000000000 +0800
@@ -22,12 +22,13 @@
 
 extern int module_id;
 extern int read_only;
 extern int verbose;
 extern int rsync_port;
 char *auth_user;
+int sanitize_paths = 0;
 
 int start_socket_client(char *host, char *path, int argc, char *argv[])
 {
 	int fd, i;
 	char *sargs[MAX_ARGS];
 	int sargc=0;
@@ -218,12 +219,13 @@
 	} else {
 		if (!push_dir(lp_path(i), 0)) {
 			rprintf(FERROR,"chdir %s failed\n", lp_path(i));
 			io_printf(fd,"@ERROR: chdir failed\n");
 			return -1;
 		}
+		sanitize_paths = 1;
 	}
 
 	if (am_root) {
 		if (setgid(gid)) {
 			rprintf(FERROR,"setgid %d failed\n", gid);
 			io_printf(fd,"@ERROR: setgid failed\n");
@@ -259,13 +261,13 @@
 
 		if (start_glob) {
 			if (start_glob == 1) {
 				request = strdup(p);
 				start_glob++;
 			}
-			glob_expand(name, argv, &argc, MAX_ARGS, !use_chroot);
+			glob_expand(name, argv, &argc, MAX_ARGS);
 		} else {
 			argc++;
 		}
 
 		if (strcmp(line,".") == 0) {
 			start_glob = 1;
@@ -273,22 +275,22 @@
 
 		if (argc == MAX_ARGS) {
 			return -1;
 		}
 	}
 
-	if (!use_chroot) {
+	if (sanitize_paths) {
 		/*
 		 * Note that this is applied to all parameters, whether or not
 		 *    they are filenames, but no other legal parameters contain
 		 *    the forms that need to be sanitized so it doesn't hurt;
 		 *    it is not known at this point which parameters are files
 		 *    and which aren't.
 		 */
 		for (i = 1; i < argc; i++) {
-			sanitize_path(argv[i]);
+			sanitize_path(argv[i], NULL);
 		}
 	}
 
 	ret = parse_arguments(argc, argv, 0);
 
 	if (request) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/compat.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/compat.c	1999-11-08 21:14:59.000000000 +0800
@@ -20,14 +20,12 @@
 /* compatability routines for older rsync protocol versions */
 
 #include "rsync.h"
 
 extern int am_server;
 
-extern int csum_length;
-
 extern int preserve_links;
 extern int preserve_perms;
 extern int preserve_devices;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_times;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/config.h.in	1999-03-16 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/config.h.in	1999-11-08 21:14:59.000000000 +0800
@@ -90,12 +90,15 @@
 /* Define if you have the getcwd function.  */
 #undef HAVE_GETCWD
 
 /* Define if you have the glob function.  */
 #undef HAVE_GLOB
 
+/* Define if you have the inet_aton function.  */
+#undef HAVE_INET_ATON
+
 /* Define if you have the lchown function.  */
 #undef HAVE_LCHOWN
 
 /* Define if you have the link function.  */
 #undef HAVE_LINK
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/configure	1999-03-16 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/configure	1999-11-08 21:15:00.000000000 +0800
@@ -2396,13 +2396,13 @@
  
 else
   echo "$ac_t""no" 1>&6
 fi
 done
 
-for ac_func in strlcat strlcpy
+for ac_func in strlcat strlcpy inet_aton
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
 echo "configure:2406: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2465,15 +2465,16 @@
   rsync_cv_HAVE_FNMATCH=cross
 else
   cat > conftest.$ac_ext <<EOF
 #line 2469 "configure"
 #include "confdefs.h"
 #include <fnmatch.h>
-main() { exit(fnmatch("*.o", "x.o", FNM_PATHNAME) == 0? 0: 1); }
+main() { exit((fnmatch("*.o", "x.o", FNM_PATHNAME) == 0 &&
+               fnmatch("a/b/*", "a/b/c/d", FNM_PATHNAME) != 0) ? 0: 1); }
 EOF
-if { (eval echo configure:2474: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2475: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_FNMATCH=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2492,33 +2493,33 @@
 
 fi
 
 # sometimes getopt_long cannot parse same arguments twice
 # e.g. on certain versions of CygWin32
 echo $ac_n "checking for working getopt_long""... $ac_c" 1>&6
-echo "configure:2499: checking for working getopt_long" >&5
+echo "configure:2500: checking for working getopt_long" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_GETOPT_LONG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_GETOPT_LONG=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2508 "configure"
+#line 2509 "configure"
 #include "confdefs.h"
 #include <getopt.h>
 main() {
     int i, x = 0; char *argv[] = { "x", "--xx" };
     struct option o[] = {{"xx", 0, 0, 1}, {0,0,0,0}};
     getopt_long(2, argv, "x", o, &i) == 1 ? x++ : 0; optind = 0;
     getopt_long(2, argv, "x", o, &i) == 1 ? x++ : 0;
     exit(x == 2 ? 0 : 1);
 }
 EOF
-if { (eval echo configure:2519: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2520: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_GETOPT_LONG=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2535,27 +2536,27 @@
 #define HAVE_GETOPT_LONG 1
 EOF
 
 fi
 
 echo $ac_n "checking for long long""... $ac_c" 1>&6
-echo "configure:2542: checking for long long" >&5
+echo "configure:2543: checking for long long" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_LONGLONG'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_LONGLONG=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2551 "configure"
+#line 2552 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main() { long long x = 1000000; x *= x; exit(((x/1000000) == 1000000)? 0: 1); }
 EOF
-if { (eval echo configure:2556: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2557: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_LONGLONG=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2572,28 +2573,28 @@
 #define HAVE_LONGLONG 1
 EOF
 
 fi
 
 echo $ac_n "checking for off64_t""... $ac_c" 1>&6
-echo "configure:2579: checking for off64_t" >&5
+echo "configure:2580: checking for off64_t" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_OFF64_T'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_OFF64_T=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2588 "configure"
+#line 2589 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #include <sys/stat.h>
 main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) exit(1); exit((lstat64("/dev/null", &st)==0)?0:1); }
 EOF
-if { (eval echo configure:2594: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2595: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_OFF64_T=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2610,29 +2611,29 @@
 #define HAVE_OFF64_T 1
 EOF
 
 fi
 
 echo $ac_n "checking for short ino_t""... $ac_c" 1>&6
-echo "configure:2617: checking for short ino_t" >&5
+echo "configure:2618: checking for short ino_t" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_SHORT_INO_T'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_SHORT_INO_T=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2626 "configure"
+#line 2627 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 main() { if (sizeof(ino_t) < sizeof(unsigned int)) return 0; return 1; }
 EOF
-if { (eval echo configure:2633: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2634: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_SHORT_INO_T=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2649,27 +2650,27 @@
 #define HAVE_SHORT_INO_T 1
 EOF
 
 fi
 
 echo $ac_n "checking for unsigned char""... $ac_c" 1>&6
-echo "configure:2656: checking for unsigned char" >&5
+echo "configure:2657: checking for unsigned char" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_UNSIGNED_CHAR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_UNSIGNED_CHAR=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2665 "configure"
+#line 2666 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main() { char c; c=250; exit((c > 0)?0:1); }
 EOF
-if { (eval echo configure:2670: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2671: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_UNSIGNED_CHAR=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2686,30 +2687,30 @@
 #define HAVE_UNSIGNED_CHAR 1
 EOF
 
 fi
 
 echo $ac_n "checking for broken readdir""... $ac_c" 1>&6
-echo "configure:2693: checking for broken readdir" >&5
+echo "configure:2694: checking for broken readdir" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_BROKEN_READDIR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_BROKEN_READDIR=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2702 "configure"
+#line 2703 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <dirent.h>
 main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
 if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
 di->d_name[0] == 0) exit(0); exit(1);} 
 EOF
-if { (eval echo configure:2710: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2711: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_BROKEN_READDIR=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2726,27 +2727,27 @@
 #define HAVE_BROKEN_READDIR 1
 EOF
 
 fi
 
 echo $ac_n "checking for utimbuf""... $ac_c" 1>&6
-echo "configure:2733: checking for utimbuf" >&5
+echo "configure:2734: checking for utimbuf" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_UTIMBUF'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 cat > conftest.$ac_ext <<EOF
-#line 2739 "configure"
+#line 2740 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <utime.h>
 int main() {
 struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));
 ; return 0; }
 EOF
-if { (eval echo configure:2747: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2748: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   rsync_cv_HAVE_UTIMBUF=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2761,34 +2762,34 @@
 #define HAVE_UTIMBUF 1
 EOF
 
 fi
 
 echo $ac_n "checking for broken inet_ntoa""... $ac_c" 1>&6
-echo "configure:2768: checking for broken inet_ntoa" >&5
+echo "configure:2769: checking for broken inet_ntoa" >&5
 if eval "test \"`echo '$''{'rsync_cv_REPLACE_INET_NTOA'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_REPLACE_INET_NTOA=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2777 "configure"
+#line 2778 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 main() { struct in_addr ip; ip.s_addr = 0x12345678;
 if (strcmp(inet_ntoa(ip),"18.52.86.120") &&
     strcmp(inet_ntoa(ip),"120.86.52.18")) { exit(0); } 
 exit(1);}
 EOF
-if { (eval echo configure:2789: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2790: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_REPLACE_INET_NTOA=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2813,18 +2814,18 @@
 # libsocket.so which has a bad implementation of gethostbyname (it
 # only looks in /etc/hosts), so we only look for -lsocket if we need
 # it.
 for ac_func in connect
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:2820: checking for $ac_func" >&5
+echo "configure:2821: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2825 "configure"
+#line 2826 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2841,13 +2842,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2848: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2849: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2869,32 +2870,32 @@
 done
 
 if test x"$ac_cv_func_connect" = x"no"; then
     case "$LIBS" in
     *-lnsl*) ;;
     *) echo $ac_n "checking for printf in -lnsl_s""... $ac_c" 1>&6
-echo "configure:2876: checking for printf in -lnsl_s" >&5
+echo "configure:2877: checking for printf in -lnsl_s" >&5
 ac_lib_var=`echo nsl_s'_'printf | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl_s  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2884 "configure"
+#line 2885 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char printf();
 
 int main() {
 printf()
 ; return 0; }
 EOF
-if { (eval echo configure:2895: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2896: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2919,32 +2920,32 @@
 fi
  ;;
     esac
     case "$LIBS" in
     *-lnsl*) ;;
     *) echo $ac_n "checking for printf in -lnsl""... $ac_c" 1>&6
-echo "configure:2926: checking for printf in -lnsl" >&5
+echo "configure:2927: checking for printf in -lnsl" >&5
 ac_lib_var=`echo nsl'_'printf | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2934 "configure"
+#line 2935 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char printf();
 
 int main() {
 printf()
 ; return 0; }
 EOF
-if { (eval echo configure:2945: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2946: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2969,32 +2970,32 @@
 fi
  ;;
     esac
     case "$LIBS" in
     *-lsocket*) ;;
     *) echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
-echo "configure:2976: checking for connect in -lsocket" >&5
+echo "configure:2977: checking for connect in -lsocket" >&5
 ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2984 "configure"
+#line 2985 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char connect();
 
 int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:2995: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2996: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3019,32 +3020,32 @@
 fi
  ;;
     esac
     case "$LIBS" in
     *-linet*) ;;
     *) echo $ac_n "checking for connect in -linet""... $ac_c" 1>&6
-echo "configure:3026: checking for connect in -linet" >&5
+echo "configure:3027: checking for connect in -linet" >&5
 ac_lib_var=`echo inet'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-linet  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3034 "configure"
+#line 3035 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char connect();
 
 int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:3045: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3046: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3083,18 +3084,18 @@
 # 
 # if we can't find strcasecmp, look in -lresolv (for Unixware at least)
 #
 for ac_func in strcasecmp
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3090: checking for $ac_func" >&5
+echo "configure:3091: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3095 "configure"
+#line 3096 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3111,13 +3112,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3118: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3119: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3137,32 +3138,32 @@
   echo "$ac_t""no" 1>&6
 fi
 done
 
 if test x"$ac_cv_func_strcasecmp" = x"no"; then
     echo $ac_n "checking for strcasecmp in -lresolv""... $ac_c" 1>&6
-echo "configure:3144: checking for strcasecmp in -lresolv" >&5
+echo "configure:3145: checking for strcasecmp in -lresolv" >&5
 ac_lib_var=`echo resolv'_'strcasecmp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3152 "configure"
+#line 3153 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char strcasecmp();
 
 int main() {
 strcasecmp()
 ; return 0; }
 EOF
-if { (eval echo configure:3163: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3164: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3189,13 +3190,13 @@
 fi
 
 #
 # The following test was mostly taken from the tcl/tk plus patches
 #
 echo $ac_n "checking whether -c -o works""... $ac_c" 1>&6
-echo "configure:3196: checking whether -c -o works" >&5
+echo "configure:3197: checking whether -c -o works" >&5
 if eval "test \"`echo '$''{'rsync_cv_DASHC_WORKS_WITH_DASHO'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 rm -rf conftest*
 cat > conftest.$ac_ext <<EOF
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/configure.in	1999-03-16 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/configure.in	1999-11-08 21:15:00.000000000 +0800
@@ -50,17 +50,18 @@
 
 AC_FUNC_MEMCMP
 AC_FUNC_UTIME_NULL
 AC_CHECK_FUNCS(waitpid wait4 getcwd strdup strerror chown chmod mknod)
 AC_CHECK_FUNCS(fchmod fstat strchr readlink link utime utimes strftime)
 AC_CHECK_FUNCS(memmove lchown vsnprintf snprintf setsid glob strpbrk)
-AC_CHECK_FUNCS(strlcat strlcpy)
+AC_CHECK_FUNCS(strlcat strlcpy inet_aton)
 
 AC_CACHE_CHECK([for working fnmatch],rsync_cv_HAVE_FNMATCH,[
 AC_TRY_RUN([#include <fnmatch.h>
-main() { exit(fnmatch("*.o", "x.o", FNM_PATHNAME) == 0? 0: 1); }],
+main() { exit((fnmatch("*.o", "x.o", FNM_PATHNAME) == 0 &&
+               fnmatch("a/b/*", "a/b/c/d", FNM_PATHNAME) != 0) ? 0: 1); }],
 rsync_cv_HAVE_FNMATCH=yes,rsync_cv_HAVE_FNMATCH=no,rsync_cv_HAVE_FNMATCH=cross)])
 if test x"$rsync_cv_HAVE_FNMATCH" = x"yes"; then
     AC_DEFINE(HAVE_FNMATCH)
 fi
 
 # sometimes getopt_long cannot parse same arguments twice
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/cvs.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/cvs.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/cvs.log	1999-04-06 23:09:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/cvs.log	1999-11-08 21:16:00.000000000 +0800
@@ -9468,6 +9468,479 @@
 
 Modified Files:
 	rsync.spec 
 Log Message:
 preparing for release of 2.3.1
 
+
+****************************************
+Date:	Tuesday April 13, 1999 @ 13:53
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16141
+
+Modified Files:
+	rsync.yo socket.c 
+Log Message:
+added RSYNC_PROXY support from Stephen Rothwell. This allows access to
+rsync servers via a web proxy (useful for getting through firewalls)
+
+
+
+
+****************************************
+Date:	Saturday June 26, 1999 @ 11:06
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv9372
+
+Modified Files:
+	checksum.c compat.c flist.c generator.c main.c rsync.h 
+Log Message:
+fixed a bug that made us use only 16 bits of the file checksum when
+comparing checksums for the --checksum (-c) option.
+
+
+
+****************************************
+Date:	Sunday June 27, 1999 @ 0:09
+Author:	tridge
+
+Update of /data/cvs/rproxy/librsync
+In directory samba:/tmp/cvs-serv26697/librsync
+
+Log Message:
+Directory /data/cvs/rproxy/librsync added to the repository
+
+
+
+****************************************
+Date:	Sunday June 27, 1999 @ 0:10
+Author:	tridge
+
+Update of /data/cvs/rproxy/librsync
+In directory samba:/tmp/cvs-serv28539
+
+Added Files:
+	Makefile base64.c base64.h byteorder.h checksum.c checksum.h 
+	fdbuffer.h funkyfd.c funkyfd.h funkyfd.p.h hash.c hash.h 
+	includes.h librsync-decode.c librsync-encode.c 
+	librsync-funcs.c librsync-signature.c librsync.h mdfour.c 
+	mdfour.h testlibrsync.c 
+Log Message:
+first version of librsync from pbarker
+
+
+
+
+****************************************
+Date:	Sunday June 27, 1999 @ 14:12
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv3839
+
+Modified Files:
+	socket.c 
+Log Message:
+continue calling waitpid() while still reapingchildren (patch from
+Matti Aarnio)
+
+
+
+
+
+
+****************************************
+Date:	Friday July 2, 1999 @ 23:58
+Author:	tridge
+
+Update of /data/cvs/rproxy/librsync
+In directory samba:/tmp/cvs-serv16494
+
+Modified Files:
+	base64.c checksum.c funkyfd.c hash.c includes.h 
+	librsync-decode.c librsync-encode.c librsync-funcs.c 
+	librsync-signature.c testlibrsync.c 
+Log Message:
+fixed up a bunch of compiler warnings
+
+
+
+****************************************
+Date:	Friday July 2, 1999 @ 23:59
+Author:	tridge
+
+Update of /data/cvs/rproxy/librsync
+In directory samba:/tmp/cvs-serv18757
+
+Added Files:
+	.cvsignore 
+Log Message:
+tell CVS to ignore the binaries
+
+
+
+
+****************************************
+Date:	Saturday July 10, 1999 @ 1:49
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv12740
+
+Modified Files:
+	clientserver.c flist.c proto.h util.c 
+Log Message:
+Fix significant security holes with "use chroot = no" in an rsync daemon:
+
+    1. The file paths being sent and received were not "sanitized" to
+	ensure that there weren't any ".." components that would escape the
+	top level directory.  This can't happen with the standard rsync
+	client, but it could be exploited on both read and write if someone
+	modified an rsync client.  This fix sanitizes all incoming and
+	outgoing paths when "use chroot = no".
+
+    2. If a module is also "read only = no", clients could have created
+	symbolic links with ".." components that would allow writing
+	outside of the module.  This could happen with the standard rsync
+	client.  This fix sanitizes all incoming symbolic link targets
+	when "use chroot = no".
+
+Previously, only top-level paths (anything passed in command line arguments)
+were sanitized.  Sorry, I didn't think about the individual file paths
+before now.
+
+
+
+****************************************
+Date:	Saturday July 10, 1999 @ 3:07
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv9144
+
+Modified Files:
+	util.c 
+Log Message:
+Add a couple clarifying points to the sanitize_path() comments.
+
+One is a note that a leading "/" in a symlink target will not behave
+exactly as if a chroot had occurred, but I decided it wasn't worth the
+making it the same.
+
+The other is note about an extra harmless trailing "." that is added under
+some rare circumstances.
+
+
+
+****************************************
+Date:	Monday August 30, 1999 @ 18:19
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv3435
+
+Modified Files:
+	Makefile.in proto.h rsync.c 
+Added Files:
+	backup.c 
+Log Message:
+separated out the make_backup code in preparation for some patches
+from Bob Edwards
+
+
+
+****************************************
+Date:	Monday September 6, 1999 @ 12:04
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4716
+
+Modified Files:
+	rsync.1 rsync.yo 
+Log Message:
+added a note about using -v with --progress
+
+
+
+****************************************
+Date:	Wednesday October 20, 1999 @ 3:50
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21269
+
+Modified Files:
+	rsyncd.conf.yo 
+Log Message:
+Minor change suggesting people put in the right path in inetd.conf.
+Suggested by Roger Price <rprice@cs.uml.edu>
+
+
+
+****************************************
+Date:	Tuesday October 26, 1999 @ 8:04
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv25280
+
+Modified Files:
+	checksum.c generator.c receiver.c sender.c util.c 
+Log Message:
+use do_open() instead of open() in several places to help the WinXX port
+and O_BINARY
+
+
+
+****************************************
+Date:	Wednesday October 27, 1999 @ 23:17
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv10776
+
+Modified Files:
+	configure configure.in 
+Log Message:
+updated the configure test for fnmatch() to see if FNM_PATHNAME is
+working correctly.
+
+
+
+****************************************
+Date:	Sunday October 31, 1999 @ 13:19
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv22413
+
+Modified Files:
+	flist.c loadparm.c receiver.c rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+added "ignore errors" option in rsyncd.conf
+
+
+
+****************************************
+Date:	Sunday October 31, 1999 @ 13:37
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv22943
+
+Modified Files:
+	rsync.1 rsync.yo 
+Log Message:
+updated rsync-path man page entry
+
+
+
+
+****************************************
+Date:	Sunday October 31, 1999 @ 13:39
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv3363
+
+Modified Files:
+	test.sh 
+Log Message:
+updated test suite from Phil.
+
+
+
+
+
+****************************************
+Date:	Sunday October 31, 1999 @ 13:47
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21513
+
+Modified Files:
+	options.c rsync.1 rsync.yo 
+Log Message:
+added -P option
+
+it is equivalent to --partial --progress
+
+
+
+
+
+
+****************************************
+Date:	Sunday October 31, 1999 @ 14:21
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv618
+
+Modified Files:
+	options.c proto.h rsync.1 rsync.yo socket.c 
+Log Message:
+added --address option for virtual hosting
+
+
+
+
+
+
+****************************************
+Date:	Sunday October 31, 1999 @ 15:28
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv28278
+
+Modified Files:
+	generator.c receiver.c 
+Log Message:
+solved the problem of not using the right permissions when
+preserve_perms is off.
+
+
+
+
+
+
+
+****************************************
+Date:	Tuesday November 2, 1999 @ 8:25
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv24675/lib
+
+Modified Files:
+	fnmatch.h 
+Log Message:
+forgot to commit the fnmatch.h changes
+
+
+****************************************
+Date:	Tuesday November 2, 1999 @ 8:35
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv5447
+
+Modified Files:
+	config.h.in configure configure.in 
+Log Message:
+added a replacement inet_aton() for systems that don't have it.
+
+thanks to Dave for pointing this out.
+
+
+
+****************************************
+Date:	Tuesday November 2, 1999 @ 8:35
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv10102
+
+Modified Files:
+	compat.c 
+Log Message:
+added a replacement inet_aton() for systems that don't have it.
+
+thanks to Dave for pointing this out.
+
+
+
+****************************************
+Date:	Friday November 5, 1999 @ 2:43
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4001
+
+Modified Files:
+	syscall.c 
+Log Message:
+Fixed bug introduced by calling do_open() for O_RDONLY files.  Changed it
+so the check for dry_run and CHECK_RO are not done when flags is O_RDONLY.
+Only do the adding of O_BINARY, which was the intention.
+
+
+
+****************************************
+Date:	Monday November 8, 1999 @ 20:12
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8583
+
+Modified Files:
+	exclude.c rsync.1 rsync.yo 
+Log Message:
+fixed passing of directory exclude options to remote side (thanks to
+andrewdagger@xerox.gbr.com)
+
+added note about multiple excludes per exclude option
+
+
+
+****************************************
+Date:	Monday November 8, 1999 @ 21:47
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv14587
+
+Modified Files:
+	rsync.c 
+Log Message:
+removed ACCESSPERMS mask when transferring a file without perms
+copy. This makes us match GNU cp more closely.
+
+
+
+
+****************************************
+Date:	Tuesday November 9, 1999 @ 0:03
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20647
+
+Modified Files:
+	options.c receiver.c rsync.1 rsync.yo 
+Log Message:
+added --delete-after option (suggested by Jason)
+
+
+
+****************************************
+Date:	Tuesday November 9, 1999 @ 0:15
+Author:	rsync-bu
+
+Update of /data/cvs/rsync
+In directory samba:/data/people/rsync-bugs/rsync
+
+Modified Files:
+	version.h 
+Log Message:
+preparing for release of 2.3.2
+
+
+****************************************
+Date:	Tuesday November 9, 1999 @ 0:15
+Author:	rsync-bu
+
+Update of /data/cvs/rsync/packaging/redhat/5.0
+In directory samba:/data/people/rsync-bugs/rsync/packaging/redhat/5.0
+
+Modified Files:
+	rsync.spec 
+Log Message:
+preparing for release of 2.3.2
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/exclude.c	1999-03-16 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/exclude.c	1999-11-08 21:15:00.000000000 +0800
@@ -267,14 +267,17 @@
 	if (!exclude_list) {
 		write_int(f,0);
 		return;
 	}
 
 	for (i=0;exclude_list[i];i++) {
-		char *pattern = exclude_list[i]->pattern; 
 		int l;
+		char pattern[MAXPATHLEN];
+
+		strlcpy(pattern,exclude_list[i]->pattern,sizeof(pattern)); 
+		if (exclude_list[i]->directory) strlcat(pattern,"/", sizeof(pattern));
 
 		l = strlen(pattern);
 		if (l == 0) continue;
 		if (exclude_list[i]->include) {
 			if (remote_version < 19) {
 				rprintf(FERROR,"remote rsync does not support include syntax - aborting\n");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/flist.c	1999-03-16 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/flist.c	1999-11-08 21:15:00.000000000 +0800
@@ -20,14 +20,12 @@
 /* generate and receive file lists */
 
 #include "rsync.h"
 
 extern struct stats stats;
 
-extern int csum_length;
-
 extern int verbose;
 extern int am_server;
 extern int always_checksum;
 
 extern int cvs_exclude;
 
@@ -44,12 +42,13 @@
 extern int preserve_times;
 extern int relative_paths;
 extern int copy_links;
 extern int copy_unsafe_links;
 extern int remote_version;
 extern int io_error;
+extern int sanitize_paths;
 
 static char topsrcname[MAXPATHLEN];
 
 static struct exclude_struct **local_exclude_list;
 
 static void clean_flist(struct file_list *flist, int strip_root);
@@ -251,13 +250,17 @@
 		write_int(f,(int)file->dev);
 		write_int(f,(int)file->inode);
 	}
 #endif
 
 	if (always_checksum) {
-		write_buf(f,file->sum,csum_length);
+		if (remote_version < 21) {
+			write_buf(f,file->sum,2);
+		} else {
+			write_buf(f,file->sum,MD4_SUM_LENGTH);
+		}
 	}       
 
 	last_mode = file->mode;
 	last_rdev = file->rdev;
 	last_uid = file->uid;
 	last_gid = file->gid;
@@ -304,12 +307,16 @@
 
 	strlcpy(lastname,thisname,MAXPATHLEN);
 	lastname[MAXPATHLEN-1] = 0;
 
 	clean_fname(thisname);
 
+	if (sanitize_paths) {
+		sanitize_path(thisname, NULL);
+	}
+
 	if ((p = strrchr(thisname,'/'))) {
 		static char *lastdir;
 		*p = 0;
 		if (lastdir && strcmp(thisname, lastdir)==0) {
 			file->dirname = lastdir;
 		} else {
@@ -338,25 +345,32 @@
 
 	if (preserve_links && S_ISLNK(file->mode)) {
 		int l = read_int(f);
 		file->link = (char *)malloc(l+1);
 		if (!file->link) out_of_memory("receive_file_entry 2");
 		read_sbuf(f,file->link,l);
+		if (sanitize_paths) {
+			sanitize_path(file->link, file->dirname);
+		}
 	}
 
 #if SUPPORT_HARD_LINKS
 	if (preserve_hard_links && S_ISREG(file->mode)) {
 		file->dev = read_int(f);
 		file->inode = read_int(f);
 	}
 #endif
   
 	if (always_checksum) {
 		file->sum = (char *)malloc(MD4_SUM_LENGTH);
 		if (!file->sum) out_of_memory("md4 sum");
-		read_buf(f,file->sum,csum_length);
+		if (remote_version < 21) {
+			read_buf(f,file->sum,2);
+		} else {
+			read_buf(f,file->sum,MD4_SUM_LENGTH);
+		}
 	}
   
 	last_mode = file->mode;
 	last_rdev = file->rdev;
 	last_uid = file->uid;
 	last_gid = file->gid;
@@ -405,12 +419,15 @@
 	char linkbuf[MAXPATHLEN];
 	extern int delete_excluded;
 
 	strlcpy(cleaned_name, fname, MAXPATHLEN);
 	cleaned_name[MAXPATHLEN-1] = 0;
 	clean_fname(cleaned_name);
+	if (sanitize_paths) {
+		sanitize_path(cleaned_name, NULL);
+	}
 	fname = cleaned_name;
 
 	memset(sum,0,SUM_LENGTH);
 
 	if (readlink_stat(fname,&st,linkbuf) != 0) {
 		io_error = 1;
@@ -749,13 +766,14 @@
 	if (f != -1 && remote_version >= 15) {
 		send_uid_list(f);
 	}
 
 	/* if protocol version is >= 17 then send the io_error flag */
 	if (f != -1 && remote_version >= 17) {
-		write_int(f, io_error);
+		extern int module_id;
+		write_int(f, lp_ignore_errors(module_id)? 0 : io_error);
 	}
 
 	if (f != -1) {
 		io_end_buffering(f);
 		stats.flist_size = stats.total_written - start_write;
 		stats.num_files = flist->count;
@@ -834,13 +852,18 @@
   if (f != -1 && remote_version >= 15) {
 	  recv_uid_list(f, flist);
   }
 
   /* if protocol version is >= 17 then recv the io_error flag */
   if (f != -1 && remote_version >= 17) {
-	  io_error |= read_int(f);
+	  extern int module_id;
+	  if (lp_ignore_errors(module_id)) {
+		  read_int(f);
+	  } else {
+		  io_error |= read_int(f);
+	  }
   }
 
   if (list_only) {
 	  int i;
 	  for (i=0;i<flist->count;i++) {
 		  list_file_entry(flist->files[i]);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/generator.c	1999-04-06 23:04:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/generator.c	1999-11-08 21:15:01.000000000 +0800
@@ -47,13 +47,17 @@
 	
 	/* if always checksum is set then we use the checksum instead 
 	   of the file time to determine whether to sync */
 	if (always_checksum && S_ISREG(st->st_mode)) {
 		char sum[MD4_SUM_LENGTH];
 		file_checksum(fname,sum,st->st_size);
-		return (memcmp(sum,file->sum,csum_length) == 0);
+		if (remote_version < 21) {
+			return (memcmp(sum,file->sum,2) == 0);
+		} else {
+			return (memcmp(sum,file->sum,MD4_SUM_LENGTH) == 0);
+		}
 	}
 
 	if (size_only) {
 		return 1;
 	}
 
@@ -83,23 +87,25 @@
 /*
   send a sums struct down a fd
   */
 static void send_sums(struct sum_struct *s,int f_out)
 {
 	int i;
-
-  /* tell the other guy how many we are going to be doing and how many
-     bytes there are in the last chunk */
+	
+	/* tell the other guy how many we are going to be doing and how many
+	   bytes there are in the last chunk */
 	write_int(f_out,s?s->count:0);
 	write_int(f_out,s?s->n:block_size);
 	write_int(f_out,s?s->remainder:0);
-	if (s)
-		for (i=0;i<s->count;i++) {
-			write_int(f_out,s->sums[i].sum1);
-			write_buf(f_out,s->sums[i].sum2,csum_length);
-		}
+
+	if (!s) return;
+
+	for (i=0;i<s->count;i++) {
+		write_int(f_out,s->sums[i].sum1);
+		write_buf(f_out,s->sums[i].sum2,csum_length);
+	}
 }
 
 
 /*
   generate a stream of signatures/checksums that describe a buffer
 
@@ -168,20 +174,30 @@
 	int statret;
 	struct file_struct *file = flist->files[i];
 	char *fnamecmp;
 	char fnamecmpbuf[MAXPATHLEN];
 	extern char *compare_dest;
 	extern int list_only;
+	extern int preserve_perms;
 
 	if (list_only) return;
 
 	if (verbose > 2)
 		rprintf(FINFO,"recv_generator(%s,%d)\n",fname,i);
 
 	statret = link_stat(fname,&st);
 
+	if (statret == 0 && 
+	    !preserve_perms && 
+	    (S_ISDIR(st.st_mode) == S_ISDIR(file->mode))) {
+		/* if the file exists already and we aren't perserving
+                   presmissions then act as though the remote end sent
+                   us the file permissions we already have */
+		file->mode = st.st_mode;
+	}
+
 	if (S_ISDIR(file->mode)) {
 		if (dry_run) return;
 		if (statret == 0 && !S_ISDIR(st.st_mode)) {
 			if (robust_unlink(fname) != 0) {
 				rprintf(FERROR,"unlink %s : %s\n",fname,strerror(errno));
 				return;
@@ -331,13 +347,13 @@
 		write_int(f_out,i);
 		send_sums(NULL,f_out);    
 		return;
 	}
 
 	/* open the file */  
-	fd = open(fnamecmp,O_RDONLY);
+	fd = do_open(fnamecmp, O_RDONLY, 0);
 
 	if (fd == -1) {
 		rprintf(FERROR,"failed to open %s : %s\n",fnamecmp,strerror(errno));
 		rprintf(FERROR,"skipping %s\n",fname);
 		return;
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/lib/compat.c	1999-03-16 05:23:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/lib/compat.c	1999-11-08 21:15:04.000000000 +0800
@@ -142,6 +142,22 @@
 		memcpy(d+len1, s, len2);
 		d[len1+len2] = 0;
 	}
 	return ret;
 }
 #endif
+
+#ifndef HAVE_INET_ATON
+ int inet_aton(const char *cp, struct in_addr *inp)
+{
+	if (strcmp(cp, "255.255.255.255") == 0) {
+		inp->s_addr = (unsigned) -1;
+		return 1;
+	}
+
+	inp->s_addr = inet_addr(cp);
+	if (inp->s_addr == (unsigned) -1) {
+		return 0;
+	}
+	return 1;
+}
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/lib/fnmatch.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/lib/fnmatch.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/lib/fnmatch.h	1996-06-22 13:04:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/lib/fnmatch.h	1999-11-08 21:15:04.000000000 +0800
@@ -45,15 +45,19 @@
 
 /* Bits set in the FLAGS argument to `fnmatch'.  */
 #define	FNM_PATHNAME	(1 << 0) /* No wildcard can ever match `/'.  */
 #define	FNM_NOESCAPE	(1 << 1) /* Backslashes don't quote special chars.  */
 #define	FNM_PERIOD	(1 << 2) /* Leading `.' is matched only explicitly.  */
 
-#if !defined (_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 2 || defined (_GNU_SOURCE)
+#ifndef FNM_FILE_NAME
 #define	FNM_FILE_NAME	FNM_PATHNAME /* Preferred GNU name.  */
+#endif
+#ifndef FNM_LEADING_DIR
 #define	FNM_LEADING_DIR	(1 << 3) /* Ignore `/...' after a match.  */
+#endif
+#ifndef FNM_CASEFOLD
 #define	FNM_CASEFOLD	(1 << 4) /* Compare without regard to case.  */
 #endif
 
 /* Value returned by `fnmatch' if STRING does not match PATTERN.  */
 #define	FNM_NOMATCH	1
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/loadparm.c	1999-03-16 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/loadparm.c	1999-11-08 21:15:01.000000000 +0800
@@ -114,12 +114,13 @@
 	char *comment;
 	char *lock_file;
 	BOOL read_only;
 	BOOL list;
 	BOOL use_chroot;
 	BOOL transfer_logging;
+	BOOL ignore_errors;
 	char *uid;
 	char *gid;
 	char *hosts_allow;
 	char *hosts_deny;
 	char *auth_users;
 	char *secrets_file;
@@ -144,12 +145,13 @@
 	NULL,    /* comment */
 	DEFAULT_LOCK_FILE,    /* lock file */
 	True,    /* read only */
 	True,    /* list */
 	True,    /* use chroot */
 	False,   /* transfer logging */
+	False,   /* ignore errors */
 	"nobody",/* uid */
 	"nobody",/* gid */
 	NULL,    /* hosts allow */
 	NULL,    /* hosts deny */
 	NULL,    /* auth users */
 	NULL,    /* secrets file */
@@ -269,12 +271,13 @@
   {"strict modes",     P_BOOL,    P_LOCAL,  &sDefault.strict_modes,NULL,   0},
   {"exclude",          P_STRING,  P_LOCAL,  &sDefault.exclude,     NULL,   0},
   {"exclude from",     P_STRING,  P_LOCAL,  &sDefault.exclude_from,NULL,   0},
   {"include",          P_STRING,  P_LOCAL,  &sDefault.include,     NULL,   0},
   {"include from",     P_STRING,  P_LOCAL,  &sDefault.include_from,NULL,   0},
   {"transfer logging", P_BOOL,    P_LOCAL,  &sDefault.transfer_logging,NULL,0},
+  {"ignore errors",    P_BOOL,    P_LOCAL,  &sDefault.ignore_errors,NULL,0},
   {"log format",       P_STRING,  P_LOCAL,  &sDefault.log_format,  NULL,   0},
   {"refuse options",   P_STRING,  P_LOCAL,  &sDefault.refuse_options,NULL, 0},
   {"dont compress",    P_STRING,  P_LOCAL,  &sDefault.dont_compress,NULL,  0},
   {NULL,               P_BOOL,    P_NONE,   NULL,                  NULL,   0}
 };
 
@@ -333,12 +336,13 @@
 FN_LOCAL_STRING(lp_path, path)
 FN_LOCAL_STRING(lp_lock_file, lock_file)
 FN_LOCAL_BOOL(lp_read_only, read_only)
 FN_LOCAL_BOOL(lp_list, list)
 FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
 FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
+FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
 FN_LOCAL_STRING(lp_uid, uid)
 FN_LOCAL_STRING(lp_gid, gid)
 FN_LOCAL_STRING(lp_hosts_allow, hosts_allow)
 FN_LOCAL_STRING(lp_hosts_deny, hosts_deny)
 FN_LOCAL_STRING(lp_auth_users, auth_users)
 FN_LOCAL_STRING(lp_secrets_file, secrets_file)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/main.c	1999-04-06 23:04:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/main.c	1999-11-08 21:15:01.000000000 +0800
@@ -20,14 +20,12 @@
 #include "rsync.h"
 
 time_t starttime = 0;
 
 struct stats stats;
 
-extern int csum_length;
-
 extern int verbose;
 
 static void report(int f)
 {
 	time_t t = time(NULL);
 	extern int am_server;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/Makefile.in	1999-03-16 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/Makefile.in	1999-11-08 21:14:59.000000000 +0800
@@ -21,13 +21,13 @@
 .SUFFIXES: .c .o
 
 LIBOBJ=lib/getopt.o lib/fnmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o
 ZLIBOBJ=zlib/deflate.o zlib/infblock.o zlib/infcodes.o zlib/inffast.o \
 	zlib/inflate.o zlib/inftrees.o zlib/infutil.o zlib/trees.o \
 	zlib/zutil.o zlib/adler32.o 
-OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o main.o checksum.o match.o syscall.o log.o
+OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o main.o checksum.o match.o syscall.o log.o backup.o
 OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o fileio.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 OBJS=$(OBJS1) $(OBJS2) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ)
 
 # note that the -I. is needed to handle config.h when using VPATH
 .c.o:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/options.c	1999-03-16 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/options.c	1999-11-08 21:15:01.000000000 +0800
@@ -59,12 +59,13 @@
 int do_progress=0;
 int keep_partial=0;
 int safe_symlinks=0;
 int copy_unsafe_links=0;
 int block_size=BLOCK_SIZE;
 int size_only=0;
+int delete_after=0;
 
 char *backup_suffix = BACKUP_SUFFIX;
 char *tmpdir = NULL;
 char *compare_dest = NULL;
 char *config_file = RSYNCD_CONF;
 char *shell_cmd = NULL;
@@ -75,12 +76,14 @@
 
 int verbose = 0;
 int quiet = 0;
 int always_checksum = 0;
 int list_only = 0;
 
+struct in_addr socket_address = {INADDR_ANY};
+
 void usage(int F)
 {
   rprintf(F,"rsync version %s Copyright Andrew Tridgell and Paul Mackerras\n\n",
 	  VERSION);
 
   rprintf(F,"rsync is a file transfer program capable of efficient remote update\nvia a fast differencing algorithm.\n\n");
@@ -121,27 +124,30 @@
   rprintf(F," -B, --block-size=SIZE       checksum blocking size (default %d)\n",BLOCK_SIZE);  
   rprintf(F," -e, --rsh=COMMAND           specify rsh replacement\n");
   rprintf(F,"     --rsync-path=PATH       specify path to rsync on the remote machine\n");
   rprintf(F," -C, --cvs-exclude           auto ignore files in the same way CVS does\n");
   rprintf(F,"     --delete                delete files that don't exist on the sending side\n");
   rprintf(F,"     --delete-excluded       also delete excluded files on the receiving side\n");
+  rprintf(F,"     --delete-after          delete after transferring, not before\n");
   rprintf(F,"     --partial               keep partially transferred files\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
   rprintf(F,"     --timeout=TIME          set IO timeout in seconds\n");
   rprintf(F," -I, --ignore-times          don't exclude files that match length and time\n");
   rprintf(F,"     --size-only             only use file size when determining if a file should be transferred\n");
   rprintf(F," -T  --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
+  rprintf(F," -P                          equivalent to --partial --progress\n");
   rprintf(F," -z, --compress              compress file data\n");
   rprintf(F,"     --exclude=PATTERN       exclude files matching PATTERN\n");
   rprintf(F,"     --exclude-from=FILE     exclude patterns listed in FILE\n");
   rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
   rprintf(F,"     --include-from=FILE     don't exclude patterns listed in FILE\n");
   rprintf(F,"     --version               print version number\n");  
   rprintf(F,"     --daemon                run as a rsync daemon\n");  
+  rprintf(F,"     --address               bind to the specified address\n");  
   rprintf(F,"     --config=FILE           specify alternate rsyncd.conf file\n");  
   rprintf(F,"     --port=PORT             specify alternate rsyncd port number\n");
   rprintf(F,"     --stats                 give some file transfer stats\n");  
   rprintf(F,"     --progress              show progress during transfer\n");  
   rprintf(F,"     --log-format=FORMAT     log file transfers using specified format\n");  
   rprintf(F,"     --password-file=FILE    get password from FILE\n");
@@ -155,15 +161,16 @@
 
 enum {OPT_VERSION, OPT_SUFFIX, OPT_SENDER, OPT_SERVER, OPT_EXCLUDE,
       OPT_EXCLUDE_FROM, OPT_DELETE, OPT_DELETE_EXCLUDED, OPT_NUMERIC_IDS,
       OPT_RSYNC_PATH, OPT_FORCE, OPT_TIMEOUT, OPT_DAEMON, OPT_CONFIG, OPT_PORT,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_STATS, OPT_PARTIAL, OPT_PROGRESS,
       OPT_COPY_UNSAFE_LINKS, OPT_SAFE_LINKS, OPT_COMPARE_DEST,
-      OPT_LOG_FORMAT, OPT_PASSWORD_FILE, OPT_SIZE_ONLY};
+      OPT_LOG_FORMAT, OPT_PASSWORD_FILE, OPT_SIZE_ONLY, OPT_ADDRESS,
+      OPT_DELETE_AFTER};
 
-static char *short_options = "oblLWHpguDCtcahvqrRIxnSe:B:T:z";
+static char *short_options = "oblLWHpguDCtcahvqrRIxnSe:B:T:zP";
 
 static struct option long_options[] = {
   {"version",     0,     0,    OPT_VERSION},
   {"server",      0,     0,    OPT_SERVER},
   {"sender",      0,     0,    OPT_SENDER},
   {"delete",      0,     0,    OPT_DELETE},
@@ -210,15 +217,17 @@
   {"compare-dest", 1,    0,    OPT_COMPARE_DEST},
   {"compress",	  0,	 0,    'z'},
   {"daemon",      0,     0,    OPT_DAEMON},
   {"stats",       0,     0,    OPT_STATS},
   {"progress",    0,     0,    OPT_PROGRESS},
   {"partial",     0,     0,    OPT_PARTIAL},
+  {"delete-after",0,     0,    OPT_DELETE_AFTER},
   {"config",      1,     0,    OPT_CONFIG},
   {"port",        1,     0,    OPT_PORT},
   {"log-format",  1,     0,    OPT_LOG_FORMAT},
+  {"address",     1,     0,    OPT_ADDRESS},
   {0,0,0,0}};
 
 
 static char err_buf[100];
 
 void option_error(void)
@@ -308,12 +317,16 @@
 			break;
 
 		case OPT_DELETE:
 			delete_mode = 1;
 			break;
 
+		case OPT_DELETE_AFTER:
+			delete_after = 1;
+			break;
+
 		case OPT_DELETE_EXCLUDED:
 			delete_excluded = 1;
 			delete_mode = 1;
 			break;
 
 		case OPT_FORCE:
@@ -497,24 +510,38 @@
 			break;
 
 		case OPT_PARTIAL:
 			keep_partial = 1;
 			break;
 
+		case 'P':
+			do_progress = 1;
+			keep_partial = 1;
+			break;
+
 		case OPT_CONFIG:
 			config_file = optarg;
 			break;
 
 		case OPT_PORT:
 			rsync_port = atoi(optarg);
 			break;
 
 		case OPT_LOG_FORMAT:
 			log_format = optarg;
 			break;
 
+		case OPT_ADDRESS:
+			{
+				struct in_addr *ia;
+				if ((ia = ip_address(optarg))) {
+					socket_address = *ia;
+				}
+			}
+			break;
+
 		default:
 			slprintf(err_buf,sizeof(err_buf),"unrecognised option\n");
 			return 0;
 		}
 	}
 	return 1;
@@ -610,12 +637,15 @@
 	if (keep_partial)
 		args[ac++] = "--partial";
 
 	if (force_delete)
 		args[ac++] = "--force";
 
+	if (delete_after)
+		args[ac++] = "--delete-after";
+
 	if (copy_unsafe_links)
 		args[ac++] = "--copy-unsafe-links";
 
 	if (safe_symlinks)
 		args[ac++] = "--safe-links";
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/packaging/redhat/5.0/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/packaging/redhat/5.0/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/packaging/redhat/5.0/rsync.spec	1999-04-06 23:09:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/packaging/redhat/5.0/rsync.spec	1999-11-08 21:15:43.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.3.1
+Version: 2.3.2
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.3.1.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.3.2.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/proto.h	1999-03-16 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/proto.h	1999-11-08 21:15:01.000000000 +0800
@@ -1,11 +1,12 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
 int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
 char *auth_server(int fd, int module, char *addr, char *leader);
 void auth_client(int fd, char *user, char *challenge);
+int make_backup(char *fname);
 uint32 get_checksum1(char *buf1,int len);
 void get_checksum2(char *buf,int len,char *sum);
 void file_checksum(char *fname,char *sum,OFF_T size);
 void checksum_init(void);
 void sum_init(void);
 void sum_update(char *p,int len);
@@ -27,12 +28,13 @@
 struct exclude_struct **make_exclude_list(char *fname,
 					  struct exclude_struct **list1,
 					  int fatal, int include);
 void add_exclude_file(char *fname,int fatal,int include);
 void send_exclude_list(int f);
 void recv_exclude_list(int f);
+char *get_exclude_tok(char *p);
 void add_exclude_line(char *p);
 void add_include_line(char *p);
 void add_cvs_excludes(void);
 int sparse_end(int f);
 int write_file(int f,char *buf,int len);
 struct map_struct *map_file(int fd,OFF_T len);
@@ -82,12 +84,13 @@
 char *lp_path(int );
 char *lp_lock_file(int );
 BOOL lp_read_only(int );
 BOOL lp_list(int );
 BOOL lp_use_chroot(int );
 BOOL lp_transfer_logging(int );
+BOOL lp_ignore_errors(int );
 char *lp_uid(int );
 char *lp_gid(int );
 char *lp_hosts_allow(int );
 char *lp_hosts_deny(int );
 char *lp_auth_users(int );
 char *lp_secrets_file(int );
@@ -125,22 +128,22 @@
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen);
 void free_sums(struct sum_struct *s);
 int delete_file(char *fname);
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
 	      int report);
 void sig_int(void);
-int make_backup(char *fname);
 void finish_transfer(char *fname, char *fnametmp, struct file_struct *file);
 void send_files(struct file_list *flist,int f_out,int f_in);
 int open_socket_out(char *host, int port);
 int is_a_socket(int fd);
 void start_accept_loop(int port, int (*fn)(int ));
 void set_socket_options(int fd, char *options);
 void become_daemon(void);
 char *client_addr(int fd);
 char *client_name(int fd);
+struct in_addr *ip_address(const char *str);
 int do_unlink(char *fname);
 int do_symlink(char *fname1, char *fname2);
 int do_link(char *fname1, char *fname2);
 int do_lchown(const char *path, uid_t owner, gid_t group);
 int do_mknod(char *pathname, mode_t mode, dev_t dev);
 int do_rmdir(char *pathname);
@@ -177,19 +180,19 @@
 void u_sleep(int usec);
 pid_t do_fork(void);
 void kill_all(int sig);
 int name_to_uid(char *name, uid_t *uid);
 int name_to_gid(char *name, gid_t *gid);
 int lock_range(int fd, int offset, int len);
-void glob_expand(char *base1, char **argv, int *argc, int maxargs, int sanitize_paths);
+void glob_expand(char *base1, char **argv, int *argc, int maxargs);
 void strlower(char *s);
 int vslprintf(char *str, int n, const char *format, va_list ap);
 int slprintf(char *str, int n, char *format, ...);
 void *Realloc(void *p, int size);
 void clean_fname(char *name);
-void sanitize_path(char *p);
+void sanitize_path(char *p, char *reldir);
 char *push_dir(char *dir, int save);
 int pop_dir(char *dir);
 int u_strcmp(const char *cs1, const char *cs2);
 void end_progress(void);
 void show_progress(OFF_T ofs, OFF_T size);
 int unsafe_symlink(char *dest, char *src);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/receiver.c	1999-04-06 23:04:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/receiver.c	1999-11-08 21:15:01.000000000 +0800
@@ -106,17 +106,18 @@
    to match more closely what most people seem to expect of this option */
 static void delete_files(struct file_list *flist)
 {
 	struct file_list *local_file_list;
 	int i, j;
 	char *name;
+	extern int module_id;
 
 	if (cvs_exclude)
 		add_cvs_excludes();
 
-	if (io_error) {
+	if (io_error && !lp_ignore_errors(module_id)) {
 		rprintf(FINFO,"IO error encountered - skipping file deletion\n");
 		return;
 	}
 
 	for (j=0;j<flist->count;j++) {
 		if (!S_ISDIR(flist->files[j]->mode) || 
@@ -299,20 +300,24 @@
 	struct map_struct *buf;
 	int i;
 	struct file_struct *file;
 	int phase=0;
 	int recv_ok;
 	extern struct stats stats;		
+	extern int preserve_perms;
+	extern int delete_after;
 	struct stats initial_stats;
 
 	if (verbose > 2) {
 		rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
 	}
 
-	if (recurse && delete_mode && !local_name && flist->count>0) {
-		delete_files(flist);
+	if (!delete_after) {
+		if (recurse && delete_mode && !local_name && flist->count>0) {
+			delete_files(flist);
+		}
 	}
 
 	while (1) {      
 		cleanup_disable();
 
 		i = read_int(f_in);
@@ -355,20 +360,20 @@
 		if (verbose > 2)
 			rprintf(FINFO,"recv_files(%s)\n",fname);
 
 		fnamecmp = fname;
 
 		/* open the file */  
-		fd1 = open(fnamecmp,O_RDONLY);
+		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 
 		if ((fd1 == -1) && (compare_dest != NULL)) {
 			/* try the file at compare_dest instead */
 			slprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",
 						compare_dest,fname);
 			fnamecmp = fnamecmpbuf;
-			fd1 = open(fnamecmp,O_RDONLY);
+			fd1 = do_open(fnamecmp, O_RDONLY, 0);
 		}
 
 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
 			rprintf(FERROR,"fstat %s : %s\n",fnamecmp,strerror(errno));
 			receive_data(f_in,NULL,-1,NULL,file->length);
 			close(fd1);
@@ -379,12 +384,19 @@
 			rprintf(FERROR,"%s : not a regular file (recv_files)\n",fnamecmp);
 			receive_data(f_in,NULL,-1,NULL,file->length);
 			close(fd1);
 			continue;
 		}
 
+		if (fd1 != -1 && !preserve_perms) {
+			/* if the file exists already and we aren't perserving
+			   presmissions then act as though the remote end sent
+			   us the file permissions we already have */
+			file->mode = st.st_mode;
+		}
+
 		if (fd1 != -1 && st.st_size > 0) {
 			buf = map_file(fd1,st.st_size);
 			if (verbose > 2)
 				rprintf(FINFO,"recv mapped %s of size %d\n",fnamecmp,(int)st.st_size);
 		} else {
 			buf = NULL;
@@ -466,12 +478,18 @@
 					rprintf(FINFO,"redoing %s(%d)\n",fname,i);
 				write_int(f_gen,i);
 			}
 		}
 	}
 
+	if (delete_after) {
+		if (recurse && delete_mode && !local_name && flist->count>0) {
+			delete_files(flist);
+		}
+	}
+
 	if (preserve_hard_links)
 		do_hard_links(flist);
 
 	/* now we need to fix any directory permissions that were 
 	   modified during the transfer */
 	for (i = 0; i < flist->count; i++) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsync.1	1999-04-06 23:04:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsync.1	1999-11-08 21:15:01.000000000 +0800
@@ -152,12 +152,17 @@
 .SH "CONNECTING TO AN RSYNC SERVER" 
 .PP 
 It is also possible to use rsync without using rsh or ssh as the
 transport\&. In this case you will connect to a remote rsync server
 running on TCP port 873\&. 
 .PP 
+You may establish the connetcion via a web proxy by setting the
+environment variable RSYNC_PROXY to a hostname:port pair pointing to
+your web proxy\&. Note that your web proxy must allow proxying to port
+873, this must be configured in your proxy servers ruleset\&.
+.PP 
 Using rsync in this way is the same as using it with rsh or ssh except
 that:
 .PP 
 .IP o 
 you use a double colon :: instead of a single colon to
 separate the hostname from the path\&. 
@@ -285,19 +290,21 @@
      --numeric-ids           don\'t map uid/gid values by user/group name
      --timeout=TIME          set IO timeout in seconds
  -I, --ignore-times          don\'t exclude files that match length and time
      --size-only             only use file size when determining if a file should be transferred
  -T  --temp-dir=DIR          create temporary files in directory DIR
      --compare-dest=DIR      also compare destination files relative to DIR
+ -P                          equivalent to --partial --progress
  -z, --compress              compress file data
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     exclude patterns listed in FILE
      --include=PATTERN       don\'t exclude files matching PATTERN
      --include-from=FILE     don\'t exclude patterns listed in FILE
      --version               print version number
      --daemon                run as a rsync daemon
+     --address               bind to the specified address
      --config=FILE           specify alternate rsyncd\&.conf file
      --port=PORT             specify alternate rsyncd port number
      --stats                 give some file transfer stats
      --progress              show progress during transfer
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
@@ -445,19 +452,12 @@
 .IP 
 .IP "\fB-W, --whole-file\fP" 
 With this option the incremental rsync algorithm
 is  not used  and  the whole file is sent as-is instead\&. This may be
 useful when using rsync with a local machine\&.
 .IP 
-.IP "\fB--partial\fP" 
-By default, rsync will delete any partially
-transferred file if the transfer is interrupted\&. In some circumstances
-it is more desirable to keep partially transferred files\&. Using the
---partial option tells rsync to keep the partial file which should
-make a subsequent transfer of the rest of the file much faster\&.
-.IP 
 .IP "\fB-p, --perms\fP" 
 This option causes rsync to update the remote
 permissions to be the same as the local permissions\&.
 .IP 
 .IP "\fB-o, --owner\fP" 
 This option causes rsync to update the  remote  owner
@@ -511,32 +511,29 @@
 This option has no effect if directory recursion is not selected\&.
 .IP 
 This option can be dangerous if used incorrectly!  It is a very good idea
 to run first using the dry run option (-n) to see what files would be
 deleted to make sure important files aren\'t listed\&.
 .IP 
-rsync 1\&.6\&.4 changed the behavior of --delete to make it less
-dangerous\&.  rsync now only scans directories on the receiving side
-that are explicitly transferred from the sending side\&.  Only files in
-these directories are deleted\&.
-.IP 
-Still, it is probably easy to get burnt with this option\&.  The moral
-of the story is to use the -n option until you get used to the
-behavior of --delete\&.
-.IP 
 If the sending side detects any IO errors then the deletion of any
 files at the destination will be automatically disabled\&. This is to
 prevent temporary filesystem failures (such as NFS errors) on the
 sending side causing a massive deletion of files on the
 destination\&. 
 .IP 
 .IP "\fB--delete-excluded\fP" 
 In addition to deleting the files on the
 receiving side that are not on the sending side, this tells rsync to also
 delete any files on the receiving side that are excluded (see --exclude)\&.
 .IP 
+.IP "\fB--delete-after\fP" 
+By default rsync does file deletions before
+transferring files to try to ensure that there is sufficient space on
+the receiving filesystem\&. If you want to delete after transferring
+then use the --delete-after switch\&.
+.IP 
 .IP "\fB--force\fP" 
 This options tells rsync to delete directories even if
 they are not empty\&.  This applies to both the --delete option and to
 cases where rsync tries to copy a normal file but the destination
 contains a directory of the same name\&. 
 .IP 
@@ -555,13 +552,15 @@
 .IP 
 You can also choose the remote shell program using the RSYNC_RSH
 environment variable\&.
 .IP 
 .IP "\fB--rsync-path=PATH\fP" 
 Use this to specify the path to the copy of
-rsync on the remote machine\&. Useful when it\'s not in your path\&.
+rsync on the remote machine\&. Useful when it\'s not in your path\&. Note
+that this is the full path to the binary, not just the directory that
+the binary is in\&.
 .IP 
 .IP "\fB--exclude=PATTERN\fP" 
 This option allows you to selectively exclude
 certain files from the list of files to be transferred\&. This is most
 useful in combination with a recursive transfer\&.
 .IP 
@@ -684,12 +683,19 @@
 is being run via inetd, otherwise it will detach from the current
 terminal and become a background daemon\&. The daemon will read the
 config file (/etc/rsyncd\&.conf) on each connect made by a client and
 respond to requests accordingly\&. See the rsyncd\&.conf(5) man page for more
 details\&. 
 .IP 
+.IP "\fB--address\fP" 
+By default rsync will bind to the wildcard address
+when run as a daemon with the --daemon option\&. The --address option
+allows you to specify a specific IP address (or hostname) to bind
+to\&. This makes virtual hosting possible in conjunction with the
+--config option\&.
+.IP 
 .IP "\fB--config=FILE\fP" 
 This specifies an alternate config file than
 the default /etc/rsyncd\&.conf\&. This is only relevant when --daemon is
 specified\&. 
 .IP 
 .IP "\fB--port=PORT\fP" 
@@ -704,17 +710,32 @@
 .IP 
 .IP "\fB--stats\fP" 
 This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data\&.
 .IP 
+.IP "\fB--partial\fP" 
+By default, rsync will delete any partially
+transferred file if the transfer is interrupted\&. In some circumstances
+it is more desirable to keep partially transferred files\&. Using the
+--partial option tells rsync to keep the partial file which should
+make a subsequent transfer of the rest of the file much faster\&.
+.IP 
 .IP "\fB--progress\fP" 
 This option tells rsync to print information
 showing the progress of the transfer\&. This gives a bored user
 something to watch\&.
 .IP 
+This option is normally combined with -v\&. Using this option without
+the -v option will produce weird results on your display\&.
+.IP 
+.IP "\fB-P\fP" 
+The -P option is equivalent to --partial --progress\&. I
+found myself typing that combination quite often so I created an
+option to make it easier\&.
+.IP 
 .IP "\fB--password-file\fP" 
 This option allows you to provide a password
 in a file for accessing a remote rsync server\&. Note that this option
 is only useful when accessing a rsync server using the built in
 transport, not when using a remote shell as the transport\&. The file
 must not be world readable\&.
@@ -730,12 +751,16 @@
 name against each exclude/include pattern in turn\&. The first matching
 pattern is acted on\&. If it is an exclude pattern than that file is
 skipped\&. If it is an include pattern then that filename is not
 skipped\&. If no matching include/exclude pattern is found then the
 filename is not skipped\&.
 .PP 
+Note that the --include and --exclude options take one pattern
+each\&. To add multiple patterns use the --include-from and
+--exclude-from options or multiple --include and --exclude options\&. 
+.PP 
 The patterns can take several forms\&. The rules are:
 .PP 
 .IP o 
 if the pattern starts with a / then it is matched against the
 start of the filename, otherwise it is matched against the end of
 the filename\&. Thus /foo would match a file called foo
@@ -837,12 +862,17 @@
 .IP 
 .IP "\fBRSYNC_RSH\fP" 
 The RSYNC_RSH environment variable allows you to
 override the default shell used as the transport for rsync\&. This can
 be used instead of the -e option\&.
 .IP 
+.IP "\fBRSYNC_PROXY\fP" 
+The RSYNC_PROXY environment variable allows you to
+redirect your rsync client to use a web proxy when connecting to a
+rsync daemon\&. You should set RSYNC_PROXY to a hostname:port pair\&.
+.IP 
 .IP "\fBRSYNC_PASSWORD\fP" 
 Setting RSYNC_PASSWORD to the required
 password allows you to run authenticated rsync connections to a rsync
 daemon without user intervention\&. Note that this does not supply a
 password to a shell transport such as ssh\&.
 .IP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsync.c	1999-03-16 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsync.c	1999-11-08 21:15:02.000000000 +0800
@@ -27,13 +27,12 @@
 extern int preserve_times;
 extern int am_root;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_perms;
 extern int make_backups;
-extern char *backup_suffix;
 
 
 /*
   free a sums struct
   */
 void free_sums(struct sum_struct *s)
@@ -198,20 +197,15 @@
 		}
 		updated = 1;
 	}
 
 #ifdef HAVE_CHMOD
 	if (!S_ISLNK(st->st_mode)) {
-		int file_mode;
-		if (preserve_perms)
-			file_mode = file->mode;
-		else
-			file_mode = file->mode & ACCESSPERMS;
 		if (st->st_mode != file->mode) {
 			updated = 1;
-			if (do_chmod(fname,file_mode) != 0) {
+			if (do_chmod(fname,file->mode) != 0) {
 				rprintf(FERROR,"failed to set permissions on %s : %s\n",
 					fname,strerror(errno));
 				return 0;
 			}
 		}
 	}
@@ -229,33 +223,12 @@
 
 void sig_int(void)
 {
 	exit_cleanup(RERR_SIGNAL);
 }
 
-int make_backup(char *fname)
-{
-	char fnamebak[MAXPATHLEN];
-	if (strlen(fname) + strlen(backup_suffix) > (MAXPATHLEN-1)) {
-		rprintf(FERROR,"backup filename too long\n");
-		return 0;
-	}
-
-	slprintf(fnamebak,sizeof(fnamebak),"%s%s",fname,backup_suffix);
-	if (do_rename(fname,fnamebak) != 0) {
-		/* cygwin (at least version b19) reports EINVAL */
-		if (errno != ENOENT && errno != EINVAL) {
-			rprintf(FERROR,"rename %s %s : %s\n",fname,fnamebak,strerror(errno));
-			return 0;
-		}
-	} else if (verbose > 1) {
-		rprintf(FINFO,"backed up %s to %s\n",fname,fnamebak);
-	}
-	return 1;
-}
-
 
 /* finish off a file transfer, renaming the file and setting the permissions
    and ownership */
 void finish_transfer(char *fname, char *fnametmp, struct file_struct *file)
 {
 	if (make_backups && !make_backup(fname))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsyncd.conf.5	1999-04-06 23:04:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsyncd.conf.5	1999-11-08 21:15:02.000000000 +0800
@@ -59,14 +59,15 @@
 and a single line something like this to /etc/inetd\&.conf:
 .PP 
 .RS 
 rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd --daemon
 .RE 
 .PP 
-You will then need to send inetd a HUP signal to tell it to reread its
-config file\&.
+Replace "/usr/bin/rsync" with the path to where you have rsync installed on
+your system\&.  You will then need to send inetd a HUP signal to tell it to
+reread its config file\&.
 .PP 
 Note that you should not send the rsync server a HUP signal to force
 it to reread the \f(CW/etc/rsyncd\&.conf\fP\&. The file is re-read on each client
 connection\&. 
 .PP 
 .SH "GLOBAL OPTIONS" 
@@ -296,12 +297,21 @@
 list of patterns that are matched against a connecting clients
 hostname and IP address\&. If the pattern matches then the connection is
 rejected\&. See the "hosts allow" option for more information\&.
 .IP 
 The default is no "hosts deny" option, which means all hosts can connect\&.
 .IP 
+.IP "\fBignore errors\fP" 
+The "ignore errors" option tells rsyncd to
+ignore IO errors on the server when deciding whether to run the delete
+phase of the transfer\&. Normally rsync skips the --delete step if any
+IO errors have occurred in order to prevent disasterous deletion due
+to a temporary resource shortage or other IO error\&. In some cases this
+test is counter productive so you can use this option to turn off this
+behaviour\&. 
+.IP 
 .IP "\fBtransfer logging\fP" 
 The "transfer logging" option enables per-file 
 logging of downloads and uploads in a format somewhat similar to that
 used by ftp daemons\&. If you want to customize the log formats look at
 the log format option\&.
 .IP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsyncd.conf.yo	1999-04-06 23:04:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsyncd.conf.yo	1999-11-08 21:15:02.000000000 +0800
@@ -55,14 +55,15 @@
 quote(rsync           873/tcp)
 
 and a single line something like this to /etc/inetd.conf:
     
 quote(rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd --daemon)
 
-You will then need to send inetd a HUP signal to tell it to reread its
-config file.
+Replace "/usr/bin/rsync" with the path to where you have rsync installed on
+your system.  You will then need to send inetd a HUP signal to tell it to
+reread its config file.
 
 Note that you should not send the rsync server a HUP signal to force
 it to reread the tt(/etc/rsyncd.conf). The file is re-read on each client
 connection. 
 
 manpagesection(GLOBAL OPTIONS)
@@ -270,12 +271,20 @@
 list of patterns that are matched against a connecting clients
 hostname and IP address. If the pattern matches then the connection is
 rejected. See the "hosts allow" option for more information.
 
 The default is no "hosts deny" option, which means all hosts can connect.
 
+dit(bf(ignore errors)) The "ignore errors" option tells rsyncd to
+ignore IO errors on the server when deciding whether to run the delete
+phase of the transfer. Normally rsync skips the --delete step if any
+IO errors have occurred in order to prevent disasterous deletion due
+to a temporary resource shortage or other IO error. In some cases this
+test is counter productive so you can use this option to turn off this
+behaviour. 
+
 dit(bf(transfer logging)) The "transfer logging" option enables per-file 
 logging of downloads and uploads in a format somewhat similar to that
 used by ftp daemons. If you want to customize the log formats look at
 the log format option.
 
 dit(bf(log format)) The "log format" option allows you to specify the
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsync.h	1999-03-16 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsync.h	1999-11-08 21:15:02.000000000 +0800
@@ -44,13 +44,13 @@
 #define SAME_DIR (1<<5)
 #define SAME_NAME SAME_DIR
 #define LONG_NAME (1<<6)
 #define SAME_TIME (1<<7)
 
 /* update this if you make incompatible changes */
-#define PROTOCOL_VERSION 20
+#define PROTOCOL_VERSION 21
 #define MIN_PROTOCOL_VERSION 11
 #define MAX_PROTOCOL_VERSION 30
 
 #define RSYNC_PORT 873
 
 #define SPARSE_WRITE_SIZE (1024)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/rsync.yo	1999-04-06 23:04:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/rsync.yo	1999-11-08 21:15:02.000000000 +0800
@@ -136,12 +136,17 @@
 manpagesection(CONNECTING TO AN RSYNC SERVER)
 
 It is also possible to use rsync without using rsh or ssh as the
 transport. In this case you will connect to a remote rsync server
 running on TCP port 873. 
 
+You may establish the connetcion via a web proxy by setting the
+environment variable RSYNC_PROXY to a hostname:port pair pointing to
+your web proxy. Note that your web proxy must allow proxying to port
+873, this must be configured in your proxy servers ruleset.
+
 Using rsync in this way is the same as using it with rsh or ssh except
 that:
 
 itemize(
 	it() you use a double colon :: instead of a single colon to
 	separate the hostname from the path. 
@@ -256,19 +261,21 @@
      --numeric-ids           don't map uid/gid values by user/group name
      --timeout=TIME          set IO timeout in seconds
  -I, --ignore-times          don't exclude files that match length and time
      --size-only             only use file size when determining if a file should be transferred
  -T  --temp-dir=DIR          create temporary files in directory DIR
      --compare-dest=DIR      also compare destination files relative to DIR
+ -P                          equivalent to --partial --progress
  -z, --compress              compress file data
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     exclude patterns listed in FILE
      --include=PATTERN       don't exclude files matching PATTERN
      --include-from=FILE     don't exclude patterns listed in FILE
      --version               print version number
      --daemon                run as a rsync daemon
+     --address               bind to the specified address
      --config=FILE           specify alternate rsyncd.conf file
      --port=PORT             specify alternate rsyncd port number
      --stats                 give some file transfer stats
      --progress              show progress during transfer
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
@@ -383,18 +390,12 @@
 This option can be quite slow, so only use it if you need it.
 
 dit(bf(-W, --whole-file)) With this option the incremental rsync algorithm
 is  not used  and  the whole file is sent as-is instead. This may be
 useful when using rsync with a local machine.
 
-dit(bf(--partial)) By default, rsync will delete any partially
-transferred file if the transfer is interrupted. In some circumstances
-it is more desirable to keep partially transferred files. Using the
---partial option tells rsync to keep the partial file which should
-make a subsequent transfer of the rest of the file much faster.
-
 dit(bf(-p, --perms)) This option causes rsync to update the remote
 permissions to be the same as the local permissions.
 
 dit(bf(-o, --owner)) This option causes rsync to update the  remote  owner
 of the  file to be the same as the local owner. This is only available
 to the super-user.  Note that if the source system is a daemon using chroot,
@@ -439,31 +440,27 @@
 This option has no effect if directory recursion is not selected.
 
 This option can be dangerous if used incorrectly!  It is a very good idea
 to run first using the dry run option (-n) to see what files would be
 deleted to make sure important files aren't listed.
 
-rsync 1.6.4 changed the behavior of --delete to make it less
-dangerous.  rsync now only scans directories on the receiving side
-that are explicitly transferred from the sending side.  Only files in
-these directories are deleted.
-
-Still, it is probably easy to get burnt with this option.  The moral
-of the story is to use the -n option until you get used to the
-behavior of --delete.
-
 If the sending side detects any IO errors then the deletion of any
 files at the destination will be automatically disabled. This is to
 prevent temporary filesystem failures (such as NFS errors) on the
 sending side causing a massive deletion of files on the
 destination. 
 
 dit(bf(--delete-excluded)) In addition to deleting the files on the
 receiving side that are not on the sending side, this tells rsync to also
 delete any files on the receiving side that are excluded (see --exclude).
 
+dit(bf(--delete-after)) By default rsync does file deletions before
+transferring files to try to ensure that there is sufficient space on
+the receiving filesystem. If you want to delete after transferring
+then use the --delete-after switch.
+
 dit(bf(--force)) This options tells rsync to delete directories even if
 they are not empty.  This applies to both the --delete option and to
 cases where rsync tries to copy a normal file but the destination
 contains a directory of the same name. 
 
 Since this option was added, deletions were reordered to be done depth-first
@@ -478,13 +475,15 @@
 like to instead use ssh because of its high security.
 
 You can also choose the remote shell program using the RSYNC_RSH
 environment variable.
 
 dit(bf(--rsync-path=PATH)) Use this to specify the path to the copy of
-rsync on the remote machine. Useful when it's not in your path.
+rsync on the remote machine. Useful when it's not in your path. Note
+that this is the full path to the binary, not just the directory that
+the binary is in.
 
 dit(bf(--exclude=PATTERN)) This option allows you to selectively exclude
 certain files from the list of files to be transferred. This is most
 useful in combination with a recursive transfer.
 
 You may use as many --exclude options on the command line as you like
@@ -593,12 +592,18 @@
 is being run via inetd, otherwise it will detach from the current
 terminal and become a background daemon. The daemon will read the
 config file (/etc/rsyncd.conf) on each connect made by a client and
 respond to requests accordingly. See the rsyncd.conf(5) man page for more
 details. 
 
+dit(bf(--address)) By default rsync will bind to the wildcard address
+when run as a daemon with the --daemon option. The --address option
+allows you to specify a specific IP address (or hostname) to bind
+to. This makes virtual hosting possible in conjunction with the
+--config option.
+
 dit(bf(--config=FILE)) This specifies an alternate config file than
 the default /etc/rsyncd.conf. This is only relevant when --daemon is
 specified. 
 
 dit(bf(--port=PORT)) This specifies an alternate TCP port number to use
 rather than the default port 873.
@@ -609,16 +614,29 @@
 rsyncd.conf.
 
 dit(bf(--stats)) This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data.
 
+dit(bf(--partial)) By default, rsync will delete any partially
+transferred file if the transfer is interrupted. In some circumstances
+it is more desirable to keep partially transferred files. Using the
+--partial option tells rsync to keep the partial file which should
+make a subsequent transfer of the rest of the file much faster.
+
 dit(bf(--progress)) This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
 
+This option is normally combined with -v. Using this option without
+the -v option will produce weird results on your display.
+
+dit(bf(-P)) The -P option is equivalent to --partial --progress. I
+found myself typing that combination quite often so I created an
+option to make it easier.
+
 dit(bf(--password-file)) This option allows you to provide a password
 in a file for accessing a remote rsync server. Note that this option
 is only useful when accessing a rsync server using the built in
 transport, not when using a remote shell as the transport. The file
 must not be world readable.
 
@@ -634,12 +652,16 @@
 name against each exclude/include pattern in turn. The first matching
 pattern is acted on. If it is an exclude pattern than that file is
 skipped. If it is an include pattern then that filename is not
 skipped. If no matching include/exclude pattern is found then the
 filename is not skipped.
 
+Note that the --include and --exclude options take one pattern
+each. To add multiple patterns use the --include-from and
+--exclude-from options or multiple --include and --exclude options. 
+
 The patterns can take several forms. The rules are:
 
 itemize(
   it() if the pattern starts with a / then it is matched against the
   start of the filename, otherwise it is matched against the end of
   the filename. Thus /foo would match a file called foo
@@ -724,12 +746,16 @@
 more details.
 
 dit(bf(RSYNC_RSH)) The RSYNC_RSH environment variable allows you to
 override the default shell used as the transport for rsync. This can
 be used instead of the -e option.
 
+dit(bf(RSYNC_PROXY)) The RSYNC_PROXY environment variable allows you to
+redirect your rsync client to use a web proxy when connecting to a
+rsync daemon. You should set RSYNC_PROXY to a hostname:port pair.
+
 dit(bf(RSYNC_PASSWORD)) Setting RSYNC_PASSWORD to the required
 password allows you to run authenticated rsync connections to a rsync
 daemon without user intervention. Note that this does not supply a
 password to a shell transport such as ssh.
 
 dit(bf(USER) or bf(LOGNAME)) The USER or LOGNAME environment variables
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/sender.c	1998-11-26 00:24:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/sender.c	1999-11-08 21:15:02.000000000 +0800
@@ -157,13 +157,13 @@
 		if (!s) {
 			io_error = 1;
 			rprintf(FERROR,"receive_sums failed\n");
 			return;
 		}
 	  
-		fd = open(fname,O_RDONLY);
+		fd = do_open(fname, O_RDONLY, 0);
 		if (fd == -1) {
 			io_error = 1;
 			rprintf(FERROR,"send_files failed to open %s: %s\n",
 				fname,strerror(errno));
 			free_sums(s);
 			continue;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/socket.c	1999-03-16 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/socket.c	1999-11-08 21:15:02.000000000 +0800
@@ -20,53 +20,147 @@
   socket functions used in rsync 
 
   */
 
 #include "rsync.h"
 
+
+/* establish a proxy connection on an open socket to a web roxy by using the CONNECT
+   method */
+static int establish_proxy_connection(int fd, char *host, int port)
+{
+	char buffer[1024];
+	char *cp;
+
+	slprintf(buffer, sizeof(buffer), "CONNECT %s:%d HTTP/1.0\r\n\r\n", host, port);
+	if (write(fd, buffer, strlen(buffer)) != strlen(buffer)) {
+		rprintf(FERROR, "failed to write to proxy - %s\n",
+			strerror(errno));
+		return -1;
+	}
+
+	for (cp = buffer; cp < &buffer[sizeof(buffer) - 1]; cp++) {
+		if (read(fd, cp, 1) != 1) {
+			rprintf(FERROR, "failed to read from proxy\n");
+			return -1;
+		}
+		if (*cp == '\n')
+			break;
+	}
+
+	if (*cp != '\n')
+		cp++;
+	*cp-- = '\0';
+	if (*cp == '\r')
+		*cp = '\0';
+	if (strncmp(buffer, "HTTP/", 5) != 0) {
+		rprintf(FERROR, "bad response from proxy - %s\n",
+			buffer);
+		return -1;
+	}
+	for (cp = &buffer[5]; isdigit(*cp) || (*cp == '.'); cp++)
+		;
+	while (*cp == ' ')
+		cp++;
+	if (*cp != '2') {
+		rprintf(FERROR, "bad response from proxy - %s\n",
+			buffer);
+		return -1;
+	}
+	/* throw away the rest of the HTTP header */
+	while (1) {
+		for (cp = buffer; cp < &buffer[sizeof(buffer) - 1];
+		     cp++) {
+			if (read(fd, cp, 1) != 1) {
+				rprintf(FERROR, "failed to read from proxy\n");
+				return -1;
+			}
+			if (*cp == '\n')
+				break;
+		}
+		if ((cp > buffer) && (*cp == '\n'))
+			cp--;
+		if ((cp == buffer) && ((*cp == '\n') || (*cp == '\r')))
+			break;
+	}
+	return 0;
+}
+
+
 /* open a socket to a tcp remote host with the specified port 
-   based on code from Warren */
+   based on code from Warren
+   proxy support by Stephen Rothwell */
 int open_socket_out(char *host, int port)
 {
 	int type = SOCK_STREAM;
 	struct sockaddr_in sock_out;
 	int res;
 	struct hostent *hp;
-  
+	char *h;
+	unsigned p;
+	int proxied = 0;
+	char buffer[1024];
+	char *cp;
+
+	/* if we have a RSYNC_PROXY env variable then redirect our connetcion via a web proxy
+	   at the given address. The format is hostname:port */
+	h = getenv("RSYNC_PROXY");
+	proxied = (h != NULL) && (*h != '\0');
+
+	if (proxied) {
+		strlcpy(buffer, h, sizeof(buffer));
+		cp = strchr(buffer, ':');
+		if (cp == NULL) {
+			rprintf(FERROR, "invalid proxy specification\n");
+			return -1;
+		}
+		*cp++ = '\0';
+		p = atoi(cp);
+		h = buffer;
+	} else {
+		h = host;
+		p = port;
+	}
 
 	res = socket(PF_INET, type, 0);
 	if (res == -1) {
 		return -1;
 	}
 
-	hp = gethostbyname(host);
+	hp = gethostbyname(h);
 	if (!hp) {
-		rprintf(FERROR,"unknown host: %s\n", host);
+		rprintf(FERROR,"unknown host: %s\n", h);
+		close(res);
 		return -1;
 	}
 
 	memcpy(&sock_out.sin_addr, hp->h_addr, hp->h_length);
-	sock_out.sin_port = htons(port);
+	sock_out.sin_port = htons(p);
 	sock_out.sin_family = PF_INET;
 
 	if (connect(res,(struct sockaddr *)&sock_out,sizeof(sock_out))) {
+		rprintf(FERROR,"failed to connect to %s - %s\n", h, strerror(errno));
+		close(res);
+		return -1;
+	}
+
+	if (proxied && establish_proxy_connection(res, host, port) != 0) {
 		close(res);
-		rprintf(FERROR,"failed to connect to %s - %s\n", host, strerror(errno));
 		return -1;
 	}
 
 	set_nonblocking(res);
 
 	return res;
 }
 
 
 /****************************************************************************
 open a socket of the specified type, port and address for incoming data
 ****************************************************************************/
-static int open_socket_in(int type, int port)
+static int open_socket_in(int type, int port, struct in_addr *address)
 {
 	struct hostent *hp;
 	struct sockaddr_in sock;
 	char host_name[MAXHOSTNAMELEN];
 	int res;
 	int one=1;
@@ -84,13 +178,17 @@
 	}
   
 	memset((char *)&sock,0,sizeof(sock));
 	memcpy((char *)&sock.sin_addr,(char *)hp->h_addr, hp->h_length);
 	sock.sin_port = htons(port);
 	sock.sin_family = hp->h_addrtype;
-	sock.sin_addr.s_addr = INADDR_ANY;
+	if (address) {
+		sock.sin_addr = *address;
+	} else {
+		sock.sin_addr.s_addr = INADDR_ANY;
+	}
 	res = socket(hp->h_addrtype, type, 0);
 	if (res == -1) { 
 		rprintf(FERROR,"socket failed\n"); 
 		return -1; 
 	}
 
@@ -118,15 +216,16 @@
 }
 
 
 void start_accept_loop(int port, int (*fn)(int ))
 {
 	int s;
+	extern struct in_addr socket_address;
 
 	/* open an incoming socket */
-	s = open_socket_in(SOCK_STREAM, port);
+	s = open_socket_in(SOCK_STREAM, port, &socket_address);
 	if (s == -1)
 		exit_cleanup(RERR_SOCKETIO);
 
 	/* ready to listen */
 	if (listen(s, 5) == -1) {
 		close(s);
@@ -158,13 +257,13 @@
 		signal(SIGCHLD, SIG_IGN);
 
 		/* we shouldn't have any children left hanging around
 		   but I have had reports that on Digital Unix zombies
 		   are produced, so this ensures that they are reaped */
 #ifdef WNOHANG
-		waitpid(-1, NULL, WNOHANG);
+                while (waitpid(-1, NULL, WNOHANG) > 0);
 #endif
 
 		if (fork()==0) {
 			close(s);
 
 			set_nonblocking(fd);
@@ -383,6 +482,42 @@
 			rprintf(FERROR,"reverse name lookup mismatch - spoofed address?\n");
 		} 
 	}
 
 	return name_buf;
 }
+
+/*******************************************************************
+convert a string to an IP address. The string can be a name or
+dotted decimal number
+  ******************************************************************/
+struct in_addr *ip_address(const char *str)
+{
+	static struct in_addr ret;
+	struct hostent *hp;
+
+	/* try as an IP address */
+	if (inet_aton(str, &ret) != 0) {
+		return &ret;
+	}
+
+	/* otherwise assume it's a network name of some sort and use 
+	   gethostbyname */
+	if ((hp = gethostbyname(str)) == 0) {
+		rprintf(FERROR, "gethostbyname: Unknown host. %s\n",str);
+		return NULL;
+	}
+
+	if (hp->h_addr == NULL) {
+		rprintf(FERROR, "gethostbyname: host address is invalid for host %s\n",str);
+		return NULL;
+	}
+
+	if (hp->h_length > sizeof(ret)) {
+		rprintf(FERROR, "gethostbyname: host address is too large\n");
+		return NULL;
+	}
+
+	memcpy(&ret.s_addr, hp->h_addr, hp->h_length);
+
+	return(&ret);
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/syscall.c	1999-03-16 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/syscall.c	1999-11-08 21:15:02.000000000 +0800
@@ -73,18 +73,20 @@
 	CHECK_RO
 	return rmdir(pathname);
 }
 
 int do_open(char *pathname, int flags, mode_t mode)
 {
-	if (dry_run) return -1;
+	if (flags != O_RDONLY) {
+	    if (dry_run) return -1;
+	    CHECK_RO
+	}
 #ifdef O_BINARY
 	/* for Windows */
 	flags |= O_BINARY;
 #endif
-	CHECK_RO
 	return open(pathname, flags, mode);
 }
 
 #if HAVE_CHMOD
 int do_chmod(const char *path, mode_t mode)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/test.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/test.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/test.sh	1998-06-01 21:47:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/test.sh	1999-11-08 21:15:02.000000000 +0800
@@ -1,27 +1,44 @@
 #!/bin/sh
 
-#
-# Copyright (C) 1998 Philip Hands <http://www.hands.com/~phil/>
+# Copyright (C) 1998,1999 Philip Hands <phil@hands.com>
 #
 # This program is distributable under the terms of the GNU GPL (see COPYING)
 #
 # This is a simple test script that tests a few rsync
 # features to make sure I haven't broken them before a release.
 #
 #
 
-cat <<EOF
+# check if we are running under debian-test, and change behaviour to suit
+if test -n "${DEBIANTEST_LIB}" ; then
+  # make sure rsync is installed
+  test -e /usr/bin/rsync || exit 0
+  
+  . ${DEBIANTEST_LIB}/functions.sh
+  Debian=1
+else
+  cat <<EOF
 
 This set of tests is not completely portable. It is intended for developers
 not for end users. You may experience failures on some platforms that
 do not indicate a problem with rsync.
 
 EOF
+  export PATH=.:$PATH
+  runtest() {
+    echo -n "Test $1: "
+    eval "$2"
+  }
+  printmsg() {
+    echo ""
+    echo "**** ${1}^G ****"
+    echo ""  
+  }
+fi
 
-export PATH=.:$PATH
 TMP=/tmp/rsync-test.$$
 FROM=${TMP}/from
 TO=${TMP}/to
 F1=text1
 LOG=${TMP}/log
 
@@ -35,40 +52,56 @@
 ps ax > ${FROM}/pslist
 echo -n "This file has no trailing lf" > ${FROM}/nolf
 ln -s nolf ${FROM}/nolf-symlink
 cat /etc/inittab /etc/services /etc/resolv.conf > ${FROM}/${F1}
 mkdir ${FROM}/dir
 cp ${FROM}/${F1} ${FROM}/dir
+mkdir ${FROM}/dir/subdir
+mkdir ${FROM}/dir/subdir/subsubdir
+ls -ltr /etc > ${FROM}/dir/subdir/subsubdir/etc-ltr-list
+mkdir ${FROM}/dir/subdir/subsubdir2
+ls -lt /bin > ${FROM}/dir/subdir/subsubdir2/bin-lt-list
 
 checkit() {
-  echo -n "Test $4: $5:"
-  log=${LOG}.$4
+  testnum=`expr 0${testnum} + 1`
+  log=${LOG}.${testnum}
   failed=
   echo "Running: \"$1\""  >${log}
   echo "">>${log}
   eval "$1 || failed=YES"  >>${log} 2>&1
 
   echo "-------------">>${log}
   echo "check how the files compare with diff:">>${log}
   echo "">>${log}
-  diff -ur $2 $3 >>${log} || failed=YES
+  diff -ur $2 $3 >>${log} 2>&1 || failed=YES
   echo "-------------">>${log}
   echo "check how the directory listings compare with diff:">>${log}
   echo "">>${log}
-  ls -la $2 > ${TMP}/ls-from
-  ls -la $3 > ${TMP}/ls-to
-  diff -u ${TMP}/ls-from ${TMP}/ls-to >>${log} || failed=YES
+  ( cd $2 ; ls -laR ) > ${TMP}/ls-from 2>>${log}
+  ( cd $3 ; ls -laR ) > ${TMP}/ls-to  2>>${log}
+  diff -u ${TMP}/ls-from ${TMP}/ls-to >>${log} 2>&1 || failed=YES
   if [ -z "${failed}" ] ; then
-    echo "	done."
+    test -z "${Debian}" && echo "	done."
     rm $log
+    return 0
   else
-    echo "	FAILED."
+    if test -n "${Debian}" ; then
+      cat ${log}
+      rm ${log}
+    else
+      echo "	FAILED (test # ${testnum})."
+    fi
+    return 1
   fi
 }
 
+
 checkforlogs() {
+  # skip it if we're under debian-test
+  if test -n "${Debian}" ; then return 0 ; fi
+
   if [ -f $1 ] ; then
     cat <<EOF
 
 Failures have occured.
 
 You can find the output of the tests in these files:
@@ -84,47 +117,48 @@
     echo "Tests Completed Successfully :-)"
   fi
 }
 
 # Main script starts here
 
-checkit "rsync -av ${FROM}/ ${TO}" ${FROM}/ ${TO} \
-  1 "basic operation"
+runtest "basic operation" 'checkit "rsync -av ${FROM}/ ${TO}" ${FROM}/ ${TO}'
 
 ln ${FROM}/pslist ${FROM}/dir
-checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
-  2 "hard links"
+runtest "hard links" 'checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
 
 rm ${TO}/${F1}
-checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
-  3 "one file"
+runtest "one file" 'checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
 
 echo "extra line" >> ${TO}/${F1}
-checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
-  4 "extra data"
+runtest "extra data" 'checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
 
 cp ${FROM}/${F1} ${TO}/ThisShouldGo
-checkit "rsync --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
-  5 " --delete"
+runtest " --delete" 'checkit "rsync --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
 
 LONGDIR=${FROM}/This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job/This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job/This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job
 mkdir -p ${LONGDIR}
 date > ${LONGDIR}/1
 ls -la / > ${LONGDIR}/2
-checkit "rsync --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
-  6 "long paths"
+runtest "long paths" 'checkit "rsync --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
 
-if type ssh >/dev/null ; then
-rm -rf ${TO}
-  checkit "rsync -avH -e ssh ${FROM}/ localhost:${TO}" ${FROM}/ ${TO} \
-    7 "ssh: basic test"
+if type ssh >/dev/null 2>&1; then
+  if [ "`ssh -o'BatchMode yes' localhost echo yes 2>/dev/null`" = "yes" ]; then
+  rm -rf ${TO}
+    runtest "ssh: basic test" 'checkit "rsync -avH -e ssh ${FROM}/ localhost:${TO}" ${FROM}/ ${TO}'
 
-  mv ${TO}/${F1} ${TO}/ThisShouldGo
-  checkit "rsync --delete -avH -e ssh ${FROM}/ localhost:${TO}" ${FROM}/ ${TO}\
-    8 "ssh: renamed file"
+    mv ${TO}/${F1} ${TO}/ThisShouldGo
+    runtest "ssh: renamed file" 'checkit "rsync --delete -avH -e ssh ${FROM}/ localhost:${TO}" ${FROM}/ ${TO}'
+  else
+  printmsg "Skipping SSH tests because ssh conection to localhost not authorised"
+  fi
 else
-  echo ""
-  echo "**** Skipping SSH tests because ssh is not in the path ****"
-  echo ""
+  printmsg "Skipping SSH tests because ssh is not in the path"
 fi
 
+rm -rf ${TO}
+mkdir -p ${FROM}2/dir/subdir
+cp -a ${FROM}/dir/subdir/subsubdir ${FROM}2/dir/subdir
+cp ${FROM}/dir/* ${FROM}2/dir 2>/dev/null
+runtest "excludes" 'checkit "rsync -vv -Hlrt --delete --include /dir/ --include /dir/\* --include /dir/\*/subsubdir  --include /dir/\*/subsubdir/\*\* --exclude \*\* ${FROM}/dir ${TO}" ${FROM}2/ ${TO}'
+rm -r ${FROM}2
+
 checkforlogs ${LOG}.?
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/util.c	1999-03-16 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/util.c	1999-11-08 21:15:03.000000000 +0800
@@ -279,13 +279,13 @@
 {
 	int ifd;
 	int ofd;
 	char buf[1024 * 8];
 	int len;   /* Number of bytes read into `buf'. */
 
-	ifd = open(source, O_RDONLY);
+	ifd = do_open(source, O_RDONLY, 0);
 	if (ifd == -1) {
 		rprintf(FERROR,"open %s: %s\n",
 			source,strerror(errno));
 		return -1;
 	}
 
@@ -474,28 +474,30 @@
 	lock.l_pid = 0;
 	
 	return fcntl(fd,F_SETLK,&lock) == 0;
 }
 
 
-static void glob_expand_one(char *s, char **argv, int *argc, int maxargs, int sanitize_paths)
+static void glob_expand_one(char *s, char **argv, int *argc, int maxargs)
 {
 #if !(defined(HAVE_GLOB) && defined(HAVE_GLOB_H))
 	if (!*s) s = ".";
 	argv[*argc] = strdup(s);
 	(*argc)++;
 	return;
 #else
+	extern int sanitize_paths;
 	glob_t globbuf;
 	int i;
 
 	if (!*s) s = ".";
 
-	s = strdup(s);
-	sanitize_path(s);
-	argv[*argc] = s;
+	argv[*argc] = strdup(s);
+	if (sanitize_paths) {
+		sanitize_path(argv[*argc], NULL);
+	}
 
 	memset(&globbuf, 0, sizeof(globbuf));
 	glob(argv[*argc], 0, NULL, &globbuf);
 	if (globbuf.gl_pathc == 0) {
 		(*argc)++;
 		globfree(&globbuf);
@@ -508,13 +510,13 @@
 	}
 	globfree(&globbuf);
 	(*argc) += i;
 #endif
 }
 
-void glob_expand(char *base1, char **argv, int *argc, int maxargs, int sanitize_paths)
+void glob_expand(char *base1, char **argv, int *argc, int maxargs)
 {
 	char *s = argv[*argc];
 	char *p, *q;
 	char *base = base1;
 
 	if (!s || !*s) return;
@@ -532,17 +534,17 @@
 	sprintf(base," %s/", base1);
 
 	q = s;
 	while ((p = strstr(q,base)) && ((*argc) < maxargs)) {
 		/* split it at this point */
 		*p = 0;
-		glob_expand_one(q, argv, argc, maxargs, sanitize_paths);
+		glob_expand_one(q, argv, argc, maxargs);
 		q = p+strlen(base);
 	}
 
-	if (*q && (*argc < maxargs)) glob_expand_one(q, argv, argc, maxargs, sanitize_paths);
+	if (*q && (*argc < maxargs)) glob_expand_one(q, argv, argc, maxargs);
 
 	free(s);
 	free(base);
 }
 
 /*******************************************************************
@@ -632,25 +634,43 @@
 	}
 }
 
 /*
  * Make path appear as if a chroot had occurred:
  *    1. remove leading "/" (or replace with "." if at end)
- *    2. remove leading ".." components
+ *    2. remove leading ".." components (except those allowed by "reldir")
  *    3. delete any other "<dir>/.." (recursively)
+ * Can only shrink paths, so sanitizes in place.
  * While we're at it, remove double slashes and "." components like
  *   clean_fname does(), but DON'T remove a trailing slash because that
  *   is sometimes significant on command line arguments.
- * Can only shrink paths, so sanitizes in place.
+ * If "reldir" is non-null, it is a sanitized directory that the path will be
+ *    relative to, so allow as many ".." at the beginning of the path as
+ *    there are components in reldir.  This is used for symbolic link targets.
+ *    If reldir is non-null and the path began with "/", to be completely like
+ *    a chroot we should add in depth levels of ".." at the beginning of the
+ *    path, but that would blow the assumption that the path doesn't grow and
+ *    it is not likely to end up being a valid symlink anyway, so just do
+ *    the normal removal of the leading "/" instead.
  * Contributed by Dave Dykstra <dwd@bell-labs.com>
  */
 
-void sanitize_path(char *p)
+void sanitize_path(char *p, char *reldir)
 {
 	char *start, *sanp;
+	int depth = 0;
+	int allowdotdot = 0;
 
+	if (reldir) {
+		depth++;
+		while (*reldir) {
+			if (*reldir++ == '/') {
+				depth++;
+			}
+		}
+	}
 	start = p;
 	sanp = p;
 	while (*p == '/') {
 		/* remove leading slashes */
 		p++;
 	}
@@ -662,42 +682,61 @@
 		if ((*p == '.') && ((*(p+1) == '/') || (*(p+1) == '\0'))) {
 			/* skip "." component */
 			while (*++p == '/') {
 				/* skip following slashes */
 				;
 			}
-		} else if ((*p == '.') && (*(p+1) == '.') &&
+			continue;
+		}
+		allowdotdot = 0;
+		if ((*p == '.') && (*(p+1) == '.') &&
 			    ((*(p+2) == '/') || (*(p+2) == '\0'))) {
-			/* skip ".." component followed by slash or end */
-			p += 2;
-			if (*p == '/')
-				p++;
-			if (sanp != start) {
-				/* back up sanp one level */
-				--sanp; /* now pointing at slash */
-				while ((sanp > start) && (*(sanp - 1) != '/')) {
-					/* skip back up to slash */
-					sanp--;
+			/* ".." component followed by slash or end */
+			if ((depth > 0) && (sanp == start)) {
+				/* allow depth levels of .. at the beginning */
+				--depth;
+				allowdotdot = 1;
+			} else {
+				p += 2;
+				if (*p == '/')
+					p++;
+				if (sanp != start) {
+					/* back up sanp one level */
+					--sanp; /* now pointing at slash */
+					while ((sanp > start) && (*(sanp - 1) != '/')) {
+						/* skip back up to slash */
+						sanp--;
+					}
 				}
+				continue;
 			}
-		} else {
-			while (1) {
-				/* copy one component through next slash */
-				*sanp++ = *p++;
-				if ((*p == '\0') || (*(p-1) == '/')) {
-					while (*p == '/') {
-						/* skip multiple slashes */
-						p++;
-					}
-					break;
+		}
+		while (1) {
+			/* copy one component through next slash */
+			*sanp++ = *p++;
+			if ((*p == '\0') || (*(p-1) == '/')) {
+				while (*p == '/') {
+					/* skip multiple slashes */
+					p++;
 				}
+				break;
 			}
 		}
+		if (allowdotdot) {
+			/* move the virtual beginning to leave the .. alone */
+			start = sanp;
+		}
 	}
-	if (sanp == start) {
+	if ((sanp == start) && !allowdotdot) {
 		/* ended up with nothing, so put in "." component */
+		/*
+		 * note that the !allowdotdot doesn't prevent this from
+		 *  happening in all allowed ".." situations, but I didn't
+		 *  think it was worth putting in an extra variable to ensure
+		 *  it since an extra "." won't hurt in those situations.
+		 */
 		*sanp++ = '.';
 	}
 	*sanp = '\0';
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.1/version.h	1999-04-06 23:09:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.3.2/version.h	1999-11-08 21:15:42.000000000 +0800
@@ -1 +1 @@
-#define VERSION "2.3.1"
+#define VERSION "2.3.2"
