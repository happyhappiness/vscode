diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/access.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/access.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/access.c	2005-02-14 08:53:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/access.c	2005-11-11 00:42:46.000000000 +0800
@@ -205,13 +205,13 @@
 
 	if (bits >= 0)
 		make_mask(mask, bits, addrlen);
 
 	ret = match_binary(a, t, mask, addrlen);
 
-out:
+  out:
 	freeaddrinfo(resa);
 	freeaddrinfo(rest);
 	return ret;
 }
 
 static int access_match(char *list, char *addr, char *host)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/authenticate.c	2005-04-11 01:09:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/authenticate.c	2006-03-07 02:22:20.000000000 +0800
@@ -18,27 +18,24 @@
 */
 
 /* support rsync authentication */
 #include "rsync.h"
 
 extern char *password_file;
-extern int am_root;
 
 /***************************************************************************
 encode a buffer using base64 - simple and slow algorithm. null terminates
 the result.
   ***************************************************************************/
-void base64_encode(char *buf, int len, char *out)
+void base64_encode(char *buf, int len, char *out, int pad)
 {
 	char *b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 	int bit_offset, byte_offset, idx, i;
 	unsigned char *d = (unsigned char *)buf;
 	int bytes = (len*8 + 5)/6;
 
-	memset(out, 0, bytes+1);
-
 	for (i = 0; i < bytes; i++) {
 		byte_offset = (i*6)/8;
 		bit_offset = (i*6)%8;
 		if (bit_offset < 3) {
 			idx = (d[byte_offset] >> (2-bit_offset)) & 0x3F;
 		} else {
@@ -46,12 +43,17 @@
 			if (byte_offset+1 < len) {
 				idx |= (d[byte_offset+1] >> (8-(bit_offset-2)));
 			}
 		}
 		out[i] = b64[idx];
 	}
+
+	while (pad && (i % 4))
+		out[i++] = '=';
+
+	out[i] = '\0';
 }
 
 /* Generate a challenge buffer and return it base64-encoded. */
 static void gen_challenge(char *addr, char *challenge)
 {
 	char input[32];
@@ -67,13 +69,13 @@
 	SIVAL(input, 24, getpid());
 
 	sum_init(0);
 	sum_update(input, sizeof input);
 	sum_end(md4_out);
 
-	base64_encode(md4_out, MD4_SUM_LENGTH, challenge);
+	base64_encode(md4_out, MD4_SUM_LENGTH, challenge, 0);
 }
 
 
 /* Return the secret for a user from the secret file, null terminated.
  * Maximum length is len (not counting the null). */
 static int get_secret(int module, char *user, char *secret, int len)
@@ -87,19 +89,19 @@
 		return 0;
 
 	if ((fd = open(fname, O_RDONLY)) < 0)
 		return 0;
 
 	if (do_stat(fname, &st) == -1) {
-		rsyserr(FLOG, errno, "stat(%s)", safe_fname(fname));
+		rsyserr(FLOG, errno, "stat(%s)", fname);
 		ok = 0;
 	} else if (lp_strict_modes(module)) {
 		if ((st.st_mode & 06) != 0) {
 			rprintf(FLOG, "secrets file must not be other-accessible (see strict modes option)\n");
 			ok = 0;
-		} else if (am_root && (st.st_uid != 0)) {
+		} else if (MY_UID() == 0 && st.st_uid != 0) {
 			rprintf(FLOG, "secrets file must be owned by root when running as root (see strict modes)\n");
 			ok = 0;
 		}
 	}
 	if (!ok) {
 		rprintf(FLOG, "continuing without secrets file\n");
@@ -157,25 +159,25 @@
 
 	if (!filename)
 		return NULL;
 
 	if ((fd = open(filename,O_RDONLY)) < 0) {
 		rsyserr(FERROR, errno, "could not open password file \"%s\"",
-			safe_fname(filename));
+			filename);
 		if (envpw)
 			rprintf(FERROR, "falling back to RSYNC_PASSWORD environment variable.\n");
 		return NULL;
 	}
 
 	if (do_stat(filename, &st) == -1) {
-		rsyserr(FERROR, errno, "stat(%s)", safe_fname(filename));
+		rsyserr(FERROR, errno, "stat(%s)", filename);
 		ok = 0;
 	} else if ((st.st_mode & 06) != 0) {
 		rprintf(FERROR,"password file must not be other-accessible\n");
 		ok = 0;
-	} else if (am_root && st.st_uid != 0) {
+	} else if (MY_UID() == 0 && st.st_uid != 0) {
 		rprintf(FERROR,"password file must be owned by root when running as root\n");
 		ok = 0;
 	}
 	if (!ok) {
 		rprintf(FERROR,"continuing without password file\n");
 		if (envpw)
@@ -206,13 +208,13 @@
 
 	sum_init(0);
 	sum_update(in, strlen(in));
 	sum_update(challenge, strlen(challenge));
 	sum_end(buf);
 
-	base64_encode(buf, MD4_SUM_LENGTH, out);
+	base64_encode(buf, MD4_SUM_LENGTH, out, 0);
 }
 
 /* Possibly negotiate authentication with the client.  Use "leader" to
  * start off the auth if necessary.
  *
  * Return NULL if authentication failed.  Return "" if anonymous access.
@@ -220,13 +222,13 @@
  */
 char *auth_server(int f_in, int f_out, int module, char *host, char *addr,
 		  char *leader)
 {
 	char *users = lp_auth_users(module);
 	char challenge[MD4_SUM_LENGTH*2];
-	char line[MAXPATHLEN];
+	char line[BIGPATHBUFLEN];
 	char secret[512];
 	char pass2[MD4_SUM_LENGTH*2];
 	char *tok, *pass;
 
 	/* if no auth list then allow anyone in! */
 	if (!users || !*users)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/backup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/backup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/backup.c	2005-06-11 01:57:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/backup.c	2006-02-25 00:43:44.000000000 +0800
@@ -18,24 +18,22 @@
 
 /* backup handling code */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int backup_suffix_len;
 extern int backup_dir_len;
 extern unsigned int backup_dir_remainder;
 extern char backup_dir_buf[MAXPATHLEN];
 extern char *backup_suffix;
 extern char *backup_dir;
 
 extern int am_root;
 extern int preserve_devices;
+extern int preserve_specials;
 extern int preserve_links;
-extern int preserve_hard_links;
-extern int orig_umask;
 extern int safe_symlinks;
 
 /* make a complete pathname for backup file */
 char *get_backup_name(char *fname)
 {
 	if (backup_dir) {
@@ -62,14 +60,13 @@
 		return 0;
 
 	while (1) {
 		if (do_rename(fname, fnamebak) == 0) {
 			if (verbose > 1) {
 				rprintf(FINFO, "backed up %s to %s\n",
-					safe_fname(fname),
-					safe_fname(fnamebak));
+					fname, fnamebak);
 			}
 			break;
 		}
 		/* cygwin (at least version b19) reports EINVAL */
 		if (errno == ENOENT || errno == EINVAL)
 			break;
@@ -78,13 +75,13 @@
 		if (errno == EISDIR && do_rmdir(fnamebak) == 0)
 			continue;
 		if (errno == ENOTDIR && do_unlink(fnamebak) == 0)
 			continue;
 
 		rsyserr(FERROR, rename_errno, "rename %s to backup %s",
-			safe_fname(fname), safe_fname(fnamebak));
+			fname, fnamebak);
 		errno = rename_errno;
 		return 0;
 	}
 
 	return 1;
 }
@@ -109,13 +106,13 @@
 		if (--p == fullpath) {
 			p += strlen(p);
 			goto failure;
 		}
 		if (*p == '/') {
 			*p = '\0';
-			if (do_mkdir(fullpath, 0777 & ~orig_umask) == 0)
+			if (mkdir_defmode(fullpath) == 0)
 				break;
 			if (errno != ENOENT) {
 				rsyserr(FERROR, errno,
 					"make_bak_dir mkdir %s failed",
 					full_fname(fullpath));
 				goto failure;
@@ -138,33 +135,34 @@
 			}
 		}
 		*p = '/';
 		p += strlen(p);
 		if (p == end)
 			break;
-		if (do_mkdir(fullpath, 0777 & ~orig_umask) < 0) {
+		if (mkdir_defmode(fullpath) < 0) {
 			rsyserr(FERROR, errno, "make_bak_dir mkdir %s failed",
 				full_fname(fullpath));
 			goto failure;
 		}
 	}
 	return 0;
 
-failure:
+  failure:
 	while (p != end) {
 		*p = '/';
 		p += strlen(p);
 	}
 	return -1;
 }
 
 /* robustly move a file, creating new directory structures if necessary */
 static int robust_move(char *src, char *dst)
 {
-	if (robust_rename(src, dst, 0755) < 0 && (errno != ENOENT
-	    || make_bak_dir(dst) < 0 || robust_rename(src, dst, 0755) < 0))
+	if (robust_rename(src, dst, NULL, 0755) < 0
+	 && (errno != ENOENT || make_bak_dir(dst) < 0
+	  || robust_rename(src, dst, NULL, 0755) < 0))
 		return -1;
 	return 0;
 }
 
 
 /* If we have a --backup-dir, then we get here from make_backup().
@@ -178,29 +176,30 @@
 	int ret_code;
 
 	/* return if no file to keep */
 	if (do_lstat(fname, &st) < 0)
 		return 1;
 
-	if (!(file = make_file(fname, NULL, NO_FILTERS)))
+	if (!(file = make_file(fname, NULL, NULL, 0, NO_FILTERS)))
 		return 1; /* the file could have disappeared */
 
 	if (!(buf = get_backup_name(fname)))
 		return 0;
 
 	/* Check to see if this is a device file, or link */
-	if (IS_DEVICE(file->mode) && am_root && preserve_devices) {
+	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
+	 || (preserve_specials && IS_SPECIAL(file->mode))) {
 		do_unlink(buf);
 		if (do_mknod(buf, file->mode, file->u.rdev) < 0
 		    && (errno != ENOENT || make_bak_dir(buf) < 0
 		     || do_mknod(buf, file->mode, file->u.rdev) < 0)) {
 			rsyserr(FERROR, errno, "mknod %s failed",
 				full_fname(buf));
 		} else if (verbose > 2) {
 			rprintf(FINFO, "make_backup: DEVICE %s successful.\n",
-				safe_fname(fname));
+				fname);
 		}
 		kept = 1;
 		do_unlink(fname);
 	}
 
 	if (!kept && S_ISDIR(file->mode)) {
@@ -232,43 +231,43 @@
 			do_unlink(buf);
 			if (do_symlink(file->u.link, buf) < 0
 			    && (errno != ENOENT || make_bak_dir(buf) < 0
 			     || do_symlink(file->u.link, buf) < 0)) {
 				rsyserr(FERROR, errno, "link %s -> \"%s\"",
 					full_fname(buf),
-					safe_fname(file->u.link));
+					file->u.link);
 			}
 			do_unlink(fname);
 			kept = 1;
 		}
 	}
 #endif
 
 	if (!kept && !S_ISREG(file->mode)) {
 		rprintf(FINFO, "make_bak: skipping non-regular file %s\n",
-			safe_fname(fname));
+			fname);
 		return 1;
 	}
 
 	/* move to keep tree if a file */
 	if (!kept) {
 		if (robust_move(fname, buf) != 0) {
 			rsyserr(FERROR, errno, "keep_backup failed: %s -> \"%s\"",
-				full_fname(fname), safe_fname(buf));
+				full_fname(fname), buf);
 		} else if (st.st_nlink > 1) {
 			/* If someone has hard-linked the file into the backup
 			 * dir, rename() might return success but do nothing! */
 			robust_unlink(fname); /* Just in case... */
 		}
 	}
-	set_perms(buf, file, NULL, 0);
+	set_file_attrs(buf, file, NULL, 0);
 	free(file);
 
 	if (verbose > 1) {
 		rprintf(FINFO, "backed up %s to %s\n",
-			safe_fname(fname), safe_fname(buf));
+			fname, buf);
 	}
 	return 1;
 }
 
 
 /* main backup switch routine */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/batch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/batch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/batch.c	2005-04-10 02:59:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/batch.c	2006-01-25 05:40:43.000000000 +0800
@@ -3,40 +3,43 @@
    Weiss 1/1999
    Batch utilities for rsync.
 
 */
 
 #include "rsync.h"
+#include "zlib/zlib.h"
 #include <time.h>
 
-extern int am_sender;
 extern int eol_nulls;
 extern int recurse;
 extern int xfer_dirs;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_devices;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int always_checksum;
 extern int do_compression;
+extern int def_compress_level;
 extern int protocol_version;
 extern char *batch_name;
 
 extern struct filter_list_struct filter_list;
 
+static int tweaked_compress_level;
+
 static int *flag_ptr[] = {
 	&recurse,		/* 0 */
 	&preserve_uid,		/* 1 */
 	&preserve_gid,		/* 2 */
 	&preserve_links,	/* 3 */
 	&preserve_devices,	/* 4 */
 	&preserve_hard_links,	/* 5 */
 	&always_checksum,	/* 6 */
 	&xfer_dirs,		/* 7 (protocol 29) */
-	&do_compression,	/* 8 (protocol 29) */
+	&tweaked_compress_level,/* 8 (protocol 29) */
 	NULL
 };
 
 static char *flag_name[] = {
 	"--recurse (-r)",
 	"--owner (-o)",
@@ -51,12 +54,18 @@
 };
 
 void write_stream_flags(int fd)
 {
 	int i, flags;
 
+#if Z_DEFAULT_COMPRESSION == -1
+	tweaked_compress_level = do_compression ? def_compress_level + 2 : 0;
+#else
+#error internal logic error!  Fix def_compress_level logic above and below too!
+#endif
+
 	/* Start the batch file with a bitmap of data-stream-affecting
 	 * flags. */
 	if (protocol_version < 29)
 		flag_ptr[7] = NULL;
 	for (i = 0, flags = 0; flag_ptr[i]; i++) {
 		if (*flag_ptr[i])
@@ -85,12 +94,19 @@
 	if (protocol_version < 29) {
 		if (recurse)
 			xfer_dirs |= 1;
 		else if (xfer_dirs < 2)
 			xfer_dirs = 0;
 	}
+
+	if (tweaked_compress_level == 0 || tweaked_compress_level == 2)
+		do_compression = 0;
+	else {
+		do_compression = 1;
+		def_compress_level = tweaked_compress_level - 2;
+	}
 }
 
 static void write_arg(int fd, char *arg)
 {
 	char *x, *s;
 
@@ -145,13 +161,13 @@
 	stringjoin(filename, sizeof filename,
 		   batch_name, ".sh", NULL);
 	fd = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
 		     S_IRUSR | S_IWUSR | S_IEXEC);
 	if (fd < 0) {
 		rsyserr(FERROR, errno, "Batch file %s open error",
-			safe_fname(filename));
+			filename);
 		exit_cleanup(1);
 	}
 
 	/* Write argvs info to BATCH.sh file */
 	write_arg(fd, argv[0]);
 	if (filter_list.head) {
@@ -191,45 +207,10 @@
 	write_arg(fd, p);
 	write_byte(fd, '}');
 	if (filter_list.head)
 		write_filter_rules(fd);
 	if (write(fd, "\n", 1) != 1 || close(fd) < 0) {
 		rsyserr(FERROR, errno, "Batch file %s write error",
-			safe_fname(filename));
+			filename);
 		exit_cleanup(1);
 	}
 }
-
-void show_flist(int index, struct file_struct **fptr)
-{
-	/*  for debugging    show_flist(flist->count, flist->files * */
-
-	int i;
-	for (i = 0; i < index; i++) {
-		rprintf(FINFO, "flist->flags=%#x\n", fptr[i]->flags);
-		rprintf(FINFO, "flist->modtime=%#lx\n",
-			(long unsigned) fptr[i]->modtime);
-		rprintf(FINFO, "flist->length=%.0f\n",
-			(double) fptr[i]->length);
-		rprintf(FINFO, "flist->mode=%#o\n", (int) fptr[i]->mode);
-		rprintf(FINFO, "flist->basename=%s\n",
-			safe_fname(fptr[i]->basename));
-		if (fptr[i]->dirname) {
-			rprintf(FINFO, "flist->dirname=%s\n",
-				safe_fname(fptr[i]->dirname));
-		}
-		if (am_sender && fptr[i]->dir.root) {
-			rprintf(FINFO, "flist->dir.root=%s\n",
-				safe_fname(fptr[i]->dir.root));
-		}
-	}
-}
-
-/* for debugging */
-void show_argvs(int argc, char *argv[])
-{
-	int i;
-
-	rprintf(FINFO, "BATCH.C:show_argvs,argc=%d\n", argc);
-	for (i = 0; i < argc; i++)
-		rprintf(FINFO, "i=%d,argv[i]=%s\n", i, safe_fname(argv[i]));
-}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7: chmod.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/cleanup.c	2005-03-06 02:58:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/cleanup.c	2006-02-04 02:46:38.000000000 +0800
@@ -23,12 +23,16 @@
 
 extern int io_error;
 extern int keep_partial;
 extern int log_got_error;
 extern char *partial_dir;
 
+#ifdef HAVE_SIGACTION
+static struct sigaction sigact;
+#endif
+
 /**
  * Close all open sockets and files, allowing a (somewhat) graceful
  * shutdown() of socket connections.  This eliminates the abortive
  * TCP RST sent by a Winsock-based system when the close() occurs.
  **/
 void close_all(void)
@@ -91,23 +95,24 @@
 	if (inside_cleanup > 10) {
 		/* prevent the occasional infinite recursion */
 		return;
 	}
 	inside_cleanup++;
 
-	signal(SIGUSR1, SIG_IGN);
-	signal(SIGUSR2, SIG_IGN);
+	SIGACTION(SIGUSR1, SIG_IGN);
+	SIGACTION(SIGUSR2, SIG_IGN);
 
 	if (verbose > 3) {
 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): entered\n",
-			code, safe_fname(file), line);
+			code, file, line);
 	}
 
 	if (cleanup_child_pid != -1) {
 		int status;
-		if (waitpid(cleanup_child_pid, &status, WNOHANG) == cleanup_child_pid) {
+		if (wait_process(cleanup_child_pid, &status, WNOHANG)
+		 == cleanup_child_pid) {
 			status = WEXITSTATUS(status);
 			if (status > code)
 				code = status;
 		}
 	}
 
@@ -118,14 +123,14 @@
 		if (cleanup_fd_r != -1)
 			close(cleanup_fd_r);
 		if (cleanup_fd_w != -1) {
 			flush_write_file(cleanup_fd_w);
 			close(cleanup_fd_w);
 		}
-		finish_transfer(cleanup_new_fname, fname, cleanup_file, 0,
-				!partial_dir);
+		finish_transfer(cleanup_new_fname, fname, NULL,
+				cleanup_file, 0, !partial_dir);
 	}
 	io_flush(FULL_FLUSH);
 	if (cleanup_fname)
 		do_unlink(cleanup_fname);
 	if (code)
 		kill_all(SIGUSR1);
@@ -146,13 +151,13 @@
 
 	if (code)
 		log_exit(code, file, line);
 
 	if (verbose > 2) {
 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n",
-			ocode, safe_fname(file), line, code);
+			ocode, file, line, code);
 	}
 
 	close_all();
 	exit(code);
 }
 
@@ -163,13 +168,13 @@
 }
 
 
 void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
 		 int fd_r, int fd_w)
 {
-	cleanup_fname = fnametmp;
+	cleanup_fname = fname ? fnametmp : NULL;
 	cleanup_new_fname = fname;
 	cleanup_file = file;
 	cleanup_fd_r = fd_r;
 	cleanup_fd_w = fd_w;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/clientname.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/clientname.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/clientname.c	2005-02-14 08:53:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/clientname.c	2006-02-25 00:43:44.000000000 +0800
@@ -31,13 +31,12 @@
  * emulate it using the KAME implementation.
  **/
 
 #include "rsync.h"
 
 static const char default_name[] = "UNKNOWN";
-extern int am_daemon;
 extern int am_server;
 
 
 /**
  * Return the IP addr of the client as a string
  **/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/clientserver.c	2005-06-11 00:57:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/clientserver.c	2006-02-24 09:56:26.000000000 +0800
@@ -25,12 +25,13 @@
  * rsyncd.
  **/
 
 #include "rsync.h"
 
 extern int verbose;
+extern int quiet;
 extern int list_only;
 extern int am_sender;
 extern int am_server;
 extern int am_daemon;
 extern int am_root;
 extern int rsync_port;
@@ -38,29 +39,37 @@
 extern int daemon_over_rsh;
 extern int sanitize_paths;
 extern int filesfrom_fd;
 extern int remote_protocol;
 extern int protocol_version;
 extern int io_timeout;
-extern int orig_umask;
 extern int no_detach;
 extern int default_af_hint;
+extern mode_t orig_umask;
 extern char *bind_address;
-extern struct filter_list_struct server_filter_list;
+extern char *sockopts;
 extern char *config_file;
 extern char *files_from;
+extern char *tmpdir;
+extern struct chmod_mode_struct *chmod_modes;
+extern struct filter_list_struct server_filter_list;
 
 char *auth_user;
 int read_only = 0;
 int daemon_log_format_has_i = 0;
 int daemon_log_format_has_o_or_i = 0;
 int module_id = -1;
+struct chmod_mode_struct *daemon_chmod_modes;
 
 /* Length of lp_path() string when in daemon mode & not chrooted, else 0. */
 unsigned int module_dirlen = 0;
 
+#ifdef HAVE_SIGACTION
+static struct sigaction sigact;
+#endif
+
 /**
  * Run a client connected to an rsyncd.  The alternative to this
  * function for remote-shell connections is do_cmd().
  *
  * After negotiating which module to use and reading the server's
  * motd, this hands over to client_run().  Telling the server the
@@ -94,24 +103,26 @@
 
 	fd = open_socket_out_wrapped(host, rsync_port, bind_address,
 				     default_af_hint);
 	if (fd == -1)
 		exit_cleanup(RERR_SOCKETIO);
 
+	set_socket_options(fd, sockopts);
+
 	ret = start_inband_exchange(user, path, fd, fd, argc);
 
 	return ret ? ret : client_run(fd, fd, -1, argc, argv);
 }
 
 int start_inband_exchange(char *user, char *path, int f_in, int f_out, 
 			  int argc)
 {
 	int i;
 	char *sargs[MAX_ARGS];
 	int sargc = 0;
-	char line[MAXPATHLEN];
+	char line[BIGPATHBUFLEN];
 	char *p;
 
 	if (argc == 0 && !am_sender)
 		list_only |= 1;
 
 	if (*path == '/') {
@@ -212,30 +223,68 @@
 			io_start_multiplex_in();
 	}
 
 	return 0;
 }
 
+static char *finish_pre_exec(pid_t pid, int fd, char *request,
+			     int argc, char *argv[])
+{
+	int j, status = -1;
+
+	if (request) {
+		write_buf(fd, request, strlen(request)+1);
+		for (j = 0; j < argc; j++)
+			write_buf(fd, argv[j], strlen(argv[j])+1);
+	}
+
+	write_byte(fd, 0);
+
+	close(fd);
+
+	if (wait_process(pid, &status, 0) < 0
+	 || !WIFEXITED(status) || WEXITSTATUS(status) != 0) {
+		char *e;
+		if (asprintf(&e, "pre-xfer exec returned failure (%d)\n", status) < 0)
+			out_of_memory("finish_pre_exec");
+		return e;
+	}
+	return NULL;
+}
+
+static int read_arg_from_pipe(int fd, char *buf, int limit)
+{
+	char *bp = buf, *eob = buf + limit - 1;
 
+	while (1) {
+	    if (read(fd, bp, 1) != 1)
+		return -1;
+	    if (*bp == '\0')
+		break;
+	    if (bp < eob)
+		bp++;
+	}
+	*bp = '\0';
+
+	return bp - buf;
+}
 
-static int rsync_module(int f_in, int f_out, int i)
+static int rsync_module(int f_in, int f_out, int i, char *addr, char *host)
 {
 	int argc = 0;
 	int maxargs;
 	char **argv;
-	char **argp;
-	char line[MAXPATHLEN];
+	char line[BIGPATHBUFLEN];
 	uid_t uid = (uid_t)-2;  /* canonically "nobody" */
 	gid_t gid = (gid_t)-2;
-	char *p;
-	char *addr = client_addr(f_in);
-	char *host = client_name(f_in);
+	char *p, *err_msg = NULL;
 	char *name = lp_name(i);
 	int use_chroot = lp_use_chroot(i);
 	int start_glob = 0;
-	int ret;
+	int ret, pre_exec_fd = -1;
+	pid_t pre_exec_pid = 0;
 	char *request = NULL;
 
 	if (!allow_access(addr, host, lp_hosts_allow(i), lp_hosts_deny(i))) {
 		rprintf(FLOG, "rsync denied on module %s from %s (%s)\n",
 			name, host, addr);
 		if (!lp_list(i))
@@ -253,13 +302,13 @@
 			name, host, addr);
 	}
 
 	if (!claim_connection(lp_lock_file(i), lp_max_connections(i))) {
 		if (errno) {
 			rsyserr(FLOG, errno, "failed to open lock file %s",
-				safe_fname(lp_lock_file(i)));
+				lp_lock_file(i));
 			io_printf(f_out, "@ERROR: failed to open lock file\n");
 		} else {
 			rprintf(FLOG, "max connections (%d) reached\n",
 				lp_max_connections(i));
 			io_printf(f_out, "@ERROR: max connections (%d) reached -- try again later\n",
 				lp_max_connections(i));
@@ -323,33 +372,124 @@
 		set_filter_dir("/", 1);
 	} else
 		set_filter_dir(lp_path(i), module_dirlen);
 
 	p = lp_filter(i);
 	parse_rule(&server_filter_list, p, MATCHFLG_WORD_SPLIT,
-		   XFLG_ANCHORED2ABS);
+		   XFLG_ABS_IF_SLASH);
 
 	p = lp_include_from(i);
 	parse_filter_file(&server_filter_list, p, MATCHFLG_INCLUDE,
-	    XFLG_ANCHORED2ABS | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
+	    XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
 
 	p = lp_include(i);
 	parse_rule(&server_filter_list, p,
 		   MATCHFLG_INCLUDE | MATCHFLG_WORD_SPLIT,
-		   XFLG_ANCHORED2ABS | XFLG_OLD_PREFIXES);
+		   XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES);
 
 	p = lp_exclude_from(i);
 	parse_filter_file(&server_filter_list, p, 0,
-	    XFLG_ANCHORED2ABS | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
+	    XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
 
 	p = lp_exclude(i);
 	parse_rule(&server_filter_list, p, MATCHFLG_WORD_SPLIT,
-		   XFLG_ANCHORED2ABS | XFLG_OLD_PREFIXES);
+		   XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES);
 
 	log_init();
 
+#ifdef HAVE_PUTENV
+	if (*lp_prexfer_exec(i) || *lp_postxfer_exec(i)) {
+		char *modname, *modpath, *hostaddr, *hostname, *username;
+		int status;
+		if (asprintf(&modname, "RSYNC_MODULE_NAME=%s", name) < 0
+		 || asprintf(&modpath, "RSYNC_MODULE_PATH=%s", lp_path(i)) < 0
+		 || asprintf(&hostaddr, "RSYNC_HOST_ADDR=%s", addr) < 0
+		 || asprintf(&hostname, "RSYNC_HOST_NAME=%s", host) < 0
+		 || asprintf(&username, "RSYNC_USER_NAME=%s", auth_user) < 0)
+			out_of_memory("rsync_module");
+		putenv(modname);
+		putenv(modpath);
+		putenv(hostaddr);
+		putenv(hostname);
+		putenv(username);
+		umask(orig_umask);
+		/* For post-xfer exec, fork a new process to run the rsync
+		 * daemon while this process waits for the exit status and
+		 * runs the indicated command at that point. */
+		if (*lp_postxfer_exec(i)) {
+			pid_t pid = fork();
+			if (pid < 0) {
+				rsyserr(FLOG, errno, "fork failed");
+				io_printf(f_out, "@ERROR: fork failed\n");
+				return -1;
+			}
+			if (pid) {
+				char *ret1, *ret2;
+				if (wait_process(pid, &status, 0) < 0)
+					status = -1;
+				if (asprintf(&ret1, "RSYNC_RAW_STATUS=%d", status) > 0)
+					putenv(ret1);
+				if (WIFEXITED(status))
+					status = WEXITSTATUS(status);
+				else
+					status = -1;
+				if (asprintf(&ret2, "RSYNC_EXIT_STATUS=%d", status) > 0)
+					putenv(ret2);
+				system(lp_postxfer_exec(i));
+				_exit(status);
+			}
+		}
+		/* For pre-xfer exec, fork a child process to run the indicated
+		 * command, though it first waits for the parent process to
+		 * send us the user's request via a pipe. */
+		if (*lp_prexfer_exec(i)) {
+			int fds[2];
+			if (pipe(fds) < 0 || (pre_exec_pid = fork()) < 0) {
+				rsyserr(FLOG, errno, "pre-xfer exec preparation failed");
+				io_printf(f_out, "@ERROR: pre-xfer exec preparation failed\n");
+				return -1;
+			}
+			if (pre_exec_pid == 0) {
+				char buf[BIGPATHBUFLEN];
+				int j, len;
+				close(fds[1]);
+				set_blocking(fds[0]);
+				len = read_arg_from_pipe(fds[0], buf, BIGPATHBUFLEN);
+				if (len <= 0)
+					_exit(1);
+				if (asprintf(&p, "RSYNC_REQUEST=%s", buf) < 0)
+					out_of_memory("rsync_module");
+				putenv(p);
+				for (j = 0; ; j++) {
+					len = read_arg_from_pipe(fds[0], buf,
+								 BIGPATHBUFLEN);
+					if (len <= 0) {
+						if (!len)
+							break;
+						_exit(1);
+					}
+					if (asprintf(&p, "RSYNC_ARG%d=%s", j, buf) < 0)
+						out_of_memory("rsync_module");
+					putenv(p);
+				}
+				close(fds[0]);
+				close(STDIN_FILENO);
+				close(STDOUT_FILENO);
+				status = system(lp_prexfer_exec(i));
+				if (!WIFEXITED(status))
+					_exit(1);
+				_exit(WEXITSTATUS(status));
+			}
+			close(fds[0]);
+			set_blocking(fds[1]);
+			pre_exec_fd = fds[1];
+		}
+		umask(0);
+	}
+#endif
+
 	if (use_chroot) {
 		/*
 		 * XXX: The 'use chroot' flag is a fairly reliable
 		 * source of confusion, because it fails under two
 		 * important circumstances: running as non-root,
 		 * running on Win32 (or possibly others).  On the
@@ -359,28 +499,28 @@
 		 * So, perhaps if we can't chroot we should just issue
 		 * a warning, unless a "require chroot" flag is set,
 		 * in which case we fail.
 		 */
 		if (chroot(lp_path(i))) {
 			rsyserr(FLOG, errno, "chroot %s failed",
-				safe_fname(lp_path(i)));
+				lp_path(i));
 			io_printf(f_out, "@ERROR: chroot failed\n");
 			return -1;
 		}
 
 		if (!push_dir("/")) {
 			rsyserr(FLOG, errno, "chdir %s failed\n",
-				safe_fname(lp_path(i)));
+				lp_path(i));
 			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 
 	} else {
 		if (!push_dir(lp_path(i))) {
 			rsyserr(FLOG, errno, "chdir %s failed\n",
-				safe_fname(lp_path(i)));
+				lp_path(i));
 			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 		sanitize_paths = 1;
 	}
 
@@ -416,12 +556,22 @@
 			return -1;
 		}
 
 		am_root = (MY_UID() == 0);
 	}
 
+	if (lp_temp_dir(i) && *lp_temp_dir(i)) {
+		tmpdir = lp_temp_dir(i);
+		if (strlen(tmpdir) >= MAXPATHLEN - 10) {
+			rprintf(FLOG,
+				"the 'temp dir' value for %s is WAY too long -- ignoring.\n",
+				name);
+			tmpdir = NULL;
+		}
+	}
+
 	io_printf(f_out, "@RSYNCD: OK\n");
 
 	maxargs = MAX_ARGS;
 	if (!(argv = new_array(char *, maxargs)))
 		out_of_memory("rsync_module");
 	argv[argc++] = "rsyncd";
@@ -440,28 +590,43 @@
 			if (!(argv = realloc_array(argv, char *, maxargs)))
 				out_of_memory("rsync_module");
 		}
 		if (!(argv[argc] = strdup(p)))
 			out_of_memory("rsync_module");
 
-		if (start_glob) {
-			if (start_glob == 1) {
-				request = strdup(p);
-				start_glob++;
-			}
-			glob_expand(name, &argv, &argc, &maxargs);
-		} else
+		switch (start_glob) {
+		case 0:
 			argc++;
+			if (strcmp(line, ".") == 0)
+				start_glob = 1;
+			break;
+		case 1:
+			if (pre_exec_pid) {
+				err_msg = finish_pre_exec(pre_exec_pid,
+							  pre_exec_fd, p,
+							  argc, argv);
+				pre_exec_pid = 0;
+			}
+			request = strdup(p);
+			start_glob = 2;
+			/* FALL THROUGH */
+		default:
+			if (!err_msg)
+				glob_expand(name, &argv, &argc, &maxargs);
+			break;
+		}
+	}
 
-		if (strcmp(line, ".") == 0)
-			start_glob = 1;
+	if (pre_exec_pid) {
+		err_msg = finish_pre_exec(pre_exec_pid, pre_exec_fd, request,
+					  argc, argv);
 	}
 
 	verbose = 0; /* future verbosity is controlled by client options */
-	argp = argv;
-	ret = parse_arguments(&argc, (const char ***) &argp, 0);
+	ret = parse_arguments(&argc, (const char ***) &argv, 0);
+	quiet = 0; /* Don't let someone try to be tricky. */
 
 	if (filesfrom_fd == 0)
 		filesfrom_fd = f_in;
 
 	if (request) {
 		if (*auth_user) {
@@ -482,13 +647,13 @@
 		verbose = lp_max_verbosity(i);
 #endif
 
 	if (protocol_version < 23
 	    && (protocol_version == 22 || am_sender))
 		io_start_multiplex_out();
-	else if (!ret) {
+	else if (!ret || err_msg) {
 		/* We have to get I/O multiplexing started so that we can
 		 * get the error back to the client.  This means getting
 		 * the protocol setup finished first in later versions. */
 		setup_protocol(f_out, f_in);
 		if (!am_sender) {
 			/* Since we failed in our option parsing, we may not
@@ -508,22 +673,38 @@
 			if (files_from)
 				write_byte(f_out, 0);
 		}
 		io_start_multiplex_out();
 	}
 
-	if (!ret) {
-		option_error();
+	if (!ret || err_msg) {
+		if (err_msg)
+			rprintf(FERROR, err_msg);
+		else
+			option_error();
 		msleep(400);
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
 
 	if (lp_timeout(i) && lp_timeout(i) > io_timeout)
 		set_io_timeout(lp_timeout(i));
 
-	start_server(f_in, f_out, argc, argp);
+	/* If we have some incoming/outgoing chmod changes, append them to
+	 * any user-specified changes (making our changes have priority).
+	 * We also get a pointer to just our changes so that a receiver
+	 * process can use them separately if --perms wasn't specified. */
+	if (am_sender)
+		p = lp_outgoing_chmod(i);
+	else
+		p = lp_incoming_chmod(i);
+	if (*p && !(daemon_chmod_modes = parse_chmod(p, &chmod_modes))) {
+		rprintf(FLOG, "Invalid \"%sing chmod\" directive: %s\n",
+			am_sender ? "outgo" : "incom", p);
+	}
+
+	start_server(f_in, f_out, argc, argv);
 
 	return 0;
 }
 
 /* send a list of available modules to the client. Don't list those
    with "list = False". */
@@ -543,26 +724,33 @@
 
 /* this is called when a connection is established to a client
    and we want to start talking. The setup of the system is done from
    here */
 int start_daemon(int f_in, int f_out)
 {
-	char line[200];
+	char line[1024];
 	char *motd;
+	char *addr = client_addr(f_in);
+	char *host = client_name(f_in);
 	int i;
 
+	rprintf(FLOG, "connect from %s (%s)\n", host, addr);
+
 	io_set_sock_fds(f_in, f_out);
 
 	if (!lp_load(config_file, 0))
 		exit_cleanup(RERR_SYNTAX);
 
 	log_init();
 
 	if (!am_server) {
 		set_socket_options(f_in, "SO_KEEPALIVE");
-		set_socket_options(f_in, lp_socket_options());
+		if (sockopts)
+			set_socket_options(f_in, sockopts);
+		else
+			set_socket_options(f_in, lp_socket_options());
 		set_nonblocking(f_in);
 	}
 
 	io_printf(f_out, "@RSYNCD: %d\n", protocol_version);
 
 	motd = lp_motd_file();
@@ -592,34 +780,38 @@
 
 	line[0] = 0;
 	if (!read_line(f_in, line, sizeof line - 1))
 		return -1;
 
 	if (!*line || strcmp(line, "#list") == 0) {
+		rprintf(FLOG, "module-list request from %s (%s)\n",
+			host, addr);
 		send_listing(f_out);
 		return -1;
 	}
 
 	if (*line == '#') {
 		/* it's some sort of command that I don't understand */
 		io_printf(f_out, "@ERROR: Unknown command '%s'\n", line);
 		return -1;
 	}
 
 	if ((i = lp_number(line)) < 0) {
-		char *addr = client_addr(f_in);
-		char *host = client_name(f_in);
 		rprintf(FLOG, "unknown module '%s' tried from %s (%s)\n",
 			line, host, addr);
 		io_printf(f_out, "@ERROR: Unknown module '%s'\n", line);
 		return -1;
 	}
 
-	return rsync_module(f_in, f_out, i);
-}
+#ifdef HAVE_SIGACTION
+	sigact.sa_flags = SA_NOCLDSTOP;
+#endif
+	SIGACTION(SIGCHLD, remember_children);
 
+	return rsync_module(f_in, f_out, i, addr, host);
+}
 
 int daemon_main(void)
 {
 	char *pid_file;
 
 	if (is_a_socket(STDIN_FILENO)) {
@@ -661,13 +853,13 @@
 		pid_t pid = getpid();
 		cleanup_set_pid(pid);
 		if ((fd = do_open(lp_pid_file(), O_WRONLY|O_CREAT|O_TRUNC,
 					0666 & ~orig_umask)) == -1) {
 			cleanup_set_pid(0);
 			rsyserr(FLOG, errno, "failed to create pid file %s",
-				safe_fname(pid_file));
+				pid_file);
 			exit_cleanup(RERR_FILEIO);
 		}
 		snprintf(pidbuf, sizeof pidbuf, "%ld\n", (long)pid);
 		write(fd, pidbuf, strlen(pidbuf));
 		close(fd);
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/compat.c	2005-03-10 02:53:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/compat.c	2006-02-25 00:43:44.000000000 +0800
@@ -26,18 +26,18 @@
 #include "rsync.h"
 
 int remote_protocol = 0;
 
 extern int verbose;
 extern int am_server;
-extern int am_sender;
 extern int inplace;
 extern int fuzzy_basis;
 extern int read_batch;
 extern int checksum_seed;
 extern int basis_dir_cnt;
+extern int prune_empty_dirs;
 extern int protocol_version;
 extern char *dest_option;
 
 void setup_protocol(int f_out,int f_in)
 {
 	if (remote_protocol == 0) {
@@ -75,31 +75,44 @@
 	if (protocol_version > PROTOCOL_VERSION) {
 		rprintf(FERROR, "--protocol must be no more than %d on the %s.\n",
 			PROTOCOL_VERSION, am_server? "Server" : "Client");
 		exit_cleanup(RERR_PROTOCOL);
 	}
 
-	if (fuzzy_basis && protocol_version < 29) {
-		rprintf(FERROR,
-			"--fuzzy requires protocol 29 or higher (negotiated %d).\n",
-			protocol_version);
-		exit_cleanup(RERR_PROTOCOL);
-	}
-
-	if (basis_dir_cnt && inplace && protocol_version < 29) {
-		rprintf(FERROR,
-			"%s with --inplace requires protocol 29 or higher (negotiated %d).\n",
-			dest_option, protocol_version);
-		exit_cleanup(RERR_PROTOCOL);
-	}
-
-	if (basis_dir_cnt > 1 && protocol_version < 29) {
-		rprintf(FERROR,
-			"Multiple %s options requires protocol 29 or higher (negotiated %d).\n",
-			dest_option, protocol_version);
-		exit_cleanup(RERR_PROTOCOL);
+	if (protocol_version < 29) {
+		if (fuzzy_basis) {
+			rprintf(FERROR,
+			    "--fuzzy requires protocol 29 or higher"
+			    " (negotiated %d).\n",
+			    protocol_version);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+
+		if (basis_dir_cnt && inplace) {
+			rprintf(FERROR,
+			    "%s with --inplace requires protocol 29 or higher"
+			    " (negotiated %d).\n",
+			    dest_option, protocol_version);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+
+		if (basis_dir_cnt > 1) {
+			rprintf(FERROR,
+			    "Using more than one %s option requires protocol"
+			    " 29 or higher (negotiated %d).\n",
+			    dest_option, protocol_version);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+
+		if (prune_empty_dirs) {
+			rprintf(FERROR,
+			    "--prune-empty-dirs requires protocol 29 or higher"
+			    " (negotiated %d).\n",
+			    protocol_version);
+			exit_cleanup(RERR_PROTOCOL);
+		}
 	}
 
 	if (am_server) {
 		if (!checksum_seed)
 			checksum_seed = time(NULL);
 		write_int(f_out, checksum_seed);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/config.h.in	2005-06-11 00:47:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/config.h.in	2006-03-12 02:25:02.000000000 +0800
@@ -110,24 +110,39 @@
 /* Define to 1 if you have the <glob.h> header file. */
 #undef HAVE_GLOB_H
 
 /* Define to 1 if you have the <grp.h> header file. */
 #undef HAVE_GRP_H
 
+/* Define to 1 if you have the <iconv.h> header file. */
+#undef HAVE_ICONV_H
+
+/* Define to 1 if you have the `iconv_open' function. */
+#undef HAVE_ICONV_OPEN
+
 /* Define to 1 if you have the `inet_ntop' function. */
 #undef HAVE_INET_NTOP
 
 /* Define to 1 if you have the `inet_pton' function. */
 #undef HAVE_INET_PTON
 
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
+/* Define to 1 if you have the <langinfo.h> header file. */
+#undef HAVE_LANGINFO_H
+
+/* Define to 1 if you have the `lchmod' function. */
+#undef HAVE_LCHMOD
+
 /* Define to 1 if you have the `lchown' function. */
 #undef HAVE_LCHOWN
 
+/* Define to 1 if you have the <libcharset.h> header file. */
+#undef HAVE_LIBCHARSET_H
+
 /* Define to 1 if you have the `inet' library (-linet). */
 #undef HAVE_LIBINET
 
 /* Define to 1 if you have the `nsl' library (-lnsl). */
 #undef HAVE_LIBNSL
 
@@ -140,25 +155,34 @@
 /* Define to 1 if you have the `resolv' library (-lresolv). */
 #undef HAVE_LIBRESOLV
 
 /* Define to 1 if you have the `socket' library (-lsocket). */
 #undef HAVE_LIBSOCKET
 
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
 /* Define to 1 if you have the `link' function. */
 #undef HAVE_LINK
 
+/* Define to 1 if you have the `locale_charset' function. */
+#undef HAVE_LOCALE_CHARSET
+
 /* Define to 1 if you have the <locale.h> header file. */
 #undef HAVE_LOCALE_H
 
 /* Define to 1 if long double works and has more range or precision than
    double. */
 #undef HAVE_LONG_DOUBLE
 
 /* Define to 1 if you have the `lseek64' function. */
 #undef HAVE_LSEEK64
 
+/* Define to 1 if you have the `lutimes' function. */
+#undef HAVE_LUTIMES
+
 /* Define to 1 if you have the `mallinfo' function. */
 #undef HAVE_MALLINFO
 
 /* Define to 1 if you have the <malloc.h> header file. */
 #undef HAVE_MALLOC_H
 
@@ -186,15 +210,21 @@
 /* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
 #undef HAVE_NDIR_H
 
 /* Define to 1 if you have the <netdb.h> header file. */
 #undef HAVE_NETDB_H
 
+/* Define to 1 if you have the `nl_langinfo' function. */
+#undef HAVE_NL_LANGINFO
+
 /* Define to 1 if you have the `open64' function. */
 #undef HAVE_OPEN64
 
+/* Define to 1 if you have the `putenv' function. */
+#undef HAVE_PUTENV
+
 /* Define to 1 if you have the `readlink' function. */
 #undef HAVE_READLINK
 
 /* Define to 1 if remote shell is remsh, not rsh */
 #undef HAVE_REMSH
 
@@ -210,12 +240,18 @@
 /* Define to 1 if you have the `setmode' function. */
 #undef HAVE_SETMODE
 
 /* Define to 1 if you have the `setsid' function. */
 #undef HAVE_SETSID
 
+/* Define to 1 if you have the `sigaction' function. */
+#undef HAVE_SIGACTION
+
+/* Define to 1 if you have the `sigprocmask' function. */
+#undef HAVE_SIGPROCMASK
+
 /* Define to 1 if you have the `snprintf' function. */
 #undef HAVE_SNPRINTF
 
 /* Do we have sockaddr_in6.sin6_scope_id? */
 #undef HAVE_SOCKADDR_IN6_SCOPE_ID
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/configure	2005-07-29 03:31:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/configure	2006-03-12 02:25:04.000000000 +0800
@@ -842,15 +842,14 @@
 
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --enable-debug          including debugging symbols and features (default
-                          yes)
-  --enable-profile        turn on CPU profiling (default no)
+  --disable-debug         turn off debugging symbols and features
+  --enable-profile        turn on CPU profiling
   --enable-maintainer-mode
                           turn on extra debug features
   --disable-largefile     omit support for large files
   --disable-ipv6          don't even try to use IPv6
   --disable-locale        turn off locale features
 
@@ -1312,13 +1311,13 @@
 
 
           ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=2.6.6
+RSYNC_VERSION=2.6.7
 
 { echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
 echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -2694,14 +2693,13 @@
 
 cat >>confdefs.h <<\_ACEOF
 #define _GNU_SOURCE 1
 _ACEOF
 
 
-if test "x$ac_cv_prog_cc_stdc" = xno
-then
+if test x"$ac_cv_prog_cc_stdc" = x"no"; then
 	{ echo "$as_me:$LINENO: WARNING: rsync requires an ANSI C compiler and you don't seem to have one" >&5
 echo "$as_me: WARNING: rsync requires an ANSI C compiler and you don't seem to have one" >&2;}
 fi
 
 # We must decide this before testing the compiler.
 
@@ -2713,14 +2711,13 @@
 # Check whether --enable-debug or --disable-debug was given.
 if test "${enable_debug+set}" = set; then
   enableval="$enable_debug"
 
 fi;
 
-if test x"$enable_debug" = x"no"
-then
+if test x"$enable_debug" = x"no"; then
     echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
     CFLAGS=${CFLAGS-"-O"}
 else
     echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6
@@ -2730,37 +2727,34 @@
 
 # Check whether --enable-profile or --disable-profile was given.
 if test "${enable_profile+set}" = set; then
   enableval="$enable_profile"
 
 fi;
-if test x"$enable_profile" = xyes
-then
+if test x"$enable_profile" = x"yes"; then
 	CFLAGS="$CFLAGS -pg"
 fi
 
 
 # Specifically, this turns on panic_action handling.
 # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.
 if test "${enable_maintainer_mode+set}" = set; then
   enableval="$enable_maintainer_mode"
 
 fi;
-if test x"$enable_maintainer_mode" = xyes
-then
+if test x"$enable_maintainer_mode" = x"yes"; then
 	CFLAGS="$CFLAGS -DMAINTAINER_MODE"
 fi
 
 
 # This is needed for our included version of popt.  Kind of silly, but
 # I don't want our version too far out of sync.
 CFLAGS="$CFLAGS -DHAVE_CONFIG_H"
 
 # If GCC, turn on warnings.
-if test x"$GCC" = x"yes"
-then
+if test x"$GCC" = x"yes"; then
 	CFLAGS="$CFLAGS -Wall -W"
 fi
 
 
 # Check whether --with-included-popt or --without-included-popt was given.
 if test "${with_included_popt+set}" = set; then
@@ -2862,14 +2856,13 @@
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_REMSH 1
 _ACEOF
 
 fi
 
-if test x"$with_rsh" != x
-then
+if test x"$with_rsh" != x; then
 	RSYNC_RSH="$with_rsh"
 else
 	RSYNC_RSH="ssh"
 fi
 
 cat >>confdefs.h <<_ACEOF
@@ -2896,13 +2889,13 @@
 
 cat >>confdefs.h <<_ACEOF
 #define NOBODY_GROUP "$NOBODY_GROUP"
 _ACEOF
 
 
-# arrgh. libc in the current debian stable screws up the largefile
+# arrgh. libc in some old debian version screwed up the largefile
 # stuff, getting byte range locking wrong
 
 echo "$as_me:$LINENO: checking for broken largefile support" >&5
 echo $ECHO_N "checking for broken largefile support... $ECHO_C" >&6
 if test "${rsync_cv_HAVE_BROKEN_LARGEFILE+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -3343,34 +3336,13 @@
 
 # Check whether --enable-ipv6 or --disable-ipv6 was given.
 if test "${enable_ipv6+set}" = set; then
   enableval="$enable_ipv6"
 
 fi;
-
-
-
-# Check whether --enable-locale or --disable-locale was given.
-if test "${enable_locale+set}" = set; then
-  enableval="$enable_locale"
-  if test x$enableval = xyes; then
-  cat >>confdefs.h <<\_ACEOF
-#define CONFIG_LOCALE 1
-_ACEOF
-
-fi
-else
-  cat >>confdefs.h <<\_ACEOF
-#define CONFIG_LOCALE 1
-_ACEOF
-
-
-fi;
-
-if test "x$enable_ipv6" != xno
-then
+if test x"$enable_ipv6" != x"no"; then
 	echo "$as_me:$LINENO: checking ipv6 stack type" >&5
 echo $ECHO_N "checking ipv6 stack type... $ECHO_C" >&6
 	for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
 		case $i in
 		inria)
 			# http://www.kame.net/
@@ -3679,12 +3651,26 @@
   test "$ac_cv_search_getaddrinfo" = "none required" || LIBS="$ac_cv_search_getaddrinfo $LIBS"
 
 fi
 
 fi
 
+# Check whether --enable-locale or --disable-locale was given.
+if test "${enable_locale+set}" = set; then
+  enableval="$enable_locale"
+
+fi;
+
+
+if test x"$enable_locale" != x"no"; then
+	cat >>confdefs.h <<\_ACEOF
+#define CONFIG_LOCALE 1
+_ACEOF
+
+fi
+
 echo "$as_me:$LINENO: checking whether to call shutdown on all sockets" >&5
 echo $ECHO_N "checking whether to call shutdown on all sockets... $ECHO_C" >&6
 case $host_os in
 	*cygwin* ) echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6
 
@@ -4643,17 +4629,21 @@
 
 
 
 
 
 
+
+
+
+
 for ac_header in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
     sys/un.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
-    netdb.h malloc.h float.h
+    netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
@@ -8918,20 +8908,19 @@
 #define HAVE_CONNECT 1
 _ACEOF
 
     fi
 fi
 
-
-echo "$as_me:$LINENO: checking for inet_ntop in -lresolv" >&5
-echo $ECHO_N "checking for inet_ntop in -lresolv... $ECHO_C" >&6
-if test "${ac_cv_lib_resolv_inet_ntop+set}" = set; then
+echo "$as_me:$LINENO: checking for library containing inet_ntop" >&5
+echo $ECHO_N "checking for library containing inet_ntop... $ECHO_C" >&6
+if test "${ac_cv_search_inet_ntop+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lresolv  $LIBS"
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_inet_ntop=no
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
@@ -8969,31 +8958,210 @@
 	 { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_resolv_inet_ntop=yes
+  ac_cv_search_inet_ntop="none required"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_resolv_inet_ntop=no
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+if test "$ac_cv_search_inet_ntop" = no; then
+  for ac_lib in resolv; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char inet_ntop ();
+int
+main ()
+{
+inet_ntop ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_inet_ntop="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_resolv_inet_ntop" >&5
-echo "${ECHO_T}$ac_cv_lib_resolv_inet_ntop" >&6
-if test $ac_cv_lib_resolv_inet_ntop = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBRESOLV 1
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_inet_ntop" >&5
+echo "${ECHO_T}$ac_cv_search_inet_ntop" >&6
+if test "$ac_cv_search_inet_ntop" != no; then
+  test "$ac_cv_search_inet_ntop" = "none required" || LIBS="$ac_cv_search_inet_ntop $LIBS"
+
+fi
+
+
+# Solaris and HP-UX weirdness:
+# Search for libiconv_open (not iconv_open) to discover if -liconv is needed!
+echo "$as_me:$LINENO: checking for library containing libiconv_open" >&5
+echo $ECHO_N "checking for library containing libiconv_open... $ECHO_C" >&6
+if test "${ac_cv_search_libiconv_open+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_libiconv_open=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
 _ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-  LIBS="-lresolv $LIBS"
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char libiconv_open ();
+int
+main ()
+{
+libiconv_open ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_libiconv_open="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_libiconv_open" = no; then
+  for ac_lib in iconv; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char libiconv_open ();
+int
+main ()
+{
+libiconv_open ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_libiconv_open="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_libiconv_open" >&5
+echo "${ECHO_T}$ac_cv_search_libiconv_open" >&6
+if test "$ac_cv_search_libiconv_open" != no; then
+  test "$ac_cv_search_libiconv_open" = "none required" || LIBS="$ac_cv_search_libiconv_open $LIBS"
 
 fi
 
 
 
 
@@ -10784,17 +10952,27 @@
 
 
 
 
 
 
-for ac_func in waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo \
-    fchmod fstat strchr readlink link utime utimes strftime mtrace ftruncate \
+
+
+
+
+
+
+
+
+for ac_func in waitpid wait4 getcwd strdup chown chmod lchmod mknod mkfifo \
+    fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \
     memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
-    setlocale setmode open64 lseek64 mkstemp64 va_copy __va_copy
+    setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
+    strerror putenv iconv_open locale_charset nl_langinfo \
+    sigaction sigprocmask
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -11176,14 +11354,13 @@
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_SOCKETPAIR 1
 _ACEOF
 
 fi
 
-if test x"$with_included_popt" != x"yes"
-then
+if test x"$with_included_popt" != x"yes"; then
 
 echo "$as_me:$LINENO: checking for poptGetContext in -lpopt" >&5
 echo $ECHO_N "checking for poptGetContext in -lpopt... $ECHO_C" >&6
 if test "${ac_cv_lib_popt_poptGetContext+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -11257,14 +11434,13 @@
 fi
 
 fi
 
 echo "$as_me:$LINENO: checking whether to use included libpopt" >&5
 echo $ECHO_N "checking whether to use included libpopt... $ECHO_C" >&6
-if test x"$with_included_popt" = x"yes"
-then
+if test x"$with_included_popt" = x"yes"; then
     echo "$as_me:$LINENO: result: $srcdir/popt" >&5
 echo "${ECHO_T}$srcdir/popt" >&6
     BUILD_POPT='$(popt_OBJS)'
     CFLAGS="$CFLAGS -I$srcdir/popt"
     if test x"$ALLOCA" != x
     then
@@ -11791,13 +11967,13 @@
 
 #include <stdio.h>
 #include <sys/stat.h>
 #include <errno.h>
 main() { int rc, ec; char *fn = "fifo-test";
 unlink(fn); rc = mknod(fn,S_IFIFO,0600); ec = errno; unlink(fn);
-if (rc) {printf("%d %d\n",rc,ec); return ec;}
+if (rc) {printf("(%d %d) ",rc,ec); return ec;}
 return 0;}
 _ACEOF
 rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
@@ -11848,13 +12024,13 @@
 
 #include <stdio.h>
 #include <sys/stat.h>
 #include <errno.h>
 main() { int rc, ec; char *fn = "sock-test";
 unlink(fn); rc = mknod(fn,S_IFSOCK,0600); ec = errno; unlink(fn);
-if (rc) {printf("%d %d\n",rc,ec); return ec;}
+if (rc) {printf("(%d %d) ",rc,ec); return ec;}
 return 0;}
 _ACEOF
 rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/configure.in	2005-07-29 03:31:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/configure.in	2006-03-12 02:25:04.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.59)
 
-RSYNC_VERSION=2.6.6
+RSYNC_VERSION=2.6.7
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -23,76 +23,68 @@
 AC_PROG_CC_STDC
 AC_SUBST(SHELL)
 
 AC_DEFINE([_GNU_SOURCE], 1,
           [Define _GNU_SOURCE so that we get all necessary prototypes])
 
-if test "x$ac_cv_prog_cc_stdc" = xno
-then
+if test x"$ac_cv_prog_cc_stdc" = x"no"; then
 	AC_MSG_WARN([rsync requires an ANSI C compiler and you don't seem to have one])
 fi
 
 # We must decide this before testing the compiler.
 
 # Please allow this to default to yes, so that your users have more
 # chance of getting a useful stack trace if problems occur.
 
 AC_MSG_CHECKING([whether to include debugging symbols])
 AC_ARG_ENABLE(debug,
-	AC_HELP_STRING([--enable-debug],
-		[including debugging symbols and features (default yes)]),
-		[], [])
+	AC_HELP_STRING([--disable-debug],
+		[turn off debugging symbols and features]))
 
-if test x"$enable_debug" = x"no"
-then
+if test x"$enable_debug" = x"no"; then
     AC_MSG_RESULT(no)
     CFLAGS=${CFLAGS-"-O"}
 else
     AC_MSG_RESULT([yes])
     # leave CFLAGS alone; AC_PROG_CC will try to include -g if it can
     dnl AC_DEFINE(DEBUG, 1, [Define to turn on debugging code that may slow normal operation])
     dnl CFLAGS=${CFLAGS-"-g"}
 fi
 
 
 AC_ARG_ENABLE(profile,
 	AC_HELP_STRING([--enable-profile],
-		[turn on CPU profiling (default no)],
-		[], []))
-if test x"$enable_profile" = xyes
-then
+		[turn on CPU profiling]))
+if test x"$enable_profile" = x"yes"; then
 	CFLAGS="$CFLAGS -pg"
 fi
 
 
 # Specifically, this turns on panic_action handling.
 AC_ARG_ENABLE(maintainer-mode,
 	AC_HELP_STRING([--enable-maintainer-mode],
-		[turn on extra debug features],
-		[], []))
-if test x"$enable_maintainer_mode" = xyes
-then
+		[turn on extra debug features]))
+if test x"$enable_maintainer_mode" = x"yes"; then
 	CFLAGS="$CFLAGS -DMAINTAINER_MODE"
 fi
 
 
 # This is needed for our included version of popt.  Kind of silly, but
 # I don't want our version too far out of sync.
 CFLAGS="$CFLAGS -DHAVE_CONFIG_H"
 
 # If GCC, turn on warnings.
-if test x"$GCC" = x"yes"
-then
+if test x"$GCC" = x"yes"; then
 	CFLAGS="$CFLAGS -Wall -W"
 fi
 
 AC_ARG_WITH(included-popt,
-        [  --with-included-popt    use bundled popt library, not from system])
+        AC_HELP_STRING([--with-included-popt], [use bundled popt library, not from system]))
 
 AC_ARG_WITH(rsync-path,
-	[  --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)],
+	AC_HELP_STRING([--with-rsync-path=PATH], [set default --rsync-path to PATH (default: rsync)]),
 	[ RSYNC_PATH="$with_rsync_path" ],
 	[ RSYNC_PATH="rsync" ])
 
 AC_DEFINE_UNQUOTED(RSYNC_PATH, "$RSYNC_PATH", [location of rsync on remote machine])
 
 AC_ARG_WITH(rsyncd-conf,
@@ -121,14 +113,13 @@
 
 AC_CHECK_PROG(HAVE_REMSH, remsh, 1, 0)
 if test x$HAVE_REMSH = x1; then
 	AC_DEFINE(HAVE_REMSH, 1, [Define to 1 if remote shell is remsh, not rsh])
 fi
 
-if test x"$with_rsh" != x
-then
+if test x"$with_rsh" != x; then
 	RSYNC_RSH="$with_rsh"
 else
 	RSYNC_RSH="ssh"
 fi
 AC_DEFINE_UNQUOTED(RSYNC_RSH, "$RSYNC_RSH", [default -e command])
 
@@ -141,13 +132,13 @@
     NOBODY_GROUP=nobody # test for others?
 fi
 AC_MSG_RESULT($NOBODY_GROUP)
 AC_DEFINE_UNQUOTED(NOBODY_USER, "nobody", [unprivileged user--e.g. nobody])
 AC_DEFINE_UNQUOTED(NOBODY_GROUP, "$NOBODY_GROUP", [unprivileged group for unprivileged user])
 
-# arrgh. libc in the current debian stable screws up the largefile
+# arrgh. libc in some old debian version screwed up the largefile
 # stuff, getting byte range locking wrong
 AC_CACHE_CHECK([for broken largefile support],rsync_cv_HAVE_BROKEN_LARGEFILE,[
 AC_TRY_RUN([
 #define _FILE_OFFSET_BITS 64
 #include <stdio.h>
 #include <fcntl.h>
@@ -187,27 +178,15 @@
 
 ipv6type=unknown
 ipv6lib=none
 ipv6trylibc=yes
 
 AC_ARG_ENABLE(ipv6,
-	AC_HELP_STRING([--disable-ipv6], [don't even try to use IPv6]))
-
-dnl Do you want to disable use of locale functions
-AH_TEMPLATE([CONFIG_LOCALE],
-[Undefine if you don't want locale features.  By default this is defined.])
-AC_ARG_ENABLE([locale],
-	AC_HELP_STRING([--disable-locale], [turn off locale features]),
-[if test x$enableval = xyes; then
-  AC_DEFINE(CONFIG_LOCALE)
-fi],
-AC_DEFINE(CONFIG_LOCALE)
-)
-
-if test "x$enable_ipv6" != xno
-then
+	AC_HELP_STRING([--disable-ipv6],
+		[don't even try to use IPv6]))
+if test x"$enable_ipv6" != x"no"; then
 	AC_MSG_CHECKING([ipv6 stack type])
 	for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
 		case $i in
 		inria)
 			# http://www.kame.net/
 			AC_EGREP_CPP(yes, [
@@ -290,12 +269,22 @@
 	done
 	AC_MSG_RESULT($ipv6type)
 
 	AC_SEARCH_LIBS(getaddrinfo, inet6)
 fi
 
+dnl Do you want to disable use of locale functions
+AC_ARG_ENABLE([locale],
+	AC_HELP_STRING([--disable-locale],
+		[turn off locale features]))
+AH_TEMPLATE([CONFIG_LOCALE],
+[Undefine if you don't want locale features.  By default this is defined.])
+if test x"$enable_locale" != x"no"; then
+	AC_DEFINE(CONFIG_LOCALE)
+fi
+
 AC_MSG_CHECKING([whether to call shutdown on all sockets])
 case $host_os in
 	*cygwin* ) AC_MSG_RESULT(yes)
                    AC_DEFINE(SHUTDOWN_ALL_SOCKETS, 1,
 			    [Define to 1 if sockets need to be shutdown])
 		   ;;
@@ -307,13 +296,13 @@
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
     sys/un.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
-    netdb.h malloc.h float.h)
+    netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h)
 AC_HEADER_MAJOR
 
 AC_CHECK_SIZEOF(int)
 AC_CHECK_SIZEOF(long)
 AC_CHECK_SIZEOF(long long)
 AC_CHECK_SIZEOF(short)
@@ -374,13 +363,17 @@
         # ac_cv_func_connect=yes
         # don't!  it would cause AC_CHECK_FUNC to succeed next time configure is run
         AC_DEFINE(HAVE_CONNECT, 1, [Define to 1 if you have the "connect" function])
     fi
 fi
 
-AC_CHECK_LIB(resolv, inet_ntop)
+AC_SEARCH_LIBS(inet_ntop, resolv)
+
+# Solaris and HP-UX weirdness:
+# Search for libiconv_open (not iconv_open) to discover if -liconv is needed!
+AC_SEARCH_LIBS(libiconv_open, iconv)
 
 dnl AC_MSG_NOTICE([Looking in libraries: $LIBS])
 
 AC_CHECK_FUNCS(inet_ntop, , [AC_LIBOBJ(lib/inet_ntop)])
 AC_CHECK_FUNCS(inet_pton, , [AC_LIBOBJ(lib/inet_pton)])
 
@@ -493,17 +486,19 @@
 dnl need to do is test for equality, not comparison, and it seems that
 dnl every platform has a memcmp that can do at least that.
 dnl AC_FUNC_MEMCMP
 
 AC_FUNC_UTIME_NULL
 AC_FUNC_ALLOCA
-AC_CHECK_FUNCS(waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo \
-    fchmod fstat strchr readlink link utime utimes strftime mtrace ftruncate \
+AC_CHECK_FUNCS(waitpid wait4 getcwd strdup chown chmod lchmod mknod mkfifo \
+    fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \
     memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
-    setlocale setmode open64 lseek64 mkstemp64 va_copy __va_copy)
+    setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
+    strerror putenv iconv_open locale_charset nl_langinfo \
+    sigaction sigprocmask)
 
 AC_CHECK_FUNCS(getpgrp tcgetpgrp)
 if test $ac_cv_func_getpgrp = yes; then
     AC_FUNC_GETPGRP
 fi
 
@@ -538,20 +533,18 @@
 }],
 rsync_cv_HAVE_SOCKETPAIR=yes,rsync_cv_HAVE_SOCKETPAIR=no,rsync_cv_HAVE_SOCKETPAIR=cross)])
 if test x"$rsync_cv_HAVE_SOCKETPAIR" = x"yes"; then
     AC_DEFINE(HAVE_SOCKETPAIR, 1, [Define to 1 if you have the "socketpair" function])
 fi
 
-if test x"$with_included_popt" != x"yes"
-then
+if test x"$with_included_popt" != x"yes"; then
     AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])
 fi
 
 AC_MSG_CHECKING([whether to use included libpopt])
-if test x"$with_included_popt" = x"yes"
-then
+if test x"$with_included_popt" = x"yes"; then
     AC_MSG_RESULT($srcdir/popt)
     BUILD_POPT='$(popt_OBJS)'
     CFLAGS="$CFLAGS -I$srcdir/popt"
     if test x"$ALLOCA" != x
     then
 	# this can be removed when/if we add an included alloca.c;
@@ -690,13 +683,13 @@
 AC_TRY_RUN([
 #include <stdio.h>
 #include <sys/stat.h>
 #include <errno.h>
 main() { int rc, ec; char *fn = "fifo-test";
 unlink(fn); rc = mknod(fn,S_IFIFO,0600); ec = errno; unlink(fn);
-if (rc) {printf("%d %d\n",rc,ec); return ec;}
+if (rc) {printf("(%d %d) ",rc,ec); return ec;}
 return 0;}],
            rsync_cv_MKNOD_CREATES_FIFOS=yes,rsync_cv_MKNOD_CREATES_FIFOS=no,rsync_cv_MKNOD_CREATES_FIFOS=cross)])
 if test x"$rsync_cv_MKNOD_CREATES_FIFOS" = x"yes"; then
     AC_DEFINE(MKNOD_CREATES_FIFOS, 1, [Define to 1 if mknod() can create FIFOs.])
 fi
 
@@ -704,13 +697,13 @@
 AC_TRY_RUN([
 #include <stdio.h>
 #include <sys/stat.h>
 #include <errno.h>
 main() { int rc, ec; char *fn = "sock-test";
 unlink(fn); rc = mknod(fn,S_IFSOCK,0600); ec = errno; unlink(fn);
-if (rc) {printf("%d %d\n",rc,ec); return ec;}
+if (rc) {printf("(%d %d) ",rc,ec); return ec;}
 return 0;}],
            rsync_cv_MKNOD_CREATES_SOCKETS=yes,rsync_cv_MKNOD_CREATES_SOCKETS=no,rsync_cv_MKNOD_CREATES_SOCKETS=cross)])
 if test x"$rsync_cv_MKNOD_CREATES_SOCKETS" = x"yes"; then
     AC_DEFINE(MKNOD_CREATES_SOCKETS, 1, [Define to 1 if mknod() can create sockets.])
 fi
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/errcode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/errcode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/errcode.h	2005-04-13 07:04:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/errcode.h	2005-12-17 07:48:28.000000000 +0800
@@ -31,14 +31,17 @@
 
 #define RERR_SOCKETIO   10      /* error in socket IO */
 #define RERR_FILEIO     11      /* error in file IO */
 #define RERR_STREAMIO   12      /* error in rsync protocol data stream */
 #define RERR_MESSAGEIO  13      /* errors with program diagnostics */
 #define RERR_IPC        14      /* error in IPC code */
+#define RERR_CRASHED    15      /* sibling crashed */
+#define RERR_TERMINATED 16      /* sibling terminated abnormally */
 
-#define RERR_SIGNAL     20      /* status returned when sent SIGUSR1, SIGINT */
+#define RERR_SIGNAL1    19      /* status returned when sent SIGUSR1 */
+#define RERR_SIGNAL     20      /* status returned when sent SIGINT, SIGTERM, SIGHUP */
 #define RERR_WAITCHILD  21      /* some error returned by waitpid() */
 #define RERR_MALLOC     22      /* error allocating core memory buffers */
 #define RERR_PARTIAL    23      /* partial transfer */
 #define RERR_VANISHED   24      /* file(s) vanished on sender side */
 #define RERR_DEL_LIMIT  25      /* skipped some deletes due to --max-delete */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/exclude.c	2005-07-08 03:49:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/exclude.c	2006-01-28 08:14:02.000000000 +0800
@@ -31,26 +31,29 @@
 extern int am_sender;
 extern int eol_nulls;
 extern int list_only;
 extern int recurse;
 extern int io_error;
 extern int local_server;
+extern int saw_delete_opt;
+extern int saw_delete_excluded_opt;
+extern int prune_empty_dirs;
 extern int delete_mode;
 extern int delete_excluded;
 extern int cvs_exclude;
 extern int sanitize_paths;
 extern int protocol_version;
 extern int module_id;
 
 extern char curr_dir[];
 extern unsigned int curr_dir_len;
 extern unsigned int module_dirlen;
 
 struct filter_list_struct filter_list = { 0, 0, "" };
-struct filter_list_struct cvs_filter_list = { 0, 0, " [cvsignore]" };
-struct filter_list_struct server_filter_list = { 0, 0, " [server]" };
+struct filter_list_struct cvs_filter_list = { 0, 0, " [global CVS]" };
+struct filter_list_struct server_filter_list = { 0, 0, " [daemon]" };
 
 /* Need room enough for ":MODS " prefix plus some room to grow. */
 #define MAX_RULE_PREFIX (16)
 
 #define MODIFIERS_MERGE_FILE "-+Cenw"
 #define MODIFIERS_INCL_EXCL "/!Crs"
@@ -130,15 +133,15 @@
 			who_am_i(), get_rule_prefix(mflags, pat, 0, NULL),
 			(int)pat_len, pat,
 			(mflags & MATCHFLG_DIRECTORY) ? "/" : "",
 			listp->debug_type);
 	}
 
-	/* This flag also indicates that we're reading a list that
+	/* These flags also indicate that we're reading a list that
 	 * needs to be filtered now, not post-filtered later. */
-	if (xflags & XFLG_ANCHORED2ABS) {
+	if (xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH)) {
 		uint32 mf = mflags & (MATCHFLG_RECEIVER_SIDE|MATCHFLG_SENDER_SIDE);
 		if (am_sender) {
 			if (mf == MATCHFLG_RECEIVER_SIDE)
 				return;
 		} else {
 			if (mf == MATCHFLG_SENDER_SIDE)
@@ -147,16 +150,20 @@
 	}
 
 	if (!(ret = new(struct filter_struct)))
 		out_of_memory("add_rule");
 	memset(ret, 0, sizeof ret[0]);
 
-	if (xflags & XFLG_ANCHORED2ABS && *pat == '/'
-	    && !(mflags & (MATCHFLG_ABS_PATH | MATCHFLG_MERGE_FILE))) {
+	if (!(mflags & (MATCHFLG_ABS_PATH | MATCHFLG_MERGE_FILE))
+	 && ((xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH) && *pat == '/')
+	  || (xflags & XFLG_ABS_IF_SLASH && strchr(pat, '/') != NULL))) {
 		mflags |= MATCHFLG_ABS_PATH;
-		ex_len = dirbuf_len - module_dirlen - 1;
+		if (*pat == '/')
+			ex_len = dirbuf_len - module_dirlen - 1;
+		else
+			ex_len = 0;
 	} else
 		ex_len = 0;
 	if (!(ret->pattern = new_array(char, ex_len + pat_len + 1)))
 		out_of_memory("add_rule");
 	if (ex_len)
 		memcpy(ret->pattern, dirbuf + module_dirlen, ex_len);
@@ -167,12 +174,18 @@
 		mflags |= MATCHFLG_WILD;
 		if ((cp = strstr(ret->pattern, "**")) != NULL) {
 			mflags |= MATCHFLG_WILD2;
 			/* If the pattern starts with **, note that. */
 			if (cp == ret->pattern)
 				mflags |= MATCHFLG_WILD2_PREFIX;
+			/* If the pattern ends with ***, note that. */
+			if (pat_len >= 3
+			 && ret->pattern[pat_len-3] == '*'
+			 && ret->pattern[pat_len-2] == '*'
+			 && ret->pattern[pat_len-1] == '*')
+				mflags |= MATCHFLG_WILD3_SUFFIX;
 		}
 	}
 
 	if (pat_len > 1 && ret->pattern[pat_len-1] == '/') {
 		ret->pattern[pat_len-1] = 0;
 		mflags |= MATCHFLG_DIRECTORY;
@@ -289,27 +302,26 @@
 			char *to = fn == buf ? tmpbuf : buf;
 			strlcpy(to, merge_file, *len_ptr + 1);
 			merge_file = to;
 		}
 		if (!sanitize_path(fn, merge_file, r, dirbuf_depth)) {
 			rprintf(FERROR, "merge-file name overflows: %s\n",
-				safe_fname(merge_file));
+				merge_file);
 			return NULL;
 		}
 	} else {
 		strlcpy(fn, merge_file, len_ptr ? *len_ptr + 1 : MAXPATHLEN);
 		clean_fname(fn, 1);
 	}
 	
 	fn_len = strlen(fn);
 	if (fn == buf)
 		goto done;
 
 	if (dirbuf_len + fn_len >= MAXPATHLEN) {
-		rprintf(FERROR, "merge-file name overflows: %s\n",
-			safe_fname(fn));
+		rprintf(FERROR, "merge-file name overflows: %s\n", fn);
 		return NULL;
 	}
 	memcpy(buf, dirbuf + prefix_skip, dirbuf_len - prefix_skip);
 	memcpy(buf + dirbuf_len - prefix_skip, fn, fn_len + 1);
 	fn_len = clean_fname(buf, 1);
 
@@ -485,76 +497,74 @@
 
 	free(pop);
 }
 
 static int rule_matches(char *name, struct filter_struct *ex, int name_is_dir)
 {
-	char *p, full_name[MAXPATHLEN];
-	int match_start = 0;
+	int slash_handling, str_cnt = 0, anchored_match = 0;
 	int ret_match = ex->match_flags & MATCHFLG_NEGATE ? 0 : 1;
-	char *pattern = ex->pattern;
+	char *p, *pattern = ex->pattern;
+	const char *strings[16]; /* more than enough */
 
 	if (!*name)
 		return 0;
 
-	/* If the pattern does not have any slashes AND it does not have
-	 * a "**" (which could match a slash), then we just match the
-	 * name portion of the path. */
 	if (!ex->u.slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
+		/* If the pattern does not have any slashes AND it does
+		 * not have a "**" (which could match a slash), then we
+		 * just match the name portion of the path. */
 		if ((p = strrchr(name,'/')) != NULL)
 			name = p+1;
-	}
-	else if (ex->match_flags & MATCHFLG_ABS_PATH && *name != '/'
+	} else if (ex->match_flags & MATCHFLG_ABS_PATH && *name != '/'
 	    && curr_dir_len > module_dirlen + 1) {
-		pathjoin(full_name, sizeof full_name,
-			 curr_dir + module_dirlen + 1, name);
-		name = full_name;
-	}
-
-	if (ex->match_flags & MATCHFLG_DIRECTORY && !name_is_dir)
+		/* If we're matching against an absolute-path pattern,
+		 * we need to prepend our full path info. */
+		strings[str_cnt++] = curr_dir + module_dirlen + 1;
+		strings[str_cnt++] = "/";
+	} else if (ex->match_flags & MATCHFLG_WILD2_PREFIX && *name != '/') {
+		/* Allow "**"+"/" to match at the start of the string. */
+		strings[str_cnt++] = "/";
+	}
+	strings[str_cnt++] = name;
+	if (name_is_dir) {
+		/* Allow a trailing "/"+"***" to match the directory. */
+		if (ex->match_flags & MATCHFLG_WILD3_SUFFIX)
+			strings[str_cnt++] = "/";
+	} else if (ex->match_flags & MATCHFLG_DIRECTORY)
 		return !ret_match;
+	strings[str_cnt] = NULL;
 
 	if (*pattern == '/') {
-		match_start = 1;
+		anchored_match = 1;
 		pattern++;
-		if (*name == '/')
-			name++;
+		if (strings[0][0] == '/')
+			strings[0]++;
 	}
 
-	if (ex->match_flags & MATCHFLG_WILD) {
+	if (!anchored_match && ex->u.slash_cnt
+	    && !(ex->match_flags & MATCHFLG_WILD2)) {
 		/* A non-anchored match with an infix slash and no "**"
 		 * needs to match the last slash_cnt+1 name elements. */
-		if (!match_start && ex->u.slash_cnt
-		    && !(ex->match_flags & MATCHFLG_WILD2)) {
-			int cnt = ex->u.slash_cnt + 1;
-			for (p = name + strlen(name) - 1; p >= name; p--) {
-				if (*p == '/' && !--cnt)
-					break;
-			}
-			name = p+1;
-		}
-		if (wildmatch(pattern, name))
+		slash_handling = ex->u.slash_cnt + 1;
+	} else if (!anchored_match && !(ex->match_flags & MATCHFLG_WILD2_PREFIX)
+				   && ex->match_flags & MATCHFLG_WILD2) {
+		/* A non-anchored match with an infix or trailing "**" (but not
+		 * a prefixed "**") needs to try matching after every slash. */
+		slash_handling = -1;
+	} else {
+		/* The pattern matches only at the start of the path or name. */
+		slash_handling = 0;
+	}
+
+	if (ex->match_flags & MATCHFLG_WILD) {
+		if (wildmatch_array(pattern, strings, slash_handling))
 			return ret_match;
-		if (ex->match_flags & MATCHFLG_WILD2_PREFIX) {
-			/* If the **-prefixed pattern has a '/' as the next
-			 * character, then try to match the rest of the
-			 * pattern at the root. */
-			if (pattern[2] == '/' && wildmatch(pattern+3, name))
-				return ret_match;
-		}
-		else if (!match_start && ex->match_flags & MATCHFLG_WILD2) {
-			/* A non-anchored match with an infix or trailing "**"
-			 * (but not a prefixed "**") needs to try matching
-			 * after every slash. */
-			while ((name = strchr(name, '/')) != NULL) {
-				name++;
-				if (wildmatch(pattern, name))
-					return ret_match;
-			}
-		}
-	} else if (match_start) {
+	} else if (str_cnt > 1) {
+		if (litmatch_array(pattern, strings, slash_handling))
+			return ret_match;
+	} else if (anchored_match) {
 		if (strcmp(name,pattern) == 0)
 			return ret_match;
 	} else {
 		int l1 = strlen(name);
 		int l2 = strlen(pattern);
 		if (l2 <= l1 &&
@@ -574,17 +584,19 @@
 {
 	/* If a trailing slash is present to match only directories,
 	 * then it is stripped out by add_rule().  So as a special
 	 * case we add it back in here. */
 
 	if (verbose >= 2) {
-		rprintf(FINFO, "[%s] %scluding %s %s because of pattern %s%s%s\n",
-			who_am_i(),
-			ent->match_flags & MATCHFLG_INCLUDE ? "in" : "ex",
-			name_is_dir ? "directory" : "file", name, ent->pattern,
-			ent->match_flags & MATCHFLG_DIRECTORY ? "/" : "", type);
+		static char *actions[2][2]
+		    = { {"show", "hid"}, {"risk", "protect"} };
+		const char *w = who_am_i();
+		rprintf(FINFO, "[%s] %sing %s %s because of pattern %s%s%s\n",
+		    w, actions[*w!='s'][!(ent->match_flags&MATCHFLG_INCLUDE)],
+		    name_is_dir ? "directory" : "file", name, ent->pattern,
+		    ent->match_flags & MATCHFLG_DIRECTORY ? "/" : "", type);
 	}
 }
 
 
 /*
  * Return -1 if file "name" is defined to be excluded by the specified
@@ -824,13 +836,14 @@
 			cp++;
 		len = cp - s;
 	} else
 		len = strlen((char*)s);
 
 	if (new_mflags & MATCHFLG_CLEAR_LIST) {
-		if (!(xflags & XFLG_OLD_PREFIXES) && len) {
+		if (!(mflags & MATCHFLG_NO_PREFIXES)
+		 && !(xflags & XFLG_OLD_PREFIXES) && len) {
 			rprintf(FERROR,
 				"'!' rule has trailing characters: %s\n", p);
 			exit_cleanup(RERR_SYNTAX);
 		}
 		if (len > 1)
 			new_mflags &= ~MATCHFLG_CLEAR_LIST;
@@ -951,13 +964,13 @@
 
 
 void parse_filter_file(struct filter_list_struct *listp, const char *fname,
 		       uint32 mflags, int xflags)
 {
 	FILE *fp;
-	char line[MAXPATHLEN+MAX_RULE_PREFIX+1]; /* +1 for trailing slash. */
+	char line[BIGPATHBUFLEN];
 	char *eob = line + sizeof line - 1;
 	int word_split = mflags & MATCHFLG_WORD_SPLIT;
 
 	if (!fname || !*fname)
 		return;
 
@@ -973,35 +986,37 @@
 			fp = fopen(fname, "rb");
 	} else
 		fp = stdin;
 
 	if (verbose > 2) {
 		rprintf(FINFO, "[%s] parse_filter_file(%s,%x,%x)%s\n",
-			who_am_i(), safe_fname(fname), mflags, xflags,
+			who_am_i(), fname, mflags, xflags,
 			fp ? "" : " [not found]");
 	}
 
 	if (!fp) {
 		if (xflags & XFLG_FATAL_ERRORS) {
 			rsyserr(FERROR, errno,
 				"failed to open %sclude file %s",
 				mflags & MATCHFLG_INCLUDE ? "in" : "ex",
-				safe_fname(fname));
+				fname);
 			exit_cleanup(RERR_FILEIO);
 		}
 		return;
 	}
 	dirbuf[dirbuf_len] = '\0';
 
 	while (1) {
 		char *s = line;
 		int ch, overflow = 0;
 		while (1) {
 			if ((ch = getc(fp)) == EOF) {
-				if (ferror(fp) && errno == EINTR)
+				if (ferror(fp) && errno == EINTR) {
+					clearerr(fp);
 					continue;
+				}
 				break;
 			}
 			if (word_split && isspace(ch))
 				break;
 			if (eol_nulls? !ch : (ch == '\n' || ch == '\r'))
 				break;
@@ -1132,14 +1147,14 @@
 	flp->tail = prev;
 }
 
 /* This is only called by the client. */
 void send_filter_list(int f_out)
 {
-	int receiver_wants_list = delete_mode
-		&& (!delete_excluded || protocol_version >= 29);
+	int receiver_wants_list = prune_empty_dirs
+	    || (delete_mode && (!delete_excluded || protocol_version >= 29));
 
 	if (local_server || (am_sender && !receiver_wants_list))
 		f_out = -1;
 	if (cvs_exclude && am_sender) {
 		if (protocol_version >= 29)
 			parse_rule(&filter_list, ":C", 0, 0);
@@ -1164,16 +1179,17 @@
 	}
 }
 
 /* This is only called by the server. */
 void recv_filter_list(int f_in)
 {
-	char line[MAXPATHLEN+MAX_RULE_PREFIX+1]; /* +1 for trailing slash. */
+	char line[BIGPATHBUFLEN];
 	int xflags = protocol_version >= 29 ? 0 : XFLG_OLD_PREFIXES;
-	int receiver_wants_list = delete_mode
-		&& (!delete_excluded || protocol_version >= 29);
+	int receiver_wants_list = prune_empty_dirs
+	    || (saw_delete_opt
+	     && (!saw_delete_excluded_opt || protocol_version >= 29));
 	unsigned int len;
 
 	if (!local_server && (am_sender || receiver_wants_list)) {
 		while ((len = read_int(f_in)) != 0) {
 			if (len >= sizeof line)
 				overflow_exit("recv_rules");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/fileio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/fileio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/fileio.c	2005-02-28 05:12:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/fileio.c	2005-09-22 01:37:41.000000000 +0800
@@ -19,12 +19,16 @@
 
 /*
   File IO utilities used in rsync
   */
 #include "rsync.h"
 
+#ifndef ENODATA
+#define ENODATA EAGAIN
+#endif
+
 extern int sparse_files;
 
 static char last_byte;
 static int last_sparse;
 
 int sparse_end(int f)
@@ -214,40 +218,41 @@
 	}
 
 	if (read_size <= 0) {
 		rprintf(FERROR, "invalid read_size of %ld in map_ptr\n",
 			(long)read_size);
 		exit_cleanup(RERR_FILEIO);
-	} else {
-		if (map->p_fd_offset != read_start) {
-			OFF_T ret = do_lseek(map->fd, read_start, SEEK_SET);
-			if (ret != read_start) {
-				rsyserr(FERROR, errno,
-					"lseek returned %.0f, not %.0f",
-					(double)ret, (double)read_start);
-				exit_cleanup(RERR_FILEIO);
-			}
-			map->p_fd_offset = read_start;
-		}
+	}
 
-		if ((nread=read(map->fd,map->p + read_offset,read_size)) != read_size) {
-			if (nread < 0) {
-				nread = 0;
-				if (!map->status)
-					map->status = errno;
-			}
-			/* the best we can do is zero the buffer - the file
-			   has changed mid transfer! */
-			memset(map->p+read_offset+nread, 0, read_size - nread);
+	if (map->p_fd_offset != read_start) {
+		OFF_T ret = do_lseek(map->fd, read_start, SEEK_SET);
+		if (ret != read_start) {
+			rsyserr(FERROR, errno, "lseek returned %.0f, not %.0f",
+				(double)ret, (double)read_start);
+			exit_cleanup(RERR_FILEIO);
 		}
-		map->p_fd_offset += nread;
+		map->p_fd_offset = read_start;
 	}
-
+	map->p_fd_offset += read_size;
 	map->p_offset = window_start;
 	map->p_len = window_size;
 
+	while (read_size > 0) {
+		nread = read(map->fd, map->p + read_offset, read_size);
+		if (nread <= 0) {
+			if (!map->status)
+				map->status = nread ? errno : ENODATA;
+			/* The best we can do is zero the buffer -- the file
+			 * has changed mid transfer! */
+			memset(map->p + read_offset, 0, read_size);
+			break;
+		}
+		read_offset += nread;
+		read_size -= nread;
+	}
+
 	return map->p;
 }
 
 
 int unmap_file(struct map_struct *map)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/flist.c	2005-07-08 03:49:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/flist.c	2006-02-25 01:54:35.000000000 +0800
@@ -25,13 +25,12 @@
  *
  **/
 
 #include "rsync.h"
 
 extern int verbose;
-extern int dry_run;
 extern int list_only;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
 extern int am_sender;
 extern int do_progress;
@@ -40,54 +39,58 @@
 extern int ignore_errors;
 extern int numeric_ids;
 extern int recurse;
 extern int xfer_dirs;
 extern int filesfrom_fd;
 extern int one_file_system;
+extern int copy_dirlinks;
 extern int keep_dirlinks;
 extern int preserve_links;
 extern int preserve_hard_links;
-extern int preserve_perms;
 extern int preserve_devices;
+extern int preserve_specials;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int relative_paths;
 extern int implied_dirs;
+extern int prune_empty_dirs;
 extern int copy_links;
 extern int copy_unsafe_links;
 extern int protocol_version;
 extern int sanitize_paths;
-extern int orig_umask;
+extern const char *io_write_phase;
 extern struct stats stats;
 extern struct file_list *the_file_list;
 
 extern char curr_dir[MAXPATHLEN];
 
+extern struct chmod_mode_struct *chmod_modes;
+
 extern struct filter_list_struct filter_list;
 extern struct filter_list_struct server_filter_list;
 
 int io_error;
+int checksum_len;
 dev_t filesystem_dev; /* used to implement -x */
+unsigned int file_struct_len;
 
 static char empty_sum[MD4_SUM_LENGTH];
 static int flist_count_offset;
-static unsigned int file_struct_len;
-static struct file_list *sorting_flist;
 
 static void clean_flist(struct file_list *flist, int strip_root, int no_dups);
 static void output_flist(struct file_list *flist);
 
 void init_flist(void)
 {
 	struct file_struct f;
 
 	/* Figure out how big the file_struct is without trailing padding */
 	file_struct_len = offsetof(struct file_struct, flags) + sizeof f.flags;
+	checksum_len = protocol_version < 21 ? 2 : MD4_SUM_LENGTH;
 }
 
-
 static int show_filelist_p(void)
 {
 	return verbose && xfer_dirs && !am_server;
 }
 
 static void start_filelist_progress(char *kind)
@@ -124,41 +124,39 @@
 
 void show_flist_stats(void)
 {
 	/* Nothing yet */
 }
 
-
 static void list_file_entry(struct file_struct *f)
 {
-	char perms[11];
+	char permbuf[PERMSTRING_SIZE];
 
 	if (!f->basename) {
 		/* this can happen if duplicate names were removed */
 		return;
 	}
 
-	permstring(perms, f->mode);
+	permstring(permbuf, f->mode);
 
 #ifdef SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(f->mode)) {
 		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
-			perms,
+			permbuf,
 			(double)f->length, timestring(f->modtime),
-			safe_fname(f_name(f)), safe_fname(f->u.link));
+			f_name(f, NULL), f->u.link);
 	} else
 #endif
 	{
 		rprintf(FINFO, "%s %11.0f %s %s\n",
-			perms,
+			permbuf,
 			(double)f->length, timestring(f->modtime),
-			safe_fname(f_name(f)));
+			f_name(f, NULL));
 	}
 }
 
-
 /**
  * Stat either a symlink or its referent, depending on the settings of
  * copy_links, copy_unsafe_links, etc.
  *
  * @retval -1 on error
  *
@@ -172,23 +170,23 @@
  **/
 static int readlink_stat(const char *path, STRUCT_STAT *buffer, char *linkbuf)
 {
 #ifdef SUPPORT_LINKS
 	if (copy_links)
 		return do_stat(path, buffer);
-	if (link_stat(path, buffer, 0) < 0)
+	if (link_stat(path, buffer, copy_dirlinks) < 0)
 		return -1;
 	if (S_ISLNK(buffer->st_mode)) {
 		int l = readlink((char *)path, linkbuf, MAXPATHLEN - 1);
 		if (l == -1)
 			return -1;
 		linkbuf[l] = 0;
 		if (copy_unsafe_links && unsafe_symlink(linkbuf, path)) {
 			if (verbose > 1) {
 				rprintf(FINFO,"copying unsafe symlink \"%s\" -> \"%s\"\n",
-					safe_fname(path), safe_fname(linkbuf));
+					path, linkbuf);
 			}
 			return do_stat(path, buffer);
 		}
 	}
 	return 0;
 #else
@@ -307,13 +304,13 @@
 	flist->files = new_ptr;
 
 	if (!flist->files)
 		out_of_memory("flist_expand");
 }
 
-void send_file_entry(struct file_struct *file, int f, unsigned short base_flags)
+static void send_file_entry(struct file_struct *file, int f)
 {
 	unsigned short flags;
 	static time_t modtime;
 	static mode_t mode;
 	static int64 dev;
 	static dev_t rdev;
@@ -336,39 +333,38 @@
 		*lastname = '\0';
 		return;
 	}
 
 	io_write_phase = "send_file_entry";
 
-	f_name_to(file, fname);
+	f_name(file, fname);
 
-	flags = base_flags;
+	flags = file->flags & XMIT_TOP_DIR;
 
 	if (file->mode == mode)
 		flags |= XMIT_SAME_MODE;
 	else
 		mode = file->mode;
-	if (preserve_devices) {
+	if ((preserve_devices && IS_DEVICE(mode))
+	 || (preserve_specials && IS_SPECIAL(mode))) {
 		if (protocol_version < 28) {
-			if (IS_DEVICE(mode)) {
-				if (file->u.rdev == rdev)
-					flags |= XMIT_SAME_RDEV_pre28;
-				else
-					rdev = file->u.rdev;
-			} else
-				rdev = makedev(0, 0);
-		} else if (IS_DEVICE(mode)) {
+			if (file->u.rdev == rdev)
+				flags |= XMIT_SAME_RDEV_pre28;
+			else
+				rdev = file->u.rdev;
+		} else {
 			rdev = file->u.rdev;
 			if ((uint32)major(rdev) == rdev_major)
 				flags |= XMIT_SAME_RDEV_MAJOR;
 			else
 				rdev_major = major(rdev);
 			if ((uint32)minor(rdev) <= 0xFFu)
 				flags |= XMIT_RDEV_MINOR_IS_SMALL;
 		}
-	}
+	} else if (protocol_version < 28)
+		rdev = makedev(0, 0);
 	if (file->uid == uid)
 		flags |= XMIT_SAME_UID;
 	else
 		uid = file->uid;
 	if (file->gid == gid)
 		flags |= XMIT_SAME_GID;
@@ -411,16 +407,14 @@
 			flags |= XMIT_EXTENDED_FLAGS;
 			write_byte(f, flags);
 			write_byte(f, flags >> 8);
 		} else
 			write_byte(f, flags);
 	} else {
-		if (!(flags & 0xFF) && !S_ISDIR(mode))
-			flags |= XMIT_TOP_DIR;
 		if (!(flags & 0xFF))
-			flags |= XMIT_LONG_NAME;
+			flags |= S_ISDIR(mode) ? XMIT_LONG_NAME : XMIT_TOP_DIR;
 		write_byte(f, flags);
 	}
 	if (flags & XMIT_SAME_NAME)
 		write_byte(f, l1);
 	if (flags & XMIT_LONG_NAME)
 		write_int(f, l2);
@@ -440,13 +434,14 @@
 	}
 	if (preserve_gid && !(flags & XMIT_SAME_GID)) {
 		if (!numeric_ids)
 			add_gid(gid);
 		write_int(f, gid);
 	}
-	if (preserve_devices && IS_DEVICE(mode)) {
+	if ((preserve_devices && IS_DEVICE(mode))
+	 || (preserve_specials && IS_SPECIAL(mode))) {
 		if (protocol_version < 28) {
 			if (!(flags & XMIT_SAME_RDEV_pre28))
 				write_int(f, (int)rdev);
 		} else {
 			if (!(flags & XMIT_SAME_RDEV_MAJOR))
 				write_int(f, major(rdev));
@@ -477,25 +472,21 @@
 				write_longint(f, dev);
 			write_longint(f, file->F_INODE);
 		}
 	}
 #endif
 
-	if (always_checksum) {
+	if (always_checksum && (S_ISREG(mode) || protocol_version < 28)) {
 		char *sum;
 		if (S_ISREG(mode))
 			sum = file->u.sum;
-		else if (protocol_version < 28) {
+		else {
 			/* Prior to 28, we sent a useless set of nulls. */
 			sum = empty_sum;
-		} else
-			sum = NULL;
-		if (sum) {
-			write_buf(f, sum,
-			    protocol_version < 21 ? 2 : MD4_SUM_LENGTH);
 		}
+		write_buf(f, sum, checksum_len);
 	}
 
 	strlcpy(lastname, fname, MAXPATHLEN);
 
 	io_write_phase = "unknown";
 }
@@ -542,13 +531,13 @@
 	else
 		l2 = read_byte(f);
 
 	if (l2 >= MAXPATHLEN - l1) {
 		rprintf(FERROR,
 			"overflow: flags=0x%x l1=%d l2=%d lastname=%s\n",
-			flags, l1, l2, safe_fname(lastname));
+			flags, l1, l2, lastname);
 		overflow_exit("receive_file_entry");
 	}
 
 	strlcpy(thisname, lastname, l1 + 1);
 	read_sbuf(f, &thisname[l1], l2);
 	thisname[l1 + l2] = 0;
@@ -578,35 +567,37 @@
 	file_length = read_longint(f);
 	if (!(flags & XMIT_SAME_TIME))
 		modtime = (time_t)read_int(f);
 	if (!(flags & XMIT_SAME_MODE))
 		mode = from_wire_mode(read_int(f));
 
+	if (chmod_modes && !S_ISLNK(mode))
+		mode = tweak_mode(mode, chmod_modes);
+
 	if (preserve_uid && !(flags & XMIT_SAME_UID))
 		uid = (uid_t)read_int(f);
 	if (preserve_gid && !(flags & XMIT_SAME_GID))
 		gid = (gid_t)read_int(f);
 
-	if (preserve_devices) {
+	if ((preserve_devices && IS_DEVICE(mode))
+	 || (preserve_specials && IS_SPECIAL(mode))) {
 		if (protocol_version < 28) {
-			if (IS_DEVICE(mode)) {
-				if (!(flags & XMIT_SAME_RDEV_pre28))
-					rdev = (dev_t)read_int(f);
-			} else
-				rdev = makedev(0, 0);
-		} else if (IS_DEVICE(mode)) {
+			if (!(flags & XMIT_SAME_RDEV_pre28))
+				rdev = (dev_t)read_int(f);
+		} else {
 			uint32 rdev_minor;
 			if (!(flags & XMIT_SAME_RDEV_MAJOR))
 				rdev_major = read_int(f);
 			if (flags & XMIT_RDEV_MINOR_IS_SMALL)
 				rdev_minor = read_byte(f);
 			else
 				rdev_minor = read_int(f);
 			rdev = makedev(rdev_major, rdev_minor);
 		}
-	}
+	} else if (protocol_version < 28)
+		rdev = makedev(0, 0);
 
 #ifdef SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(mode)) {
 		linkname_len = read_int(f) + 1; /* count the '\0' */
 		if (linkname_len <= 0 || linkname_len > MAXPATHLEN) {
 			rprintf(FERROR, "overflow: linkname_len=%d\n",
@@ -625,13 +616,12 @@
 	bp = pool_alloc(flist->file_pool, alloc_len, "receive_file_entry");
 
 	file = (struct file_struct *)bp;
 	memset(bp, 0, file_struct_len);
 	bp += file_struct_len;
 
-	file->flags = 0;
 	file->modtime = modtime;
 	file->length = file_length;
 	file->mode = mode;
 	file->uid = uid;
 	file->gid = gid;
 
@@ -650,33 +640,35 @@
 		file->dir.depth = 1;
 
 	if (S_ISDIR(mode)) {
 		if (basename_len == 1+1 && *basename == '.') /* +1 for '\0' */
 			file->dir.depth--;
 		if (flags & XMIT_TOP_DIR) {
-			in_del_hier = 1;
+			in_del_hier = recurse;
 			del_hier_name_len = file->dir.depth == 0 ? 0 : l1 + l2;
 			if (relative_paths && del_hier_name_len > 2
-			    && basename_len == 1+1 && *basename == '.')
+			    && lastname[del_hier_name_len-1] == '.'
+			    && lastname[del_hier_name_len-2] == '/')
 				del_hier_name_len -= 2;
 			file->flags |= FLAG_TOP_DIR | FLAG_DEL_HERE;
 		} else if (in_del_hier) {
 			if (!relative_paths || !del_hier_name_len
 			 || (l1 >= del_hier_name_len
-			  && thisname[del_hier_name_len] == '/'))
+			  && lastname[del_hier_name_len] == '/'))
 				file->flags |= FLAG_DEL_HERE;
 			else
 				in_del_hier = 0;
 		}
 	}
 
 	file->basename = bp;
 	memcpy(bp, basename, basename_len);
 	bp += basename_len;
 
-	if (preserve_devices && IS_DEVICE(mode))
+	if ((preserve_devices && IS_DEVICE(mode))
+	 || (preserve_specials && IS_SPECIAL(mode)))
 		file->u.rdev = rdev;
 
 #ifdef SUPPORT_LINKS
 	if (linkname_len) {
 		file->u.link = bp;
 		read_sbuf(f, bp, linkname_len - 1);
@@ -705,38 +697,27 @@
 			file->F_INODE = inode;
 			file->F_DEV = dev;
 		}
 	}
 #endif
 
-	if (always_checksum) {
+	if (always_checksum && (sum_len || protocol_version < 28)) {
 		char *sum;
 		if (sum_len) {
 			file->u.sum = sum = bp;
 			/*bp += sum_len;*/
-		} else if (protocol_version < 28) {
+		} else {
 			/* Prior to 28, we get a useless set of nulls. */
 			sum = empty_sum;
-		} else
-			sum = NULL;
-		if (sum) {
-			read_buf(f, sum,
-			    protocol_version < 21 ? 2 : MD4_SUM_LENGTH);
 		}
-	}
-
-	if (!preserve_perms) {
-		/* set an appropriate set of permissions based on original
-		 * permissions and umask. This emulates what GNU cp does */
-		file->mode &= ~orig_umask;
+		read_buf(f, sum, checksum_len);
 	}
 
 	return file;
 }
 
-
 /**
  * Create a file_struct for a named file by reading its stat()
  * information and performing extensive checks against global
  * options.
  *
  * @return the new file, or NULL if there was an error or this file
@@ -747,41 +728,42 @@
  * We are called immediately after doing readdir(), and so we may
  * already know the d_type of the file.  We could for example avoid
  * statting directories if we're not recursing, but this is not a very
  * important case.  Some systems may not have d_type.
  **/
 struct file_struct *make_file(char *fname, struct file_list *flist,
+			      STRUCT_STAT *stp, unsigned short flags,
 			      int filter_level)
 {
 	static char *lastdir;
 	static int lastdir_len = -1;
 	struct file_struct *file;
 	STRUCT_STAT st;
 	char sum[SUM_LENGTH];
 	char thisname[MAXPATHLEN];
 	char linkname[MAXPATHLEN];
 	int alloc_len, basename_len, dirname_len, linkname_len, sum_len;
 	char *basename, *dirname, *bp;
-	unsigned short flags = 0;
 
 	if (!flist || !flist->count)	/* Ignore lastdir when invalid. */
 		lastdir_len = -1;
 
 	if (strlcpy(thisname, fname, sizeof thisname)
 	    >= sizeof thisname - flist_dir_len) {
-		rprintf(FINFO, "skipping overly long name: %s\n",
-			safe_fname(fname));
+		rprintf(FINFO, "skipping overly long name: %s\n", fname);
 		return NULL;
 	}
 	clean_fname(thisname, 0);
 	if (sanitize_paths)
 		sanitize_path(thisname, thisname, "", 0);
 
 	memset(sum, 0, SUM_LENGTH);
 
-	if (readlink_stat(thisname, &st, linkname) != 0) {
+	if (stp && S_ISDIR(stp->st_mode))
+		st = *stp; /* Needed for "symlink/." with --relative. */
+	else if (readlink_stat(thisname, &st, linkname) != 0) {
 		int save_errno = errno;
 		/* See if file is excluded before reporting an error. */
 		if (filter_level != NO_FILTERS
 		    && is_excluded(thisname, 0, filter_level))
 			return NULL;
 		if (save_errno == ENOENT) {
@@ -811,39 +793,47 @@
 
 	/* backup.c calls us with filter_level set to NO_FILTERS. */
 	if (filter_level == NO_FILTERS)
 		goto skip_filters;
 
 	if (S_ISDIR(st.st_mode) && !xfer_dirs) {
-		rprintf(FINFO, "skipping directory %s\n", safe_fname(thisname));
+		rprintf(FINFO, "skipping directory %s\n", thisname);
 		return NULL;
 	}
 
 	/* We only care about directories because we need to avoid recursing
 	 * into a mount-point directory, not to avoid copying a symlinked
 	 * file if -L (or similar) was specified. */
 	if (one_file_system && st.st_dev != filesystem_dev
-	    && S_ISDIR(st.st_mode))
+	 && S_ISDIR(st.st_mode)) {
+		if (one_file_system > 1) {
+			if (verbose > 2) {
+				rprintf(FINFO, "skipping mount-point dir %s\n",
+					thisname);
+			}
+			return NULL;
+		}
 		flags |= FLAG_MOUNT_POINT;
+	}
 
 	if (is_excluded(thisname, S_ISDIR(st.st_mode) != 0, filter_level))
 		return NULL;
 
 	if (lp_ignore_nonreadable(module_id)) {
 #ifdef SUPPORT_LINKS
 		if (!S_ISLNK(st.st_mode))
 #endif
 			if (access(thisname, R_OK) != 0)
 				return NULL;
 	}
 
-skip_filters:
+  skip_filters:
 
 	if (verbose > 2) {
 		rprintf(FINFO, "[%s] make_file(%s,*,%d)\n",
-			who_am_i(), safe_fname(thisname), filter_level);
+			who_am_i(), thisname, filter_level);
 	}
 
 	if ((basename = strrchr(thisname, '/')) != NULL) {
 		dirname_len = ++basename - thisname; /* counts future '\0' */
 		if (lastdir_len == dirname_len - 1
 		    && strncmp(thisname, lastdir, lastdir_len) == 0) {
@@ -861,22 +851,22 @@
 #ifdef SUPPORT_LINKS
 	linkname_len = S_ISLNK(st.st_mode) ? strlen(linkname) + 1 : 0;
 #else
 	linkname_len = 0;
 #endif
 
-	sum_len = always_checksum && S_ISREG(st.st_mode) ? MD4_SUM_LENGTH : 0;
+	sum_len = always_checksum && am_sender && S_ISREG(st.st_mode)
+	        ? MD4_SUM_LENGTH : 0;
 
 	alloc_len = file_struct_len + dirname_len + basename_len
 	    + linkname_len + sum_len;
-	if (flist) {
-		bp = pool_alloc(flist->file_pool, alloc_len,
-		    "receive_file_entry");
-	} else {
+	if (flist)
+		bp = pool_alloc(flist->file_pool, alloc_len, "make_file");
+	else {
 		if (!(bp = new_array(char, alloc_len)))
-			out_of_memory("receive_file_entry");
+			out_of_memory("make_file");
 	}
 
 	file = (struct file_struct *)bp;
 	memset(bp, 0, file_struct_len);
 	bp += file_struct_len;
 
@@ -918,13 +908,14 @@
 
 	file->basename = bp;
 	memcpy(bp, basename, basename_len);
 	bp += basename_len;
 
 #ifdef HAVE_STRUCT_STAT_ST_RDEV
-	if (preserve_devices && IS_DEVICE(st.st_mode))
+	if ((preserve_devices && IS_DEVICE(st.st_mode))
+	 || (preserve_specials && IS_SPECIAL(st.st_mode)))
 		file->u.rdev = st.st_rdev;
 #endif
 
 #ifdef SUPPORT_LINKS
 	if (linkname_len) {
 		file->u.link = bp;
@@ -943,13 +934,13 @@
 
 	/* This code is only used by the receiver when it is building
 	 * a list of files for a delete pass. */
 	if (keep_dirlinks && linkname_len && flist) {
 		STRUCT_STAT st2;
 		int save_mode = file->mode;
-		file->mode = S_IFDIR; /* find a directory w/our name */
+		file->mode = S_IFDIR; /* Find a directory with our name. */
 		if (flist_find(the_file_list, file) >= 0
 		    && do_stat(thisname, &st2) == 0 && S_ISDIR(st2.st_mode)) {
 			file->modtime = st2.st_mtime;
 			file->length = st2.st_size;
 			file->mode = st2.st_mode;
 			file->uid = st2.st_uid;
@@ -962,40 +953,45 @@
 	if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))
 		stats.total_size += st.st_size;
 
 	return file;
 }
 
-
 static struct file_struct *send_file_name(int f, struct file_list *flist,
-					  char *fname, unsigned short base_flags)
+					  char *fname, STRUCT_STAT *stp,
+					  unsigned short flags)
 {
 	struct file_struct *file;
 
-	file = make_file(fname, flist, f == -2 ? SERVER_FILTERS : ALL_FILTERS);
+	file = make_file(fname, flist, stp, flags,
+			 f == -2 ? SERVER_FILTERS : ALL_FILTERS);
 	if (!file)
 		return NULL;
 
+	if (chmod_modes && !S_ISLNK(file->mode))
+		file->mode = tweak_mode(file->mode, chmod_modes);
+
 	maybe_emit_filelist_progress(flist->count + flist_count_offset);
 
 	flist_expand(flist);
 
 	if (file->basename[0]) {
 		flist->files[flist->count++] = file;
-		send_file_entry(file, f, base_flags);
+		send_file_entry(file, f);
 	}
 	return file;
 }
 
 static void send_if_directory(int f, struct file_list *flist,
-			      struct file_struct *file)
+			      struct file_struct *file,
+			      char *fbuf, unsigned int ol)
 {
-	char fbuf[MAXPATHLEN];
+	char is_dot_dir = fbuf[ol-1] == '.' && (ol == 1 || fbuf[ol-2] == '/');
 
 	if (S_ISDIR(file->mode)
-	    && !(file->flags & FLAG_MOUNT_POINT) && f_name_to(file, fbuf)) {
+	    && !(file->flags & FLAG_MOUNT_POINT) && f_name(file, fbuf)) {
 		void *save_filters;
 		unsigned int len = strlen(fbuf);
 		if (len > 1 && fbuf[len-1] == '/')
 			fbuf[--len] = '\0';
 		if (len >= MAXPATHLEN - 1) {
 			io_error |= IOERR_GENERAL;
@@ -1003,16 +999,18 @@
 				full_fname(fbuf));
 			return;
 		}
 		save_filters = push_local_filters(fbuf, len);
 		send_directory(f, flist, fbuf, len);
 		pop_local_filters(save_filters);
+		fbuf[ol] = '\0';
+		if (is_dot_dir)
+			fbuf[ol-1] = '.';
 	}
 }
 
-
 /* This function is normally called by the sender, but the receiving side also
  * calls it from get_dirlist() with f set to -1 so that we just construct the
  * file list in memory without sending it over the wire.  Also, get_dirlist()
  * might call this with f set to -2, which also indicates that local filter
  * rules should be ignored. */
 static void send_directory(int f, struct file_list *flist,
@@ -1038,20 +1036,21 @@
 
 	for (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {
 		char *dname = d_name(di);
 		if (dname[0] == '.' && (dname[1] == '\0'
 		    || (dname[1] == '.' && dname[2] == '\0')))
 			continue;
-		if (strlcpy(p, dname, remainder) < remainder)
-			send_file_name(f, flist, fbuf, 0);
-		else {
+		if (strlcpy(p, dname, remainder) >= remainder) {
 			io_error |= IOERR_GENERAL;
 			rprintf(FINFO,
 				"cannot send long-named file %s\n",
 				full_fname(fbuf));
+			continue;
 		}
+
+		send_file_name(f, flist, fbuf, NULL, 0);
 	}
 
 	fbuf[len] = '\0';
 
 	if (errno) {
 		io_error |= IOERR_GENERAL;
@@ -1060,20 +1059,19 @@
 
 	closedir(d);
 
 	if (recurse) {
 		int i, end = flist->count - 1;
 		for (i = start; i <= end; i++)
-			send_if_directory(f, flist, flist->files[i]);
+			send_if_directory(f, flist, flist->files[i], fbuf, len);
 	}
 }
 
-
 struct file_list *send_file_list(int f, int argc, char *argv[])
 {
-	int l;
+	int len;
 	STRUCT_STAT st;
 	char *p, *dir, olddir[sizeof curr_dir];
 	char lastpath[MAXPATHLEN] = "";
 	struct file_list *flist;
 	struct timeval start_tv, end_tv;
 	int64 start_write;
@@ -1095,119 +1093,136 @@
 			exit_cleanup(RERR_FILESELECT);
 		}
 		use_ff_fd = 1;
 	}
 
 	while (1) {
-		struct file_struct *file;
-		char fname2[MAXPATHLEN];
-		char *fname = fname2;
+		char fbuf[MAXPATHLEN];
+		char *fn;
 		int is_dot_dir;
 
 		if (use_ff_fd) {
-			if (read_filesfrom_line(filesfrom_fd, fname) == 0)
+			if (read_filesfrom_line(filesfrom_fd, fbuf) == 0)
 				break;
-			sanitize_path(fname, fname, "", 0);
+			sanitize_path(fbuf, fbuf, "", 0);
 		} else {
 			if (argc-- == 0)
 				break;
-			strlcpy(fname, *argv++, MAXPATHLEN);
+			strlcpy(fbuf, *argv++, MAXPATHLEN);
 			if (sanitize_paths)
-				sanitize_path(fname, fname, "", 0);
+				sanitize_path(fbuf, fbuf, "", 0);
 		}
 
-		l = strlen(fname);
-		if (!l || fname[l - 1] == '/') {
-			if (l == 2 && fname[0] == '.') {
+		len = strlen(fbuf);
+		if (relative_paths) {
+			/* We clean up fbuf below. */
+			is_dot_dir = 0;
+		} else if (!len || fbuf[len - 1] == '/') {
+			if (len == 2 && fbuf[0] == '.') {
 				/* Turn "./" into just "." rather than "./." */
-				fname[1] = '\0';
+				fbuf[1] = '\0';
 			} else {
-				if (l + 1 >= MAXPATHLEN)
+				if (len + 1 >= MAXPATHLEN)
 					overflow_exit("send_file_list");
-				fname[l++] = '.';
-				fname[l] = '\0';
+				fbuf[len++] = '.';
+				fbuf[len] = '\0';
 			}
 			is_dot_dir = 1;
-		} else if (l > 1 && fname[l-1] == '.' && fname[l-2] == '.'
-		    && (l == 2 || fname[l-3] == '/')) {
-			if (l + 2 >= MAXPATHLEN)
+		} else if (len > 1 && fbuf[len-1] == '.' && fbuf[len-2] == '.'
+		    && (len == 2 || fbuf[len-3] == '/')) {
+			if (len + 2 >= MAXPATHLEN)
 				overflow_exit("send_file_list");
-			fname[l++] = '/';
-			fname[l++] = '.';
-			fname[l] = '\0';
+			fbuf[len++] = '/';
+			fbuf[len++] = '.';
+			fbuf[len] = '\0';
 			is_dot_dir = 1;
 		} else {
-			is_dot_dir = fname[l-1] == '.'
-				   && (l == 1 || fname[l-2] == '/');
+			is_dot_dir = fbuf[len-1] == '.'
+				   && (len == 1 || fbuf[len-2] == '/');
 		}
 
-		if (link_stat(fname, &st, keep_dirlinks) != 0) {
+		if (link_stat(fbuf, &st, copy_dirlinks) != 0) {
 			io_error |= IOERR_GENERAL;
 			rsyserr(FERROR, errno, "link_stat %s failed",
-				full_fname(fname));
+				full_fname(fbuf));
 			continue;
 		}
 
 		if (S_ISDIR(st.st_mode) && !xfer_dirs) {
-			rprintf(FINFO, "skipping directory %s\n",
-				safe_fname(fname));
+			rprintf(FINFO, "skipping directory %s\n", fbuf);
 			continue;
 		}
 
 		dir = NULL;
 		olddir[0] = '\0';
 
 		if (!relative_paths) {
-			p = strrchr(fname, '/');
+			p = strrchr(fbuf, '/');
 			if (p) {
-				*p = 0;
-				if (p == fname)
+				*p = '\0';
+				if (p == fbuf)
 					dir = "/";
 				else
-					dir = fname;
-				fname = p + 1;
-			}
-		} else if (implied_dirs && (p=strrchr(fname,'/')) && p != fname) {
-			/* this ensures we send the intermediate directories,
-			   thus getting their permissions right */
-			char *lp = lastpath, *fn = fname, *slash = fname;
-			*p = 0;
-			/* Skip any initial directories in our path that we
-			 * have in common with lastpath. */
-			while (*fn && *lp == *fn) {
-				if (*fn == '/')
-					slash = fn;
-				lp++, fn++;
+					dir = fbuf;
+				len -= p - fbuf + 1;
+				fn = p + 1;
+			} else
+				fn = fbuf;
+		} else {
+			if ((p = strstr(fbuf, "/./")) != NULL) {
+				*p = '\0';
+				if (p == fbuf)
+					dir = "/";
+				else
+					dir = fbuf;
+				len -= p - fbuf + 3;
+				fn = p + 3;
+			} else
+				fn = fbuf;
+			/* Get rid of trailing "/" and "/.". */
+			while (len) {
+				if (fn[len - 1] == '/') {
+					is_dot_dir = 1;
+					if (!--len && !dir) {
+						len++;
+						break;
+					}
+				}
+				else if (len >= 2 && fn[len - 1] == '.'
+						  && fn[len - 2] == '/') {
+					is_dot_dir = 1;
+					if (!(len -= 2) && !dir) {
+						len++;
+						break;
+					}
+				} else
+					break;
 			}
-			*p = '/';
-			if (fn != p || (*lp && *lp != '/')) {
-				int save_copy_links = copy_links;
-				int save_xfer_dirs = xfer_dirs;
-				copy_links = copy_unsafe_links;
-				xfer_dirs = 1;
-				while ((slash = strchr(slash+1, '/')) != 0) {
-					*slash = 0;
-					send_file_name(f, flist, fname, 0);
-					*slash = '/';
+			fn[len] = '\0';
+			/* Reject a ".." dir in the active part of the path. */
+			for (p = fn; (p = strstr(p, "..")) != NULL; p += 2) {
+				if ((p[2] == '/' || p[2] == '\0')
+				 && (p == fn || p[-1] == '/')) {
+					rprintf(FERROR,
+					    "found \"..\" dir in relative path: %s\n",
+					    fbuf);
+					exit_cleanup(RERR_SYNTAX);
 				}
-				copy_links = save_copy_links;
-				xfer_dirs = save_xfer_dirs;
-				*p = 0;
-				strlcpy(lastpath, fname, sizeof lastpath);
-				*p = '/';
 			}
 		}
 
-		if (!*fname)
-			fname = ".";
+		if (!*fn) {
+			len = 1;
+			fn = ".";
+		}
 
 		if (dir && *dir) {
 			static char *lastdir;
 			static int lastdir_len;
 
-			strcpy(olddir, curr_dir); /* can't overflow */
+			strlcpy(olddir, curr_dir, sizeof olddir);
 
 			if (!push_dir(dir)) {
 				io_error |= IOERR_GENERAL;
 				rsyserr(FERROR, errno, "push_dir %s failed",
 					full_fname(dir));
 				continue;
@@ -1219,39 +1234,75 @@
 			} else {
 				flist_dir = lastdir = strdup(dir);
 				flist_dir_len = lastdir_len = strlen(dir);
 			}
 		}
 
+		if (fn != fbuf)
+			memmove(fbuf, fn, len + 1);
+
+		if (implied_dirs && (p=strrchr(fbuf,'/')) && p != fbuf) {
+			/* Send the implied directories at the start of the
+			 * source spec, so we get their permissions right. */
+			char *lp = lastpath, *slash = fbuf;
+			*p = '\0';
+			/* Skip any initial directories in our path that we
+			 * have in common with lastpath. */
+			for (fn = fbuf; *fn && *lp == *fn; lp++, fn++) {
+				if (*fn == '/')
+					slash = fn;
+			}
+			*p = '/';
+			if (fn != p || (*lp && *lp != '/')) {
+				int save_copy_links = copy_links;
+				int save_xfer_dirs = xfer_dirs;
+				copy_links |= copy_unsafe_links;
+				xfer_dirs = 1;
+				while ((slash = strchr(slash+1, '/')) != 0) {
+					*slash = '\0';
+					send_file_name(f, flist, fbuf, NULL, 0);
+					*slash = '/';
+				}
+				copy_links = save_copy_links;
+				xfer_dirs = save_xfer_dirs;
+				*p = '\0';
+				strlcpy(lastpath, fbuf, sizeof lastpath);
+				*p = '/';
+			}
+		}
+
 		if (one_file_system)
 			filesystem_dev = st.st_dev;
 
-		if ((file = send_file_name(f, flist, fname, XMIT_TOP_DIR))) {
-			if (recurse || (xfer_dirs && is_dot_dir))
-				send_if_directory(f, flist, file);
-		}
+		if (recurse || (xfer_dirs && is_dot_dir)) {
+			struct file_struct *file;
+			file = send_file_name(f, flist, fbuf, &st, FLAG_TOP_DIR);
+			if (file)
+				send_if_directory(f, flist, file, fbuf, len);
+		} else
+			send_file_name(f, flist, fbuf, &st, 0);
 
 		if (olddir[0]) {
 			flist_dir = NULL;
 			flist_dir_len = 0;
 			if (!pop_dir(olddir)) {
 				rsyserr(FERROR, errno, "pop_dir %s failed",
-					full_fname(dir));
+					full_fname(olddir));
 				exit_cleanup(RERR_FILESELECT);
 			}
 		}
 	}
 
 	gettimeofday(&end_tv, NULL);
 	stats.flist_buildtime = (int64)(end_tv.tv_sec - start_tv.tv_sec) * 1000
 			      + (end_tv.tv_usec - start_tv.tv_usec) / 1000;
 	if (stats.flist_buildtime == 0)
 		stats.flist_buildtime = 1;
 	start_tv = end_tv;
 
-	send_file_entry(NULL, f, 0);
+	send_file_entry(NULL, f);
 
 	if (show_filelist_p())
 		finish_filelist_progress(flist);
 
 	gettimeofday(&end_tv, NULL);
 	stats.flist_xfertime = (int64)(end_tv.tv_sec - start_tv.tv_sec) * 1000
@@ -1265,14 +1316,12 @@
 	/* Sort the list without removing any duplicates.  This allows the
 	 * receiving side to ask for any name they like, which gives us the
 	 * flexibility to change the way we unduplicate names in the future
 	 * without causing a compatibility problem with older versions. */
 	clean_flist(flist, 0, 0);
 
-	/* Now send the uid/gid list. This was introduced in
-	 * protocol version 15 */
 	send_uid_list(f);
 
 	/* send the io_error flag */
 	write_int(f, lp_ignore_errors(module_id) ? 0 : io_error);
 
 	io_end_buffering();
@@ -1315,22 +1362,22 @@
 		flist_expand(flist);
 
 		if (protocol_version >= 28 && (flags & XMIT_EXTENDED_FLAGS))
 			flags |= read_byte(f) << 8;
 		file = receive_file_entry(flist, flags, f);
 
-		if (S_ISREG(file->mode))
+		if (S_ISREG(file->mode) || S_ISLNK(file->mode))
 			stats.total_size += file->length;
 
 		flist->files[flist->count++] = file;
 
 		maybe_emit_filelist_progress(flist->count);
 
 		if (verbose > 2) {
 			rprintf(FINFO, "recv_file_name(%s)\n",
-				safe_fname(f_name(file)));
+				f_name(file, NULL));
 		}
 	}
 	receive_file_entry(NULL, 0, 0); /* Signal that we're done. */
 
 	if (verbose > 2)
 		rprintf(FINFO, "received %d names\n", flist->count);
@@ -1338,14 +1385,12 @@
 	if (show_filelist_p())
 		finish_filelist_progress(flist);
 
 	clean_flist(flist, relative_paths, 1);
 
 	if (f >= 0) {
-		/* Now send the uid/gid list. This was introduced in
-		 * protocol version 15 */
 		recv_uid_list(f, flist);
 
 		/* Recv the io_error flag */
 		if (lp_ignore_errors(module_id) || ignore_errors)
 			read_int(f);
 		else
@@ -1366,66 +1411,89 @@
 
 	stats.flist_size = stats.total_read - start_read;
 	stats.num_files = flist->count;
 
 	return flist;
 
-oom:
+  oom:
 	out_of_memory("recv_file_list");
 	return NULL;		/* not reached */
 }
 
-
 static int file_compare(struct file_struct **file1, struct file_struct **file2)
 {
 	return f_name_cmp(*file1, *file2);
 }
 
-
 /* Search for an identically-named item in the file list.  Note that the
  * items must agree in their directory-ness, or no match is returned. */
 int flist_find(struct file_list *flist, struct file_struct *f)
 {
 	int low = flist->low, high = flist->high;
-	int ret, mid, mid_up;
+	int diff, mid, mid_up;
 
 	while (low <= high) {
 		mid = (low + high) / 2;
-		for (mid_up = mid; !flist->files[mid_up]->basename; mid_up++) {}
-		if (mid_up <= high)
-			ret = f_name_cmp(flist->files[mid_up], f);
-		else
-			ret = 1;
-		if (ret == 0) {
+		if (flist->files[mid]->basename)
+			mid_up = mid;
+		else {
+			/* Scan for the next non-empty entry using the cached
+			 * distance values.  If the value isn't fully up-to-
+			 * date, update it. */
+			mid_up = mid + flist->files[mid]->dir.depth;
+			if (!flist->files[mid_up]->basename) {
+				do {
+				    mid_up += flist->files[mid_up]->dir.depth;
+				} while (!flist->files[mid_up]->basename);
+				flist->files[mid]->dir.depth = mid_up - mid;
+			}
+			if (mid_up > high) {
+				/* If there's nothing left above us, set high to
+				 * a non-empty entry below us and continue. */
+				high = mid - flist->files[mid]->length;
+				if (!flist->files[high]->basename) {
+					do {
+					    high -= flist->files[high]->length;
+					} while (!flist->files[high]->basename);
+					flist->files[mid]->length = mid - high;
+				}
+				continue;
+			}
+		}
+		diff = f_name_cmp(flist->files[mid_up], f);
+		if (diff == 0) {
 			if (protocol_version < 29
 			    && S_ISDIR(flist->files[mid_up]->mode)
 			    != S_ISDIR(f->mode))
 				return -1;
 			return mid_up;
 		}
-		if (ret > 0)
-			high = mid - 1;
-		else
+		if (diff < 0)
 			low = mid_up + 1;
+		else
+			high = mid - 1;
 	}
 	return -1;
 }
 
-
 /*
  * Free up any resources a file_struct has allocated
  * and clear the file.
  */
-void clear_file(int i, struct file_list *flist)
+void clear_file(struct file_struct *file, struct file_list *flist)
 {
-	if (flist->hlink_pool && flist->files[i]->link_u.idev)
-		pool_free(flist->hlink_pool, 0, flist->files[i]->link_u.idev);
-	memset(flist->files[i], 0, file_struct_len);
+	if (flist->hlink_pool && file->link_u.idev)
+		pool_free(flist->hlink_pool, 0, file->link_u.idev);
+	memset(file, 0, file_struct_len);
+	/* In an empty entry, dir.depth is an offset to the next non-empty
+	 * entry.  Likewise for length in the opposite direction.  We assume
+	 * that we're alone for now since flist_find() will adjust the counts
+	 * it runs into that aren't up-to-date. */
+	file->length = file->dir.depth = 1;
 }
 
-
 /*
  * allocate a new file list
  */
 struct file_list *flist_new(int with_hlink, char *msg)
 {
 	struct file_list *flist;
@@ -1466,25 +1533,24 @@
 /*
  * This routine ensures we don't have any duplicate names in our file list.
  * duplicate names can cause corruption because of the pipelining
  */
 static void clean_flist(struct file_list *flist, int strip_root, int no_dups)
 {
+	char fbuf[MAXPATHLEN];
 	int i, prev_i = 0;
 
 	if (!flist)
 		return;
 	if (flist->count == 0) {
 		flist->high = -1;
 		return;
 	}
 
-	sorting_flist = flist;
 	qsort(flist->files, flist->count,
 	    sizeof flist->files[0], (int (*)())file_compare);
-	sorting_flist = NULL;
 
 	for (i = no_dups? 0 : flist->count; i < flist->count; i++) {
 		if (flist->files[i]->basename) {
 			prev_i = i;
 			break;
 		}
@@ -1521,20 +1587,20 @@
 					keep = j, drop = i;
 			} else
 				keep = j, drop = i;
 			if (verbose > 1 && !am_server) {
 				rprintf(FINFO,
 					"removing duplicate name %s from file list (%d)\n",
-					safe_fname(f_name(file)), drop);
+					f_name(file, fbuf), drop);
 			}
-			/* Make sure that if we unduplicate '.', that we don't
-			 * lose track of a user-specified top directory. */
+			/* Make sure we don't lose track of a user-specified
+			 * top directory. */
 			flist->files[keep]->flags |= flist->files[drop]->flags
 						   & (FLAG_TOP_DIR|FLAG_DEL_HERE);
 
-			clear_file(drop, flist);
+			clear_file(flist->files[drop], flist);
 
 			if (keep == i) {
 				if (flist->low == drop) {
 					for (j = drop + 1;
 					     j < i && !flist->files[j]->basename;
 					     j++) {}
@@ -1552,24 +1618,85 @@
 		 * paths, but this must be done _after_ the sorting phase. */
 		for (i = flist->low; i <= flist->high; i++) {
 			struct file_struct *file = flist->files[i];
 
 			if (!file->dirname)
 				continue;
-			if (*file->dirname == '/') {
-				char *s = file->dirname + 1;
-				while (*s == '/') s++;
-				memmove(file->dirname, s, strlen(s) + 1);
-			}
-
+			while (*file->dirname == '/')
+				file->dirname++;
 			if (!*file->dirname)
 				file->dirname = NULL;
 		}
 	}
-}
 
+	if (prune_empty_dirs && no_dups) {
+		int j, prev_depth = 0;
+
+		prev_i = 0; /* It's OK that this isn't really true. */
+
+		for (i = flist->low; i <= flist->high; i++) {
+			struct file_struct *fp, *file = flist->files[i];
+
+			/* This temporarily abuses the dir.depth value for a
+			 * directory that is in a chain that might get pruned.
+			 * We restore the old value if it gets a reprieve. */
+			if (S_ISDIR(file->mode) && file->dir.depth) {
+				/* Dump empty dirs when coming back down. */
+				for (j = prev_depth; j >= file->dir.depth; j--) {
+					fp = flist->files[prev_i];
+					if (fp->dir.depth >= 0)
+						break;
+					prev_i = -fp->dir.depth-1;
+					clear_file(fp, flist);
+				}
+				prev_depth = file->dir.depth;
+				if (is_excluded(f_name(file, fbuf), 1,
+						       ALL_FILTERS)) {
+					/* Keep dirs through this dir. */
+					for (j = prev_depth-1; ; j--) {
+						fp = flist->files[prev_i];
+						if (fp->dir.depth >= 0)
+							break;
+						prev_i = -fp->dir.depth-1;
+						fp->dir.depth = j;
+					}
+				} else
+					file->dir.depth = -prev_i-1;
+				prev_i = i;
+			} else {
+				/* Keep dirs through this non-dir. */
+				for (j = prev_depth; ; j--) {
+					fp = flist->files[prev_i];
+					if (fp->dir.depth >= 0)
+						break;
+					prev_i = -fp->dir.depth-1;
+					fp->dir.depth = j;
+				}
+			}
+		}
+		/* Dump empty all remaining empty dirs. */
+		while (1) {
+			struct file_struct *fp = flist->files[prev_i];
+			if (fp->dir.depth >= 0)
+				break;
+			prev_i = -fp->dir.depth-1;
+			clear_file(fp, flist);
+		}
+
+		for (i = flist->low; i <= flist->high; i++) {
+			if (flist->files[i]->basename)
+				break;
+		}
+		flist->low = i;
+		for (i = flist->high; i >= flist->low; i--) {
+			if (flist->files[i]->basename)
+				break;
+		}
+		flist->high = i;
+	}
+}
 
 static void output_flist(struct file_list *flist)
 {
 	char uidbuf[16], gidbuf[16], depthbuf[16];
 	struct file_struct *file;
 	const char *who = who_am_i();
@@ -1586,13 +1713,13 @@
 		else
 			*gidbuf = '\0';
 		if (!am_sender)
 			sprintf(depthbuf, "%d", file->dir.depth);
 		rprintf(FINFO, "[%s] i=%d %s %s%s%s%s mode=0%o len=%.0f%s%s flags=%x\n",
 			who, i, am_sender ? NS(file->dir.root) : depthbuf,
-			file->dirname ? safe_fname(file->dirname) : "",
+			file->dirname ? file->dirname : "",
 			file->dirname ? "/" : "", NS(file->basename),
 			S_ISDIR(file->mode) ? "/" : "", (int)file->mode,
 			(double)file->length, uidbuf, gidbuf, file->flags);
 	}
 }
 
@@ -1740,45 +1866,41 @@
 		}
 	}
 
 	return dif;
 }
 
-
 /* Return a copy of the full filename of a flist entry, using the indicated
- * buffer.  No size-checking is done because we checked the size when creating
- * the file_struct entry.
+ * buffer or one of 5 static buffers if fbuf is NULL.  No size-checking is
+ * done because we checked the size when creating the file_struct entry.
  */
-char *f_name_to(struct file_struct *f, char *fbuf)
+char *f_name(struct file_struct *f, char *fbuf)
 {
 	if (!f || !f->basename)
 		return NULL;
 
+	if (!fbuf) {
+		static char names[5][MAXPATHLEN];
+		static unsigned int n;
+
+		n = (n + 1) % (sizeof names / sizeof names[0]);
+
+		fbuf = names[n];
+	}
+
 	if (f->dirname) {
 		int len = strlen(f->dirname);
 		memcpy(fbuf, f->dirname, len);
 		fbuf[len] = '/';
 		strcpy(fbuf + len + 1, f->basename);
 	} else
 		strcpy(fbuf, f->basename);
-	return fbuf;
-}
 
-
-/* Like f_name_to(), but we rotate through 5 static buffers of our own. */
-char *f_name(struct file_struct *f)
-{
-	static char names[5][MAXPATHLEN];
-	static unsigned int n;
-
-	n = (n + 1) % (sizeof names / sizeof names[0]);
-
-	return f_name_to(f, names[n]);
+	return fbuf;
 }
 
-
 /* Do a non-recursive scan of the named directory, possibly ignoring all
  * exclude rules except for the daemon's.  If "dlen" is >=0, it is the length
  * of the dirname string, and also indicates that "dirname" is a MAXPATHLEN
  * buffer (the functions we call will append names onto the end, but the old
  * dir value will be restored on exit). */
 struct file_list *get_dirlist(char *dirname, int dlen,
@@ -1784,24 +1906,27 @@
 struct file_list *get_dirlist(char *dirname, int dlen,
 			      int ignore_filter_rules)
 {
 	struct file_list *dirlist;
 	char dirbuf[MAXPATHLEN];
 	int save_recurse = recurse;
+	int save_xfer_dirs = xfer_dirs;
 
 	if (dlen < 0) {
 		dlen = strlcpy(dirbuf, dirname, MAXPATHLEN);
 		if (dlen >= MAXPATHLEN)
 			return NULL;
 		dirname = dirbuf;
 	}
 
 	dirlist = flist_new(WITHOUT_HLINK, "get_dirlist");
 
 	recurse = 0;
+	xfer_dirs = 1;
 	send_directory(ignore_filter_rules ? -2 : -1, dirlist, dirname, dlen);
+	xfer_dirs = save_xfer_dirs;
 	recurse = save_recurse;
 	if (do_progress)
 		flist_count_offset += dirlist->count;
 
 	clean_flist(dirlist, 0, 0);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/generator.c	2005-07-29 03:06:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/generator.c	2006-03-10 23:57:03.000000000 +0800
@@ -24,61 +24,65 @@
 #include "rsync.h"
 
 extern int verbose;
 extern int dry_run;
 extern int do_xfers;
 extern int log_format_has_i;
-extern int log_format_has_o_or_i;
 extern int daemon_log_format_has_i;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
 extern int do_progress;
 extern int recurse;
 extern int relative_paths;
+extern int implied_dirs;
 extern int keep_dirlinks;
 extern int preserve_links;
 extern int preserve_devices;
+extern int preserve_specials;
 extern int preserve_hard_links;
 extern int preserve_perms;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_times;
 extern int omit_dir_times;
+extern int delete_mode;
 extern int delete_before;
 extern int delete_during;
 extern int delete_after;
 extern int module_id;
 extern int ignore_errors;
 extern int remove_sent_files;
 extern int delay_updates;
 extern int update_only;
-extern int opt_ignore_existing;
+extern int ignore_existing;
+extern int ignore_non_existing;
 extern int inplace;
+extern int append_mode;
 extern int make_backups;
 extern int csum_length;
 extern int ignore_times;
 extern int size_only;
 extern OFF_T max_size;
+extern OFF_T min_size;
 extern int io_error;
 extern int allowed_lull;
 extern int sock_f_out;
 extern int ignore_timeout;
 extern int protocol_version;
 extern int fuzzy_basis;
 extern int always_checksum;
+extern int checksum_len;
 extern char *partial_dir;
 extern char *basis_dir[];
 extern int compare_dest;
 extern int copy_dest;
 extern int link_dest;
 extern int whole_file;
 extern int list_only;
 extern int read_batch;
-extern int only_existing;
-extern int orig_umask;
 extern int safe_symlinks;
 extern long block_size; /* "long" because popt can't set an int32. */
 extern int max_delete;
 extern int force_delete;
 extern int one_file_system;
 extern struct stats stats;
@@ -87,30 +91,40 @@
 extern char *backup_suffix;
 extern int backup_suffix_len;
 extern struct file_list *the_file_list;
 extern struct filter_list_struct server_filter_list;
 
 static int deletion_count = 0; /* used to implement --max-delete */
+static int can_link_symlinks = 1; /* start out optimistic */
+static int can_link_devices = 1;
+
+/* For calling delete_file() */
+#define DEL_FORCE_RECURSE	(1<<1) /* recurse even w/o --force */
+#define DEL_TERSE		(1<<3)
 
 
 static int is_backup_file(char *fn)
 {
 	int k = strlen(fn) - backup_suffix_len;
 	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
 }
 
 
 /* Delete a file or directory.  If DEL_FORCE_RECURSE is set in the flags, or if
- * force_delete is set, this will delete recursively as long as DEL_NO_RECURSE
- * is not set in the flags. */
+ * force_delete is set, this will delete recursively.
+ *
+ * Note that fname must point to a MAXPATHLEN buffer if the mode indicates it's
+ * a directory! (The buffer is used for recursion, but returned unchanged.)
+ */
 static int delete_item(char *fname, int mode, int flags)
 {
 	struct file_list *dirlist;
-	char buf[MAXPATHLEN];
 	int j, dlen, zap_dir, ok;
+	unsigned remainder;
 	void *save_filters;
+	char *p;
 
 	if (!S_ISDIR(mode)) {
 		if (max_delete && ++deletion_count > max_delete)
 			return 0;
 		if (make_backups && (backup_dir || !is_backup_file(fname)))
 			ok = make_backup(fname);
@@ -127,14 +141,13 @@
 		}
 		rsyserr(FERROR, errno, "delete_file: unlink %s failed",
 			full_fname(fname));
 		return -1;
 	}
 
-	zap_dir = (flags & DEL_FORCE_RECURSE || (force_delete && recurse))
-		&& !(flags & DEL_NO_RECURSE);
+	zap_dir = flags & DEL_FORCE_RECURSE || force_delete;
 	if ((max_delete && ++deletion_count > max_delete)
 	    || (dry_run && zap_dir)) {
 		ok = 0;
 		errno = ENOTEMPTY;
 	} else if (make_backups && !backup_dir && !is_backup_file(fname)
 	    && !(flags & DEL_FORCE_RECURSE))
@@ -155,27 +168,35 @@
 			full_fname(fname));
 		return -1;
 	}
 	flags |= DEL_FORCE_RECURSE; /* mark subdir dels as not "in the way" */
 	deletion_count--;
 
-	dlen = strlcpy(buf, fname, MAXPATHLEN);
-	save_filters = push_local_filters(buf, dlen);
+	dlen = strlen(fname);
+	save_filters = push_local_filters(fname, dlen);
+
+	dirlist = get_dirlist(fname, dlen, 0);
+
+	p = fname + dlen;
+	if (dlen != 1 || *fname != '/')
+		*p++ = '/';
+	remainder = MAXPATHLEN - (p - fname);
 
-	dirlist = get_dirlist(buf, dlen, 0);
 	for (j = dirlist->count; j--; ) {
 		struct file_struct *fp = dirlist->files[j];
 
 		if (fp->flags & FLAG_MOUNT_POINT)
 			continue;
 
-		f_name_to(fp, buf);
-		delete_item(buf, fp->mode, flags & ~DEL_TERSE);
+		strlcpy(p, fp->basename, remainder);
+		delete_item(fname, fp->mode, flags & ~DEL_TERSE);
 	}
 	flist_free(dirlist);
 
+	fname[dlen] = '\0';
+
 	pop_local_filters(save_filters);
 
 	if (max_delete && ++deletion_count > max_delete)
 		return 0;
 
 	if (do_rmdir(fname) == 0) {
@@ -194,32 +215,31 @@
 /* This function is used to implement per-directory deletion, and is used by
  * all the --delete-WHEN options.  Note that the fbuf pointer must point to a
  * MAXPATHLEN buffer with the name of the directory in it (the functions we
  * call will append names onto the end, but the old dir value will be restored
  * on exit). */
 static void delete_in_dir(struct file_list *flist, char *fbuf,
-			  struct file_struct *file)
+			  struct file_struct *file, STRUCT_STAT *stp)
 {
 	static int min_depth = MAXPATHLEN, cur_depth = -1;
 	static void *filt_array[MAXPATHLEN/2+1];
 	static int already_warned = 0;
 	struct file_list *dirlist;
 	char delbuf[MAXPATHLEN];
-	STRUCT_STAT st;
 	int dlen, i;
 
 	if (!flist) {
 		while (cur_depth >= min_depth)
 			pop_local_filters(filt_array[cur_depth--]);
 		min_depth = MAXPATHLEN;
 		cur_depth = -1;
 		return;
 	}
 
 	if (verbose > 2)
-		rprintf(FINFO, "delete_in_dir(%s)\n", safe_fname(fbuf));
+		rprintf(FINFO, "delete_in_dir(%s)\n", fbuf);
 
 	if (allowed_lull)
 		maybe_send_keepalive();
 
 	if (file->dir.depth >= MAXPATHLEN/2+1)
 		return; /* Impossible... */
@@ -238,68 +258,71 @@
 	cur_depth = file->dir.depth;
 	if (min_depth > cur_depth)
 		min_depth = cur_depth;
 	dlen = strlen(fbuf);
 	filt_array[cur_depth] = push_local_filters(fbuf, dlen);
 
-	if (link_stat(fbuf, &st, keep_dirlinks) < 0)
-		return;
-
 	if (one_file_system) {
 		if (file->flags & FLAG_TOP_DIR)
-			filesystem_dev = st.st_dev;
-		else if (filesystem_dev != st.st_dev)
+			filesystem_dev = stp->st_dev;
+		else if (filesystem_dev != stp->st_dev)
 			return;
 	}
 
 	dirlist = get_dirlist(fbuf, dlen, 0);
 
 	/* If an item in dirlist is not found in flist, delete it
 	 * from the filesystem. */
 	for (i = dirlist->count; i--; ) {
 		struct file_struct *fp = dirlist->files[i];
 		if (!fp->basename || fp->flags & FLAG_MOUNT_POINT)
 			continue;
 		if (flist_find(flist, fp) < 0) {
-			int mode = fp->mode;
-			f_name_to(fp, delbuf);
-			delete_item(delbuf, mode, DEL_FORCE_RECURSE);
+			f_name(fp, delbuf);
+			delete_item(delbuf, fp->mode, DEL_FORCE_RECURSE);
 		}
 	}
 
 	flist_free(dirlist);
 }
 
 /* This deletes any files on the receiving side that are not present on the
  * sending side.  This is used by --delete-before and --delete-after. */
 static void do_delete_pass(struct file_list *flist)
 {
 	char fbuf[MAXPATHLEN];
+	STRUCT_STAT st;
 	int j;
 
 	if (dry_run > 1 /* destination doesn't exist yet */
 	 || list_only)
 		return;
 
 	for (j = 0; j < flist->count; j++) {
 		struct file_struct *file = flist->files[j];
 
 		if (!(file->flags & FLAG_DEL_HERE))
 			continue;
 
-		f_name_to(file, fbuf);
+		f_name(file, fbuf);
 		if (verbose > 1 && file->flags & FLAG_TOP_DIR)
-			rprintf(FINFO, "deleting in %s\n", safe_fname(fbuf));
+			rprintf(FINFO, "deleting in %s\n", fbuf);
 
-		delete_in_dir(flist, fbuf, file);
+		if (link_stat(fbuf, &st, keep_dirlinks) < 0
+		 || !S_ISDIR(st.st_mode))
+			continue;
+
+		delete_in_dir(flist, fbuf, file, &st);
 	}
+	delete_in_dir(NULL, NULL, NULL, NULL);
+
 	if (do_progress && !am_server)
 		rprintf(FINFO, "                    \r");
 }
 
-static int unchanged_attrs(struct file_struct *file, STRUCT_STAT *st)
+int unchanged_attrs(struct file_struct *file, STRUCT_STAT *st)
 {
 	if (preserve_perms
 	 && (st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS))
 		return 0;
 
 	if (am_root && preserve_uid && st->st_uid != file->uid)
@@ -308,43 +331,39 @@
 	if (preserve_gid && file->gid != GID_NONE && st->st_gid != file->gid)
 		return 0;
 
 	return 1;
 }
 
-
 void itemize(struct file_struct *file, int ndx, int statret, STRUCT_STAT *st,
 	     int32 iflags, uchar fnamecmp_type, char *xname)
 {
-	if (statret == 0) {
+	if (statret >= 0) { /* A from-dest-dir statret can == 1! */
+		int keep_time = !preserve_times ? 0
+		    : S_ISDIR(file->mode) ? !omit_dir_times
+		    : !S_ISLNK(file->mode);
+
 		if (S_ISREG(file->mode) && file->length != st->st_size)
 			iflags |= ITEM_REPORT_SIZE;
-		if (!(iflags & ITEM_NO_DEST_AND_NO_UPDATE)) {
-			int keep_time = !preserve_times ? 0
-			    : S_ISDIR(file->mode) ? !omit_dir_times
-			    : !S_ISLNK(file->mode);
-
-			if ((iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !keep_time
-			     && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
-			    || (keep_time && cmp_modtime(file->modtime, st->st_mtime) != 0))
-				iflags |= ITEM_REPORT_TIME;
-			if (preserve_perms
-			 && (file->mode & CHMOD_BITS) != (st->st_mode & CHMOD_BITS))
-				iflags |= ITEM_REPORT_PERMS;
-			if (preserve_uid && am_root && file->uid != st->st_uid)
-				iflags |= ITEM_REPORT_OWNER;
-			if (preserve_gid && file->gid != GID_NONE
-			    && st->st_gid != file->gid)
-				iflags |= ITEM_REPORT_GROUP;
-		}
+		if ((iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !keep_time
+		     && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
+		    || (keep_time && cmp_time(file->modtime, st->st_mtime) != 0))
+			iflags |= ITEM_REPORT_TIME;
+		if ((file->mode & CHMOD_BITS) != (st->st_mode & CHMOD_BITS))
+			iflags |= ITEM_REPORT_PERMS;
+		if (preserve_uid && am_root && file->uid != st->st_uid)
+			iflags |= ITEM_REPORT_OWNER;
+		if (preserve_gid && file->gid != GID_NONE
+		    && st->st_gid != file->gid)
+			iflags |= ITEM_REPORT_GROUP;
 	} else
 		iflags |= ITEM_IS_NEW;
 
 	iflags &= 0xffff;
 	if ((iflags & SIGNIFICANT_ITEM_FLAGS || verbose > 1
-	  || (xname && *xname)) && !read_batch) {
+	  || log_format_has_i > 1 || (xname && *xname)) && !read_batch) {
 		if (protocol_version >= 29) {
 			if (ndx >= 0)
 				write_int(sock_f_out, ndx);
 			write_shortint(sock_f_out, iflags);
 			if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
 				write_byte(sock_f_out, fnamecmp_type);
@@ -354,33 +373,32 @@
 			log_item(file, &stats, iflags, xname);
 	}
 }
 
 
 /* Perform our quick-check heuristic for determining if a file is unchanged. */
-static int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
+int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
 {
 	if (st->st_size != file->length)
 		return 0;
 
 	/* if always checksum is set then we use the checksum instead
 	   of the file time to determine whether to sync */
 	if (always_checksum && S_ISREG(st->st_mode)) {
 		char sum[MD4_SUM_LENGTH];
 		file_checksum(fn, sum, st->st_size);
-		return memcmp(sum, file->u.sum, protocol_version < 21 ? 2
-							: MD4_SUM_LENGTH) == 0;
+		return memcmp(sum, file->u.sum, checksum_len) == 0;
 	}
 
 	if (size_only)
 		return 1;
 
 	if (ignore_times)
 		return 0;
 
-	return cmp_modtime(st->st_mtime, file->modtime) == 0;
+	return cmp_time(st->st_mtime, file->modtime) == 0;
 }
 
 
 /*
  * set (initialize) the size entries in the per-file sum_struct
  * calculating dynamic block and checksum sizes.
@@ -442,14 +460,14 @@
 		s2length = MIN(s2length, SUM_LENGTH);
 	}
 
 	sum->flength	= len;
 	sum->blength	= blength;
 	sum->s2length	= s2length;
-	sum->count	= (len + (blength - 1)) / blength;
-	sum->remainder	= (len % blength);
+	sum->remainder	= len % blength;
+	sum->count	= len / blength + (sum->remainder != 0);
 
 	if (sum->count && verbose > 2) {
 		rprintf(FINFO,
 			"count=%.0f rem=%ld blength=%ld s2length=%d flength=%.0f\n",
 			(double)sum->count, (long)sum->remainder, (long)sum->blength,
 			sum->s2length, (double)sum->flength);
@@ -467,41 +485,48 @@
 	int32 i;
 	struct map_struct *mapbuf;
 	struct sum_struct sum;
 	OFF_T offset = 0;
 
 	sum_sizes_sqroot(&sum, len);
+	write_sum_head(f_out, &sum);
+
+	if (append_mode > 0 && f_copy < 0)
+		return;
 
 	if (len > 0)
 		mapbuf = map_file(fd, len, MAX_MAP_SIZE, sum.blength);
 	else
 		mapbuf = NULL;
 
-	write_sum_head(f_out, &sum);
-
 	for (i = 0; i < sum.count; i++) {
 		int32 n1 = (int32)MIN(len, (OFF_T)sum.blength);
 		char *map = map_ptr(mapbuf, offset, n1);
-		uint32 sum1 = get_checksum1(map, n1);
 		char sum2[SUM_LENGTH];
+		uint32 sum1;
 
-		if (f_copy >= 0)
+		len -= n1;
+		offset += n1;
+
+		if (f_copy >= 0) {
 			full_write(f_copy, map, n1);
+			if (append_mode > 0)
+				continue;
+		}
 
+		sum1 = get_checksum1(map, n1);
 		get_checksum2(map, n1, sum2);
 
 		if (verbose > 3) {
 			rprintf(FINFO,
 				"chunk[%.0f] offset=%.0f len=%ld sum1=%08lx\n",
-				(double)i, (double)offset, (long)n1,
+				(double)i, (double)offset - n1, (long)n1,
 				(unsigned long)sum1);
 		}
 		write_int(f_out, sum1);
 		write_buf(f_out, sum2, sum.s2length);
-		len -= n1;
-		offset += n1;
 	}
 
 	if (mapbuf)
 		unmap_file(mapbuf);
 }
 
@@ -527,13 +552,13 @@
 		    || fp->flags & FLAG_NO_FUZZY)
 			continue;
 
 		name = fp->basename;
 
 		if (fp->length == file->length
-		    && cmp_modtime(fp->modtime, file->modtime) == 0) {
+		    && cmp_time(fp->modtime, file->modtime) == 0) {
 			if (verbose > 4) {
 				rprintf(FINFO,
 					"fuzzy size/modtime match for %s\n",
 					name);
 			}
 			return j;
@@ -573,74 +598,227 @@
 			continue;
 
 		hard_link_cluster(file, ndx, itemizing, code);
 	}
 }
 
+/* This is only called for regular files.  We return -2 if we've finished
+ * handling the file, -1 if no dest-linking occurred, or a non-negative
+ * value if we found an alternate basis file. */
+static int try_dests_reg(struct file_struct *file, char *fname, int ndx,
+			 char *cmpbuf, STRUCT_STAT *stp, int itemizing,
+			 int maybe_ATTRS_REPORT, enum logcode code)
+{
+	int best_match = -1;
+	int match_level = 0;
+	int j = 0;
+
+	do {
+		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
+		if (link_stat(cmpbuf, stp, 0) < 0 || !S_ISREG(stp->st_mode))
+			continue;
+		switch (match_level) {
+		case 0:
+			best_match = j;
+			match_level = 1;
+			/* FALL THROUGH */
+		case 1:
+			if (!unchanged_file(cmpbuf, file, stp))
+				continue;
+			best_match = j;
+			match_level = 2;
+			/* FALL THROUGH */
+		case 2:
+			if (!unchanged_attrs(file, stp))
+				continue;
+			if ((always_checksum || ignore_times)
+			 && cmp_time(stp->st_mtime, file->modtime))
+				continue;
+			best_match = j;
+			match_level = 3;
+			break;
+		}
+		break;
+	} while (basis_dir[++j] != NULL);
+
+	if (!match_level)
+		return -1;
+
+	if (j != best_match) {
+		j = best_match;
+		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
+		if (link_stat(cmpbuf, stp, 0) < 0)
+			match_level = 0;
+	}
+
+#ifdef HAVE_LINK
+	if (match_level == 3 && !copy_dest) {
+		if (link_dest) {
+			if (hard_link_one(file, ndx, fname, 0, stp,
+					  cmpbuf, 1,
+					  itemizing && verbose > 1,
+					  code) < 0)
+				goto try_a_copy;
+			if (preserve_hard_links && file->link_u.links)
+				hard_link_cluster(file, ndx, itemizing, code);
+		} else if (itemizing)
+			itemize(file, ndx, 0, stp, 0, 0, NULL);
+		if (verbose > 1 && maybe_ATTRS_REPORT) {
+			code = daemon_log_format_has_i || dry_run
+			     ? FCLIENT : FINFO;
+			rprintf(code, "%s is uptodate\n", fname);
+		}
+		return -2;
+	}
+#endif
+
+	if (match_level >= 2) {
+	  try_a_copy: /* Copy the file locally. */
+		if (copy_file(cmpbuf, fname, file->mode) < 0) {
+			if (verbose) {
+				rsyserr(FINFO, errno, "copy_file %s => %s",
+					full_fname(cmpbuf), fname);
+			}
+			return -1;
+		}
+		if (itemizing)
+			itemize(file, ndx, 0, stp, ITEM_LOCAL_CHANGE, 0, NULL);
+		set_file_attrs(fname, file, NULL, 0);
+		if (maybe_ATTRS_REPORT
+		 && ((!itemizing && verbose && match_level == 2)
+		  || (verbose > 1 && match_level == 3))) {
+			code = daemon_log_format_has_i || dry_run
+			     ? FCLIENT : FINFO;
+			rprintf(code, "%s%s\n", fname,
+				match_level == 3 ? " is uptodate" : "");
+		}
+		if (preserve_hard_links && file->link_u.links)
+			hard_link_cluster(file, ndx, itemizing, code);
+		return -2;
+	}
+
+	return FNAMECMP_BASIS_DIR_LOW + j;
+}
+
+/* This is only called for non-regular files.  We return -2 if we've finished
+ * handling the file, or -1 if no dest-linking occurred. */
+static int try_dests_non(struct file_struct *file, char *fname, int ndx,
+			 int itemizing, int *possible_ptr,
+			 int maybe_ATTRS_REPORT, enum logcode code)
+{
+	char fnamebuf[MAXPATHLEN], lnk[MAXPATHLEN];
+	STRUCT_STAT st;
+	int len, i = 0;
+
+	do {
+		pathjoin(fnamebuf, MAXPATHLEN, basis_dir[i], fname);
+		if (link_stat(fnamebuf, &st, 0) < 0 || S_ISDIR(st.st_mode)
+		 || !unchanged_attrs(file, &st))
+			continue;
+		if (S_ISLNK(file->mode)) {
+#ifdef SUPPORT_LINKS
+			if ((len = readlink(fnamebuf, lnk, MAXPATHLEN-1)) <= 0)
+				continue;
+			lnk[len] = '\0';
+			if (strcmp(lnk, file->u.link) != 0)
+#endif
+				continue;
+		} else {
+			if (!IS_DEVICE(st.st_mode) || st.st_rdev != file->u.rdev)
+				continue;
+		}
+		if (link_dest) {
+			if (do_link(fnamebuf, fname) < 0) {
+				/* TODO improve this to be based on errno? */
+				*possible_ptr = 0;
+				break;
+			}
+			if (preserve_hard_links && file->link_u.links)
+				hard_link_cluster(file, ndx, itemizing, code);
+		}
+		if (itemizing && log_format_has_i && verbose > 1) {
+			int changes = compare_dest ? 0 : ITEM_LOCAL_CHANGE
+				    + (link_dest ? ITEM_XNAME_FOLLOWS : 0);
+			char *lp = link_dest ? "" : NULL;
+			itemize(file, ndx, 0, &st, changes, 0, lp);
+		}
+		if (verbose > 1 && maybe_ATTRS_REPORT) {
+			code = daemon_log_format_has_i || dry_run
+			     ? FCLIENT : FINFO;
+			rprintf(code, "%s is uptodate\n", fname);
+		}
+		return -2;
+	} while (basis_dir[++i] != NULL);
+
+	return -1;
+}
+
 static int phase = 0;
 
 /* Acts on the_file_list->file's ndx'th item, whose name is fname.  If a dir,
  * make sure it exists, and has the right permissions/timestamp info.  For
  * all other non-regular files (symlinks, etc.) we create them here.  For
  * regular files that have changed, we try to find a basis file and then
  * start sending checksums.
  *
+ * When fname is non-null, it must point to a MAXPATHLEN buffer!
+ *
  * Note that f_out is set to -1 when doing final directory-permission and
  * modification-time repair. */
 static void recv_generator(char *fname, struct file_struct *file, int ndx,
-			   int itemizing, int maybe_PERMS_REPORT,
+			   int itemizing, int maybe_ATTRS_REPORT,
 			   enum logcode code, int f_out)
 {
 	static int missing_below = -1, excluded_below = -1;
-	static char *fuzzy_dirname = "";
+	static char *parent_dirname = "";
 	static struct file_list *fuzzy_dirlist = NULL;
+	static int need_fuzzy_dirlist = 0;
 	struct file_struct *fuzzy_file = NULL;
 	int fd = -1, f_copy = -1;
 	STRUCT_STAT st, real_st, partial_st;
 	struct file_struct *back_file = NULL;
 	int statret, real_ret, stat_errno;
 	char *fnamecmp, *partialptr, *backupptr = NULL;
 	char fnamecmpbuf[MAXPATHLEN];
 	uchar fnamecmp_type;
+	int del_opts = DEL_TERSE | (delete_mode ? DEL_FORCE_RECURSE : 0);
 
 	if (list_only)
 		return;
 
 	if (!fname) {
 		if (fuzzy_dirlist) {
 			flist_free(fuzzy_dirlist);
 			fuzzy_dirlist = NULL;
-			fuzzy_dirname = "";
 		}
 		if (missing_below >= 0) {
 			dry_run--;
 			missing_below = -1;
 		}
+		parent_dirname = "";
 		return;
 	}
 
-	if (verbose > 2) {
-		rprintf(FINFO, "recv_generator(%s,%d)\n",
-			safe_fname(fname), ndx);
-	}
+	if (verbose > 2)
+		rprintf(FINFO, "recv_generator(%s,%d)\n", fname, ndx);
 
 	if (server_filter_list.head) {
 		if (excluded_below >= 0) {
 			if (file->dir.depth > excluded_below)
 				goto skipping;
 			excluded_below = -1;
 		}
 		if (check_filter(&server_filter_list, fname,
 				 S_ISDIR(file->mode)) < 0) {
 			if (S_ISDIR(file->mode))
 				excluded_below = file->dir.depth;
-		    skipping:
+		  skipping:
 			if (verbose) {
 				rprintf(FINFO,
 					"skipping server-excluded file \"%s\"\n",
-					safe_fname(fname));
+					fname);
 			}
 			return;
 		}
 	}
 
 	if (missing_below >= 0 && file->dir.depth <= missing_below) {
@@ -648,94 +826,108 @@
 		missing_below = -1;
 	}
 	if (dry_run > 1) {
 		statret = -1;
 		stat_errno = ENOENT;
 	} else {
-		if (fuzzy_basis && S_ISREG(file->mode)) {
-			char *dn = file->dirname ? file->dirname : ".";
-			if (fuzzy_dirname != dn
-			    && strcmp(fuzzy_dirname, dn) != 0) {
-				if (fuzzy_dirlist)
-					flist_free(fuzzy_dirlist);
-				fuzzy_dirlist = get_dirlist(dn, -1, 1);
+		char *dn = file->dirname ? file->dirname : ".";
+		if (parent_dirname != dn && strcmp(parent_dirname, dn) != 0) {
+			if (relative_paths && !implied_dirs
+			 && do_stat(dn, &st) < 0
+			 && create_directory_path(fname) < 0) {
+				rsyserr(FERROR, errno,
+					"recv_generator: mkdir %s failed",
+					full_fname(dn));
 			}
-			fuzzy_dirname = dn;
+			if (fuzzy_dirlist) {
+				flist_free(fuzzy_dirlist);
+				fuzzy_dirlist = NULL;
+			}
+			if (fuzzy_basis)
+				need_fuzzy_dirlist = 1;
+		}
+		parent_dirname = dn;
+
+		if (need_fuzzy_dirlist && S_ISREG(file->mode)) {
+			fuzzy_dirlist = get_dirlist(dn, -1, 1);
+			need_fuzzy_dirlist = 0;
 		}
 
 		statret = link_stat(fname, &st,
 				    keep_dirlinks && S_ISDIR(file->mode));
 		stat_errno = errno;
 	}
 
-	if (only_existing && statret == -1 && stat_errno == ENOENT) {
-		/* we only want to update existing files */
+	if (ignore_non_existing && statret == -1 && stat_errno == ENOENT) {
 		if (verbose > 1) {
 			rprintf(FINFO, "not creating new %s \"%s\"\n",
 				S_ISDIR(file->mode) ? "directory" : "file",
-				safe_fname(fname));
+				fname);
 		}
 		return;
 	}
 
-	if (statret == 0 && !preserve_perms
-	    && S_ISDIR(st.st_mode) == S_ISDIR(file->mode)) {
-		/* if the file exists already and we aren't perserving
-		 * permissions then act as though the remote end sent
-		 * us the file permissions we already have */
-		file->mode = (file->mode & ~CHMOD_BITS)
-			   | (st.st_mode & CHMOD_BITS);
+	/* If we're not preserving permissions, change the file-list's
+	 * mode based on the local permissions and some heuristics. */
+	if (!preserve_perms) {
+		int exists = statret == 0
+			  && S_ISDIR(st.st_mode) == S_ISDIR(file->mode);
+		file->mode = dest_mode(file->mode, st.st_mode, exists);
 	}
 
 	if (S_ISDIR(file->mode)) {
 		/* The file to be received is a directory, so we need
 		 * to prepare appropriately.  If there is already a
 		 * file of that name and it is *not* a directory, then
 		 * we need to delete it.  If it doesn't exist, then
 		 * (perhaps recursively) create it. */
 		if (statret == 0 && !S_ISDIR(st.st_mode)) {
-			if (delete_item(fname, st.st_mode, DEL_TERSE) < 0)
+			if (delete_item(fname, st.st_mode, del_opts) < 0)
 				return;
 			statret = -1;
 		}
 		if (dry_run && statret != 0 && missing_below < 0) {
 			missing_below = file->dir.depth;
 			dry_run++;
 		}
 		if (itemizing && f_out != -1) {
 			itemize(file, ndx, statret, &st,
 				statret ? ITEM_LOCAL_CHANGE : 0, 0, NULL);
 		}
-		if (statret != 0 && do_mkdir(fname,file->mode) != 0 && errno != EEXIST) {
+		if (statret != 0 && do_mkdir(fname,file->mode) < 0 && errno != EEXIST) {
 			if (!relative_paths || errno != ENOENT
-			    || create_directory_path(fname, orig_umask) < 0
+			    || create_directory_path(fname) < 0
 			    || (do_mkdir(fname, file->mode) < 0 && errno != EEXIST)) {
 				rsyserr(FERROR, errno,
 					"recv_generator: mkdir %s failed",
 					full_fname(fname));
 			}
 		}
-		if (set_perms(fname, file, statret ? NULL : &st, 0)
+		if (set_file_attrs(fname, file, statret ? NULL : &st, 0)
 		    && verbose && code && f_out != -1)
-			rprintf(code, "%s/\n", safe_fname(fname));
+			rprintf(code, "%s/\n", fname);
 		if (delete_during && f_out != -1 && !phase && dry_run < 2
 		    && (file->flags & FLAG_DEL_HERE))
-			delete_in_dir(the_file_list, fname, file);
+			delete_in_dir(the_file_list, fname, file, &st);
 		return;
 	}
 
+	if (preserve_hard_links && file->link_u.links
+	    && hard_link_check(file, ndx, fname, statret, &st,
+			       itemizing, code, HL_CHECK_MASTER))
+		return;
+
 	if (preserve_links && S_ISLNK(file->mode)) {
 #ifdef SUPPORT_LINKS
 		if (safe_symlinks && unsafe_symlink(file->u.link, fname)) {
 			if (verbose) {
 				if (the_file_list->count == 1)
-					fname = f_name(file);
+					fname = f_name(file, NULL);
 				rprintf(FINFO,
 					"ignoring unsafe symlink %s -> \"%s\"\n",
-					full_fname(fname),
-					safe_fname(file->u.link));
+					full_fname(fname), file->u.link);
 			}
 			return;
 		}
 		if (statret == 0) {
 			char lnk[MAXPATHLEN];
 			int len;
@@ -748,223 +940,179 @@
 				 * required. */
 				if (strcmp(lnk, file->u.link) == 0) {
 					if (itemizing) {
 						itemize(file, ndx, 0, &st, 0,
 							0, NULL);
 					}
-					set_perms(fname, file, &st,
-						  maybe_PERMS_REPORT);
+					set_file_attrs(fname, file, &st,
+						       maybe_ATTRS_REPORT);
+					if (preserve_hard_links
+					    && file->link_u.links) {
+						hard_link_cluster(file, ndx,
+								  itemizing,
+								  code);
+					}
 					return;
 				}
 			}
 			/* Not the right symlink (or not a symlink), so
 			 * delete it. */
-			if (delete_item(fname, st.st_mode, DEL_TERSE) < 0)
+			if (delete_item(fname, st.st_mode, del_opts) < 0)
 				return;
 			if (!S_ISLNK(st.st_mode))
 				statret = -1;
+		} else if (basis_dir[0] != NULL && can_link_symlinks) {
+			if (try_dests_non(file, fname, ndx, itemizing,
+					  &can_link_symlinks,
+					  maybe_ATTRS_REPORT, code) == -2) {
+				if (!copy_dest)
+					return;
+				itemizing = code = 0;
+			}
 		}
+		if (preserve_hard_links && file->link_u.links
+		    && hard_link_check(file, ndx, fname, -1, &st,
+				       itemizing, code, HL_SKIP))
+			return;
 		if (do_symlink(file->u.link,fname) != 0) {
 			rsyserr(FERROR, errno, "symlink %s -> \"%s\" failed",
-				full_fname(fname), safe_fname(file->u.link));
+				full_fname(fname), file->u.link);
 		} else {
-			set_perms(fname,file,NULL,0);
+			set_file_attrs(fname, file, NULL, 0);
 			if (itemizing) {
 				itemize(file, ndx, statret, &st,
 					ITEM_LOCAL_CHANGE, 0, NULL);
 			}
 			if (code && verbose) {
-				rprintf(code, "%s -> %s\n", safe_fname(fname),
-					safe_fname(file->u.link));
+				rprintf(code, "%s -> %s\n", fname,
+					file->u.link);
 			}
 			if (remove_sent_files && !dry_run) {
 				char numbuf[4];
 				SIVAL(numbuf, 0, ndx);
 				send_msg(MSG_SUCCESS, numbuf, 4);
 			}
+			if (preserve_hard_links && file->link_u.links)
+				hard_link_cluster(file, ndx, itemizing, code);
 		}
 #endif
 		return;
 	}
 
-	if (am_root && preserve_devices && IS_DEVICE(file->mode)) {
-		if (statret != 0 ||
-		    st.st_mode != file->mode ||
-		    st.st_rdev != file->u.rdev) {
-			if (delete_item(fname, st.st_mode, DEL_TERSE) < 0)
+	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
+	 || (preserve_specials && IS_SPECIAL(file->mode))) {
+		if (statret != 0
+		 && (basis_dir[0] != NULL && can_link_devices)) {
+			if (try_dests_non(file, fname, ndx, itemizing,
+					  &can_link_devices,
+					  maybe_ATTRS_REPORT, code) == -2) {
+				if (!copy_dest)
+					return;
+				itemizing = code = 0;
+			}
+		}
+		if (statret != 0
+		 || (st.st_mode & ~CHMOD_BITS) != (file->mode & ~CHMOD_BITS)
+		 || st.st_rdev != file->u.rdev) {
+			if (statret == 0
+			 && delete_item(fname, st.st_mode, del_opts) < 0)
+				return;
+			if (preserve_hard_links && file->link_u.links
+			    && hard_link_check(file, ndx, fname, -1, &st,
+					       itemizing, code, HL_SKIP))
 				return;
-			if (!IS_DEVICE(st.st_mode))
+			if ((IS_DEVICE(file->mode) && !IS_DEVICE(st.st_mode))
+			 || (IS_SPECIAL(file->mode) && !IS_SPECIAL(st.st_mode)))
 				statret = -1;
 			if (verbose > 2) {
 				rprintf(FINFO,"mknod(%s,0%o,0x%x)\n",
-					safe_fname(fname),
+					fname,
 					(int)file->mode, (int)file->u.rdev);
 			}
-			if (do_mknod(fname,file->mode,file->u.rdev) != 0) {
+			if (do_mknod(fname,file->mode,file->u.rdev) < 0) {
 				rsyserr(FERROR, errno, "mknod %s failed",
 					full_fname(fname));
 			} else {
-				set_perms(fname,file,NULL,0);
+				set_file_attrs(fname, file, NULL, 0);
 				if (itemizing) {
 					itemize(file, ndx, statret, &st,
 						ITEM_LOCAL_CHANGE, 0, NULL);
 				}
-				if (code && verbose) {
-					rprintf(code, "%s\n",
-						safe_fname(fname));
+				if (code && verbose)
+					rprintf(code, "%s\n", fname);
+				if (preserve_hard_links && file->link_u.links) {
+					hard_link_cluster(file, ndx,
+							  itemizing, code);
 				}
 			}
 		} else {
 			if (itemizing)
 				itemize(file, ndx, statret, &st, 0, 0, NULL);
-			set_perms(fname, file, &st, maybe_PERMS_REPORT);
+			set_file_attrs(fname, file, &st, maybe_ATTRS_REPORT);
+			if (preserve_hard_links && file->link_u.links)
+				hard_link_cluster(file, ndx, itemizing, code);
 		}
 		return;
 	}
 
-	if (preserve_hard_links
-	    && hard_link_check(file, ndx, fname, statret, &st,
-			       itemizing, code, HL_CHECK_MASTER))
-		return;
-
 	if (!S_ISREG(file->mode)) {
 		if (the_file_list->count == 1)
-			fname = f_name(file);
-		rprintf(FINFO, "skipping non-regular file \"%s\"\n",
-			safe_fname(fname));
+			fname = f_name(file, NULL);
+		rprintf(FINFO, "skipping non-regular file \"%s\"\n", fname);
 		return;
 	}
 
 	if (max_size && file->length > max_size) {
 		if (verbose > 1) {
 			if (the_file_list->count == 1)
-				fname = f_name(file);
-			rprintf(FINFO, "%s is over max-size\n",
-				safe_fname(fname));
+				fname = f_name(file, NULL);
+			rprintf(FINFO, "%s is over max-size\n", fname);
+		}
+		return;
+	}
+	if (min_size && file->length < min_size) {
+		if (verbose > 1) {
+			if (the_file_list->count == 1)
+				fname = f_name(file, NULL);
+			rprintf(FINFO, "%s is under min-size\n", fname);
 		}
 		return;
 	}
 
-	if (opt_ignore_existing && statret == 0) {
+	if (ignore_existing && statret == 0) {
 		if (verbose > 1)
-			rprintf(FINFO, "%s exists\n", safe_fname(fname));
+			rprintf(FINFO, "%s exists\n", fname);
 		return;
 	}
 
 	if (update_only && statret == 0
-	    && cmp_modtime(st.st_mtime, file->modtime) > 0) {
+	    && cmp_time(st.st_mtime, file->modtime) > 0) {
 		if (verbose > 1)
-			rprintf(FINFO, "%s is newer\n", safe_fname(fname));
+			rprintf(FINFO, "%s is newer\n", fname);
 		return;
 	}
 
 	fnamecmp = fname;
 	fnamecmp_type = FNAMECMP_FNAME;
 
 	if (statret == 0 && !S_ISREG(st.st_mode)) {
-		if (delete_item(fname, st.st_mode, DEL_TERSE) != 0)
+		if (delete_item(fname, st.st_mode, del_opts) != 0)
 			return;
 		statret = -1;
 		stat_errno = ENOENT;
 	}
 
 	if (statret != 0 && basis_dir[0] != NULL) {
-		int best_match = -1;
-		int match_level = 0;
-		int i = 0;
-		do {
-			pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
-				 basis_dir[i], fname);
-			if (link_stat(fnamecmpbuf, &st, 0) < 0
-			    || !S_ISREG(st.st_mode))
-				continue;
-			switch (match_level) {
-			case 0:
-				best_match = i;
-				match_level = 1;
-				/* FALL THROUGH */
-			case 1:
-				if (!unchanged_file(fnamecmpbuf, file, &st))
-					continue;
-				best_match = i;
-				match_level = 2;
-				if (copy_dest)
-					break;
-				/* FALL THROUGH */
-			case 2:
-				if (!unchanged_attrs(file, &st))
-					continue;
-				best_match = i;
-				match_level = 3;
-				break;
-			}
-			break;
-		} while (basis_dir[++i] != NULL);
-		if (match_level) {
+		int j = try_dests_reg(file, fname, ndx, fnamecmpbuf, &st,
+				      itemizing, maybe_ATTRS_REPORT, code);
+		if (j == -2)
+			return;
+		if (j != -1) {
+			fnamecmp = fnamecmpbuf;
+			fnamecmp_type = j;
 			statret = 0;
-			if (i != best_match) {
-				i = best_match;
-				pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
-					 basis_dir[i], fname);
-				if (link_stat(fnamecmpbuf, &st, 0) < 0) {
-					match_level = 0;
-					statret = -1;
-					stat_errno = errno;
-				}
-			}
-#ifdef HAVE_LINK
-			if (link_dest && match_level == 3) {
-				if (hard_link_one(file, ndx, fname, -1, &st,
-						  fnamecmpbuf, 1,
-						  itemizing && verbose > 1,
-						  code) == 0) {
-					if (preserve_hard_links
-					    && file->link_u.links) {
-						hard_link_cluster(file, ndx,
-								  itemizing,
-								  code);
-					}
-					return;
-				}
-				match_level = 2;
-			}
-#endif
-			if (match_level == 2) {
-				/* Copy the file locally. */
-				if (copy_file(fnamecmpbuf, fname, file->mode) < 0) {
-					if (verbose) {
-						rsyserr(FINFO, errno,
-							"copy_file %s => %s",
-							full_fname(fnamecmpbuf),
-							safe_fname(fname));
-					}
-					match_level = 0;
-					statret = -1;
-				} else {
-					if (itemizing) {
-						itemize(file, ndx, 0, &st,
-							ITEM_LOCAL_CHANGE, 0,
-							NULL);
-					} else if (verbose && code) {
-						rprintf(code, "%s\n",
-							safe_fname(fname));
-					}
-					set_perms(fname, file, NULL,
-						  maybe_PERMS_REPORT);
-					if (preserve_hard_links
-					    && file->link_u.links) {
-						hard_link_cluster(file, ndx,
-								  itemizing,
-								  code);
-					}
-					return;
-				}
-			} else if (compare_dest || match_level == 1) {
-				fnamecmp = fnamecmpbuf;
-				fnamecmp_type = i;
-			}
 		}
 	}
 
 	real_ret = statret;
 	real_st = st;
 
@@ -973,103 +1121,101 @@
 	    && S_ISREG(partial_st.st_mode)) {
 		if (statret != 0)
 			goto prepare_to_open;
 	} else
 		partialptr = NULL;
 
-	if (statret != 0 && fuzzy_basis && dry_run <= 1) {
+	if (statret != 0 && fuzzy_dirlist && dry_run <= 1) {
 		int j = find_fuzzy(file, fuzzy_dirlist);
 		if (j >= 0) {
 			fuzzy_file = fuzzy_dirlist->files[j];
-			f_name_to(fuzzy_file, fnamecmpbuf);
+			f_name(fuzzy_file, fnamecmpbuf);
 			if (verbose > 2) {
 				rprintf(FINFO, "fuzzy basis selected for %s: %s\n",
-					safe_fname(fname), safe_fname(fnamecmpbuf));
+					fname, fnamecmpbuf);
 			}
 			st.st_size = fuzzy_file->length;
 			statret = 0;
 			fnamecmp = fnamecmpbuf;
 			fnamecmp_type = FNAMECMP_FUZZY;
 		}
 	}
 
 	if (statret != 0) {
-		if (preserve_hard_links
+		if (preserve_hard_links && file->link_u.links
 		    && hard_link_check(file, ndx, fname, statret, &st,
 				       itemizing, code, HL_SKIP))
 			return;
 		if (stat_errno == ENOENT)
 			goto notify_others;
-		if (verbose > 1) {
-			rsyserr(FERROR, stat_errno,
-				"recv_generator: failed to stat %s",
-				full_fname(fname));
-		}
+		rsyserr(FERROR, stat_errno, "recv_generator: failed to stat %s",
+			full_fname(fname));
 		return;
 	}
 
-	if (!compare_dest && fnamecmp_type <= FNAMECMP_BASIS_DIR_HIGH)
+	if (append_mode && st.st_size > file->length)
+		return;
+
+	if (fnamecmp_type <= FNAMECMP_BASIS_DIR_HIGH)
 		;
 	else if (fnamecmp_type == FNAMECMP_FUZZY)
 		;
 	else if (unchanged_file(fnamecmp, file, &st)) {
-		if (fnamecmp_type == FNAMECMP_FNAME) {
-			if (itemizing) {
-				itemize(file, ndx, real_ret, &real_st,
-					0, 0, NULL);
-			}
-			set_perms(fname, file, &st, maybe_PERMS_REPORT);
-			if (preserve_hard_links && file->link_u.links)
-				hard_link_cluster(file, ndx, itemizing, code);
-			return;
+		if (partialptr) {
+			do_unlink(partialptr);
+			handle_partial_dir(partialptr, PDIR_DELETE);
+		}
+		if (itemizing) {
+			itemize(file, ndx, real_ret, &real_st,
+				0, 0, NULL);
 		}
-		/* Only --compare-dest gets here. */
-		itemize(file, ndx, real_ret, &real_st,
-			ITEM_NO_DEST_AND_NO_UPDATE, 0, NULL);
+		set_file_attrs(fname, file, &st, maybe_ATTRS_REPORT);
+		if (preserve_hard_links && file->link_u.links)
+			hard_link_cluster(file, ndx, itemizing, code);
 		return;
 	}
 
-prepare_to_open:
+  prepare_to_open:
 	if (partialptr) {
 		st = partial_st;
 		fnamecmp = partialptr;
 		fnamecmp_type = FNAMECMP_PARTIAL_DIR;
 		statret = 0;
 	}
 
 	if (!do_xfers || read_batch || whole_file)
 		goto notify_others;
 
-	if (fuzzy_basis) {
+	if (fuzzy_dirlist) {
 		int j = flist_find(fuzzy_dirlist, file);
 		if (j >= 0) /* don't use changing file as future fuzzy basis */
 			fuzzy_dirlist->files[j]->flags |= FLAG_NO_FUZZY;
 	}
 
 	/* open the file */
 	fd = do_open(fnamecmp, O_RDONLY, 0);
 
 	if (fd == -1) {
 		rsyserr(FERROR, errno, "failed to open %s, continuing",
 			full_fname(fnamecmp));
-	    pretend_missing:
+	  pretend_missing:
 		/* pretend the file didn't exist */
-		if (preserve_hard_links
+		if (preserve_hard_links && file->link_u.links
 		    && hard_link_check(file, ndx, fname, statret, &st,
 				       itemizing, code, HL_SKIP))
 			return;
 		statret = real_ret = -1;
 		goto notify_others;
 	}
 
 	if (inplace && make_backups && fnamecmp_type == FNAMECMP_FNAME) {
 		if (!(backupptr = get_backup_name(fname))) {
 			close(fd);
 			return;
 		}
-		if (!(back_file = make_file(fname, NULL, NO_FILTERS))) {
+		if (!(back_file = make_file(fname, NULL, NULL, 0, NO_FILTERS))) {
 			close(fd);
 			goto pretend_missing;
 		}
 		if (robust_unlink(backupptr) && errno != ENOENT) {
 			rsyserr(FERROR, errno, "unlink %s",
 				full_fname(backupptr));
@@ -1087,19 +1233,21 @@
 		}
 		fnamecmp_type = FNAMECMP_BACKUP;
 	}
 
 	if (verbose > 3) {
 		rprintf(FINFO, "gen mapped %s of size %.0f\n",
-			safe_fname(fnamecmp), (double)st.st_size);
+			fnamecmp, (double)st.st_size);
 	}
 
 	if (verbose > 2)
 		rprintf(FINFO, "generating and sending sums for %d\n", ndx);
 
-notify_others:
+  notify_others:
+	if (remove_sent_files && !delay_updates && !phase)
+	    increment_active_files(ndx, itemizing, code);
 	write_int(f_out, ndx);
 	if (itemizing) {
 		int iflags = ITEM_TRANSFER;
 		if (always_checksum)
 			iflags |= ITEM_REPORT_CHECKSUM;
 		if (fnamecmp_type != FNAMECMP_FNAME)
@@ -1124,16 +1272,16 @@
 	}
 
 	generate_and_send_sums(fd, st.st_size, f_out, f_copy);
 
 	if (f_copy >= 0) {
 		close(f_copy);
-		set_perms(backupptr, back_file, NULL, 0);
+		set_file_attrs(backupptr, back_file, NULL, 0);
 		if (verbose > 1) {
 			rprintf(FINFO, "backed up %s to %s\n",
-				safe_fname(fname), safe_fname(backupptr));
+				fname, backupptr);
 		}
 		free(back_file);
 	}
 
 	close(fd);
 }
@@ -1135,55 +1283,55 @@
 		free(back_file);
 	}
 
 	close(fd);
 }
 
-
 void generate_files(int f_out, struct file_list *flist, char *local_name)
 {
 	int i;
 	char fbuf[MAXPATHLEN];
-	int itemizing, maybe_PERMS_REPORT;
+	int itemizing, maybe_ATTRS_REPORT;
 	enum logcode code;
 	int lull_mod = allowed_lull * 5;
 	int need_retouch_dir_times = preserve_times && !omit_dir_times;
 	int need_retouch_dir_perms = 0;
-	int save_only_existing = only_existing;
-	int save_opt_ignore_existing = opt_ignore_existing;
+	int save_ignore_existing = ignore_existing;
+	int save_ignore_non_existing = ignore_non_existing;
 	int save_do_progress = do_progress;
 	int save_make_backups = make_backups;
+	int dir_tweaking = !(list_only || local_name || dry_run);
 
 	if (protocol_version >= 29) {
 		itemizing = 1;
-		maybe_PERMS_REPORT = log_format_has_i ? 0 : PERMS_REPORT;
+		maybe_ATTRS_REPORT = log_format_has_i ? 0 : ATTRS_REPORT;
 		code = daemon_log_format_has_i ? 0 : FLOG;
 	} else if (am_daemon) {
 		itemizing = daemon_log_format_has_i && do_xfers;
-		maybe_PERMS_REPORT = PERMS_REPORT;
+		maybe_ATTRS_REPORT = ATTRS_REPORT;
 		code = itemizing || !do_xfers ? FCLIENT : FINFO;
 	} else if (!am_server) {
 		itemizing = log_format_has_i;
-		maybe_PERMS_REPORT = log_format_has_i ? 0 : PERMS_REPORT;
+		maybe_ATTRS_REPORT = log_format_has_i ? 0 : ATTRS_REPORT;
 		code = itemizing ? 0 : FINFO;
 	} else {
 		itemizing = 0;
-		maybe_PERMS_REPORT = PERMS_REPORT;
+		maybe_ATTRS_REPORT = ATTRS_REPORT;
 		code = FINFO;
 	}
 
 	if (verbose > 2) {
 		rprintf(FINFO, "generator starting pid=%ld count=%d\n",
 			(long)getpid(), flist->count);
 	}
 
 	if (delete_before && !local_name && flist->count > 0)
 		do_delete_pass(flist);
 	do_progress = 0;
 
-	if (whole_file < 0)
+	if (append_mode || whole_file < 0)
 		whole_file = 0;
 	if (verbose >= 2) {
 		rprintf(FINFO, "delta-transmission %s\n",
 			whole_file
 			? "disabled for local transfer or --whole-file"
 			: "enabled");
@@ -1198,67 +1346,77 @@
 	for (i = 0; i < flist->count; i++) {
 		struct file_struct *file = flist->files[i];
 
 		if (!file->basename)
 			continue;
 
-		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
-			       file, i, itemizing, maybe_PERMS_REPORT, code,
-			       f_out);
+		if (local_name)
+			strlcpy(fbuf, local_name, sizeof fbuf);
+		else
+			f_name(file, fbuf);
+		recv_generator(fbuf, file, i, itemizing, maybe_ATTRS_REPORT,
+			       code, f_out);
 
 		/* We need to ensure that any dirs we create have writeable
 		 * permissions during the time we are putting files within
 		 * them.  This is then fixed after the transfer is done. */
+#ifdef HAVE_CHMOD
 		if (!am_root && S_ISDIR(file->mode) && !(file->mode & S_IWUSR)
-		    && !list_only) {
-			int mode = file->mode | S_IWUSR; /* user write */
+		 && dir_tweaking) {
+			mode_t mode = file->mode | S_IWUSR; /* user write */
 			char *fname = local_name ? local_name : fbuf;
-			if (do_chmod(fname, mode & CHMOD_BITS) < 0) {
+			if (do_chmod(fname, mode) < 0) {
 				rsyserr(FERROR, errno,
 					"failed to modify permissions on %s",
 					full_fname(fname));
 			}
 			need_retouch_dir_perms = 1;
 		}
+#endif
 
 		if (preserve_hard_links)
 			check_for_finished_hlinks(itemizing, code);
 
 		if (allowed_lull && !(i % lull_mod))
 			maybe_send_keepalive();
 		else if (!(i % 200))
 			maybe_flush_socket();
 	}
 	recv_generator(NULL, NULL, 0, 0, 0, code, -1);
 	if (delete_during)
-		delete_in_dir(NULL, NULL, NULL);
+		delete_in_dir(NULL, NULL, NULL, NULL);
 
 	phase++;
 	csum_length = SUM_LENGTH;
-	only_existing = max_size = opt_ignore_existing = 0;
+	max_size = min_size = ignore_existing = ignore_non_existing = 0;
 	update_only = always_checksum = size_only = 0;
 	ignore_times = 1;
+	if (append_mode)  /* resend w/o append mode */
+		append_mode = -1; /* ... but only longer files */
 	make_backups = 0; /* avoid a duplicate backup for inplace processing */
 
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
 	write_int(f_out, -1);
 
 	/* files can cycle through the system more than once
 	 * to catch initial checksum errors */
 	while ((i = get_redo_num(itemizing, code)) != -1) {
 		struct file_struct *file = flist->files[i];
-		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
-			       file, i, itemizing, maybe_PERMS_REPORT, code,
-			       f_out);
+		if (local_name)
+			strlcpy(fbuf, local_name, sizeof fbuf);
+		else
+			f_name(file, fbuf);
+		recv_generator(fbuf, file, i, itemizing, maybe_ATTRS_REPORT,
+			       code, f_out);
 	}
 
 	phase++;
-	only_existing = save_only_existing;
-	opt_ignore_existing = save_opt_ignore_existing;
+	ignore_non_existing = save_ignore_non_existing;
+	ignore_existing = save_ignore_existing;
 	make_backups = save_make_backups;
 
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
 	write_int(f_out, -1);
@@ -1280,14 +1438,13 @@
 	}
 
 	do_progress = save_do_progress;
 	if (delete_after && !local_name && flist->count > 0)
 		do_delete_pass(flist);
 
-	if ((need_retouch_dir_perms || need_retouch_dir_times)
-	    && !list_only && !local_name && !dry_run) {
+	if ((need_retouch_dir_perms || need_retouch_dir_times) && dir_tweaking) {
 		int j = 0;
 		/* Now we need to fix any directory permissions that were
 		 * modified during the transfer and/or re-set any tweaked
 		 * modified-time values. */
 		for (i = 0; i < flist->count; i++) {
 			struct file_struct *file = flist->files[i];
@@ -1288,18 +1445,19 @@
 		int j = 0;
 		/* Now we need to fix any directory permissions that were
 		 * modified during the transfer and/or re-set any tweaked
 		 * modified-time values. */
 		for (i = 0; i < flist->count; i++) {
 			struct file_struct *file = flist->files[i];
+
 			if (!file->basename || !S_ISDIR(file->mode))
 				continue;
 			if (!need_retouch_dir_times && file->mode & S_IWUSR)
 				continue;
-			recv_generator(f_name(file), file, i, itemizing,
-				       maybe_PERMS_REPORT, code, -1);
+			recv_generator(f_name(file, NULL), file, i, itemizing,
+				       maybe_ATTRS_REPORT, code, -1);
 			if (allowed_lull && !(++j % lull_mod))
 				maybe_send_keepalive();
 			else if (!(j % 200))
 				maybe_flush_socket();
 		}
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/hlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/hlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/hlink.c	2005-06-10 05:56:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/hlink.c	2006-02-25 00:43:44.000000000 +0800
@@ -17,16 +17,17 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
-extern int dry_run;
 extern int verbose;
+extern int link_dest;
 extern int make_backups;
 extern int log_format_has_i;
+extern char *basis_dir[];
 extern struct file_list *the_file_list;
 
 #ifdef SUPPORT_HARD_LINKS
 
 #define SKIPPED_LINK (-1)
 #define FINISHED_LINK (-2)
@@ -170,32 +171,55 @@
 int hard_link_check(struct file_struct *file, int ndx, char *fname,
 		    int statret, STRUCT_STAT *st, int itemizing,
 		    enum logcode code, int skip)
 {
 #ifdef SUPPORT_HARD_LINKS
 	int head;
-	if (!file->link_u.links)
-		return 0;
 	if (skip && !(file->flags & FLAG_HLINK_EOL))
 		head = hlink_list[file->F_HLINDEX] = file->F_NEXT;
 	else
 		head = hlink_list[file->F_HLINDEX];
 	if (ndx != head) {
 		struct file_struct *head_file = FPTR(head);
 		if (!log_format_has_i && verbose > 1) {
 			rprintf(FINFO, "\"%s\" is a hard link\n",
-				safe_fname(f_name(file)));
+				f_name(file, NULL));
 		}
 		if (head_file->F_HLINDEX == FINISHED_LINK) {
-			STRUCT_STAT st2;
-			char *toname = f_name(head_file);
+			STRUCT_STAT st2, st3;
+			char *toname = f_name(head_file, NULL);
 			if (link_stat(toname, &st2, 0) < 0) {
 				rsyserr(FERROR, errno, "stat %s failed",
 					full_fname(toname));
 				return -1;
 			}
+			if (statret < 0 && basis_dir[0] != NULL) {
+				char cmpbuf[MAXPATHLEN];
+				int j = 0;
+				do {
+					pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
+					if (link_stat(cmpbuf, &st3, 0) < 0)
+						continue;
+					if (link_dest) {
+						if (st2.st_dev != st3.st_dev
+						 || st2.st_ino != st3.st_ino)
+							continue;
+						statret = 1;
+						st = &st3;
+						if (verbose < 2 || !log_format_has_i)
+							itemizing = code = 0;
+						break;
+					}
+					if (!unchanged_file(cmpbuf, file, &st3))
+						continue;
+					statret = 1;
+					st = &st3;
+					if (unchanged_attrs(file, &st3))
+						break;
+				} while (basis_dir[++j] != NULL);
+			}
 			maybe_hard_link(file, ndx, fname, statret, st,
 					toname, &st2, itemizing, code);
 			file->F_HLINDEX = FINISHED_LINK;
 		} else
 			file->F_HLINDEX = SKIPPED_LINK;
 		return 1;
@@ -214,25 +238,23 @@
 			if (!verbose)
 				return -1;
 			code = FINFO;
 		} else
 			code = FERROR;
 		rsyserr(code, errno, "link %s => %s failed",
-			full_fname(fname), safe_fname(toname));
+			full_fname(fname), toname);
 		return -1;
 	}
 
 	if (itemizing) {
 		itemize(file, ndx, statret, st,
 			ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS, 0,
 			terse ? "" : toname);
 	}
-	if (code && verbose && !terse) {
-		rprintf(code, "%s => %s\n",
-			safe_fname(fname), safe_fname(toname));
-	}
+	if (code && verbose && !terse)
+		rprintf(code, "%s => %s\n", fname, toname);
 	return 0;
 }
 #endif
 
 
 void hard_link_cluster(struct file_struct *file, int master, int itemizing,
@@ -242,26 +264,26 @@
 	char hlink1[MAXPATHLEN];
 	char *hlink2;
 	STRUCT_STAT st1, st2;
 	int statret, ndx = master;
 
 	file->F_HLINDEX = FINISHED_LINK;
-	if (link_stat(f_name_to(file, hlink1), &st1, 0) < 0)
+	if (link_stat(f_name(file, hlink1), &st1, 0) < 0)
 		return;
 	if (!(file->flags & FLAG_HLINK_TOL)) {
 		while (!(file->flags & FLAG_HLINK_EOL)) {
 			ndx = file->F_NEXT;
 			file = FPTR(ndx);
 		}
 	}
 	do {
 		ndx = file->F_NEXT;
 		file = FPTR(ndx);
 		if (file->F_HLINDEX != SKIPPED_LINK)
 			continue;
-		hlink2 = f_name(file);
+		hlink2 = f_name(file, NULL);
 		statret = link_stat(hlink2, &st2, 0);
 		maybe_hard_link(file, ndx, hlink2, statret, &st2,
 				hlink1, &st1, itemizing, code);
 		file->F_HLINDEX = FINISHED_LINK;
 	} while (!(file->flags & FLAG_HLINK_EOL));
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6: .ignore
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/INSTALL	2003-12-16 02:20:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/INSTALL	2005-12-17 00:57:26.000000000 +0800
@@ -1,19 +1,26 @@
-To build and install rsync
+To build and install rsync:
 
   $ ./configure
   $ make
   # make install
 
 You may set the installation directory and other parameters by options
 to ./configure.  To see them, use:
 
   $ ./configure --help
 
+Configure tries to figure out if the local system uses group "nobody" or
+"nogroup" by looking in the /etc/group file.  (This is only used for the
+default group of an rsync daemon, which attempts to run with "nobody"
+user and group permissions.)  You can change the default user and group
+for the daemon by editing the NOBODY_USER and NOBODY_GROUP defines in
+config.h, or just override them in your /etc/rsyncd.conf file.
+
 As of 2.4.7, rsync uses Eric Troan's popt option-parsing library.  A
-cut-down copy of release 1.5 is included in the rsync distribution,
+cut-down copy of release 1.6.4 is included in the rsync distribution,
 and will be used if there is no popt library on your build host, or if
 the --with-included-popt option is passed to ./configure.
 
 If you configure using --enable-maintainer-mode, then rsync will try
 to pop up an xterm on DISPLAY=:0 if it crashes.  You might find this
 useful, but it should be turned off for production builds.
@@ -34,22 +40,21 @@
 fails:
 
   (Bundled) cc: "configure", line 2162: error 1705: Function prototypes are an ANSI feature.
 
 Install gcc or HP's "ANSI/C Compiler".
 
-
-
 MAC OSX NOTES
 -------------
 
-Mac OS X (Darwin) seems to have an IPv6 stack, but it does not
-completely implement the "New Sockets" API.  
+Some versions of Mac OS X (Darwin) seem to have an IPv6 stack, but do
+not completely implement the "New Sockets" API.  
 
-<http://www.ipv6.org/impl/mac.html> says that Apple do not support
-IPv6 yet.  If your build fails, try again with --disable-ipv6.
+<http://www.ipv6.org/impl/mac.html> says that Apple started to support
+IPv6 in 10.2 (Jaguar).  If your build fails, try again after running
+configure with --disable-ipv6.
 
 IBM AIX NOTES
 -------------
 
 IBM AIX has a largefile problem with mkstemp.  See IBM PR-51921.
 The workaround is to append the below to config.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/io.c	2005-05-19 16:52:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/io.c	2006-02-27 11:12:26.000000000 +0800
@@ -38,13 +38,12 @@
 
 /** If no timeout is specified then use a 60 second select timeout */
 #define SELECT_TIMEOUT 60
 
 extern int bwlimit;
 extern size_t bwlimit_writemax;
-extern int verbose;
 extern int io_timeout;
 extern int allowed_lull;
 extern int am_server;
 extern int am_daemon;
 extern int am_sender;
 extern int am_generator;
@@ -102,12 +101,14 @@
 static char io_filesfrom_buf[2048];
 static char *io_filesfrom_bp;
 static char io_filesfrom_lastchar;
 static int io_filesfrom_buflen;
 static size_t contiguous_write_len = 0;
 static int select_timeout = SELECT_TIMEOUT;
+static int active_filecnt = 0;
+static OFF_T active_bytecnt = 0;
 
 static void read_loop(int fd, char *buf, size_t len);
 
 struct flist_ndx_item {
 	struct flist_ndx_item *next;
 	int ndx;
@@ -116,20 +117,23 @@
 struct flist_ndx_list {
 	struct flist_ndx_item *head, *tail;
 };
 
 static struct flist_ndx_list redo_list, hlink_list;
 
-struct msg_list {
-	struct msg_list *next;
+struct msg_list_item {
+	struct msg_list_item *next;
 	char *buf;
 	int len;
 };
 
-static struct msg_list *msg_list_head;
-static struct msg_list *msg_list_tail;
+struct msg_list {
+	struct msg_list_item *head, *tail;
+};
+
+static struct msg_list msg_list;
 
 static void flist_ndx_push(struct flist_ndx_list *lp, int ndx)
 {
 	struct flist_ndx_item *item;
 
 	if (!(item = new(struct flist_ndx_item)))
@@ -221,37 +225,27 @@
 	set_nonblocking(msg_fd_out);
 }
 
 /* Add a message to the pending MSG_* list. */
 static void msg_list_add(int code, char *buf, int len)
 {
-	struct msg_list *ml;
+	struct msg_list_item *ml;
 
-	if (!(ml = new(struct msg_list)))
+	if (!(ml = new(struct msg_list_item)))
 		out_of_memory("msg_list_add");
 	ml->next = NULL;
 	if (!(ml->buf = new_array(char, len+4)))
 		out_of_memory("msg_list_add");
 	SIVAL(ml->buf, 0, ((code+MPLEX_BASE)<<24) | len);
 	memcpy(ml->buf+4, buf, len);
 	ml->len = len+4;
-	if (msg_list_tail)
-		msg_list_tail->next = ml;
+	if (msg_list.tail)
+		msg_list.tail->next = ml;
 	else
-		msg_list_head = ml;
-	msg_list_tail = ml;
-}
-
-void send_msg(enum msgcode code, char *buf, int len)
-{
-	if (msg_fd_out < 0) {
-		io_multiplex_write(code, buf, len);
-		return;
-	}
-	msg_list_add(code, buf, len);
-	msg_list_push(NORMAL_FLUSH);
+		msg_list.head = ml;
+	msg_list.tail = ml;
 }
 
 /* Read a message from the MSG_* fd and handle it.  This is called either
  * during the early stages of being a local sender (up through the sending
  * of the file list) or when we're the generator (to fetch the messages
  * from the receiver). */
@@ -283,12 +277,14 @@
 	case MSG_REDO:
 		if (len != 4 || !am_generator) {
 			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
 			exit_cleanup(RERR_STREAMIO);
 		}
 		read_loop(fd, buf, 4);
+		if (remove_sent_files)
+			decrement_active_files(IVAL(buf,0));
 		flist_ndx_push(&redo_list, IVAL(buf,0));
 		break;
 	case MSG_DELETED:
 		if (len >= (int)sizeof buf || !am_generator) {
 			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
 			exit_cleanup(RERR_STREAMIO);
@@ -299,17 +295,26 @@
 	case MSG_SUCCESS:
 		if (len != 4 || !am_generator) {
 			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
 			exit_cleanup(RERR_STREAMIO);
 		}
 		read_loop(fd, buf, len);
-		if (remove_sent_files)
+		if (remove_sent_files) {
+			decrement_active_files(IVAL(buf,0));
 			io_multiplex_write(MSG_SUCCESS, buf, len);
+		}
 		if (preserve_hard_links)
 			flist_ndx_push(&hlink_list, IVAL(buf,0));
 		break;
+	case MSG_SOCKERR:
+		if (!am_generator) {
+			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
+			exit_cleanup(RERR_STREAMIO);
+		}
+		close_multiplexing_out();
+		/* FALL THROUGH */
 	case MSG_INFO:
 	case MSG_ERROR:
 	case MSG_LOG:
 		while (len) {
 			n = len;
 			if (n >= sizeof buf)
@@ -324,26 +329,48 @@
 		exit_cleanup(RERR_STREAMIO);
 	}
 
 	msg_fd_in = fd;
 }
 
+/* This is used by the generator to limit how many file transfers can
+ * be active at once when --remove-sent-files is specified.  Without
+ * this, sender-side deletions were mostly happening at the end. */
+void increment_active_files(int ndx, int itemizing, enum logcode code)
+{
+	/* TODO: tune these limits? */
+	while (active_filecnt >= (active_bytecnt >= 128*1024 ? 10 : 50)) {
+		if (hlink_list.head)
+			check_for_finished_hlinks(itemizing, code);
+		read_msg_fd();
+	}
+
+	active_filecnt++;
+	active_bytecnt += the_file_list->files[ndx]->length;
+}
+
+void decrement_active_files(int ndx)
+{
+	active_filecnt--;
+	active_bytecnt -= the_file_list->files[ndx]->length;
+}
+
 /* Try to push messages off the list onto the wire.  If we leave with more
  * to do, return 0.  On error, return -1.  If everything flushed, return 1.
  * This is only active in the receiver. */
-int msg_list_push(int flush_it_all)
+static int msg_list_flush(int flush_it_all)
 {
 	static int written = 0;
 	struct timeval tv;
 	fd_set fds;
 
 	if (msg_fd_out < 0)
 		return -1;
 
-	while (msg_list_head) {
-		struct msg_list *ml = msg_list_head;
+	while (msg_list.head) {
+		struct msg_list_item *ml = msg_list.head;
 		int n = write(msg_fd_out, ml->buf + written, ml->len - written);
 		if (n < 0) {
 			if (errno == EINTR)
 				continue;
 			if (errno != EWOULDBLOCK && errno != EAGAIN)
 				return -1;
@@ -354,22 +381,32 @@
 			tv.tv_sec = select_timeout;
 			tv.tv_usec = 0;
 			if (!select(msg_fd_out+1, NULL, &fds, NULL, &tv))
 				check_timeout();
 		} else if ((written += n) == ml->len) {
 			free(ml->buf);
-			msg_list_head = ml->next;
-			if (!msg_list_head)
-				msg_list_tail = NULL;
+			msg_list.head = ml->next;
+			if (!msg_list.head)
+				msg_list.tail = NULL;
 			free(ml);
 			written = 0;
 		}
 	}
 	return 1;
 }
 
+void send_msg(enum msgcode code, char *buf, int len)
+{
+	if (msg_fd_out < 0) {
+		io_multiplex_write(code, buf, len);
+		return;
+	}
+	msg_list_add(code, buf, len);
+	msg_list_flush(NORMAL_FLUSH);
+}
+
 int get_redo_num(int itemizing, enum logcode code)
 {
 	while (1) {
 		if (hlink_list.head)
 			check_for_finished_hlinks(itemizing, code);
 		if (redo_list.head)
@@ -445,27 +481,27 @@
  * should trap that: if we fail to read any data at all, we should
  * give a better explanation.  We can tell whether the connection has
  * started by looking e.g. at whether the remote version is known yet.
  */
 static int read_timeout(int fd, char *buf, size_t len)
 {
-	int n, ret = 0;
+	int n, cnt = 0;
 
 	io_flush(NORMAL_FLUSH);
 
-	while (ret == 0) {
+	while (cnt == 0) {
 		/* until we manage to read *something* */
 		fd_set r_fds, w_fds;
 		struct timeval tv;
 		int maxfd = fd;
 		int count;
 
 		FD_ZERO(&r_fds);
 		FD_ZERO(&w_fds);
 		FD_SET(fd, &r_fds);
-		if (msg_list_head) {
+		if (msg_list.head) {
 			FD_SET(msg_fd_out, &w_fds);
 			if (msg_fd_out > maxfd)
 				maxfd = msg_fd_out;
 		}
 		if (io_filesfrom_f_out >= 0) {
 			int new_fd;
@@ -496,14 +532,14 @@
 			if (errno == EBADF)
 				exit_cleanup(RERR_SOCKETIO);
 			check_timeout();
 			continue;
 		}
 
-		if (msg_list_head && FD_ISSET(msg_fd_out, &w_fds))
-			msg_list_push(NORMAL_FLUSH);
+		if (msg_list.head && FD_ISSET(msg_fd_out, &w_fds))
+			msg_list_flush(NORMAL_FLUSH);
 
 		if (io_filesfrom_f_out >= 0) {
 			if (io_filesfrom_buflen) {
 				if (FD_ISSET(io_filesfrom_f_out, &w_fds)) {
 					int l = write(io_filesfrom_f_out,
 						      io_filesfrom_bp,
@@ -575,27 +611,29 @@
 				whine_about_eof(fd); /* Doesn't return. */
 			if (errno == EINTR || errno == EWOULDBLOCK
 			    || errno == EAGAIN)
 				continue;
 
 			/* Don't write errors on a dead socket. */
-			if (fd == sock_f_in)
+			if (fd == sock_f_in) {
 				close_multiplexing_out();
-			rsyserr(FERROR, errno, "read error");
+				rsyserr(FSOCKERR, errno, "read error");
+			} else
+				rsyserr(FERROR, errno, "read error");
 			exit_cleanup(RERR_STREAMIO);
 		}
 
 		buf += n;
 		len -= n;
-		ret += n;
+		cnt += n;
 
 		if (fd == sock_f_in && io_timeout)
 			last_io_in = time(NULL);
 	}
 
-	return ret;
+	return cnt;
 }
 
 /**
  * Read a line into the "fname" buffer (which must be at least MAXPATHLEN
  * characters long).
  */
@@ -724,34 +755,30 @@
  */
 static int readfd_unbuffered(int fd, char *buf, size_t len)
 {
 	static size_t remaining;
 	static size_t iobuf_in_ndx;
 	size_t msg_bytes;
-	int tag, ret = 0;
-#if MAXPATHLEN < 4096
-	char line[4096+1024];
-#else
-	char line[MAXPATHLEN+1024];
-#endif
+	int tag, cnt = 0;
+	char line[BIGPATHBUFLEN];
 
 	if (!iobuf_in || fd != sock_f_in)
 		return read_timeout(fd, buf, len);
 
 	if (!io_multiplexing_in && remaining == 0) {
 		remaining = read_timeout(fd, iobuf_in, iobuf_in_siz);
 		iobuf_in_ndx = 0;
 	}
 
-	while (ret == 0) {
+	while (cnt == 0) {
 		if (remaining) {
 			len = MIN(len, remaining);
 			memcpy(buf, iobuf_in + iobuf_in_ndx, len);
 			iobuf_in_ndx += len;
 			remaining -= len;
-			ret = len;
+			cnt = len;
 			break;
 		}
 
 		read_loop(fd, line, 4);
 		tag = IVAL(line, 0);
 
@@ -771,18 +798,19 @@
 			iobuf_in_ndx = 0;
 			break;
 		case MSG_DELETED:
 			if (msg_bytes >= sizeof line)
 				goto overflow;
 			read_loop(fd, line, msg_bytes);
-			line[msg_bytes] = '\0';
 			/* A directory name was sent with the trailing null */
 			if (msg_bytes > 0 && !line[msg_bytes-1])
 				log_delete(line, S_IFDIR);
-			else
+			else {
+				line[msg_bytes] = '\0';
 				log_delete(line, S_IFREG);
+			}
 			break;
 		case MSG_SUCCESS:
 			if (msg_bytes != 4) {
 				rprintf(FERROR, "invalid multi-message %d:%ld [%s]\n",
 					tag, (long)msg_bytes, who_am_i());
 				exit_cleanup(RERR_STREAMIO);
@@ -809,17 +837,15 @@
 		}
 	}
 
 	if (remaining == 0)
 		io_flush(NORMAL_FLUSH);
 
-	return ret;
+	return cnt;
 }
 
-
-
 /**
  * Do a buffered read from @p fd.  Don't return until all @p n bytes
  * have been read.  If all @p n can't be read then exit with an
  * error.
  **/
 static void readfd(int fd, char *buffer, size_t N)
@@ -821,18 +847,18 @@
  * Do a buffered read from @p fd.  Don't return until all @p n bytes
  * have been read.  If all @p n can't be read then exit with an
  * error.
  **/
 static void readfd(int fd, char *buffer, size_t N)
 {
-	int  ret;
+	int  cnt;
 	size_t total = 0;
 
 	while (total < N) {
-		ret = readfd_unbuffered(fd, buffer + total, N-total);
-		total += ret;
+		cnt = readfd_unbuffered(fd, buffer + total, N-total);
+		total += cnt;
 	}
 
 	if (fd == write_batch_monitor_in) {
 		if ((size_t)write(batch_fd, buffer, total) != total)
 			exit_cleanup(RERR_FILEIO);
 	}
@@ -846,43 +871,42 @@
 {
 	uchar b[2];
 	readfd(f, (char *)b, 2);
 	return (b[1] << 8) + b[0];
 }
 
-
 int32 read_int(int f)
 {
 	char b[4];
-	int32 ret;
+	int32 num;
 
 	readfd(f,b,4);
-	ret = IVAL(b,0);
-	if (ret == (int32)0xffffffff)
+	num = IVAL(b,0);
+	if (num == (int32)0xffffffff)
 		return -1;
-	return ret;
+	return num;
 }
 
 int64 read_longint(int f)
 {
-	int64 ret;
+	int64 num;
 	char b[8];
-	ret = read_int(f);
+	num = read_int(f);
 
-	if ((int32)ret != (int32)0xffffffff)
-		return ret;
+	if ((int32)num != (int32)0xffffffff)
+		return num;
 
 #if SIZEOF_INT64 < 8
 	rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
 	exit_cleanup(RERR_UNSUPPORTED);
 #else
 	readfd(f,b,8);
-	ret = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
+	num = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
 #endif
 
-	return ret;
+	return num;
 }
 
 void read_buf(int f,char *buf,size_t len)
 {
 	readfd(f,buf,len);
 }
@@ -921,12 +945,17 @@
 
 /* Populate a sum_struct with values from the socket.  This is
  * called by both the sender and the receiver. */
 void read_sum_head(int f, struct sum_struct *sum)
 {
 	sum->count = read_int(f);
+	if (sum->count < 0) {
+		rprintf(FERROR, "Invalid checksum count %ld [%s]\n",
+			(long)sum->count, who_am_i());
+		exit_cleanup(RERR_PROTOCOL);
+	}
 	sum->blength = read_int(f);
 	if (sum->blength < 0 || sum->blength > MAX_BLOCK_SIZE) {
 		rprintf(FERROR, "Invalid block length %ld [%s]\n",
 			(long)sum->blength, who_am_i());
 		exit_cleanup(RERR_PROTOCOL);
 	}
@@ -984,13 +1012,13 @@
 	static long total_written = 0; 
 	struct timeval tv, start_tv;
 	long elapsed_usec, sleep_usec;
 
 #define ONE_SEC	1000000L /* # of microseconds in a second */
 
-	if (!bwlimit)
+	if (!bwlimit_writemax)
 		return;
 
 	total_written += bytes_written; 
 
 	gettimeofday(&start_tv, NULL);
 	if (prior_tv.tv_sec) {
@@ -1014,24 +1042,23 @@
 	gettimeofday(&prior_tv, NULL);
 	elapsed_usec = (prior_tv.tv_sec - start_tv.tv_sec) * ONE_SEC
 		     + (prior_tv.tv_usec - start_tv.tv_usec);
 	total_written = (sleep_usec - elapsed_usec) * bwlimit / (ONE_SEC/1024);
 }
 
-
 /* Write len bytes to the file descriptor fd, looping as necessary to get
- * the job done and also (in certain circumstnces) reading any data on
+ * the job done and also (in certain circumstances) reading any data on
  * msg_fd_in to avoid deadlock.
  *
  * This function underlies the multiplexing system.  The body of the
  * application never calls this function directly. */
 static void writefd_unbuffered(int fd,char *buf,size_t len)
 {
 	size_t n, total = 0;
 	fd_set w_fds, r_fds;
-	int maxfd, count, ret, using_r_fds;
+	int maxfd, count, cnt, using_r_fds;
 	struct timeval tv;
 
 	no_flush++;
 
 	while (total < len) {
 		FD_ZERO(&w_fds);
@@ -1065,18 +1092,18 @@
 			read_msg_fd();
 
 		if (!FD_ISSET(fd, &w_fds))
 			continue;
 
 		n = len - total;
-		if (bwlimit && n > bwlimit_writemax)
+		if (bwlimit_writemax && n > bwlimit_writemax)
 			n = bwlimit_writemax;
-		ret = write(fd, buf + total, n);
+		cnt = write(fd, buf + total, n);
 
-		if (ret <= 0) {
-			if (ret < 0) {
+		if (cnt <= 0) {
+			if (cnt < 0) {
 				if (errno == EINTR)
 					continue;
 				if (errno == EWOULDBLOCK || errno == EAGAIN) {
 					msleep(1);
 					continue;
 				}
@@ -1096,18 +1123,18 @@
 				readfd_unbuffered(sock_f_in, io_filesfrom_buf,
 						  sizeof io_filesfrom_buf);
 			}
 			exit_cleanup(RERR_STREAMIO);
 		}
 
-		total += ret;
+		total += cnt;
 
 		if (fd == sock_f_out) {
 			if (io_timeout || am_generator)
 				last_io_out = time(NULL);
-			sleep_for_bwlimit(ret);
+			sleep_for_bwlimit(cnt);
 		}
 	}
 
 	no_flush--;
 }
 
@@ -1115,28 +1141,29 @@
 /**
  * Write an message to a multiplexed stream. If this fails then rsync
  * exits.
  **/
 static void mplex_write(enum msgcode code, char *buf, size_t len)
 {
-	char buffer[4096];
+	char buffer[1024];
 	size_t n = len;
 
 	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
 
 	/* When the generator reads messages from the msg_fd_in pipe, it can
 	 * cause output to occur down the socket.  Setting contiguous_write_len
 	 * prevents the reading of msg_fd_in once we actually start to write
 	 * this sequence of data (though we might read it before the start). */
 	if (am_generator && msg_fd_in >= 0)
 		contiguous_write_len = len + 4;
 
 	if (n > sizeof buffer - 4)
-		n = sizeof buffer - 4;
+		n = 0;
+	else
+		memcpy(buffer + 4, buf, n);
 
-	memcpy(&buffer[4], buf, n);
 	writefd_unbuffered(sock_f_out, buffer, n+4);
 
 	len -= n;
 	buf += n;
 
 	if (len)
@@ -1143,16 +1170,15 @@
 		writefd_unbuffered(sock_f_out, buf, len);
 
 	if (am_generator && msg_fd_in >= 0)
 		contiguous_write_len = 0;
 }
 
-
 void io_flush(int flush_it_all)
 {
-	msg_list_push(flush_it_all);
+	msg_list_flush(flush_it_all);
 
 	if (!iobuf_out_cnt || no_flush)
 		return;
 
 	if (io_multiplexing_out)
 		mplex_write(MSG_DATA, iobuf_out, iobuf_out_cnt);
@@ -1306,30 +1326,33 @@
 		}
 	}
 	*buf = '\0';
 	return maxlen > 0;
 }
 
-
 void io_printf(int fd, const char *format, ...)
 {
 	va_list ap;
-	char buf[1024];
+	char buf[BIGPATHBUFLEN];
 	int len;
 
 	va_start(ap, format);
 	len = vsnprintf(buf, sizeof buf, format, ap);
 	va_end(ap);
 
 	if (len < 0)
 		exit_cleanup(RERR_STREAMIO);
 
+	if (len > (int)sizeof buf) {
+		rprintf(FERROR, "io_printf() was too long for the buffer.\n");
+		exit_cleanup(RERR_STREAMIO);
+	}
+
 	write_sbuf(fd, buf);
 }
 
-
 /** Setup for multiplexing a MSG_* stream with the data stream. */
 void io_start_multiplex_out(void)
 {
 	io_flush(NORMAL_FLUSH);
 	io_start_buffering_out();
 	io_multiplexing_out = 1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/permstring.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/permstring.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/permstring.c	2003-01-11 04:08:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/permstring.c	2006-01-30 08:39:59.000000000 +0800
@@ -23,14 +23,13 @@
 /**
  * Produce a string representation of Unix mode bits like that used by
  * ls(1).
  *
  * @param buf buffer of at least 11 characters
  **/
-void permstring(char *perms,
-		int mode)
+void permstring(char *perms, mode_t mode)
 {
 	static const char *perm_map = "rwxrwxrwx";
 	int i;
 
 	strcpy(perms, "----------");
 	
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/permstring.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/permstring.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/permstring.h	2001-11-27 14:43:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/permstring.h	2006-01-30 08:39:59.000000000 +0800
@@ -1,3 +1,3 @@
 #define PERMSTRING_SIZE 11
 
-void permstring(char *perms, int mode);
+void permstring(char *perms, mode_t mode);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/pool_alloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/pool_alloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/pool_alloc.c	2005-01-21 06:37:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/pool_alloc.c	2005-11-15 05:24:30.000000000 +0800
@@ -53,14 +53,13 @@
 		return pool;
 	memset(pool, 0, sizeof (struct alloc_pool));
 
 	pool->size = size	/* round extent size to min alignment reqs */
 	    ? (size + MINALIGN - 1) & ~(MINALIGN - 1)
 	    : POOL_DEF_EXTENT;
-	if (pool->flags & POOL_INTERN)
-	{
+	if (pool->flags & POOL_INTERN) {
 		pool->size -= sizeof (struct pool_extent);
 		flags |= POOL_APPEND;
 	}
 	pool->quantum = quantum ? quantum : MINALIGN;
 	pool->bomb = bomb;
 	pool->flags = flags;
@@ -74,21 +73,19 @@
 	struct alloc_pool *pool = (struct alloc_pool *) p;
 	struct pool_extent	*cur, *next;
 
 	if (!pool)
 		return;
 
-	if (pool->live)
-	{
+	if (pool->live) {
 		cur = pool->live;
 		free(cur->start);
 		if (!(pool->flags & POOL_APPEND))
 			free(cur);
 	}
-	for (cur = pool->free; cur; cur = next)
-	{
+	for (cur = pool->free; cur; cur = next) {
 		next = cur->next;
 		free(cur->start);
 		if (!(pool->flags & POOL_APPEND))
 			free(cur);
 	}
 	free(pool);
@@ -106,22 +103,20 @@
 	else if (pool->quantum > 1 && len % pool->quantum)
 		len += pool->quantum - len % pool->quantum;
 
 	if (len > pool->size)
 		goto bomb;
 
-	if (!pool->live || len > pool->live->free)
-	{
+	if (!pool->live || len > pool->live->free) {
 		void	*start;
 		size_t	free;
 		size_t	bound;
 		size_t	sqew;
 		size_t	asize;
 
-		if (pool->live)
-		{
+		if (pool->live) {
 			pool->live->next = pool->free;
 			pool->free = pool->live;
 		}
 
 		free = pool->size;
 		bound = 0;
@@ -134,22 +129,17 @@
 			goto bomb;
 
 		if (pool->flags & POOL_CLEAR)
 			memset(start, 0, pool->size);
 
 		if (pool->flags & POOL_APPEND)
-		{
 			pool->live = PTR_ADD(start, free);
-		}
 		else if (!(pool->live = (struct pool_extent *) malloc(sizeof (struct pool_extent))))
-		{
 			goto bomb;
-		}
 		if (pool->flags & POOL_QALIGN && pool->quantum > 1
-		    && (sqew = (size_t)PTR_ADD(start, free) % pool->quantum))
-		{
+		    && (sqew = (size_t)PTR_ADD(start, free) % pool->quantum)) {
 			bound  += sqew;
 			free -= sqew;
 		}
 		pool->live->start = start;
 		pool->live->free = free;
 		pool->live->bound = bound;
@@ -183,85 +173,75 @@
 
 	if (!len)
 		len = pool->quantum;
 	else if (pool->quantum > 1 && len % pool->quantum)
 		len += pool->quantum - len % pool->quantum;
 
-	if (!addr && pool->live)
-	{
+	if (!addr && pool->live) {
 		pool->live->next = pool->free;
 		pool->free = pool->live;
 		pool->live = NULL;
 		return;
 	}
 	pool->n_freed++;
 	pool->b_freed += len;
 
 	cur = pool->live;
-	if (cur
-	    && addr >= cur->start
-	    && addr < PTR_ADD(cur->start, pool->size))
-	{
-		if (addr == PTR_ADD(cur->start, cur->free))
-		{
+	if (cur && addr >= cur->start
+	    && addr < PTR_ADD(cur->start, pool->size)) {
+		if (addr == PTR_ADD(cur->start, cur->free)) {
 			if (pool->flags & POOL_CLEAR)
 				memset(addr, 0, len);
 			pool->b_freed += len;
-		} else {
+		} else
 			cur->bound += len;
-		}
-		if (cur->free + cur->bound >= pool->size)
-		{
+		if (cur->free + cur->bound >= pool->size) {
 			size_t sqew;
 
 			cur->free = pool->size;
 			cur->bound = 0;
 			if (pool->flags & POOL_QALIGN && pool->quantum > 1
-			    && (sqew = (size_t)PTR_ADD(cur->start, cur->free) % pool->quantum))
-			{
+			    && (sqew = (size_t)PTR_ADD(cur->start, cur->free) % pool->quantum)) {
 				cur->bound += sqew;
 				cur->free -= sqew;
 			}
 		}
 		return;
 	}
-	for (prev = NULL, cur = pool->free; cur; prev = cur, cur = cur->next)
-	{
+	for (prev = NULL, cur = pool->free; cur; prev = cur, cur = cur->next) {
 		if (addr >= cur->start
 		    && addr < PTR_ADD(cur->start, pool->size))
 			break;
 	}
 	if (!cur)
 		return;
 
-	if (prev)
-	{
+	if (prev) {
 		prev->next = cur->next;
 		cur->next = pool->free;
 		pool->free = cur;
 	}
 	cur->bound += len;
 
-	if (cur->free + cur->bound >= pool->size)
-	{
+	if (cur->free + cur->bound >= pool->size) {
 		pool->free = cur->next;
 
 		free(cur->start);
 		if (!(pool->flags & POOL_APPEND))
 			free(cur);
 		pool->e_freed++;
 	}
 	return;
 }
 
 #define FDPRINT(label, value) \
-	snprintf(buf, BUFSIZ, label, value), \
-	write(fd, buf, strlen(buf));
+	snprintf(buf, sizeof buf, label, value), \
+	write(fd, buf, strlen(buf))
 
 #define FDEXTSTAT(ext) \
-	snprintf(buf, BUFSIZ, "  %12ld  %5ld\n", \
+	snprintf(buf, sizeof buf, "  %12ld  %5ld\n", \
 		(long) ext->free, \
 		(long) ext->bound), \
 	write(fd, buf, strlen(buf))
 
 void
 pool_stats(alloc_pool_t p, int fd, int summarize)
@@ -288,17 +268,13 @@
 	if (!pool->live && !pool->free)
 		return;
 
 	write(fd, "\n", 1);
 
 	if (pool->live)
-	{
 		FDEXTSTAT(pool->live);
-	}
 	strcpy(buf, "   FREE    BOUND\n");
 	write(fd, buf, strlen(buf));
 
 	for (cur = pool->free; cur; cur = cur->next)
-	{
 		FDEXTSTAT(cur);
-	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/snprintf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/snprintf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/snprintf.c	2005-02-22 01:02:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/snprintf.c	2005-10-12 04:21:03.000000000 +0800
@@ -143,13 +143,13 @@
 #define LLONG long long
 #else
 #define LLONG long
 #endif
 
 #ifndef VA_COPY
-#ifdef HAVE_VA_COPY
+#if defined HAVE_VA_COPY || defined va_copy
 #define VA_COPY(dest, src) va_copy(dest, src)
 #else
 #ifdef HAVE___VA_COPY
 #define VA_COPY(dest, src) __va_copy(dest, src)
 #else
 #define VA_COPY(dest, src) (dest) = (src)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/wildmatch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/wildmatch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/wildmatch.c	2005-01-29 05:01:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/wildmatch.c	2006-01-03 01:46:15.000000000 +0800
@@ -54,176 +54,315 @@
 #define ISXDIGIT(c) (ISASCII(c) && isxdigit(c))
 
 #ifdef WILD_TEST_ITERATIONS
 int wildmatch_iteration_count;
 #endif
 
-static int domatch(const uchar *p, const uchar *text)
+static int force_lower_case = 0;
+
+/* Match pattern "p" against the a virtually-joined string consisting
+ * of "text" and any strings in array "a". */
+static int dowild(const uchar *p, const uchar *text, const uchar*const *a)
 {
-    int matched, special;
-    uchar ch, prev;
+    uchar p_ch;
 
 #ifdef WILD_TEST_ITERATIONS
     wildmatch_iteration_count++;
 #endif
 
-    for ( ; (ch = *p) != '\0'; text++, p++) {
-	if (*text == '\0' && ch != '*')
-	    return FALSE;
-	switch (ch) {
+    for ( ; (p_ch = *p) != '\0'; text++, p++) {
+	int matched, special;
+	uchar t_ch, prev_ch;
+	while ((t_ch = *text) == '\0') {
+	    if (*a == NULL) {
+		if (p_ch != '*')
+		    return ABORT_ALL;
+		break;
+	    }
+	    text = *a++;
+	}
+	if (force_lower_case && ISUPPER(t_ch))
+	    t_ch = tolower(t_ch);
+	switch (p_ch) {
 	  case '\\':
 	    /* Literal match with following character.  Note that the test
 	     * in "default" handles the p[1] == '\0' failure case. */
-	    ch = *++p;
+	    p_ch = *++p;
 	    /* FALLTHROUGH */
 	  default:
-	    if (*text != ch)
+	    if (t_ch != p_ch)
 		return FALSE;
 	    continue;
 	  case '?':
 	    /* Match anything but '/'. */
-	    if (*text == '/')
+	    if (t_ch == '/')
 		return FALSE;
 	    continue;
 	  case '*':
 	    if (*++p == '*') {
 		while (*++p == '*') {}
 		special = TRUE;
-	    }
-	    else
+	    } else
 		special = FALSE;
 	    if (*p == '\0') {
 		/* Trailing "**" matches everything.  Trailing "*" matches
 		 * only if there are no more slash characters. */
-		return special? TRUE : strchr((char*)text, '/') == NULL;
+		if (!special) {
+		    do {
+			if (strchr((char*)text, '/') != NULL)
+			    return FALSE;
+		    } while ((text = *a++) != NULL);
+		}
+		return TRUE;
 	    }
-	    for ( ; *text; text++) {
-		if ((matched = domatch(p, text)) != FALSE) {
+	    while (1) {
+		if (t_ch == '\0') {
+		    if ((text = *a++) == NULL)
+			break;
+		    t_ch = *text;
+		    continue;
+		}
+		if ((matched = dowild(p, text, a)) != FALSE) {
 		    if (!special || matched != ABORT_TO_STARSTAR)
 			return matched;
-		}
-		else if (!special && *text == '/')
+		} else if (!special && t_ch == '/')
 		    return ABORT_TO_STARSTAR;
+		t_ch = *++text;
 	    }
 	    return ABORT_ALL;
 	  case '[':
-	    ch = *++p;
+	    p_ch = *++p;
 #ifdef NEGATE_CLASS2
-	    if (ch == NEGATE_CLASS2)
-		ch = NEGATE_CLASS;
+	    if (p_ch == NEGATE_CLASS2)
+		p_ch = NEGATE_CLASS;
 #endif
 	    /* Assign literal TRUE/FALSE because of "matched" comparison. */
-	    special = ch == NEGATE_CLASS? TRUE : FALSE;
+	    special = p_ch == NEGATE_CLASS? TRUE : FALSE;
 	    if (special) {
 		/* Inverted character class. */
-		ch = *++p;
+		p_ch = *++p;
 	    }
-	    prev = 0;
+	    prev_ch = 0;
 	    matched = FALSE;
 	    do {
-		if (!ch)
+		if (!p_ch)
 		    return ABORT_ALL;
-		if (ch == '\\') {
-		    ch = *++p;
-		    if (!ch)
+		if (p_ch == '\\') {
+		    p_ch = *++p;
+		    if (!p_ch)
 			return ABORT_ALL;
-		    if (*text == ch)
+		    if (t_ch == p_ch)
 			matched = TRUE;
-		}
-		else if (ch == '-' && prev && p[1] && p[1] != ']') {
-		    ch = *++p;
-		    if (ch == '\\') {
-			ch = *++p;
-			if (!ch)
+		} else if (p_ch == '-' && prev_ch && p[1] && p[1] != ']') {
+		    p_ch = *++p;
+		    if (p_ch == '\\') {
+			p_ch = *++p;
+			if (!p_ch)
 			    return ABORT_ALL;
 		    }
-		    if (*text <= ch && *text >= prev)
+		    if (t_ch <= p_ch && t_ch >= prev_ch)
 			matched = TRUE;
-		    ch = 0; /* This makes "prev" get set to 0. */
-		}
-		else if (ch == '[' && p[1] == ':') {
+		    p_ch = 0; /* This makes "prev_ch" get set to 0. */
+		} else if (p_ch == '[' && p[1] == ':') {
 		    const uchar *s;
 		    int i;
-		    for (s = p += 2; (ch = *p) && ch != ']'; p++) {}
-		    if (!ch)
+		    for (s = p += 2; (p_ch = *p) && p_ch != ']'; p++) {}
+		    if (!p_ch)
 			return ABORT_ALL;
 		    i = p - s - 1;
 		    if (i < 0 || p[-1] != ':') {
 			/* Didn't find ":]", so treat like a normal set. */
 			p = s - 2;
-			ch = '[';
-			if (*text == ch)
+			p_ch = '[';
+			if (t_ch == p_ch)
 			    matched = TRUE;
 			continue;
 		    }
 		    if (CC_EQ(s,i, "alnum")) {
-			if (ISALNUM(*text))
+			if (ISALNUM(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "alpha")) {
-			if (ISALPHA(*text))
+		    } else if (CC_EQ(s,i, "alpha")) {
+			if (ISALPHA(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "blank")) {
-			if (ISBLANK(*text))
+		    } else if (CC_EQ(s,i, "blank")) {
+			if (ISBLANK(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "cntrl")) {
-			if (ISCNTRL(*text))
+		    } else if (CC_EQ(s,i, "cntrl")) {
+			if (ISCNTRL(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "digit")) {
-			if (ISDIGIT(*text))
+		    } else if (CC_EQ(s,i, "digit")) {
+			if (ISDIGIT(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "graph")) {
-			if (ISGRAPH(*text))
+		    } else if (CC_EQ(s,i, "graph")) {
+			if (ISGRAPH(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "lower")) {
-			if (ISLOWER(*text))
+		    } else if (CC_EQ(s,i, "lower")) {
+			if (ISLOWER(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "print")) {
-			if (ISPRINT(*text))
+		    } else if (CC_EQ(s,i, "print")) {
+			if (ISPRINT(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "punct")) {
-			if (ISPUNCT(*text))
+		    } else if (CC_EQ(s,i, "punct")) {
+			if (ISPUNCT(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "space")) {
-			if (ISSPACE(*text))
+		    } else if (CC_EQ(s,i, "space")) {
+			if (ISSPACE(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "upper")) {
-			if (ISUPPER(*text))
+		    } else if (CC_EQ(s,i, "upper")) {
+			if (ISUPPER(t_ch))
 			    matched = TRUE;
-		    }
-		    else if (CC_EQ(s,i, "xdigit")) {
-			if (ISXDIGIT(*text))
+		    } else if (CC_EQ(s,i, "xdigit")) {
+			if (ISXDIGIT(t_ch))
 			    matched = TRUE;
-		    }
-		    else /* malformed [:class:] string */
+		    } else /* malformed [:class:] string */
 			return ABORT_ALL;
-		    ch = 0; /* This makes "prev" get set to 0. */
-		}
-		else if (*text == ch)
+		    p_ch = 0; /* This makes "prev_ch" get set to 0. */
+		} else if (t_ch == p_ch)
 		    matched = TRUE;
-	    } while (prev = ch, (ch = *++p) != ']');
-	    if (matched == special || *text == '/')
+	    } while (prev_ch = p_ch, (p_ch = *++p) != ']');
+	    if (matched == special || t_ch == '/')
 		return FALSE;
 	    continue;
 	}
     }
 
-    return *text == '\0';
+    do {
+	if (*text)
+	    return FALSE;
+    } while ((text = *a++) != NULL);
+
+    return TRUE;
+}
+
+/* Match literal string "s" against the a virtually-joined string consisting
+ * of "text" and any strings in array "a". */
+static int doliteral(const uchar *s, const uchar *text, const uchar*const *a)
+{
+    for ( ; *s != '\0'; text++, s++) {
+	while (*text == '\0') {
+	    if ((text = *a++) == NULL)
+		return FALSE;
+	}
+	if (*text != *s)
+	    return FALSE;
+    }
+
+    do {
+	if (*text)
+	    return FALSE;
+    } while ((text = *a++) != NULL);
+
+    return TRUE;
+}
+
+/* Return the last "count" path elements from the concatenated string.
+ * We return a string pointer to the start of the string, and update the
+ * array pointer-pointer to point to any remaining string elements. */
+static const uchar *trailing_N_elements(const uchar*const **a_ptr, int count)
+{
+    const uchar*const *a = *a_ptr;
+    const uchar*const *first_a = a;
+
+    while (*a)
+	    a++;
+
+    while (a != first_a) {
+	const uchar *s = *--a;
+	s += strlen((char*)s);
+	while (--s >= *a) {
+	    if (*s == '/' && !--count) {
+		*a_ptr = a+1;
+		return s+1;
+	    }
+	}
+    }
+
+    if (count == 1) {
+	*a_ptr = a+1;
+	return *a;
+    }
+
+    return NULL;
+}
+
+/* Match the "pattern" against the "text" string. */
+int wildmatch(const char *pattern, const char *text)
+{
+    static const uchar *nomore[1]; /* A NULL pointer. */
+#ifdef WILD_TEST_ITERATIONS
+    wildmatch_iteration_count = 0;
+#endif
+    return dowild((const uchar*)pattern, (const uchar*)text, nomore) == TRUE;
 }
 
-/* Find the pattern (p) in the text string (t). */
-int wildmatch(const char *p, const char *t)
+/* Match the "pattern" against the forced-to-lower-case "text" string. */
+int iwildmatch(const char *pattern, const char *text)
 {
+    static const uchar *nomore[1]; /* A NULL pointer. */
+    int ret;
 #ifdef WILD_TEST_ITERATIONS
     wildmatch_iteration_count = 0;
 #endif
-    return domatch((const uchar*)p, (const uchar*)t) == TRUE;
+    force_lower_case = 1;
+    ret = dowild((const uchar*)pattern, (const uchar*)text, nomore) == TRUE;
+    force_lower_case = 0;
+    return ret;
+}
+
+/* Match pattern "p" against the a virtually-joined string consisting
+ * of all the pointers in array "texts" (which has a NULL pointer at the
+ * end).  The int "where" can be 0 (normal matching), > 0 (match only
+ * the trailing N slash-separated filename components of "texts"), or < 0
+ * (match the "pattern" at the start or after any slash in "texts"). */
+int wildmatch_array(const char *pattern, const char*const *texts, int where)
+{
+    const uchar *p = (const uchar*)pattern;
+    const uchar*const *a = (const uchar*const*)texts;
+    const uchar *text;
+    int matched;
+
+#ifdef WILD_TEST_ITERATIONS
+    wildmatch_iteration_count = 0;
+#endif
+
+    if (where > 0)
+	text = trailing_N_elements(&a, where);
+    else
+	text = *a++;
+    if (!text)
+	return FALSE;
+
+    if ((matched = dowild(p, text, a)) != TRUE && where < 0
+     && matched != ABORT_ALL) {
+	while (1) {
+	    if (*text == '\0') {
+		if ((text = (uchar*)*a++) == NULL)
+		    return FALSE;
+		continue;
+	    }
+	    if (*text++ == '/' && (matched = dowild(p, text, a)) != FALSE
+	     && matched != ABORT_TO_STARSTAR)
+		break;
+	}
+    }
+    return matched == TRUE;
+}
+
+/* Match literal string "s" against the a virtually-joined string consisting
+ * of all the pointers in array "texts" (which has a NULL pointer at the
+ * end).  The int "where" can be 0 (normal matching), or > 0 (match
+ * only the trailing N slash-separated filename components of "texts"). */
+int litmatch_array(const char *string, const char*const *texts, int where)
+{
+    const uchar *s = (const uchar*)string;
+    const uchar*const *a = (const uchar* const*)texts;
+    const uchar *text;
+
+    if (where > 0)
+	text = trailing_N_elements(&a, where);
+    else
+	text = *a++;
+    if (!text)
+	return FALSE;
+
+    return doliteral(s, text, a) == TRUE;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/wildmatch.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/wildmatch.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/lib/wildmatch.h	2003-07-05 08:03:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/lib/wildmatch.h	2006-01-03 01:46:12.000000000 +0800
@@ -1,3 +1,6 @@
 /* wildmatch.h */
 
-int wildmatch(const char *p, const char *text);
+int wildmatch(const char *pattern, const char *text);
+int iwildmatch(const char *pattern, const char *text);
+int wildmatch_array(const char *pattern, const char*const *texts, int where);
+int litmatch_array(const char *string, const char*const *texts, int where);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/loadparm.c	2005-06-11 00:57:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/loadparm.c	2006-01-31 05:47:02.000000000 +0800
@@ -95,93 +95,113 @@
 
 /*
  * This structure describes global (ie., server-wide) parameters.
  */
 typedef struct
 {
-	char *motd_file;
+	char *bind_address;
 	char *log_file;
+	char *motd_file;
 	char *pid_file;
 	char *socket_options;
-	char *bind_address;
-	int syslog_facility;
+
 	int rsync_port;
+	int syslog_facility;
 } global;
 
 static global Globals;
 
 
 /*
- * This structure describes a single service.
+ * This structure describes a single service.  Their order must match the
+ * initializers below, which you can accomplish by keeping each sub-section
+ * sorted.  (e.g. in vim, just visually select each subsection and use !sort.)
  */
 typedef struct
 {
-	char *name;
-	char *path;
+	char *auth_users;
 	char *comment;
-	char *lock_file;
-	BOOL read_only;
-	BOOL write_only;
-	BOOL list;
-	BOOL use_chroot;
-	BOOL transfer_logging;
-	BOOL ignore_errors;
-	char *uid;
+	char *dont_compress;
+	char *exclude;
+	char *exclude_from;
+	char *filter;
 	char *gid;
 	char *hosts_allow;
 	char *hosts_deny;
-	char *auth_users;
-	char *secrets_file;
-	BOOL strict_modes;
-	char *filter;
-	char *exclude;
-	char *exclude_from;
 	char *include;
 	char *include_from;
+	char *incoming_chmod;
+	char *lock_file;
 	char *log_format;
+	char *name;
+	char *outgoing_chmod;
+	char *path;
+	char *postxfer_exec;
+	char *prexfer_exec;
 	char *refuse_options;
-	char *dont_compress;
-	int timeout;
+	char *secrets_file;
+	char *temp_dir;
+	char *uid;
+
 	int max_connections;
 	int max_verbosity;
+	int timeout;
+
+	BOOL ignore_errors;
 	BOOL ignore_nonreadable;
+	BOOL list;
+	BOOL read_only;
+	BOOL strict_modes;
+	BOOL transfer_logging;
+	BOOL use_chroot;
+	BOOL write_only;
 } service;
 
 
-/* This is a default service used to prime a services structure */
+/* This is a default service used to prime a services structure.  In order
+ * to make these easy to keep sorted in the same way as the variables
+ * above, use the variable name in the leading comment, including a
+ * trailing ';' (to avoid a sorting problem with trailing digits). */
 static service sDefault =
 {
-	NULL,    /* name */
-	NULL,    /* path */
-	NULL,    /* comment */
-	DEFAULT_LOCK_FILE,    /* lock file */
-	True,    /* read only */
-	False,   /* write only */
-	True,    /* list */
-	True,    /* use chroot */
-	False,   /* transfer logging */
-	False,   /* ignore errors */
-	NOBODY_USER,/* uid */
-	NOBODY_GROUP,/* gid */
-	NULL,    /* hosts allow */
-	NULL,    /* hosts deny */
-	NULL,    /* auth users */
-	NULL,    /* secrets file */
-	True,   /* strict modes */
-	NULL,    /* filter */
-	NULL,    /* exclude */
-	NULL,    /* exclude from */
-	NULL,    /* include */
-	NULL,    /* include from */
-	"%o %h [%a] %m (%u) %f %l",    /* log format */
-	NULL,    /* refuse options */
-	"*.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz",    /* dont compress */
-	0,        /* timeout */
-	0,        /* max connections */
-	1,        /* max verbosity */
-	False     /* ignore nonreadable */
+ /* auth_users; */		NULL,
+ /* comment; */			NULL,
+ /* dont_compress; */		"*.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz",
+ /* exclude; */			NULL,
+ /* exclude_from; */		NULL,
+ /* filter; */			NULL,
+ /* gid; */			NOBODY_GROUP,
+ /* hosts_allow; */		NULL,
+ /* hosts_deny; */		NULL,
+ /* include; */			NULL,
+ /* include_from; */		NULL,
+ /* incoming_chmod; */		NULL,
+ /* lock_file; */		DEFAULT_LOCK_FILE,
+ /* log_format; */		"%o %h [%a] %m (%u) %f %l",
+ /* name; */			NULL,
+ /* outgoing_chmod; */		NULL,
+ /* path; */			NULL,
+ /* postxfer_exec; */		NULL,
+ /* prexfer_exec; */		NULL,
+ /* refuse_options; */		NULL,
+ /* secrets_file; */		NULL,
+ /* temp_dir; */ 		NULL,
+ /* uid; */			NOBODY_USER,
+
+ /* max_connections; */		0,
+ /* max_verbosity; */		1,
+ /* timeout; */			0,
+
+ /* ignore_errors; */		False,
+ /* ignore_nonreadable; */	False,
+ /* list; */			True,
+ /* read_only; */		True,
+ /* strict_modes; */		True,
+ /* transfer_logging; */	False,
+ /* use_chroot; */		True,
+ /* write_only; */		False,
 };
 
 
 
 /* local variables */
 static service **ServicePtrs = NULL;
@@ -258,50 +278,57 @@
 	{ -1, NULL }};
 
 
 /* note that we do not initialise the defaults union - it is not allowed in ANSI C */
 static struct parm_struct parm_table[] =
 {
-  {"motd file",        P_STRING,  P_GLOBAL, &Globals.motd_file,    NULL,   0},
-  {"syslog facility",  P_ENUM,    P_GLOBAL, &Globals.syslog_facility, enum_facilities,0},
-  {"socket options",   P_STRING,  P_GLOBAL, &Globals.socket_options,NULL,  0},
-  {"log file",         P_STRING,  P_GLOBAL, &Globals.log_file,      NULL,  0},
-  {"pid file",         P_STRING,  P_GLOBAL, &Globals.pid_file,      NULL,  0},
-  {"port",             P_INTEGER, P_GLOBAL, &Globals.rsync_port,    NULL,  0},
-  {"address",          P_STRING,  P_GLOBAL, &Globals.bind_address,  NULL,  0},
-
-  {"timeout",          P_INTEGER, P_LOCAL,  &sDefault.timeout,     NULL,  0},
-  {"max connections",  P_INTEGER, P_LOCAL,  &sDefault.max_connections,NULL, 0},
-  {"max verbosity",    P_INTEGER, P_LOCAL,  &sDefault.max_verbosity,NULL,  0},
-  {"name",             P_STRING,  P_LOCAL,  &sDefault.name,        NULL,   0},
-  {"comment",          P_STRING,  P_LOCAL,  &sDefault.comment,     NULL,   0},
-  {"lock file",        P_STRING,  P_LOCAL,  &sDefault.lock_file,   NULL,   0},
-  {"path",             P_PATH,    P_LOCAL,  &sDefault.path,        NULL,   0},
-  {"read only",        P_BOOL,    P_LOCAL,  &sDefault.read_only,   NULL,   0},
-  {"write only",       P_BOOL,    P_LOCAL,  &sDefault.write_only,  NULL,   0},
-  {"list",             P_BOOL,    P_LOCAL,  &sDefault.list,        NULL,   0},
-  {"use chroot",       P_BOOL,    P_LOCAL,  &sDefault.use_chroot,  NULL,   0},
-  {"ignore nonreadable",P_BOOL,   P_LOCAL,  &sDefault.ignore_nonreadable,  NULL,   0},
-  {"uid",              P_STRING,  P_LOCAL,  &sDefault.uid,         NULL,   0},
-  {"gid",              P_STRING,  P_LOCAL,  &sDefault.gid,         NULL,   0},
-  {"hosts allow",      P_STRING,  P_LOCAL,  &sDefault.hosts_allow, NULL,   0},
-  {"hosts deny",       P_STRING,  P_LOCAL,  &sDefault.hosts_deny,  NULL,   0},
-  {"auth users",       P_STRING,  P_LOCAL,  &sDefault.auth_users,  NULL,   0},
-  {"secrets file",     P_STRING,  P_LOCAL,  &sDefault.secrets_file,NULL,   0},
-  {"strict modes",     P_BOOL,    P_LOCAL,  &sDefault.strict_modes,NULL,   0},
-  {"filter",           P_STRING,  P_LOCAL,  &sDefault.filter,      NULL,   0},
-  {"exclude",          P_STRING,  P_LOCAL,  &sDefault.exclude,     NULL,   0},
-  {"exclude from",     P_STRING,  P_LOCAL,  &sDefault.exclude_from,NULL,   0},
-  {"include",          P_STRING,  P_LOCAL,  &sDefault.include,     NULL,   0},
-  {"include from",     P_STRING,  P_LOCAL,  &sDefault.include_from,NULL,   0},
-  {"transfer logging", P_BOOL,    P_LOCAL,  &sDefault.transfer_logging,NULL,0},
-  {"ignore errors",    P_BOOL,    P_LOCAL,  &sDefault.ignore_errors,NULL,0},
-  {"log format",       P_STRING,  P_LOCAL,  &sDefault.log_format,  NULL,   0},
-  {"refuse options",   P_STRING,  P_LOCAL,  &sDefault.refuse_options,NULL, 0},
-  {"dont compress",    P_STRING,  P_LOCAL,  &sDefault.dont_compress,NULL,  0},
-  {NULL,               P_BOOL,    P_NONE,   NULL,                  NULL,   0}
+ {"address",           P_STRING, P_GLOBAL,&Globals.bind_address,       NULL,0},
+ {"log file",          P_STRING, P_GLOBAL,&Globals.log_file,           NULL,0},
+ {"motd file",         P_STRING, P_GLOBAL,&Globals.motd_file,          NULL,0},
+ {"pid file",          P_STRING, P_GLOBAL,&Globals.pid_file,           NULL,0},
+ {"port",              P_INTEGER,P_GLOBAL,&Globals.rsync_port,         NULL,0},
+ {"socket options",    P_STRING, P_GLOBAL,&Globals.socket_options,     NULL,0},
+ {"syslog facility",   P_ENUM,   P_GLOBAL,&Globals.syslog_facility,enum_facilities,0},
+
+ {"auth users",        P_STRING, P_LOCAL, &sDefault.auth_users,        NULL,0},
+ {"comment",           P_STRING, P_LOCAL, &sDefault.comment,           NULL,0},
+ {"dont compress",     P_STRING, P_LOCAL, &sDefault.dont_compress,     NULL,0},
+ {"exclude from",      P_STRING, P_LOCAL, &sDefault.exclude_from,      NULL,0},
+ {"exclude",           P_STRING, P_LOCAL, &sDefault.exclude,           NULL,0},
+ {"filter",            P_STRING, P_LOCAL, &sDefault.filter,            NULL,0},
+ {"gid",               P_STRING, P_LOCAL, &sDefault.gid,               NULL,0},
+ {"hosts allow",       P_STRING, P_LOCAL, &sDefault.hosts_allow,       NULL,0},
+ {"hosts deny",        P_STRING, P_LOCAL, &sDefault.hosts_deny,        NULL,0},
+ {"ignore errors",     P_BOOL,   P_LOCAL, &sDefault.ignore_errors,     NULL,0},
+ {"ignore nonreadable",P_BOOL,   P_LOCAL, &sDefault.ignore_nonreadable,NULL,0},
+ {"include from",      P_STRING, P_LOCAL, &sDefault.include_from,      NULL,0},
+ {"include",           P_STRING, P_LOCAL, &sDefault.include,           NULL,0},
+ {"incoming chmod",    P_STRING, P_LOCAL, &sDefault.incoming_chmod,    NULL,0},
+ {"list",              P_BOOL,   P_LOCAL, &sDefault.list,              NULL,0},
+ {"lock file",         P_STRING, P_LOCAL, &sDefault.lock_file,         NULL,0},
+ {"log format",        P_STRING, P_LOCAL, &sDefault.log_format,        NULL,0},
+ {"max connections",   P_INTEGER,P_LOCAL, &sDefault.max_connections,   NULL,0},
+ {"max verbosity",     P_INTEGER,P_LOCAL, &sDefault.max_verbosity,     NULL,0},
+ {"name",              P_STRING, P_LOCAL, &sDefault.name,              NULL,0},
+ {"outgoing chmod",    P_STRING, P_LOCAL, &sDefault.outgoing_chmod,    NULL,0},
+ {"path",              P_PATH,   P_LOCAL, &sDefault.path,              NULL,0},
+#ifdef HAVE_PUTENV
+ {"post-xfer exec",    P_STRING, P_LOCAL, &sDefault.postxfer_exec,     NULL,0},
+ {"pre-xfer exec",     P_STRING, P_LOCAL, &sDefault.prexfer_exec,      NULL,0},
+#endif
+ {"read only",         P_BOOL,   P_LOCAL, &sDefault.read_only,         NULL,0},
+ {"refuse options",    P_STRING, P_LOCAL, &sDefault.refuse_options,    NULL,0},
+ {"secrets file",      P_STRING, P_LOCAL, &sDefault.secrets_file,      NULL,0},
+ {"strict modes",      P_BOOL,   P_LOCAL, &sDefault.strict_modes,      NULL,0},
+ {"temp dir",          P_PATH,   P_LOCAL, &sDefault.temp_dir,          NULL,0},
+ {"timeout",           P_INTEGER,P_LOCAL, &sDefault.timeout,           NULL,0},
+ {"transfer logging",  P_BOOL,   P_LOCAL, &sDefault.transfer_logging,  NULL,0},
+ {"uid",               P_STRING, P_LOCAL, &sDefault.uid,               NULL,0},
+ {"use chroot",        P_BOOL,   P_LOCAL, &sDefault.use_chroot,        NULL,0},
+ {"write only",        P_BOOL,   P_LOCAL, &sDefault.write_only,        NULL,0},
+ {NULL,                P_BOOL,   P_NONE,  NULL,                        NULL,0}
 };
 
 
 /***************************************************************************
 Initialise the global parameter structure.
 ***************************************************************************/
@@ -342,49 +369,57 @@
 #define FN_LOCAL_CHAR(fn_name,val) \
  char fn_name(int i) {return(LP_SNUM_OK(i)? pSERVICE(i)->val : sDefault.val);}
 #define FN_LOCAL_INTEGER(fn_name,val) \
  int fn_name(int i) {return(LP_SNUM_OK(i)? pSERVICE(i)->val : sDefault.val);}
 
 
-FN_GLOBAL_STRING(lp_motd_file, &Globals.motd_file)
+FN_GLOBAL_STRING(lp_bind_address, &Globals.bind_address)
 FN_GLOBAL_STRING(lp_log_file, &Globals.log_file)
+FN_GLOBAL_STRING(lp_motd_file, &Globals.motd_file)
 FN_GLOBAL_STRING(lp_pid_file, &Globals.pid_file)
 FN_GLOBAL_STRING(lp_socket_options, &Globals.socket_options)
-FN_GLOBAL_INTEGER(lp_syslog_facility, &Globals.syslog_facility)
+
 FN_GLOBAL_INTEGER(lp_rsync_port, &Globals.rsync_port)
-FN_GLOBAL_STRING(lp_bind_address, &Globals.bind_address)
+FN_GLOBAL_INTEGER(lp_syslog_facility, &Globals.syslog_facility)
 
-FN_LOCAL_STRING(lp_name, name)
+FN_LOCAL_STRING(lp_auth_users, auth_users)
 FN_LOCAL_STRING(lp_comment, comment)
-FN_LOCAL_STRING(lp_path, path)
-FN_LOCAL_STRING(lp_lock_file, lock_file)
-FN_LOCAL_BOOL(lp_read_only, read_only)
-FN_LOCAL_BOOL(lp_write_only, write_only)
-FN_LOCAL_BOOL(lp_list, list)
-FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
-FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
-FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
-FN_LOCAL_BOOL(lp_ignore_nonreadable, ignore_nonreadable)
-FN_LOCAL_STRING(lp_uid, uid)
+FN_LOCAL_STRING(lp_dont_compress, dont_compress)
+FN_LOCAL_STRING(lp_exclude, exclude)
+FN_LOCAL_STRING(lp_exclude_from, exclude_from)
+FN_LOCAL_STRING(lp_filter, filter)
 FN_LOCAL_STRING(lp_gid, gid)
 FN_LOCAL_STRING(lp_hosts_allow, hosts_allow)
 FN_LOCAL_STRING(lp_hosts_deny, hosts_deny)
-FN_LOCAL_STRING(lp_auth_users, auth_users)
-FN_LOCAL_STRING(lp_secrets_file, secrets_file)
-FN_LOCAL_BOOL(lp_strict_modes, strict_modes)
-FN_LOCAL_STRING(lp_filter, filter)
-FN_LOCAL_STRING(lp_exclude, exclude)
-FN_LOCAL_STRING(lp_exclude_from, exclude_from)
 FN_LOCAL_STRING(lp_include, include)
 FN_LOCAL_STRING(lp_include_from, include_from)
+FN_LOCAL_STRING(lp_incoming_chmod, incoming_chmod)
+FN_LOCAL_STRING(lp_lock_file, lock_file)
 FN_LOCAL_STRING(lp_log_format, log_format)
+FN_LOCAL_STRING(lp_name, name)
+FN_LOCAL_STRING(lp_outgoing_chmod, outgoing_chmod)
+FN_LOCAL_STRING(lp_path, path)
+FN_LOCAL_STRING(lp_postxfer_exec, postxfer_exec)
+FN_LOCAL_STRING(lp_prexfer_exec, prexfer_exec)
 FN_LOCAL_STRING(lp_refuse_options, refuse_options)
-FN_LOCAL_STRING(lp_dont_compress, dont_compress)
-FN_LOCAL_INTEGER(lp_timeout, timeout)
+FN_LOCAL_STRING(lp_secrets_file, secrets_file)
+FN_LOCAL_STRING(lp_temp_dir, temp_dir)
+FN_LOCAL_STRING(lp_uid, uid)
+
 FN_LOCAL_INTEGER(lp_max_connections, max_connections)
 FN_LOCAL_INTEGER(lp_max_verbosity, max_verbosity)
+FN_LOCAL_INTEGER(lp_timeout, timeout)
+
+FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
+FN_LOCAL_BOOL(lp_ignore_nonreadable, ignore_nonreadable)
+FN_LOCAL_BOOL(lp_list, list)
+FN_LOCAL_BOOL(lp_read_only, read_only)
+FN_LOCAL_BOOL(lp_strict_modes, strict_modes)
+FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
+FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
+FN_LOCAL_BOOL(lp_write_only, write_only)
 
 /* local prototypes */
 static int    strwicmp(char *psz1, char *psz2);
 static int    map_parameter(char *parmname);
 static BOOL   set_boolean(BOOL *pb, char *parmvalue);
 static int    getservicebyname(char *name, service *pserviceDest);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/log.c	2005-06-10 06:27:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/log.c	2006-02-24 09:56:26.000000000 +0800
@@ -23,28 +23,37 @@
   tridge, May 1998
 
   Mapping to human-readable messages added by Martin Pool
   <mbp@samba.org>, Oct 2000.
   */
 #include "rsync.h"
+#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+#include <iconv.h>
+#endif
 
 extern int verbose;
 extern int dry_run;
 extern int am_daemon;
 extern int am_server;
 extern int am_sender;
 extern int local_server;
 extern int quiet;
 extern int module_id;
 extern int msg_fd_out;
+extern int allow_8bit_chars;
 extern int protocol_version;
 extern int preserve_times;
+extern int log_format_has_i;
 extern int log_format_has_o_or_i;
 extern int daemon_log_format_has_o_or_i;
+extern mode_t orig_umask;
 extern char *auth_user;
 extern char *log_format;
+#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+extern iconv_t ic_chck;
+#endif
 
 static int log_initialised;
 static int logfile_was_closed;
 static char *logfname;
 static FILE *logfile;
 struct stats stats;
@@ -62,14 +71,17 @@
 	{ RERR_STARTCLIENT, "error starting client-server protocol" },
 	{ RERR_SOCKETIO   , "error in socket IO" },
 	{ RERR_FILEIO     , "error in file IO" },
 	{ RERR_STREAMIO   , "error in rsync protocol data stream" },
 	{ RERR_MESSAGEIO  , "errors with program diagnostics" },
 	{ RERR_IPC        , "error in IPC code" },
-	{ RERR_SIGNAL     , "received SIGUSR1 or SIGINT" },
-	{ RERR_WAITCHILD  , "some error returned by waitpid()" },
+	{ RERR_CRASHED    , "sibling process crashed" },
+	{ RERR_TERMINATED , "sibling process terminated abnormally" },
+	{ RERR_SIGNAL1    , "received SIGUSR1" },
+	{ RERR_SIGNAL     , "received SIGINT, SIGTERM, or SIGHUP" },
+	{ RERR_WAITCHILD  , "waitpid() failed" },
 	{ RERR_MALLOC     , "error allocating core memory buffers" },
 	{ RERR_PARTIAL    , "some files could not be transferred" },
 	{ RERR_VANISHED   , "some files vanished before they could be transferred" },
 	{ RERR_TIMEOUT    , "timeout in data send/receive" },
 	{ RERR_CMD_FAILED , "remote shell failed" },
 	{ RERR_CMD_KILLED , "remote shell killed" },
@@ -131,14 +141,13 @@
 	logit(LOG_INFO, "rsyncd started\n");
 #endif
 }
 
 static void logfile_open(void)
 {
-	extern int orig_umask;
-	int old_umask = umask(022 | orig_umask);
+	mode_t old_umask = umask(022 | orig_umask);
 	logfile = fopen(logfname, "a");
 	umask(old_umask);
 	if (!logfile) {
 		int fopen_errno = errno;
 		/* Rsync falls back to using syslog on failure. */
 		syslog_init();
@@ -184,33 +193,57 @@
 	if (logfile_was_closed) {
 		logfile_was_closed = 0;
 		logfile_open();
 	}
 }
 
+static void filtered_fwrite(FILE *f, const char *buf, int len, int use_isprint)
+{
+	const char *s, *end = buf + len;
+	for (s = buf; s < end; s++) {
+		if ((s < end - 4
+		  && *s == '\\' && s[1] == '#'
+		  && isdigit(*(uchar*)(s+2))
+		  && isdigit(*(uchar*)(s+3))
+		  && isdigit(*(uchar*)(s+4)))
+		 || (*s != '\t'
+		  && ((use_isprint && !isprint(*(uchar*)s))
+		   || *(uchar*)s < ' '))) {
+			if (s != buf && fwrite(buf, s - buf, 1, f) != 1)
+				exit_cleanup(RERR_MESSAGEIO);
+			fprintf(f, "\\#%03o", *(uchar*)s);
+			buf = s + 1;
+		}
+	}
+	if (buf != end && fwrite(buf, end - buf, 1, f) != 1)
+		exit_cleanup(RERR_MESSAGEIO);
+}
+
 /* this is the underlying (unformatted) rsync debugging function. Call
- * it with FINFO, FERROR or FLOG */
+ * it with FINFO, FERROR or FLOG.  Note: recursion can happen with
+ * certain fatal conditions. */
 void rwrite(enum logcode code, char *buf, int len)
 {
+	int trailing_CR_or_NL;
 	FILE *f = NULL;
-	/* recursion can happen with certain fatal conditions */
-
-	if (quiet && code == FINFO)
-		return;
 
 	if (len < 0)
 		exit_cleanup(RERR_MESSAGEIO);
 
-	buf[len] = 0;
+	if (quiet && code == FINFO)
+		return;
 
 	if (am_server && msg_fd_out >= 0) {
 		/* Pass the message to our sibling. */
 		send_msg((enum msgcode)code, buf, len);
 		return;
 	}
 
+	if (code == FSOCKERR) /* This gets simplified for a non-sibling. */
+		code = FERROR;
+
 	if (code == FCLIENT)
 		code = FINFO;
 	else if (am_daemon) {
 		static int in_block;
 		char msg[2048];
 		int priority = code == FERROR ? LOG_WARNING : LOG_INFO;
@@ -236,48 +269,84 @@
 		if (am_daemon) {
 			/* TODO: can we send the error to the user somehow? */
 			return;
 		}
 	}
 
-	if (code == FERROR) {
+	switch (code) {
+	case FERROR:
 		log_got_error = 1;
 		f = stderr;
-	}
-
-	if (code == FINFO)
+		goto pre_scan;
+	case FINFO:
 		f = am_server ? stderr : stdout;
-
-	if (!f)
+	pre_scan:
+		while (len > 1 && *buf == '\n') {
+			fputc(*buf, f);
+			buf++;
+			len--;
+		}
+		break;
+	case FNAME:
+		f = am_server ? stderr : stdout;
+		break;
+	default:
 		exit_cleanup(RERR_MESSAGEIO);
+	}
 
-	if (fwrite(buf, len, 1, f) != 1)
-		exit_cleanup(RERR_MESSAGEIO);
+	trailing_CR_or_NL = len && (buf[len-1] == '\n' || buf[len-1] == '\r')
+			  ? buf[--len] : 0;
+
+#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+	if (ic_chck != (iconv_t)-1) {
+		char convbuf[1024];
+		char *in_buf = buf, *out_buf = convbuf;
+		size_t in_cnt = len, out_cnt = sizeof convbuf - 1;
+
+		iconv(ic_chck, NULL, 0, NULL, 0);
+		while (iconv(ic_chck, &in_buf,&in_cnt,
+				 &out_buf,&out_cnt) == (size_t)-1) {
+			if (out_buf != convbuf) {
+				filtered_fwrite(f, convbuf, out_buf - convbuf, 0);
+				out_buf = convbuf;
+				out_cnt = sizeof convbuf - 1;
+			}
+			if (errno == E2BIG)
+				continue;
+			fprintf(f, "\\#%03o", *(uchar*)in_buf++);
+			in_cnt--;
+		}
+		if (out_buf != convbuf)
+			filtered_fwrite(f, convbuf, out_buf - convbuf, 0);
+	} else
+#endif
+		filtered_fwrite(f, buf, len, !allow_8bit_chars);
 
-	if (buf[len-1] == '\r' || buf[len-1] == '\n')
+	if (trailing_CR_or_NL) {
+		fputc(trailing_CR_or_NL, f);
 		fflush(f);
+	}
 }
 
-
 /* This is the rsync debugging function. Call it with FINFO, FERROR or
  * FLOG. */
 void rprintf(enum logcode code, const char *format, ...)
 {
 	va_list ap;
-	char buf[MAXPATHLEN+512];
+	char buf[BIGPATHBUFLEN];
 	size_t len;
 
 	va_start(ap, format);
 	len = vsnprintf(buf, sizeof buf, format, ap);
 	va_end(ap);
 
 	/* Deal with buffer overruns.  Instead of panicking, just
 	 * truncate the resulting string.  (Note that configure ensures
 	 * that we have a vsnprintf() that doesn't ever return -1.) */
 	if (len > sizeof buf - 1) {
-		const char ellipsis[] = "[...]";
+		static const char ellipsis[] = "[...]";
 
 		/* Reset length, and zero-terminate the end of our buffer */
 		len = sizeof buf - 1;
 		buf[len] = '\0';
 
 		/* Copy the ellipsis to the end of the string, but give
@@ -287,13 +356,13 @@
 		 *        abcdefghij0
 		 *     -> abcd[...]00  <-- now two null bytes at end
 		 *
 		 * If the input format string has a trailing newline,
 		 * we copy it into that extra null; if it doesn't, well,
 		 * all we lose is one byte.  */
-		strncpy(buf+len-sizeof ellipsis, ellipsis, sizeof ellipsis);
+		memcpy(buf+len-sizeof ellipsis, ellipsis, sizeof ellipsis);
 		if (format[strlen(format)-1] == '\n') {
 			buf[len-1] = '\n';
 		}
 	}
 
 	rwrite(code, buf, len);
@@ -308,13 +376,13 @@
  *
  * Note that since strerror might involve dynamically loading a
  * message catalog we need to call it once before chroot-ing. */
 void rsyserr(enum logcode code, int errcode, const char *format, ...)
 {
 	va_list ap;
-	char buf[MAXPATHLEN+512];
+	char buf[BIGPATHBUFLEN];
 	size_t len;
 
 	strcpy(buf, RSYNC_NAME ": ");
 	len = (sizeof RSYNC_NAME ": ") - 1;
 
 	va_start(ap, format);
@@ -396,72 +460,112 @@
 		if (!*p)
 			break;
 		*n = '\0';
 		n = NULL;
 
 		switch (*p) {
-		case 'h': if (am_daemon) n = client_name(0); break;
-		case 'a': if (am_daemon) n = client_addr(0); break;
+		case 'h':
+			if (am_daemon)
+				n = client_name(0);
+			break;
+		case 'a':
+			if (am_daemon)
+				n = client_addr(0);
+			break;
 		case 'l':
 			strlcat(fmt, ".0f", sizeof fmt);
 			snprintf(buf2, sizeof buf2, fmt,
 				 (double)file->length);
 			n = buf2;
 			break;
+		case 'U':
+			strlcat(fmt, "ld", sizeof fmt);
+			snprintf(buf2, sizeof buf2, fmt,
+				 (long)file->uid);
+			n = buf2;
+			break;
+		case 'G':
+			if (file->gid == GID_NONE)
+				n = "DEFAULT";
+			else {
+				strlcat(fmt, "ld", sizeof fmt);
+				snprintf(buf2, sizeof buf2, fmt,
+					 (long)file->gid);
+				n = buf2;
+			}
+			break;
 		case 'p':
 			strlcat(fmt, "ld", sizeof fmt);
 			snprintf(buf2, sizeof buf2, fmt,
 				 (long)getpid());
 			n = buf2;
 			break;
-		case 'o': n = op; break;
+		case 'M':
+			n = timestring(file->modtime);
+			{
+				char *cp = n;
+				while ((cp = strchr(cp, ' ')) != NULL)
+					*cp = '-';
+			}
+			break;
+		case 'B':
+			n = buf2 + MAXPATHLEN - PERMSTRING_SIZE;
+			permstring(n - 1, file->mode); /* skip the type char */
+			break;
+		case 'o':
+			n = op;
+			break;
 		case 'f':
-			n = safe_fname(f_name(file));
+			n = f_name(file, NULL);
 			if (am_sender && file->dir.root) {
 				pathjoin(buf2, sizeof buf2,
 					 file->dir.root, n);
-				/* The buffer from safe_fname() has more
-				 * room than MAXPATHLEN, so this is safe. */
+				clean_fname(buf2, 0);
 				if (fmt[1])
-					strcpy(n, buf2);
+					strlcpy(n, buf2, MAXPATHLEN);
 				else
 					n = buf2;
-			}
-			clean_fname(n, 0);
+			} else
+				clean_fname(n, 0);
 			if (*n == '/')
 				n++;
 			break;
 		case 'n':
-			n = safe_fname(f_name(file));
-			if (S_ISDIR(file->mode)) {
-				/* The buffer from safe_fname() has more
-				 * room than MAXPATHLEN, so this is safe. */
-				strcat(n, "/");
-			}
+			n = f_name(file, NULL);
+			if (S_ISDIR(file->mode))
+				strlcat(n, "/", MAXPATHLEN);
 			break;
 		case 'L':
 			if (hlink && *hlink) {
-				n = safe_fname(hlink);
+				n = hlink;
 				strcpy(buf2, " => ");
 			} else if (S_ISLNK(file->mode) && file->u.link) {
-				n = safe_fname(file->u.link);
+				n = file->u.link;
 				strcpy(buf2, " -> ");
 			} else {
 				n = "";
 				if (!fmt[1])
 					break;
 				strcpy(buf2, "    ");
 			}
 			strlcat(fmt, "s", sizeof fmt);
 			snprintf(buf2 + 4, sizeof buf2 - 4, fmt, n);
 			n = buf2;
 			break;
-		case 'm': n = lp_name(module_id); break;
-		case 't': n = timestring(time(NULL)); break;
-		case 'P': n = lp_path(module_id); break;
-		case 'u': n = auth_user; break;
+		case 'm':
+			n = lp_name(module_id);
+			break;
+		case 't':
+			n = timestring(time(NULL));
+			break;
+		case 'P':
+			n = lp_path(module_id);
+			break;
+		case 'u':
+			n = auth_user;
+			break;
 		case 'b':
 			if (am_sender) {
 				b = stats.total_written -
 					initial_stats->total_written;
 			} else {
 				b = stats.total_read -
@@ -491,31 +595,32 @@
 			n = buf2 + MAXPATHLEN - 32;
 			n[0] = iflags & ITEM_LOCAL_CHANGE
 			      ? iflags & ITEM_XNAME_FOLLOWS ? 'h' : 'c'
 			     : !(iflags & ITEM_TRANSFER) ? '.'
 			     : !local_server && *op == 's' ? '<' : '>';
 			n[1] = S_ISDIR(file->mode) ? 'd'
+			     : IS_SPECIAL(file->mode) ? 'S'
 			     : IS_DEVICE(file->mode) ? 'D'
 			     : S_ISLNK(file->mode) ? 'L' : 'f';
 			n[2] = !(iflags & ITEM_REPORT_CHECKSUM) ? '.' : 'c';
 			n[3] = !(iflags & ITEM_REPORT_SIZE) ? '.' : 's';
 			n[4] = !(iflags & ITEM_REPORT_TIME) ? '.'
-			     : !preserve_times || IS_DEVICE(file->mode)
-					       || S_ISLNK(file->mode) ? 'T' : 't';
+			     : !preserve_times || S_ISLNK(file->mode) ? 'T' : 't';
 			n[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
 			n[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
 			n[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
-			n[8] = !(iflags & ITEM_REPORT_XATTRS) ? '.' : 'a';
+			n[8] = '.';
 			n[9] = '\0';
 
 			if (iflags & (ITEM_IS_NEW|ITEM_MISSING_DATA)) {
 				char ch = iflags & ITEM_IS_NEW ? '+' : '?';
 				int i;
 				for (i = 2; n[i]; i++)
 					n[i] = ch;
-			} else if (n[0] == '.' || n[0] == 'h') {
+			} else if (n[0] == '.' || n[0] == 'h'
+			        || (n[0] == 'c' && n[1] == 'f')) {
 				int i;
 				for (i = 2; n[i]; i++) {
 					if (n[i] != '.')
 						break;
 				}
 				if (!n[i]) {
@@ -591,24 +696,24 @@
 	char *s_or_r = am_sender ? "send" : "recv";
 
 	if (lp_transfer_logging(module_id)) {
 		log_formatted(FLOG, lp_log_format(module_id), s_or_r,
 			      file, initial_stats, iflags, hlink);
 	} else if (log_format && !am_server) {
-		log_formatted(FINFO, log_format, s_or_r,
+		log_formatted(FNAME, log_format, s_or_r,
 			      file, initial_stats, iflags, hlink);
 	}
 }
 
 void maybe_log_item(struct file_struct *file, int iflags, int itemizing,
 		    char *buf)
 {
 	int significant_flags = iflags & SIGNIFICANT_ITEM_FLAGS;
-	int see_item = itemizing && (significant_flags || *buf || verbose > 1);
-	int local_change = iflags & ITEM_LOCAL_CHANGE
-	    && (!(iflags & ITEM_XNAME_FOLLOWS) || significant_flags);
+	int see_item = itemizing && (significant_flags || *buf
+		|| log_format_has_i > 1 || (verbose > 1 && log_format_has_i));
+	int local_change = iflags & ITEM_LOCAL_CHANGE && significant_flags;
 	if (am_server) {
 		if (am_daemon && !dry_run && see_item)
 			log_item(file, &stats, iflags, buf);
 	} else if (see_item || local_change || *buf
 	    || (S_ISDIR(file->mode) && significant_flags))
 		log_item(file, &stats, iflags, buf);
@@ -662,14 +766,14 @@
 		name = rerr_name(code);
 		if (!name)
 			name = "unexplained error";
 
 		/* VANISHED is not an error, only a warning */
 		if (code == RERR_VANISHED) {
-			rprintf(FINFO, "rsync warning: %s (code %d) at %s(%d)\n", 
-				name, code, file, line);
+			rprintf(FINFO, "rsync warning: %s (code %d) at %s(%d) [%s]\n", 
+				name, code, file, line, who_am_i());
 		} else {
-			rprintf(FERROR, "rsync error: %s (code %d) at %s(%d)\n",
-				name, code, file, line);
+			rprintf(FERROR, "rsync error: %s (code %d) at %s(%d) [%s]\n",
+				name, code, file, line, who_am_i());
 		}
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/main.c	2005-05-12 15:43:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/main.c	2006-03-02 11:53:42.000000000 +0800
@@ -37,87 +37,112 @@
 extern int daemon_over_rsh;
 extern int need_messages_from_generator;
 extern int kluge_around_eof;
 extern int do_stats;
 extern int log_got_error;
 extern int module_id;
-extern int orig_umask;
 extern int copy_links;
+extern int copy_dirlinks;
 extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int protocol_version;
 extern int recurse;
-extern int fuzzy_basis;
 extern int relative_paths;
 extern int rsync_port;
-extern int inplace;
-extern int make_backups;
 extern int whole_file;
 extern int read_batch;
 extern int write_batch;
 extern int batch_fd;
 extern int batch_gen_fd;
 extern int filesfrom_fd;
 extern pid_t cleanup_child_pid;
 extern struct stats stats;
 extern char *filesfrom_host;
-extern char *partial_dir;
-extern char *basis_dir[];
 extern char *rsync_path;
 extern char *shell_cmd;
 extern char *batch_name;
 
 int local_server = 0;
+mode_t orig_umask = 0;
 struct file_list *the_file_list;
 
 /* There's probably never more than at most 2 outstanding child processes,
  * but set it higher, just in case. */
-#define MAXCHILDPROCS 5
+#define MAXCHILDPROCS 7
+
+#ifdef HAVE_SIGACTION
+# ifdef HAVE_SIGPROCMASK
+#  define SIGACTMASK(n,h) SIGACTION(n,h), sigaddset(&sigmask,(n))
+# else
+#  define SIGACTMASK(n,h) SIGACTION(n,h)
+# endif
+static struct sigaction sigact;
+#endif
 
 struct pid_status {
 	pid_t pid;
-	int   status;
+	int status;
 } pid_stat_table[MAXCHILDPROCS];
 
 static time_t starttime, endtime;
 static int64 total_read, total_written;
 
 static void show_malloc_stats(void);
 
-/****************************************************************************
-wait for a process to exit, calling io_flush while waiting
-****************************************************************************/
-void wait_process(pid_t pid, int *status)
+/* Works like waitpid(), but if we already harvested the child pid in our
+ * remember_children(), we succeed instead of returning an error. */
+pid_t wait_process(pid_t pid, int *status_ptr, int flags)
 {
-	pid_t waited_pid;
-	int cnt;
-
-	while ((waited_pid = waitpid(pid, status, WNOHANG)) == 0) {
-		msleep(20);
-		io_flush(FULL_FLUSH);
-	}
+	pid_t waited_pid = waitpid(pid, status_ptr, flags);
 
 	if (waited_pid == -1 && errno == ECHILD) {
-		/* status of requested child no longer available.
-		 * check to see if it was processed by the sigchld_handler.
-		 */
-		for (cnt = 0;  cnt < MAXCHILDPROCS; cnt++) {
+		/* Status of requested child no longer available:  check to
+		 * see if it was processed by remember_children(). */
+		int cnt;
+		for (cnt = 0; cnt < MAXCHILDPROCS; cnt++) {
 			if (pid == pid_stat_table[cnt].pid) {
-				*status = pid_stat_table[cnt].status;
+				*status_ptr = pid_stat_table[cnt].status;
 				pid_stat_table[cnt].pid = 0;
-				break;
+				return pid;
 			}
 		}
 	}
 
+	return waited_pid;
+}
+
+/* Wait for a process to exit, calling io_flush while waiting. */
+static void wait_process_with_flush(pid_t pid, int *exit_code_ptr)
+{
+	pid_t waited_pid;
+	int status;
+
+	while ((waited_pid = wait_process(pid, &status, WNOHANG)) == 0) {
+		msleep(20);
+		io_flush(FULL_FLUSH);
+	}
+
 	/* TODO: If the child exited on a signal, then log an
 	 * appropriate error message.  Perhaps we should also accept a
 	 * message describing the purpose of the child.  Also indicate
-	 * this to the caller so that thhey know something went
-	 * wrong.  */
-	*status = WEXITSTATUS(*status);
+	 * this to the caller so that they know something went wrong. */
+	if (waited_pid < 0) {
+		rsyserr(FERROR, errno, "waitpid");
+		*exit_code_ptr = RERR_WAITCHILD;
+	} else if (!WIFEXITED(status)) {
+#ifdef WCOREDUMP
+		if (WCOREDUMP(status))
+			*exit_code_ptr = RERR_CRASHED;
+		else
+#endif
+		if (WIFSIGNALED(status))
+			*exit_code_ptr = RERR_TERMINATED;
+		else
+			*exit_code_ptr = RERR_WAITCHILD;
+	} else
+		*exit_code_ptr = WEXITSTATUS(status);
 }
 
 /* This function gets called from all 3 processes.  We want the client side
  * to actually output the text, but the sender is the only process that has
  * all the stats we need.  So, if we're a client sender, we do the report.
  * If we're a server sender, we write the stats on the supplied fd.  If
@@ -191,42 +216,42 @@
 static void output_summary(void)
 {
 	if (do_stats) {
 		rprintf(FINFO,"\nNumber of files: %d\n", stats.num_files);
 		rprintf(FINFO,"Number of files transferred: %d\n",
 			stats.num_transferred_files);
-		rprintf(FINFO,"Total file size: %.0f bytes\n",
-			(double)stats.total_size);
-		rprintf(FINFO,"Total transferred file size: %.0f bytes\n",
-			(double)stats.total_transferred_size);
-		rprintf(FINFO,"Literal data: %.0f bytes\n",
-			(double)stats.literal_data);
-		rprintf(FINFO,"Matched data: %.0f bytes\n",
-			(double)stats.matched_data);
+		rprintf(FINFO,"Total file size: %s bytes\n",
+			human_num(stats.total_size));
+		rprintf(FINFO,"Total transferred file size: %s bytes\n",
+			human_num(stats.total_transferred_size));
+		rprintf(FINFO,"Literal data: %s bytes\n",
+			human_num(stats.literal_data));
+		rprintf(FINFO,"Matched data: %s bytes\n",
+			human_num(stats.matched_data));
 		rprintf(FINFO,"File list size: %d\n", stats.flist_size);
 		if (stats.flist_buildtime) {
 			rprintf(FINFO,
 				"File list generation time: %.3f seconds\n",
 				(double)stats.flist_buildtime / 1000);
 			rprintf(FINFO,
 				"File list transfer time: %.3f seconds\n",
 				(double)stats.flist_xfertime / 1000);
 		}
-		rprintf(FINFO,"Total bytes sent: %.0f\n",
-			(double)total_written);
-		rprintf(FINFO,"Total bytes received: %.0f\n",
-			(double)total_read);
+		rprintf(FINFO,"Total bytes sent: %s\n",
+			human_num(total_written));
+		rprintf(FINFO,"Total bytes received: %s\n",
+			human_num(total_read));
 	}
 
 	if (verbose || do_stats) {
 		rprintf(FINFO,
-			"\nsent %.0f bytes  received %.0f bytes  %.2f bytes/sec\n",
-			(double)total_written, (double)total_read,
-			(total_written + total_read)/(0.5 + (endtime - starttime)));
-		rprintf(FINFO, "total size is %.0f  speedup is %.2f\n",
-			(double)stats.total_size,
+			"\nsent %s bytes  received %s bytes  %s bytes/sec\n",
+			human_num(total_written), human_num(total_read),
+			human_dnum((total_written + total_read)/(0.5 + (endtime - starttime)), 2));
+		rprintf(FINFO, "total size is %s  speedup is %.2f\n",
+			human_num(stats.total_size),
 			(double)stats.total_size / (total_written+total_read));
 	}
 
 	fflush(stdout);
 	fflush(stderr);
 }
@@ -275,32 +300,59 @@
 static pid_t do_cmd(char *cmd, char *machine, char *user, char *path,
 		    int *f_in, int *f_out)
 {
 	int i, argc = 0;
 	char *args[MAX_ARGS];
 	pid_t ret;
-	char *tok, *dir = NULL;
+	char *dir = NULL;
 	int dash_l_set = 0;
 
 	if (!read_batch && !local_server) {
+		char *t, *f, in_quote = '\0';
 		char *rsh_env = getenv(RSYNC_RSH_ENV);
 		if (!cmd)
 			cmd = rsh_env;
 		if (!cmd)
 			cmd = RSYNC_RSH;
 		cmd = strdup(cmd);
 		if (!cmd)
 			goto oom;
 
-		for (tok = strtok(cmd, " "); tok; tok = strtok(NULL, " ")) {
+		for (t = f = cmd; *f; f++) {
+			if (*f == ' ')
+				continue;
 			/* Comparison leaves rooms for server_options(). */
 			if (argc >= MAX_ARGS - MAX_SERVER_ARGS) {
 				rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
-			args[argc++] = tok;
+			args[argc++] = t;
+			while (*f != ' ' || in_quote) {
+				if (!*f) {
+					if (in_quote) {
+						rprintf(FERROR,
+						    "Missing trailing-%c in remote-shell command.\n",
+						    in_quote);
+						exit_cleanup(RERR_SYNTAX);
+					}
+					f--;
+					break;
+				}
+				if (*f == '\'' || *f == '"') {
+					if (!in_quote) {
+						in_quote = *f++;
+						continue;
+					}
+					if (*f == in_quote && *++f != in_quote) {
+						in_quote = '\0';
+						continue;
+					}
+				}
+				*t++ = *f++;
+			}
+			*t++ = '\0';
 		}
 
 		/* check to see if we've already been given '-l user' in
 		 * the remote-shell command */
 		for (i = 0; i < argc-1; i++) {
 			if (!strcmp(args[i], "-l") && args[i+1][0] != '-')
@@ -347,16 +399,15 @@
 	if (!daemon_over_rsh && path && *path)
 		args[argc++] = path;
 
 	args[argc] = NULL;
 
 	if (verbose > 3) {
-		rprintf(FINFO,"cmd=");
 		for (i = 0; i < argc; i++)
-			rprintf(FINFO, "%s ", safe_fname(args[i]));
-		rprintf(FINFO,"\n");
+			rprintf(FINFO, "cmd[%d]=%s ", i, args[i]);
+		rprintf(FINFO, "\n");
 	}
 
 	if (read_batch) {
 		int from_gen_pipe[2];
 		if (fd_pair(from_gen_pipe) < 0) {
 			rsyserr(FERROR, errno, "pipe");
@@ -377,68 +428,128 @@
 
 	if (dir)
 		free(dir);
 
 	return ret;
 
-oom:
+  oom:
 	out_of_memory("do_cmd");
 	return 0; /* not reached */
 }
 
-
-static char *get_local_name(struct file_list *flist,char *name)
+/* The receiving side operates in one of two modes:
+ *
+ * 1. it receives any number of files into a destination directory,
+ * placing them according to their names in the file-list.
+ *
+ * 2. it receives a single file and saves it using the name in the
+ * destination path instead of its file-list name.  This requires a
+ * "local name" for writing out the destination file.
+ *
+ * So, our task is to figure out what mode/local-name we need and return
+ * either a NULL for mode 1, or the local-name for mode 2.  We also
+ * change directory if there are any path components in dest_path. */
+static char *get_local_name(struct file_list *flist, char *dest_path)
 {
 	STRUCT_STAT st;
-	int e;
+	char *cp;
 
-	if (verbose > 2)
-		rprintf(FINFO,"get_local_name count=%d %s\n",
-			flist->count, NS(name));
+	if (verbose > 2) {
+		rprintf(FINFO, "get_local_name count=%d %s\n",
+			flist->count, NS(dest_path));
+	}
 
-	if (!name)
+	if (!dest_path || list_only)
 		return NULL;
 
-	if (do_stat(name,&st) == 0) {
+	/* If the destination path refers to an existing directory, enter
+	 * it and use mode 1.  If there is something other than a directory
+	 * at the destination path, we must be transferring one file
+	 * (anything at the destination will be overwritten). */
+	if (do_stat(dest_path, &st) == 0) {
 		if (S_ISDIR(st.st_mode)) {
-			if (!push_dir(name)) {
+			if (!push_dir(dest_path)) {
 				rsyserr(FERROR, errno, "push_dir#1 %s failed",
-					full_fname(name));
+					full_fname(dest_path));
 				exit_cleanup(RERR_FILESELECT);
 			}
 			return NULL;
 		}
 		if (flist->count > 1) {
-			rprintf(FERROR,"ERROR: destination must be a directory when copying more than 1 file\n");
+			rprintf(FERROR,
+				"ERROR: destination must be a directory when"
+				" copying more than 1 file\n");
 			exit_cleanup(RERR_FILESELECT);
 		}
-		return name;
+		/* Caution: flist->count could be 0! */
+		if (flist->count == 1 && S_ISDIR(flist->files[0]->mode)) {
+			rprintf(FERROR,
+				"ERROR: cannot overwrite non-directory"
+				" with a directory\n");
+			exit_cleanup(RERR_FILESELECT);
+		}
+	} else if (errno != ENOENT) {
+		rsyserr(FERROR, errno, "cannot stat destination %s",
+			full_fname(dest_path));
+		exit_cleanup(RERR_FILESELECT);
 	}
 
-	if (flist->count <= 1 && ((e = strlen(name)) <= 1 || name[e-1] != '/'))
-		return name;
+	cp = strrchr(dest_path, '/');
 
-	if (do_mkdir(name,0777 & ~orig_umask) != 0) {
-		rsyserr(FERROR, errno, "mkdir %s failed", full_fname(name));
-		exit_cleanup(RERR_FILEIO);
-	}
-	if (verbose > 0)
-		rprintf(FINFO, "created directory %s\n", safe_fname(name));
+	/* If the destination path ends in a slash or we are transferring
+	 * multiple files, create a directory at the destination path,
+	 * enter the new directory, and use mode 1. */
+	if (flist->count > 1 || (cp && !cp[1])) {
+		/* Lop off the final slash (if any). */
+		if (cp && !cp[1])
+			*cp = '\0';
+
+		if (mkdir_defmode(dest_path) != 0) {
+			rsyserr(FERROR, errno, "mkdir %s failed",
+				full_fname(dest_path));
+			exit_cleanup(RERR_FILEIO);
+		}
+
+		if (verbose)
+			rprintf(FINFO, "created directory %s\n", dest_path);
+
+		if (dry_run) {
+			/* Indicate that the destination directory doesn't
+			 * really exist and return mode 1. */
+			dry_run++;
+			return NULL;
+		}
+
+		if (!push_dir(dest_path)) {
+			rsyserr(FERROR, errno, "push_dir#2 %s failed",
+				full_fname(dest_path));
+			exit_cleanup(RERR_FILESELECT);
+		}
 
-	if (dry_run) {
-		dry_run++;
 		return NULL;
 	}
 
-	if (!push_dir(name)) {
-		rsyserr(FERROR, errno, "push_dir#2 %s failed",
-			full_fname(name));
+	/* Otherwise, we are writing a single file, possibly on top of an
+	 * existing non-directory.  Change to the item's parent directory
+	 * (if it has a path component), return the basename of the
+	 * destination file as the local name, and use mode 2. */
+	if (!cp)
+		return dest_path;
+
+	if (cp == dest_path)
+		dest_path = "/";
+
+	*cp = '\0';
+	if (!push_dir(dest_path)) {
+		rsyserr(FERROR, errno, "push_dir#3 %s failed",
+			full_fname(dest_path));
 		exit_cleanup(RERR_FILESELECT);
 	}
+	*cp = '/';
 
-	return NULL;
+	return cp + 1;
 }
 
 
 /* This is only called by the sender. */
 static void read_final_goodbye(int f_in, int f_out)
 {
@@ -460,15 +571,14 @@
 			i, who_am_i());
 		exit_cleanup(RERR_PROTOCOL);
 	}
 }
 
 
-static void do_server_sender(int f_in, int f_out, int argc,char *argv[])
+static void do_server_sender(int f_in, int f_out, int argc, char *argv[])
 {
-	int i;
 	struct file_list *flist;
 	char *dir = argv[0];
 
 	if (verbose > 2) {
 		rprintf(FINFO, "server_sender starting pid=%ld\n",
 			(long)getpid());
@@ -491,20 +601,12 @@
 			full_fname(dir));
 		exit_cleanup(RERR_FILESELECT);
 	}
 	argc--;
 	argv++;
 
-	if (strcmp(dir,".")) {
-		int l = strlen(dir);
-		if (strcmp(dir,"/") == 0)
-			l = 0;
-		for (i = 0; i < argc; i++)
-			argv[i] += l+1;
-	}
-
 	if (argc == 0 && (recurse || list_only)) {
 		argc = 1;
 		argv--;
 		argv[0] = ".";
 	}
 
@@ -527,18 +629,18 @@
 }
 
 
 static int do_recv(int f_in,int f_out,struct file_list *flist,char *local_name)
 {
 	int pid;
-	int status = 0;
+	int exit_code = 0;
 	int error_pipe[2];
 
 	/* The receiving side mustn't obey this, or an existing symlink that
 	 * points to an identical file won't be replaced by the referent. */
-	copy_links = 0;
+	copy_links = copy_dirlinks = 0;
 
 	if (preserve_hard_links)
 		init_hard_links();
 
 	if (fd_pair(error_pipe) < 0) {
 		rsyserr(FERROR, errno, "pipe failed in do_recv");
@@ -613,20 +715,20 @@
 		write_int(f_out, -1);
 	}
 	io_flush(FULL_FLUSH);
 
 	set_msg_fd_in(-1);
 	kill(pid, SIGUSR2);
-	wait_process(pid, &status);
-	return status;
+	wait_process_with_flush(pid, &exit_code);
+	return exit_code;
 }
 
 
 static void do_server_recv(int f_in, int f_out, int argc,char *argv[])
 {
-	int status;
+	int exit_code;
 	struct file_list *flist;
 	char *local_name = NULL;
 	char *dir = NULL;
 	int save_verbose = verbose;
 
 	if (filesfrom_fd >= 0) {
@@ -676,23 +777,17 @@
 	if (!flist) {
 		rprintf(FERROR,"server_recv: recv_file_list error\n");
 		exit_cleanup(RERR_FILESELECT);
 	}
 	the_file_list = flist;
 
-	if (argc > 0) {
-		if (strcmp(dir,".")) {
-			argv[0] += strlen(dir);
-			if (argv[0][0] == '/')
-				argv[0]++;
-		}
+	if (argc > 0)
 		local_name = get_local_name(flist,argv[0]);
-	}
 
-	status = do_recv(f_in,f_out,flist,local_name);
-	exit_cleanup(status);
+	exit_code = do_recv(f_in,f_out,flist,local_name);
+	exit_cleanup(exit_code);
 }
 
 
 int child_main(int argc, char *argv[])
 {
 	start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
@@ -704,12 +799,15 @@
 {
 	set_nonblocking(f_in);
 	set_nonblocking(f_out);
 
 	io_set_sock_fds(f_in, f_out);
 	setup_protocol(f_out, f_in);
+#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+	setup_iconv();
+#endif
 
 	if (protocol_version >= 23)
 		io_start_multiplex_out();
 
 	if (am_sender) {
 		keep_dirlinks = 0; /* Must be disabled on the sender. */
@@ -729,23 +827,26 @@
  * This is called once the connection has been negotiated.  It is used
  * for rsyncd, remote-shell, and local connections.
  */
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[])
 {
 	struct file_list *flist = NULL;
-	int status = 0, status2 = 0;
+	int exit_code = 0, exit_code2 = 0;
 	char *local_name = NULL;
 
 	cleanup_child_pid = pid;
 	if (!read_batch) {
 		set_nonblocking(f_in);
 		set_nonblocking(f_out);
 	}
 
 	io_set_sock_fds(f_in, f_out);
 	setup_protocol(f_out,f_in);
+#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+	setup_iconv();
+#endif
 
 	if (protocol_version >= 23 && !read_batch)
 		io_start_multiplex_in();
 
 	/* We set our stderr file handle to blocking because ssh might have
 	 * set it to non-blocking.  This can be particularly troublesome if
@@ -781,17 +882,17 @@
 		if (protocol_version >= 24)
 			read_final_goodbye(f_in, f_out);
 		if (pid != -1) {
 			if (verbose > 3)
 				rprintf(FINFO,"client_run waiting on %d\n", (int) pid);
 			io_flush(FULL_FLUSH);
-			wait_process(pid, &status);
+			wait_process_with_flush(pid, &exit_code);
 		}
 		output_summary();
 		io_flush(FULL_FLUSH);
-		exit_cleanup(status);
+		exit_cleanup(exit_code);
 	}
 
 	if (need_messages_from_generator && !read_batch)
 		io_start_multiplex_out();
 
 	if (argc == 0)
@@ -809,26 +910,26 @@
 	flist = recv_file_list(f_in);
 	the_file_list = flist;
 
 	if (flist && flist->count > 0) {
 		local_name = get_local_name(flist, argv[0]);
 
-		status2 = do_recv(f_in, f_out, flist, local_name);
+		exit_code2 = do_recv(f_in, f_out, flist, local_name);
 	} else {
 		handle_stats(-1);
 		output_summary();
 	}
 
 	if (pid != -1) {
 		if (verbose > 3)
 			rprintf(FINFO,"client_run2 waiting on %d\n", (int) pid);
 		io_flush(FULL_FLUSH);
-		wait_process(pid, &status);
+		wait_process_with_flush(pid, &exit_code);
 	}
 
-	return MAX(status, status2);
+	return MAX(exit_code, exit_code2);
 }
 
 static int copy_argv (char *argv[])
 {
 	int i;
 
@@ -866,15 +967,22 @@
 	/* Don't clobber argv[] so that ps(1) can still show the right
 	 * command line. */
 	if ((rc = copy_argv(argv)))
 		return rc;
 
 	if (!read_batch) { /* for read_batch, NO source is specified */
-		argc--;
 		shell_path = check_for_hostspec(argv[0], &shell_machine, &rsync_port);
 		if (shell_path) { /* source is remote */
+			char *dummy1;
+			int dummy2;
+			if (--argc
+			 && check_for_hostspec(argv[argc], &dummy1, &dummy2)) {
+				rprintf(FERROR,
+					"The source and destination cannot both be remote.\n");
+				exit_cleanup(RERR_SYNTAX);
+			}
 			argv++;
 			if (filesfrom_host && *filesfrom_host
 			    && strcmp(filesfrom_host, shell_machine) != 0) {
 				rprintf(FERROR,
 					"--files-from hostname is not the same as the transfer hostname\n");
 				exit_cleanup(RERR_SYNTAX);
@@ -889,18 +997,20 @@
 			}
 
 			am_sender = 0;
 		} else { /* source is local, check dest arg */
 			am_sender = 1;
 
-			if (argc < 1) { /* destination required */
-				usage(FERROR);
-				exit_cleanup(RERR_SYNTAX);
+			if (argc > 1)
+				p = argv[--argc];
+			else {
+				p = ".";
+				list_only = 1;
 			}
 
-			shell_path = check_for_hostspec(argv[argc], &shell_machine, &rsync_port);
+			shell_path = check_for_hostspec(p, &shell_machine, &rsync_port);
 			if (shell_path && filesfrom_host && *filesfrom_host
 			    && strcmp(filesfrom_host, shell_machine) != 0) {
 				rprintf(FERROR,
 					"--files-from hostname is not the same as the transfer hostname\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
@@ -909,13 +1019,13 @@
 				if (filesfrom_host) {
 					rprintf(FERROR,
 						"--files-from cannot be remote when the transfer is local\n");
 					exit_cleanup(RERR_SYNTAX);
 				}
 				shell_machine = NULL;
-				shell_path = argv[argc];
+				shell_path = p;
 			} else if (rsync_port) {
 				if (!shell_cmd) {
 					return start_socket_client(shell_machine,
 								   shell_path,
 								   argc, argv);
 				}
@@ -939,16 +1049,16 @@
 			shell_machine = p+1;
 		}
 	}
 
 	if (verbose > 3) {
 		rprintf(FINFO,"cmd=%s machine=%s user=%s path=%s\n",
-			shell_cmd ? safe_fname(shell_cmd) : "",
-			shell_machine ? safe_fname(shell_machine) : "",
-			shell_user ? safe_fname(shell_user) : "",
-			shell_path ? safe_fname(shell_path) : "");
+			shell_cmd ? shell_cmd : "",
+			shell_machine ? shell_machine : "",
+			shell_user ? shell_user : "",
+			shell_path ? shell_path : "");
 	}
 
 	/* for remote source, only single dest arg can remain ... */
 	if (!am_sender && argc > 1) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
@@ -979,47 +1089,49 @@
 	return ret;
 }
 
 
 static RETSIGTYPE sigusr1_handler(UNUSED(int val))
 {
-	exit_cleanup(RERR_SIGNAL);
+	exit_cleanup(RERR_SIGNAL1);
 }
 
 static RETSIGTYPE sigusr2_handler(UNUSED(int val))
 {
 	if (!am_server)
 		output_summary();
 	close_all();
 	if (log_got_error)
 		_exit(RERR_PARTIAL);
 	_exit(0);
 }
 
-static RETSIGTYPE sigchld_handler(UNUSED(int val))
+RETSIGTYPE remember_children(UNUSED(int val))
 {
 #ifdef WNOHANG
 	int cnt, status;
 	pid_t pid;
 	/* An empty waitpid() loop was put here by Tridge and we could never
 	 * get him to explain why he put it in, so rather than taking it
 	 * out we're instead saving the child exit statuses for later use.
 	 * The waitpid() loop presumably eliminates all possibility of leaving
-	 * zombie children, maybe that's why he did it.
-	 */
+	 * zombie children, maybe that's why he did it. */
 	while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
 		/* save the child's exit status */
 		for (cnt = 0; cnt < MAXCHILDPROCS; cnt++) {
 			if (pid_stat_table[cnt].pid == 0) {
 				pid_stat_table[cnt].pid = pid;
 				pid_stat_table[cnt].status = status;
 				break;
 			}
 		}
 	}
 #endif
+#ifndef HAVE_SIGACTION
+	signal(SIGCHLD, remember_children);
+#endif
 }
 
 
 /**
  * This routine catches signals and tries to send them to gdb.
  *
@@ -1073,22 +1185,29 @@
 
 int main(int argc,char *argv[])
 {
 	int ret;
 	int orig_argc = argc;
 	char **orig_argv = argv;
-
-	signal(SIGUSR1, sigusr1_handler);
-	signal(SIGUSR2, sigusr2_handler);
-	signal(SIGCHLD, sigchld_handler);
+#ifdef HAVE_SIGACTION
+# ifdef HAVE_SIGPROCMASK
+	sigset_t sigmask;
+
+	sigemptyset(&sigmask);
+# endif
+	sigact.sa_flags = SA_NOCLDSTOP;
+#endif
+	SIGACTMASK(SIGUSR1, sigusr1_handler);
+	SIGACTMASK(SIGUSR2, sigusr2_handler);
+	SIGACTMASK(SIGCHLD, remember_children);
 #ifdef MAINTAINER_MODE
-	signal(SIGSEGV, rsync_panic_handler);
-	signal(SIGFPE, rsync_panic_handler);
-	signal(SIGABRT, rsync_panic_handler);
-	signal(SIGBUS, rsync_panic_handler);
-#endif /* def MAINTAINER_MODE */
+	SIGACTMASK(SIGSEGV, rsync_panic_handler);
+	SIGACTMASK(SIGFPE, rsync_panic_handler);
+	SIGACTMASK(SIGABRT, rsync_panic_handler);
+	SIGACTMASK(SIGBUS, rsync_panic_handler);
+#endif
 
 	starttime = time(NULL);
 	am_root = (MY_UID() == 0);
 
 	memset(&stats, 0, sizeof(stats));
 
@@ -1096,31 +1215,37 @@
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	/* we set a 0 umask so that correct file permissions can be
 	 * carried across */
-	orig_umask = (int)umask(0);
+	orig_umask = umask(0);
+
+#if defined CONFIG_LOCALE && defined HAVE_SETLOCALE
+	setlocale(LC_CTYPE, "");
+#endif
 
 	if (!parse_arguments(&argc, (const char ***) &argv, 1)) {
 		/* FIXME: We ought to call the same error-handling
 		 * code here, rather than relying on getopt. */
 		option_error();
 		exit_cleanup(RERR_SYNTAX);
 	}
 
-	signal(SIGINT,SIGNAL_CAST sig_int);
-	signal(SIGHUP,SIGNAL_CAST sig_int);
-	signal(SIGTERM,SIGNAL_CAST sig_int);
+	SIGACTMASK(SIGINT, sig_int);
+	SIGACTMASK(SIGHUP, sig_int);
+	SIGACTMASK(SIGTERM, sig_int);
+#if defined HAVE_SIGACTION && HAVE_SIGPROCMASK
+	sigprocmask(SIG_UNBLOCK, &sigmask, NULL);
+#endif
 
 	/* Ignore SIGPIPE; we consistently check error codes and will
 	 * see the EPIPE. */
-	signal(SIGPIPE, SIG_IGN);
-
-#if defined CONFIG_LOCALE && defined HAVE_SETLOCALE
-	setlocale(LC_CTYPE, "");
+	SIGACTION(SIGPIPE, SIG_IGN);
+#ifdef SIGXFSZ
+	SIGACTION(SIGXFSZ, SIG_IGN);
 #endif
 
 	/* Initialize push_dir here because on some old systems getcwd
 	 * (implemented by forking "pwd" and reading its output) doesn't
 	 * work when there are other child processes.  Also, on all systems
 	 * that implement getcwd that way "pwd" can't be found after chroot. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/Makefile.in	2005-07-08 05:29:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/Makefile.in	2006-02-06 12:54:30.000000000 +0800
@@ -30,13 +30,13 @@
 	lib/permstring.o lib/pool_alloc.o @LIBOBJS@
 ZLIBOBJ=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
 	zlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o
 OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
 	main.o checksum.o match.o syscall.o log.o backup.o
 OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
-	fileio.o batch.o clientname.o
+	fileio.o batch.o clientname.o chmod.o
 OBJS3=progress.o pipe.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 	popt/popthelp.o popt/poptparse.o
 OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
 
@@ -87,35 +87,20 @@
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
 
 T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o t_stub.o lib/compat.o lib/snprintf.o
 t_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(T_UNSAFE_OBJ) $(LIBS)
 
-gen: $(srcdir)/configure $(srcdir)/config.h.in proto man
+gen:
+	$(MAKE) -C $(srcdir) -f prepare-source.mak gen
 
-man: $(srcdir)/rsync.1 $(srcdir)/rsyncd.conf.5
-
-$(srcdir)/configure: $(srcdir)/configure.in $(srcdir)/aclocal.m4
-	cd $(srcdir); autoconf
-
-$(srcdir)/config.h.in: $(srcdir)/configure.in $(srcdir)/aclocal.m4
-	cd $(srcdir); autoheader
-
-$(srcdir)/rsync.1: $(srcdir)/rsync.yo
-	yodl2man -o $(srcdir)/rsync.1 $(srcdir)/rsync.yo
-
-$(srcdir)/rsyncd.conf.5: $(srcdir)/rsyncd.conf.yo
-	yodl2man -o $(srcdir)/rsyncd.conf.5 $(srcdir)/rsyncd.conf.yo
+man:
+	$(MAKE) -C $(srcdir) -f prepare-source.mak man
 
 proto:
-	cat $(srcdir)/*.c $(srcdir)/lib/compat.c | awk -f $(srcdir)/mkproto.awk >$(srcdir)/proto.h.new
-	if diff $(srcdir)/proto.h $(srcdir)/proto.h.new >/dev/null; then \
-	  rm $(srcdir)/proto.h.new; \
-	else \
-	  mv $(srcdir)/proto.h.new $(srcdir)/proto.h; \
-	fi
+	$(MAKE) -C $(srcdir) -f prepare-source.mak proto.h
 
 clean: cleantests
 	rm -f *~ $(OBJS) $(TLS_OBJ) $(CHECK_PROGS) $(CHECK_OBJS)
 
 cleantests:
 	rm -rf ./testtmp*
@@ -157,14 +142,14 @@
 # might lose in the future where POSIX diverges from old sh.
 
 check: all $(CHECK_PROGS)
 	POSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin=`pwd`/rsync$(EXEEXT) srcdir="$(srcdir)" $(srcdir)/runtests.sh
 
 wildtest.o: wildtest.c lib/wildmatch.c rsync.h
-wildtest$(EXEEXT): wildtest.o
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ wildtest.o @BUILD_POPT@ $(LIBS)
+wildtest$(EXEEXT): wildtest.o lib/compat.o
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ wildtest.o lib/compat.o @BUILD_POPT@ $(LIBS)
 
 # This does *not* depend on building or installing: you can use it to
 # check a version installed from a binary or some other source tree,
 # if you want.
 
 installcheck: $(CHECK_PROGS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/match.c	2005-03-06 01:51:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/match.c	2006-03-01 05:48:15.000000000 +0800
@@ -17,75 +17,53 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int am_server;
 extern int do_progress;
 extern int checksum_seed;
+extern int append_mode;
 
 int updating_basis_file;
 
-typedef unsigned short tag;
-
-#define TABLESIZE (1<<16)
-#define NULL_TAG (-1)
-
 static int false_alarms;
-static int tag_hits;
+static int hash_hits;
 static int matches;
 static int64 data_transfer;
 
 static int total_false_alarms;
-static int total_tag_hits;
+static int total_hash_hits;
 static int total_matches;
 
 extern struct stats stats;
 
-struct target {
-	tag t;
-	int32 i;
-};
-
-static struct target *targets;
-
-static int32 *tag_table;
+#define TABLESIZE (1<<16)
 
-#define gettag2(s1,s2) (((s1) + (s2)) & 0xFFFF)
-#define gettag(sum) gettag2((sum)&0xFFFF,(sum)>>16)
-
-static int compare_targets(struct target *t1,struct target *t2)
-{
-	return (int)t1->t - (int)t2->t;
-}
+static int32 *hash_table;
 
+#define SUM2HASH2(s1,s2) (((s1) + (s2)) & 0xFFFF)
+#define SUM2HASH(sum) SUM2HASH2((sum)&0xFFFF,(sum)>>16)
 
 static void build_hash_table(struct sum_struct *s)
 {
 	int32 i;
 
-	if (!tag_table)
-		tag_table = new_array(int32, TABLESIZE);
+	if (!hash_table) {
+		hash_table = new_array(int32, TABLESIZE);
+		if (!hash_table)
+			out_of_memory("build_hash_table");
+	}
 
-	targets = new_array(struct target, s->count);
-	if (!tag_table || !targets)
-		out_of_memory("build_hash_table");
+	memset(hash_table, 0xFF, TABLESIZE * sizeof hash_table[0]);
 
 	for (i = 0; i < s->count; i++) {
-		targets[i].i = i;
-		targets[i].t = gettag(s->sums[i].sum1);
+		uint32 t = SUM2HASH(s->sums[i].sum1);
+		s->sums[i].chain = hash_table[t];
+		hash_table[t] = i;
 	}
-
-	qsort(targets,s->count,sizeof(targets[0]),(int (*)())compare_targets);
-
-	for (i = 0; i < TABLESIZE; i++)
-		tag_table[i] = NULL_TAG;
-
-	for (i = s->count; i-- > 0; )
-		tag_table[targets[i].t] = i;
 }
 
 
 static OFF_T last_match;
 
 
@@ -174,26 +151,28 @@
 	if (verbose > 3) {
 		rprintf(FINFO, "hash search s->blength=%ld len=%.0f count=%.0f\n",
 			(long)s->blength, (double)len, (double)s->count);
 	}
 
 	do {
-		tag t = gettag2(s1,s2);
 		int done_csum2 = 0;
-		int32 j = tag_table[t];
-
-		if (verbose > 4)
-			rprintf(FINFO,"offset=%.0f sum=%08x\n",(double)offset,sum);
+		int32 i;
 
-		if (j == NULL_TAG)
-			goto null_tag;
+		if (verbose > 4) {
+			rprintf(FINFO, "offset=%.0f sum=%04x%04x\n",
+				(double)offset, s2 & 0xFFFF, s1 & 0xFFFF);
+		}
+
+		i = hash_table[SUM2HASH2(s1,s2)];
+		if (i < 0)
+			goto null_hash;
 
 		sum = (s1 & 0xffff) | (s2 << 16);
-		tag_hits++;
+		hash_hits++;
 		do {
-			int32 l, i = targets[j].i;
+			int32 l;
 
 			if (sum != s->sums[i].sum1)
 				continue;
 
 			/* also make sure the two blocks are the same length */
 			l = (int32)MIN((OFF_T)s->blength, len-offset);
@@ -203,15 +182,17 @@
 			/* in-place: ensure chunk's offset is either >= our
 			 * offset or that the data didn't move. */
 			if (updating_basis_file && s->sums[i].offset < offset
 			    && !(s->sums[i].flags & SUMFLG_SAME_OFFSET))
 				continue;
 
-			if (verbose > 3)
-				rprintf(FINFO,"potential match at %.0f target=%.0f %.0f sum=%08x\n",
-					(double)offset,(double)j,(double)i,sum);
+			if (verbose > 3) {
+				rprintf(FINFO,
+					"potential match at %.0f i=%ld sum=%08x\n",
+					(double)offset, (long)i, sum);
+			}
 
 			if (!done_csum2) {
 				map = (schar *)map_ptr(buf,offset,l);
 				get_checksum2((char *)map,l,sum2);
 				done_csum2 = 1;
 			}
@@ -222,14 +203,14 @@
 			}
 
 			/* When updating in-place, the best possible match is
 			 * one with an identical offset, so we prefer that over
 			 * the following want_i optimization. */
 			if (updating_basis_file) {
-				do {
-					int32 i2 = targets[j].i;
+				int32 i2;
+				for (i2 = i; i2 >= 0; i2 = s->sums[i2].chain) {
 					if (s->sums[i2].offset != offset)
 						continue;
 					if (i2 != i) {
 						if (sum != s->sums[i2].sum1)
 							break;
 						if (memcmp(sum2, s->sums[i2].sum2,
@@ -238,13 +219,13 @@
 						i = i2;
 					}
 					/* This chunk was at the same offset on
 					 * both the sender and the receiver. */
 					s->sums[i].flags |= SUMFLG_SAME_OFFSET;
 					goto set_want_i;
-				} while (++j < s->count && targets[j].t == t);
+				}
 			}
 
 			/* we've found a match, but now check to see
 			 * if want_i can hint at a better match. */
 			if (i != want_i && want_i < s->count
 			    && (!updating_basis_file || s->sums[want_i].offset >= offset
@@ -264,15 +245,15 @@
 			map = (schar *)map_ptr(buf, offset, k);
 			sum = get_checksum1((char *)map, k);
 			s1 = sum & 0xFFFF;
 			s2 = sum >> 16;
 			matches++;
 			break;
-		} while (++j < s->count && targets[j].t == t);
+		} while ((i = s->sums[i].chain) >= 0);
 
-	null_tag:
+	  null_hash:
 		backup = offset - last_match;
 		/* We sometimes read 1 byte prior to last_match... */
 		if (backup < 0)
 			backup = 0;
 
 		/* Trim off the first byte from the checksum */
@@ -321,18 +302,37 @@
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len)
 {
 	char file_sum[MD4_SUM_LENGTH];
 
 	last_match = 0;
 	false_alarms = 0;
-	tag_hits = 0;
+	hash_hits = 0;
 	matches = 0;
 	data_transfer = 0;
 
 	sum_init(checksum_seed);
 
+	if (append_mode) {
+		OFF_T j = 0;
+		for (j = CHUNK_SIZE; j < s->flength; j += CHUNK_SIZE) {
+			if (buf && do_progress)
+				show_progress(last_match, buf->file_size);
+			sum_update(map_ptr(buf, last_match, CHUNK_SIZE),
+				   CHUNK_SIZE);
+			last_match = j;
+		}
+		if (last_match < s->flength) {
+			int32 len = s->flength - last_match;
+			if (buf && do_progress)
+				show_progress(last_match, buf->file_size);
+			sum_update(map_ptr(buf, last_match, len), len);
+			last_match = s->flength;
+		}
+		s->count = 0;
+	}
+
 	if (len > 0 && s->count > 0) {
 		build_hash_table(s);
 
 		if (verbose > 2)
 			rprintf(FINFO,"built hash table\n");
 
@@ -340,13 +340,13 @@
 
 		if (verbose > 2)
 			rprintf(FINFO,"done hash search\n");
 	} else {
 		OFF_T j;
 		/* by doing this in pieces we avoid too many seeks */
-		for (j = CHUNK_SIZE; j < len; j += CHUNK_SIZE)
+		for (j = last_match + CHUNK_SIZE; j < len; j += CHUNK_SIZE)
 			matched(f, s, buf, j, -2);
 		matched(f, s, buf, len, -1);
 	}
 
 	sum_end(file_sum);
 	/* If we had a read error, send a bad checksum. */
@@ -354,32 +354,26 @@
 		file_sum[0]++;
 
 	if (verbose > 2)
 		rprintf(FINFO,"sending file_sum\n");
 	write_buf(f,file_sum,MD4_SUM_LENGTH);
 
-	if (targets) {
-		free(targets);
-		targets=NULL;
-	}
-
 	if (verbose > 2)
-		rprintf(FINFO, "false_alarms=%d tag_hits=%d matches=%d\n",
-			false_alarms, tag_hits, matches);
+		rprintf(FINFO, "false_alarms=%d hash_hits=%d matches=%d\n",
+			false_alarms, hash_hits, matches);
 
-	total_tag_hits += tag_hits;
+	total_hash_hits += hash_hits;
 	total_false_alarms += false_alarms;
 	total_matches += matches;
 	stats.literal_data += data_transfer;
 }
 
 void match_report(void)
 {
 	if (verbose <= 1)
 		return;
 
 	rprintf(FINFO,
-		"total: matches=%d  tag_hits=%d  false_alarms=%d data=%.0f\n",
-		total_matches,total_tag_hits,
-		total_false_alarms,
+		"total: matches=%d  hash_hits=%d  false_alarms=%d data=%.0f\n",
+		total_matches, total_hash_hits, total_false_alarms,
 		(double)stats.literal_data);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/mkproto.awk /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/mkproto.awk
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/mkproto.awk	2005-02-19 04:16:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/mkproto.awk	2006-02-02 10:29:30.000000000 +0800
@@ -55,13 +55,13 @@
 }
 
 /^static|^extern/ || !/^[a-zA-Z]/ || /[;]/ {
   next;
 }
 
-!/^OFF_T|^size_t|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^uchar|^short|^struct|^BOOL|^void|^time|^const/ {
+!/^OFF_T|^size_t|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^uchar|^short|^struct|^BOOL|^void|^time|^const|^RETSIGTYPE/ {
   next;
 }
 
 
 /[(].*[)][ \t]*$/ {
     printf "%s;\n",$0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/NEWS	2005-07-29 03:31:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/NEWS	2006-03-12 02:25:04.000000000 +0800
@@ -1,65 +1,320 @@
-NEWS for rsync 2.6.6 (28 Jul 2005)
+NEWS for rsync 2.6.7 (11 Mar 2006)
+
 Protocol: 29 (unchanged)
-Changes since 2.6.5:
+Changes since 2.6.6:
 
-  SECURITY FIXES:
+  OUTPUT CHANGES:
 
-    - The zlib code was upgraded to version 1.2.3 in order to make it more
-      secure.  While the widely-publicized security problem in zlib 1.2.2 did
-      not affect rsync, another security problem surfaced that affects rsync's
-      zlib 1.1.4.
+    - The letter 'D' in the itemized output was being used for both devices
+      (character or block) as well as other special files (such as fifos and
+      named sockets).  This has changed to separate non-device special files
+      under the 'S' designation (e.g. "cS+++++++ path/fifo").  See also the
+      "--specials" option, below.
+
+    - The way rsync escapes unreadable characters has changed.  First, rsync
+      now has support for recognizing valid multibyte character sequences in
+      your current locale, allowing it to escape fewer characters than before
+      for a locale such as UTF-8.  Second, it now uses an escape idiom of
+      "\#123", which is the literal string "\#" followed by exactly 3 octal
+      digits.  Rsync no longer doubles a backslash character in a filename
+      (e.g. it used to output "foo\\bar" when copying "foo\bar") -- now it only
+      escapes a backslash that is followed by a hash-sign and 3 digits (0-9)
+      (e.g. it will output "foo\#134#789" when copying "foo\#789").  See also
+      the --8-bit-output (-8) option, mentioned below.
+
+      Script writers: the local rsync is the one that outputs escaped names,
+      so if you need to support unescaping of filenames for older rsyncs, I'd
+      suggest that you parse the output of "rsync --version" and only use the
+      old unescaping rules for 2.6.5 and 2.6.6.
 
   BUG FIXES:
 
-    - The setting of flist->high in clean_flist() was wrong for an empty list.
-      This could cause flist_find() to crash in certain rare circumstances
-      (e.g. if just the right directory setup was around when --fuzzy was
-      combined with --link-dest).
-
-    - The outputting of hard-linked files when verbosity was > 1 was not right:
-      without -i it would output the name of each hard-linked file as though
-      it had been changed (it now outputs a "is hard linked" message for the
-      file); with -i it would output all dots for the unchanged attributes of
-      a hard-link (it now changes those dots to spaces, as is done for other
-      totally unchanged items).
-
-    - When backing up a changed symlink or device, get rid of any old backup
-      item so that we don't get an "already exists" error.
-
-    - A couple places that were comparing a local and a remote modification-
-      time were not honoring the --modify-window option.
-
-    - Fixed a bug where the 'p' (permissions) itemized-changes flag might get
-      set too often (if some non-significant mode bits differed).
-
-    - Fixed a really old, minor bug that could cause rsync to warn about being
-      unable to mkdir() a path that ends in "/." because it just created the
-      directory (required --relative, --no-implied-dirs, a source path that
-      ended in either a trailing slash or a trailing "/.", and a non-existing
-      destination dir to tickle the bug in a recent version).
+    - Fixed a really old bug that caused --checksum (-c) to checksum all the
+      files encountered during the delete scan (ouch).
+
+    - Fixed a potential hang in a remote generator:  when the receiver gets a
+      read-error on the socket, it now signals the generator about this so that
+      the generator does not try to send any of the terminating error messages
+      to the client (avoiding a potential hang in some setups).
+
+    - Made hard-links work with symlinks and devices again.
+
+    - If the sender gets an early EOF reading a source file, we propagate this
+      error to the receiver so that it can discard the file and try requesting
+      it again (which is the existing behavior for other kinds of read errors).
+
+    - If a device-file/special-file changes permissions, rsync now updates the
+      permissions without recreating the file.
+
+    - If the user specifies a remote-host for both the source and destination,
+      we now output a syntax error rather than trying to open the destination
+      hostspec as a filename.
+
+    - When --inplace creates a new destination file, rsync now creates it with
+      permissions 0600 instead of 0000 -- this makes restarting possible when
+      the transfer gets interrupted in the middle of sending a new file.
+
+    - Reject the combination of --inplace and --sparse since the sparse-output
+      algorithm doesn't work when overwriting existing data.
+
+    - Fixed the directory name in the error that is output when pop_dir()
+      fails.
+
+    - Really fixed the parsing of a "!" entry in .cvsignore files this time.
+
+    - If the generator gets a stat() error on a file, output it (this used to
+      require at least -vv for the error to be seen).
+
+    - If waitpid() fails or the child rsync didn't exit cleanly, we now handle
+      the exit status properly and generate a better error.
+
+    - Fixed some glitches in the double-verbose output when using --copy-dest,
+      --link-dest, or --compare-dest.  Also improved how the verbose output
+      handles hard-links (within the transfer) that had an up-to-date alternate
+      "dest" file, and copied files (via --copy-dest).
+
+    - Fixed the matching of the dont-compress items (e.g. *.gz) against files
+      that have a path component containing a slash.
+
+    - If code reading a filter/exclude file an EINTR error, rsync now clears
+      the error flag on the file handle so it can keep on reading.
+
+    - If --relative is active, the sending side cleans up trailing "/" or "/."
+      suffixes to avoid triggering a bug in older rsync versions.  Also, we now
+      reject a ".." dir if it would be sent as a relative dir.
+
+    - If a non-directory is in the way of a directory and rsync is run with
+      --dry-run and --delete, rsync no longer complains about not being able
+      to opendir() the not-yet present directory.
+
+    - When --list-only is used and a non-existent local destination dir was
+      also specified as a destination, rsync no longer generates a warning
+      about being unable to create the missing directory.
+
+    - Fixed some problems with --relative --no-implied-dirs when the
+      destination directory did not yet exist:  we can now create a symlink or
+      device when it is the first thing in the missing dir, and --fuzzy no
+      longer complains about being unable to open the missing dir.
+
+    - Fixed a bug where the --copy-links option would not affect implied
+      directories without --copy-unsafe-links (see --relative).
+
+    - Got rid of the need for --force to be used in some circumstances with
+      --delete-after (making it consistent with --delete-before/-during).
+
+    - Rsync now ignores the SIGXFSZ signal, just in case your OS sends this
+      when a file is too large (rsync handles the write error).
+
+    - Fixed a bug in the Proxy-Authorization header's base64-encoded value: it
+      was not properly padded with trailing '=' chars.  This only affects a
+      user that need to use a password-authenticated proxy for an outgoing
+      daemon-rsync connection.
+
+    - If we're transferring an empty directory to a new name, rsync no longer
+      forces S_IWUSR if it wasn't already set, nor does it accidentally leave
+      it set.
+
+    - Fixed a bug in the debug output (-vvvvv) that could mention the wrong
+      checksum for the current file offset.
+
+    - Rsync no longer allows a single directory to be copied over a non-
+      directory destination arg.
 
   ENHANCEMENTS:
 
-    - Made the "max verbosity" setting in the rsyncd.conf file settable on a
-      per-module basis (which now matches the documentation).
+    - Added the --append option that makes rsync append data onto files that
+      are longer on the source than the destination (this includes new files).
+
+    - Added the --min-size=SIZE option to exclude small files from the
+      transfer.
+
+    - Added the --compress-level option to allow you to set how aggressive
+      rsync's compression should be (this option implies --compress).
+
+    - Enhanced the parsing of the SIZE value for --min-size and --max-size to
+      allow easy entry of multiples of 1000 (instead of just multiples of 1024)
+      and off-by-one values too (e.g. --max-size=8mb-1).
+
+    - Added the --8-bit-output (-8) option, which tells rsync to avoid escaping
+      high-bit characters that it thinks are unreadable in the current locale.
+
+    - The new option --human-readable (-h) changes the output of --progress,
+      --stats, and the end-of-run summary to be easier to read.  If repeated,
+      the units become powers of 1024 instead of powers of 1000.  (The old
+      meaning of -h, as a shorthand for --help, still works as long as you
+      just use it on its own, as in "rsync -h".)
+
+    - If lutimes() and/or lchmod() are around, use them to allow the
+      preservation of attributes on symlinks.
+
+    - The --link-dest option now affects symlinks and devices (when possible).
+
+    - Added two config items to the rsyncd.conf parsing:  "pre-xfer exec" and
+      "post-xfer exec".  These allow a command to be specified on a per-module
+      basis that will be run before and/or after a daemon-mode transfer.  (See
+      the man page for a list of the environment variables that are set with
+      information about the transfer.)
+
+    - When using the --relative option, you can now insert a dot dir in
+      the source path to indicate where the replication of the source dirs
+      should start.  For example, if you specify a source path of
+      rsync://host/module/foo/bar/./baz/dir with -R, rsync will now only
+      replicate the "baz/dir" part of the source path (note: a trailing
+      dot dir is unaffected unless it also has a trailing slash).
+
+    - Added some new --no-FOO options that make it easier to override unwanted
+      implied or default options.  For example, "-a --no-o" (aka "--archive
+      --no-owner") can be used to turn off the preservation of file ownership
+      that is implied by -a.
+
+    - Added the --chmod=MODE option that allows the destination permissions to
+      be changed from the source permissions.  E.g. --chmod=g+w,o-rwx
+
+    - Added the "incoming chmod" and "outgoing chmod" daemon options that allow
+      a module to specify what permissions changes should be applied to all
+      files copied to and from the daemon.
+
+    - Allow the --temp-dir option to be specified when starting a daemon, which
+      sets the default temporary directory for incoming files.
+
+    - If --delete is combined with --dirs without --recursive, rsync will now
+      delete in any directory whose content is being synchronized.
+
+    - If --backup is combined with --delete without --backup-dir (and without
+      --delete-excluded), we add a "protect" filter-rule to ensure that files
+      with the backup suffix are not deleted.
+
+    - The file-count stats that are output by --progress were improved to
+      better indicate what the numbers mean.  For instance, the output:
+      "(xfer#5, to-check=8383/9999)" indicates that this was the fifth file
+      to be transferred, and we still need to check 8383 more files out of
+      a total of 9999.
+
+    - The include/exclude code now allows a dir/*** directive (with 3 trailing
+      stars) to match both the dir itself as well as all the content below the
+      dir (dir/** would not match the dir).
+
+    - Added the --prune-empty-dirs (-m) option that makes the receiving rsync
+      discard empty chains of directories from the file-list.  This makes it
+      easier to selectively copy files from a source hierarchy and end up with
+      just the directories needed to hold the resulting files.
+
+    - If the --itemize-changes (-i) option is repeated, rsync now includes
+      unchanged files in the itemized output (similar to -vv, but without all
+      the other verbose messages that can get in the way).  Of course, the
+      client must be version 2.6.7 for this to work, but the remote rsync only
+      needs to be 2.6.7 if you're pushing files.
+
+    - Added the --specials option to tell rsync to copy non-device special
+      files (which rsync now attempts even as a normal user).  The --devices
+      option now requests the copying of just devices (character and block).
+      The -D option still requests both (e.g. --devices and --specials), -a
+      still implies -D, and non-root users still get a silent downgrade that
+      omits device copying.
+
+    - Added the --super option to make the receiver always attempt super-user
+      activities.  This is useful for systems that allow things such as devices
+      to be created or ownership to be set without being UID 0, and is also
+      useful for someone who wants to ensure that errors will be output if the
+      receiving rsync isn't being run as root.
+
+    - Added the --sockopts option for those few who want to customize the TCP
+      options used to contact a daemon rsync.
+
+    - Added a way for the --temp-dir option to be combined with a partial-dir
+      setting that lets rsync avoid non-atomic updates (for those times when
+      --temp-dir is not being used because space is tight).
+
+    - A new support script, files-to-excludes, will transform a list of files
+      into a set of include/exclude directives that will copy those files.
+
+    - A new option, --executability (-E) can be used to preserve just the
+      execute bit on files, for those times when using the --perms option is
+      not desired.
+
+    - The daemon now logs each connection and also each module-list request
+      that it receives.
+
+    - New log-format options: %M (modtime), %U (uid), %G (gid), and %B
+      (permission bits, e.g. "rwxr-xrwt").
+
+    - The --dry-run option no longer forces the enabling of --verbose.
+
+    - The --remove-sent-files option now does a better job of incrementally
+      removing the sent files on the sending side (older versions tended to
+      clump up all the removals at the end).
+
+    - A daemon now supersedes its minimal SIGCHLD handler with the standard
+      PID-remembering version after forking.  This ensures that the generator
+      can get the child-exit status from the receiver.
+
+    - Use of the --bwlimit option no longer interferes with the remote rsync
+      sending error messages about invalid/refused options.
+
+    - Rsync no longer returns a usage error when used with one local source arg
+      and no destination: this now implies the --list-only option, just like
+      the comparable situation with a remote source arg.
+
+    - Added the --copy-dirlinks option, a more limited version of --copy-links.
+
+    - Various documentation improvements, including: a better synopsis, some
+      improved examples, a better discussion of the presence and absence of
+      --perms (including how it interacts with the new --executability and
+      --chmod options), an extended discussion of --temp-dir, an improved
+      discussion of --partial-dir, a better description of rsync's pattern
+      matching characters, an improved --no-implied-dirs section, and the
+      documenting of what the --stats option outputs.
+
+    - Various new and updated diffs in the patches dir, including: acls.diff,
+      xattrs.diff, atimes.diff, detect-renamed.diff, and slp.diff.
+
+  INTERNAL:
+
+    - We now use sigaction() and sigprocmask() if possible, and fall back on
+      signal() if not.  Using sigprocmask() ensures that rsync enables all the
+      signals that it needs, just in case it was started in a masked state.
+
+    - Some buffer sizes were expanded a bit, particularly on systems where
+      MAXPATHLEN is overly small (e.g. cygwin).
+
+    - If io_printf() tries to format more data than fits in the buffer, exit
+      with an error instead of transmitting a truncated buffer.
+
+    - If a va_copy macro is defined, lib/snprintf.c will use it when defining
+      the VA_COPY macro.
+
+    - Reduced the amount of stack memory needed for each level of directory
+      recursion by nearly MAXPATHLEN bytes.
+
+    - The wildmatch function was extended to allow an array of strings to be
+      supplied as the string to match.  This allows the exclude code to do less
+      string copying.
+
+    - Got rid of the safe_fname() function (and all the myriad calls) and
+      replaced it with a new function in the log.c code that filters all the
+      output going to the terminal.
 
-    - The support/rrsync script has been upgraded to verify the args of options
-      that take args (instead of rejecting any such options).  The script was
-      also changed to try to be more secure and to fix a problem in the parsing
-      of a pull operation that has multiple sources.
+    - Unified the f_name() and the f_name_to() functions.
 
-    - Improved the documentation that explains the difference between a
-      normal daemon transfer and a daemon-over remote-shell transfer.
+    - Improved the hash-table code the sender uses to handle checksums to make
+      it use slightly less memory and run just a little faster.
 
-    - Some of the diffs supplied in the patches dir were fixed and/or
-      improved.
+  DEVELOPER RELATED:
 
-  BUILD CHANGES:
+    - The diffs in the patches dir now require "patch -p1 <DIFF" instead of
+      the previous -p0.  Also, the version included in the release tar now
+      affect generated files (e.g. configure, rsync.1, proto.h, etc.), so
+      it is no longer necessary to run autoconf and/or yodl unless you're
+      applying a patch that was checked out from CVS.
 
-    - Made configure define NOBODY_USER (currently hard-wired to "nobody") and
-      NOBODY_GROUP (set to either "nobody" or "nogroup" depending on what we
-      find in the /etc/group file).
+    - Several diffs in the patches dir now use the proper --enable-FOO
+      configure option instead of --with-FOO to turn on the inclusion of
+      the newly patched feature.
 
-    - Added a test to the test suite, itemized.test, that tests the output of
-      -i (log-format w/%i) and some double-verbose messages.
+    - There is a new script, "prepare-source" than can be used to update the
+      various generated files (proto.h, configure, etc.) even before configure
+      has created the Makefile (this is mainly useful when patching the source
+      with a patch that doesn't affect generated files).
 
+    - The testsuite now sets HOME so that it won't be affected by a file such
+      as ~/.popt.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/OLDNEWS	2005-07-29 03:31:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/OLDNEWS	2006-03-12 02:25:04.000000000 +0800
@@ -1,6 +1,72 @@
+NEWS for rsync 2.6.6 (28 Jul 2005)
+Protocol: 29 (unchanged)
+Changes since 2.6.5:
+
+  SECURITY FIXES:
+
+    - The zlib code was upgraded to version 1.2.3 in order to make it more
+      secure.  While the widely-publicized security problem in zlib 1.2.2 did
+      not affect rsync, another security problem surfaced that affects rsync's
+      zlib 1.1.4.
+
+  BUG FIXES:
+
+    - The setting of flist->high in clean_flist() was wrong for an empty list.
+      This could cause flist_find() to crash in certain rare circumstances
+      (e.g. if just the right directory setup was around when --fuzzy was
+      combined with --link-dest).
+
+    - The outputting of hard-linked files when verbosity was > 1 was not right:
+      (1) Without -i it would output the name of each hard-linked file as
+      though it had been changed; it now outputs a "is hard linked" message for
+      the file. (2) With -i it would output all dots for the unchanged
+      attributes of a hard-link; it now changes those dots to spaces, as is
+      done for other totally unchanged items.
+
+    - When backing up a changed symlink or device, get rid of any old backup
+      item so that we don't get an "already exists" error.
+
+    - A couple places that were comparing a local and a remote modification-
+      time were not honoring the --modify-window option.
+
+    - Fixed a bug where the 'p' (permissions) itemized-changes flag might get
+      set too often (if some non-significant mode bits differed).
+
+    - Fixed a really old, minor bug that could cause rsync to warn about being
+      unable to mkdir() a path that ends in "/." because it just created the
+      directory (required --relative, --no-implied-dirs, a source path that
+      ended in either a trailing slash or a trailing "/.", and a non-existing
+      destination dir to tickle the bug in a recent version).
+
+  ENHANCEMENTS:
+
+    - Made the "max verbosity" setting in the rsyncd.conf file settable on a
+      per-module basis (which now matches the documentation).
+
+    - The support/rrsync script has been upgraded to verify the args of options
+      that take args (instead of rejecting any such options).  The script was
+      also changed to try to be more secure and to fix a problem in the parsing
+      of a pull operation that has multiple sources.
+
+    - Improved the documentation that explains the difference between a
+      normal daemon transfer and a daemon-over remote-shell transfer.
+
+    - Some of the diffs supplied in the patches dir were fixed and/or
+      improved.
+
+  BUILD CHANGES:
+
+    - Made configure define NOBODY_USER (currently hard-wired to "nobody") and
+      NOBODY_GROUP (set to either "nobody" or "nogroup" depending on what we
+      find in the /etc/group file).
+
+    - Added a test to the test suite, itemized.test, that tests the output of
+      -i (log-format w/%i) and some double-verbose messages.
+
+
 NEWS for rsync 2.6.5 (1 Jun 2005)
 Protocol: 29 (unchanged)
 Changes since 2.6.4:
 
   OUTPUT CHANGES:
 
@@ -225,13 +291,13 @@
 
     - Avoid a mkdir warning when removing a directory in the destination
       that already exists in the --backup-dir.
 
     - An OS that has a binary mode for its files (such as cygwin) needed
       setmode(fd, O_BINARY) called on the temp-file we opened with
-      mkstemp().  (Fix derived from the cygwin's 2.6.3 rsync package.)
+      mkstemp().  (Fix derived from cygwin's 2.6.3 rsync package.)
 
     - Fixed a potential hang when verbosity is high, the client side is
       the sender, and the file-list is large.
 
     - Fixed a potential protocol-corrupting bug where the generator could
       merge a message from the receiver into the middle of a multiplexed
@@ -290,15 +356,17 @@
       specified) and exit with a new error code (6).
 
     - A local transfer no longer duplicates all its include/exclude options
       (since the forked process already has a copy of the exclude list,
       there's no need to send them a set of duplicates).
 
-    - When --progress is specified, the output of items that the generator
-      is creating (e.g. dirs, symlinks) is now integrated into the progress
-      output without overlapping it.  (Requires protocol 29.)
+    - The output of the items that are being updated by the generator (dirs,
+      symlinks, devices) is now intermingled in the proper order with the
+      output from the items that the receiver is updating (regular files)
+      when pulling.  This misordering was particularly bad when --progress
+      was specified.  (Requires protocol 29.)
 
     - When --timeout is specified, lulls that occur in the transfer while
       the generator is doing work that does not generate socket traffic
       (looking for changed files, deleting files, doing directory-time
       touch-ups, etc.) will cause a new keep-alive packet to be sent that
       should keep the transfer going as long as the generator continues to
@@ -912,13 +980,13 @@
       the expanded PATH/NAME value of the current item to get
       overwritten (due to an expanded-name caching bug).
       
     - We now reset the "new data has been sent" flag at the start of
       each file we send.  This makes sure that an interrupted transfer
       with the --partial option set doesn't keep a shorter temp file
-      than the current basis file when no new data has been transfered
+      than the current basis file when no new data has been transferred
       over the wire for that file.
 
     - Fixed a byte-order problem in --batch-mode on big-endian machines.
       (Jay Fenlason)
 
     - When using --cvs-exclude, the exclude items we get from a
@@ -1616,12 +1684,14 @@
     * The existing test.sh script by Phil Hands has been merged into a
       test framework that works from both "make check" and the Samba
       build farm.
 
 Partial Protocol History
 	RELEASE DATE	VER.	DATE OF COMMIT*	PROTOCOL
+	11 Mar 2006	2.6.7			29
+	28 Jul 2005	2.6.6			29
 	01 Jun 2005	2.6.5			29
 	30 Mar 2005	2.6.4	17 Jan 2005	29
 	30 Sep 2004	2.6.3			28
 	30 Apr 2004	2.6.2			28
 	26 Apr 2004	2.6.1	08 Jan 2004	28
 	01 Jan 2004	2.6.0	10 Apr 2003	27 (MAX=40)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/options.c	2005-05-19 16:52:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/options.c	2006-02-28 07:35:18.000000000 +0800
@@ -16,13 +16,14 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "rsync.h"
-#include "popt.h"
+#include <popt.h>
+#include "zlib/zlib.h"
 
 extern int module_id;
 extern int sanitize_paths;
 extern struct filter_list_struct filter_list;
 extern struct filter_list_struct server_filter_list;
 
@@ -35,73 +36,82 @@
  * If -1, then look at whether we're local or remote and go by that.
  *
  * @sa disable_deltas_p()
  **/
 int whole_file = -1;
 
-int archive_mode = 0;
+int append_mode = 0;
 int keep_dirlinks = 0;
+int copy_dirlinks = 0;
 int copy_links = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
 int preserve_perms = 0;
+int preserve_executability = 0;
 int preserve_devices = 0;
+int preserve_specials = 0;
 int preserve_uid = 0;
 int preserve_gid = 0;
 int preserve_times = 0;
 int omit_dir_times = 0;
 int update_only = 0;
 int cvs_exclude = 0;
 int dry_run = 0;
 int do_xfers = 1;
 int ignore_times = 0;
+int saw_delete_opt = 0;
+int saw_delete_excluded_opt = 0;
 int delete_mode = 0;
 int delete_during = 0;
 int delete_before = 0;
 int delete_after = 0;
 int delete_excluded = 0;
 int remove_sent_files = 0;
 int one_file_system = 0;
 int protocol_version = PROTOCOL_VERSION;
 int sparse_files = 0;
 int do_compression = 0;
+int def_compress_level = Z_DEFAULT_COMPRESSION;
 int am_root = 0;
 int am_server = 0;
 int am_sender = 0;
 int am_generator = 0;
 int am_starting_up = 1;
-int orig_umask = 0;
 int relative_paths = -1;
 int implied_dirs = 1;
 int numeric_ids = 0;
+int allow_8bit_chars = 0;
 int force_delete = 0;
 int io_timeout = 0;
 int allowed_lull = 0;
+int prune_empty_dirs = 0;
 char *files_from = NULL;
 int filesfrom_fd = -1;
 char *filesfrom_host = NULL;
 int eol_nulls = 0;
+int human_readable = 0;
 int recurse = 0;
-int xfer_dirs = 0;
+int xfer_dirs = -1;
 int am_daemon = 0;
 int daemon_over_rsh = 0;
 int do_stats = 0;
 int do_progress = 0;
 int keep_partial = 0;
 int safe_symlinks = 0;
 int copy_unsafe_links = 0;
 int size_only = 0;
 int daemon_bwlimit = 0;
 int bwlimit = 0;
 int fuzzy_basis = 0;
 size_t bwlimit_writemax = 0;
-int only_existing = 0;
-int opt_ignore_existing = 0;
+int ignore_existing = 0;
+int ignore_non_existing = 0;
 int need_messages_from_generator = 0;
 int max_delete = 0;
 OFF_T max_size = 0;
+OFF_T min_size = 0;
 int ignore_errors = 0;
 int modify_window = 0;
 int blocking_io = -1;
 int checksum_seed = 0;
 int inplace = 0;
 int delay_updates = 0;
@@ -139,12 +149,13 @@
 char *shell_cmd = NULL;
 char *log_format = NULL;
 char *password_file = NULL;
 char *rsync_path = RSYNC_PATH;
 char *backup_dir = NULL;
 char backup_dir_buf[MAXPATHLEN];
+char *sockopts = NULL;
 int rsync_port = 0;
 int compare_dest = 0;
 int copy_dest = 0;
 int link_dest = 0;
 int basis_dir_cnt = 0;
 char *dest_option = NULL;
@@ -157,20 +168,23 @@
 int always_checksum = 0;
 int list_only = 0;
 
 #define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
 char *batch_name = NULL;
 
+struct chmod_mode_struct *chmod_modes = NULL;
+
 static int daemon_opt;   /* sets am_daemon after option error-reporting */
 static int F_option_cnt = 0;
 static int modify_window_set;
 static int itemize_changes = 0;
-static int refused_delete, refused_archive_part;
+static int refused_delete, refused_archive_part, refused_compress;
 static int refused_partial, refused_progress, refused_delete_before;
-static char *max_size_arg;
-static char partialdir_for_delayupdate[] = ".~tmp~";
+static int refused_inplace;
+static char *max_size_arg, *min_size_arg;
+static char tmp_partialdir[] = ".~tmp~";
 
 /** Local address to bind.  As a character string because it's
  * interpreted by the IPv6 layer: should be a numeric IP4 or IP6
  * address, or a hostname. **/
 char *bind_address;
 
@@ -203,143 +217,150 @@
 #ifdef INET6
 	ipv6 = "";
 #endif
 
 	rprintf(f, "%s  version %s  protocol version %d\n",
 		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
-	rprintf(f,
-		"Copyright (C) 1996-2005 by Andrew Tridgell and others\n");
+	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
 	rprintf(f, "<http://rsync.samba.org/>\n");
 	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
-		"%shard links, %ssymlinks, batchfiles, \n",
+		"%shard links, %ssymlinks, batchfiles,\n",
 		(int) (sizeof (OFF_T) * 8),
 		got_socketpair, hardlinks, links);
 
 	/* Note that this field may not have type ino_t.  It depends
 	 * on the complicated interaction between largefile feature
 	 * macros. */
-	rprintf(f, "              %sinplace, %sIPv6, %d-bit system inums, %d-bit internal inums\n",
+	rprintf(f, "              %sinplace, %sIPv6, "
+		"%d-bit system inums, %d-bit internal inums\n",
 		have_inplace, ipv6,
 		(int) (sizeof dumstat->st_ino * 8),
 		(int) (sizeof (int64) * 8));
 #ifdef MAINTAINER_MODE
-	rprintf(f, "              panic action: \"%s\"\n",
-		get_panic_action());
+	rprintf(f, "Panic Action: \"%s\"\n", get_panic_action());
 #endif
 
 #if SIZEOF_INT64 < 8
 	rprintf(f, "WARNING: no 64-bit integers on this platform!\n");
 #endif
 	if (sizeof (int64) != SIZEOF_INT64) {
 		rprintf(f,
 			"WARNING: size mismatch in SIZEOF_INT64 define (%d != %d)\n",
 			(int) SIZEOF_INT64, (int) sizeof (int64));
 	}
 
-	rprintf(f,
-"\n"
-"rsync comes with ABSOLUTELY NO WARRANTY.  This is free software, and you\n"
-"are welcome to redistribute it under certain conditions.  See the GNU\n"
-"General Public Licence for details.\n"
-		);
+	rprintf(f,"\nrsync comes with ABSOLUTELY NO WARRANTY.  This is free software, and you\n");
+	rprintf(f,"are welcome to redistribute it under certain conditions.  See the GNU\n");
+	rprintf(f,"General Public Licence for details.\n");
 }
 
 
 void usage(enum logcode F)
 {
   print_rsync_version(F);
 
-  rprintf(F,"\nrsync is a file transfer program capable of efficient remote update\nvia a fast differencing algorithm.\n\n");
+  rprintf(F,"\nrsync is a file transfer program capable of efficient remote update\n");
+  rprintf(F,"via a fast differencing algorithm.\n");
 
-  rprintf(F,"Usage: rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST\n");
+  rprintf(F,"\nUsage: rsync [OPTION]... SRC [SRC]... DEST\n");
+  rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST\n");
+  rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\n");
+  rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\n");
   rprintf(F,"  or   rsync [OPTION]... [USER@]HOST:SRC [DEST]\n");
-  rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... DEST\n");
   rprintf(F,"  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]\n");
-  rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST\n");
   rprintf(F,"  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n");
-  rprintf(F,"  or   rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST\n");
-  rprintf(F,"SRC on single-colon remote HOST will be expanded by remote shell\n");
-  rprintf(F,"SRC on server remote HOST may contain shell wildcards or multiple\n");
-  rprintf(F,"  sources separated by space as long as they have same top-level\n");
+  rprintf(F,"The ':' usages connect via remote shell, while '::' & 'rsync://' usages connect\n");
+  rprintf(F,"to an rsync daemon, and require SRC or DEST to start with a module name.\n");
   rprintf(F,"\nOptions\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
   rprintf(F," -q, --quiet                 suppress non-error messages\n");
   rprintf(F," -c, --checksum              skip based on checksum, not mod-time & size\n");
   rprintf(F," -a, --archive               archive mode; same as -rlptgoD (no -H)\n");
+  rprintf(F,"     --no-OPTION             turn off an implied OPTION (e.g. --no-D)\n");
   rprintf(F," -r, --recursive             recurse into directories\n");
   rprintf(F," -R, --relative              use relative path names\n");
-  rprintf(F,"     --no-relative           turn off --relative\n");
-  rprintf(F,"     --no-implied-dirs       don't send implied dirs with -R\n");
+  rprintf(F,"     --no-implied-dirs       don't send implied dirs with --relative\n");
   rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
   rprintf(F,"     --backup-dir=DIR        make backups into hierarchy based in DIR\n");
   rprintf(F,"     --suffix=SUFFIX         set backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
   rprintf(F," -u, --update                skip files that are newer on the receiver\n");
   rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
+  rprintf(F,"     --append                append data onto shorter files\n");
   rprintf(F," -d, --dirs                  transfer directories without recursing\n");
   rprintf(F," -l, --links                 copy symlinks as symlinks\n");
   rprintf(F," -L, --copy-links            transform symlink into referent file/dir\n");
   rprintf(F,"     --copy-unsafe-links     only \"unsafe\" symlinks are transformed\n");
   rprintf(F,"     --safe-links            ignore symlinks that point outside the source tree\n");
-  rprintf(F," -H, --hard-links            preserve hard links\n");
+  rprintf(F," -k, --copy-dirlinks         transform symlink to a dir into referent dir\n");
   rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
+  rprintf(F," -H, --hard-links            preserve hard links\n");
   rprintf(F," -p, --perms                 preserve permissions\n");
-  rprintf(F," -o, --owner                 preserve owner (root only)\n");
+  rprintf(F," -E, --executability         preserve the file's executability\n");
+  rprintf(F,"     --chmod=CHMOD           change destination permissions\n");
+  rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
   rprintf(F," -g, --group                 preserve group\n");
-  rprintf(F," -D, --devices               preserve devices (root only)\n");
+  rprintf(F,"     --devices               preserve device files (super-user only)\n");
+  rprintf(F,"     --specials              preserve special files\n");
+  rprintf(F," -D                          same as --devices --specials\n");
   rprintf(F," -t, --times                 preserve times\n");
   rprintf(F," -O, --omit-dir-times        omit directories when preserving times\n");
+  rprintf(F,"     --super                 receiver attempts super-user activities\n");
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
   rprintf(F," -n, --dry-run               show what would have been transferred\n");
   rprintf(F," -W, --whole-file            copy files whole (without rsync algorithm)\n");
-  rprintf(F,"     --no-whole-file         always use incremental rsync algorithm\n");
   rprintf(F," -x, --one-file-system       don't cross filesystem boundaries\n");
   rprintf(F," -B, --block-size=SIZE       force a fixed checksum block-size\n");
   rprintf(F," -e, --rsh=COMMAND           specify the remote shell to use\n");
   rprintf(F,"     --rsync-path=PROGRAM    specify the rsync to run on the remote machine\n");
-  rprintf(F,"     --existing              only update files that already exist on receiver\n");
+  rprintf(F,"     --existing              ignore non-existing files on receiving side\n");
   rprintf(F,"     --ignore-existing       ignore files that already exist on receiving side\n");
   rprintf(F,"     --remove-sent-files     sent files/symlinks are removed from sending side\n");
   rprintf(F,"     --del                   an alias for --delete-during\n");
   rprintf(F,"     --delete                delete files that don't exist on the sending side\n");
   rprintf(F,"     --delete-before         receiver deletes before transfer (default)\n");
   rprintf(F,"     --delete-during         receiver deletes during transfer, not before\n");
   rprintf(F,"     --delete-after          receiver deletes after transfer, not before\n");
   rprintf(F,"     --delete-excluded       also delete excluded files on the receiving side\n");
   rprintf(F,"     --ignore-errors         delete even if there are I/O errors\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --max-delete=NUM        don't delete more than NUM files\n");
   rprintf(F,"     --max-size=SIZE         don't transfer any file larger than SIZE\n");
+  rprintf(F,"     --min-size=SIZE         don't transfer any file smaller than SIZE\n");
   rprintf(F,"     --partial               keep partially transferred files\n");
   rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
   rprintf(F,"     --delay-updates         put all updated files into place at transfer's end\n");
+  rprintf(F," -m, --prune-empty-dirs      prune empty directory chains from the file-list\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
   rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
   rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
   rprintf(F,"     --size-only             skip files that match in size\n");
   rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
   rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
   rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
   rprintf(F," -z, --compress              compress file data during the transfer\n");
+  rprintf(F,"     --compress-level=NUM    explicitly set compression level\n");
   rprintf(F," -C, --cvs-exclude           auto-ignore files the same way CVS does\n");
   rprintf(F," -f, --filter=RULE           add a file-filtering RULE\n");
   rprintf(F," -F                          same as --filter='dir-merge /.rsync-filter'\n");
   rprintf(F,"                             repeated: --filter='- .rsync-filter'\n");
   rprintf(F,"     --exclude=PATTERN       exclude files matching PATTERN\n");
   rprintf(F,"     --exclude-from=FILE     read exclude patterns from FILE\n");
   rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
   rprintf(F,"     --include-from=FILE     read include patterns from FILE\n");
   rprintf(F,"     --files-from=FILE       read list of source-file names from FILE\n");
   rprintf(F," -0, --from0                 all *-from/filter files are delimited by 0s\n");
   rprintf(F,"     --address=ADDRESS       bind address for outgoing socket to daemon\n");
   rprintf(F,"     --port=PORT             specify double-colon alternate port number\n");
+  rprintf(F,"     --sockopts=OPTIONS      specify custom TCP options\n");
   rprintf(F,"     --blocking-io           use blocking I/O for the remote shell\n");
-  rprintf(F,"     --no-blocking-io        turn off blocking I/O when it is the default\n");
   rprintf(F,"     --stats                 give some file-transfer stats\n");
+  rprintf(F," -8, --8-bit-output          leave high-bit chars unescaped in output\n");
+  rprintf(F," -h, --human-readable        output numbers in a human-readable format\n");
   rprintf(F,"     --progress              show progress during transfer\n");
   rprintf(F," -P                          same as --partial --progress\n");
   rprintf(F," -i, --itemize-changes       output a change-summary for all updates\n");
   rprintf(F,"     --log-format=FORMAT     output filenames using the specified format\n");
   rprintf(F,"     --password-file=FILE    read password from FILE\n");
   rprintf(F,"     --list-only             list the files instead of copying them\n");
@@ -350,124 +371,165 @@
   rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
 #ifdef INET6
   rprintf(F," -4, --ipv4                  prefer IPv4\n");
   rprintf(F," -6, --ipv6                  prefer IPv6\n");
 #endif
   rprintf(F,"     --version               print version number\n");
-  rprintf(F," -h, --help                  show this help screen\n");
+  rprintf(F,"(-h) --help                  show this help (-h works with no other options)\n");
 
   rprintf(F,"\nUse \"rsync --daemon --help\" to see the daemon-mode command-line options.\n");
   rprintf(F,"Please see the rsync(1) and rsyncd.conf(5) man pages for full documentation.\n");
   rprintf(F,"See http://rsync.samba.org/ for updates, bug reports, and answers\n");
 }
 
 enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
-      OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST,
-      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
+      OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
+      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
-      OPT_REFUSED_BASE = 9000};
+      OPT_NO_D,
+      OPT_SERVER, OPT_REFUSED_BASE = 9000};
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
+  {"help",             0,  POPT_ARG_NONE,   0, OPT_HELP, 0, 0 },
   {"version",          0,  POPT_ARG_NONE,   0, OPT_VERSION, 0, 0},
-  {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
-  {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
-  {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
+  {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
+  {"no-verbose",       0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
+  {"no-v",             0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
+  {"quiet",           'q', POPT_ARG_NONE,   0, 'q', 0, 0 },
+  {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
+  {"human-readable",  'h', POPT_ARG_NONE,   0, 'h', 0, 0},
+  {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
+  {"archive",         'a', POPT_ARG_NONE,   0, 'a', 0, 0 },
+  {"recursive",       'r', POPT_ARG_VAL,    &recurse, 2, 0, 0 },
+  {"no-recursive",     0,  POPT_ARG_VAL,    &recurse, 0, 0, 0 },
+  {"no-r",             0,  POPT_ARG_VAL,    &recurse, 0, 0, 0 },
+  {"dirs",            'd', POPT_ARG_VAL,    &xfer_dirs, 2, 0, 0 },
+  {"no-dirs",          0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },
+  {"no-d",             0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },
+  {"perms",           'p', POPT_ARG_VAL,    &preserve_perms, 1, 0, 0 },
+  {"no-perms",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
+  {"no-p",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
+  {"executability",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },
+  {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
+  {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+  {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+  {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
+  {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
+  {"super",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },
+  {"no-super",         0,  POPT_ARG_VAL,    &am_root, 0, 0, 0 },
+  {"owner",           'o', POPT_ARG_VAL,    &preserve_uid, 1, 0, 0 },
+  {"no-owner",         0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },
+  {"no-o",             0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },
+  {"group",           'g', POPT_ARG_VAL,    &preserve_gid, 1, 0, 0 },
+  {"no-group",         0,  POPT_ARG_VAL,    &preserve_gid, 0, 0, 0 },
+  {"no-g",             0,  POPT_ARG_VAL,    &preserve_gid, 0, 0, 0 },
+  {0,                 'D', POPT_ARG_NONE,   0, 'D', 0, 0 },
+  {"no-D",             0,  POPT_ARG_NONE,   0, OPT_NO_D, 0, 0 },
+  {"devices",          0,  POPT_ARG_VAL,    &preserve_devices, 1, 0, 0 },
+  {"no-devices",       0,  POPT_ARG_VAL,    &preserve_devices, 0, 0, 0 },
+  {"specials",         0,  POPT_ARG_VAL,    &preserve_specials, 1, 0, 0 },
+  {"no-specials",      0,  POPT_ARG_VAL,    &preserve_specials, 0, 0, 0 },
+  {"links",           'l', POPT_ARG_VAL,    &preserve_links, 1, 0, 0 },
+  {"no-links",         0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
+  {"no-l",             0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
+  {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
+  {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
+  {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
+  {"copy-dirlinks",   'k', POPT_ARG_NONE,   &copy_dirlinks, 0, 0, 0 },
+  {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
+  {"hard-links",      'H', POPT_ARG_VAL,    &preserve_hard_links, 1, 0, 0 },
+  {"no-hard-links",    0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },
+  {"no-H",             0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },
+  {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
+  {"no-relative",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
+  {"no-R",             0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
+  {"implied-dirs",     0,  POPT_ARG_VAL,    &implied_dirs, 1, 0, 0 },
+  {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
+  {"chmod",            0,  POPT_ARG_STRING, 0, OPT_CHMOD, 0, 0 },
   {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
   {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
-  {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
-  {"one-file-system", 'x', POPT_ARG_NONE,   &one_file_system, 0, 0, 0 },
-  {"existing",         0,  POPT_ARG_NONE,   &only_existing, 0, 0, 0 },
-  {"ignore-existing",  0,  POPT_ARG_NONE,   &opt_ignore_existing, 0, 0, 0 },
+  {"one-file-system", 'x', POPT_ARG_NONE,   0, 'x', 0, 0 },
+  {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
+  {"existing",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
+  {"ignore-non-existing",0,POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
+  {"ignore-existing",  0,  POPT_ARG_NONE,   &ignore_existing, 0, 0, 0 },
+  {"max-size",         0,  POPT_ARG_STRING, &max_size_arg, OPT_MAX_SIZE, 0, 0 },
+  {"min-size",         0,  POPT_ARG_STRING, &min_size_arg, OPT_MIN_SIZE, 0, 0 },
+  {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
+  {"inplace",          0,  POPT_ARG_NONE,   &inplace, 0, 0, 0 },
+  {"append",           0,  POPT_ARG_VAL,    &append_mode, 1, 0, 0 },
   {"del",              0,  POPT_ARG_NONE,   &delete_during, 0, 0, 0 },
   {"delete",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },
   {"delete-before",    0,  POPT_ARG_VAL,    &delete_before, 2, 0, 0 },
   {"delete-during",    0,  POPT_ARG_NONE,   &delete_during, 0, 0, 0 },
   {"delete-after",     0,  POPT_ARG_NONE,   &delete_after, 0, 0, 0 },
   {"delete-excluded",  0,  POPT_ARG_NONE,   &delete_excluded, 0, 0, 0 },
   {"remove-sent-files",0,  POPT_ARG_NONE,   &remove_sent_files, 0, 0, 0 },
   {"force",            0,  POPT_ARG_NONE,   &force_delete, 0, 0, 0 },
-  {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
+  {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
+  {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
+  {0,                 'F', POPT_ARG_NONE,   0, 'F', 0, 0 },
   {"filter",          'f', POPT_ARG_STRING, 0, OPT_FILTER, 0, 0 },
   {"exclude",          0,  POPT_ARG_STRING, 0, OPT_EXCLUDE, 0, 0 },
   {"include",          0,  POPT_ARG_STRING, 0, OPT_INCLUDE, 0, 0 },
   {"exclude-from",     0,  POPT_ARG_STRING, 0, OPT_EXCLUDE_FROM, 0, 0 },
   {"include-from",     0,  POPT_ARG_STRING, 0, OPT_INCLUDE_FROM, 0, 0 },
-  {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
-  {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
-  {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
-  {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
-  {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
   {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
-  {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
-  {"inplace",          0,  POPT_ARG_NONE,   &inplace, 0, 0, 0 },
-  {"dirs",            'd', POPT_ARG_VAL,    &xfer_dirs, 2, 0, 0 },
-  {"links",           'l', POPT_ARG_NONE,   &preserve_links, 0, 0, 0 },
-  {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
-  {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
   {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
   {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
-  {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
-  {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
-  {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
-  {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
-  {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
-  {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
-  {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
+  {"no-W",             0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
   {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
-  {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
-  {"quiet",           'q', POPT_ARG_NONE,   0, 'q', 0, 0 },
-  {"archive",         'a', POPT_ARG_NONE,   &archive_mode, 0, 0, 0 },
-  {"server",           0,  POPT_ARG_NONE,   &am_server, 0, 0, 0 },
-  {"sender",           0,  POPT_ARG_NONE,   0, OPT_SENDER, 0, 0 },
-  {"recursive",       'r', POPT_ARG_NONE,   &recurse, 0, 0, 0 },
-  {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
-  {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
-  {"no-relative",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
-  {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
-  {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
-  {"max-size",         0,  POPT_ARG_STRING, &max_size_arg,  OPT_MAX_SIZE, 0, 0 },
-  {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
-  {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
   {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
-  /* TODO: Should this take an optional int giving the compression level? */
-  {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
-  {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
-  {"progress",         0,  POPT_ARG_NONE,   &do_progress, 0, 0, 0 },
-  {"partial",          0,  POPT_ARG_NONE,   &keep_partial, 0, 0, 0 },
+  {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
+  {"compress-level",   0,  POPT_ARG_INT,    &def_compress_level, 'z', 0, 0 },
+  {0,                 'P', POPT_ARG_NONE,   0, 'P', 0, 0 },
+  {"progress",         0,  POPT_ARG_VAL,    &do_progress, 1, 0, 0 },
+  {"no-progress",      0,  POPT_ARG_VAL,    &do_progress, 0, 0, 0 },
+  {"partial",          0,  POPT_ARG_VAL,    &keep_partial, 1, 0, 0 },
+  {"no-partial",       0,  POPT_ARG_VAL,    &keep_partial, 0, 0, 0 },
   {"partial-dir",      0,  POPT_ARG_STRING, &partial_dir, 0, 0, 0 },
   {"delay-updates",    0,  POPT_ARG_NONE,   &delay_updates, 0, 0, 0 },
-  {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
-  {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
-  {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
-  {0,                 'F', POPT_ARG_NONE,   0, 'F', 0, 0 },
-  {0,                 'P', POPT_ARG_NONE,   0, 'P', 0, 0 },
-  {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
-  {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
+  {"prune-empty-dirs",'m', POPT_ARG_NONE,   &prune_empty_dirs, 0, 0, 0 },
   {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
-  {"itemize-changes", 'i', POPT_ARG_NONE,   &itemize_changes, 0, 0, 0 },
+  {"itemize-changes", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },
   {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
+  {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
   {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
-  {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
+  {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
+  {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
   {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
   {"write-batch",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },
   {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
   {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
   {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
-  {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
-  {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
-  {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
+  {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
+  {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
+  {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
+  {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
+  {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
 #ifdef INET6
   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
 #endif
-  /* All these options switch us into daemon-mode option-parsing. */
+  {"8-bit-output",    '8', POPT_ARG_NONE,   &allow_8bit_chars, 0, 0, 0 },
+  {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
+  {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
+  {"sockopts",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },
+  {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
+  {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
+  {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
+  {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
+  {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
+  {"server",           0,  POPT_ARG_NONE,   0, OPT_SERVER, 0, 0 },
+  {"sender",           0,  POPT_ARG_NONE,   0, OPT_SENDER, 0, 0 },
+  /* All the following options switch us into daemon-mode option-parsing. */
   {"config",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
   {"daemon",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
   {"detach",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
   {"no-detach",        0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
   {0,0,0,0, 0, 0, 0}
 };
@@ -479,18 +541,19 @@
   rprintf(F,"\nUsage: rsync --daemon [OPTION]...\n");
   rprintf(F,"     --address=ADDRESS       bind to the specified address\n");
   rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
   rprintf(F,"     --config=FILE           specify alternate rsyncd.conf file\n");
   rprintf(F,"     --no-detach             do not detach from the parent\n");
   rprintf(F,"     --port=PORT             listen on alternate port number\n");
+  rprintf(F,"     --sockopts=OPTIONS      specify custom TCP options\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
 #ifdef INET6
   rprintf(F," -4, --ipv4                  prefer IPv4\n");
   rprintf(F," -6, --ipv6                  prefer IPv6\n");
 #endif
-  rprintf(F," -h, --help                  show this help screen\n");
+  rprintf(F,"     --help                  show this help screen\n");
 
   rprintf(F,"\nIf you were not trying to invoke rsync as a daemon, avoid using any of the\n");
   rprintf(F,"daemon-specific rsync options.  See also the rsyncd.conf(5) man page.\n");
 }
 
 static struct poptOption long_daemon_options[] = {
@@ -503,15 +566,19 @@
   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
 #endif
   {"detach",           0,  POPT_ARG_VAL,    &no_detach, 0, 0, 0 },
   {"no-detach",        0,  POPT_ARG_VAL,    &no_detach, 1, 0, 0 },
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
+  {"sockopts",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },
   {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
   {"server",           0,  POPT_ARG_NONE,   &am_server, 0, 0, 0 },
+  {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
   {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
+  {"no-verbose",       0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
+  {"no-v",             0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
   {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
   {0,0,0,0, 0, 0, 0}
 };
 
 
 static char err_buf[200];
@@ -527,12 +594,13 @@
 	if (!err_buf[0]) {
 		strcpy(err_buf, "Error parsing options: "
 		    "option may be supported on client but not on server?\n");
 	}
 
 	rprintf(FERROR, RSYNC_NAME ": %s", err_buf);
+	msleep(20);
 }
 
 
 /**
  * Tweak the option table to disable all options that the rsyncd.conf
  * file has told us to refuse.
@@ -567,21 +635,26 @@
 				 * an implied option later in the code. */
 				switch (*shortname) {
 				case 'r': case 'd': case 'l': case 'p':
 				case 't': case 'g': case 'o': case 'D':
 					refused_archive_part = op->val;
 					break;
+				case 'z':
+					refused_compress = op->val;
+					break;
 				case '\0':
 					if (wildmatch("delete", op->longName))
 						refused_delete = op->val;
 					else if (wildmatch("delete-before", op->longName))
 						refused_delete_before = op->val;
 					else if (wildmatch("partial", op->longName))
 						refused_partial = op->val;
 					else if (wildmatch("progress", op->longName))
 						refused_progress = op->val;
+					else if (wildmatch("inplace", op->longName))
+						refused_inplace = op->val;
 					break;
 				}
 				if (!is_wild)
 					break;
 			}
 		}
@@ -618,36 +691,64 @@
 	}
 
 	return i;
 }
 
 
-static OFF_T parse_size_arg(const char *size_arg)
+static OFF_T parse_size_arg(char **size_arg, char def_suf)
 {
+	int reps, mult, make_compatible = 0;
 	const char *arg;
-	OFF_T size;
+	OFF_T size = 1;
 
-	for (arg = size_arg; isdigit(*(uchar*)arg); arg++) {}
+	for (arg = *size_arg; isdigit(*(uchar*)arg); arg++) {}
 	if (*arg == '.')
 		for (arg++; isdigit(*(uchar*)arg); arg++) {}
-	switch (*arg) {
+	switch (*arg && *arg != '+' && *arg != '-' ? *arg++ : def_suf) {
+	case 'b': case 'B':
+		reps = 0;
+		break;
 	case 'k': case 'K':
-		size = atof(size_arg) * 1024;
+		reps = 1;
 		break;
 	case 'm': case 'M':
-		size = atof(size_arg) * 1024*1024;
+		reps = 2;
 		break;
 	case 'g': case 'G':
-		size = atof(size_arg) * 1024*1024*1024;
-		break;
-	case '\0':
-		size = atof(size_arg);
+		reps = 3;
 		break;
 	default:
-		size = 0;
-		break;
+		return -1;
+	}
+	if (*arg == 'b' || *arg == 'B')
+		mult = 1000, make_compatible = 1, arg++;
+	else if (!*arg || *arg == '+' || *arg == '-')
+		mult = 1024;
+	else if (strncasecmp(arg, "ib", 2) == 0)
+		mult = 1024, arg += 2;
+	else
+		return -1;
+	while (reps--)
+		size *= mult;
+	size *= atof(*size_arg);
+	if ((*arg == '+' || *arg == '-') && arg[1] == '1')
+		size += atoi(arg), make_compatible = 1, arg += 2;
+	if (*arg)
+		return -1;
+	if (size > 0 && make_compatible) {
+		/* We convert this manually because we may need %lld precision,
+		 * and that's not a portable sprintf() escape. */
+		char buf[128], *s = buf + sizeof buf - 1;
+		OFF_T num = size;
+		*s = '\0';
+		while (num) {
+			*--s = (num % 10) + '0';
+			num /= 10;
+		}
+		if (!(*size_arg = strdup(s)))
+			out_of_memory("parse_size_arg");
 	}
 	return size;
 }
 
 
 static void create_refuse_error(int which)
@@ -695,12 +796,31 @@
 
 		switch (opt) {
 		case OPT_VERSION:
 			print_rsync_version(FINFO);
 			exit_cleanup(0);
 
+		case OPT_SERVER:
+			if (!am_server) {
+				/* Disable popt aliases on the server side and
+				 * then start parsing the options again. */
+				poptFreeContext(pc);
+				pc = poptGetContext(RSYNC_NAME, *argc, *argv,
+						    long_options, 0);
+				am_server = 1;
+			}
+			break;
+
+		case OPT_SENDER:
+			if (!am_server) {
+				usage(FERROR);
+				exit_cleanup(RERR_SYNTAX);
+			}
+			am_sender = 1;
+			break;
+
 		case OPT_DAEMON:
 			if (am_daemon) {
 				strcpy(err_buf, "Attempt to hack rsync thwarted!\n");
 				return 0;
 			}
 			poptFreeContext(pc);
@@ -721,12 +841,19 @@
 					    "rsync: %s: %s (in daemon mode)\n",
 					    poptBadOption(pc, POPT_BADOPTION_NOALIAS),
 					    poptStrerror(opt));
 					goto daemon_error;
 				}
 			}
+
+			if (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {
+				snprintf(err_buf, sizeof err_buf,
+					 "the --temp-dir path is WAY too long.\n");
+				return 0;
+			}
+
 			if (!daemon_opt) {
 				rprintf(FERROR, "Daemon option(s) used without --daemon.\n");
 			    daemon_error:
 				rprintf(FERROR,
 				    "(Type \"rsync --daemon --help\" for assistance with daemon mode.)\n");
 				exit_cleanup(RERR_SYNTAX);
@@ -774,31 +902,57 @@
 			}
 			parse_filter_file(&filter_list, arg,
 				opt == OPT_INCLUDE_FROM ? MATCHFLG_INCLUDE : 0,
 				XFLG_FATAL_ERRORS | XFLG_OLD_PREFIXES);
 			break;
 
+		case 'a':
+			if (refused_archive_part) {
+				create_refuse_error(refused_archive_part);
+				return 0;
+			}
+			if (!recurse) /* preserve recurse == 2 */
+				recurse = 1;
+#ifdef SUPPORT_LINKS
+			preserve_links = 1;
+#endif
+			preserve_perms = 1;
+			preserve_times = 1;
+			preserve_gid = 1;
+			preserve_uid = 1;
+			preserve_devices = 1;
+			preserve_specials = 1;
+			break;
+
+		case 'D':
+			preserve_devices = preserve_specials = 1;
+			break;
+
+		case OPT_NO_D:
+			preserve_devices = preserve_specials = 0;
+			break;
+
 		case 'h':
-			usage(FINFO);
-			exit_cleanup(0);
+			human_readable++;
+			break;
+
+		case 'i':
+			itemize_changes++;
+			break;
 
 		case 'v':
 			verbose++;
 			break;
 
 		case 'q':
 			if (frommain)
 				quiet++;
 			break;
 
-		case OPT_SENDER:
-			if (!am_server) {
-				usage(FERROR);
-				exit_cleanup(RERR_SYNTAX);
-			}
-			am_sender = 1;
+		case 'x':
+			one_file_system++;
 			break;
 
 		case 'F':
 			switch (++F_option_cnt) {
 			case 1:
 				parse_rule(&filter_list,": /.rsync-filter",0,0);
@@ -816,12 +970,27 @@
 				return 0;
 			}
 			do_progress = 1;
 			keep_partial = 1;
 			break;
 
+		case 'z':
+			if (def_compress_level < Z_DEFAULT_COMPRESSION
+			 || def_compress_level > Z_BEST_COMPRESSION) {
+				snprintf(err_buf, sizeof err_buf,
+					"--compress-level value is invalid: %d\n",
+					def_compress_level);
+				return 0;
+			}
+			do_compression = def_compress_level != Z_NO_COMPRESSION;
+			if (do_compression && refused_compress) {
+				create_refuse_error(refused_compress);
+				return 0;
+			}
+			break;
+
 		case OPT_WRITE_BATCH:
 			/* batch_name is already set */
 			write_batch = 1;
 			break;
 
 		case OPT_ONLY_WRITE_BATCH:
@@ -832,20 +1001,29 @@
 		case OPT_READ_BATCH:
 			/* batch_name is already set */
 			read_batch = 1;
 			break;
 
 		case OPT_MAX_SIZE:
-			if ((max_size = parse_size_arg(max_size_arg)) <= 0) {
+			if ((max_size = parse_size_arg(&max_size_arg, 'b')) <= 0) {
 				snprintf(err_buf, sizeof err_buf,
 					"--max-size value is invalid: %s\n",
 					max_size_arg);
 				return 0;
 			}
 			break;
 
+		case OPT_MIN_SIZE:
+			if ((min_size = parse_size_arg(&min_size_arg, 'b')) <= 0) {
+				snprintf(err_buf, sizeof err_buf,
+					"--min-size value is invalid: %s\n",
+					min_size_arg);
+				return 0;
+			}
+			break;
+
 		case OPT_LINK_DEST:
 #ifdef HAVE_LINK
 			link_dest = 1;
 			dest_option = "--link-dest";
 			goto set_dest_dir;
 #else
@@ -873,12 +1051,26 @@
 			arg = poptGetOptArg(pc);
 			if (sanitize_paths)
 				arg = sanitize_path(NULL, arg, NULL, 0);
 			basis_dir[basis_dir_cnt++] = (char *)arg;
 			break;
 
+		case OPT_CHMOD:
+			arg = poptGetOptArg(pc);
+			if (!parse_chmod(arg, &chmod_modes)) {
+				snprintf(err_buf, sizeof err_buf,
+				    "Invalid argument passed to --chmod (%s)\n",
+				    arg);
+				return 0;
+			}
+			break;
+
+		case OPT_HELP:
+			usage(FINFO);
+			exit_cleanup(0);
+
 		default:
 			/* A large opt value means that set_refuse_options()
 			 * turned this option off. */
 			if (opt >= OPT_REFUSED_BASE) {
 				create_refuse_error(opt);
 				return 0;
@@ -888,12 +1080,18 @@
 				 poptBadOption(pc, POPT_BADOPTION_NOALIAS),
 				 poptStrerror(opt));
 			return 0;
 		}
 	}
 
+	if (human_readable && *argc == 2) {
+		/* Allow the old meaning of 'h' (--help) on its own. */
+		usage(FINFO);
+		exit_cleanup(0);
+	}
+
 #ifndef SUPPORT_LINKS
 	if (preserve_links && !am_sender) {
 		snprintf(err_buf, sizeof err_buf,
 			 "symlinks are not supported on this %s\n",
 			 am_server ? "server" : "client");
 		return 0;
@@ -948,52 +1146,47 @@
 	if (compare_dest + copy_dest + link_dest > 1) {
 		snprintf(err_buf, sizeof err_buf,
 			"You may not mix --compare-dest, --copy-dest, and --link-dest.\n");
 		return 0;
 	}
 
-	if (archive_mode) {
-		if (refused_archive_part) {
-			create_refuse_error(refused_archive_part);
-			return 0;
-		}
-		if (!files_from)
-			recurse = 1;
-#ifdef SUPPORT_LINKS
-		preserve_links = 1;
-#endif
-		preserve_perms = 1;
-		preserve_times = 1;
-		preserve_gid = 1;
-		preserve_uid = 1;
-		preserve_devices = 1;
+	if (files_from) {
+		if (recurse == 1) /* preserve recurse == 2 */
+			recurse = 0;
+		if (xfer_dirs < 0)
+			xfer_dirs = 1;
 	}
 
-	if (recurse || list_only || files_from)
-		xfer_dirs |= 1;
+	if (xfer_dirs < 1)
+		xfer_dirs = recurse || list_only;
 
 	if (relative_paths < 0)
 		relative_paths = files_from? 1 : 0;
+	if (!relative_paths)
+		implied_dirs = 0;
 
 	if (!!delete_before + delete_during + delete_after > 1) {
 		snprintf(err_buf, sizeof err_buf,
 			"You may not combine multiple --delete-WHEN options.\n");
 		return 0;
 	}
-	if (!recurse) {
-		delete_before = delete_during = delete_after = 0;
-		delete_mode = delete_excluded = 0;
-	} else if (delete_before || delete_during || delete_after)
+	if (delete_before || delete_during || delete_after)
 		delete_mode = 1;
 	else if (delete_mode || delete_excluded) {
 		if (refused_delete_before) {
 			create_refuse_error(refused_delete_before);
 			return 0;
 		}
 		delete_mode = delete_before = 1;
 	}
+	saw_delete_opt = delete_mode;
+	saw_delete_excluded_opt = delete_excluded;
+	if (!xfer_dirs) {
+		delete_before = delete_during = delete_after = 0;
+		delete_mode = delete_excluded = 0;
+	}
 
 	if (delete_mode && refused_delete) {
 		create_refuse_error(refused_delete);
 		return 0;
 	}
 
@@ -1075,38 +1268,41 @@
 			return 0;
 		}
 		if (backup_dir_buf[backup_dir_len - 1] != '/') {
 			backup_dir_buf[backup_dir_len++] = '/';
 			backup_dir_buf[backup_dir_len] = '\0';
 		}
-		if (verbose > 1 && !am_sender) {
-			rprintf(FINFO, "backup_dir is %s\n",
-				safe_fname(backup_dir_buf));
-		}
+		if (verbose > 1 && !am_sender)
+			rprintf(FINFO, "backup_dir is %s\n", backup_dir_buf);
 	} else if (!backup_suffix_len && (!am_server || !am_sender)) {
 		snprintf(err_buf, sizeof err_buf,
 			"--suffix cannot be a null string without --backup-dir\n");
 		return 0;
+	} else if (make_backups && delete_mode && !delete_excluded) {
+		snprintf(backup_dir_buf, sizeof backup_dir_buf,
+			"P *%s", backup_suffix);
+		parse_rule(&filter_list, backup_dir_buf, 0, 0);
 	}
 	if (make_backups && !backup_dir)
 		omit_dir_times = 1;
 
 	if (log_format) {
-		if (log_format_has(log_format, 'i'))
-			log_format_has_i = 1;
+		if (am_server && log_format_has(log_format, 'I'))
+			log_format_has_i = 2;
+		else if (log_format_has(log_format, 'i'))
+			log_format_has_i = itemize_changes | 1;
 		if (!log_format_has(log_format, 'b')
 		 && !log_format_has(log_format, 'c'))
 			log_before_transfer = !am_server;
 	} else if (itemize_changes) {
 		log_format = "%i %n%L";
-		log_format_has_i = 1;
+		log_format_has_i = itemize_changes;
 		log_before_transfer = !am_server;
 	}
 
-	if ((do_progress || dry_run) && !verbose && !log_before_transfer
-	    && !am_server)
+	if (do_progress && !verbose && !log_before_transfer && !am_server)
 		verbose = 1;
 
 	if (dry_run)
 		do_xfers = 0;
 
 	set_io_timeout(io_timeout);
@@ -1123,38 +1319,61 @@
 	if (bwlimit) {
 		bwlimit_writemax = (size_t)bwlimit * 128;
 		if (bwlimit_writemax < 512)
 			bwlimit_writemax = 512;
 	}
 
+	if (sparse_files && inplace) {
+		/* Note: we don't check for this below, because --append is
+		 * OK with --sparse (as long as redos are handled right). */
+		snprintf(err_buf, sizeof err_buf,
+			 "--sparse cannot be used with --inplace\n");
+		return 0;
+	}
+
+	if (append_mode) {
+		if (whole_file > 0) {
+			snprintf(err_buf, sizeof err_buf,
+				 "--append cannot be used with --whole-file\n");
+			return 0;
+		}
+		if (refused_inplace) {
+			create_refuse_error(refused_inplace);
+			return 0;
+		}
+		inplace = 1;
+	}
+
 	if (delay_updates && !partial_dir)
-		partial_dir = partialdir_for_delayupdate;
+		partial_dir = tmp_partialdir;
 
 	if (inplace) {
 #ifdef HAVE_FTRUNCATE
 		if (partial_dir) {
 			snprintf(err_buf, sizeof err_buf,
-				 "--inplace cannot be used with --%s\n",
+				 "--%s cannot be used with --%s\n",
+				 append_mode ? "append" : "inplace",
 				 delay_updates ? "delay-updates" : "partial-dir");
 			return 0;
 		}
 		/* --inplace implies --partial for refusal purposes, but we
 		 * clear the keep_partial flag for internal logic purposes. */
 		if (refused_partial) {
 			create_refuse_error(refused_partial);
 			return 0;
 		}
 		keep_partial = 0;
 #else
 		snprintf(err_buf, sizeof err_buf,
-			 "--inplace is not supported on this %s\n",
+			 "--%s is not supported on this %s\n",
+			 append_mode ? "append" : "inplace",
 			 am_server ? "server" : "client");
 		return 0;
 #endif
 	} else {
-		if (keep_partial && !partial_dir) {
+		if (keep_partial && !partial_dir && !am_server) {
 			if ((arg = getenv("RSYNC_PARTIAL_DIR")) != NULL && *arg)
 				partial_dir = strdup(arg);
 		}
 		if (partial_dir) {
 			if (*partial_dir)
 				clean_fname(partial_dir, 1);
@@ -1238,12 +1457,13 @@
 
 	int i, x;
 
 	if (blocking_io == -1)
 		blocking_io = 0;
 
+	/* This should always remain first on the server's command-line. */
 	args[ac++] = "--server";
 
 	if (daemon_over_rsh) {
 		args[ac++] = "--daemon";
 		*argc = ac;
 		/* if we're passing --daemon, we're done */
@@ -1260,22 +1480,31 @@
 
 	/* the -q option is intentionally left out */
 	if (make_backups)
 		argstr[x++] = 'b';
 	if (update_only)
 		argstr[x++] = 'u';
-	if (!do_xfers) /* NOT "dry_run"! */
+	if (!do_xfers) /* Note: NOT "dry_run"! */
 		argstr[x++] = 'n';
 	if (preserve_links)
 		argstr[x++] = 'l';
-	if (copy_links)
-		argstr[x++] = 'L';
-	if (xfer_dirs > 1)
+	if (xfer_dirs > (recurse || !delete_mode || !am_sender))
 		argstr[x++] = 'd';
-	if (keep_dirlinks && am_sender)
-		argstr[x++] = 'K';
+	if (am_sender) {
+		if (keep_dirlinks)
+			argstr[x++] = 'K';
+		if (prune_empty_dirs)
+			argstr[x++] = 'm';
+		if (omit_dir_times == 2)
+			argstr[x++] = 'O';
+	} else {
+		if (copy_links)
+			argstr[x++] = 'L';
+		if (copy_dirlinks)
+			argstr[x++] = 'k';
+	}
 
 	if (whole_file > 0)
 		argstr[x++] = 'W';
 	/* We don't need to send --no-whole-file, because it's the
 	 * default for remote transfers, and in any case old versions
 	 * of rsync will not understand it. */
@@ -1283,55 +1512,78 @@
 	if (preserve_hard_links)
 		argstr[x++] = 'H';
 	if (preserve_uid)
 		argstr[x++] = 'o';
 	if (preserve_gid)
 		argstr[x++] = 'g';
-	if (preserve_devices)
+	if (preserve_devices) /* ignore preserve_specials here */
 		argstr[x++] = 'D';
 	if (preserve_times)
 		argstr[x++] = 't';
-	if (omit_dir_times == 2 && am_sender)
-		argstr[x++] = 'O';
 	if (preserve_perms)
 		argstr[x++] = 'p';
+	else if (preserve_executability && am_sender)
+		argstr[x++] = 'E';
 	if (recurse)
 		argstr[x++] = 'r';
 	if (always_checksum)
 		argstr[x++] = 'c';
 	if (cvs_exclude)
 		argstr[x++] = 'C';
 	if (ignore_times)
 		argstr[x++] = 'I';
 	if (relative_paths)
 		argstr[x++] = 'R';
-	if (one_file_system)
+	if (one_file_system) {
 		argstr[x++] = 'x';
+		if (one_file_system > 1)
+			argstr[x++] = 'x';
+	}
 	if (sparse_files)
 		argstr[x++] = 'S';
 	if (do_compression)
 		argstr[x++] = 'z';
 
 	/* This is a complete hack - blame Rusty.  FIXME!
 	 * This hack is only needed for older rsync versions that
 	 * don't understand the --list-only option. */
 	if (list_only == 1 && !recurse)
 		argstr[x++] = 'r';
 
-	argstr[x] = 0;
+	argstr[x] = '\0';
 
 	if (x != 1)
 		args[ac++] = argstr;
 
 	if (list_only > 1)
 		args[ac++] = "--list-only";
 
+	/* This makes sure that the remote rsync can handle deleting with -d
+	 * sans -r because the --no-r option was added at the same time. */
+	if (xfer_dirs && !recurse && delete_mode && am_sender)
+		args[ac++] = "--no-r";
+
+	if (do_compression && def_compress_level != Z_DEFAULT_COMPRESSION) {
+		if (asprintf(&arg, "--compress-level=%d", def_compress_level) < 0)
+			goto oom;
+		args[ac++] = arg;
+	}
+
+	if (preserve_devices) {
+		/* Note: sending "--devices" would not be backward-compatible. */
+		if (!preserve_specials)
+			args[ac++] = "--no-specials"; /* -D is already set. */
+	} else if (preserve_specials)
+		args[ac++] = "--specials";
+
 	/* The server side doesn't use our log-format, but in certain
 	 * circumstances they need to know a little about the option. */
 	if (log_format && am_sender) {
-		if (log_format_has_i)
+		if (log_format_has_i > 1)
+			args[ac++] = "--log-format=%i%I";
+		else if (log_format_has_i)
 			args[ac++] = "--log-format=%i";
 		else if (log_format_has_o_or_i)
 			args[ac++] = "--log-format=%o";
 		else if (!verbose)
 			args[ac++] = "--log-format=X";
 	}
@@ -1345,12 +1597,17 @@
 	if (max_delete && am_sender) {
 		if (asprintf(&arg, "--max-delete=%d", max_delete) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
+	if (min_size && am_sender) {
+		args[ac++] = "--min-size";
+		args[ac++] = min_size_arg;
+	}
+
 	if (max_size && am_sender) {
 		args[ac++] = "--max-size";
 		args[ac++] = max_size_arg;
 	}
 
 	if (io_timeout) {
@@ -1390,17 +1647,18 @@
 		if (delete_after)
 			args[ac++] = "--delete-after";
 		if (force_delete)
 			args[ac++] = "--force";
 		if (write_batch < 0)
 			args[ac++] = "--only-write-batch=X";
+		if (am_root > 1)
+			args[ac++] = "--super";
+		if (size_only)
+			args[ac++] = "--size-only";
 	}
 
-	if (size_only)
-		args[ac++] = "--size-only";
-
 	if (modify_window_set) {
 		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
@@ -1408,19 +1666,19 @@
 		if (asprintf(&arg, "--checksum-seed=%d", checksum_seed) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
 	if (partial_dir && am_sender) {
-		if (partial_dir != partialdir_for_delayupdate) {
+		if (partial_dir != tmp_partialdir) {
 			args[ac++] = "--partial-dir";
 			args[ac++] = partial_dir;
 		}
 		if (delay_updates)
 			args[ac++] = "--delay-updates";
-	} else if (keep_partial)
+	} else if (keep_partial && am_sender)
 		args[ac++] = "--partial";
 
 	if (ignore_errors)
 		args[ac++] = "--ignore-errors";
 
 	if (copy_unsafe_links)
@@ -1429,22 +1687,25 @@
 	if (safe_symlinks)
 		args[ac++] = "--safe-links";
 
 	if (numeric_ids)
 		args[ac++] = "--numeric-ids";
 
-	if (only_existing && am_sender)
-		args[ac++] = "--existing";
-
-	if (opt_ignore_existing && am_sender)
+	if (ignore_existing && am_sender)
 		args[ac++] = "--ignore-existing";
 
-	if (inplace)
+	/* Backward compatibility: send --existing, not --ignore-non-existing. */
+	if (ignore_non_existing && am_sender)
+		args[ac++] = "--existing";
+
+	if (append_mode)
+		args[ac++] = "--append";
+	else if (inplace)
 		args[ac++] = "--inplace";
 
-	if (tmpdir) {
+	if (tmpdir && am_sender) {
 		args[ac++] = "--temp-dir";
 		args[ac++] = tmpdir;
 	}
 
 	if (basis_dir[0] && am_sender) {
 		/* the server only needs this option if it is not the sender,
@@ -1468,13 +1729,13 @@
 			args[ac++] = "--files-from=-";
 			args[ac++] = "--from0";
 		}
 		if (!relative_paths)
 			args[ac++] = "--no-relative";
 	}
-	if (!implied_dirs && !am_sender)
+	if (relative_paths && !implied_dirs && !am_sender)
 		args[ac++] = "--no-implied-dirs";
 
 	if (fuzzy_basis && am_sender)
 		args[ac++] = "--fuzzy";
 
 	if (remove_sent_files)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/packaging/lsb/rsync.spec	2005-07-29 03:31:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging/lsb/rsync.spec	2006-03-12 02:25:04.000000000 +0800
@@ -1,9 +1,9 @@
 Summary: A program for synchronizing files over a network.
 Name: rsync
-Version: 2.6.6
+Version: 2.6.7
 Release: 1
 Group: Applications/Internet
 Source:	ftp://rsync.samba.org/pub/rsync/rsync-%{version}.tar.gz
 URL: http://rsync.samba.org/
 
 Prefix: %{_prefix}
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging: nightly-rsync
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/packaging: release-rsync
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/params.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/params.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/params.c	2005-02-08 04:36:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/params.c	2006-01-14 05:17:09.000000000 +0800
@@ -489,13 +489,13 @@
     }
 
   OpenedFile = fopen( FileName, "r" );
   if( NULL == OpenedFile )
     {
     rsyserr(FERROR, errno, "rsync: unable to open configuration file \"%s\"",
-	    safe_fname(FileName));
+	    FileName);
     }
 
   return( OpenedFile );
   } /* OpenConfFile */
 
 BOOL pm_process( char *FileName,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/acls.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/acls.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/acls.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/acls.diff	2006-03-12 02:44:02.000000000 +0800
@@ -1,21 +1,19 @@
 After applying this patch, run these commands for a successful build:
 
-    autoconf
-    autoheader
-    ./configure --with-acl-support
-    make proto
+    ./prepare-source
+    ./configure --enable-acl-support
     make
 
 The program currently complains when the --acls (-A) option is used to copy
 from a disk that doesn't support ACLs.  This should be changed to silently 
 notice that no ACLs are available to copy.  Of course, trying to write out
 ACLs to a non-ACL-supporting disk should complain.
 
---- orig/Makefile.in	2005-07-07 21:29:57
-+++ Makefile.in	2005-07-07 23:11:55
+--- old/Makefile.in
++++ new/Makefile.in
 @@ -25,15 +25,15 @@ VERSION=@VERSION@
  .SUFFIXES:
  .SUFFIXES: .c .o
  
 -HEADERS=byteorder.h config.h errcode.h proto.h rsync.h lib/pool_alloc.h
 +HEADERS=byteorder.h config.h errcode.h proto.h rsync.h smb_acls.h lib/pool_alloc.h
@@ -24,20 +22,20 @@
 +	lib/permstring.o lib/pool_alloc.o lib/sysacls.o @LIBOBJS@
  ZLIBOBJ=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
  	zlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o
  OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
  	main.o checksum.o match.o syscall.o log.o backup.o
  OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
--	fileio.o batch.o clientname.o
-+	fileio.o batch.o clientname.o acls.o
+-	fileio.o batch.o clientname.o chmod.o
++	fileio.o batch.o clientname.o chmod.o acls.o
  OBJS3=progress.o pipe.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
---- orig/acls.c	2005-05-12 23:30:45
-+++ acls.c	2005-05-12 23:30:45
-@@ -0,0 +1,1130 @@
+--- old/acls.c
++++ new/acls.c
+@@ -0,0 +1,1201 @@
 +/* -*- c-file-style: "linux" -*-
 +   Copyright (C) Andrew Tridgell 1996
 +   Copyright (C) Paul Mackerras 1996
 +
 +   This program is free software; you can redistribute it and/or modify
 +   it under the terms of the GNU General Public License as published by
@@ -61,12 +59,13 @@
 +
 +#ifdef SUPPORT_ACLS
 +
 +extern int preserve_acls;
 +extern int am_root;
 +extern int dry_run;
++extern int orig_umask;
 +
 +typedef struct {
 +	id_t id;
 +	uchar access;
 +	SMB_ACL_TAG_T tag_type;
 +} rsync_ace;
@@ -341,13 +340,13 @@
 +			break;
 +		case SMB_ACL_MASK:
 +			ch = 'm';
 +			break;
 +		default:
 +			rprintf(FERROR,
-+				"send_rsync_acl: unknown tag_type (%0x) on ACE; disregarding\n",
++				"send_rsync_acl: unknown tag_type (%02x) on ACE; disregarding\n",
 +				race->tag_type);
 +			continue;
 +		}
 +		write_byte(f, ch);
 +		write_byte(f, race->access);
 +		if (isupper((int)ch)) {
@@ -373,37 +372,37 @@
 +		"unknown SMB_ACL_TYPE_T";
 +}
 +
 +/* Generate the ACL(s) for this flist entry;
 + * ACL(s) are either sent or cleaned-up by send_acl() below. */
 +
-+BOOL make_acl(const struct file_struct *file, const char *fname)
++int make_acl(const struct file_struct *file, const char *fname)
 +{
 +	SMB_ACL_TYPE_T *type,
 +		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
 +	rsync_acl *curr_racl;
 +	if (!preserve_acls || S_ISLNK(file->mode))
-+		return True;
++		return 1;
 +	for (type = &types[0], curr_racl = &_curr_rsync_acls[0];
 +	     type < &types[0] + sizeof types / sizeof types[0]
 +		&& (*type == SMB_ACL_TYPE_ACCESS || S_ISDIR(file->mode));
 +	     type++, curr_racl++) {
 +		SMB_ACL_T sacl;
 +		BOOL ok;
 +		*curr_racl = rsync_acl_initializer;
 +		if (!(sacl = sys_acl_get_file(fname, *type))) {
 +			rprintf(FERROR, "send_acl: sys_acl_get_file(%s, %s): %s\n",
 +				fname, str_acl_type(*type), strerror(errno));
-+			return False;
++			return -1;
 +		}
 +		ok = unpack_smb_acl(curr_racl, sacl);
 +		sys_acl_free_acl(sacl);
 +		if (!ok)
-+			return False;
++			return -1;
 +	}
-+	return True;
++	return 0;
 +}
 +
 +/* Send the make_acl()-generated ACLs for this flist entry,
 + * or clean up after an flist entry that's not being sent (f == -1). */
 +
 +void send_acl(const struct file_struct *file, int f)
@@ -757,13 +756,13 @@
 +{
 +	SMB_ACL_TYPE_T *type,
 +		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
 +	char *fname;
 +	if (!preserve_acls || S_ISLNK(file->mode))
 +		return;
-+	fname = f_name(file);
++	fname = f_name(file, NULL);
 +	for (type = &types[0];
 +	     type < &types[0] + sizeof types / sizeof types[0]
 +		&& (*type == SMB_ACL_TYPE_ACCESS || S_ISDIR(file->mode));
 +	     type++) {
 +		file_acl_index_list *fileaclidx_list =
 +			file_acl_index_lists(*type);
@@ -879,13 +878,13 @@
 +int dup_acl(const char *orig, const char *bak, mode_t mode)
 +{
 +	SMB_ACL_TYPE_T *type,
 +		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
 +	int ret = 0;
 +	if (!preserve_acls)
-+		return 0;
++		return 1;
 +	for (type = &types[0];
 +	     type < &types[0] + sizeof types / sizeof types[0]
 +		 && (*type == SMB_ACL_TYPE_ACCESS || S_ISDIR(mode));
 +	     type++) {
 +		SMB_ACL_T sacl_orig, sacl_bak;
 +		rsync_acl racl_orig, racl_bak;
@@ -913,18 +912,18 @@
 +			if (rsync_acls_equal(&racl_orig, &racl_bak))
 +				goto out_with_all;
 +		} else {
 +			; /* presume they're unequal */
 +		}
 +		if (*type == SMB_ACL_TYPE_DEFAULT && !racl_orig.count) {
-+			if (-1 == sys_acl_delete_def_file(bak)) {
++			if (sys_acl_delete_def_file(bak) < 0) {
 +				rprintf(FERROR, "dup_acl: sys_acl_delete_def_file(%s): %s\n",
 +					bak, strerror(errno));
 +				ret = -1;
 +			}
-+		} else if (-1 == sys_acl_set_file(bak, *type, sacl_bak)) {
++		} else if (sys_acl_set_file(bak, *type, sacl_bak) < 0) {
 +			rprintf(FERROR, "dup_acl: sys_acl_set_file(%s, %s): %s\n",
 +				bak, str_acl_type(*type), strerror(errno));
 +			ret = -1;
 +		}
 +		out_with_all:
 +			if (sacl_bak)
@@ -938,13 +937,13 @@
 +			if (sacl_orig)
 +				sys_acl_free_acl(sacl_orig);
 +	}
 +	return ret;
 +}
 +
-+/* Stuff for redirecting calls to set_acl() from set_perms()
++/* Stuff for redirecting calls to set_acl() from set_file_attrs()
 + * for keep_backup(). */
 +static const struct file_struct *backup_orig_file = NULL;
 +static const char null_string[] = "";
 +static const char *backup_orig_fname = null_string;
 +static const char *backup_dest_fname = null_string;
 +static SMB_ACL_T _backup_sacl[] = { NULL, NULL };
@@ -983,26 +982,25 @@
 +		SMB_ACL_T *sacl;
 +		int ret = 0;
 +		for (type = &types[0], sacl = &_backup_sacl[0];
 +		     type < &types[0] + sizeof types / sizeof types[0];
 +		     type++) {
 +			if (*sacl) {
-+				if (-1 == sys_acl_set_file(backup_dest_fname,
-+							   *type, *sacl))
-+				{
++				if (sys_acl_set_file(backup_dest_fname,
++						     *type, *sacl) < 0) {
 +					rprintf(FERROR, "push_keep_backup_acl: sys_acl_get_file(%s, %s): %s\n",
 +						backup_dest_fname,
 +						str_acl_type(*type),
 +						strerror(errno));
 +					ret = -1;
 +				}
 +			}
 +		}
 +		return ret;
 +	}
-+	return 0;
++	return 1;
 +}
 +
 +void cleanup_keep_backup_acl()
 +{
 +	if (preserve_acls) {
 +		SMB_ACL_TYPE_T *type,
@@ -1022,17 +1020,17 @@
 +}
 +
 +/* set ACL on rsync-ed or keep_backup-ed file */
 +
 +int set_acl(const char *fname, const struct file_struct *file)
 +{
-+	int updated = 0;
++	int unchanged = 1;
 +	SMB_ACL_TYPE_T *type,
 +		types[] = {SMB_ACL_TYPE_ACCESS, SMB_ACL_TYPE_DEFAULT};
 +	if (dry_run || !preserve_acls || S_ISLNK(file->mode))
-+		return 0;
++		return 1;
 +	if (file == backup_orig_file) {
 +		if (!strcmp(fname, backup_dest_fname))
 +			return set_keep_backup_acl();
 +	}
 +	for (type = &types[0];
 +	     type < &types[0] + sizeof  types / sizeof types[0]
@@ -1046,50 +1044,50 @@
 +		racl_new = &(rsync_acl_lists(*type)->racls[aclidx]);
 +		sacl_new = &(smb_acl_lists(*type)->sacls[aclidx]);
 +		sacl_orig = sys_acl_get_file(fname, *type);
 +		if (!sacl_orig) {
 +			rprintf(FERROR, "set_acl: sys_acl_get_file(%s, %s): %s\n",
 +				fname, str_acl_type(*type), strerror(errno));
-+			updated = -1;
++			unchanged = -1;
 +			continue;
 +		}
 +		ok = unpack_smb_acl(&racl_orig, sacl_orig);
 +		sys_acl_free_acl(sacl_orig);
 +		if (!ok) {
-+			updated = -1;
++			unchanged = -1;
 +			continue;
 +		}
 +		ok = rsync_acls_equal(&racl_orig, racl_new);
 +		rsync_acl_free(&racl_orig);
 +		if (ok)
 +			continue;
 +		if (*type == SMB_ACL_TYPE_DEFAULT && !racl_new->count) {
-+			if (-1 == sys_acl_delete_def_file(fname)) {
++			if (sys_acl_delete_def_file(fname) < 0) {
 +				rprintf(FERROR, "set_acl: sys_acl_delete_def_file(%s): %s\n",
 +					fname, strerror(errno));
-+				updated = -1;
++				unchanged = -1;
 +				continue;
 +			}
 +		} else {
 +			if (!*sacl_new)
 +				if (!pack_smb_acl(sacl_new, racl_new)) {
-+					updated = -1;
++					unchanged = -1;
 +					continue;
 +				}
-+			if (-1 == sys_acl_set_file(fname, *type, *sacl_new)) {
++			if (sys_acl_set_file(fname, *type, *sacl_new) < 0) {
 +				rprintf(FERROR, "set_acl: sys_acl_set_file(%s, %s): %s\n",
 +					fname, str_acl_type(*type),
 +					strerror(errno));
-+				updated = -1;
++				unchanged = -1;
 +				continue;
 +			}
 +		}
-+		if (!updated)
-+			updated = 1;
++		if (unchanged == 1)
++			unchanged = 0;
 +	}
-+	return updated;
++	return unchanged;
 +}
 +
 +/* Enumeration functions for uid mapping: */
 +
 +/* Context -- one and only one.  Should be cycled through once on uid
 + * mapping and once on gid mapping. */
@@ -1161,67 +1159,144 @@
 +
 +void acl_gid_map(id_t gid)
 +{
 +	set_acl_id(gid);
 +}
 +
++#define PERMS_SPLICE(perms,newbits,where) (((perms) & ~(7 << (where))) | ((newbits) << (where)))
++
++int default_perms_for_dir(const char *dir)
++{
++	rsync_acl racl;
++	SMB_ACL_T sacl;
++	BOOL ok, saw_mask = False;
++	size_t i;
++	int perms;
++
++	if (dir == NULL)
++		dir = ".";
++	perms = ACCESSPERMS & ~orig_umask;
++	/* Read the directory's default ACL.  If it has none, this will successfully return an empty ACL. */
++	sacl = sys_acl_get_file(dir, SMB_ACL_TYPE_DEFAULT);
++	if (sacl == NULL) {
++		/* Couldn't get an ACL.  Darn. */
++		switch (errno) {
++		case ENOTSUP:
++			/* ACLs are disabled.  We could yell at the user to turn them on, but... */
++			break;
++		case ENOENT:
++			if (dry_run) {
++				/* We're doing a dry run, so the containing directory
++				 * wasn't actually created.  Don't worry about it. */
++				break;
++			}
++			/* Otherwise fall through. */
++		default:
++			rprintf(FERROR, "default_perms_for_dir: sys_acl_get_file(%s, %s): %s, falling back on umask\n",
++				dir, str_acl_type(SMB_ACL_TYPE_DEFAULT), strerror(errno));
++		}
++		return perms;
++	}
++
++	/* Convert it. */
++	ok = unpack_smb_acl(&racl, sacl);
++	sys_acl_free_acl(sacl);
++	if (!ok) {
++		rprintf(FERROR, "default_perms_for_dir: unpack_smb_acl failed, falling back on umask\n");
++		return perms;
++	}
++
++	/* Look at each default ACL entry and possibly modify three bits of `perms' accordingly.
++	 * If there's "no" default ACL, there will be zero entries and the umask-based perms is unchanged. */
++	for (i = 0; i < racl.count; i++) {
++		switch (racl.races[i].tag_type) {
++		case SMB_ACL_USER_OBJ:
++			perms = PERMS_SPLICE(perms, racl.races[i].access, 6);
++			break;
++		case SMB_ACL_GROUP_OBJ:
++			if (!saw_mask)
++				perms = PERMS_SPLICE(perms, racl.races[i].access, 3);
++			break;
++		case SMB_ACL_MASK:
++			saw_mask = True;
++			perms = PERMS_SPLICE(perms, racl.races[i].access, 3);
++			break;
++		case SMB_ACL_OTHER:
++			perms = PERMS_SPLICE(perms, racl.races[i].access, 0);
++			break;
++		default:
++			break;
++		}
++	}
++	rsync_acl_free(&racl);
++	if (verbose > 2)
++		rprintf(FINFO, "got ACL-based default perms %o for directory %s\n", perms, dir);
++	return perms;
++}
++
 +#endif /* SUPPORT_ACLS */
---- orig/backup.c	2005-06-10 17:57:18
-+++ backup.c	2004-10-06 00:13:09
-@@ -135,6 +135,7 @@ static int make_bak_dir(char *fullpath)
+--- old/backup.c
++++ new/backup.c
+@@ -132,6 +132,9 @@ static int make_bak_dir(char *fullpath)
  			} else {
  				do_lchown(fullpath, st.st_uid, st.st_gid);
  				do_chmod(fullpath, st.st_mode);
-+				(void)DUP_ACL(end, fullpath, st.st_mode);
++#ifdef SUPPORT_ACLS
++				dup_acl(end, fullpath, st.st_mode);
++#endif
  			}
  		}
  		*p = '/';
-@@ -187,6 +188,8 @@ static int keep_backup(char *fname)
+@@ -185,6 +188,10 @@ static int keep_backup(char *fname)
  	if (!(buf = get_backup_name(fname)))
  		return 0;
  
-+	PUSH_KEEP_BACKUP_ACL(file, fname, buf);
++#ifdef SUPPORT_ACLS
++	push_keep_backup_acl(file, fname, buf);
++#endif
 +
  	/* Check to see if this is a device file, or link */
- 	if (IS_DEVICE(file->mode) && am_root && preserve_devices) {
- 		do_unlink(buf);
-@@ -261,6 +264,7 @@ static int keep_backup(char *fname)
+ 	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
+ 	 || (preserve_specials && IS_SPECIAL(file->mode))) {
+@@ -260,6 +267,9 @@ static int keep_backup(char *fname)
  		}
  	}
- 	set_perms(buf, file, NULL, 0);
-+	CLEANUP_KEEP_BACKUP_ACL();
+ 	set_file_attrs(buf, file, NULL, 0);
++#ifdef SUPPORT_ACLS
++	cleanup_keep_backup_acl();
++#endif
  	free(file);
  
  	if (verbose > 1) {
---- orig/configure.in	2005-07-28 18:48:38
-+++ configure.in	2004-08-19 19:53:27
-@@ -489,6 +489,11 @@ if test x"$ac_cv_func_strcasecmp" = x"no
+--- old/configure.in
++++ new/configure.in
+@@ -482,6 +482,11 @@ if test x"$ac_cv_func_strcasecmp" = x"no
      AC_CHECK_LIB(resolv, strcasecmp)
  fi
  
 +AC_CHECK_FUNCS(aclsort)
 +if test x"$ac_cv_func_aclsort" = x"no"; then
 +    AC_CHECK_LIB(sec, aclsort)
 +fi
 +
  dnl At the moment we don't test for a broken memcmp(), because all we
  dnl need to do is test for equality, not comparison, and it seems that
  dnl every platform has a memcmp that can do at least that.
-@@ -745,6 +750,77 @@ AC_SUBST(OBJ_RESTORE)
+@@ -738,6 +743,77 @@ AC_SUBST(OBJ_RESTORE)
  AC_SUBST(CC_SHOBJ_FLAG)
  AC_SUBST(BUILD_POPT)
  
 +AC_CHECK_HEADERS(sys/acl.h)
 +AC_CHECK_FUNCS(_acl __acl _facl __facl)
 +#################################################
 +# check for ACL support
 +
 +AC_MSG_CHECKING(whether to support ACLs)
-+AC_ARG_WITH(acl-support,
-+[  --with-acl-support      Include ACL support (default=no)],
-+[ case "$withval" in
++AC_ARG_ENABLE(acl-support,
++AC_HELP_STRING([--enable-acl-support], [Include ACL support (default=no)]),
++[ case "$enableval" in
 +  yes)
 +
 +		case "$host_os" in
 +		*sysv5*)
 +			AC_MSG_RESULT(Using UnixWare ACLs)
 +			AC_DEFINE(HAVE_UNIXWARE_ACLS, 1, [true if you have UnixWare ACLs])
@@ -1281,67 +1356,110 @@
 +  AC_MSG_RESULT(no)
 +)
 +
  AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
  AC_OUTPUT
  
---- orig/flist.c	2005-07-28 18:48:38
-+++ flist.c	2005-03-16 02:24:11
-@@ -974,6 +974,8 @@ static struct file_struct *send_file_nam
- 	file = make_file(fname, flist, f == -2 ? SERVER_FILTERS : ALL_FILTERS);
+--- old/flist.c
++++ new/flist.c
+@@ -966,6 +966,10 @@ static struct file_struct *send_file_nam
+ 			 f == -2 ? SERVER_FILTERS : ALL_FILTERS);
  	if (!file)
  		return NULL;
-+	if (!MAKE_ACL(file, fname))
++#ifdef SUPPORT_ACLS
++	if (make_acl(file, fname) < 0)
 +		return NULL;
++#endif
  
- 	maybe_emit_filelist_progress(flist->count + flist_count_offset);
- 
-@@ -982,6 +984,10 @@ static struct file_struct *send_file_nam
+ 	if (chmod_modes && !S_ISLNK(file->mode))
+ 		file->mode = tweak_mode(file->mode, chmod_modes);
+@@ -977,6 +981,12 @@ static struct file_struct *send_file_nam
  	if (file->basename[0]) {
  		flist->files[flist->count++] = file;
- 		send_file_entry(file, f, base_flags);
-+		SEND_ACL(file, f);
+ 		send_file_entry(file, f);
++#ifdef SUPPORT_ACLS
++		send_acl(file, f);
 +	} else {
 +		/* Cleanup unsent ACL(s). */
-+		SEND_ACL(file, -1);
++		send_acl(file, -1);
++#endif
  	}
  	return file;
  }
-@@ -1318,6 +1324,8 @@ struct file_list *recv_file_list(int f)
+@@ -1365,6 +1375,10 @@ struct file_list *recv_file_list(int f)
  			flags |= read_byte(f) << 8;
  		file = receive_file_entry(flist, flags, f);
  
-+		RECEIVE_ACL(file, f);
++#ifdef SUPPORT_ACLS
++		receive_acl(file, f);
++#endif
 +
- 		if (S_ISREG(file->mode))
+ 		if (S_ISREG(file->mode) || S_ISLNK(file->mode))
  			stats.total_size += file->length;
  
-@@ -1340,6 +1348,8 @@ struct file_list *recv_file_list(int f)
+@@ -1387,6 +1401,10 @@ struct file_list *recv_file_list(int f)
  
  	clean_flist(flist, relative_paths, 1);
  
-+	SORT_FILE_ACL_INDEX_LISTS();
++#ifdef SUPPORT_ACLS
++	sort_file_acl_index_lists();
++#endif
 +
  	if (f >= 0) {
- 		/* Now send the uid/gid list. This was introduced in
- 		 * protocol version 15 */
---- orig/generator.c	2005-07-28 19:00:14
-+++ generator.c	2005-05-12 23:34:00
-@@ -717,6 +717,10 @@ static void recv_generator(char *fname, 
- 		if (set_perms(fname, file, statret ? NULL : &st, 0)
- 		    && verbose && code && f_out != -1)
- 			rprintf(code, "%s/\n", safe_fname(fname));
+ 		recv_uid_list(f, flist);
+ 
+--- old/generator.c
++++ new/generator.c
+@@ -85,6 +85,7 @@ extern long block_size; /* "long" becaus
+ extern int max_delete;
+ extern int force_delete;
+ extern int one_file_system;
++extern mode_t orig_umask;
+ extern struct stats stats;
+ extern dev_t filesystem_dev;
+ extern char *backup_dir;
+@@ -753,6 +754,7 @@ static int try_dests_non(struct file_str
+ }
+ 
+ static int phase = 0;
++static int dflt_perms;
+ 
+ /* Acts on the_file_list->file's ndx'th item, whose name is fname.  If a dir,
+  * make sure it exists, and has the right permissions/timestamp info.  For
+@@ -844,6 +846,10 @@ static void recv_generator(char *fname, 
+ 			}
+ 			if (fuzzy_basis)
+ 				need_fuzzy_dirlist = 1;
 +#ifdef SUPPORT_ACLS
-+		if (f_out == -1)
-+			SET_ACL(fname, file);
++			if (!preserve_perms)
++				dflt_perms = default_perms_for_dir(dn);
 +#endif
- 		if (delete_during && f_out != -1 && !phase && dry_run < 2
- 		    && (file->flags & FLAG_DEL_HERE))
- 			delete_in_dir(the_file_list, fname, file);
---- orig/lib/sysacls.c	2005-05-16 23:27:53
-+++ lib/sysacls.c	2005-05-16 23:27:53
+ 		}
+ 		parent_dirname = dn;
+ 
+@@ -871,7 +877,8 @@ static void recv_generator(char *fname, 
+ 	if (!preserve_perms) {
+ 		int exists = statret == 0
+ 			  && S_ISDIR(st.st_mode) == S_ISDIR(file->mode);
+-		file->mode = dest_mode(file->mode, st.st_mode, exists);
++		file->mode = dest_mode(file->mode, st.st_mode, dflt_perms,
++				       exists);
+ 	}
+ 
+ 	if (S_ISDIR(file->mode)) {
+@@ -1343,6 +1350,8 @@ void generate_files(int f_out, struct fi
+ 	 * notice that and let us know via the redo pipe (or its closing). */
+ 	ignore_timeout = 1;
+ 
++	dflt_perms = (ACCESSPERMS & ~orig_umask);
++
+ 	for (i = 0; i < flist->count; i++) {
+ 		struct file_struct *file = flist->files[i];
+ 
+--- old/lib/sysacls.c
++++ new/lib/sysacls.c
 @@ -0,0 +1,3242 @@
 +/* 
 +   Unix SMB/CIFS implementation.
 +   Samba system utilities for ACL support.
 +   Copyright (C) Jeremy Allison 2000.
 +   
@@ -4579,14 +4697,14 @@
 +	if (err == ENOTSUP) {
 +		return 1;
 +	}
 +#endif
 +	return 0;
 +}
---- orig/lib/sysacls.h	2005-05-16 23:25:51
-+++ lib/sysacls.h	2005-05-16 23:25:51
+--- old/lib/sysacls.h
++++ new/lib/sysacls.h
 @@ -0,0 +1,28 @@
 +#define SMB_MALLOC(cnt) new_array(char, cnt)
 +#define SMB_MALLOC_P(obj) new_array(obj, 1)
 +#define SMB_MALLOC_ARRAY(obj, cnt) new_array(obj, cnt)
 +#define SMB_REALLOC(mem, cnt) realloc_array(mem, char, cnt)
 +#define slprintf snprintf
@@ -4610,202 +4728,265 @@
 +int sys_acl_set_file(const char *name, SMB_ACL_TYPE_T acltype, SMB_ACL_T theacl);
 +int sys_acl_set_fd(int fd, SMB_ACL_T theacl);
 +int sys_acl_delete_def_file(const char *name);
 +int sys_acl_free_text(char *text);
 +int sys_acl_free_acl(SMB_ACL_T the_acl);
 +int sys_acl_free_qualifier(void *qual, SMB_ACL_TAG_T tagtype);
---- orig/mkproto.awk	2005-02-18 20:16:59
-+++ mkproto.awk	2005-02-18 20:18:17
+--- old/mkproto.awk
++++ new/mkproto.awk
 @@ -58,7 +58,7 @@ BEGIN {
    next;
  }
  
--!/^OFF_T|^size_t|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^uchar|^short|^struct|^BOOL|^void|^time|^const/ {
-+!/^OFF_T|^size_t|^off_t|^pid_t|^id_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^uchar|^short|^struct|^BOOL|^void|^time|^const/ {
+-!/^OFF_T|^size_t|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^uchar|^short|^struct|^BOOL|^void|^time|^const|^RETSIGTYPE/ {
++!/^OFF_T|^size_t|^off_t|^pid_t|^id_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^uchar|^short|^struct|^BOOL|^void|^time|^const|^RETSIGTYPE/ {
    next;
  }
  
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-05-12 23:34:38
-@@ -43,6 +43,7 @@ int keep_dirlinks = 0;
+--- old/options.c
++++ new/options.c
+@@ -45,6 +45,7 @@ int copy_dirlinks = 0;
  int copy_links = 0;
  int preserve_links = 0;
  int preserve_hard_links = 0;
 +int preserve_acls = 0;
  int preserve_perms = 0;
+ int preserve_executability = 0;
  int preserve_devices = 0;
- int preserve_uid = 0;
-@@ -180,6 +181,7 @@ static void print_rsync_version(enum log
+@@ -194,6 +195,7 @@ static void print_rsync_version(enum log
  	char const *got_socketpair = "no ";
  	char const *have_inplace = "no ";
  	char const *hardlinks = "no ";
 +	char const *acls = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
  	STRUCT_STAT *dumstat;
-@@ -196,6 +198,10 @@ static void print_rsync_version(enum log
+@@ -210,6 +212,10 @@ static void print_rsync_version(enum log
  	hardlinks = "";
  #endif
  
 +#ifdef SUPPORT_ACLS
 +	acls = "";
 +#endif
 +
  #ifdef SUPPORT_LINKS
  	links = "";
  #endif
-@@ -210,9 +216,9 @@ static void print_rsync_version(enum log
- 		"Copyright (C) 1996-2005 by Andrew Tridgell and others\n");
+@@ -223,9 +229,9 @@ static void print_rsync_version(enum log
+ 	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
  	rprintf(f, "<http://rsync.samba.org/>\n");
  	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
--		"%shard links, %ssymlinks, batchfiles, \n",
-+		"%shard links, %sACLs, %ssymlinks, batchfiles, \n",
+-		"%shard links, %ssymlinks, batchfiles,\n",
++		"%shard links, %sACLs, %ssymlinks, batchfiles,\n",
  		(int) (sizeof (OFF_T) * 8),
 -		got_socketpair, hardlinks, links);
 +		got_socketpair, hardlinks, acls, links);
  
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
-@@ -282,6 +288,7 @@ void usage(enum logcode F)
+@@ -295,6 +301,9 @@ void usage(enum logcode F)
    rprintf(F," -H, --hard-links            preserve hard links\n");
-   rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
    rprintf(F," -p, --perms                 preserve permissions\n");
+   rprintf(F," -E, --executability         preserve the file's executability\n");
++#ifdef SUPPORT_ACLS
 +  rprintf(F," -A, --acls                  preserve ACLs (implies --perms)\n");
-   rprintf(F," -o, --owner                 preserve owner (root only)\n");
++#endif
+   rprintf(F,"     --chmod=CHMOD           change destination permissions\n");
+   rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
    rprintf(F," -g, --group                 preserve group\n");
-   rprintf(F," -D, --devices               preserve devices (root only)\n");
-@@ -408,6 +415,7 @@ static struct poptOption long_options[] 
-   {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
-   {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
-   {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
-+  {"acls",            'A', POPT_ARG_NONE,   0,              'A', 0, 0 },
-   {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
-   {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
-   {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
-@@ -876,6 +884,24 @@ int parse_arguments(int *argc, const cha
- 			basis_dir[basis_dir_cnt++] = (char *)arg;
- 			break;
+@@ -410,6 +419,9 @@ static struct poptOption long_options[] 
+   {"no-perms",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
+   {"no-p",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
+   {"executability",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },
++  {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
++  {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
++  {"no-A",             0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
+   {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
+   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+   {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+@@ -1068,6 +1080,23 @@ int parse_arguments(int *argc, const cha
+ 			usage(FINFO);
+ 			exit_cleanup(0);
  
 +		case 'A':
 +#ifdef SUPPORT_ACLS
-+			preserve_acls = 1;
-+			preserve_perms = 1;
++			preserve_acls = preserve_perms = 1;
++			break;
 +#else
 +			/* FIXME: this should probably be ignored with a
 + 			 * warning and then countermeasures taken to
 + 			 * restrict group and other access in the presence
 + 			 * of any more restrictive ACLs, but this is safe
 +			 * for now */
 +			snprintf(err_buf,sizeof(err_buf),
 +                                 "ACLs are not supported on this %s\n",
 +				 am_server ? "server" : "client");
 +			return 0;
-+#endif /* SUPPORT_ACLS */
-+			break;
++#endif
 +
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1282,6 +1308,8 @@ void server_options(char **args,int *arg
+@@ -1511,6 +1540,10 @@ void server_options(char **args,int *arg
  
  	if (preserve_hard_links)
  		argstr[x++] = 'H';
++#ifdef SUPPORT_ACLS
 +	if (preserve_acls)
 +		argstr[x++] = 'A';
++#endif
  	if (preserve_uid)
  		argstr[x++] = 'o';
  	if (preserve_gid)
---- orig/rsync.c	2005-07-28 18:48:38
-+++ rsync.c	2004-07-03 20:11:58
-@@ -137,6 +137,14 @@ int set_perms(char *fname,struct file_st
+--- old/receiver.c
++++ new/receiver.c
+@@ -46,6 +46,7 @@ extern int keep_partial;
+ extern int checksum_seed;
+ extern int inplace;
+ extern int delay_updates;
++extern mode_t orig_umask;
+ extern struct stats stats;
+ extern char *log_format;
+ extern char *tmpdir;
+@@ -344,6 +345,10 @@ int recv_files(int f_in, struct file_lis
+ 	int itemizing = am_daemon ? daemon_log_format_has_i
+ 		      : !am_server && log_format_has_i;
+ 	int max_phase = protocol_version >= 29 ? 2 : 1;
++	int dflt_perms = (ACCESSPERMS & ~orig_umask);
++#ifdef SUPPORT_ACLS
++	char *parent_dirname = "";
++#endif
+ 	int i, recv_ok;
+ 
+ 	if (verbose > 2)
+@@ -541,7 +546,16 @@ int recv_files(int f_in, struct file_lis
+ 		 * mode based on the local permissions and some heuristics. */
+ 		if (!preserve_perms) {
+ 			int exists = fd1 != -1;
+-			file->mode = dest_mode(file->mode, st.st_mode, exists);
++#ifdef SUPPORT_ACLS
++			char *dn = file->dirname ? file->dirname : ".";
++			if (parent_dirname != dn
++			 && strcmp(parent_dirname, dn) != 0) {
++				dflt_perms = default_perms_for_dir(dn);
++				parent_dirname = dn;
++			}
++#endif
++			file->mode = dest_mode(file->mode, st.st_mode,
++					       dflt_perms, exists);
+ 		}
+ 
+ 		/* We now check to see if we are writing file "inplace" */
+--- old/rsync.c
++++ new/rsync.c
+@@ -101,7 +101,8 @@ void free_sums(struct sum_struct *s)
+ 
+ /* This is only called when we aren't preserving permissions.  Figure out what
+  * the permissions should be and return them merged back into the mode. */
+-mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int exists)
++mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int dflt_perms,
++		 int exists)
+ {
+ 	/* If the file already exists, we'll return the local permissions,
+ 	 * possibly tweaked by the --executability option. */
+@@ -116,7 +117,7 @@ mode_t dest_mode(mode_t flist_mode, mode
+ 				cur_mode |= (cur_mode & 0444) >> 2;
+ 		}
+ 	} else
+-		cur_mode = flist_mode & ACCESSPERMS & ~orig_umask;
++		cur_mode = flist_mode & ACCESSPERMS & dflt_perms;
+ 	if (daemon_chmod_modes && !S_ISLNK(flist_mode))
+ 		cur_mode = tweak_mode(cur_mode, daemon_chmod_modes);
+ 	return (flist_mode & ~CHMOD_BITS) | (cur_mode & CHMOD_BITS);
+@@ -217,6 +218,13 @@ int set_file_attrs(char *fname, struct f
  	}
  #endif
  
-+	/* If this is a directory, SET_ACL() will be called on the cleanup
-+	 * receive_generator() pass (if we called it here, we might clobber
-+	 * writability on the directory). Everything else is OK to do now. */
-+	if (!S_ISDIR(st->st_mode)) {
-+		if (SET_ACL(fname, file) == 0)
-+			updated = 1;
-+	}
++#ifdef SUPPORT_ACLS
++	/* It's fine to call set_acl() now; the generator will enable
++	 * writability on the directory using chmod if necessary. */
++	if (set_acl(fname, file) == 0)
++		updated = 1;
++#endif
 +
- 	if (verbose > 1 && flags & PERMS_REPORT) {
+ 	if (verbose > 1 && flags & ATTRS_REPORT) {
  		enum logcode code = daemon_log_format_has_i || dry_run
  				  ? FCLIENT : FINFO;
---- orig/rsync.h	2005-05-03 17:00:47
-+++ rsync.h	2005-05-12 23:32:56
-@@ -638,6 +638,44 @@ struct stats {
- #include "lib/permstring.h"
- #include "lib/addrinfo.h"
+--- old/rsync.h
++++ new/rsync.h
+@@ -658,6 +658,20 @@ struct chmod_mode_struct;
+ 
+ #define UNUSED(x) x __attribute__((__unused__))
  
 +#if HAVE_POSIX_ACLS|HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|\
 +    HAVE_HPUX_ACLS|HAVE_IRIX_ACLS|HAVE_AIX_ACLS|HAVE_TRU64_ACLS
 +#define SUPPORT_ACLS 1
 +#endif
 +
 +#if HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|HAVE_HPUX_ACLS
 +#define ACLS_NEED_MASK 1
 +#endif
 +
-+#ifdef SUPPORT_ACLS
-+#ifdef HAVE_SYS_ACL_H
++#if defined SUPPORT_ACLS && defined HAVE_SYS_ACL_H
 +#include <sys/acl.h>
 +#endif
-+#define MAKE_ACL(file, fname)			make_acl(file, fname)
-+#define SEND_ACL(file, f)			send_acl(file, f)
-+#define RECEIVE_ACL(file, f)			receive_acl(file, f)
-+#define SORT_FILE_ACL_INDEX_LISTS()		sort_file_acl_index_lists()
-+#define SET_ACL(fname, file)			set_acl(fname, file)
-+#define NEXT_ACL_UID()				next_acl_uid()
-+#define ACL_UID_MAP(uid)			acl_uid_map(uid)
-+#define PUSH_KEEP_BACKUP_ACL(file, orig, dest) \
-+					push_keep_backup_acl(file, orig, dest)
-+#define CLEANUP_KEEP_BACKUP_ACL() 		cleanup_keep_backup_acl()
-+#define DUP_ACL(orig, dest, mode)		dup_acl(orig, dest, mode)
-+#else /* SUPPORT_ACLS */
-+#define MAKE_ACL(file, fname)			1 /* checked return value */
-+#define SEND_ACL(file, f)
-+#define RECEIVE_ACL(file, f)
-+#define SORT_FILE_ACL_INDEX_LISTS()
-+#define SET_ACL(fname, file)			0 /* checked return value */
-+#define NEXT_ACL_UID()	
-+#define ACL_UID_MAP(uid)
-+#define PUSH_KEEP_BACKUP_ACL(file, orig, dest)
-+#define CLEANUP_KEEP_BACKUP_ACL()
-+#define DUP_ACL(src, orig, mode)		0 /* checked return value */
-+#endif /* SUPPORT_ACLS */
 +#include "smb_acls.h"
 +
  #include "proto.h"
  
  /* We have replacement versions of these if they're missing. */
---- orig/rsync.yo	2005-07-28 19:26:48
-+++ rsync.yo	2004-07-03 20:11:58
-@@ -315,6 +315,7 @@ to the detailed description below for a 
+--- old/rsync.yo
++++ new/rsync.yo
+@@ -321,6 +321,7 @@ to the detailed description below for a 
   -H, --hard-links            preserve hard links
-  -K, --keep-dirlinks         treat symlinked dir on receiver as dir
   -p, --perms                 preserve permissions
-+ -A, --acls                  preserve ACLs (implies -p) [local option]
-  -o, --owner                 preserve owner (root only)
+  -E, --executability         preserve executability
++ -A, --acls                  preserve ACLs (implies -p) [non-standard]
+      --chmod=CHMOD           change destination permissions
+  -o, --owner                 preserve owner (super-user only)
   -g, --group                 preserve group
-  -D, --devices               preserve devices (root only)
-@@ -627,6 +628,11 @@ based on the source file's permissions, 
- umask setting
- (which is the same behavior as other file-copy utilities, such as cp).
- 
-+dit(bf(-A, --acls)) This option causes rsync to update the remote
-+ACLs to be the same as the local ACLs.  This will work only if the
-+remote machine's rsync supports this option also. This is a non-standard
-+option.
-+
- dit(bf(-o, --owner)) This option causes rsync to set the owner of the
- destination file to be the same as the source file.  On most systems,
- only the super-user can set file ownership.  By default, the preservation
---- orig/smb_acls.h	2004-06-30 00:04:07
-+++ smb_acls.h	2004-06-30 00:04:07
+@@ -742,7 +743,9 @@ quote(itemize(
+   permissions, though the bf(--executability) option might change just
+   the execute permission for the file.
+   it() New files get their "normal" permission bits set to the source
+-  file's permissions masked with the receiving end's umask setting, and
++  file's permissions masked with the receiving directory's default
++  permissions (either the receiving process's umask, or the permissions
++  specified via the destination directory's default ACL), and
+   their special permission bits disabled except in the case where a new
+   directory inherits a setgid bit from its parent directory.
+ ))
+@@ -773,9 +776,11 @@ The preservation of the destination's se
+ directories when bf(--perms) is off was added in rsync 2.6.7.  Older rsync
+ versions erroneously preserved the three special permission bits for
+ newly-created files when bf(--perms) was off, while overriding the
+-destination's setgid bit setting on a newly-created directory.  (Keep in
+-mind that it is the version of the receiving rsync that affects this
+-behavior.)
++destination's setgid bit setting on a newly-created directory.  Default ACL
++observance was added to the ACL patch for rsync 2.6.7, so older (or
++non-ACL-enabled) rsyncs use the umask even if default ACLs are present.
++(Keep in mind that it is the version of the receiving rsync that affects
++these behaviors.)
+ 
+ dit(bf(-E, --executability)) This option causes rsync to preserve the
+ executability (or non-executability) of regular files when bf(--perms) is
+@@ -793,6 +798,10 @@ quote(itemize(
+ 
+ If bf(--perms) is enabled, this option is ignored.
+ 
++dit(bf(-A, --acls)) This option causes rsync to update the destination
++ACLs to be the same as the source ACLs.  This nonstandard option only
++works if the remote rsync also supports it.  bf(--acls) implies bf(--perms).
++
+ dit(bf(--chmod)) This option tells rsync to apply one or more
+ comma-separated "chmod" strings to the permission of the files in the
+ transfer.  The resulting value is treated as though it was the permissions
+--- old/smb_acls.h
++++ new/smb_acls.h
 @@ -0,0 +1,277 @@
 +/* 
 +   Unix SMB/Netbios implementation.
 +   Version 2.2.x
 +   Portable SMB ACL interface
 +   Copyright (C) Jeremy Allison 2000
@@ -4825,13 +5006,13 @@
 +   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 +*/
 +
 +#ifndef _SMB_ACLS_H
 +#define _SMB_ACLS_H
 +
-+#if defined(HAVE_POSIX_ACLS)
++#if defined HAVE_POSIX_ACLS
 +
 +/* This is an identity mapping (just remove the SMB_). */
 +
 +#define SMB_ACL_TAG_T		acl_tag_t
 +#define SMB_ACL_TYPE_T		acl_type_t
 +#define SMB_ACL_PERMSET_T	acl_permset_t
@@ -4855,13 +5036,13 @@
 +#define SMB_ACL_FIRST_ENTRY	ACL_FIRST_ENTRY
 +#define SMB_ACL_NEXT_ENTRY	ACL_NEXT_ENTRY
 +
 +#define SMB_ACL_TYPE_ACCESS	ACL_TYPE_ACCESS
 +#define SMB_ACL_TYPE_DEFAULT	ACL_TYPE_DEFAULT
 +
-+#elif defined(HAVE_TRU64_ACLS)
++#elif defined HAVE_TRU64_ACLS
 +
 +/* This is for DEC/Compaq Tru64 UNIX */
 +
 +#define SMB_ACL_TAG_T		acl_tag_t
 +#define SMB_ACL_TYPE_T		acl_type_t
 +#define SMB_ACL_PERMSET_T	acl_permset_t
@@ -4885,13 +5066,13 @@
 +#define SMB_ACL_FIRST_ENTRY	0
 +#define SMB_ACL_NEXT_ENTRY	1
 +
 +#define SMB_ACL_TYPE_ACCESS	ACL_TYPE_ACCESS
 +#define SMB_ACL_TYPE_DEFAULT	ACL_TYPE_DEFAULT
 +
-+#elif defined(HAVE_UNIXWARE_ACLS) || defined(HAVE_SOLARIS_ACLS)
++#elif defined HAVE_UNIXWARE_ACLS || defined HAVE_SOLARIS_ACLS
 +/*
 + * Donated by Michael Davidson <md@sco.COM> for UnixWare / OpenUNIX.
 + * Modified by Toomas Soome <tsoome@ut.ee> for Solaris.
 + */
 +
 +/* SVR4.2 ES/MP ACLs */
@@ -4923,13 +5104,13 @@
 +#define SMB_ACL_FIRST_ENTRY	0
 +#define SMB_ACL_NEXT_ENTRY	1
 +
 +#define SMB_ACL_TYPE_ACCESS	0
 +#define SMB_ACL_TYPE_DEFAULT	1
 +
-+#elif defined(HAVE_HPUX_ACLS)
++#elif defined HAVE_HPUX_ACLS
 +
 +/*
 + * Based on the Solaris & UnixWare code.
 + */
 +
 +#undef GROUP
@@ -4964,13 +5145,13 @@
 +#define SMB_ACL_FIRST_ENTRY	0
 +#define SMB_ACL_NEXT_ENTRY	1
 +
 +#define SMB_ACL_TYPE_ACCESS	0
 +#define SMB_ACL_TYPE_DEFAULT	1
 +
-+#elif defined(HAVE_IRIX_ACLS)
++#elif defined HAVE_IRIX_ACLS
 +
 +#define SMB_ACL_TAG_T		acl_tag_t
 +#define SMB_ACL_TYPE_T		acl_type_t
 +#define SMB_ACL_PERMSET_T	acl_permset_t
 +#define SMB_ACL_PERM_T		acl_perm_t
 +#define SMB_ACL_READ		ACL_READ
@@ -4996,13 +5177,13 @@
 +#define SMB_ACL_FIRST_ENTRY	0
 +#define SMB_ACL_NEXT_ENTRY	1
 +
 +#define SMB_ACL_TYPE_ACCESS	ACL_TYPE_ACCESS
 +#define SMB_ACL_TYPE_DEFAULT	ACL_TYPE_DEFAULT
 +
-+#elif defined(HAVE_AIX_ACLS)
++#elif defined HAVE_AIX_ACLS
 +
 +/* Donated by Medha Date, mdate@austin.ibm.com, for IBM */
 +
 +#include "/usr/include/acl.h"
 +
 +typedef uint *SMB_ACL_PERMSET_T;
@@ -5078,14 +5259,72 @@
 +
 +#define SMB_ACL_TYPE_ACCESS	0
 +#define SMB_ACL_TYPE_DEFAULT	1
 +
 +#endif /* No ACLs. */
 +#endif /* _SMB_ACLS_H */
---- orig/uidlist.c	2005-02-14 00:53:44
-+++ uidlist.c	2004-07-03 20:11:58
+--- old/testsuite/default-acls.test
++++ new/testsuite/default-acls.test
+@@ -0,0 +1,55 @@
++#! /bin/sh
++
++# This program is distributable under the terms of the GNU GPL see
++# COPYING).
++
++# Test that rsync obeys default ACLs. -- Matt McCutchen
++
++. $srcdir/testsuite/rsync.fns
++
++$RSYNC --version | grep ", ACLs" >/dev/null || test_skipped "Rsync is configured without ACL support"
++setfacl -dm u::rwx,g::---,o::--- "$scratchdir" || test_skipped "Your filesystem has ACLs disabled"
++
++# Call as: testit <dirname> <default-acl> <file-expected> <program-expected>
++testit() {
++    todir="$scratchdir/$1"
++    mkdir "$todir"
++    # FIXME This doesn't work on solaris...
++    setfacl -k "$todir"
++    [ "$2" ] && setfacl -dm "$2" "$todir"
++    # Make sure we obey ACLs when creating a directory to hold multiple transferred files,
++    # even though the directory itself is outside the transfer
++    $RSYNC -rvv "$scratchdir/dir" "$scratchdir/file" "$scratchdir/program" "$todir/to/"
++    check_perms "$todir/to" $4 "Target $1"
++    check_perms "$todir/to/dir" $4 "Target $1"
++    check_perms "$todir/to/file" $3 "Target $1"
++    check_perms "$todir/to/program" $4 "Target $1"
++    # Make sure get_local_name doesn't mess us up when transferring only one file
++    $RSYNC -rvv "$scratchdir/file" "$todir/to/anotherfile"
++    check_perms "$todir/to/anotherfile" $3 "Target $1"
++    # Make sure we obey default ACLs when not transferring a regular file
++    $RSYNC -rvv "$scratchdir/dir/" "$todir/to/anotherdir/"
++    check_perms "$todir/to/anotherdir" $4 "Target $1"
++}
++
++mkdir "$scratchdir/dir"
++echo "File!" >"$scratchdir/file"
++echo "#!/bin/sh" >"$scratchdir/program"
++chmod 777 "$scratchdir/dir"
++chmod 666 "$scratchdir/file"
++chmod 777 "$scratchdir/program"
++
++# Test some target directories
++umask 0077
++testit da777 u::rwx,g::rwx,o::rwx rw-rw-rw- rwxrwxrwx
++testit da775 u::rwx,g::rwx,o::r-x rw-rw-r-- rwxrwxr-x
++testit da750 u::rwx,g::r-x,o::--- rw-r----- rwxr-x---
++testit da770mask u::rwx,g::---,m::rwx,o::--- rw-rw---- rwxrwx---
++testit noda1 '' rw------- rwx------
++umask 0000
++testit noda2 '' rw-rw-rw- rwxrwxrwx
++umask 0022
++testit noda3 '' rw-r--r-- rwxr-xr-x
++
++# Hooray
++exit 0
+--- old/uidlist.c
++++ new/uidlist.c
 @@ -34,6 +34,7 @@
  extern int verbose;
  extern int preserve_uid;
  extern int preserve_gid;
 +extern int preserve_acls;
  extern int numeric_ids;
@@ -5115,22 +5354,22 @@
  
 -	if (preserve_uid && !numeric_ids) {
 +	if ((preserve_uid || preserve_acls) && !numeric_ids) {
  		/* read the uid list */
  		while ((id = read_int(f)) != 0) {
  			int len = read_byte(f);
-@@ -325,7 +326,7 @@ void recv_uid_list(int f, struct file_li
+@@ -324,7 +325,7 @@ void recv_uid_list(int f, struct file_li
+ 		}
  	}
  
- 
 -	if (preserve_gid && !numeric_ids) {
 +	if ((preserve_gid || preserve_acls) && !numeric_ids) {
  		/* read the gid list */
  		while ((id = read_int(f)) != 0) {
  			int len = read_byte(f);
-@@ -337,6 +338,18 @@ void recv_uid_list(int f, struct file_li
+@@ -336,6 +337,18 @@ void recv_uid_list(int f, struct file_li
  		}
  	}
  
 +#ifdef SUPPORT_ACLS
 +	if (preserve_acls && !numeric_ids) {
 +		id_t id;
@@ -5140,9 +5379,970 @@
 +			acl_uid_map(match_uid(id));
 +		while ((id = next_acl_gid(flist)) != 0)
 +			acl_gid_map(match_gid(id));
 +	}
 +#endif /* SUPPORT_ACLS */
 +
- 	/* now convert the uid/gid of all files in the list to the mapped
- 	 * uid/gid */
+ 	/* Now convert all the uids/gids from sender values to our values. */
  	if (am_root && preserve_uid && !numeric_ids) {
+ 		for (i = 0; i < flist->count; i++)
+--- old/proto.h
++++ new/proto.h
+@@ -1,6 +1,20 @@
+ /* This file is automatically generated with "make proto". DO NOT EDIT */
+ 
+ int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
++int make_acl(const struct file_struct *file, const char *fname);
++void send_acl(const struct file_struct *file, int f);
++void receive_acl(struct file_struct *file, int f);
++void sort_file_acl_index_lists();
++int dup_acl(const char *orig, const char *bak, mode_t mode);
++void push_keep_backup_acl(const struct file_struct *file,
++			  const char *orig, const char *dest);
++void cleanup_keep_backup_acl();
++int set_acl(const char *fname, const struct file_struct *file);
++id_t next_acl_uid();
++id_t next_acl_gid();
++void acl_uid_map(id_t uid);
++void acl_gid_map(id_t gid);
++int default_perms_for_dir(const char *dir);
+ void base64_encode(char *buf, int len, char *out, int pad);
+ char *auth_server(int f_in, int f_out, int module, char *host, char *addr,
+ 		  char *leader);
+@@ -224,7 +238,8 @@ void show_progress(OFF_T ofs, OFF_T size
+ int recv_files(int f_in, struct file_list *flist, char *local_name);
+ void setup_iconv();
+ void free_sums(struct sum_struct *s);
+-mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int exists);
++mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int dflt_perms,
++		 int exists);
+ int set_file_attrs(char *fname, struct file_struct *file, STRUCT_STAT *st,
+ 		   int flags);
+ RETSIGTYPE sig_int(UNUSED(int val));
+--- old/configure
++++ new/configure
+@@ -852,6 +852,7 @@ Optional Features:
+   --disable-largefile     omit support for large files
+   --disable-ipv6          don't even try to use IPv6
+   --disable-locale        turn off locale features
++  --enable-acl-support    Include ACL support (default=no)
+ 
+ Optional Packages:
+   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+@@ -10491,6 +10492,183 @@ fi
+ fi
+ 
+ 
++for ac_func in aclsort
++do
++as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
++echo "$as_me:$LINENO: checking for $ac_func" >&5
++echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
++if eval "test \"\${$as_ac_var+set}\" = set"; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
++   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
++#define $ac_func innocuous_$ac_func
++
++/* System header to define __stub macros and hopefully few prototypes,
++    which can conflict with char $ac_func (); below.
++    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
++    <limits.h> exists even on freestanding compilers.  */
++
++#ifdef __STDC__
++# include <limits.h>
++#else
++# include <assert.h>
++#endif
++
++#undef $ac_func
++
++/* Override any gcc2 internal prototype to avoid an error.  */
++#ifdef __cplusplus
++extern "C"
++{
++#endif
++/* We use char because int might match the return type of a gcc2
++   builtin and then its argument prototype would still apply.  */
++char $ac_func ();
++/* The GNU C library defines this for functions which it implements
++    to always fail with ENOSYS.  Some functions are actually named
++    something starting with __ and the normal name is an alias.  */
++#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
++choke me
++#else
++char (*f) () = $ac_func;
++#endif
++#ifdef __cplusplus
++}
++#endif
++
++int
++main ()
++{
++return f != $ac_func;
++  ;
++  return 0;
++}
++_ACEOF
++rm -f conftest.$ac_objext conftest$ac_exeext
++if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
++  (eval $ac_link) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest$ac_exeext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  eval "$as_ac_var=yes"
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++eval "$as_ac_var=no"
++fi
++rm -f conftest.err conftest.$ac_objext \
++      conftest$ac_exeext conftest.$ac_ext
++fi
++echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
++echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
++if test `eval echo '${'$as_ac_var'}'` = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
++_ACEOF
++
++fi
++done
++
++if test x"$ac_cv_func_aclsort" = x"no"; then
++
++echo "$as_me:$LINENO: checking for aclsort in -lsec" >&5
++echo $ECHO_N "checking for aclsort in -lsec... $ECHO_C" >&6
++if test "${ac_cv_lib_sec_aclsort+set}" = set; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  ac_check_lib_save_LIBS=$LIBS
++LIBS="-lsec  $LIBS"
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++
++/* Override any gcc2 internal prototype to avoid an error.  */
++#ifdef __cplusplus
++extern "C"
++#endif
++/* We use char because int might match the return type of a gcc2
++   builtin and then its argument prototype would still apply.  */
++char aclsort ();
++int
++main ()
++{
++aclsort ();
++  ;
++  return 0;
++}
++_ACEOF
++rm -f conftest.$ac_objext conftest$ac_exeext
++if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
++  (eval $ac_link) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest$ac_exeext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  ac_cv_lib_sec_aclsort=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++ac_cv_lib_sec_aclsort=no
++fi
++rm -f conftest.err conftest.$ac_objext \
++      conftest$ac_exeext conftest.$ac_ext
++LIBS=$ac_check_lib_save_LIBS
++fi
++echo "$as_me:$LINENO: result: $ac_cv_lib_sec_aclsort" >&5
++echo "${ECHO_T}$ac_cv_lib_sec_aclsort" >&6
++if test $ac_cv_lib_sec_aclsort = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define HAVE_LIBSEC 1
++_ACEOF
++
++  LIBS="-lsec $LIBS"
++
++fi
++
++fi
++
++
+ echo "$as_me:$LINENO: checking whether utime accepts a null argument" >&5
+ echo $ECHO_N "checking whether utime accepts a null argument... $ECHO_C" >&6
+ if test "${ac_cv_func_utime_null+set}" = set; then
+@@ -12102,6 +12280,556 @@ fi
+ 
+ 
+ 
++
++for ac_header in sys/acl.h
++do
++as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo "$as_me:$LINENO: checking for $ac_header" >&5
++echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++fi
++echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
++echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
++else
++  # Is the header compilable?
++echo "$as_me:$LINENO: checking $ac_header usability" >&5
++echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++$ac_includes_default
++#include <$ac_header>
++_ACEOF
++rm -f conftest.$ac_objext
++if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
++  (eval $ac_compile) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest.$ac_objext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  ac_header_compiler=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++ac_header_compiler=no
++fi
++rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
++echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
++echo "${ECHO_T}$ac_header_compiler" >&6
++
++# Is the header present?
++echo "$as_me:$LINENO: checking $ac_header presence" >&5
++echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++#include <$ac_header>
++_ACEOF
++if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
++  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } >/dev/null; then
++  if test -s conftest.err; then
++    ac_cpp_err=$ac_c_preproc_warn_flag
++    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
++  else
++    ac_cpp_err=
++  fi
++else
++  ac_cpp_err=yes
++fi
++if test -z "$ac_cpp_err"; then
++  ac_header_preproc=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++  ac_header_preproc=no
++fi
++rm -f conftest.err conftest.$ac_ext
++echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
++echo "${ECHO_T}$ac_header_preproc" >&6
++
++# So?  What about this header?
++case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
++  yes:no: )
++    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
++echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
++echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
++    ac_header_preproc=yes
++    ;;
++  no:yes:* )
++    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
++echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
++echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
++echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
++echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
++echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
++echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
++    (
++      cat <<\_ASBOX
++## ------------------------------------------ ##
++## Report this to the AC_PACKAGE_NAME lists.  ##
++## ------------------------------------------ ##
++_ASBOX
++    ) |
++      sed "s/^/$as_me: WARNING:     /" >&2
++    ;;
++esac
++echo "$as_me:$LINENO: checking for $ac_header" >&5
++echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  eval "$as_ac_Header=\$ac_header_preproc"
++fi
++echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
++echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
++
++fi
++if test `eval echo '${'$as_ac_Header'}'` = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
++_ACEOF
++
++fi
++
++done
++
++
++
++
++
++for ac_func in _acl __acl _facl __facl
++do
++as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
++echo "$as_me:$LINENO: checking for $ac_func" >&5
++echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
++if eval "test \"\${$as_ac_var+set}\" = set"; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
++   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
++#define $ac_func innocuous_$ac_func
++
++/* System header to define __stub macros and hopefully few prototypes,
++    which can conflict with char $ac_func (); below.
++    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
++    <limits.h> exists even on freestanding compilers.  */
++
++#ifdef __STDC__
++# include <limits.h>
++#else
++# include <assert.h>
++#endif
++
++#undef $ac_func
++
++/* Override any gcc2 internal prototype to avoid an error.  */
++#ifdef __cplusplus
++extern "C"
++{
++#endif
++/* We use char because int might match the return type of a gcc2
++   builtin and then its argument prototype would still apply.  */
++char $ac_func ();
++/* The GNU C library defines this for functions which it implements
++    to always fail with ENOSYS.  Some functions are actually named
++    something starting with __ and the normal name is an alias.  */
++#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
++choke me
++#else
++char (*f) () = $ac_func;
++#endif
++#ifdef __cplusplus
++}
++#endif
++
++int
++main ()
++{
++return f != $ac_func;
++  ;
++  return 0;
++}
++_ACEOF
++rm -f conftest.$ac_objext conftest$ac_exeext
++if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
++  (eval $ac_link) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest$ac_exeext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  eval "$as_ac_var=yes"
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++eval "$as_ac_var=no"
++fi
++rm -f conftest.err conftest.$ac_objext \
++      conftest$ac_exeext conftest.$ac_ext
++fi
++echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
++echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
++if test `eval echo '${'$as_ac_var'}'` = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
++_ACEOF
++
++fi
++done
++
++#################################################
++# check for ACL support
++
++echo "$as_me:$LINENO: checking whether to support ACLs" >&5
++echo $ECHO_N "checking whether to support ACLs... $ECHO_C" >&6
++# Check whether --enable-acl-support or --disable-acl-support was given.
++if test "${enable_acl_support+set}" = set; then
++  enableval="$enable_acl_support"
++   case "$enableval" in
++  yes)
++
++		case "$host_os" in
++		*sysv5*)
++			echo "$as_me:$LINENO: result: Using UnixWare ACLs" >&5
++echo "${ECHO_T}Using UnixWare ACLs" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_UNIXWARE_ACLS 1
++_ACEOF
++
++			;;
++		*solaris*)
++			echo "$as_me:$LINENO: result: Using solaris ACLs" >&5
++echo "${ECHO_T}Using solaris ACLs" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_SOLARIS_ACLS 1
++_ACEOF
++
++			;;
++		*hpux*)
++			echo "$as_me:$LINENO: result: Using HPUX ACLs" >&5
++echo "${ECHO_T}Using HPUX ACLs" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_HPUX_ACLS 1
++_ACEOF
++
++			;;
++		*irix*)
++			echo "$as_me:$LINENO: result: Using IRIX ACLs" >&5
++echo "${ECHO_T}Using IRIX ACLs" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_IRIX_ACLS 1
++_ACEOF
++
++			;;
++		*aix*)
++			echo "$as_me:$LINENO: result: Using AIX ACLs" >&5
++echo "${ECHO_T}Using AIX ACLs" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_AIX_ACLS 1
++_ACEOF
++
++			;;
++		*osf*)
++			echo "$as_me:$LINENO: result: Using Tru64 ACLs" >&5
++echo "${ECHO_T}Using Tru64 ACLs" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_TRU64_ACLS 1
++_ACEOF
++
++			LIBS="$LIBS -lpacl"
++			;;
++		*)
++		    echo "$as_me:$LINENO: result: ACLs requested -- running tests" >&5
++echo "${ECHO_T}ACLs requested -- running tests" >&6
++
++echo "$as_me:$LINENO: checking for acl_get_file in -lacl" >&5
++echo $ECHO_N "checking for acl_get_file in -lacl... $ECHO_C" >&6
++if test "${ac_cv_lib_acl_acl_get_file+set}" = set; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  ac_check_lib_save_LIBS=$LIBS
++LIBS="-lacl  $LIBS"
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++
++/* Override any gcc2 internal prototype to avoid an error.  */
++#ifdef __cplusplus
++extern "C"
++#endif
++/* We use char because int might match the return type of a gcc2
++   builtin and then its argument prototype would still apply.  */
++char acl_get_file ();
++int
++main ()
++{
++acl_get_file ();
++  ;
++  return 0;
++}
++_ACEOF
++rm -f conftest.$ac_objext conftest$ac_exeext
++if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
++  (eval $ac_link) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest$ac_exeext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  ac_cv_lib_acl_acl_get_file=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++ac_cv_lib_acl_acl_get_file=no
++fi
++rm -f conftest.err conftest.$ac_objext \
++      conftest$ac_exeext conftest.$ac_ext
++LIBS=$ac_check_lib_save_LIBS
++fi
++echo "$as_me:$LINENO: result: $ac_cv_lib_acl_acl_get_file" >&5
++echo "${ECHO_T}$ac_cv_lib_acl_acl_get_file" >&6
++if test $ac_cv_lib_acl_acl_get_file = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define HAVE_LIBACL 1
++_ACEOF
++
++  LIBS="-lacl $LIBS"
++
++fi
++
++			echo "$as_me:$LINENO: checking for ACL support" >&5
++echo $ECHO_N "checking for ACL support... $ECHO_C" >&6
++if test "${samba_cv_HAVE_POSIX_ACLS+set}" = set; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++
++			cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++#include <sys/types.h>
++#include <sys/acl.h>
++int
++main ()
++{
++ acl_t acl; int entry_id; acl_entry_t *entry_p; return acl_get_entry( acl, entry_id, entry_p);
++  ;
++  return 0;
++}
++_ACEOF
++rm -f conftest.$ac_objext conftest$ac_exeext
++if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
++  (eval $ac_link) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest$ac_exeext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  samba_cv_HAVE_POSIX_ACLS=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++samba_cv_HAVE_POSIX_ACLS=no
++fi
++rm -f conftest.err conftest.$ac_objext \
++      conftest$ac_exeext conftest.$ac_ext
++fi
++echo "$as_me:$LINENO: result: $samba_cv_HAVE_POSIX_ACLS" >&5
++echo "${ECHO_T}$samba_cv_HAVE_POSIX_ACLS" >&6
++			if test x"$samba_cv_HAVE_POSIX_ACLS" = x"yes"; then
++			    echo "$as_me:$LINENO: result: Using posix ACLs" >&5
++echo "${ECHO_T}Using posix ACLs" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_POSIX_ACLS 1
++_ACEOF
++
++			    echo "$as_me:$LINENO: checking for acl_get_perm_np" >&5
++echo $ECHO_N "checking for acl_get_perm_np... $ECHO_C" >&6
++if test "${samba_cv_HAVE_ACL_GET_PERM_NP+set}" = set; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++
++				cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++#include <sys/types.h>
++#include <sys/acl.h>
++int
++main ()
++{
++ acl_permset_t permset_d; acl_perm_t perm; return acl_get_perm_np( permset_d, perm);
++  ;
++  return 0;
++}
++_ACEOF
++rm -f conftest.$ac_objext conftest$ac_exeext
++if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
++  (eval $ac_link) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest$ac_exeext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  samba_cv_HAVE_ACL_GET_PERM_NP=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++samba_cv_HAVE_ACL_GET_PERM_NP=no
++fi
++rm -f conftest.err conftest.$ac_objext \
++      conftest$ac_exeext conftest.$ac_ext
++fi
++echo "$as_me:$LINENO: result: $samba_cv_HAVE_ACL_GET_PERM_NP" >&5
++echo "${ECHO_T}$samba_cv_HAVE_ACL_GET_PERM_NP" >&6
++			    if test x"$samba_cv_HAVE_ACL_GET_PERM_NP" = x"yes"; then
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_ACL_GET_PERM_NP 1
++_ACEOF
++
++			    fi
++			else
++			    { { echo "$as_me:$LINENO: error: Failed to find ACL support" >&5
++echo "$as_me: error: Failed to find ACL support" >&2;}
++   { (exit 1); exit 1; }; }
++			fi
++			;;
++		esac
++		;;
++  *)
++    echo "$as_me:$LINENO: result: no" >&5
++echo "${ECHO_T}no" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_NO_ACLS 1
++_ACEOF
++
++    ;;
++  esac
++else
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_NO_ACLS 1
++_ACEOF
++
++  echo "$as_me:$LINENO: result: no" >&5
++echo "${ECHO_T}no" >&6
++
++fi;
++
+                                                   ac_config_files="$ac_config_files Makefile lib/dummy zlib/dummy popt/dummy shconfig"
+ 
+ cat >confcache <<\_ACEOF
+--- old/config.h.in
++++ new/config.h.in
+@@ -21,6 +21,15 @@
+ /* Define to 1 if the `getpgrp' function requires zero arguments. */
+ #undef GETPGRP_VOID
+ 
++/* Define to 1 if you have the `aclsort' function. */
++#undef HAVE_ACLSORT
++
++/* true if you have acl_get_perm_np */
++#undef HAVE_ACL_GET_PERM_NP
++
++/* true if you have AIX ACLs */
++#undef HAVE_AIX_ACLS
++
+ /* Define to 1 if you have `alloca', as a function or macro. */
+ #undef HAVE_ALLOCA
+ 
+@@ -113,6 +122,9 @@
+ /* Define to 1 if you have the <grp.h> header file. */
+ #undef HAVE_GRP_H
+ 
++/* true if you have HPUX ACLs */
++#undef HAVE_HPUX_ACLS
++
+ /* Define to 1 if you have the <iconv.h> header file. */
+ #undef HAVE_ICONV_H
+ 
+@@ -128,6 +140,9 @@
+ /* Define to 1 if you have the <inttypes.h> header file. */
+ #undef HAVE_INTTYPES_H
+ 
++/* true if you have IRIX ACLs */
++#undef HAVE_IRIX_ACLS
++
+ /* Define to 1 if you have the <langinfo.h> header file. */
+ #undef HAVE_LANGINFO_H
+ 
+@@ -137,6 +152,9 @@
+ /* Define to 1 if you have the `lchown' function. */
+ #undef HAVE_LCHOWN
+ 
++/* Define to 1 if you have the `acl' library (-lacl). */
++#undef HAVE_LIBACL
++
+ /* Define to 1 if you have the <libcharset.h> header file. */
+ #undef HAVE_LIBCHARSET_H
+ 
+@@ -155,6 +173,9 @@
+ /* Define to 1 if you have the `resolv' library (-lresolv). */
+ #undef HAVE_LIBRESOLV
+ 
++/* Define to 1 if you have the `sec' library (-lsec). */
++#undef HAVE_LIBSEC
++
+ /* Define to 1 if you have the `socket' library (-lsocket). */
+ #undef HAVE_LIBSOCKET
+ 
+@@ -216,9 +237,15 @@
+ /* Define to 1 if you have the `nl_langinfo' function. */
+ #undef HAVE_NL_LANGINFO
+ 
++/* true if you don't have ACLs */
++#undef HAVE_NO_ACLS
++
+ /* Define to 1 if you have the `open64' function. */
+ #undef HAVE_OPEN64
+ 
++/* true if you have posix ACLs */
++#undef HAVE_POSIX_ACLS
++
+ /* Define to 1 if you have the `putenv' function. */
+ #undef HAVE_PUTENV
+ 
+@@ -270,6 +297,9 @@
+ /* Define to 1 if you have the "socketpair" function */
+ #undef HAVE_SOCKETPAIR
+ 
++/* true if you have solaris ACLs */
++#undef HAVE_SOLARIS_ACLS
++
+ /* Define to 1 if you have the <stdint.h> header file. */
+ #undef HAVE_STDINT_H
+ 
+@@ -315,6 +345,9 @@
+ /* Define to 1 if `st_rdev' is member of `struct stat'. */
+ #undef HAVE_STRUCT_STAT_ST_RDEV
+ 
++/* Define to 1 if you have the <sys/acl.h> header file. */
++#undef HAVE_SYS_ACL_H
++
+ /* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+    */
+ #undef HAVE_SYS_DIR_H
+@@ -365,9 +398,15 @@
+ /* Define to 1 if you have the `tcgetpgrp' function. */
+ #undef HAVE_TCGETPGRP
+ 
++/* true if you have Tru64 ACLs */
++#undef HAVE_TRU64_ACLS
++
+ /* Define to 1 if you have the <unistd.h> header file. */
+ #undef HAVE_UNISTD_H
+ 
++/* true if you have UnixWare ACLs */
++#undef HAVE_UNIXWARE_ACLS
++
+ /* Define to 1 if you have the "struct utimbuf" type */
+ #undef HAVE_UTIMBUF
+ 
+@@ -398,6 +437,18 @@
+ /* Define to 1 if you have the `waitpid' function. */
+ #undef HAVE_WAITPID
+ 
++/* Define to 1 if you have the `_acl' function. */
++#undef HAVE__ACL
++
++/* Define to 1 if you have the `_facl' function. */
++#undef HAVE__FACL
++
++/* Define to 1 if you have the `__acl' function. */
++#undef HAVE___ACL
++
++/* Define to 1 if you have the `__facl' function. */
++#undef HAVE___FACL
++
+ /* Define to 1 if you have the `__va_copy' function. */
+ #undef HAVE___VA_COPY
+ 
+--- old/rsync.1
++++ new/rsync.1
+@@ -377,6 +377,7 @@ to the detailed description below for a 
+  -H, --hard-links            preserve hard links
+  -p, --perms                 preserve permissions
+  -E, --executability         preserve executability
++ -A, --acls                  preserve ACLs (implies -p) [non-standard]
+      --chmod=CHMOD           change destination permissions
+  -o, --owner                 preserve owner (super-user only)
+  -g, --group                 preserve group
+@@ -845,7 +846,9 @@ permissions, though the \fB--executabili
+ the execute permission for the file\&.
+ .IP o 
+ New files get their "normal" permission bits set to the source
+-file\&'s permissions masked with the receiving end\&'s umask setting, and
++file\&'s permissions masked with the receiving directory\&'s default
++permissions (either the receiving process\&'s umask, or the permissions
++specified via the destination directory\&'s default ACL), and
+ their special permission bits disabled except in the case where a new
+ directory inherits a setgid bit from its parent directory\&.
+ .RE 
+@@ -880,9 +883,11 @@ The preservation of the destination\&'s 
+ directories when \fB--perms\fP is off was added in rsync 2\&.6\&.7\&.  Older rsync
+ versions erroneously preserved the three special permission bits for
+ newly-created files when \fB--perms\fP was off, while overriding the
+-destination\&'s setgid bit setting on a newly-created directory\&.  (Keep in
+-mind that it is the version of the receiving rsync that affects this
+-behavior\&.)
++destination\&'s setgid bit setting on a newly-created directory\&.  Default ACL
++observance was added to the ACL patch for rsync 2\&.6\&.7, so older (or
++non-ACL-enabled) rsyncs use the umask even if default ACLs are present\&.
++(Keep in mind that it is the version of the receiving rsync that affects
++these behaviors\&.)
+ .IP 
+ .IP "\fB-E, --executability\fP" 
+ This option causes rsync to preserve the
+@@ -903,6 +908,11 @@ has a corresponding \&'r\&' permission e
+ .IP 
+ If \fB--perms\fP is enabled, this option is ignored\&.
+ .IP 
++.IP "\fB-A, --acls\fP" 
++This option causes rsync to update the destination
++ACLs to be the same as the source ACLs\&.  This nonstandard option only
++works if the remote rsync also supports it\&.  \fB--acls\fP implies \fB--perms\fP\&.
++.IP 
+ .IP "\fB--chmod\fP" 
+ This option tells rsync to apply one or more
+ comma-separated "chmod" strings to the permission of the files in the
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: adaptec_acl_mods.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches: append.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/atimes.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/atimes.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/atimes.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/atimes.diff	2006-03-12 02:44:24.000000000 +0800
@@ -1,405 +1,602 @@
-After applying this patch and running configure, you MUST run this
-command before "make":
+After applying this patch, run these commands for a successful build:
 
-    make proto
+    ./prepare-source
+    ./configure                      (optional if already run)
+    make
 
 
---- orig/batch.c	2005-04-09 18:59:44
-+++ batch.c	2004-07-03 20:15:41
-@@ -208,6 +208,8 @@ void show_flist(int index, struct file_s
- 		rprintf(FINFO, "flist->flags=%#x\n", fptr[i]->flags);
- 		rprintf(FINFO, "flist->modtime=%#lx\n",
- 			(long unsigned) fptr[i]->modtime);
-+		rprintf(FINFO, "flist->atime=%#lx\n",
-+			(long unsigned) fptr[i]->atime);
- 		rprintf(FINFO, "flist->length=%.0f\n",
- 			(double) fptr[i]->length);
- 		rprintf(FINFO, "flist->mode=%#o\n", (int) fptr[i]->mode);
---- orig/flist.c	2005-07-28 18:48:38
-+++ flist.c	2005-07-28 00:16:34
-@@ -50,6 +50,7 @@ extern int preserve_perms;
- extern int preserve_devices;
+--- old/flist.c
++++ new/flist.c
+@@ -50,6 +50,7 @@ extern int preserve_devices;
+ extern int preserve_specials;
  extern int preserve_uid;
  extern int preserve_gid;
 +extern int preserve_atimes;
  extern int relative_paths;
  extern int implied_dirs;
- extern int copy_links;
-@@ -141,16 +142,18 @@ static void list_file_entry(struct file_
+ extern int prune_empty_dirs;
+@@ -84,7 +85,13 @@ void init_flist(void)
+ 	struct file_struct f;
+ 
+ 	/* Figure out how big the file_struct is without trailing padding */
+-	file_struct_len = offsetof(struct file_struct, flags) + sizeof f.flags;
++	if (preserve_atimes)
++		file_struct_len = offsetof(struct file_struct, fl4g5);
++	else
++		file_struct_len = offsetof(struct file_struct, atime);
++	/* The "flags" uchar is no longer accessed directly, so I
++	 * mangled the name to fl4g5 as a reminder. */
++	file_struct_len += sizeof f.fl4g5;
+ 	checksum_len = protocol_version < 21 ? 2 : MD4_SUM_LENGTH;
+ }
+ 
+@@ -140,16 +147,18 @@ static void list_file_entry(struct file_
  
  #ifdef SUPPORT_LINKS
  	if (preserve_links && S_ISLNK(f->mode)) {
 -		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
 +		rprintf(FINFO, "%s %11.0f %s %s %s -> %s\n",
- 			perms,
+ 			permbuf,
  			(double)f->length, timestring(f->modtime),
-+			timestring(f->atime),
- 			safe_fname(f_name(f)), safe_fname(f->u.link));
++			preserve_atimes ? timestring(f->atime) : "",
+ 			f_name(f, NULL), f->u.link);
  	} else
  #endif
  	{
 -		rprintf(FINFO, "%s %11.0f %s %s\n",
 +		rprintf(FINFO, "%s %11.0f %s %s %s\n",
- 			perms,
+ 			permbuf,
  			(double)f->length, timestring(f->modtime),
-+			timestring(f->atime),
- 			safe_fname(f_name(f)));
++			preserve_atimes ? timestring(f->atime) : "",
+ 			f_name(f, NULL));
  	}
  }
-@@ -314,6 +317,7 @@ void send_file_entry(struct file_struct 
+@@ -311,6 +320,7 @@ static void send_file_entry(struct file_
  {
  	unsigned short flags;
  	static time_t modtime;
 +	static time_t atime;
  	static mode_t mode;
  	static int64 dev;
  	static dev_t rdev;
-@@ -329,7 +333,7 @@ void send_file_entry(struct file_struct 
+@@ -326,7 +336,7 @@ static void send_file_entry(struct file_
  
  	if (!file) {
  		write_byte(f, 0);
 -		modtime = 0, mode = 0;
 +		modtime = 0, atime = 0, mode = 0;
  		dev = 0, rdev = makedev(0, 0);
  		rdev_major = 0;
  		uid = 0, gid = 0;
-@@ -378,6 +382,12 @@ void send_file_entry(struct file_struct 
+@@ -338,7 +348,7 @@ static void send_file_entry(struct file_
+ 
+ 	f_name(file, fname);
+ 
+-	flags = file->flags & XMIT_TOP_DIR;
++	flags = FFLAGS(file) & XMIT_TOP_DIR;
+ 
+ 	if (file->mode == mode)
+ 		flags |= XMIT_SAME_MODE;
+@@ -374,6 +384,12 @@ static void send_file_entry(struct file_
  		flags |= XMIT_SAME_TIME;
  	else
  		modtime = file->modtime;
 +	if (preserve_atimes && !S_ISDIR(mode)) {
 +		if (file->atime == atime)
 +			flags |= XMIT_SAME_ATIME;
 +		else
 +			atime = file->atime;
 +	}
  
  #ifdef SUPPORT_HARD_LINKS
  	if (file->link_u.idev) {
-@@ -433,6 +443,8 @@ void send_file_entry(struct file_struct 
+@@ -427,6 +443,8 @@ static void send_file_entry(struct file_
  		write_int(f, modtime);
  	if (!(flags & XMIT_SAME_MODE))
  		write_int(f, to_wire_mode(mode));
 +	if (preserve_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
 +		write_int(f, atime);
  	if (preserve_uid && !(flags & XMIT_SAME_UID)) {
  		if (!numeric_ids)
  			add_uid(uid);
-@@ -506,6 +518,7 @@ static struct file_struct *receive_file_
+@@ -495,6 +513,7 @@ static struct file_struct *receive_file_
  					      unsigned short flags, int f)
  {
  	static time_t modtime;
 +	static time_t atime;
  	static mode_t mode;
  	static int64 dev;
  	static dev_t rdev;
-@@ -524,7 +537,7 @@ static struct file_struct *receive_file_
+@@ -513,7 +532,7 @@ static struct file_struct *receive_file_
  	struct file_struct *file;
  
  	if (!flist) {
 -		modtime = 0, mode = 0;
 +		modtime = 0, atime = 0, mode = 0;
  		dev = 0, rdev = makedev(0, 0);
  		rdev_major = 0;
  		uid = 0, gid = 0;
-@@ -580,6 +593,8 @@ static struct file_struct *receive_file_
+@@ -569,6 +588,8 @@ static struct file_struct *receive_file_
  		modtime = (time_t)read_int(f);
  	if (!(flags & XMIT_SAME_MODE))
  		mode = from_wire_mode(read_int(f));
 +	if (preserve_atimes && !S_ISDIR(mode) && !(flags & XMIT_SAME_ATIME))
 +		atime = (time_t)read_int(f);
  
- 	if (preserve_uid && !(flags & XMIT_SAME_UID))
- 		uid = (uid_t)read_int(f);
-@@ -630,6 +645,7 @@ static struct file_struct *receive_file_
- 
- 	file->flags = 0;
- 	file->modtime = modtime;
-+	file->atime = atime;
- 	file->length = file_length;
+ 	if (chmod_modes && !S_ISLNK(mode))
+ 		mode = tweak_mode(mode, chmod_modes);
+@@ -624,6 +645,8 @@ static struct file_struct *receive_file_
  	file->mode = mode;
  	file->uid = uid;
-@@ -882,6 +898,7 @@ skip_filters:
+ 	file->gid = gid;
++	if (preserve_atimes)
++		file->atime = atime;
+ 
+ 	if (dirname_len) {
+ 		file->dirname = lastdir = bp;
+@@ -649,12 +672,12 @@ static struct file_struct *receive_file_
+ 			    && lastname[del_hier_name_len-1] == '.'
+ 			    && lastname[del_hier_name_len-2] == '/')
+ 				del_hier_name_len -= 2;
+-			file->flags |= FLAG_TOP_DIR | FLAG_DEL_HERE;
++			FFLAGS(file) |= FLAG_TOP_DIR | FLAG_DEL_HERE;
+ 		} else if (in_del_hier) {
+ 			if (!relative_paths || !del_hier_name_len
+ 			 || (l1 >= del_hier_name_len
+ 			  && lastname[del_hier_name_len] == '/'))
+-				file->flags |= FLAG_DEL_HERE;
++				FFLAGS(file) |= FLAG_DEL_HERE;
+ 			else
+ 				in_del_hier = 0;
+ 		}
+@@ -870,12 +893,14 @@ struct file_struct *make_file(char *fnam
+ 	memset(bp, 0, file_struct_len);
+ 	bp += file_struct_len;
  
- 	file->flags = flags;
+-	file->flags = flags;
++	FFLAGS(file) = flags;
  	file->modtime = st.st_mtime;
-+	file->atime = st.st_atime;
  	file->length = st.st_size;
  	file->mode = st.st_mode;
  	file->uid = st.st_uid;
---- orig/generator.c	2005-07-28 19:00:14
-+++ generator.c	2005-07-28 18:58:21
-@@ -44,6 +44,7 @@ extern int preserve_uid;
+ 	file->gid = st.st_gid;
++	if (preserve_atimes)
++		file->atime = st.st_atime;
+ 
+ #ifdef SUPPORT_HARD_LINKS
+ 	if (flist && flist->hlink_pool) {
+@@ -988,7 +1013,7 @@ static void send_if_directory(int f, str
+ 	char is_dot_dir = fbuf[ol-1] == '.' && (ol == 1 || fbuf[ol-2] == '/');
+ 
+ 	if (S_ISDIR(file->mode)
+-	    && !(file->flags & FLAG_MOUNT_POINT) && f_name(file, fbuf)) {
++	    && !(FFLAGS(file) & FLAG_MOUNT_POINT) && f_name(file, fbuf)) {
+ 		void *save_filters;
+ 		unsigned int len = strlen(fbuf);
+ 		if (len > 1 && fbuf[len-1] == '/')
+@@ -1594,8 +1619,9 @@ static void clean_flist(struct file_list
+ 			}
+ 			/* Make sure we don't lose track of a user-specified
+ 			 * top directory. */
+-			flist->files[keep]->flags |= flist->files[drop]->flags
+-						   & (FLAG_TOP_DIR|FLAG_DEL_HERE);
++			FFLAGS(flist->files[keep])
++			    |= FFLAGS(flist->files[drop])
++			     & (FLAG_TOP_DIR|FLAG_DEL_HERE);
+ 
+ 			clear_file(flist->files[drop], flist);
+ 
+@@ -1719,7 +1745,7 @@ static void output_flist(struct file_lis
+ 			file->dirname ? file->dirname : "",
+ 			file->dirname ? "/" : "", NS(file->basename),
+ 			S_ISDIR(file->mode) ? "/" : "", (int)file->mode,
+-			(double)file->length, uidbuf, gidbuf, file->flags);
++			(double)file->length, uidbuf, gidbuf, FFLAGS(file));
+ 	}
+ }
+ 
+--- old/generator.c
++++ new/generator.c
+@@ -44,6 +44,7 @@ extern int preserve_perms;
+ extern int preserve_uid;
  extern int preserve_gid;
  extern int preserve_times;
- extern int omit_dir_times;
 +extern int preserve_atimes;
+ extern int omit_dir_times;
+ extern int delete_mode;
  extern int delete_before;
- extern int delete_during;
- extern int delete_after;
-@@ -323,9 +324,21 @@ void itemize(struct file_struct *file, i
- 			    : S_ISDIR(file->mode) ? !omit_dir_times
- 			    : !S_ISLNK(file->mode);
- 
-+			if (iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !keep_time
-+			     && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname)) {
-+				iflags |= ITEM_REPORT_TIME;
-+				if (!preserve_atimes && !S_ISDIR(file->mode))
-+					iflags |= ITEM_REPORT_ATIME;
-+			} else {
-+				if (keep_time && cmp_time(file->modtime, st->st_mtime) != 0)
-+					iflags |= ITEM_REPORT_TIME;
-+				if (preserve_atimes && !S_ISDIR(file->mode)
-+				 && cmp_time(file->atime, st->st_atime) != 0)
-+					iflags |= ITEM_REPORT_ATIME;
-+			}
- 			if ((iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !keep_time
- 			     && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
--			    || (keep_time && cmp_modtime(file->modtime, st->st_mtime) != 0))
-+			    || (keep_time && cmp_time(file->modtime, st->st_mtime) != 0))
- 				iflags |= ITEM_REPORT_TIME;
- 			if (preserve_perms
- 			 && (file->mode & CHMOD_BITS) != (st->st_mode & CHMOD_BITS))
-@@ -377,7 +390,7 @@ static int unchanged_file(char *fn, stru
- 	if (ignore_times)
- 		return 0;
+@@ -90,6 +91,7 @@ extern dev_t filesystem_dev;
+ extern char *backup_dir;
+ extern char *backup_suffix;
+ extern int backup_suffix_len;
++extern unsigned int file_struct_len;
+ extern struct file_list *the_file_list;
+ extern struct filter_list_struct server_filter_list;
+ 
+@@ -184,7 +186,7 @@ static int delete_item(char *fname, int 
+ 	for (j = dirlist->count; j--; ) {
+ 		struct file_struct *fp = dirlist->files[j];
+ 
+-		if (fp->flags & FLAG_MOUNT_POINT)
++		if (FFLAGS(fp) & FLAG_MOUNT_POINT)
+ 			continue;
+ 
+ 		strlcpy(p, fp->basename, remainder);
+@@ -262,7 +264,7 @@ static void delete_in_dir(struct file_li
+ 	filt_array[cur_depth] = push_local_filters(fbuf, dlen);
+ 
+ 	if (one_file_system) {
+-		if (file->flags & FLAG_TOP_DIR)
++		if (FFLAGS(file) & FLAG_TOP_DIR)
+ 			filesystem_dev = stp->st_dev;
+ 		else if (filesystem_dev != stp->st_dev)
+ 			return;
+@@ -274,7 +276,7 @@ static void delete_in_dir(struct file_li
+ 	 * from the filesystem. */
+ 	for (i = dirlist->count; i--; ) {
+ 		struct file_struct *fp = dirlist->files[i];
+-		if (!fp->basename || fp->flags & FLAG_MOUNT_POINT)
++		if (!fp->basename || FFLAGS(fp) & FLAG_MOUNT_POINT)
+ 			continue;
+ 		if (flist_find(flist, fp) < 0) {
+ 			f_name(fp, delbuf);
+@@ -300,11 +302,11 @@ static void do_delete_pass(struct file_l
+ 	for (j = 0; j < flist->count; j++) {
+ 		struct file_struct *file = flist->files[j];
+ 
+-		if (!(file->flags & FLAG_DEL_HERE))
++		if (!(FFLAGS(file) & FLAG_DEL_HERE))
+ 			continue;
+ 
+ 		f_name(file, fbuf);
+-		if (verbose > 1 && file->flags & FLAG_TOP_DIR)
++		if (verbose > 1 && FFLAGS(file) & FLAG_TOP_DIR)
+ 			rprintf(FINFO, "deleting in %s\n", fbuf);
+ 
+ 		if (link_stat(fbuf, &st, keep_dirlinks) < 0
+@@ -348,6 +350,9 @@ void itemize(struct file_struct *file, i
+ 		     && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
+ 		    || (keep_time && cmp_time(file->modtime, st->st_mtime) != 0))
+ 			iflags |= ITEM_REPORT_TIME;
++		if (preserve_atimes && !S_ISDIR(file->mode) && !S_ISLNK(file->mode)
++		 && cmp_time(file->atime, st->st_atime) != 0)
++			iflags |= ITEM_REPORT_ATIME;
+ 		if ((file->mode & CHMOD_BITS) != (st->st_mode & CHMOD_BITS))
+ 			iflags |= ITEM_REPORT_PERMS;
+ 		if (preserve_uid && am_root && file->uid != st->st_uid)
+@@ -549,7 +554,7 @@ static int find_fuzzy(struct file_struct
+ 		uint32 dist;
+ 
+ 		if (!S_ISREG(fp->mode) || !fp->length
+-		    || fp->flags & FLAG_NO_FUZZY)
++		    || FFLAGS(fp) & FLAG_NO_FUZZY)
+ 			continue;
  
--	return cmp_modtime(st->st_mtime, file->modtime) == 0;
-+	return cmp_time(st->st_mtime, file->modtime) == 0;
- }
- 
- 
-@@ -530,7 +543,7 @@ static int find_fuzzy(struct file_struct
  		name = fp->basename;
- 
- 		if (fp->length == file->length
--		    && cmp_modtime(fp->modtime, file->modtime) == 0) {
-+		    && cmp_time(fp->modtime, file->modtime) == 0) {
- 			if (verbose > 4) {
- 				rprintf(FINFO,
- 					"fuzzy size/modtime match for %s\n",
-@@ -851,7 +864,7 @@ static void recv_generator(char *fname, 
+@@ -658,6 +663,8 @@ static int try_dests_reg(struct file_str
+ 					  itemizing && verbose > 1,
+ 					  code) < 0)
+ 				goto try_a_copy;
++			if (preserve_atimes)
++				set_file_attrs(fname, file, stp, 0);
+ 			if (preserve_hard_links && file->link_u.links)
+ 				hard_link_cluster(file, ndx, itemizing, code);
+ 		} else if (itemizing)
+@@ -906,7 +913,7 @@ static void recv_generator(char *fname, 
+ 		    && verbose && code && f_out != -1)
+ 			rprintf(code, "%s/\n", fname);
+ 		if (delete_during && f_out != -1 && !phase && dry_run < 2
+-		    && (file->flags & FLAG_DEL_HERE))
++		    && (FFLAGS(file) & FLAG_DEL_HERE))
+ 			delete_in_dir(the_file_list, fname, file, &st);
+ 		return;
  	}
+@@ -1188,7 +1195,7 @@ static void recv_generator(char *fname, 
+ 	if (fuzzy_dirlist) {
+ 		int j = flist_find(fuzzy_dirlist, file);
+ 		if (j >= 0) /* don't use changing file as future fuzzy basis */
+-			fuzzy_dirlist->files[j]->flags |= FLAG_NO_FUZZY;
++			FFLAGS(fuzzy_dirlist->files[j]) |= FLAG_NO_FUZZY;
+ 	}
+ 
+ 	/* open the file */
+--- old/hlink.c
++++ new/hlink.c
+@@ -25,6 +25,7 @@ extern int link_dest;
+ extern int make_backups;
+ extern int log_format_has_i;
+ extern char *basis_dir[];
++extern unsigned int file_struct_len;
+ extern struct file_list *the_file_list;
  
- 	if (update_only && statret == 0
--	    && cmp_modtime(st.st_mtime, file->modtime) > 0) {
-+	    && cmp_time(st.st_mtime, file->modtime) > 0) {
- 		if (verbose > 1)
- 			rprintf(FINFO, "%s is newer\n", safe_fname(fname));
+ #ifdef SUPPORT_HARD_LINKS
+@@ -85,10 +86,10 @@ static void link_idev_data(void)
+ 			FPTR(cur)->link_u.links = pool_talloc(hlink_pool,
+ 			    struct hlink, 1, "hlink_list");
+ 
+-			FPTR(head)->flags |= FLAG_HLINK_TOL;
++			FFLAGS(FPTR(head)) |= FLAG_HLINK_TOL;
+ 			FPTR(cur)->F_HLINDEX = to;
+ 			FPTR(cur)->F_NEXT = head;
+-			FPTR(cur)->flags |= FLAG_HLINK_EOL;
++			FFLAGS(FPTR(cur)) |= FLAG_HLINK_EOL;
+ 			hlink_list[to++] = head;
+ 		} else
+ 			FPTR(cur)->link_u.links = NULL;
+@@ -174,7 +175,7 @@ int hard_link_check(struct file_struct *
+ {
+ #ifdef SUPPORT_HARD_LINKS
+ 	int head;
+-	if (skip && !(file->flags & FLAG_HLINK_EOL))
++	if (skip && !(FFLAGS(file) & FLAG_HLINK_EOL))
+ 		head = hlink_list[file->F_HLINDEX] = file->F_NEXT;
+ 	else
+ 		head = hlink_list[file->F_HLINDEX];
+@@ -269,8 +270,8 @@ void hard_link_cluster(struct file_struc
+ 	file->F_HLINDEX = FINISHED_LINK;
+ 	if (link_stat(f_name(file, hlink1), &st1, 0) < 0)
  		return;
---- orig/log.c	2005-06-09 22:27:22
-+++ log.c	2005-07-28 00:22:30
-@@ -38,6 +38,7 @@ extern int module_id;
- extern int msg_fd_out;
+-	if (!(file->flags & FLAG_HLINK_TOL)) {
+-		while (!(file->flags & FLAG_HLINK_EOL)) {
++	if (!(FFLAGS(file) & FLAG_HLINK_TOL)) {
++		while (!(FFLAGS(file) & FLAG_HLINK_EOL)) {
+ 			ndx = file->F_NEXT;
+ 			file = FPTR(ndx);
+ 		}
+@@ -285,6 +286,6 @@ void hard_link_cluster(struct file_struc
+ 		maybe_hard_link(file, ndx, hlink2, statret, &st2,
+ 				hlink1, &st1, itemizing, code);
+ 		file->F_HLINDEX = FINISHED_LINK;
+-	} while (!(file->flags & FLAG_HLINK_EOL));
++	} while (!(FFLAGS(file) & FLAG_HLINK_EOL));
+ #endif
+ }
+--- old/log.c
++++ new/log.c
+@@ -42,6 +42,7 @@ extern int msg_fd_out;
+ extern int allow_8bit_chars;
  extern int protocol_version;
  extern int preserve_times;
 +extern int preserve_atimes;
+ extern int log_format_has_i;
  extern int log_format_has_o_or_i;
  extern int daemon_log_format_has_o_or_i;
- extern char *auth_user;
-@@ -501,11 +502,14 @@ static void log_formatted(enum logcode c
- 			n[4] = !(iflags & ITEM_REPORT_TIME) ? '.'
- 			     : !preserve_times || IS_DEVICE(file->mode)
- 					       || S_ISLNK(file->mode) ? 'T' : 't';
--			n[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
--			n[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
--			n[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
--			n[8] = !(iflags & ITEM_REPORT_XATTRS) ? '.' : 'a';
--			n[9] = '\0';
-+			n[5] = !(iflags & ITEM_REPORT_ATIME) ? '.'
-+			     : !preserve_atimes || IS_DEVICE(file->mode)
-+					        || S_ISLNK(file->mode) ? 'A' : 'a';
-+			n[6] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
-+			n[7] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
-+			n[8] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
-+			n[9] = !(iflags & ITEM_REPORT_XATTRS) ? '.' : 'a';
-+			n[10] = '\0';
+@@ -608,7 +609,8 @@ static void log_formatted(enum logcode c
+ 			n[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
+ 			n[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
+ 			n[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
+-			n[8] = '.';
++			n[8] = !(iflags & ITEM_REPORT_ATIME) ? '.'
++			     : S_ISLNK(file->mode) ? 'U' : 'u';
+ 			n[9] = '\0';
  
  			if (iflags & (ITEM_IS_NEW|ITEM_MISSING_DATA)) {
- 				char ch = iflags & ITEM_IS_NEW ? '+' : '?';
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-07-28 01:00:24
-@@ -49,6 +49,7 @@ int preserve_uid = 0;
+--- old/options.c
++++ new/options.c
+@@ -53,6 +53,7 @@ int preserve_uid = 0;
  int preserve_gid = 0;
  int preserve_times = 0;
  int omit_dir_times = 0;
 +int preserve_atimes = 0;
  int update_only = 0;
  int cvs_exclude = 0;
  int dry_run = 0;
-@@ -285,8 +286,9 @@ void usage(enum logcode F)
-   rprintf(F," -o, --owner                 preserve owner (root only)\n");
-   rprintf(F," -g, --group                 preserve group\n");
-   rprintf(F," -D, --devices               preserve devices (root only)\n");
+@@ -301,8 +302,9 @@ void usage(enum logcode F)
+   rprintf(F,"     --devices               preserve device files (super-user only)\n");
+   rprintf(F,"     --specials              preserve special files\n");
+   rprintf(F," -D                          same as --devices --specials\n");
 -  rprintf(F," -t, --times                 preserve times\n");
 -  rprintf(F," -O, --omit-dir-times        omit directories when preserving times\n");
 +  rprintf(F," -t, --times                 preserve modify times\n");
 +  rprintf(F," -O, --omit-dir-times        omit directories when preserving modify times\n");
-+  rprintf(F," -A, --atimes                preserve access times\n");
++  rprintf(F," -U, --atimes                preserve access (use) times\n");
+   rprintf(F,"     --super                 receiver attempts super-user activities\n");
    rprintf(F," -S, --sparse                handle sparse files efficiently\n");
    rprintf(F," -n, --dry-run               show what would have been transferred\n");
-   rprintf(F," -W, --whole-file            copy files whole (without rsync algorithm)\n");
-@@ -413,6 +415,7 @@ static struct poptOption long_options[] 
-   {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
-   {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
+@@ -413,6 +415,9 @@ static struct poptOption long_options[] 
+   {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
+   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+   {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
++  {"atimes",          'U', POPT_ARG_VAL,    &preserve_atimes, 1, 0, 0 },
++  {"no-atimes",        0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
++  {"no-k",             0,  POPT_ARG_VAL,    &preserve_atimes, 0, 0, 0 },
    {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
-+  {"atimes",          'A', POPT_ARG_NONE,   &preserve_atimes, 0, 0, 0 },
-   {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
-   {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
-   {"quiet",           'q', POPT_ARG_NONE,   0, 'q', 0, 0 },
-@@ -1290,6 +1293,8 @@ void server_options(char **args,int *arg
+   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
+   {"super",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },
+@@ -1519,6 +1524,8 @@ void server_options(char **args,int *arg
  		argstr[x++] = 'D';
  	if (preserve_times)
  		argstr[x++] = 't';
 +	if (preserve_atimes)
-+		argstr[x++] = 'A';
- 	if (omit_dir_times == 2 && am_sender)
- 		argstr[x++] = 'O';
++		argstr[x++] = 'U';
  	if (preserve_perms)
---- orig/rsync.c	2005-07-28 18:48:38
-+++ rsync.c	2005-07-28 18:58:38
-@@ -27,6 +27,7 @@ extern int dry_run;
+ 		argstr[x++] = 'p';
+ 	else if (preserve_executability && am_sender)
+--- old/rsync.c
++++ new/rsync.c
+@@ -35,6 +35,7 @@ extern int dry_run;
  extern int daemon_log_format_has_i;
+ extern int preserve_perms;
+ extern int preserve_executability;
++extern int preserve_atimes;
  extern int preserve_times;
  extern int omit_dir_times;
-+extern int preserve_atimes;
  extern int am_root;
- extern int am_server;
- extern int am_sender;
-@@ -56,6 +57,7 @@ int set_perms(char *fname,struct file_st
+@@ -128,6 +129,7 @@ int set_file_attrs(char *fname, struct f
  	int updated = 0;
  	STRUCT_STAT st2;
  	int change_uid, change_gid;
 +	time_t atime, mtime;
  
  	if (!st) {
  		if (dry_run)
-@@ -71,9 +73,23 @@ int set_perms(char *fname,struct file_st
- 	if (!preserve_times || S_ISLNK(st->st_mode)
- 	 || (S_ISDIR(st->st_mode) && omit_dir_times))
- 		flags |= PERMS_SKIP_MTIME;
+@@ -146,18 +148,33 @@ int set_file_attrs(char *fname, struct f
+ 		}
+ 	}
+ 
++	/* This code must be the first update in the function due to
++	 * how it uses the "updated" variable. */
+ 	if (!preserve_times || (S_ISDIR(st->st_mode) && omit_dir_times))
+ 		flags |= ATTRS_SKIP_MTIME;
 +	if (!preserve_atimes || S_ISDIR(st->st_mode))
-+		flags |= PERMS_SKIP_ATIME;
- 	if (!(flags & PERMS_SKIP_MTIME)
--	    && cmp_modtime(st->st_mtime, file->modtime) != 0) {
--		if (set_modtime(fname,file->modtime) != 0) {
-+	    && cmp_time(st->st_mtime, file->modtime) != 0) {
++		flags |= ATTRS_SKIP_ATIME;
+ 	if (!(flags & ATTRS_SKIP_MTIME)
+ 	    && cmp_time(st->st_mtime, file->modtime) != 0) {
+-		int ret = set_modtime(fname, file->modtime, st->st_mode);
 +		mtime = file->modtime;
 +		updated = 1;
 +	} else
 +		mtime = st->st_mtime;
-+	if (!(flags & PERMS_SKIP_ATIME)
++	if (!(flags & ATTRS_SKIP_ATIME)
 +	    && cmp_time(st->st_atime, file->atime) != 0) {
 +		atime = file->atime;
 +		updated = 1;
 +	} else
 +		atime = st->st_atime;
 +	if (updated) {
-+		int ret = set_times(fname, mtime, atime);
-+		if (ret < 0) {
++		int ret = set_times(fname, mtime, atime, st->st_mode);
+ 		if (ret < 0) {
  			rsyserr(FERROR, errno, "failed to set times on %s",
  				full_fname(fname));
  			return 0;
---- orig/rsync.h	2005-05-03 17:00:47
-+++ rsync.h	2005-07-28 00:04:51
+ 		}
+-		if (ret == 0) /* ret == 1 if symlink could not be set */
+-			updated = 1;
++		if (ret > 0) /* ret == 1 if symlink could not be set */
++			updated = 0;
+ 	}
+ 
+ 	change_uid = am_root && preserve_uid && st->st_uid != file->uid;
+--- old/rsync.h
++++ new/rsync.h
 @@ -54,6 +54,7 @@
  #define XMIT_HAS_IDEV_DATA (1<<9)
  #define XMIT_SAME_DEV (1<<10)
  #define XMIT_RDEV_MINOR_IS_SMALL (1<<11)
 +#define XMIT_SAME_ATIME (1<<12)
  
  /* These flags are used in the live flist data. */
  
-@@ -118,6 +119,7 @@
+@@ -119,6 +120,7 @@
  
- #define PERMS_REPORT		(1<<0)
- #define PERMS_SKIP_MTIME	(1<<1)
-+#define PERMS_SKIP_ATIME	(1<<2)
+ #define ATTRS_REPORT		(1<<0)
+ #define ATTRS_SKIP_MTIME	(1<<1)
++#define ATTRS_SKIP_ATIME	(1<<2)
  
  #define FULL_FLUSH	1
  #define NORMAL_FLUSH	0
-@@ -139,6 +141,7 @@
- #define DEL_TERSE		(1<<3)
+@@ -135,6 +137,7 @@
+ #define FNAMECMP_FUZZY		0x83
  
  /* For use by the itemize_changes code */
 +#define ITEM_REPORT_ATIME (1<<0)
  #define ITEM_REPORT_CHECKSUM (1<<1)
  #define ITEM_REPORT_SIZE (1<<2)
  #define ITEM_REPORT_TIME (1<<3)
-@@ -509,6 +512,7 @@ struct file_struct {
- 		struct hlink *links;
- 	} link_u;
- 	time_t modtime;
-+	time_t atime;
+@@ -520,9 +523,12 @@ struct file_struct {
  	uid_t uid;
  	gid_t gid;
  	mode_t mode;
---- orig/rsync.yo	2005-07-28 19:26:48
-+++ rsync.yo	2005-07-28 01:04:09
-@@ -318,8 +318,9 @@ to the detailed description below for a 
-  -o, --owner                 preserve owner (root only)
-  -g, --group                 preserve group
-  -D, --devices               preserve devices (root only)
+-	uchar flags;	/* this item MUST remain last */
++	time_t atime;   /* this MUST be second to last */
++	uchar fl4g5;	/* this item MUST remain last */
+ };
+ 
++#define FFLAGS(f) ((uchar*)(f))[file_struct_len-1]
++
+ /*
+  * Start the flist array at FLIST_START entries and grow it
+  * by doubling until FLIST_LINEAR then grow by FLIST_LINEAR
+--- old/rsync.yo
++++ new/rsync.yo
+@@ -327,8 +327,9 @@ to the detailed description below for a 
+      --devices               preserve device files (super-user only)
+      --specials              preserve special files
+  -D                          same as --devices --specials
 - -t, --times                 preserve times
+- -O, --omit-dir-times        omit directories when preserving times
 + -t, --times                 preserve modify times
-  -O, --omit-dir-times        omit directories when preserving times
-+ -A, --atimes                preserve access times
++ -O, --omit-dir-times        omit directories when preserving mod-times
++ -U, --atimes                preserve access (use) times
+      --super                 receiver attempts super-user activities
   -S, --sparse                handle sparse files efficiently
   -n, --dry-run               show what would have been transferred
-  -W, --whole-file            copy files whole (without rsync algorithm)
-@@ -657,6 +658,12 @@ it is preserving modification times (see
+@@ -851,6 +852,12 @@ it is preserving modification times (see
  the directories on the receiving side, it is a good idea to use bf(-O).
  This option is inferred if you use bf(--backup) without bf(--backup-dir).
  
-+dit(bf(-A, --atimes)) This tells rsync to set the access times of the
++dit(bf(-U, --atimes)) This tells rsync to set the access (use) times of the
 +destination files to the same value as the source files.  Note that the
 +reading of the source file may update the atime of the source files, so
 +repeated rsync runs with --atimes may be needed if you want to force the
 +access-time values to be 100% identical on the two systems.
 +
- dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
- instead it will just report the actions it would have taken.
- 
-@@ -1064,7 +1071,7 @@ changes that are being made to each file
- This is exactly the same as specifying bf(--log-format='%i %n%L').
+ dit(bf(--super)) This tells the receiving side to attempt super-user
+ activities even if the receiving rsync wasn't run by the super-user.  These
+ activities include: preserving users via the bf(--owner) option, preserving
+@@ -1366,7 +1373,7 @@ with older versions of rsync, but that a
+ verbose messages).
  
  The "%i" escape has a cryptic output that is 9 letters long.  The general
--format is like the string bf(UXcstpoga)), where bf(U) is replaced by the
-+format is like the string bf(UXcstapogx)), where bf(U) is replaced by the
- kind of update being done, bf(X) is replaced by the file-type, and the
+-format is like the string bf(YXcstpogz), where bf(Y) is replaced by the
++format is like the string bf(YXcstpogu), where bf(Y) is replaced by the
+ type of update being done, bf(X) is replaced by the file-type, and the
  other letters represent attributes that may be output if they are being
  modified.
-@@ -1103,17 +1110,22 @@ quote(itemize(
+@@ -1406,7 +1413,7 @@ quote(itemize(
    by the file transfer.
    it() A bf(t) means the modification time is different and is being updated
    to the sender's value (requires bf(--times)).  An alternate value of bf(T)
 -  means that the time will be set to the transfer time, which happens
 +  means that the modify time will be set to the transfer time, which happens
    anytime a symlink is transferred, or when a file or device is transferred
    without bf(--times).
-+  it() A bf(a) means the access time is different and is being updated to
-+  the sender's value (requires bf(--atimes)).  An alternate value of bf(A)
-+  means that the access time  will be set to the transfer time, which happens
-+  anytime a symlink is transferred, or when a file or device is transferred
-+  without bf(--atimes).
    it() A bf(p) means the permissions are different and are being updated to
-   the sender's value (requires bf(--perms)).
-   it() An bf(o) means the owner is different and is being updated to the
-   sender's value (requires bf(--owner) and root privileges).
+@@ -1415,7 +1422,10 @@ quote(itemize(
+   sender's value (requires bf(--owner) and super-user privileges).
    it() A bf(g) means the group is different and is being updated to the
    sender's value (requires bf(--group) and the authority to set the group).
--  it() The bf(a) is reserved for a future enhanced version that supports
--  extended file attributes, such as ACLs.
-+  it() The bf(x) is reserved for a future enhanced version that supports
-+  extended file attributes.
+-  it() The bf(z) slot is reserved for future use.
++  it() A bf(u) means the access (use) time is different and is being updated to
++  the sender's value (requires bf(--atimes)).  An alternate value of bf(U)
++  means that the access time will be set to the transfer time, which happens
++  when a symlink or directory is updated.
  ))
  
  One other output is possible:  when deleting files, the "%i" will output
---- orig/testsuite/atimes.test	2004-06-30 00:06:23
-+++ testsuite/atimes.test	2004-06-30 00:06:23
+--- old/sender.c
++++ new/sender.c
+@@ -38,6 +38,7 @@ extern int do_progress;
+ extern int inplace;
+ extern int batch_fd;
+ extern int write_batch;
++extern unsigned int file_struct_len;
+ extern struct stats stats;
+ extern struct file_list *the_file_list;
+ extern char *log_format;
+@@ -126,7 +127,7 @@ void successful_send(int ndx)
+ 
+ 	file = the_file_list->files[ndx];
+ 	/* The generator might tell us about symlinks we didn't send. */
+-	if (!(file->flags & FLAG_SENT) && !S_ISLNK(file->mode))
++	if (!(FFLAGS(file) & FLAG_SENT) && !S_ISLNK(file->mode))
+ 		return;
+ 	if (file->dir.root) {
+ 		offset = stringjoin(fname, sizeof fname,
+@@ -370,7 +371,7 @@ void send_files(struct file_list *flist,
+ 			rprintf(FINFO, "sender finished %s\n", fname);
+ 
+ 		/* Flag that we actually sent this entry. */
+-		file->flags |= FLAG_SENT;
++		FFLAGS(file) |= FLAG_SENT;
+ 	}
+ 	make_backups = save_make_backups;
+ 
+--- old/testsuite/atimes.test
++++ new/testsuite/atimes.test
 @@ -0,0 +1,19 @@
 +#! /bin/sh
 +
 +# Test rsync copying atimes
 +
 +. "$suitedir/rsync.fns"
@@ -410,176 +607,39 @@
 +
 +touch "$fromdir/foo"
 +touch -a -t 200102031717.42 "$fromdir/foo"
 +
 +TLS_ARGS=--atime
 +
-+checkit "$RSYNC -rtAgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
++checkit "$RSYNC -rtUgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 +
 +# The script would have aborted on error, so getting here means we've won.
 +exit 0
---- orig/testsuite/itemize.test	2005-06-24 02:14:12
-+++ testsuite/itemize.test	2005-07-28 00:29:54
-@@ -44,14 +44,14 @@ ln "$fromdir/foo/config1" "$fromdir/foo/
- $RSYNC -iplr "$fromdir/" "$todir/" \
-     | tee "$outfile"
- cat <<EOT >"$chkfile"
--cd+++++++ bar/
--cd+++++++ bar/baz/
-->f+++++++ bar/baz/rsync
--cd+++++++ foo/
-->f+++++++ foo/config1
-->f+++++++ foo/config2
-->f+++++++ foo/extra
--cL+++++++ foo/sym -> ../bar/baz/rsync
-+cd++++++++ bar/
-+cd++++++++ bar/baz/
-+>f++++++++ bar/baz/rsync
-+cd++++++++ foo/
-+>f++++++++ foo/config1
-+>f++++++++ foo/config2
-+>f++++++++ foo/extra
-+cL++++++++ foo/sym -> ../bar/baz/rsync
- EOT
- diff $diffopt "$chkfile" "$outfile" || test_fail "test 1 failed"
- 
-@@ -63,10 +63,10 @@ chmod 601 "$fromdir/foo/config2"
- $RSYNC -iplrH "$fromdir/" "$todir/" \
-     | tee "$outfile"
- cat <<EOT >"$chkfile"
-->f..T.... bar/baz/rsync
-->f..T.... foo/config1
-->f.sTp... foo/config2
--hf..T.... foo/extra => foo/config1
-+>f..TA.... bar/baz/rsync
-+>f..TA.... foo/config1
-+>f.sTAp... foo/config2
-+hf..TA.... foo/extra => foo/config1
- EOT
- diff $diffopt "$chkfile" "$outfile" || test_fail "test 2 failed"
- 
-@@ -83,11 +83,11 @@ chmod 777 "$todir/bar/baz/rsync"
- $RSYNC -iplrtc "$fromdir/" "$todir/" \
-     | tee "$outfile"
- cat <<EOT >"$chkfile"
--.f..tp... bar/baz/rsync
--.d..t.... foo/
--.f..t.... foo/config1
-->fcstp... foo/config2
--cL..T.... foo/sym -> ../bar/baz/rsync
-+.f..t.p... bar/baz/rsync
-+.d..t..... foo/
-+.f..t..... foo/config1
-+>fcst.p... foo/config2
-+cL..TA.... foo/sym -> ../bar/baz/rsync
- EOT
- diff $diffopt "$chkfile" "$outfile" || test_fail "test 3 failed"
- 
-@@ -112,15 +112,15 @@ $RSYNC -ivvplrtH "$fromdir/" "$todir/" \
-     | tee "$outfile"
- filter_outfile
- cat <<EOT >"$chkfile"
--.d        ./
--.d        bar/
--.d        bar/baz/
--.f...p... bar/baz/rsync
--.d        foo/
--.f        foo/config1
-->f..t.... foo/config2
--hf        foo/extra
--.L        foo/sym -> ../bar/baz/rsync
-+.d         ./
-+.d         bar/
-+.d         bar/baz/
-+.f....p... bar/baz/rsync
-+.d         foo/
-+.f         foo/config1
-+>f..t..... foo/config2
-+hf         foo/extra
-+.L         foo/sym -> ../bar/baz/rsync
- EOT
- diff $diffopt "$chkfile" "$outfile" || test_fail "test 5 failed"
- 
-@@ -139,8 +139,8 @@ touch "$todir/foo/config2"
- $RSYNC -iplrtH "$fromdir/" "$todir/" \
-     | tee "$outfile"
- cat <<EOT >"$chkfile"
--.f...p... foo/config1
-->f..t.... foo/config2
-+.f....p... foo/config1
-+>f..t..... foo/config2
- EOT
- diff $diffopt "$chkfile" "$outfile" || test_fail "test 7 failed"
- 
-@@ -149,15 +149,15 @@ $RSYNC -ivvplrtH --copy-dest="$lddir" "$
-     | tee "$outfile"
- filter_outfile
- cat <<EOT >"$chkfile"
--.d..t.... ./
--cd+++++++ bar/
--cd+++++++ bar/baz/
--cf....... bar/baz/rsync
--cd+++++++ foo/
--cf....... foo/config1
--cf....... foo/config2
--hf+++++++ foo/extra => foo/config1
--cL+++++++ foo/sym -> ../bar/baz/rsync
-+.d..t..... ./
-+cd++++++++ bar/
-+cd++++++++ bar/baz/
-+cf........ bar/baz/rsync
-+cd++++++++ foo/
-+cf........ foo/config1
-+cf........ foo/config2
-+hf++++++++ foo/extra => foo/config1
-+cL++++++++ foo/sym -> ../bar/baz/rsync
- EOT
- diff $diffopt "$chkfile" "$outfile" || test_fail "test 8 failed"
- 
-@@ -165,12 +165,12 @@ rm -rf "$todir"
- $RSYNC -iplrtH --link-dest="$lddir" "$fromdir/" "$todir/" \
-     | tee "$outfile"
- cat <<EOT >"$chkfile"
--.d..t.... ./
--cd+++++++ bar/
--cd+++++++ bar/baz/
--cd+++++++ foo/
--hf+++++++ foo/extra => foo/config1
--cL+++++++ foo/sym -> ../bar/baz/rsync
-+.d..t..... ./
-+cd++++++++ bar/
-+cd++++++++ bar/baz/
-+cd++++++++ foo/
-+hf++++++++ foo/extra => foo/config1
-+cL++++++++ foo/sym -> ../bar/baz/rsync
- EOT
- diff $diffopt "$chkfile" "$outfile" || test_fail "test 9 failed"
- 
---- orig/testsuite/rsync.fns	2005-06-10 20:04:11
-+++ testsuite/rsync.fns	2005-07-28 00:41:20
-@@ -50,7 +50,7 @@ printmsg() {
- 
+--- old/testsuite/rsync.fns
++++ new/testsuite/rsync.fns
+@@ -66,7 +66,7 @@ printmsg() {
+ }
  
  rsync_ls_lR() {
 -    find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls"
 +    find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls" $TLS_ARGS
  }
  
- rsync_getgroups() { 
-@@ -158,6 +158,10 @@ checkit() {
+ check_perms() {
+@@ -184,6 +184,10 @@ checkit() {
      # We can just write everything to stdout/stderr, because the
      # wrapper hides it unless there is a problem.
  
 +    if test x$TLS_ARGS = x--atime; then
 +	( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
 +    fi
 +
      echo "Running: \"$1\""  
      eval "$1" 
      status=$?
-@@ -165,10 +169,13 @@ checkit() {
+@@ -191,10 +195,13 @@ checkit() {
  	failed="YES";
      fi
  
 +    if test x$TLS_ARGS != x--atime; then
 +	( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
 +    fi
@@ -588,14 +648,14 @@
      echo "check how the directory listings compare with diff:"
      echo ""
 -    ( cd "$2" && rsync_ls_lR . ) > "$tmpdir/ls-from"
      ( cd "$3" && rsync_ls_lR . ) > "$tmpdir/ls-to"
      diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to" || failed=YES
  
---- orig/tls.c	2005-01-19 19:30:29
-+++ tls.c	2005-03-23 17:49:48
+--- old/tls.c
++++ new/tls.c
 @@ -39,6 +39,7 @@
  
  
  #include "rsync.h"
 +#include "popt.h"
  
@@ -616,18 +676,18 @@
 +static void storetime(char *dest, time_t t)
 +{
 +	if (t) {
 +		struct tm *mt = gmtime(&t);
  
 +		sprintf(dest, "%04d-%02d-%02d %02d:%02d:%02d ",
-+			mt->tm_year + 1900,
-+			mt->tm_mon + 1,
-+			mt->tm_mday,
-+			mt->tm_hour,
-+			mt->tm_min,
-+			mt->tm_sec);
++			(int)mt->tm_year + 1900,
++			(int)mt->tm_mon + 1,
++			(int)mt->tm_mday,
++			(int)mt->tm_hour,
++			(int)mt->tm_min,
++			(int)mt->tm_sec);
 +	} else {
 +		strcpy(dest, "                    ");
 +	}
 +}	
  
  static void list_file(const char *fname)
@@ -646,18 +706,18 @@
  	permstring(permbuf, buf.st_mode);
  
 -	if (buf.st_mtime) {
 -		mt = gmtime(&buf.st_mtime);
 -
 -		sprintf(datebuf, "%04d-%02d-%02d %02d:%02d:%02d",
--			mt->tm_year + 1900,
--			mt->tm_mon + 1,
--			mt->tm_mday,
--			mt->tm_hour,
--			mt->tm_min,
--			mt->tm_sec);
+-			(int)mt->tm_year + 1900,
+-			(int)mt->tm_mon + 1,
+-			(int)mt->tm_mday,
+-			(int)mt->tm_hour,
+-			(int)mt->tm_min,
+-			(int)mt->tm_sec);
 -	} else {
 -		strcpy(datebuf, "                   ");
 -	}
 +	storetime(mtimebuf, buf.st_mtime);
 +	storetime(atimebuf, buf.st_atime);
  
@@ -725,69 +785,126 @@
 +	for (; *extra_args; extra_args++)
 +		list_file(*extra_args);
 +	poptFreeContext(pc);
  
  	return 0;
  }
---- orig/util.c	2005-07-28 18:48:39
-+++ util.c	2005-07-28 18:54:19
-@@ -128,12 +128,16 @@ void overflow_exit(char *str)
- 
- 
+--- old/util.c
++++ new/util.c
+@@ -126,7 +126,7 @@ void overflow_exit(char *str)
+ 	exit_cleanup(RERR_MALLOC);
+ }
  
--int set_modtime(char *fname, time_t modtime)
-+int set_times(char *fname, time_t modtime, time_t atime)
+-int set_modtime(char *fname, time_t modtime, mode_t mode)
++int set_times(char *fname, time_t modtime, time_t atime, mode_t mode)
  {
+ #if !defined HAVE_LUTIMES || !defined HAVE_UTIMES
+ 	if (S_ISLNK(mode))
+@@ -134,9 +134,13 @@ int set_modtime(char *fname, time_t modt
+ #endif
+ 
  	if (verbose > 2) {
 -		rprintf(FINFO, "set modtime of %s to (%ld) %s",
 +		char mtimebuf[200];
 +
 +		strlcpy(mtimebuf, timestring(modtime), sizeof mtimebuf);
 +		rprintf(FINFO,
 +			"set modtime, atime of %s to (%ld) %s, (%ld) %s\n",
- 			safe_fname(fname), (long)modtime,
+ 			fname, (long)modtime,
 -			asctime(localtime(&modtime)));
 +			mtimebuf, (long)atime, timestring(atime));
  	}
  
  	if (dry_run)
-@@ -142,17 +146,17 @@ int set_modtime(char *fname, time_t modt
+@@ -145,7 +149,7 @@ int set_modtime(char *fname, time_t modt
  	{
- #ifdef HAVE_UTIMBUF
+ #ifdef HAVE_UTIMES
+ 		struct timeval t[2];
+-		t[0].tv_sec = time(NULL);
++		t[0].tv_sec = atime;
+ 		t[0].tv_usec = 0;
+ 		t[1].tv_sec = modtime;
+ 		t[1].tv_usec = 0;
+@@ -156,12 +160,12 @@ int set_modtime(char *fname, time_t modt
+ 		return utimes(fname, t);
+ #elif defined HAVE_UTIMBUF
  		struct utimbuf tbuf;
 -		tbuf.actime = time(NULL);
 +		tbuf.actime = atime;
  		tbuf.modtime = modtime;
  		return utime(fname,&tbuf);
  #elif defined HAVE_UTIME
  		time_t t[2];
 -		t[0] = time(NULL);
 +		t[0] = atime;
  		t[1] = modtime;
  		return utime(fname,t);
  #else
- 		struct timeval t[2];
--		t[0].tv_sec = time(NULL);
-+		t[0].tv_sec = atime;
- 		t[0].tv_usec = 0;
- 		t[1].tv_sec = modtime;
- 		t[1].tv_usec = 0;
-@@ -1156,8 +1160,8 @@ int msleep(int t)
- 
- 
- /**
-- * Determine if two file modification times are equivalent (either
-- * exact or in the modification timestamp window established by
-+ * Determine if two file  times are equivalent (either
-+ * exact or in the timestamp window established by
-  * --modify-window).
-  *
-  * @retval 0 if the times should be treated as the same
-@@ -1166,7 +1170,7 @@ int msleep(int t)
-  *
-  * @retval -1 if the 2nd is later
-  **/
--int cmp_modtime(time_t file1, time_t file2)
-+int cmp_time(time_t file1, time_t file2)
- {
- 	if (file2 > file1) {
- 		if (file2 - file1 <= modify_window)
+--- old/proto.h
++++ new/proto.h
+@@ -279,7 +279,7 @@ int fd_pair(int fd[2]);
+ void print_child_argv(char **cmd);
+ void out_of_memory(char *str);
+ void overflow_exit(char *str);
+-int set_modtime(char *fname, time_t modtime, mode_t mode);
++int set_times(char *fname, time_t modtime, time_t atime, mode_t mode);
+ int mkdir_defmode(char *fname);
+ int create_directory_path(char *fname);
+ int full_write(int desc, char *ptr, size_t len);
+--- old/rsync.1
++++ new/rsync.1
+@@ -383,8 +383,9 @@ to the detailed description below for a 
+      --devices               preserve device files (super-user only)
+      --specials              preserve special files
+  -D                          same as --devices --specials
+- -t, --times                 preserve times
+- -O, --omit-dir-times        omit directories when preserving times
++ -t, --times                 preserve modify times
++ -O, --omit-dir-times        omit directories when preserving mod-times
++ -U, --atimes                preserve access (use) times
+      --super                 receiver attempts super-user activities
+  -S, --sparse                handle sparse files efficiently
+  -n, --dry-run               show what would have been transferred
+@@ -971,6 +972,13 @@ it is preserving modification times (see
+ the directories on the receiving side, it is a good idea to use \fB-O\fP\&.
+ This option is inferred if you use \fB--backup\fP without \fB--backup-dir\fP\&.
+ .IP 
++.IP "\fB-U, --atimes\fP" 
++This tells rsync to set the access (use) times of the
++destination files to the same value as the source files\&.  Note that the
++reading of the source file may update the atime of the source files, so
++repeated rsync runs with --atimes may be needed if you want to force the
++access-time values to be 100% identical on the two systems\&.
++.IP 
+ .IP "\fB--super\fP" 
+ This tells the receiving side to attempt super-user
+ activities even if the receiving rsync wasn\&'t run by the super-user\&.  These
+@@ -1552,7 +1560,7 @@ with older versions of rsync, but that a
+ verbose messages)\&.
+ .IP 
+ The "%i" escape has a cryptic output that is 9 letters long\&.  The general
+-format is like the string \fBYXcstpogz\fP, where \fBY\fP is replaced by the
++format is like the string \fBYXcstpogu\fP, where \fBY\fP is replaced by the
+ type of update being done, \fBX\fP is replaced by the file-type, and the
+ other letters represent attributes that may be output if they are being
+ modified\&.
+@@ -1600,7 +1608,7 @@ by the file transfer\&.
+ .IP o 
+ A \fBt\fP means the modification time is different and is being updated
+ to the sender\&'s value (requires \fB--times\fP)\&.  An alternate value of \fBT\fP
+-means that the time will be set to the transfer time, which happens
++means that the modify time will be set to the transfer time, which happens
+ anytime a symlink is transferred, or when a file or device is transferred
+ without \fB--times\fP\&.
+ .IP o 
+@@ -1613,7 +1621,10 @@ sender\&'s value (requires \fB--owner\fP
+ A \fBg\fP means the group is different and is being updated to the
+ sender\&'s value (requires \fB--group\fP and the authority to set the group)\&.
+ .IP o 
+-The \fBz\fP slot is reserved for future use\&.
++A \fBu\fP means the access (use) time is different and is being updated to
++the sender\&'s value (requires \fB--atimes\fP)\&.  An alternate value of \fBU\fP
++means that the access time will be set to the transfer time, which happens
++when a symlink or directory is updated\&.
+ .RE 
+ .IP 
+ One other output is possible:  when deleting files, the "%i" will output
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/backup-dir-dels.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/backup-dir-dels.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/backup-dir-dels.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/backup-dir-dels.diff	2006-03-12 02:44:32.000000000 +0800
@@ -10,19 +10,17 @@
 The default behaviour if one or both of the options are not specified
 is the previous behaviour, both backups use the same directory or
 suffix.
 
 Marc St-Onge
 
---- orig/backup.c	2005-06-10 17:57:18
-+++ backup.c	2005-02-22 02:11:15
-@@ -22,11 +22,17 @@
+--- old/backup.c
++++ new/backup.c
+@@ -22,10 +22,15 @@
  
  extern int verbose;
- extern int backup_suffix_len;
-+extern int backup_suffix_dels_len;
  extern int backup_dir_len;
 +extern int backup_dir_dels_len;
  extern unsigned int backup_dir_remainder;
 +extern unsigned int backup_dir_dels_remainder;
  extern char backup_dir_buf[MAXPATHLEN];
 +extern char backup_dir_dels_buf[MAXPATHLEN];
@@ -30,22 +28,22 @@
 +extern char *backup_suffix_dels;
  extern char *backup_dir;
 +extern char *backup_dir_dels;
  
  extern int am_root;
  extern int preserve_devices;
-@@ -35,6 +41,8 @@ extern int preserve_hard_links;
- extern int orig_umask;
+@@ -33,6 +38,8 @@ extern int preserve_specials;
+ extern int preserve_links;
  extern int safe_symlinks;
  
 +static int deleting;
 +
  /* make a complete pathname for backup file */
  char *get_backup_name(char *fname)
  {
-@@ -52,11 +60,28 @@ char *get_backup_name(char *fname)
+@@ -50,11 +57,28 @@ char *get_backup_name(char *fname)
  	return NULL;
  }
  
 +static char *get_delete_name(char *fname)
 +{
 +	if (backup_dir_dels) {
@@ -69,33 +67,33 @@
 -	char *fnamebak = get_backup_name(fname);
 +	char *fnamebak = deleting ? get_delete_name(fname)
 +				  : get_backup_name(fname);
  
  	if (!fnamebak)
  		return 0;
-@@ -97,7 +122,8 @@ path
+@@ -94,7 +118,8 @@ path
  static int make_bak_dir(char *fullpath)
  {
  	STRUCT_STAT st;
 -	char *rel = fullpath + backup_dir_len;
 +	int dir_len = deleting ? backup_dir_dels_len : backup_dir_len;
 +	char *rel = fullpath + dir_len;
  	char *end = rel + strlen(rel);
  	char *p = end;
  
-@@ -184,7 +210,8 @@ static int keep_backup(char *fname)
- 	if (!(file = make_file(fname, NULL, NO_FILTERS)))
+@@ -182,7 +207,8 @@ static int keep_backup(char *fname)
+ 	if (!(file = make_file(fname, NULL, NULL, 0, NO_FILTERS)))
  		return 1; /* the file could have disappeared */
  
 -	if (!(buf = get_backup_name(fname)))
 +	buf = deleting ? get_delete_name(fname) : get_backup_name(fname);
 +	if (!buf)
  		return 0;
  
  	/* Check to see if this is a device file, or link */
-@@ -278,3 +305,13 @@ int make_backup(char *fname)
+@@ -277,3 +303,13 @@ int make_backup(char *fname)
  		return keep_backup(fname);
  	return make_simple_backup(fname);
  }
 +
 +/* backup switch routine called only when backing-up removed file */
 +int safe_delete(char *fname)
@@ -103,25 +101,26 @@
 +	int ret;
 +	deleting = 1;
 +	ret = make_backup(fname);
 +	deleting = 0;
 +	return ret;
 +}
---- orig/generator.c	2005-07-28 19:00:14
-+++ generator.c	2005-03-11 11:22:38
-@@ -86,16 +86,23 @@ extern dev_t filesystem_dev;
+--- old/generator.c
++++ new/generator.c
+@@ -90,6 +90,9 @@ extern dev_t filesystem_dev;
  extern char *backup_dir;
  extern char *backup_suffix;
  extern int backup_suffix_len;
 +extern char *backup_dir_dels;
 +extern char *backup_suffix_dels;
 +extern int backup_suffix_dels_len;
  extern struct file_list *the_file_list;
  extern struct filter_list_struct server_filter_list;
  
- static int deletion_count = 0; /* used to implement --max-delete */
+@@ -102,10 +105,14 @@ static int can_link_devices = 1;
+ #define DEL_TERSE		(1<<3)
  
  
 +/* Function now compares both backup_suffix and backup_suffix_dels. */
  static int is_backup_file(char *fn)
  {
  	int k = strlen(fn) - backup_suffix_len;
@@ -130,38 +129,38 @@
 +		return 1;
 +	k += backup_suffix_len - backup_suffix_dels_len;
 +	return k > 0 && strcmp(fn+k, backup_suffix_dels) == 0;
  }
  
  
-@@ -112,8 +119,8 @@ static int delete_item(char *fname, int 
+@@ -126,8 +133,8 @@ static int delete_item(char *fname, int 
  	if (!S_ISDIR(mode)) {
  		if (max_delete && ++deletion_count > max_delete)
  			return 0;
 -		if (make_backups && (backup_dir || !is_backup_file(fname)))
 -			ok = make_backup(fname);
 +		if (make_backups && (backup_dir_dels || !is_backup_file(fname)))
 +			ok = safe_delete(fname);
  		else
  			ok = robust_unlink(fname) == 0;
  		if (ok) {
-@@ -136,9 +143,9 @@ static int delete_item(char *fname, int 
+@@ -149,9 +156,9 @@ static int delete_item(char *fname, int 
  	    || (dry_run && zap_dir)) {
  		ok = 0;
  		errno = ENOTEMPTY;
 -	} else if (make_backups && !backup_dir && !is_backup_file(fname)
 +	} else if (make_backups && !backup_dir_dels && !is_backup_file(fname)
  	    && !(flags & DEL_FORCE_RECURSE))
 -		ok = make_backup(fname);
 +		ok = safe_delete(fname);
  	else
  		ok = do_rmdir(fname) == 0;
  	if (ok) {
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-03-01 01:25:39
-@@ -128,10 +128,14 @@ int no_detach
+--- old/options.c
++++ new/options.c
+@@ -138,10 +138,14 @@ int no_detach
  int write_batch = 0;
  int read_batch = 0;
  int backup_dir_len = 0;
 +int backup_dir_dels_len = 0;	
  int backup_suffix_len;
 +int backup_suffix_dels_len;
@@ -170,57 +169,51 @@
  
  char *backup_suffix = NULL;
 +char *backup_suffix_dels = NULL;
  char *tmpdir = NULL;
  char *partial_dir = NULL;
  char *basis_dir[MAX_BASIS_DIRS+1];
-@@ -141,7 +145,9 @@ char *log_format = NULL;
+@@ -151,7 +155,9 @@ char *log_format = NULL;
  char *password_file = NULL;
  char *rsync_path = RSYNC_PATH;
  char *backup_dir = NULL;
 +char *backup_dir_dels = NULL;
  char backup_dir_buf[MAXPATHLEN];
 +char backup_dir_dels_buf[MAXPATHLEN];
+ char *sockopts = NULL;
  int rsync_port = 0;
  int compare_dest = 0;
- int copy_dest = 0;
-@@ -272,6 +278,8 @@ void usage(enum logcode F)
+@@ -282,6 +288,8 @@ void usage(enum logcode F)
    rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
    rprintf(F,"     --backup-dir=DIR        make backups into hierarchy based in DIR\n");
    rprintf(F,"     --suffix=SUFFIX         set backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
 +  rprintf(F,"     --backup-dir-dels       make backups of removed files into current dir\n");
 +  rprintf(F,"     --suffix-dels=SUFFIX    set removed-files suffix (defaults to --suffix)\n");
    rprintf(F," -u, --update                skip files that are newer on the receiver\n");
    rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
-   rprintf(F," -d, --dirs                  transfer directories without recursing\n");
-@@ -370,6 +378,7 @@ static struct poptOption long_options[] 
-   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
-   {"version",          0,  POPT_ARG_NONE,   0, OPT_VERSION, 0, 0},
-   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
-+  {"suffix-dels",      0,  POPT_ARG_STRING, &backup_suffix_dels, 0, 0, 0 },
-   {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
-   {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
-   {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
-@@ -451,6 +460,7 @@ static struct poptOption long_options[] 
-   {"itemize-changes", 'i', POPT_ARG_NONE,   &itemize_changes, 0, 0, 0 },
+   rprintf(F,"     --append                append data onto shorter files\n");
+@@ -499,7 +507,9 @@ static struct poptOption long_options[] 
    {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
+   {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
    {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
 +  {"backup-dir-dels",  0,  POPT_ARG_STRING, &backup_dir_dels, 0, 0, 0 },
-   {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
+   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
++  {"suffix-dels",      0,  POPT_ARG_STRING, &backup_suffix_dels, 0, 0, 0 },
+   {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
    {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
    {"write-batch",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },
-@@ -1021,6 +1031,8 @@ int parse_arguments(int *argc, const cha
+@@ -1214,6 +1224,8 @@ int parse_arguments(int *argc, const cha
  			partial_dir = sanitize_path(NULL, partial_dir, NULL, 0);
  		if (backup_dir)
  			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0);
 +		if (backup_dir_dels)							
 +			backup_dir_dels = sanitize_path(NULL, backup_dir_dels, NULL, 0);
  	}
  	if (server_filter_list.head && !am_sender) {
  		struct filter_list_struct *elp = &server_filter_list;
-@@ -1055,6 +1067,14 @@ int parse_arguments(int *argc, const cha
+@@ -1248,6 +1260,14 @@ int parse_arguments(int *argc, const cha
  				return 0;
  			}
  		}
 +		/* Clean backup_dir_dels same as for backup_dir */
 +		if (backup_dir_dels) {
 +			if (!*backup_dir_dels)
@@ -229,13 +222,13 @@
 +			if (check_filter(elp, backup_dir_dels, 1) < 0)
 +				goto options_rejected;
 +		}
  	}
  
  	if (!backup_suffix)
-@@ -1066,6 +1086,16 @@ int parse_arguments(int *argc, const cha
+@@ -1259,6 +1279,16 @@ int parse_arguments(int *argc, const cha
  			backup_suffix);
  		return 0;
  	}
 +	/* if backup_suffix_dels not supplied, default to backup_suffix */
 +	if (!backup_suffix_dels)
 +		backup_suffix_dels = backup_dir_dels ? "" : backup_suffix;
@@ -246,15 +239,15 @@
 +			backup_suffix_dels);	
 +		return 0;
 +	}
  	if (backup_dir) {
  		backup_dir_len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
  		backup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;
-@@ -1087,6 +1117,31 @@ int parse_arguments(int *argc, const cha
- 			"--suffix cannot be a null string without --backup-dir\n");
- 		return 0;
+@@ -1282,6 +1312,31 @@ int parse_arguments(int *argc, const cha
+ 			"P *%s", backup_suffix);
+ 		parse_rule(&filter_list, backup_dir_buf, 0, 0);
  	}
 +	/* If backup_dir_dels not supplied default to backup_dir if it has been supplied */
 +	if (backup_dir && !backup_dir_dels) {
 +		backup_dir_dels = backup_dir;
 +		backup_dir_dels_len = backup_dir_len;
 +		backup_dir_dels_remainder = backup_dir_remainder;
@@ -278,24 +271,24 @@
 +			"--suffix-dels cannot be a null string without --backup-dir-dels\n");
 +		return 0;
 +	}
  	if (make_backups && !backup_dir)
  		omit_dir_times = 1;
  
-@@ -1369,6 +1424,10 @@ void server_options(char **args,int *arg
+@@ -1626,6 +1681,10 @@ void server_options(char **args,int *arg
  		args[ac++] = "--backup-dir";
  		args[ac++] = backup_dir;
  	}
-+	if (backup_dir_dels) {
++	if (backup_dir_dels && backup_dir_dels != backup_dir) {
 +		args[ac++] = "--backup-dir-dels";
 +		args[ac++] = backup_dir_dels;
 +	}
  
  	/* Only send --suffix if it specifies a non-default value. */
  	if (strcmp(backup_suffix, backup_dir ? "" : BACKUP_SUFFIX) != 0) {
-@@ -1377,7 +1436,13 @@ void server_options(char **args,int *arg
+@@ -1634,7 +1693,13 @@ void server_options(char **args,int *arg
  			goto oom;
  		args[ac++] = arg;
  	}
 -
 +	/* Only send --suffix-dels if it specifies a non-default value. */
 +	if (strcmp(backup_suffix_dels, backup_dir_dels ? "" : BACKUP_SUFFIX) != 0) {
@@ -304,6 +297,16 @@
 +			goto oom;
 +		args[ac++] = arg;
 +	}
  	if (am_sender) {
  		if (delete_excluded)
  			args[ac++] = "--delete-excluded";
+--- old/proto.h
++++ new/proto.h
+@@ -7,6 +7,7 @@ char *auth_server(int f_in, int f_out, i
+ void auth_client(int fd, char *user, char *challenge);
+ char *get_backup_name(char *fname);
+ int make_backup(char *fname);
++int safe_delete(char *fname);
+ void write_stream_flags(int fd);
+ void read_stream_flags(int fd);
+ void write_batch_shell_file(int argc, char *argv[], int file_arg_cnt);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: catch_crash_signals.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches: chmod-option.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/cvs-entries.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/cvs-entries.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/cvs-entries.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/cvs-entries.diff	2006-02-06 14:32:33.000000000 +0800
@@ -1,13 +1,22 @@
 This patch causes the --cvs-exclude option to prefix the names listed
 in each dir's CVS/Entries file as per-dir includes before the dir's list
 of excludes taken from the .cvsignore file.
 
---- orig/exclude.c	2005-07-07 19:49:14
-+++ exclude.c	2005-04-07 18:06:34
-@@ -442,6 +442,14 @@ void *push_local_filters(const char *dir
+--- old/exclude.c
++++ new/exclude.c
+@@ -221,6 +221,8 @@ static void add_rule(struct filter_list_
+ 		if (!(lp = new_array(struct filter_list_struct, 1)))
+ 			out_of_memory("add_rule");
+ 		lp->head = lp->tail = NULL;
++		if (mflags & MATCHFLG_CVS_IGNORE)
++			cp = "CVS";
+ 		if (asprintf(&lp->debug_type, " [per-dir %s]", cp) < 0)
+ 			out_of_memory("add_rule");
+ 		ret->u.mergelist = lp;
+@@ -454,6 +456,14 @@ void *push_local_filters(const char *dir
  				set_filter_dir(dir, dirlen);
  		}
  
 +		if (ex->match_flags & MATCHFLG_CVS_IGNORE
 +		    && strlcpy(dirbuf + dirbuf_len, "CVS/Entries",
 +			MAXPATHLEN - dirbuf_len) < MAXPATHLEN - dirbuf_len) {
@@ -16,62 +25,130 @@
 +				      MATCHFLG_NO_PREFIXES | MATCHFLG_INCLUDE,
 +				      XFLG_CVS_ENTRIES);
 +		}
  		if (strlcpy(dirbuf + dirbuf_len, ex->pattern,
  		    MAXPATHLEN - dirbuf_len) < MAXPATHLEN - dirbuf_len) {
  			parse_filter_file(lp, dirbuf, ex->match_flags,
-@@ -957,6 +965,7 @@ void parse_filter_file(struct filter_lis
- 	char line[MAXPATHLEN+MAX_RULE_PREFIX+1]; /* +1 for trailing slash. */
+@@ -970,6 +980,7 @@ void parse_filter_file(struct filter_lis
+ 	char line[BIGPATHBUFLEN];
  	char *eob = line + sizeof line - 1;
  	int word_split = mflags & MATCHFLG_WORD_SPLIT;
 +	int slash_parse = xflags & XFLG_CVS_ENTRIES ? 1 : 0;
  
  	if (!fname || !*fname)
  		return;
-@@ -1001,6 +1010,29 @@ void parse_filter_file(struct filter_lis
- 					continue;
+@@ -1016,6 +1027,24 @@ void parse_filter_file(struct filter_lis
+ 				}
  				break;
  			}
-+			switch (slash_parse) {
-+			case 1:
-+				if (ch == '/') {
-+					s = line;
++			switch (slash_parse) { /* CVS/Entries parsing: */
++			case 1: /* Ignore starting chars until first slash. */
++				if (ch == '/')
 +					slash_parse = 2;
-+					continue;
-+				}
-+				break;
-+			case 2:
++				continue;
++			case 2: /* Name ends at 2nd slash on the line. */
 +				if (ch == '/') {
 +					slash_parse = 3;
 +					continue;
 +				}
 +				break;
-+			case 3:
++			case 3: /* Ignore trailing chars until EOL. */
 +				if (ch == '\n' || ch == '\r') {
 +					slash_parse = 1;
-+					goto double_break;
++					goto end_the_line;
 +				}
 +				continue;
-+			default:
-+				break;
 +			}
  			if (word_split && isspace(ch))
  				break;
  			if (eol_nulls? !ch : (ch == '\n' || ch == '\r'))
-@@ -1010,6 +1042,7 @@ void parse_filter_file(struct filter_lis
+@@ -1025,13 +1054,15 @@ void parse_filter_file(struct filter_lis
  			else
  				overflow = 1;
  		}
-+	    double_break:
++	  end_the_line:
  		if (overflow) {
  			rprintf(FERROR, "discarding over-long filter: %s...\n", line);
  			s = line;
---- orig/rsync.h	2005-05-03 17:00:47
-+++ rsync.h	2005-04-07 18:06:34
-@@ -115,6 +115,7 @@
- #define XFLG_FATAL_ERRORS	(1<<0)
+ 		}
+ 		*s = '\0';
+ 		/* Skip an empty token and (when line parsing) comments. */
+-		if (*line && (word_split || (*line != ';' && *line != '#')))
++		if (*line && (word_split || slash_parse
++			   || (*line != ';' && *line != '#')))
+ 			parse_rule(listp, line, mflags, xflags);
+ 		if (ch == EOF)
+ 			break;
+--- old/rsync.h
++++ new/rsync.h
+@@ -116,6 +116,7 @@
  #define XFLG_OLD_PREFIXES	(1<<1)
  #define XFLG_ANCHORED2ABS	(1<<2)
-+#define XFLG_CVS_ENTRIES	(1<<3)
+ #define XFLG_ABS_IF_SLASH	(1<<3)
++#define XFLG_CVS_ENTRIES	(1<<4)
+ 
+ #define ATTRS_REPORT		(1<<0)
+ #define ATTRS_SKIP_MTIME	(1<<1)
+--- old/testsuite/exclude.test
++++ new/testsuite/exclude.test
+@@ -19,6 +19,7 @@ export CVSIGNORE
+ 
+ makepath "$fromdir/foo/down/to/you"
+ makepath "$fromdir/foo/sub"
++makepath "$fromdir/bar/down/to/CVS"
+ makepath "$fromdir/bar/down/to/foo/too"
+ makepath "$fromdir/bar/down/to/bar/baz"
+ makepath "$fromdir/mid/for/foo/and/that/is/who"
+@@ -57,6 +58,9 @@ echo cvsout >"$fromdir/bar/down/to/foo/f
+ echo gone >"$fromdir/bar/down/to/foo/file3"
+ echo lost >"$fromdir/bar/down/to/foo/file4"
+ echo weird >"$fromdir/bar/down/to/foo/+ file3"
++echo cvsin >"$fromdir/bar/down/to/not.junk"
++echo cvsout >"$fromdir/bar/down/to/not.good"
++echo cvsout >"$fromdir/bar/down/to/D"
+ echo cvsout-but-filtin >"$fromdir/bar/down/to/foo/file4.junk"
+ echo smashed >"$fromdir/bar/down/to/foo/to"
+ cat >"$fromdir/bar/down/to/bar/.filt2" <<EOF
+@@ -103,7 +107,18 @@ cat >"$excl" <<EOF
+ EOF
+ 
+ cat >"$scratchdir/.cvsignore" <<EOF
+-home-cvs-exclude
++home-cvs-exclude D
++EOF
++cat >"$fromdir/bar/down/to/CVS/Entries" <<EOF
++/not.junk/1.1/Mon Jan  1 11:11:11 2001//
++filt2
++/another.file/1.1/Tue Jan  1 22:22:22 2002//
++invalid lines should just be ignored...
++D/directory////
++D
++EOF
++cat >"$fromdir/bar/down/to/.cvsignore" <<EOF
++not.good
+ EOF
+ 
+ # Create the chk dir with what we expect to be excluded
+@@ -132,6 +147,10 @@ checkit "$RSYNC -avv --exclude-from=\"$e
+ # Modify the chk dir by removing cvs-ignored files and then tweaking the dir times.
+ 
+ rm "$chkdir"/foo/*.old
++rm "$chkdir"/bar/down/to/D
++rm "$chkdir"/bar/down/to/CVS/Entries
++rmdir "$chkdir"/bar/down/to/CVS
++rm "$chkdir"/bar/down/to/not.good
+ rm "$chkdir"/bar/down/to/foo/*.bak
+ rm "$chkdir"/bar/down/to/foo/*.junk
+ rm "$chkdir"/bar/down/to/home-cvs-exclude
+@@ -147,8 +166,12 @@ checkit "$RSYNC -avvC --filter=\"merge $
+ 
+ # Modify the chk dir for our merge-exclude test and then tweak the dir times.
+ 
++makepath "$chkdir/bar/down/to/CVS"
+ rm "$chkdir"/foo/file1
+ rm "$chkdir"/bar/down/to/bar/baz/*.deep
++cp -p "$fromdir"/bar/down/to/D "$chkdir"/bar/down/to/D
++cp -p "$fromdir"/bar/down/to/not.good "$chkdir"/bar/down/to/not.good
++cp -p "$fromdir"/bar/down/to/CVS/Entries "$chkdir"/bar/down/to/CVS/Entries
+ cp -p "$fromdir"/bar/down/to/foo/*.junk "$chkdir"/bar/down/to/foo
+ cp -p "$fromdir"/bar/down/to/foo/to "$chkdir"/bar/down/to/foo
  
- #define PERMS_REPORT		(1<<0)
- #define PERMS_SKIP_MTIME	(1<<1)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/date-only.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/date-only.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/date-only.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/date-only.diff	2006-03-12 02:45:00.000000000 +0800
@@ -12,84 +12,108 @@
 
 Best Regards,
 Jeremy Bornstein
 
 [Patched update to have context and apply to latest CVS source.]
 
---- orig/generator.c	2005-07-28 19:00:14
-+++ generator.c	2004-11-11 22:15:27
-@@ -57,6 +57,7 @@ extern int inplace;
+--- old/generator.c
++++ new/generator.c
+@@ -61,6 +61,7 @@ extern int append_mode;
  extern int make_backups;
  extern int csum_length;
  extern int ignore_times;
 +extern int date_only;
  extern int size_only;
  extern OFF_T max_size;
- extern int io_error;
-@@ -359,6 +360,8 @@ void itemize(struct file_struct *file, i
+ extern OFF_T min_size;
+@@ -378,6 +379,8 @@ void itemize(struct file_struct *file, i
  /* Perform our quick-check heuristic for determining if a file is unchanged. */
- static int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
+ int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
  {
 +	if (date_only)
-+		return cmp_modtime(st->st_mtime, file->modtime) == 0;
++		return cmp_time(st->st_mtime, file->modtime) == 0;
  	if (st->st_size != file->length)
  		return 0;
  
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-01-28 19:14:15
-@@ -90,6 +90,7 @@ int keep_partial = 0;
+--- old/options.c
++++ new/options.c
+@@ -99,6 +99,7 @@ int keep_partial = 0;
  int safe_symlinks = 0;
  int copy_unsafe_links = 0;
  int size_only = 0;
 +int date_only = 0;
  int daemon_bwlimit = 0;
  int bwlimit = 0;
  int fuzzy_basis = 0;
-@@ -315,6 +316,7 @@ void usage(enum logcode F)
+@@ -333,6 +334,7 @@ void usage(enum logcode F)
    rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
    rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
    rprintf(F,"     --size-only             skip files that match in size\n");
 +  rprintf(F,"     --date-only             skip files that match in mod-time\n");
    rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
    rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
    rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
-@@ -374,6 +376,7 @@ static struct poptOption long_options[] 
-   {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
+@@ -448,6 +450,7 @@ static struct poptOption long_options[] 
+   {"chmod",            0,  POPT_ARG_STRING, 0, OPT_CHMOD, 0, 0 },
    {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
    {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
 +  {"date-only",        0,  POPT_ARG_NONE,   &date_only, 0, 0, 0 },
-   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
-   {"one-file-system", 'x', POPT_ARG_NONE,   &one_file_system, 0, 0, 0 },
-   {"existing",         0,  POPT_ARG_NONE,   &only_existing, 0, 0, 0 },
-@@ -1398,6 +1401,9 @@ void server_options(char **args,int *arg
- 	if (size_only)
- 		args[ac++] = "--size-only";
+   {"one-file-system", 'x', POPT_ARG_NONE,   0, 'x', 0, 0 },
+   {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
+   {"existing",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
+@@ -1656,6 +1659,9 @@ void server_options(char **args,int *arg
+ 			args[ac++] = "--size-only";
+ 	}
  
 +	if (date_only)
 +		args[ac++] = "--date-only";
 +
  	if (modify_window_set) {
  		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
  			goto oom;
---- orig/rsync.yo	2005-07-28 19:26:48
-+++ rsync.yo	2005-02-11 22:49:10
-@@ -348,6 +348,7 @@ to the detailed description below for a 
+--- old/rsync.yo
++++ new/rsync.yo
+@@ -359,6 +359,7 @@ to the detailed description below for a 
       --timeout=TIME          set I/O timeout in seconds
   -I, --ignore-times          don't skip files that match size and time
       --size-only             skip files that match in size
 +     --date-only             skip files that match in mod-time
       --modify-window=NUM     compare mod-times with reduced accuracy
   -T, --temp-dir=DIR          create temporary files in directory DIR
   -y, --fuzzy                 find similar file for basis if no dest file
-@@ -447,6 +448,12 @@ regardless of timestamp. This is useful 
+@@ -466,6 +467,12 @@ regardless of timestamp. This is useful 
  after using another mirroring system which may not preserve timestamps
  exactly.
  
 +dit(bf(--date-only)) Normally rsync will skip any files that are
 +already the same size and have the same modification time-stamp. With the
 +--date-only option, files will be skipped if they have the same
 +timestamp, regardless of size. This may be useful when the remote
 +files have passed through a size-changing filter, e.g. for encryption.
 +
  dit(bf(--modify-window)) When comparing two timestamps, rsync treats the
  timestamps as being equal if they differ by no more than the modify-window
  value.  This is normally 0 (for an exact match), but you may find it useful
+--- old/rsync.1
++++ new/rsync.1
+@@ -415,6 +415,7 @@ to the detailed description below for a 
+      --timeout=TIME          set I/O timeout in seconds
+  -I, --ignore-times          don\&'t skip files that match size and time
+      --size-only             skip files that match in size
++     --date-only             skip files that match in mod-time
+      --modify-window=NUM     compare mod-times with reduced accuracy
+  -T, --temp-dir=DIR          create temporary files in directory DIR
+  -y, --fuzzy                 find similar file for basis if no dest file
+@@ -536,6 +537,13 @@ regardless of timestamp\&. This is usefu
+ after using another mirroring system which may not preserve timestamps
+ exactly\&.
+ .IP 
++.IP "\fB--date-only\fP" 
++Normally rsync will skip any files that are
++already the same size and have the same modification time-stamp\&. With the
++--date-only option, files will be skipped if they have the same
++timestamp, regardless of size\&. This may be useful when the remote
++files have passed through a size-changing filter, e\&.g\&. for encryption\&.
++.IP 
+ .IP "\fB--modify-window\fP" 
+ When comparing two timestamps, rsync treats the
+ timestamps as being equal if they differ by no more than the modify-window
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: detect-renamed.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: dynamic_hash.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: early-checksum.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches: fname-convert.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/fsync.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/fsync.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/fsync.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/fsync.diff	2006-03-12 02:45:36.000000000 +0800
@@ -1,89 +1,89 @@
 This patch from Sami Farin lets you specify --fsync if you want fsync()
 to be called on every file we write.
 
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-07-28 01:47:53
-@@ -41,6 +41,7 @@ int whole_file = -1;
- int archive_mode = 0;
+--- old/options.c
++++ new/options.c
+@@ -43,6 +43,7 @@ int append_mode = 0;
  int keep_dirlinks = 0;
+ int copy_dirlinks = 0;
  int copy_links = 0;
 +int do_fsync = 0;
  int preserve_links = 0;
  int preserve_hard_links = 0;
  int preserve_perms = 0;
-@@ -311,6 +312,7 @@ void usage(enum logcode F)
-   rprintf(F,"     --partial               keep partially transferred files\n");
+@@ -329,6 +330,7 @@ void usage(enum logcode F)
    rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
    rprintf(F,"     --delay-updates         put all updated files into place at transfer's end\n");
+   rprintf(F," -m, --prune-empty-dirs      prune empty directory chains from the file-list\n");
 +  rprintf(F,"     --fsync                 fsync every written file\n");
    rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
    rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
    rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
-@@ -395,6 +397,7 @@ static struct poptOption long_options[] 
-   {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
-   {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
-   {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
+@@ -506,6 +508,7 @@ static struct poptOption long_options[] 
+   {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
+   {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
+   {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
 +  {"fsync",            0,  POPT_ARG_NONE,   &do_fsync, 0, 0, 0 },
-   {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
-   {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
-   {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
-@@ -1446,6 +1449,9 @@ void server_options(char **args,int *arg
+   {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
+   {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
+   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
+@@ -1707,6 +1710,9 @@ void server_options(char **args,int *arg
  		args[ac++] = tmpdir;
  	}
  
 +	if (do_fsync && am_sender)
 +		args[ac++] = "--fsync";
 +
  	if (basis_dir[0] && am_sender) {
  		/* the server only needs this option if it is not the sender,
  		 *   and it may be an older version that doesn't know this
---- orig/receiver.c	2005-07-28 18:48:38
-+++ receiver.c	2005-02-20 00:17:37
-@@ -38,6 +38,7 @@ extern int keep_dirlinks;
+--- old/receiver.c
++++ new/receiver.c
+@@ -36,6 +36,7 @@ extern int protocol_version;
+ extern int relative_paths;
  extern int preserve_hard_links;
  extern int preserve_perms;
- extern int io_error;
 +extern int do_fsync;
  extern int basis_dir_cnt;
  extern int make_backups;
  extern int cleanup_got_literal;
-@@ -291,6 +292,12 @@ static int receive_data(int f_in, char *
+@@ -252,6 +253,12 @@ static int receive_data(int f_in, char *
  		exit_cleanup(RERR_FILEIO);
  	}
  
 +	if (do_fsync && fd != -1 && fsync(fd) != 0) {
 +		rsyserr(FERROR, errno, "fsync failed on %s",
 +			full_fname(fname));
 +		exit_cleanup(RERR_FILEIO);
 +	}
 +
  	sum_end(file_sum1);
  
  	if (mapbuf)
---- orig/t_stub.c	2005-01-25 10:39:14
-+++ t_stub.c	2004-10-09 04:03:09
-@@ -28,6 +28,7 @@
+--- old/t_stub.c
++++ new/t_stub.c
+@@ -26,6 +26,7 @@
+  * functions, so that module test harnesses can run standalone.
+  **/
  
++int do_fsync = 0;
  int modify_window = 0;
  int module_id = -1;
-+int do_fsync;
- char *partial_dir;
- struct filter_list_struct server_filter_list;
- 
---- orig/util.c	2005-07-28 18:48:39
-+++ util.c	2004-07-03 20:18:13
-@@ -33,6 +33,7 @@ extern int module_id;
- extern int modify_window;
- extern char *partial_dir;
- extern struct filter_list_struct server_filter_list;
+ int relative_paths = 0;
+--- old/util.c
++++ new/util.c
+@@ -30,6 +30,7 @@
+ extern int verbose;
+ extern int dry_run;
+ extern int module_id;
 +extern int do_fsync;
- 
- int sanitize_paths = 0;
- 
-@@ -299,6 +300,12 @@ int copy_file(char *source, char *dest, 
+ extern int modify_window;
+ extern int relative_paths;
+ extern int human_readable;
+@@ -319,6 +320,12 @@ int copy_file(const char *source, const 
  		return -1;
  	}
  
 +	if (do_fsync && fsync(ofd) < 0) {
 +		rsyserr(FERROR, errno, "fsync failed on %s",
 +			full_fname(dest));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/gzip-rsyncable-checksum.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/gzip-rsyncable-checksum.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/gzip-rsyncable-checksum.diff	2005-02-20 09:13:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/gzip-rsyncable-checksum.diff	2006-02-06 14:24:29.000000000 +0800
@@ -1,13 +1,13 @@
 NOTE: this patch is for _gzip_!
 
 Kevin Day's version of the gzip-rsyncable patch that uses the rsync
 checksum algorithm.
 
---- original-1.2.2/deflate.c	2004-09-15 10:28:14.000000000 -0700
-+++ rsyncable-1.2.2/deflate.c	2005-02-17 14:37:14.660957200 -0700
+--- gzip-1.2.2/deflate.c	2004-09-15 10:28:14.000000000 -0700
++++ rsyncable/deflate.c	2005-02-17 14:37:14.660957200 -0700
 @@ -98,6 +98,10 @@
                              int length));
  #endif
  
 +local void rsync_roll(deflate_state *s, unsigned start, unsigned num);
 +local void rsync_roll_noop(deflate_state *s, unsigned start, unsigned num);
@@ -347,15 +347,14 @@
      }
 -    FLUSH_BLOCK(s, flush == Z_FINISH);
 +    FLUSH_BLOCK(s, flush == Z_FINISH, bflush-1);
      return flush == Z_FINISH ? finish_done : block_done;
  }
  #endif /* FASTEST */
-diff -Naur original-1.2.2/deflate.h rsyncable-1.2.2/deflate.h
---- original-1.2.2/deflate.h	2004-02-24 07:38:44.000000000 -0700
-+++ rsyncable-1.2.2/deflate.h	2005-02-17 13:46:12.056551200 -0700
+--- gzip-1.2.2/deflate.h	2004-02-24 07:38:44.000000000 -0700
++++ rsyncable/deflate.h	2005-02-17 13:46:12.056551200 -0700
 @@ -254,6 +254,17 @@
       * are always zero.
       */
  
 +    ulg rsync_sum;      /* rolling sum of rsync window */
 +    ulg rsync_chunk_end; /* next rsync sequence point */
@@ -377,15 +376,14 @@
  void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
 -                          int eof));
 +                          int pad, int eof));
  void _tr_align        OF((deflate_state *s));
  void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
                            int eof));
-diff -Naur original-1.2.2/minigzip.c rsyncable-1.2.2/minigzip.c
---- original-1.2.2/minigzip.c	2003-11-04 18:19:26.000000000 -0700
-+++ rsyncable-1.2.2/minigzip.c	2005-02-17 13:11:35.472851600 -0700
+--- gzip-1.2.2/minigzip.c	2003-11-04 18:19:26.000000000 -0700
++++ rsyncable/minigzip.c	2005-02-17 13:11:35.472851600 -0700
 @@ -215,7 +215,7 @@
      }
      gz_compress(in, out);
  
 -    unlink(file);
 +    //unlink(file);
@@ -410,15 +408,14 @@
  
 -    unlink(infile);
 +    //unlink(infile);
  }
  
  
-diff -Naur original-1.2.2/trees.c rsyncable-1.2.2/trees.c
---- original-1.2.2/trees.c	2004-02-24 07:36:38.000000000 -0700
-+++ rsyncable-1.2.2/trees.c	2005-02-17 13:09:38.768435100 -0700
+--- gzip-1.2.2/trees.c	2004-02-24 07:36:38.000000000 -0700
++++ rsyncable/trees.c	2005-02-17 13:09:38.768435100 -0700
 @@ -918,10 +918,11 @@
   * Determine the best encoding for the current block: dynamic trees, static
   * trees or store, and output the encoded block to the zip file.
   */
 -void _tr_flush_block(s, buf, stored_len, eof)
 +void _tr_flush_block(s, buf, stored_len, pad, eof)
@@ -439,15 +436,14 @@
 +    } else if (pad) {
 +#endif
 +        _tr_stored_block(s, buf, 0, eof);
      }
      Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
             s->compressed_len-7*eof));
-diff -Naur original-1.2.2/zlib.def rsyncable-1.2.2/zlib.def
---- original-1.2.2/zlib.def	1969-12-31 17:00:00.000000000 -0700
-+++ rsyncable-1.2.2/zlib.def	2005-02-17 14:01:48.972258000 -0700
+--- gzip-1.2.2/zlib.def	1969-12-31 17:00:00.000000000 -0700
++++ rsyncable/zlib.def	2005-02-17 14:01:48.972258000 -0700
 @@ -0,0 +1,61 @@
 +LIBRARY
 +; zlib data compression library
 +
 +EXPORTS
 +; basic functions
@@ -505,15 +501,14 @@
 +    inflateBackInit_
 +    inflateSyncPoint
 +    get_crc_table
 +    zError
 +	deflateSetRsyncParameters_
 \ No newline at end of file
-diff -Naur original-1.2.2/zlib.h rsyncable-1.2.2/zlib.h
---- original-1.2.2/zlib.h	2004-10-03 22:57:26.000000000 -0700
-+++ rsyncable-1.2.2/zlib.h	2005-02-17 14:02:11.753362200 -0700
+--- gzip-1.2.2/zlib.h	2004-10-03 22:57:26.000000000 -0700
++++ rsyncable/zlib.h	2005-02-17 14:02:11.753362200 -0700
 @@ -179,6 +179,13 @@
  
  #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
  
 +
 +/* Constants used for selecting Rsyncable checksum type */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/gzip-rsyncable.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/gzip-rsyncable.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/gzip-rsyncable.diff	2005-02-06 01:54:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/gzip-rsyncable.diff	2006-02-06 14:24:29.000000000 +0800
@@ -2,13 +2,13 @@
 
 This is pending for actual inclusion in gzip.  It is currently being
 tried out in the default gzip for Debian Sarge, and may go into the
 upstream gzip at somepoint in the not-too-distant future.
 
 --- gzip-1.3.5/deflate.c	1999-10-07 23:46:28 -0700
-+++ deflate.c	2005-02-05 09:40:33 -0800
++++ rsyncable/deflate.c	2005-02-05 09:40:33 -0800
 @@ -122,6 +122,14 @@
  #endif
  /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
  
 +#ifndef RSYNC_WIN
 +#  define RSYNC_WIN 4096
@@ -180,13 +180,13 @@
              match_available = 1;
 +	    RSYNC_ROLL(strstart, 1);
              strstart++;
              lookahead--;
          }
 --- gzip-1.3.5/gzip.c	2002-09-28 00:38:43 -0700
-+++ gzip.c	2005-02-05 09:40:33 -0800
++++ rsyncable/gzip.c	2005-02-05 09:40:33 -0800
 @@ -256,6 +256,7 @@
  unsigned insize;           /* valid bytes in inbuf */
  unsigned inptr;            /* index of next byte to be processed in inbuf */
  unsigned outcnt;           /* bytes in output buffer */
 +int rsync = 0;             /* make ryncable chunks */
  
@@ -216,13 +216,13 @@
 +	    rsync = 1; break;
 +
  	case 'S':
  #ifdef NO_MULTIPLE_DOTS
              if (*optarg == '.') optarg++;
 --- gzip-1.3.5/gzip.h	2001-09-30 23:53:41 -0700
-+++ gzip.h	2005-02-05 09:40:33 -0800
++++ rsyncable/gzip.h	2005-02-05 09:40:33 -0800
 @@ -133,6 +133,7 @@
  extern unsigned insize; /* valid bytes in inbuf */
  extern unsigned inptr;  /* index of next byte to be processed in inbuf */
  extern unsigned outcnt; /* bytes in output buffer */
 +extern int rsync;  /* deflate into rsyncable chunks */
  
@@ -235,13 +235,13 @@
 -off_t flush_block OF((char *buf, ulg stored_len, int eof));
 +off_t flush_block OF((char *buf, ulg stored_len, int pad, int eof));
  
          /* in bits.c */
  void     bi_init    OF((file_t zipfile));
 --- gzip-1.3.5/gzip.texi	2002-09-29 23:57:29 -0700
-+++ gzip.texi	2005-02-05 09:40:33 -0800
++++ rsyncable/gzip.texi	2005-02-05 09:40:33 -0800
 @@ -334,6 +334,14 @@
  into the directory and compress all the files it finds there (or
  decompress them in the case of @code{gunzip}).
  
 +@item --rsyncable
 +While compressing, synchronize the output occasionally based on the
@@ -252,13 +252,13 @@
 +compressed file created with this option, and one created without it.
 +
  @item --suffix @var{suf}
  @itemx -S @var{suf}
  Use suffix @samp{@var{suf}} instead of @samp{.gz}. Any suffix can be
 --- gzip-1.3.5/trees.c	1999-10-05 22:00:00 -0700
-+++ trees.c	2005-02-05 09:40:33 -0800
++++ rsyncable/trees.c	2005-02-05 09:40:33 -0800
 @@ -46,12 +46,13 @@
   *      void ct_tally (int dist, int lc);
   *          Save the match info and tally the frequency counts.
   *
 - *      off_t flush_block (char *buf, ulg stored_len, int eof)
 + *      off_t flush_block (char *buf, ulg stored_len, int pad, int eof)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: id-pair.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/ignore-case.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/ignore-case.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/ignore-case.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/ignore-case.diff	2006-03-12 02:45:52.000000000 +0800
@@ -1,127 +1,109 @@
 This adds the --ignore-case option, which makes rsync compare filenames
 in a case-insensitive manner.
 
---- orig/lib/wildmatch.c	2005-01-28 21:01:21
-+++ lib/wildmatch.c	2004-08-13 16:43:27
+--- old/flist.c
++++ new/flist.c
+@@ -36,6 +36,7 @@ extern int am_sender;
+ extern int do_progress;
+ extern int always_checksum;
+ extern int module_id;
++extern int ignore_case;
+ extern int ignore_errors;
+ extern int numeric_ids;
+ extern int recurse;
+@@ -1800,7 +1801,14 @@ int f_name_cmp(struct file_struct *f1, s
+ 		return type1 == t_PATH ? 1 : -1;
+ 
+ 	while (1) {
+-		if ((dif = (int)*c1++ - (int)*c2++) != 0)
++		if (ignore_case) {
++			uchar ch1, ch2;
++			ch1 = islower(*c1) ? toupper(*c1) : *c1;
++			ch2 = islower(*c2) ? toupper(*c2) : *c2;
++			c1++, c2++;
++			if ((dif = (int)ch1 - (int)ch2) != 0)
++				break;
++		} else if ((dif = (int)*c1++ - (int)*c2++) != 0)
+ 			break;
+ 		if (!*c1) {
+ 			switch (state1) {
+--- old/lib/wildmatch.c
++++ new/lib/wildmatch.c
 @@ -53,6 +53,8 @@
  #define ISUPPER(c) (ISASCII(c) && isupper(c))
  #define ISXDIGIT(c) (ISASCII(c) && isxdigit(c))
  
 +extern int ignore_case;
 +
  #ifdef WILD_TEST_ITERATIONS
  int wildmatch_iteration_count;
  #endif
-@@ -76,9 +78,19 @@ static int domatch(const uchar *p, const
- 	    ch = *++p;
- 	    /* FALLTHROUGH */
- 	  default:
--	    if (*text != ch)
--		return FALSE;
--	    continue;
-+	    if (*text == ch)
-+		continue;
-+	    if (ignore_case) {
-+		if (ISUPPER(*text)) {
-+		    if (tolower(*text) == ch)
-+			continue;
-+		}
-+		else if (ISUPPER(ch)) {
-+		    if (*text == tolower(ch))
-+			continue;
-+		}
-+	    }
-+	    return FALSE;
- 	  case '?':
- 	    /* Match anything but '/'. */
- 	    if (*text == '/')
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-05-03 16:47:52
-@@ -101,6 +101,7 @@ int max_delete = 0;
- OFF_T max_size = 0;
+@@ -72,6 +74,8 @@ static int dowild(const uchar *p, const 
+     for ( ; (p_ch = *p) != '\0'; text++, p++) {
+ 	int matched, special;
+ 	uchar t_ch, prev_ch;
++	if (ignore_case && ISUPPER(p_ch))
++	    p_ch = tolower(p_ch);
+ 	while ((t_ch = *text) == '\0') {
+ 	    if (*a == NULL) {
+ 		if (p_ch != '*')
+@@ -288,10 +292,14 @@ static const uchar *trailing_N_elements(
+ int wildmatch(const char *pattern, const char *text)
+ {
+     static const uchar *nomore[1]; /* A NULL pointer. */
++    int ret;
+ #ifdef WILD_TEST_ITERATIONS
+     wildmatch_iteration_count = 0;
+ #endif
+-    return dowild((const uchar*)pattern, (const uchar*)text, nomore) == TRUE;
++    force_lower_case = ignore_case;
++    ret = dowild((const uchar*)pattern, (const uchar*)text, nomore) == TRUE;
++    force_lower_case = 0;
++    return ret;
+ }
+ 
+ /* Match the "pattern" against the forced-to-lower-case "text" string. */
+--- old/options.c
++++ new/options.c
+@@ -111,6 +111,7 @@ OFF_T max_size = 0;
+ OFF_T min_size = 0;
  int ignore_errors = 0;
  int modify_window = 0;
 +int ignore_case = 0;
  int blocking_io = -1;
  int checksum_seed = 0;
  int inplace = 0;
-@@ -332,6 +333,7 @@ void usage(enum logcode F)
+@@ -351,6 +352,7 @@ void usage(enum logcode F)
    rprintf(F,"     --include-from=FILE     read include patterns from FILE\n");
    rprintf(F,"     --files-from=FILE       read list of source-file names from FILE\n");
    rprintf(F," -0, --from0                 all *-from/filter files are delimited by 0s\n");
 +  rprintf(F,"     --ignore-case           ignore case when comparing filenames\n");
    rprintf(F,"     --address=ADDRESS       bind address for outgoing socket to daemon\n");
    rprintf(F,"     --port=PORT             specify double-colon alternate port number\n");
-   rprintf(F,"     --blocking-io           use blocking I/O for the remote shell\n");
-@@ -392,6 +394,7 @@ static struct poptOption long_options[] 
-   {"include",          0,  POPT_ARG_STRING, 0, OPT_INCLUDE, 0, 0 },
-   {"exclude-from",     0,  POPT_ARG_STRING, 0, OPT_EXCLUDE_FROM, 0, 0 },
-   {"include-from",     0,  POPT_ARG_STRING, 0, OPT_INCLUDE_FROM, 0, 0 },
+   rprintf(F,"     --sockopts=OPTIONS      specify custom TCP options\n");
+@@ -506,6 +508,7 @@ static struct poptOption long_options[] 
+   {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
+   {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
+   {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
 +  {"ignore-case",      0,  POPT_ARG_NONE,   &ignore_case, 0, 0, 0 },
-   {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
-   {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
-   {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
-@@ -1410,6 +1413,9 @@ void server_options(char **args,int *arg
+   {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
+   {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
+   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
+@@ -1668,6 +1671,9 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
  
 +	if (ignore_case)
 +		args[ac++] = "--ignore-case";
 +
  	if (partial_dir && am_sender) {
- 		if (partial_dir != partialdir_for_delayupdate) {
+ 		if (partial_dir != tmp_partialdir) {
  			args[ac++] = "--partial-dir";
---- orig/t_stub.c	2005-01-25 10:39:14
-+++ t_stub.c	2004-08-13 17:19:56
-@@ -28,6 +28,7 @@
- 
- int modify_window = 0;
- int module_id = -1;
-+int ignore_case = 0;
- char *partial_dir;
- struct filter_list_struct server_filter_list;
- 
---- orig/util.c	2005-07-28 18:48:39
-+++ util.c	2004-08-13 16:40:34
-@@ -31,6 +31,7 @@ extern int verbose;
- extern int dry_run;
- extern int module_id;
- extern int modify_window;
-+extern int ignore_case;
- extern char *partial_dir;
- extern struct filter_list_struct server_filter_list;
- 
-@@ -1029,11 +1030,23 @@ int u_strcmp(const char *cs1, const char
- {
- 	const uchar *s1 = (const uchar *)cs1;
- 	const uchar *s2 = (const uchar *)cs2;
-+ 	
-+	if (ignore_case) {
-+		uchar c1, c2;
-+		while (1) {
-+			c1 = islower(*s1) ? toupper(*s1) : *s1;
-+			c2 = islower(*s2) ? toupper(*s2) : *s2;
-+			if (!c1 || c1 != c2)
-+				break;
-+			s1++, s2++;
-+		}
- 
--	while (*s1 && *s2 && (*s1 == *s2)) {
--		s1++; s2++;
-+		return (int)c1 - (int)c2;
- 	}
- 
-+	while (*s1 && *s1 == *s2)
-+		s1++, s2++;
-+
- 	return (int)*s1 - (int)*s2;
- }
- 
---- orig/wildtest.c	2004-02-07 18:40:52
-+++ wildtest.c	2004-08-13 17:19:34
+--- old/wildtest.c
++++ new/wildtest.c
 @@ -16,6 +16,7 @@ int fnmatch_errors = 0;
  #endif
  
  int wildmatch_errors = 0;
 +int ignore_case = 0;
  
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/last-match.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/last-match.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/last-match.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/last-match.diff	2006-02-06 14:32:33.000000000 +0800
@@ -1,60 +1,60 @@
 This adds the ability to put rules into a filter/include/exclude file
 in last-match-wins order.  All you need to do is to start the file with
 this line:
 
 [last-match]
 
---- orig/exclude.c	2005-07-07 19:49:14
-+++ exclude.c	2005-02-26 03:22:20
-@@ -73,6 +73,7 @@ static BOOL parent_dirscan = False;
+--- old/exclude.c
++++ new/exclude.c
+@@ -76,6 +76,7 @@ static BOOL parent_dirscan = False;
  static struct filter_struct **mergelist_parents;
  static int mergelist_cnt = 0;
  static int mergelist_size = 0;
 +static int reversing_rules = 0;
  
  /* Each filter_list_struct describes a singly-linked list by keeping track
   * of both the head and tail pointers.  The list is slightly unusual in that
-@@ -231,6 +232,9 @@ static void add_rule(struct filter_list_
+@@ -244,6 +245,9 @@ static void add_rule(struct filter_list_
  	if (!listp->tail) {
  		ret->next = listp->head;
  		listp->head = listp->tail = ret;
 +	} else if (reversing_rules) {
 +		ret->next = listp->head;
 +		listp->head = ret;
  	} else {
  		ret->next = listp->tail->next;
  		listp->tail->next = ret;
-@@ -957,6 +961,7 @@ void parse_filter_file(struct filter_lis
- 	char line[MAXPATHLEN+MAX_RULE_PREFIX+1]; /* +1 for trailing slash. */
+@@ -970,6 +974,7 @@ void parse_filter_file(struct filter_lis
+ 	char line[BIGPATHBUFLEN];
  	char *eob = line + sizeof line - 1;
  	int word_split = mflags & MATCHFLG_WORD_SPLIT;
 +	int save_reversing_rules = reversing_rules;
  
  	if (!fname || !*fname)
  		return;
-@@ -992,6 +997,7 @@ void parse_filter_file(struct filter_lis
+@@ -1005,6 +1010,7 @@ void parse_filter_file(struct filter_lis
  	}
  	dirbuf[dirbuf_len] = '\0';
  
 +	reversing_rules = 0;
  	while (1) {
  		char *s = line;
  		int ch, overflow = 0;
-@@ -1015,6 +1021,10 @@ void parse_filter_file(struct filter_lis
+@@ -1030,6 +1036,10 @@ void parse_filter_file(struct filter_lis
  			s = line;
  		}
  		*s = '\0';
 +		if (*line == '[' && strcmp(line+1, "last-match]") == 0) {
 +			reversing_rules = 1;
 +			continue;
 +		}
  		/* Skip an empty token and (when line parsing) comments. */
  		if (*line && (word_split || (*line != ';' && *line != '#')))
  			parse_rule(listp, line, mflags, xflags);
-@@ -1022,6 +1032,7 @@ void parse_filter_file(struct filter_lis
+@@ -1037,6 +1047,7 @@ void parse_filter_file(struct filter_lis
  			break;
  	}
  	fclose(fp);
 +	reversing_rules = save_reversing_rules;
  }
  
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/link-by-hash.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/link-by-hash.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/link-by-hash.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/link-by-hash.diff	2006-03-12 02:46:12.000000000 +0800
@@ -1,33 +1,34 @@
-After applying this patch and running configure, you MUST run this
-command before "make":
+After applying this patch, run these commands for a successful build:
 
-    make proto
+    ./prepare-source
+    ./configure                      (optional if already run)
+    make
 
 Jason M. Felice writes:
 
 This patch adds the --link-by-hash=DIR option, which hard links received
 files in a link farm arranged by MD4 file hash.  The result is that the system
 will only store one copy of the unique contents of each file, regardless of
 the file's name.
 
 
---- orig/Makefile.in	2005-07-07 21:29:57
-+++ Makefile.in	2004-07-03 20:20:15
+--- old/Makefile.in
++++ new/Makefile.in
 @@ -34,7 +34,7 @@ OBJS1=rsync.o generator.o receiver.o cle
  	main.o checksum.o match.o syscall.o log.o backup.o
  OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
- 	fileio.o batch.o clientname.o
+ 	fileio.o batch.o clientname.o chmod.o
 -OBJS3=progress.o pipe.o
 +OBJS3=progress.o pipe.o hashlink.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
  	popt/popthelp.o popt/poptparse.o
---- orig/hashlink.c	2004-09-24 16:44:25
-+++ hashlink.c	2004-09-24 16:44:25
-@@ -0,0 +1,340 @@
+--- old/hashlink.c
++++ new/hashlink.c
+@@ -0,0 +1,339 @@
 +/*
 +   Copyright (C) Cronosys, LLC 2004
 +
 +   This program is free software; you can redistribute it and/or modify
 +   it under the terms of the GNU General Public License as published by
 +   the Free Software Foundation; either version 2 of the License, or
@@ -251,34 +252,33 @@
 +	STRUCT_STAT st;
 +	char *hashname = make_hash_name(file);
 +	int first = 0, rc;
 +	char *linkname;
 +	long last_fnbr;
 +
-+	if (file->length == 0) {
-+		return robust_rename(fnametmp,fname,0644);
-+	}
++	if (file->length == 0)
++		return robust_rename(fnametmp, fname, NULL, 0644);
 +
 +	if (do_stat(hashname, &st) == -1) {
 +		char *dirname;
 +
 +		/* Directory does not exist. */
 +		dirname = strdup(hashname);
 +		*strrchr(dirname,'/') = 0;
 +		if (do_mkdir(dirname, 0755) == -1 && errno != EEXIST) {
 +			rsyserr(FERROR, errno, "mkdir failed: %s", dirname);
 +			free(hashname);
 +			free(dirname);
-+			return robust_rename(fnametmp,fname,0644);
++			return robust_rename(fnametmp, fname, NULL, 0644);
 +		}
 +		free(dirname);
 +
 +		if (do_mkdir(hashname, 0755) == -1 && errno != EEXIST) {
 +			rsyserr(FERROR, errno, "mkdir failed: %s", hashname);
 +			free(hashname);
-+			return robust_rename(fnametmp,fname,0644);
++			return robust_rename(fnametmp, fname, NULL, 0644);
 +		}
 +
 +		first = 1;
 +		asprintf(&linkname,"%s/0",hashname);
 +		rprintf(FINFO, "(1) linkname = %s\n", linkname);
 +	} else {
@@ -333,24 +333,24 @@
 +					 last_fnbr + 1);
 +				rprintf(FINFO, "(5) linkname = %s\n", linkname);
 +				rprintf(FINFO,"link-by-hash: max link count exceeded, starting new file \"%s\".\n", linkname);
 +			} else {
 +				rsyserr(FERROR, errno, "link \"%s\" -> \"%s\"",
 +					linkname, full_fname(fname));
-+				rc = robust_rename(fnametmp,fname,0644);
++				rc = robust_rename(fnametmp, fname, NULL, 0644);
 +			}
 +		} else {
 +			do_unlink(fnametmp);
 +		}
 +	}
 +
 +	if (first) {
 +		rprintf(FINFO, "link-by-hash (new): %s -> \"%s\"\n",
 +				full_fname(fname),linkname);
 +
-+		rc = robust_rename(fnametmp,fname,0644);
++		rc = robust_rename(fnametmp, fname, NULL, 0644);
 +		if (rc != 0) {
 +			rsyserr(FERROR, errno, "rename \"%s\" -> \"%s\"",
 +				full_fname(fnametmp), full_fname(fname));
 +		}
 +		rc = do_link(fname,linkname);
 +		if (rc != 0) {
@@ -362,50 +362,50 @@
 +	free(linkname);
 +	free(hashname);
 +	return rc;
 +}
 +
 +#endif
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-05-19 08:55:42
-@@ -141,6 +141,7 @@ char *log_format = NULL;
- char *password_file = NULL;
- char *rsync_path = RSYNC_PATH;
- char *backup_dir = NULL;
+--- old/options.c
++++ new/options.c
+@@ -145,6 +145,7 @@ char *backup_suffix = NULL;
+ char *tmpdir = NULL;
+ char *partial_dir = NULL;
+ char *basis_dir[MAX_BASIS_DIRS+1];
 +char *link_by_hash_dir = NULL;
- char backup_dir_buf[MAXPATHLEN];
- int rsync_port = 0;
- int compare_dest = 0;
-@@ -321,6 +322,7 @@ void usage(enum logcode F)
+ char *config_file = NULL;
+ char *shell_cmd = NULL;
+ char *log_format = NULL;
+@@ -339,6 +340,7 @@ void usage(enum logcode F)
    rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
    rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
    rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
 +  rprintf(F,"     --link-by-hash=DIR      create hardlinks by hash into DIR\n");
    rprintf(F," -z, --compress              compress file data during the transfer\n");
+   rprintf(F,"     --compress-level=NUM    explicitly set compression level\n");
    rprintf(F," -C, --cvs-exclude           auto-ignore files the same way CVS does\n");
-   rprintf(F," -f, --filter=RULE           add a file-filtering RULE\n");
-@@ -362,7 +364,7 @@ void usage(enum logcode F)
- 
- enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
-       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST,
--      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
-+      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_LINK_BY_HASH,
+@@ -385,7 +387,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
+       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
+       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
        OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
-       OPT_REFUSED_BASE = 9000};
+-      OPT_NO_D,
++      OPT_NO_D, OPT_LINK_BY_HASH,
+       OPT_SERVER, OPT_REFUSED_BASE = 9000};
  
-@@ -432,6 +434,7 @@ static struct poptOption long_options[] 
+ static struct poptOption long_options[] = {
+@@ -483,6 +485,7 @@ static struct poptOption long_options[] 
    {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
    {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
    {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
 +  {"link-by-hash",     0,  POPT_ARG_STRING, 0, OPT_LINK_BY_HASH, 0, 0},
    {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
-   /* TODO: Should this take an optional int giving the compression level? */
-   {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
-@@ -876,6 +879,21 @@ int parse_arguments(int *argc, const cha
- 			basis_dir[basis_dir_cnt++] = (char *)arg;
- 			break;
+   {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
+   {"compress-level",   0,  POPT_ARG_INT,    &def_compress_level, 'z', 0, 0 },
+@@ -1068,6 +1071,21 @@ int parse_arguments(int *argc, const cha
+ 			usage(FINFO);
+ 			exit_cleanup(0);
  
 +                case OPT_LINK_BY_HASH:
 +#if HAVE_LINK
 +			arg = poptGetOptArg(pc);
 +			if (sanitize_paths)
 +				arg = sanitize_path(NULL, arg, NULL, 0);
@@ -419,35 +419,35 @@
 +			return 0;
 +#endif
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1458,6 +1476,11 @@ void server_options(char **args,int *arg
+@@ -1719,6 +1737,11 @@ void server_options(char **args,int *arg
  		}
  	}
  
 +	if (link_by_hash_dir && am_sender) {
 +		args[ac++] = "--link-by-hash";
 +		args[ac++] = link_by_hash_dir;
 +	}
 +
  	if (files_from && (!am_sender || filesfrom_host)) {
  		if (filesfrom_host) {
  			args[ac++] = "--files-from";
---- orig/receiver.c	2005-07-28 18:48:38
-+++ receiver.c	2005-01-15 21:29:13
-@@ -52,6 +52,7 @@ extern int delay_updates;
+--- old/receiver.c
++++ new/receiver.c
+@@ -49,6 +49,7 @@ extern int delay_updates;
  extern struct stats stats;
  extern char *log_format;
  extern char *tmpdir;
 +extern char *link_by_hash_dir;
  extern char *partial_dir;
  extern char *basis_dir[];
  extern struct file_list *the_file_list;
-@@ -185,12 +186,13 @@ static int get_tmpname(char *fnametmp, c
+@@ -120,12 +121,13 @@ static int get_tmpname(char *fnametmp, c
  
  
  static int receive_data(int f_in, char *fname_r, int fd_r, OFF_T size_r,
 -			char *fname, int fd, OFF_T total_size)
 +			char *fname, int fd, OFF_T total_size, char *md4)
  {
@@ -456,117 +456,146 @@
  	struct map_struct *mapbuf;
  	struct sum_struct sum;
 +	struct mdfour mdfour_data;
  	int32 len;
  	OFF_T offset = 0;
  	OFF_T offset2;
-@@ -210,6 +212,9 @@ static int receive_data(int f_in, char *
+@@ -145,6 +147,9 @@ static int receive_data(int f_in, char *
  	} else
  		mapbuf = NULL;
  
 +	if (md4)
 +		mdfour_begin(&mdfour_data);
 +
  	sum_init(checksum_seed);
  
- 	while ((i = recv_token(f_in, &data)) != 0) {
-@@ -226,6 +231,8 @@ static int receive_data(int f_in, char *
+ 	if (append_mode) {
+@@ -187,6 +192,8 @@ static int receive_data(int f_in, char *
  			cleanup_got_literal = 1;
  
  			sum_update(data, i);
 +			if (md4)
-+				mdfour_update(&mdfour_data,data,i);
++				mdfour_update(&mdfour_data, (uchar*)data, i);
  
  			if (fd != -1 && write_file(fd,data,i) != i)
  				goto report_write_error;
-@@ -252,6 +259,8 @@ static int receive_data(int f_in, char *
+@@ -213,6 +220,8 @@ static int receive_data(int f_in, char *
  
  			see_token(map, len);
  			sum_update(map, len);
 +			if (md4)
-+				mdfour_update(&mdfour_data,map,len);
++				mdfour_update(&mdfour_data, (uchar*)map, len);
  		}
  
  		if (inplace) {
-@@ -292,6 +301,8 @@ static int receive_data(int f_in, char *
+@@ -253,6 +262,8 @@ static int receive_data(int f_in, char *
  	}
  
  	sum_end(file_sum1);
 +	if (md4)
 +		mdfour_result(&mdfour_data, (unsigned char*)md4);
  
  	if (mapbuf)
  		unmap_file(mapbuf);
-@@ -307,7 +318,7 @@ static int receive_data(int f_in, char *
+@@ -268,7 +279,7 @@ static int receive_data(int f_in, char *
  
  static void discard_receive_data(int f_in, OFF_T length)
  {
 -	receive_data(f_in, NULL, -1, 0, NULL, -1, length);
 +	receive_data(f_in, NULL, -1, 0, NULL, -1, length, NULL);
  }
  
  static void handle_delayed_updates(struct file_list *flist, char *local_name)
-@@ -635,8 +646,12 @@ int recv_files(int f_in, struct file_lis
- 			rprintf(FINFO, "%s\n", safe_fname(fname));
+@@ -600,8 +611,12 @@ int recv_files(int f_in, struct file_lis
+ 			rprintf(FINFO, "%s\n", fname);
  
  		/* recv file data */
 +#if HAVE_LINK
 +		if (link_by_hash_dir)
 +			file->u.sum = new_array(char, MD4_SUM_LENGTH);
 +#endif
  		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
 -				       fname, fd2, file->length);
 +				       fname, fd2, file->length, file->u.sum);
  
  		if (!log_before_transfer)
  			log_item(file, &initial_stats, iflags, NULL);
---- orig/rsync.c	2005-07-28 18:48:38
-+++ rsync.c	2005-02-21 11:04:36
-@@ -38,6 +38,7 @@ extern int inplace;
+--- old/rsync.c
++++ new/rsync.c
+@@ -49,6 +49,7 @@ extern int inplace;
  extern int keep_dirlinks;
  extern int make_backups;
- extern struct stats stats;
+ extern mode_t orig_umask;
 +extern char *link_by_hash_dir;
+ extern struct stats stats;
+ extern struct chmod_mode_struct *daemon_chmod_modes;
  
- 
- /*
-@@ -188,7 +189,12 @@ void finish_transfer(char *fname, char *
- 		rprintf(FINFO, "renaming %s to %s\n",
- 			safe_fname(fnametmp), safe_fname(fname));
- 	}
--	ret = robust_rename(fnametmp, fname, file->mode & INITACCESSPERMS);
+@@ -269,8 +270,15 @@ void finish_transfer(char *fname, char *
+ 	/* move tmp file over real file */
+ 	if (verbose > 2)
+ 		rprintf(FINFO, "renaming %s to %s\n", fnametmp, fname);
+-	ret = robust_rename(fnametmp, fname, partialptr,
+-			    file->mode & INITACCESSPERMS);
 +#if HAVE_LINK
 +	if (link_by_hash_dir)
 +		ret = link_by_hash(fnametmp, fname, file);
 +	else
 +#endif
-+		ret = robust_rename(fnametmp, fname, file->mode & INITACCESSPERMS);
++	{
++		ret = robust_rename(fnametmp, fname, partialptr,
++				    file->mode & INITACCESSPERMS);
++	}
  	if (ret < 0) {
  		rsyserr(FERROR, errno, "%s %s -> \"%s\"",
- 		    ret == -2 ? "copy" : "rename",
---- orig/rsync.h	2005-05-03 17:00:47
-+++ rsync.h	2004-07-03 20:20:15
-@@ -631,6 +631,14 @@ struct stats {
+ 			ret == -2 ? "copy" : "rename",
+--- old/rsync.h
++++ new/rsync.h
+@@ -641,6 +641,14 @@ struct stats {
  	int current_file_index;
  };
  
 +struct hashfile_struct {
 +	struct hashfile_struct *next;
 +	struct hashfile_struct *prev;
 +	char *name;
 +	int fd;
 +	uint32 nlink;
 +};
 +
+ struct chmod_mode_struct;
  
  #include "byteorder.h"
- #include "lib/mdfour.h"
---- orig/rsync.yo	2005-07-28 19:26:48
-+++ rsync.yo	2005-02-13 06:58:47
-@@ -354,6 +354,7 @@ to the detailed description below for a 
+--- old/rsync.yo
++++ new/rsync.yo
+@@ -365,6 +365,7 @@ to the detailed description below for a 
       --compare-dest=DIR      also compare received files relative to DIR
       --copy-dest=DIR         ... and include copies of unchanged files
       --link-dest=DIR         hardlink to files in DIR when unchanged
 +     --link-by-hash=DIR      create hardlinks by hash into DIR
   -z, --compress              compress file data during the transfer
+      --compress-level=NUM    explicitly set compression level
+  -C, --cvs-exclude           auto-ignore files in the same way CVS does
+--- old/proto.h
++++ new/proto.h
+@@ -89,6 +89,12 @@ void itemize(struct file_struct *file, i
+ int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st);
+ void check_for_finished_hlinks(int itemizing, enum logcode code);
+ void generate_files(int f_out, struct file_list *flist, char *local_name);
++char* make_hash_name(struct file_struct *file);
++void kill_hashfile(struct hashfile_struct *hashfile);
++void kill_hashfiles(struct hashfile_struct *hashfiles);
++struct hashfile_struct *find_hashfiles(char *hashname, int64 size, long *fnbr);
++struct hashfile_struct *compare_hashfiles(int fd,struct hashfile_struct *files);
++int link_by_hash(char *fnametmp,char *fname,struct file_struct *file);
+ void init_hard_links(void);
+ int hard_link_check(struct file_struct *file, int ndx, char *fname,
+ 		    int statret, STRUCT_STAT *st, int itemizing,
+--- old/rsync.1
++++ new/rsync.1
+@@ -421,6 +421,7 @@ to the detailed description below for a 
+      --compare-dest=DIR      also compare received files relative to DIR
+      --copy-dest=DIR         \&.\&.\&. and include copies of unchanged files
+      --link-dest=DIR         hardlink to files in DIR when unchanged
++     --link-by-hash=DIR      create hardlinks by hash into DIR
+  -z, --compress              compress file data during the transfer
+      --compress-level=NUM    explicitly set compression level
   -C, --cvs-exclude           auto-ignore files in the same way CVS does
-  -f, --filter=RULE           add a file-filtering RULE
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/links-depth.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/links-depth.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/links-depth.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/links-depth.diff	2006-03-12 02:46:23.000000000 +0800
@@ -3,26 +3,26 @@
 
 The patch has been heavily modified from its original form to work
 with the latest codebase, but even in its original form it didn't
 handle relative symlinks properly, and that has not yet been fixed
 in this modified version.
 
---- orig/flist.c	2005-07-28 18:48:38
-+++ flist.c	2004-07-16 16:58:04
-@@ -45,6 +45,7 @@ extern int filesfrom_fd;
- extern int one_file_system;
+--- old/flist.c
++++ new/flist.c
+@@ -45,6 +45,7 @@ extern int one_file_system;
+ extern int copy_dirlinks;
  extern int keep_dirlinks;
  extern int preserve_links;
 +extern int follow_links_depth;
  extern int preserve_hard_links;
- extern int preserve_perms;
  extern int preserve_devices;
-@@ -734,6 +735,30 @@ static struct file_struct *receive_file_
+ extern int preserve_specials;
+@@ -715,6 +716,30 @@ static struct file_struct *receive_file_
+ 	return file;
  }
  
- 
 +#if SUPPORT_LINKS
 +static int links_depth(char *linkname, STRUCT_STAT *st_ptr)
 +{
 +	char buf[MAXPATHLEN];
 +	STRUCT_STAT st;
 +	int i;
@@ -44,13 +44,13 @@
 +}
 +#endif
 +
  /**
   * Create a file_struct for a named file by reading its stat()
   * information and performing extensive checks against global
-@@ -859,7 +884,13 @@ skip_filters:
+@@ -849,7 +874,13 @@ struct file_struct *make_file(char *fnam
  	basename_len = strlen(basename) + 1; /* count the '\0' */
  
  #ifdef SUPPORT_LINKS
 -	linkname_len = S_ISLNK(st.st_mode) ? strlen(linkname) + 1 : 0;
 +	if (S_ISLNK(st.st_mode)) {
 +		if (follow_links_depth && links_depth(linkname, &st))
@@ -59,42 +59,52 @@
 +			linkname_len = strlen(linkname) + 1;
 +	} else
 +		linkname_len = 0;
  #else
  	linkname_len = 0;
  #endif
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-01-28 19:33:24
-@@ -42,6 +42,7 @@ int archive_mode = 0;
- int keep_dirlinks = 0;
+--- old/options.c
++++ new/options.c
+@@ -44,6 +44,7 @@ int keep_dirlinks = 0;
+ int copy_dirlinks = 0;
  int copy_links = 0;
  int preserve_links = 0;
 +int follow_links_depth = 0;
  int preserve_hard_links = 0;
  int preserve_perms = 0;
- int preserve_devices = 0;
-@@ -276,6 +277,7 @@ void usage(enum logcode F)
-   rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
+ int preserve_executability = 0;
+@@ -287,6 +288,7 @@ void usage(enum logcode F)
+   rprintf(F,"     --append                append data onto shorter files\n");
    rprintf(F," -d, --dirs                  transfer directories without recursing\n");
    rprintf(F," -l, --links                 copy symlinks as symlinks\n");
 +  rprintf(F,"     --links-depth=NUM       follow symlinks up to NUM depth\n");
    rprintf(F," -L, --copy-links            transform symlink into referent file/dir\n");
    rprintf(F,"     --copy-unsafe-links     only \"unsafe\" symlinks are transformed\n");
    rprintf(F,"     --safe-links            ignore symlinks that point outside the source tree\n");
-@@ -402,6 +404,7 @@ static struct poptOption long_options[] 
-   {"inplace",          0,  POPT_ARG_NONE,   &inplace, 0, 0, 0 },
-   {"dirs",            'd', POPT_ARG_VAL,    &xfer_dirs, 2, 0, 0 },
-   {"links",           'l', POPT_ARG_NONE,   &preserve_links, 0, 0, 0 },
+@@ -432,6 +434,7 @@ static struct poptOption long_options[] 
+   {"links",           'l', POPT_ARG_VAL,    &preserve_links, 1, 0, 0 },
+   {"no-links",         0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
+   {"no-l",             0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
 +  {"links-depth",      0,  POPT_ARG_INT,    &follow_links_depth , 0, 0, 0 },
    {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
-   {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
-   {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
---- orig/rsync.yo	2005-07-28 19:26:48
-+++ rsync.yo	2005-01-28 19:33:40
-@@ -309,6 +309,7 @@ to the detailed description below for a 
-      --inplace               update destination files in-place
+   {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
+   {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
+--- old/rsync.yo
++++ new/rsync.yo
+@@ -313,6 +313,7 @@ to the detailed description below for a 
+      --append                append data onto shorter files
+  -d, --dirs                  transfer directories without recursing
+  -l, --links                 copy symlinks as symlinks
++     --links-depth=NUM       follow symlinks up to NUM depth
+  -L, --copy-links            transform symlink into referent file/dir
+      --copy-unsafe-links     only "unsafe" symlinks are transformed
+      --safe-links            ignore symlinks that point outside the tree
+--- old/rsync.1
++++ new/rsync.1
+@@ -369,6 +369,7 @@ to the detailed description below for a 
+      --append                append data onto shorter files
   -d, --dirs                  transfer directories without recursing
   -l, --links                 copy symlinks as symlinks
 +     --links-depth=NUM       follow symlinks up to NUM depth
   -L, --copy-links            transform symlink into referent file/dir
       --copy-unsafe-links     only "unsafe" symlinks are transformed
       --safe-links            ignore symlinks that point outside the tree
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/md5.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/md5.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/md5.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/md5.diff	2006-03-12 02:46:32.000000000 +0800
@@ -1,19 +1,19 @@
---- orig/Makefile.in	2005-07-07 21:29:57
-+++ Makefile.in	2005-06-14 02:33:20
+--- old/Makefile.in
++++ new/Makefile.in
 @@ -26,7 +26,7 @@ VERSION=@VERSION@
  .SUFFIXES: .c .o
  
  HEADERS=byteorder.h config.h errcode.h proto.h rsync.h lib/pool_alloc.h
 -LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o \
 +LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o lib/md5.o \
  	lib/permstring.o lib/pool_alloc.o @LIBOBJS@
  ZLIBOBJ=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
  	zlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o
---- orig/checksum.c	2005-01-01 21:08:05
-+++ checksum.c	2005-06-14 02:43:38
+--- old/checksum.c
++++ new/checksum.c
 @@ -18,6 +18,7 @@
  */
  
  #include "rsync.h"
 +#include "lib/md5.h"
  
@@ -184,14 +184,14 @@
 -	mdfour_result(&md, (uchar *)sum);
 +	if (use_md5)
 +		md5_finish(&ctxd, (uchar *)sum);
 +	else
 +		mdfour_result(&md, (uchar *)sum);
  }
---- orig/lib/md5.c	2005-06-14 02:35:52
-+++ lib/md5.c	2005-06-14 02:35:52
+--- old/lib/md5.c
++++ new/lib/md5.c
 @@ -0,0 +1,344 @@
 +/*
 + *  RFC 1321 compliant MD5 implementation
 + *
 + *  Copyright (C) 2001-2003  Christophe Devine
 + *
@@ -531,14 +531,14 @@
 +    }
 +
 +    return( 0 );
 +}
 +
 +#endif
---- orig/lib/md5.h	2005-06-14 02:35:26
-+++ lib/md5.h	2005-06-14 02:35:26
+--- old/lib/md5.h
++++ new/lib/md5.h
 @@ -0,0 +1,14 @@
 +#ifndef _MD5_H
 +#define _MD5_H
 +
 +typedef struct {
 +    uint32 total[2];
@@ -548,39 +548,39 @@
 +
 +void md5_starts(md5_context *ctx);
 +void md5_update(md5_context *ctx, uchar *input, uint32 length);
 +void md5_finish(md5_context *ctx, uchar digest[16]);
 +
 +#endif /* md5.h */
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-06-14 02:21:26
-@@ -107,6 +107,7 @@ int inplace = 0;
+--- old/options.c
++++ new/options.c
+@@ -117,6 +117,7 @@ int inplace = 0;
  int delay_updates = 0;
  long block_size = 0; /* "long" because popt can't set an int32. */
  
 +int use_md5 = 0;
  
  /** Network address family. **/
  #ifdef INET6
-@@ -348,6 +349,7 @@ void usage(enum logcode F)
+@@ -369,6 +370,7 @@ void usage(enum logcode F)
    rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
    rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
    rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
 +  rprintf(F,"     --md5                   use MD5 checksums instead of MD4\n");
  #ifdef INET6
    rprintf(F," -4, --ipv4                  prefer IPv4\n");
    rprintf(F," -6, --ipv6                  prefer IPv6\n");
-@@ -460,6 +462,7 @@ static struct poptOption long_options[] 
-   {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
-   {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
-   {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
+@@ -478,6 +480,7 @@ static struct poptOption long_options[] 
+   {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
+   {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
+   {"no-W",             0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
 +  {"md5",              0,  POPT_ARG_NONE,   &use_md5, 0, 0, 0 },
- #ifdef INET6
-   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
-   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
-@@ -1365,6 +1368,9 @@ void server_options(char **args,int *arg
+   {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
+   {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
+   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
+@@ -1622,6 +1625,9 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
  
 +	if (use_md5) 
 +		args[ac++] = "--md5";
 +
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches: min-size.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/netgroup-auth.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/netgroup-auth.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/netgroup-auth.diff	2005-03-16 10:28:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/netgroup-auth.diff	2006-02-06 14:32:33.000000000 +0800
@@ -1,13 +1,13 @@
 This allows you to use the samba style @netgroup names in hosts allow
 and hosts deny.
 
 This patch still needs autoconf support for portability.
 
---- orig/access.c	2005-02-14 00:53:43
-+++ access.c	2005-01-15 20:09:59
+--- old/access.c
++++ new/access.c
 @@ -22,12 +22,15 @@
    */
  
  #include "rsync.h"
 +#include <netdb.h>
  
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/ODBC-dblog.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/ODBC-dblog.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/ODBC-dblog.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/ODBC-dblog.diff	2006-03-12 02:46:51.000000000 +0800
@@ -1,184 +1,130 @@
 Add support for logging daemon messages to an SQL database.
 
 After applying this patch, run these commands for a successful build:
 
-    autoconf
-    autoheader
-    ./configure --with-ODBC
-    make proto
+    ./prepare-source
+    ./configure --enable-ODBC
     make
 
-Steve Sether writes:
+See the file "instructions" (after applying this patch) for more info.
 
-This patch adds the following options:
-
-"database logging"
-    If set to True, rsync will attempt to connect to
-    the specified datasource and write to the named tables.
-    Defaults to False.
-
-"database datasource"
-    Specifies the name of the ODBC data source to use.
-
-"database username"
-    The username to use when connecting to the database.
-
-"database password"
-    The password to use when connecting to the database.
-
-"transfer table name"
-    The name of the transfer table to log to.  This table contains individual
-    filenames, file sizes, bytes transferred, checksum bytes transferred,
-    operation (send or receive), and a timestamp.
-
-"session table name"
-    The name of the session table to log to.  This table contains the username,
-    module name, module path, ip address, process ID, and a timestamp.
-
-"exit table name"
-
-    The name of the exit table to log to.  This table contains the total bytes
-    read, total bytes written, total size of all files, error code, line the
-    error occured at, file the error occured at and the text of the error.
-    (most of which will be blank if the program exited normally).
-
-"unique id method"
-    Different databases use different methods to get a unique identifier.
-    Some databases support sequence objects, and use various forms of the
-    nextval command to retrieve a unique identifier from it.  Other databases
-    support an autonumber field, and support different methds of retrieving
-    the ID used in the last insert.  Valid values for this option are:
-
-	nextval-postgres
-	    uses the syntax of nextval for PostgreSQL databases
-
-	nextval-oracle
-	    uses the syntax of nextval for Oracle databases
-
-	nextval-db2
-	    uses the syntax of nextval for DB2 databases
-
-	last_insert_id
-	    uses the last_insert_id() command for the MySQL databases
-
-	@@IDENTITY
-	    uses the @@IDENTITY command for Sybase databases
-
-	custom
-	    Define your own method to get a unique identifier.  See the
-	    "custom unique id select", and the "get custom id before select"
-	    parameters.
-
-"sequence name"
-    If your database supports sequences, list the name of the sequence to use
-    for the session unique identifier.
-
-"custom unique id select"
-    Only used if you specify the custom method in "unique id method".  This is
-    a SQL statement to be executed to get a unique ID.  This SQL statement must
-    return one column with the unique ID to use for the session ID.  Should be
-    used in concert with the "get custom id before select" parameter.
-
-"get custom id before insert"
-    This parameter is ignored unless the "unique id method" is set to custom.
-    If set to true, the "custom unique id select" statement will be executed
-    BEFORE the session row is inserted into the database.  (as is done when a
-    sequence is used for unique IDs).  If False the statement will be executed
-    after the session row is inserted (as is done when the session ID is
-    automatically generates unique IDs).  Defaults to True.
-
---- orig/Makefile.in	2005-07-07 21:29:57
-+++ Makefile.in	2005-05-23 23:31:30
+--- old/Makefile.in
++++ new/Makefile.in
 @@ -31,7 +31,7 @@ LIBOBJ=lib/wildmatch.o lib/compat.o lib/
  ZLIBOBJ=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
  	zlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o
  OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
 -	main.o checksum.o match.o syscall.o log.o backup.o
 +	main.o checksum.o match.o syscall.o log.o backup.o @EXTRA_OBJECT@
  OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
- 	fileio.o batch.o clientname.o
+ 	fileio.o batch.o clientname.o chmod.o
  OBJS3=progress.o pipe.o
---- orig/cleanup.c	2005-03-05 18:58:38
-+++ cleanup.c	2005-05-23 23:28:28
-@@ -39,6 +39,10 @@ void close_all(void)
- 	int ret;
- 	STRUCT_STAT st;
+--- old/cleanup.c
++++ new/cleanup.c
+@@ -23,6 +23,7 @@
  
-+#ifdef HAVE_LIBODBC
-+	db_log_close();
-+#endif
-+
- 	max_fd = sysconf(_SC_OPEN_MAX) - 1;
- 	for (fd = max_fd; fd >= 0; fd--) {
- 		if ((ret = do_fstat(fd, &st)) == 0) {
-@@ -144,8 +148,12 @@ void _exit_cleanup(int code, const char 
+ extern int io_error;
+ extern int keep_partial;
++extern int am_generator;
+ extern int log_got_error;
+ extern char *partial_dir;
+ 
+@@ -149,8 +150,13 @@ void _exit_cleanup(int code, const char 
  			code = RERR_PARTIAL;
  	}
  
 -	if (code)
 +	if (code) {
  		log_exit(code, file, line);
 +#ifdef HAVE_LIBODBC
 +		db_log_exit(code,file,line);
++		db_log_close();
 +#endif
 +	}
  
  	if (verbose > 2) {
  		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n",
---- orig/clientserver.c	2005-07-28 18:48:38
-+++ clientserver.c	2005-05-23 23:29:31
-@@ -346,6 +346,9 @@ static int rsync_module(int f_in, int f_
- 		   XFLG_ANCHORED2ABS | XFLG_OLD_PREFIXES);
+--- old/clientserver.c
++++ new/clientserver.c
+@@ -395,6 +395,9 @@ static int rsync_module(int f_in, int f_
+ 		   XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES);
  
  	log_init();
 +#ifdef HAVE_LIBODBC
 +	db_log_open();
 +#endif
  
- 	if (use_chroot) {
- 		/*
-@@ -468,6 +471,9 @@ static int rsync_module(int f_in, int f_
+ #ifdef HAVE_PUTENV
+ 	if (*lp_prexfer_exec(i) || *lp_postxfer_exec(i)) {
+@@ -633,6 +636,9 @@ static int rsync_module(int f_in, int f_
  			rprintf(FLOG, "rsync %s %s from %s@%s (%s)\n",
  				am_sender ? "on" : "to",
  				request, auth_user, host, addr);
 +#ifdef HAVE_LIBODBC
 +			db_log_session();
 +#endif
  		} else {
  			rprintf(FLOG, "rsync %s %s from %s (%s)\n",
  				am_sender ? "on" : "to",
---- orig/configure.in	2005-07-28 18:48:38
-+++ configure.in	2005-05-23 23:32:21
-@@ -92,6 +92,8 @@ AC_ARG_WITH(rsync-path,
- 	[  --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)],
- 	[ RSYNC_PATH="$with_rsync_path" ],
- 	[ RSYNC_PATH="rsync" ])
-+AC_ARG_WITH(ODBC,
-+	[  --with-ODBC             compile in support for ODBC database logging])
- 
- AC_DEFINE_UNQUOTED(RSYNC_PATH, "$RSYNC_PATH", [location of rsync on remote machine])
- 
-@@ -546,6 +548,14 @@ then
+--- old/configure.in
++++ new/configure.in
+@@ -540,6 +540,12 @@ if test x"$with_included_popt" != x"yes"
      AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])
  fi
  
-+if test x"$with_ODBC" = x"yes"
-+then
-+    AC_CHECK_HEADERS(sql.h sqlext.h sqltypes.h)
++AC_ARG_ENABLE(ODBC, AC_HELP_STRING([--enable-ODBC], [compile in support for ODBC database logging]),
++    [ AC_CHECK_HEADERS(sql.h sqlext.h sqltypes.h)
 +    AC_CHECK_LIB(odbc,SQLExecDirect)
 +    EXTRA_OBJECT="$EXTRA_OBJECT dblog.o"
-+    AC_SUBST(EXTRA_OBJECT)
-+fi
++    AC_SUBST(EXTRA_OBJECT) ])
 +
  AC_MSG_CHECKING([whether to use included libpopt])
- if test x"$with_included_popt" = x"yes"
- then
---- orig/dblog-tables-mysql.sql	2005-05-23 23:28:40
-+++ dblog-tables-mysql.sql	2005-05-23 23:28:40
-@@ -0,0 +1,43 @@
+ if test x"$with_included_popt" = x"yes"; then
+     AC_MSG_RESULT($srcdir/popt)
+--- old/db_log_error-list.txt
++++ new/db_log_error-list.txt
+@@ -0,0 +1,35 @@
++error type		description
++0			not an error.
++1			authentication
++2			file/dir deletion failed
++3			connection closed
++4			read error
++5			multiplexing overflow
++6			unexpected tag
++7			over long v-string received
++8			invalid block length
++9			invalid checksum length
++10			invalid remainder length
++11			failed to write error
++12			attempting to send over-long vstring
++13			temporary filename too long
++14			lseek failed
++15			write failed
++16			rename failed
++17			rsync hack failed
++18			"invalid basis_dir index
++19			fstat failed
++20			is a directory
++21			open file failed
++22			mkstemp failed
++23			close failed
++24			failed verification
++25			IO error, skipping deletion.
++26			directory creation failed
++27			ignoring unsafe symbolic link
++28			symbolic link failed
++29			mknod failed
++30			failed to stat
++31			unlink
++32			failed to open file/directory
++33			open?
+--- old/dblog-tables-mysql.sql
++++ new/dblog-tables-mysql.sql
+@@ -0,0 +1,64 @@
 +drop table transfer;
 +drop table exit;
 +drop table session;
 +
 +CREATE TABLE session (
 +	id			int auto_increment NOT NULL,
@@ -216,15 +162,36 @@
 +	error_file		varchar(64) NOT NULL,
 +	error_line		int NOT NULL,
 +	process_id		int NOT NULL,
 +	Primary Key (id),
 +	foreign key (session_id) references session (id)
 +);
---- orig/dblog-tables-postgresql.sql	2005-05-23 23:28:48
-+++ dblog-tables-postgresql.sql	2005-05-23 23:28:48
-@@ -0,0 +1,45 @@
++
++CREATE TABLE error (
++	id			int auto_increment NOT NULL,
++	session_id		int NOT NULL,
++	date			timestamp NOT NULL,
++	logcode			bigint NOT NULL,
++	error_number		bigint NOT NULL,
++	error_text		varchar(512),
++	PrimaryKey (id),
++	foreign key (session_id) references session (id)
++);
++
++CREATE TABLE delete (
++	id			serial NOT NULL,
++	session_id		int NOT NULL,
++	date			timestamp NOT NULL,
++	path			varchar(512) NOT NULL,
++	mode			int NOT NULL,
++	PrimaryKey (id),
++	foreign key (session_id) references session (id)
++);
+--- old/dblog-tables-postgresql.sql
++++ new/dblog-tables-postgresql.sql
+@@ -0,0 +1,67 @@
 +drop table transfer;
 +drop table exit;
 +drop table session;
 +drop sequence session_id_seq;
 +create sequence session_id_seq;
 +
@@ -264,15 +231,37 @@
 +	"error_file"		varchar(64) NOT NULL,
 +	"error_line"		int NOT NULL,
 +	"process_id"		int NOT NULL,
 +	Primary Key (id),
 +	foreign key (session_id) references session (id)
 +);
---- orig/dblog.c	2005-05-24 07:12:54
-+++ dblog.c	2005-05-24 07:12:54
-@@ -0,0 +1,360 @@
++
++CREATE TABLE "error" (
++	"id"			serial NOT NULL,
++	"session_id"		int NOT NULL,
++	"date"			timestamp NOT NULL default now(),
++	"logcode"		int NOT NULL,
++	"error_number"		int NOT NULL,
++	"error_text"		varchar(512),
++	Primary Key (id),
++	foreign key (session_id) references session (id)
++
++);
++
++CREATE TABLE "delete" (
++	"id"			serial NOT NULL,
++	"session_id"		int NOT NULL,
++	"date"			timestamp NOT NULL default now(),
++	"path"			varchar(512) NOT NULL,
++	"mode"			int NOT NULL,
++	Primary Key (id),
++	foreign key (session_id) references session (id)
++);
+--- old/dblog.c
++++ new/dblog.c
+@@ -0,0 +1,549 @@
 +/*
 + *  ODBC Database logging functions
 + *
 + *  Written by Steve Sether, April 2004
 + *  steve@vellmont.com
 + */
@@ -302,17 +291,23 @@
 +#include <odbc/sqltypes.h>
 +#endif
 +#endif
 +
 +SQLHENV db_environ_handle;			/* Handle ODBC environment */
 +long result;					/* result of functions */
-+SQLHDBC db_handle= NULL;			/* database connection handle */
-+SQLHSTMT sql_statement_handle;			/* SQL statement handle */
++SQLHDBC db_handle_g = NULL;			/* database connection handle for generator*/
++SQLHDBC db_handle_r = NULL;			/* database connection handle for sender */
++SQLHSTMT sql_statement_handle_g;		/* SQL statement handle for generator*/
++SQLHSTMT sql_statement_handle_r;		/* SQL statement handle for receiver*/
++extern int am_daemon;
 +extern int am_sender;
++extern int am_generator;
 +extern char *auth_user;
 +extern int module_id;
++extern int dry_run;
++
 +
 +char sql_status[10];				/* Status SQL */
 +SQLINTEGER V_OD_err, V_OD_rowanz, V_OD_id;
 +SQLSMALLINT V_OD_mlen, V_OD_colanz;
 +char V_OD_msg[200], V_OD_buffer[200];
 +SQLINTEGER session_id;
@@ -360,127 +355,202 @@
 +	*ptr = '\0';
 +	return out;
 +}
 +
 +void db_log_open(void)
 +{
-+	if (lp_database_logging(module_id)) {
-+		if (db_handle == NULL) {
-+			/* get ODBC environment handle */
-+			result = SQLAllocHandle(SQL_HANDLE_ENV,SQL_NULL_HANDLE,&db_environ_handle);
-+			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
-+				rprintf(FERROR, "Error: couldn't get database environment handle\n");
-+				return;
-+			}
++	if (!lp_database_logging(module_id))
++		return;
 +
-+			/* Setting database enviroment */
-+			result = SQLSetEnvAttr(db_environ_handle, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);
-+			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
-+				rprintf(FERROR, "Error: couldn't set database environment.\n");
-+				SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
-+				db_environ_handle = NULL;
-+				return;
-+			}
++	/* get ODBC environment handle */
++	result = SQLAllocHandle(SQL_HANDLE_ENV,SQL_NULL_HANDLE,&db_environ_handle);
++	if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++		rprintf(FERROR, "Error: couldn't get database environment handle\n");
++		return;
++	}
 +
-+			/* Get a database handle */
-+			result = SQLAllocHandle(SQL_HANDLE_DBC, db_environ_handle, &db_handle);
-+			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
-+				rprintf(FERROR, "Error: couldn't allocate database handle\n");
-+				SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
-+				db_environ_handle = NULL;
-+				return;
-+			}
++	/* Setting database enviroment */
++	result = SQLSetEnvAttr(db_environ_handle, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);
++	if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++		rprintf(FERROR, "Error: couldn't set database environment.\n");
++		SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
++		db_environ_handle = NULL;
++		return;
++	}
++	if (db_handle_g == NULL) {
++		/* Get a database handle for the generator*/
++		result = SQLAllocHandle(SQL_HANDLE_DBC, db_environ_handle, &db_handle_g);
++		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++			rprintf(FERROR, "Error: couldn't allocate database handle for generator\n");
++			SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
++			db_environ_handle = NULL;
++			return;
++		}
 +
-+			/* Set connection attributes */
-+			SQLSetConnectAttr(db_handle, SQL_LOGIN_TIMEOUT, (SQLPOINTER *)5, 0);
++		/* Set connection attributes for the generator db connection */
++		SQLSetConnectAttr(db_handle_g, SQL_LOGIN_TIMEOUT, (SQLPOINTER *)5, 0);
 +
-+			/* Connect to the database. */
-+			result = SQLConnect(db_handle, (SQLCHAR*) lp_database_datasource(module_id), SQL_NTS,
-+			    (SQLCHAR*) lp_database_username(module_id), SQL_NTS,
-+			    (SQLCHAR*) lp_database_password(module_id), SQL_NTS);
++		/* get the database connection for the generator. */
++		result = SQLConnect(db_handle_g, (SQLCHAR*) lp_database_datasource(module_id), SQL_NTS,
++		    (SQLCHAR*) lp_database_username(module_id), SQL_NTS,
++		    (SQLCHAR*) lp_database_password(module_id), SQL_NTS);
 +
-+			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
-+				SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1,
-+				    sql_status, &V_OD_err,V_OD_msg,100,&V_OD_mlen);
-+				rprintf(FERROR,"Error Connecting to Database %s\n",V_OD_msg);
-+				SQLFreeHandle(SQL_HANDLE_DBC,db_handle);
-+				db_handle = NULL;
-+				SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
-+				db_environ_handle = NULL;
-+				return;
-+			}
-+			rprintf(FLOG,"Connected to database!\n");
++		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++			SQLGetDiagRec(SQL_HANDLE_DBC, db_handle_g, 1,
++			    sql_status, &V_OD_err, V_OD_msg, 100, &V_OD_mlen);
++			rprintf(FERROR,"Error Connecting to Database (generator) %s\n",V_OD_msg);
++			SQLFreeHandle(SQL_HANDLE_DBC,db_handle_g);
++			db_handle_g = NULL;
++			SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
++			db_environ_handle = NULL;
++			return;
++		}
++		rprintf(FLOG,"Connected to database for generator!\n");
++	} else {
++		rprintf(FERROR,"Already connected to database for generator\n");
++	}
++	if (db_handle_r == NULL) {
++		/* Get a database handle for the receiver */
++		result = SQLAllocHandle(SQL_HANDLE_DBC, db_environ_handle, &db_handle_r);
++		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++			rprintf(FERROR, "Error: couldn't allocate database handle for receiver\n");
++			SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
++			db_environ_handle = NULL;
++			return;
++		}
 +
-+			/* get SQL statement handle */
-+			result = SQLAllocHandle(SQL_HANDLE_STMT, db_handle, &sql_statement_handle);
-+			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
-+				SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
-+				rprintf(FERROR,"Error in allocating SQL statement handle %s\n",V_OD_msg);
-+				SQLDisconnect(db_handle);
-+				SQLFreeHandle(SQL_HANDLE_DBC,db_handle);
-+				db_handle = NULL;
-+				SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
-+				db_environ_handle = NULL;
-+				return;
-+			}
-+		} else {
-+			rprintf(FERROR,"Already connected to database\n");
++		/* Set connection attributes for the receiver db connection */
++		SQLSetConnectAttr(db_handle_r, SQL_LOGIN_TIMEOUT, (SQLPOINTER *)5, 0);
++
++		/* get the generator connection for the receiver. */
++		result = SQLConnect(db_handle_r, (SQLCHAR*) lp_database_datasource(module_id), SQL_NTS,
++		    (SQLCHAR*) lp_database_username(module_id), SQL_NTS,
++		    (SQLCHAR*) lp_database_password(module_id), SQL_NTS);
++
++		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++			SQLGetDiagRec(SQL_HANDLE_DBC, db_handle_r,1,
++			    sql_status, &V_OD_err,V_OD_msg,100,&V_OD_mlen);
++			rprintf(FERROR,"Error Connecting to Database (receiver) %s\n",V_OD_msg);
++			SQLFreeHandle(SQL_HANDLE_DBC,db_handle_r);
++			db_handle_r = NULL;
++			SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
++			db_environ_handle = NULL;
++			return;
 +		}
++		rprintf(FLOG,"Connected to database for receiver!\n");
++	} else {
++		rprintf(FERROR,"Already connected to database for receiver\n");
++	}
++
++	/* get SQL statement handle for generator */
++	result = SQLAllocHandle(SQL_HANDLE_STMT, db_handle_g, &sql_statement_handle_g);
++	if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++		SQLGetDiagRec(SQL_HANDLE_DBC, db_handle_g,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
++		rprintf(FERROR,"Error in allocating SQL statement handle %s\n",V_OD_msg);
++		SQLDisconnect(db_handle_g);
++		SQLFreeHandle(SQL_HANDLE_DBC,db_handle_g);
++		db_handle_g = NULL;
++		SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
++		db_environ_handle = NULL;
++		return;
++	}
++
++	/* get SQL statement handle for receiver */
++	result = SQLAllocHandle(SQL_HANDLE_STMT, db_handle_r, &sql_statement_handle_r);
++	if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++		SQLGetDiagRec(SQL_HANDLE_DBC, db_handle_r,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
++		rprintf(FERROR,"Error in allocating SQL statement handle %s\n",V_OD_msg);
++		SQLDisconnect(db_handle_r);
++		SQLFreeHandle(SQL_HANDLE_DBC,db_handle_r);
++		db_handle_r = NULL;
++		SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
++		db_environ_handle = NULL;
++		return;
 +	}
 +}
 +
 +void db_log_close()
 +{
-+	if (lp_database_logging(module_id)) {
-+		if (sql_statement_handle != NULL) {
++	if (!lp_database_logging(module_id))
++		return;
++
++	if (am_generator) {
++		if (sql_statement_handle_g != NULL) {
 +			/* free the statement handle first */
-+			SQLFreeHandle(SQL_HANDLE_STMT,sql_statement_handle);
-+			sql_statement_handle = NULL;
++			SQLFreeHandle(SQL_HANDLE_STMT,sql_statement_handle_g);
++			sql_statement_handle_g = NULL;
 +		} else {
-+			rprintf(FERROR,"No sql statement handle to close\n");
++			rprintf(FERROR,"No generator sql statement handle to close\n");
 +		}
-+		if (db_handle != NULL) {
++
++		if (db_handle_g != NULL) {
 +			/* disconnect, and free the database handle. */
-+			SQLDisconnect(db_handle);
-+			SQLFreeHandle(SQL_HANDLE_DBC,db_handle);
-+			db_handle = NULL;
++			SQLDisconnect(db_handle_g);
++			SQLFreeHandle(SQL_HANDLE_DBC,db_handle_g);
++			db_handle_g = NULL;
 +		} else {
-+			rprintf(FERROR,"Database already closed");
++			rprintf(FERROR,"Generator database connection already closed\n");
 +		}
-+		if (db_environ_handle != NULL) {
-+			/* free the environment handle */
-+			SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
-+			db_environ_handle = NULL;
++	} else { /* must be receiver */
++		if (sql_statement_handle_r != NULL) {
++			/* free the statement handle first */
++			SQLFreeHandle(SQL_HANDLE_STMT,sql_statement_handle_r);
++			sql_statement_handle_r = NULL;
++		} else {
++			rprintf(FERROR,"No receiver sql statement handle to close\n");
++		}
++
++		if (db_handle_r != NULL) {
++			/* disconnect, and free the database handle. */
++			SQLDisconnect(db_handle_r);
++			SQLFreeHandle(SQL_HANDLE_DBC,db_handle_r);
++			db_handle_r = NULL;
 +		} else {
-+			rprintf(FERROR,"No environment handle to close");
++			rprintf(FERROR,"Receiver database connection already closed\n");
 +		}
 +	}
++
++	if (db_environ_handle != NULL) {
++		/* free the environment handle */
++		SQLFreeHandle(SQL_HANDLE_ENV, db_environ_handle);
++		db_environ_handle = NULL;
++	} else {
++		rprintf(FERROR,"No environment handle to close\n");
++	}
 +}
 +
 +static long get_unique_session_id()
 +{
 +	long unique;
 +	char strSqlStatement[1024];
++	SQLHDBC db_handle = (am_generator) ? db_handle_g : db_handle_r;
++	SQLHSTMT sql_statement_handle = (am_generator) ? sql_statement_handle_g : sql_statement_handle_r;
 +
 +	if (db_handle != NULL) {
 +		/* choose the appropriate select statement based upon which DBMS we're using.
 +		 * different datbases use different methods to get a unique ID.  Some use a counter
 +		 * object (sequence), others use an auto increment datatype and have a method
 +		 * to get the last ID inserted using this connection. */
 +		if (strcmp(lp_unique_id_method(module_id),"nextval-postgresql") == 0) {
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"SELECT NEXTVAL('%s');",lp_sequence_name(module_id));
++			snprintf(strSqlStatement, sizeof strSqlStatement,
++			    "SELECT NEXTVAL('%s');", lp_sequence_name(module_id));
 +		} else if (strcmp(lp_unique_id_method(module_id),"nextval-oracle") == 0) {
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"SELECT %s.NEXTVAL FROM dual;",lp_sequence_name(module_id));
++			snprintf(strSqlStatement, sizeof strSqlStatement,
++			    "SELECT %s.NEXTVAL FROM dual;", lp_sequence_name(module_id));
 +		} else if (strcmp(lp_unique_id_method(module_id),"nextval-db2") == 0) {
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"VALUES NEXTVAL FOR %s;",lp_sequence_name(module_id));
-+		} else if (strcmp(lp_unique_id_method(module_id),"last_insert_id") == 0) {  /* MySql */
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"SELECT LAST_INSERT_ID()");
-+		} else if (strcmp(lp_unique_id_method(module_id),"@@IDENTITY") == 0) {           /* Sybase */
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"SELECT @@IDENTITY");
-+		} else if (strcmp(lp_unique_id_method(module_id),"custom") == 0){     /* Users custom statement */
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),lp_custom_unique_id_select(module_id));
++			snprintf(strSqlStatement, sizeof strSqlStatement,
++			    "VALUES NEXTVAL FOR %s;",lp_sequence_name(module_id));
++		} else if (strcmp(lp_unique_id_method(module_id),"last_insert_id") == 0) { /* MySql */
++			snprintf(strSqlStatement, sizeof strSqlStatement,
++			    "SELECT LAST_INSERT_ID()");
++		} else if (strcmp(lp_unique_id_method(module_id),"@@IDENTITY") == 0) { /* Sybase */
++			snprintf(strSqlStatement, sizeof strSqlStatement,
++			    "SELECT @@IDENTITY");
++		} else if (strcmp(lp_unique_id_method(module_id),"custom") == 0){ /* Users custom statement */
++			snprintf(strSqlStatement, sizeof strSqlStatement,
++			    lp_custom_unique_id_select(module_id));
 +		}
 +
 +		/* bind the 1st column to unique */
 +		SQLBindCol(sql_statement_handle,1,SQL_C_LONG,&unique,150,&V_OD_err);
 +		/* execute the SQL statement */
 +		result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
@@ -505,31 +575,44 @@
 +		}
 +	}
 +	rprintf(FERROR,"Error at get_sequence: Not connected to database\n");
 +	return -1;
 +}
 +
-+
 +void db_log_session()
 +{
 +	char strSqlStatement[1024];
 +	int gotSessionID = 0;
-+	if (lp_database_logging(module_id)) {
-+		/* if we're using a sequence via the nextval command to get a unique ID, we need to get it before
-+		 * we do the insert. We also get the unique ID  now if custom, and get_custom_id_before_insert is set. */
++	SQLHDBC db_handle = (am_generator) ? db_handle_g : db_handle_r;
++	SQLHSTMT sql_statement_handle = (am_generator) ? sql_statement_handle_g : sql_statement_handle_r;
++
++	if (!lp_database_logging(module_id))
++		return;
++
++	if (db_handle != NULL) {
++		/* if we're using a sequence via the nextval command to
++		 * get a unique ID, we need to get it before we do the
++		 * insert. We also get the unique ID  now if custom,
++		 * and get_custom_id_before_insert is set. */
 +		if (strcmp(lp_unique_id_method(module_id),"nextval-postgresql") == 0
-+		    || strcmp(lp_unique_id_method(module_id),"nextval-oracle") == 0
-+		    || strcmp(lp_unique_id_method(module_id),"nextval-db2") == 0
-+		    || (strcmp(lp_unique_id_method(module_id),"custom") == 0
-+		     && lp_get_custom_id_before_insert(module_id))) {
++		 || strcmp(lp_unique_id_method(module_id),"nextval-oracle") == 0
++		 || strcmp(lp_unique_id_method(module_id),"nextval-db2") == 0
++		 || (strcmp(lp_unique_id_method(module_id),"custom") == 0
++		  && lp_get_custom_id_before_insert(module_id))) {
 +			session_id = get_unique_session_id();
 +			gotSessionID = 1;
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"INSERT INTO %s (id, date, ip_address, username, module_name, module_path, process_id) VALUES ('%ld', '%s', '%s', '%s','%s','%s','%d');",lp_session_table_name(module_id),session_id,timestring(time(NULL)),client_addr(0),auth_user,lp_name(module_id),lp_path(module_id),getpid());
++			snprintf(strSqlStatement, sizeof strSqlStatement,
++			    "INSERT INTO %s (id, date, ip_address, username, module_name, module_path, process_id) VALUES ('%ld', '%s', '%s', '%s','%s','%s','%d');",
++			    lp_session_table_name(module_id), session_id, timestring(time(NULL)), client_addr(0),
++			    auth_user, lp_name(module_id), lp_path(module_id), getpid());
 +		} else {
 +			/* Otherwise the ID gets created automatically, and we get the ID it used after the insert. */
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"INSERT INTO %s (date, ip_address, username, module_name, module_path, process_id) VALUES ('%s', '%s', '%s', '%s','%s','%d');",lp_session_table_name(module_id),timestring(time(NULL)),client_addr(0),auth_user,lp_name(module_id),lp_path(module_id),getpid());
++			snprintf(strSqlStatement, sizeof strSqlStatement,
++			    "INSERT INTO %s (date, ip_address, username, module_name, module_path, process_id) VALUES ('%s', '%s', '%s', '%s','%s','%d');",
++			    lp_session_table_name(module_id), timestring(time(NULL)), client_addr(0), auth_user,
++			    lp_name(module_id), lp_path(module_id), getpid());
 +		}
 +
 +		/* Insert the new session into the database */
 +		result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
 +		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
 +			SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
@@ -543,14 +626,13 @@
 +			rprintf(FERROR,"Error in resetting SQL statement handle %s\n",V_OD_msg);
 +		}
 +		/* get the session ID for databases that give the unique ID after an insert */
 +		if (gotSessionID == 0) {
 +			session_id = get_unique_session_id();
 +		}
-+	}
-+	else {
++	} else {
 +		rprintf(FERROR,"Error at db_log_session:  Not connected to database!\n");
 +	}
 +}
 +
 +void db_log_transfer(struct file_struct *file,struct stats *initial_stats,char *operation)
 +{
@@ -558,196 +640,939 @@
 +	char strSqlStatement[2048];
 +	char strFileName[MAXPATHLEN];
 +	char *strFileNamePtr;
 +	char strFileSize[255];
 +	int64 intBytesTransferred;
 +	int64 intCheckSumBytes;
++	SQLHDBC db_handle = (am_generator) ? db_handle_g : db_handle_r;
++	SQLHSTMT sql_statement_handle = (am_generator) ? sql_statement_handle_g : sql_statement_handle_r;
 +
-+	if (lp_database_logging(module_id)) {
-+		if (db_handle != NULL) {
-+			strFileNamePtr = safe_fname(f_name(file));
-+			if (am_sender && file->dir.root) {
-+				pathjoin(strFileName, sizeof strFileName,
-+					 file->dir.root, strFileNamePtr);
-+				strFileNamePtr = strFileName;
-+			}
-+			clean_fname(strFileNamePtr, 0);
-+			if (*strFileNamePtr == '/')
-+				strFileNamePtr++;
-+
-+			snprintf(strFileSize,sizeof(strFileSize),"%.0f", (double)file->length);
-+			if (am_sender) {
-+				intBytesTransferred = stats.total_written - initial_stats->total_written;
-+			} else {
-+				intBytesTransferred = stats.total_read - initial_stats->total_read;
-+			}
++	if (!lp_database_logging(module_id))
++		return;
 +
-+			if (!am_sender) {
-+				intCheckSumBytes = stats.total_written - initial_stats->total_written;
-+			} else {
-+				intCheckSumBytes = stats.total_read - initial_stats->total_read;
-+			}
++	if (db_handle != NULL) {
++		strFileNamePtr = f_name(file, NULL);
++		if (am_sender && file->dir.root) {
++			pathjoin(strFileName, sizeof strFileName,
++				 file->dir.root, strFileNamePtr);
++			strFileNamePtr = strFileName;
++		}
++		clean_fname(strFileNamePtr, 0);
++		if (*strFileNamePtr == '/')
++			strFileNamePtr++;
++
++		snprintf(strFileSize, sizeof strFileSize, "%.0f", (double)file->length);
++		if (am_sender) {
++			intBytesTransferred = stats.total_written - initial_stats->total_written;
++		} else {
++			intBytesTransferred = stats.total_read - initial_stats->total_read;
++		}
 +
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"INSERT INTO %s (session_id,date, file_name, file_size, bytes_transferred, checksum_bytes_transferred, operation) VALUES ('%ld','%s','%s','%s','%Ld','%Ld','%s');",lp_transfer_table_name(module_id),session_id,timestring(time(NULL)),sanitizeSql(strFileNamePtr),strFileSize,intBytesTransferred,intCheckSumBytes,operation);
-+			result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
-+			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
-+				SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
-+				rprintf(FERROR,"Error at db_log_transfer:  Error in Insert %s %s\n",strSqlStatement,V_OD_msg);
-+				if (result == SQL_INVALID_HANDLE)
-+					rprintf(FERROR,"INVALID HANDLE\n");
-+			}
++		if (!am_sender) {
++			intCheckSumBytes = stats.total_written - initial_stats->total_written;
 +		} else {
-+			rprintf(FERROR,"Error at db_log_transfer: Not connected to database!\n");
++			intCheckSumBytes = stats.total_read - initial_stats->total_read;
++		}
++
++		snprintf(strSqlStatement, sizeof strSqlStatement,
++		    "INSERT INTO %s (session_id,date, file_name, file_size, bytes_transferred, checksum_bytes_transferred, operation) VALUES ('%ld','%s','%s','%s','%Ld','%Ld','%s');",
++		    lp_transfer_table_name(module_id), session_id, timestring(time(NULL)),
++		    sanitizeSql(strFileNamePtr), strFileSize, intBytesTransferred,
++		    intCheckSumBytes, operation);
++		result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
++		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++			SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
++			rprintf(FERROR,"Error at db_log_transfer:  Error in Insert %s %s\n",strSqlStatement,V_OD_msg);
++			if (result == SQL_INVALID_HANDLE)
++				rprintf(FERROR,"INVALID HANDLE\n");
 +		}
++	} else {
++		rprintf(FERROR,"Error at db_log_transfer: Not connected to database!\n");
 +	}
 +}
 +
-+
 +void db_log_exit(int code, const char *file, int line)
 +{
 +	char strSqlStatement[2048];
 +	const char *error_text;
 +	extern struct stats stats;
++	SQLHDBC db_handle = (am_generator) ? db_handle_g : db_handle_r;
++	SQLHSTMT sql_statement_handle = (am_generator) ? sql_statement_handle_g : sql_statement_handle_r;
++
++	if (!lp_database_logging(module_id))
++		return;
++
 +	if (db_handle != NULL) {
-+		if (lp_database_logging(module_id)) {
-+			if (code != 0) {
-+				error_text = rerr_name(code);
-+				if (!error_text) {
-+					error_text = "unexplained error";
-+				}
-+			} else {
-+				error_text = "";
++		if (code != 0) {
++			error_text = rerr_name(code);
++			if (!error_text) {
++				error_text = "unexplained error";
 +			}
-+			snprintf(strSqlStatement,sizeof(strSqlStatement),"INSERT INTO %s (session_id, date, total_bytes_written,total_bytes_read,total_size,error_text,error_code,error_file,error_line,process_id) VALUES ('%ld','%s','%Ld','%Ld','%Ld','%s','%d','%s','%d','%d');",lp_exit_table_name(module_id),session_id,timestring(time(NULL)),stats.total_written,stats.total_read,stats.total_size,error_text,code,file,line,getpid());
++		} else {
++			error_text = "";
++		}
++		snprintf(strSqlStatement, sizeof strSqlStatement,
++		    "INSERT INTO %s (session_id, date, total_bytes_written,total_bytes_read,total_size,error_text,error_code,error_file,error_line,process_id) VALUES ('%ld','%s','%Ld','%Ld','%Ld','%s','%d','%s','%d','%d');",
++		    lp_exit_table_name(module_id), session_id, timestring(time(NULL)), stats.total_written,
++		    stats.total_read, stats.total_size, error_text, code, file, line, getpid());
 +
-+			result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
++		result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
 +
-+			if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
-+				SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
-+				rprintf(FERROR,"Error at db_log_exit: Error in Insert %s %s\n",strSqlStatement,V_OD_msg);
-+			}
++		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++			SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
++			rprintf(FERROR,"Error at db_log_exit: Error in Insert %s %s\n",strSqlStatement,V_OD_msg);
 +		}
 +	} else {
 +		rprintf(FERROR,"Error at db_log_exit: Not connected to database!\n");
 +	}
 +}
---- orig/loadparm.c	2005-07-28 18:48:38
-+++ loadparm.c	2005-05-23 23:29:42
-@@ -124,6 +124,17 @@ typedef struct
- 	BOOL list;
- 	BOOL use_chroot;
- 	BOOL transfer_logging;
-+	BOOL database_logging;
++
++void db_log_delete(char *fname, int mode)
++{
++	char strSqlStatement[2048];
++	SQLHDBC db_handle = (am_generator) ? db_handle_g : db_handle_r;
++	SQLHSTMT sql_statement_handle = (am_generator) ? sql_statement_handle_g : sql_statement_handle_r;
++
++	if (!am_daemon || dry_run || !lp_database_logging(module_id))
++		return;
++
++	if (db_handle != NULL) {
++		snprintf(strSqlStatement, sizeof strSqlStatement,
++		    "INSERT INTO %s (session_id, date, path, mode) VALUES ('%ld','%s','%s','%d');",
++		    lp_delete_table_name(module_id), session_id, timestring(time(NULL)), sanitizeSql(fname), mode);
++
++		result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
++
++		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++			SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
++			rprintf(FERROR,"Error at db_log_delete: Error in Insert %s %s\n",strSqlStatement,V_OD_msg);
++		}
++	} else {
++		rprintf(FERROR,"Error at db_log_delete: Not connected to database!\n");
++	}
++}
++
++void db_log_error(enum logcode code, int errcode, const char *format,...)
++{
++	char strSqlStatement[MAXPATHLEN+1024];
++	va_list ap;
++	char buf[MAXPATHLEN+512];
++	size_t len;
++	SQLHDBC db_handle = (am_generator) ? db_handle_g : db_handle_r;
++	SQLHSTMT sql_statement_handle = (am_generator) ? sql_statement_handle_g : sql_statement_handle_r;
++
++	if (!lp_database_logging(module_id))
++		return;
++
++	va_start(ap, format);
++	len = vsnprintf(buf, sizeof buf, format, ap);
++	va_end(ap);
++
++	/* Deal with buffer overruns.  Instead of panicking, just
++	 * truncate the resulting string.  (Note that configure ensures
++	 * that we have a vsnprintf() that doesn't ever return -1.) */
++	if (len > sizeof buf - 1) {
++		const char ellipsis[] = "[...]";
++
++		/* Reset length, and zero-terminate the end of our buffer */
++		len = sizeof buf - 1;
++		buf[len] = '\0';
++
++		/* Copy the ellipsis to the end of the string, but give
++		 * us one extra character:
++		 *
++		 *                  v--- null byte at buf[sizeof buf - 1]
++		 *        abcdefghij0
++		 *     -> abcd[...]00  <-- now two null bytes at end
++		 *
++		 * If the input format string has a trailing newline,
++		 * we copy it into that extra null; if it doesn't, well,
++		 * all we lose is one byte.  */
++		strncpy(buf+len-sizeof ellipsis, ellipsis, sizeof ellipsis);
++		if (format[strlen(format)-1] == '\n') {
++			buf[len-1] = '\n';
++		}
++	}
++
++	if (db_handle != NULL) {
++		snprintf(strSqlStatement, sizeof strSqlStatement,
++		    "INSERT INTO %s (session_id, date, logcode, error_number, error_text) VALUES ('%ld','%s','%d','%d','%s');",
++		    lp_error_table_name(module_id), session_id, timestring(time(NULL)), code, errcode, sanitizeSql(buf));
++
++		result = SQLExecDirect(sql_statement_handle,strSqlStatement,SQL_NTS);
++
++		if (result != SQL_SUCCESS && result != SQL_SUCCESS_WITH_INFO) {
++			SQLGetDiagRec(SQL_HANDLE_DBC, db_handle,1, sql_status,&V_OD_err,V_OD_msg,100,&V_OD_mlen);
++			rprintf(FERROR,"Error at db_log_error: Error in Insert %s %s\n",strSqlStatement,V_OD_msg);
++		}
++	} else {
++		rprintf(FERROR,"Error at db_log_error: Not connected to database!\n");
++	}
++}
+--- old/instructions
++++ new/instructions
+@@ -0,0 +1,84 @@
++This patch adds the following options:
++
++"database logging"
++    If set to True, rsync will attempt to connect to
++    the specified datasource and write to the named tables.
++    Defaults to False.
++
++"database datasource"
++    Specifies the name of the ODBC data source to use.
++
++"database username"
++    The username to use when connecting to the database.
++
++"database password"
++    The password to use when connecting to the database.
++
++"transfer table name"
++    The name of the transfer table to log to.  This table contains individual
++    filenames, file sizes, bytes transferred, checksum bytes transferred,
++    operation (send or receive), and a timestamp.
++
++"session table name"
++    The name of the session table to log to.  This table contains the username,
++    module name, module path, ip address, process ID, and a timestamp.
++
++"exit table name"
++
++    The name of the exit table to log to.  This table contains the total bytes
++    read, total bytes written, total size of all files, error code, line the
++    error occured at, file the error occured at and the text of the error.
++    (most of which will be blank if the program exited normally).
++
++"delete table name"
++
++    The name of the table to log deleted files/directories to.
++
++"error table name"
++
++   The name of the table errors will be logged to.
++
++"unique id method"
++    Different databases use different methods to get a unique identifier.
++    Some databases support sequence objects, and use various forms of the
++    nextval command to retrieve a unique identifier from it.  Other databases
++    support an autonumber field, and support different methds of retrieving
++    the ID used in the last insert.  Valid values for this option are:
++
++	nextval-postgres
++	    uses the syntax of nextval for PostgreSQL databases
++
++	nextval-oracle
++	    uses the syntax of nextval for Oracle databases
++
++	nextval-db2
++	    uses the syntax of nextval for DB2 databases
++
++	last_insert_id
++	    uses the last_insert_id() command for the MySQL databases
++
++	@@IDENTITY
++	    uses the @@IDENTITY command for Sybase databases
++
++	custom
++	    Define your own method to get a unique identifier.  See the
++	    "custom unique id select", and the "get custom id before select"
++	    parameters.
++
++"sequence name"
++    If your database supports sequences, list the name of the sequence to use
++    for the session unique identifier.
++
++"custom unique id select"
++    Only used if you specify the custom method in "unique id method".  This is
++    a SQL statement to be executed to get a unique ID.  This SQL statement must
++    return one column with the unique ID to use for the session ID.  Should be
++    used in concert with the "get custom id before select" parameter.
++
++"get custom id before insert"
++    This parameter is ignored unless the "unique id method" is set to custom.
++    If set to true, the "custom unique id select" statement will be executed
++    BEFORE the session row is inserted into the database.  (as is done when a
++    sequence is used for unique IDs).  If False the statement will be executed
++    after the session row is inserted (as is done when the session ID is
++    automatically generates unique IDs).  Defaults to True.
+--- old/loadparm.c
++++ new/loadparm.c
+@@ -120,9 +120,16 @@ typedef struct
+ {
+ 	char *auth_users;
+ 	char *comment;
++	char *custom_unique_id_select;
 +	char *database_datasource;
-+	char *database_username;
 +	char *database_password;
-+	char *transfer_table_name;
++	char *database_username;
++	char *delete_table_name;
+ 	char *dont_compress;
++	char *error_table_name;
+ 	char *exclude;
+ 	char *exclude_from;
 +	char *exit_table_name;
-+	char *session_table_name;
+ 	char *filter;
+ 	char *gid;
+ 	char *hosts_allow;
+@@ -139,13 +146,19 @@ typedef struct
+ 	char *prexfer_exec;
+ 	char *refuse_options;
+ 	char *secrets_file;
 +	char *sequence_name;
++	char *session_table_name;
+ 	char *temp_dir;
++	char *transfer_table_name;
+ 	char *uid;
 +	char *unique_id_method;
-+	char *custom_unique_id_select;
+ 
+ 	int max_connections;
+ 	int max_verbosity;
+ 	int timeout;
+ 
++	BOOL database_logging;
 +	BOOL get_custom_id_before_insert;
  	BOOL ignore_errors;
- 	char *uid;
- 	char *gid;
-@@ -159,6 +170,17 @@ static service sDefault =
- 	True,    /* list */
- 	True,    /* use chroot */
- 	False,   /* transfer logging */
-+	False,   /* Database Logging */
-+	NULL,    /* Database datasource */
-+	NULL,    /* Database username */
-+	NULL,    /* Database password */
-+	NULL,    /* Transfer table name */
-+	NULL,    /* Exit table name */
-+	NULL,    /* Session table name */
-+	NULL,    /* sequence name */
-+	NULL,    /* unique method */
-+	NULL,    /* custom unique id select*/
-+	True,    /* get custom id before insert */
- 	False,   /* ignore errors */
- 	NOBODY_USER,/* uid */
- 	NOBODY_GROUP,/* gid */
-@@ -294,6 +316,17 @@ static struct parm_struct parm_table[] =
-   {"include",          P_STRING,  P_LOCAL,  &sDefault.include,     NULL,   0},
-   {"include from",     P_STRING,  P_LOCAL,  &sDefault.include_from,NULL,   0},
-   {"transfer logging", P_BOOL,    P_LOCAL,  &sDefault.transfer_logging,NULL,0},
-+  {"database logging", P_BOOL,    P_LOCAL,  &sDefault.database_logging,NULL,0},
-+  {"database datasource",P_STRING,P_LOCAL,  &sDefault.database_datasource,NULL,0},
-+  {"database username",P_STRING,  P_LOCAL,  &sDefault.database_username,NULL,0},
-+  {"database password",P_STRING,  P_LOCAL,  &sDefault.database_password,NULL,0},
-+  {"transfer table name",P_STRING,P_LOCAL,  &sDefault.transfer_table_name,NULL,0},
-+  {"exit table name",  P_STRING,  P_LOCAL,  &sDefault.exit_table_name,NULL,0},
-+  {"session table name",P_STRING, P_LOCAL,  &sDefault.session_table_name,NULL,0},
-+  {"sequence name",    P_STRING,  P_LOCAL,  &sDefault.sequence_name,NULL,0},
-+  {"unique id method", P_STRING,  P_LOCAL,  &sDefault.unique_id_method,NULL,0},
-+  {"custom unique id select",P_STRING,P_LOCAL,&sDefault.custom_unique_id_select,NULL,0},
-+  {"get custom id before insert",P_BOOL,P_LOCAL,&sDefault.get_custom_id_before_insert,NULL,0},
-   {"ignore errors",    P_BOOL,    P_LOCAL,  &sDefault.ignore_errors,NULL,0},
-   {"log format",       P_STRING,  P_LOCAL,  &sDefault.log_format,  NULL,   0},
-   {"refuse options",   P_STRING,  P_LOCAL,  &sDefault.refuse_options,NULL, 0},
-@@ -362,6 +395,17 @@ FN_LOCAL_BOOL(lp_write_only, write_only)
- FN_LOCAL_BOOL(lp_list, list)
- FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
- FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
-+FN_LOCAL_BOOL(lp_database_logging, database_logging)
+ 	BOOL ignore_nonreadable;
+ 	BOOL list;
+@@ -165,9 +178,16 @@ static service sDefault =
+ {
+  /* auth_users; */		NULL,
+  /* comment; */			NULL,
++ /* custom_unique_id_select; */	NULL,
++ /* database_datasource; */	NULL,
++ /* database_password; */	NULL,
++ /* database_username; */	NULL,
++ /* delete_table_name; */	NULL,
+  /* dont_compress; */		"*.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz",
++ /* error_table_name; */	NULL,
+  /* exclude; */			NULL,
+  /* exclude_from; */		NULL,
++ /* exit_table_name; */		NULL,
+  /* filter; */			NULL,
+  /* gid; */			NOBODY_GROUP,
+  /* hosts_allow; */		NULL,
+@@ -184,13 +204,19 @@ static service sDefault =
+  /* prexfer_exec; */		NULL,
+  /* refuse_options; */		NULL,
+  /* secrets_file; */		NULL,
++ /* sequence_name; */		NULL,
++ /* session_table_name; */	NULL,
+  /* temp_dir; */ 		NULL,
++ /* transfer_table_name; */	NULL,
+  /* uid; */			NOBODY_USER,
++ /* unique_id_method; */	NULL,
+ 
+  /* max_connections; */		0,
+  /* max_verbosity; */		1,
+  /* timeout; */			0,
+ 
++ /* database_logging; */	False,
++ /* get_custom_id_before_insert; */ True,
+  /* ignore_errors; */		False,
+  /* ignore_nonreadable; */	False,
+  /* list; */			True,
+@@ -291,10 +317,19 @@ static struct parm_struct parm_table[] =
+ 
+  {"auth users",        P_STRING, P_LOCAL, &sDefault.auth_users,        NULL,0},
+  {"comment",           P_STRING, P_LOCAL, &sDefault.comment,           NULL,0},
++ {"custom unique id select",P_STRING,P_LOCAL,&sDefault.custom_unique_id_select,NULL,0},
++ {"database datasource",P_STRING,P_LOCAL, &sDefault.database_datasource,NULL,0},
++ {"database logging",  P_BOOL,   P_LOCAL, &sDefault.database_logging,  NULL,0},
++ {"database password", P_STRING, P_LOCAL, &sDefault.database_password, NULL,0},
++ {"database username", P_STRING, P_LOCAL, &sDefault.database_username, NULL,0},
++ {"delete table name", P_STRING, P_LOCAL, &sDefault.delete_table_name, NULL,0},
+  {"dont compress",     P_STRING, P_LOCAL, &sDefault.dont_compress,     NULL,0},
++ {"error table name",  P_STRING, P_LOCAL, &sDefault.error_table_name,  NULL,0},
+  {"exclude from",      P_STRING, P_LOCAL, &sDefault.exclude_from,      NULL,0},
+  {"exclude",           P_STRING, P_LOCAL, &sDefault.exclude,           NULL,0},
++ {"exit table name",   P_STRING, P_LOCAL, &sDefault.exit_table_name,   NULL,0},
+  {"filter",            P_STRING, P_LOCAL, &sDefault.filter,            NULL,0},
++ {"get custom id before insert",P_BOOL,P_LOCAL,&sDefault.get_custom_id_before_insert,NULL,0},
+  {"gid",               P_STRING, P_LOCAL, &sDefault.gid,               NULL,0},
+  {"hosts allow",       P_STRING, P_LOCAL, &sDefault.hosts_allow,       NULL,0},
+  {"hosts deny",        P_STRING, P_LOCAL, &sDefault.hosts_deny,        NULL,0},
+@@ -318,11 +353,15 @@ static struct parm_struct parm_table[] =
+  {"read only",         P_BOOL,   P_LOCAL, &sDefault.read_only,         NULL,0},
+  {"refuse options",    P_STRING, P_LOCAL, &sDefault.refuse_options,    NULL,0},
+  {"secrets file",      P_STRING, P_LOCAL, &sDefault.secrets_file,      NULL,0},
++ {"sequence name",     P_STRING, P_LOCAL, &sDefault.sequence_name,     NULL,0},
++ {"session table name",P_STRING, P_LOCAL, &sDefault.session_table_name,NULL,0},
+  {"strict modes",      P_BOOL,   P_LOCAL, &sDefault.strict_modes,      NULL,0},
+  {"temp dir",          P_PATH,   P_LOCAL, &sDefault.temp_dir,          NULL,0},
+  {"timeout",           P_INTEGER,P_LOCAL, &sDefault.timeout,           NULL,0},
+  {"transfer logging",  P_BOOL,   P_LOCAL, &sDefault.transfer_logging,  NULL,0},
++ {"transfer table name",P_STRING,P_LOCAL, &sDefault.transfer_table_name,NULL,0},
+  {"uid",               P_STRING, P_LOCAL, &sDefault.uid,               NULL,0},
++ {"unique id method",  P_STRING, P_LOCAL, &sDefault.unique_id_method,  NULL,0},
+  {"use chroot",        P_BOOL,   P_LOCAL, &sDefault.use_chroot,        NULL,0},
+  {"write only",        P_BOOL,   P_LOCAL, &sDefault.write_only,        NULL,0},
+  {NULL,                P_BOOL,   P_NONE,  NULL,                        NULL,0}
+@@ -383,9 +422,16 @@ FN_GLOBAL_INTEGER(lp_syslog_facility, &G
+ 
+ FN_LOCAL_STRING(lp_auth_users, auth_users)
+ FN_LOCAL_STRING(lp_comment, comment)
++FN_LOCAL_STRING(lp_custom_unique_id_select,custom_unique_id_select)
 +FN_LOCAL_STRING(lp_database_datasource, database_datasource)
-+FN_LOCAL_STRING(lp_database_username, database_username)
 +FN_LOCAL_STRING(lp_database_password, database_password)
-+FN_LOCAL_STRING(lp_transfer_table_name, transfer_table_name)
++FN_LOCAL_STRING(lp_database_username, database_username)
++FN_LOCAL_STRING(lp_delete_table_name,delete_table_name)
+ FN_LOCAL_STRING(lp_dont_compress, dont_compress)
++FN_LOCAL_STRING(lp_error_table_name,error_table_name)
+ FN_LOCAL_STRING(lp_exclude, exclude)
+ FN_LOCAL_STRING(lp_exclude_from, exclude_from)
 +FN_LOCAL_STRING(lp_exit_table_name, exit_table_name)
-+FN_LOCAL_STRING(lp_session_table_name,session_table_name)
+ FN_LOCAL_STRING(lp_filter, filter)
+ FN_LOCAL_STRING(lp_gid, gid)
+ FN_LOCAL_STRING(lp_hosts_allow, hosts_allow)
+@@ -402,13 +448,19 @@ FN_LOCAL_STRING(lp_postxfer_exec, postxf
+ FN_LOCAL_STRING(lp_prexfer_exec, prexfer_exec)
+ FN_LOCAL_STRING(lp_refuse_options, refuse_options)
+ FN_LOCAL_STRING(lp_secrets_file, secrets_file)
 +FN_LOCAL_STRING(lp_sequence_name,sequence_name)
++FN_LOCAL_STRING(lp_session_table_name,session_table_name)
+ FN_LOCAL_STRING(lp_temp_dir, temp_dir)
++FN_LOCAL_STRING(lp_transfer_table_name, transfer_table_name)
+ FN_LOCAL_STRING(lp_uid, uid)
 +FN_LOCAL_STRING(lp_unique_id_method,unique_id_method)
-+FN_LOCAL_STRING(lp_custom_unique_id_select,custom_unique_id_select)
+ 
+ FN_LOCAL_INTEGER(lp_max_connections, max_connections)
+ FN_LOCAL_INTEGER(lp_max_verbosity, max_verbosity)
+ FN_LOCAL_INTEGER(lp_timeout, timeout)
+ 
++FN_LOCAL_BOOL(lp_database_logging, database_logging)
 +FN_LOCAL_BOOL(lp_get_custom_id_before_insert,get_custom_id_before_insert)
  FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
  FN_LOCAL_BOOL(lp_ignore_nonreadable, ignore_nonreadable)
- FN_LOCAL_STRING(lp_uid, uid)
---- orig/log.c	2005-06-09 22:27:22
-+++ log.c	2005-05-23 23:29:54
-@@ -84,7 +84,7 @@ struct {
+ FN_LOCAL_BOOL(lp_list, list)
+--- old/log.c
++++ new/log.c
+@@ -95,7 +95,7 @@ struct {
  /*
   * Map from rsync error code to name, or return NULL.
   */
 -static char const *rerr_name(int code)
 +char const *rerr_name(int code)
  {
  	int i;
  	for (i = 0; rerr_names[i].name; i++) {
---- orig/main.c	2005-07-28 18:48:38
-+++ main.c	2005-05-23 23:30:01
-@@ -144,6 +144,9 @@ static void handle_stats(int f)
+--- old/main.c
++++ new/main.c
+@@ -169,6 +169,9 @@ static void handle_stats(int f)
  
  	if (am_daemon) {
  		log_exit(0, __FILE__, __LINE__);
 +#ifdef HAVE_LIBODBC
 +		db_log_exit(0,__FILE__,__LINE__);
 +#endif
  		if (f == -1 || !am_sender)
  			return;
  	}
---- orig/receiver.c	2005-07-28 18:48:38
-+++ receiver.c	2005-05-23 23:30:07
-@@ -640,6 +640,9 @@ int recv_files(int f_in, struct file_lis
+--- old/receiver.c
++++ new/receiver.c
+@@ -108,6 +108,10 @@ static int get_tmpname(char *fnametmp, c
+ 
+ 	if (maxname < 1) {
+ 		rprintf(FERROR, "temporary filename too long: %s\n", fname);
++#ifdef HAVE_LIBODBC
++		db_log_error(FERROR,13, "temporary filename too long: %s\n",
++			fname);
++#endif
+ 		fnametmp[0] = '\0';
+ 		return 0;
+ 	}
+@@ -224,6 +228,11 @@ static int receive_data(int f_in, char *
+ 					rsyserr(FERROR, errno,
+ 						"lseek failed on %s",
+ 						full_fname(fname));
++#ifdef HAVE_LIBODBC
++					db_log_error(FERROR, 14,
++						"lseek failed on %s",
++						full_fname(fname));
++#endif
+ 					exit_cleanup(RERR_FILEIO);
+ 				}
+ 				continue;
+@@ -249,6 +258,9 @@ static int receive_data(int f_in, char *
+ 	    report_write_error:
+ 		rsyserr(FERROR, errno, "write failed on %s",
+ 			full_fname(fname));
++#ifdef HAVE_LIBODBC
++		db_log_error(FERROR, 15, "write failed on %s",full_fname(fname));
++#endif
+ 		exit_cleanup(RERR_FILEIO);
+ 	}
+ 
+@@ -292,6 +304,12 @@ static void handle_delayed_updates(struc
+ 				rsyserr(FERROR, errno,
+ 					"rename failed for %s (from %s)",
+ 					full_fname(fname), partialptr);
++#ifdef HAVE_LIBODBC
++				db_log_error(FERROR, 16,
++					"rename failed for %s (from %s)",
++					full_fname(fname),
++					partialptr);
++#endif
+ 			} else {
+ 				if (remove_sent_files
+ 				    || (preserve_hard_links
+@@ -414,6 +432,9 @@ int recv_files(int f_in, struct file_lis
+ 		if (server_filter_list.head
+ 		    && check_filter(&server_filter_list, fname, 0) < 0) {
+ 			rprintf(FERROR, "attempt to hack rsync failed.\n");
++#ifdef HAVE_LIBODBC
++				db_log_error(FERROR,17,"attempt to hack rsync failed.");
++#endif
+ 			exit_cleanup(RERR_PROTOCOL);
+ 		}
+ 
+@@ -469,6 +490,11 @@ int recv_files(int f_in, struct file_lis
+ 					rprintf(FERROR,
+ 						"invalid basis_dir index: %d.\n",
+ 						fnamecmp_type);
++#ifdef HAVE_LIBODBC
++					db_log_error(FERROR, 18,
++						"invalid basis_dir index: %d.\n",
++						fnamecmp_type);
++#endif
+ 					exit_cleanup(RERR_PROTOCOL);
+ 				}
+ 				pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
+@@ -514,6 +540,9 @@ int recv_files(int f_in, struct file_lis
+ 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
+ 			rsyserr(FERROR, errno, "fstat %s failed",
+ 				full_fname(fnamecmp));
++#ifdef HAVE_LIBODBC
++				db_log_error(FERROR, 19,"fstat %s failed",full_fname(fnamecmp));
++#endif
+ 			discard_receive_data(f_in, file->length);
+ 			close(fd1);
+ 			continue;
+@@ -527,6 +556,9 @@ int recv_files(int f_in, struct file_lis
+ 			 */
+ 			rprintf(FERROR,"recv_files: %s is a directory\n",
+ 				full_fname(fnamecmp));
++#ifdef HAVE_LIBODBC
++				db_log_error(FERROR,20,"recv_files: %s is a directory",full_fname(fnamecmp));
++#endif
+ 			discard_receive_data(f_in, file->length);
+ 			close(fd1);
+ 			continue;
+@@ -550,6 +582,9 @@ int recv_files(int f_in, struct file_lis
+ 			if (fd2 == -1) {
+ 				rsyserr(FERROR, errno, "open %s failed",
+ 					full_fname(fname));
++#ifdef HAVE_LIBODBC
++					db_log_error(FERROR,22, "open %s failed", full_fname(fname));
++#endif
+ 				discard_receive_data(f_in, file->length);
+ 				if (fd1 != -1)
+ 					close(fd1);
+@@ -583,6 +618,10 @@ int recv_files(int f_in, struct file_lis
+ 			if (fd2 == -1) {
+ 				rsyserr(FERROR, errno, "mkstemp %s failed",
+ 					full_fname(fnametmp));
++#ifdef HAVE_LIBODBC
++					db_log_error(FERROR, 22, "mkstemp %s failed",
++					full_fname(fnametmp));
++#endif
+ 				discard_receive_data(f_in, file->length);
+ 				if (fd1 != -1)
+ 					close(fd1);
+@@ -605,12 +644,19 @@ int recv_files(int f_in, struct file_lis
  
  		if (!log_before_transfer)
  			log_item(file, &initial_stats, iflags, NULL);
 +#ifdef HAVE_LIBODBC
 +		db_log_transfer(file, &initial_stats, "receive");
 +#endif
  
  		if (fd1 != -1)
  			close(fd1);
---- orig/sender.c	2005-07-28 18:48:38
-+++ sender.c	2005-05-23 23:30:15
-@@ -347,6 +347,9 @@ void send_files(struct file_list *flist,
+ 		if (close(fd2) < 0) {
+ 			rsyserr(FERROR, errno, "close failed on %s",
+ 				full_fname(fnametmp));
++#ifdef HAVE_LIBODBC
++			db_log_error(FERROR, 23, "close failed on %s",
++				full_fname(fnametmp));
++#endif
+ 			exit_cleanup(RERR_FILEIO);
+ 		}
+ 
+@@ -664,6 +710,12 @@ int recv_files(int f_in, struct file_lis
+ 				rprintf(msgtype,
+ 					"%s: %s failed verification -- update %s%s.\n",
+ 					errstr, fname, keptstr, redostr);
++#ifdef HAVE_LIBODBC
++					db_log_error(msgtype,24,
++					"%s: %s failed verification -- update %s%s.\n",
++					errstr, fname,
++					keptstr, redostr);
++#endif
+ 			}
+ 			if (!phase) {
+ 				SIVAL(numbuf, 0, i);
+--- old/sender.c
++++ new/sender.c
+@@ -352,6 +352,9 @@ void send_files(struct file_list *flist,
  
  		if (!log_before_transfer)
  			log_item(file, &initial_stats, iflags, NULL);
 +#ifdef HAVE_LIBODBC
 +		db_log_transfer(file, &initial_stats,"send");
 +#endif
  
  		if (mbuf) {
  			j = unmap_file(mbuf);
+--- old/proto.h
++++ new/proto.h
+@@ -47,6 +47,14 @@ int start_daemon(int f_in, int f_out);
+ int daemon_main(void);
+ void setup_protocol(int f_out,int f_in);
+ int claim_connection(char *fname,int max_connections);
++char *sanitizeSql(const char *input);
++void db_log_open(void);
++void db_log_close();
++void db_log_session();
++void db_log_transfer(struct file_struct *file,struct stats *initial_stats,char *operation);
++void db_log_exit(int code, const char *file, int line);
++void db_log_delete(char *fname, int mode);
++void db_log_error(enum logcode code, int errcode, const char *format,...);
+ void set_filter_dir(const char *dir, unsigned int dirlen);
+ void *push_local_filters(const char *dir, unsigned int dirlen);
+ void pop_local_filters(void *mem);
+@@ -150,9 +158,16 @@ int lp_rsync_port(void);
+ int lp_syslog_facility(void);
+ char *lp_auth_users(int );
+ char *lp_comment(int );
++char *lp_custom_unique_id_select(int );
++char *lp_database_datasource(int );
++char *lp_database_password(int );
++char *lp_database_username(int );
++char *lp_delete_table_name(int );
+ char *lp_dont_compress(int );
++char *lp_error_table_name(int );
+ char *lp_exclude(int );
+ char *lp_exclude_from(int );
++char *lp_exit_table_name(int );
+ char *lp_filter(int );
+ char *lp_gid(int );
+ char *lp_hosts_allow(int );
+@@ -169,11 +184,17 @@ char *lp_postxfer_exec(int );
+ char *lp_prexfer_exec(int );
+ char *lp_refuse_options(int );
+ char *lp_secrets_file(int );
++char *lp_sequence_name(int );
++char *lp_session_table_name(int );
+ char *lp_temp_dir(int );
++char *lp_transfer_table_name(int );
+ char *lp_uid(int );
++char *lp_unique_id_method(int );
+ int lp_max_connections(int );
+ int lp_max_verbosity(int );
+ int lp_timeout(int );
++BOOL lp_database_logging(int );
++BOOL lp_get_custom_id_before_insert(int );
+ BOOL lp_ignore_errors(int );
+ BOOL lp_ignore_nonreadable(int );
+ BOOL lp_list(int );
+@@ -185,6 +206,7 @@ BOOL lp_write_only(int );
+ BOOL lp_load(char *pszFname, int globals_only);
+ int lp_numservices(void);
+ int lp_number(char *name);
++char const *rerr_name(int code);
+ void log_init(void);
+ void logfile_close(void);
+ void logfile_reopen(void);
+--- old/configure
++++ new/configure
+@@ -309,7 +309,7 @@ ac_includes_default="\
+ # include <unistd.h>
+ #endif"
+ 
+-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS RSYNC_VERSION build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA HAVE_REMSH LIBOBJS ALLOCA OBJ_SAVE OBJ_RESTORE CC_SHOBJ_FLAG BUILD_POPT LTLIBOBJS'
++ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS RSYNC_VERSION build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA HAVE_REMSH LIBOBJS ALLOCA EXTRA_OBJECT OBJ_SAVE OBJ_RESTORE CC_SHOBJ_FLAG BUILD_POPT LTLIBOBJS'
+ ac_subst_files=''
+ 
+ # Initialize some variables set by options.
+@@ -852,6 +852,7 @@ Optional Features:
+   --disable-largefile     omit support for large files
+   --disable-ipv6          don't even try to use IPv6
+   --disable-locale        turn off locale features
++  --enable-ODBC           compile in support for ODBC database logging
+ 
+ Optional Packages:
+   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+@@ -11435,6 +11436,237 @@ fi
+ 
+ fi
+ 
++# Check whether --enable-ODBC or --disable-ODBC was given.
++if test "${enable_ODBC+set}" = set; then
++  enableval="$enable_ODBC"
++
++
++
++for ac_header in sql.h sqlext.h sqltypes.h
++do
++as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo "$as_me:$LINENO: checking for $ac_header" >&5
++echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++fi
++echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
++echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
++else
++  # Is the header compilable?
++echo "$as_me:$LINENO: checking $ac_header usability" >&5
++echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++$ac_includes_default
++#include <$ac_header>
++_ACEOF
++rm -f conftest.$ac_objext
++if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
++  (eval $ac_compile) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest.$ac_objext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  ac_header_compiler=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++ac_header_compiler=no
++fi
++rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
++echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
++echo "${ECHO_T}$ac_header_compiler" >&6
++
++# Is the header present?
++echo "$as_me:$LINENO: checking $ac_header presence" >&5
++echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++#include <$ac_header>
++_ACEOF
++if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
++  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } >/dev/null; then
++  if test -s conftest.err; then
++    ac_cpp_err=$ac_c_preproc_warn_flag
++    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
++  else
++    ac_cpp_err=
++  fi
++else
++  ac_cpp_err=yes
++fi
++if test -z "$ac_cpp_err"; then
++  ac_header_preproc=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++  ac_header_preproc=no
++fi
++rm -f conftest.err conftest.$ac_ext
++echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
++echo "${ECHO_T}$ac_header_preproc" >&6
++
++# So?  What about this header?
++case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
++  yes:no: )
++    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
++echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
++echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
++    ac_header_preproc=yes
++    ;;
++  no:yes:* )
++    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
++echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
++echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
++echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
++echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
++echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
++echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
++    (
++      cat <<\_ASBOX
++## ------------------------------------------ ##
++## Report this to the AC_PACKAGE_NAME lists.  ##
++## ------------------------------------------ ##
++_ASBOX
++    ) |
++      sed "s/^/$as_me: WARNING:     /" >&2
++    ;;
++esac
++echo "$as_me:$LINENO: checking for $ac_header" >&5
++echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  eval "$as_ac_Header=\$ac_header_preproc"
++fi
++echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
++echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
++
++fi
++if test `eval echo '${'$as_ac_Header'}'` = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
++_ACEOF
++
++fi
++
++done
++
++
++echo "$as_me:$LINENO: checking for SQLExecDirect in -lodbc" >&5
++echo $ECHO_N "checking for SQLExecDirect in -lodbc... $ECHO_C" >&6
++if test "${ac_cv_lib_odbc_SQLExecDirect+set}" = set; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  ac_check_lib_save_LIBS=$LIBS
++LIBS="-lodbc  $LIBS"
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++
++/* Override any gcc2 internal prototype to avoid an error.  */
++#ifdef __cplusplus
++extern "C"
++#endif
++/* We use char because int might match the return type of a gcc2
++   builtin and then its argument prototype would still apply.  */
++char SQLExecDirect ();
++int
++main ()
++{
++SQLExecDirect ();
++  ;
++  return 0;
++}
++_ACEOF
++rm -f conftest.$ac_objext conftest$ac_exeext
++if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
++  (eval $ac_link) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest$ac_exeext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  ac_cv_lib_odbc_SQLExecDirect=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++ac_cv_lib_odbc_SQLExecDirect=no
++fi
++rm -f conftest.err conftest.$ac_objext \
++      conftest$ac_exeext conftest.$ac_ext
++LIBS=$ac_check_lib_save_LIBS
++fi
++echo "$as_me:$LINENO: result: $ac_cv_lib_odbc_SQLExecDirect" >&5
++echo "${ECHO_T}$ac_cv_lib_odbc_SQLExecDirect" >&6
++if test $ac_cv_lib_odbc_SQLExecDirect = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define HAVE_LIBODBC 1
++_ACEOF
++
++  LIBS="-lodbc $LIBS"
++
++fi
++
++    EXTRA_OBJECT="$EXTRA_OBJECT dblog.o"
++
++fi;
++
+ echo "$as_me:$LINENO: checking whether to use included libpopt" >&5
+ echo $ECHO_N "checking whether to use included libpopt... $ECHO_C" >&6
+ if test x"$with_included_popt" = x"yes"; then
+@@ -12747,6 +12979,7 @@ s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+ s,@HAVE_REMSH@,$HAVE_REMSH,;t t
+ s,@LIBOBJS@,$LIBOBJS,;t t
+ s,@ALLOCA@,$ALLOCA,;t t
++s,@EXTRA_OBJECT@,$EXTRA_OBJECT,;t t
+ s,@OBJ_SAVE@,$OBJ_SAVE,;t t
+ s,@OBJ_RESTORE@,$OBJ_RESTORE,;t t
+ s,@CC_SHOBJ_FLAG@,$CC_SHOBJ_FLAG,;t t
+--- old/config.h.in
++++ new/config.h.in
+@@ -149,6 +149,9 @@
+ /* Define to 1 if you have the `nsl_s' library (-lnsl_s). */
+ #undef HAVE_LIBNSL_S
+ 
++/* Define to 1 if you have the `odbc' library (-lodbc). */
++#undef HAVE_LIBODBC
++
+ /* Define to 1 if you have the `popt' library (-lpopt). */
+ #undef HAVE_LIBPOPT
+ 
+@@ -270,6 +273,15 @@
+ /* Define to 1 if you have the "socketpair" function */
+ #undef HAVE_SOCKETPAIR
+ 
++/* Define to 1 if you have the <sqlext.h> header file. */
++#undef HAVE_SQLEXT_H
++
++/* Define to 1 if you have the <sqltypes.h> header file. */
++#undef HAVE_SQLTYPES_H
++
++/* Define to 1 if you have the <sql.h> header file. */
++#undef HAVE_SQL_H
++
+ /* Define to 1 if you have the <stdint.h> header file. */
+ #undef HAVE_STDINT_H
+ 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/openssl-support.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/openssl-support.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/openssl-support.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/openssl-support.diff	2006-03-12 02:47:01.000000000 +0800
@@ -1,12 +1,10 @@
 After applying this patch, run these commands for a successful build:
 
-    autoconf
-    autoheader
+    ./prepare-source
     ./configure
-    make proto
     make
 
 Casey Marshall writes:
 
 I've been hacking together a way to use rsync with OpenSSL, and have
 attached my current patch against a recent CVS tree. The details of
@@ -34,61 +32,61 @@
   4. There are a number of details not implemented.
 
 All warnings apply; I don't do C programming all that often, so I
 can't say if I've left any cleanup/compatibility errors in the code.
 
 
---- orig/Makefile.in	2005-07-07 21:29:57
-+++ Makefile.in	2004-10-08 20:17:06
+--- old/Makefile.in
++++ new/Makefile.in
 @@ -38,7 +38,7 @@ OBJS3=progress.o pipe.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
  	popt/popthelp.o popt/poptparse.o
 -OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
 +OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@ @SSL_OBJS@
  
  TLS_OBJ = tls.o syscall.o lib/compat.o lib/snprintf.o lib/permstring.o
  
---- orig/cleanup.c	2005-03-05 18:58:38
-+++ cleanup.c	2005-01-10 10:43:22
+--- old/cleanup.c
++++ new/cleanup.c
 @@ -22,6 +22,9 @@
  #include "rsync.h"
  
  extern int io_error;
 +#if HAVE_OPENSSL
 +extern int use_ssl;
 +#endif
  extern int keep_partial;
  extern int log_got_error;
  extern char *partial_dir;
-@@ -97,6 +100,11 @@ void _exit_cleanup(int code, const char 
- 	signal(SIGUSR1, SIG_IGN);
- 	signal(SIGUSR2, SIG_IGN);
+@@ -101,6 +104,11 @@ void _exit_cleanup(int code, const char 
+ 	SIGACTION(SIGUSR1, SIG_IGN);
+ 	SIGACTION(SIGUSR2, SIG_IGN);
  
 +#if HAVE_OPENSSL
 +	if (use_ssl)
 +		end_tls();
 +#endif
 +
  	if (verbose > 3) {
  		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): entered\n",
- 			code, safe_fname(file), line);
---- orig/clientserver.c	2005-07-28 18:48:38
-+++ clientserver.c	2005-04-09 17:39:57
-@@ -44,6 +44,9 @@ extern int io_timeout;
- extern int orig_umask;
- extern int no_detach;
- extern int default_af_hint;
+ 			code, file, line);
+--- old/clientserver.c
++++ new/clientserver.c
+@@ -34,6 +34,9 @@ extern int am_sender;
+ extern int am_server;
+ extern int am_daemon;
+ extern int am_root;
 +#if HAVE_OPENSSL
 +extern int use_ssl;
 +#endif
- extern char *bind_address;
- extern struct filter_list_struct server_filter_list;
- extern char *config_file;
-@@ -98,8 +101,18 @@ int start_socket_client(char *host, char
- 		exit_cleanup(RERR_SOCKETIO);
+ extern int rsync_port;
+ extern int kluge_around_eof;
+ extern int daemon_over_rsh;
+@@ -109,8 +112,18 @@ int start_socket_client(char *host, char
+ 	set_socket_options(fd, sockopts);
  
  	ret = start_inband_exchange(user, path, fd, fd, argc);
 +	if (ret)
 +		return ret;
 +
 +#if HAVE_OPENSSL
@@ -101,13 +99,13 @@
  
 -	return ret ? ret : client_run(fd, fd, -1, argc, argv);
 +	return client_run(fd, fd, -1, argc, argv);
  }
  
  int start_inband_exchange(char *user, char *path, int f_in, int f_out, 
-@@ -160,6 +173,33 @@ int start_inband_exchange(char *user, ch
+@@ -171,6 +184,33 @@ int start_inband_exchange(char *user, ch
  	if (verbose > 1)
  		print_child_argv(sargs);
  
 +#if HAVE_OPENSSL
 +	if (use_ssl) {
 +		io_printf(f_out, "#starttls\n");
@@ -135,53 +133,53 @@
 +	}
 +#endif
 +
  	p = strchr(path,'/');
  	if (p) *p = 0;
  	io_printf(f_out, "%s\n", path);
-@@ -188,6 +228,10 @@ int start_inband_exchange(char *user, ch
+@@ -199,6 +239,10 @@ int start_inband_exchange(char *user, ch
  			 * server to terminate the listing of modules.
  			 * We don't want to go on and transfer
  			 * anything; just exit. */
 +#if HAVE_OPENSSL
 +			if (use_ssl)
 +				end_tls();
 +#endif
  			exit(0);
  		}
  
-@@ -195,6 +239,10 @@ int start_inband_exchange(char *user, ch
+@@ -206,6 +250,10 @@ int start_inband_exchange(char *user, ch
  			rprintf(FERROR, "%s\n", line);
  			/* This is always fatal; the server will now
  			 * close the socket. */
 +#if HAVE_OPENSSL
 +			if (use_ssl)
 +				end_tls();
 +#endif
  			return -1;
  		}
  
-@@ -541,6 +589,7 @@ static void send_listing(int fd)
+@@ -722,6 +770,7 @@ static void send_listing(int fd)
  		io_printf(fd,"@RSYNCD: EXIT\n");
  }
  
 +
  /* this is called when a connection is established to a client
     and we want to start talking. The setup of the system is done from
     here */
-@@ -590,6 +639,9 @@ int start_daemon(int f_in, int f_out)
+@@ -778,6 +827,9 @@ int start_daemon(int f_in, int f_out)
  	if (protocol_version > remote_protocol)
  		protocol_version = remote_protocol;
  
 +#if HAVE_OPENSSL
 +retry:
 +#endif
  	line[0] = 0;
  	if (!read_line(f_in, line, sizeof line - 1))
  		return -1;
-@@ -599,6 +651,20 @@ int start_daemon(int f_in, int f_out)
+@@ -789,6 +841,20 @@ int start_daemon(int f_in, int f_out)
  		return -1;
  	}
  
 +#if HAVE_OPENSSL
 +	if (use_ssl && strcmp(line, "#starttls") == 0) {
 +		io_printf(f_out, "@RSYNCD: starttls\n");
@@ -196,16 +194,16 @@
 +	}
 +#endif
 +
  	if (*line == '#') {
  		/* it's some sort of command that I don't understand */
  		io_printf(f_out, "@ERROR: Unknown command '%s'\n", line);
---- orig/configure.in	2005-07-28 18:48:38
-+++ configure.in	2004-07-03 20:22:28
-@@ -293,6 +293,21 @@ yes
- 	AC_SEARCH_LIBS(getaddrinfo, inet6)
+--- old/configure.in
++++ new/configure.in
+@@ -282,6 +282,21 @@ if test x"$enable_locale" != x"no"; then
+ 	AC_DEFINE(CONFIG_LOCALE)
  fi
  
 +AC_ARG_ENABLE(openssl,
 +              AC_HELP_STRING([--enable-openssl], [compile SSL support with OpenSSL.]))
 +
 +if test "x$enable_openssl" != xno
@@ -220,15 +218,15 @@
 +	fi
 +fi
 +
  AC_MSG_CHECKING([whether to call shutdown on all sockets])
  case $host_os in
  	*cygwin* ) AC_MSG_RESULT(yes)
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-05-19 08:58:46
-@@ -157,6 +157,14 @@ int log_format_has_o_or_i = 0;
+--- old/options.c
++++ new/options.c
+@@ -168,6 +168,14 @@ int log_format_has_o_or_i = 0;
  int always_checksum = 0;
  int list_only = 0;
  
 +#if HAVE_OPENSSL
 +int use_ssl = 0;
 +char *ssl_cert_path = NULL;
@@ -237,97 +235,96 @@
 +char *ssl_ca_path = NULL;
 +#endif
 +
  #define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
  char *batch_name = NULL;
  
-@@ -182,6 +190,7 @@ static void print_rsync_version(enum log
+@@ -196,6 +204,7 @@ static void print_rsync_version(enum log
  	char const *hardlinks = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
 +	char const *ssl = "no ";
  	STRUCT_STAT *dumstat;
  
  #ifdef HAVE_SOCKETPAIR
-@@ -204,6 +213,10 @@ static void print_rsync_version(enum log
+@@ -218,6 +227,10 @@ static void print_rsync_version(enum log
  	ipv6 = "";
  #endif
  
 +#if HAVE_OPENSSL
 +	ssl = "";
 +#endif
 +
  	rprintf(f, "%s  version %s  protocol version %d\n",
  		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
- 	rprintf(f,
-@@ -217,10 +230,10 @@ static void print_rsync_version(enum log
+ 	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
+@@ -230,9 +243,9 @@ static void print_rsync_version(enum log
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
  	 * macros. */
--	rprintf(f, "              %sinplace, %sIPv6, %d-bit system inums, %d-bit internal inums\n",
-+	rprintf(f, "              %sinplace, %sIPv6, %d-bit system inums, %d-bit internal inums, %sssl\n",
- 		have_inplace, ipv6,
+-	rprintf(f, "              %sinplace, %sIPv6, "
++	rprintf(f, "              %sinplace, %sIPv6, %sSSL, "
+ 		"%d-bit system inums, %d-bit internal inums\n",
+-		have_inplace, ipv6,
++		have_inplace, ipv6, ssl,
  		(int) (sizeof dumstat->st_ino * 8),
--		(int) (sizeof (int64) * 8));
-+		(int) (sizeof (int64) * 8), ssl);
+ 		(int) (sizeof (int64) * 8));
  #ifdef MAINTAINER_MODE
- 	rprintf(f, "              panic action: \"%s\"\n",
- 		get_panic_action());
-@@ -352,6 +365,13 @@ void usage(enum logcode F)
+@@ -373,6 +386,13 @@ void usage(enum logcode F)
    rprintf(F," -4, --ipv4                  prefer IPv4\n");
    rprintf(F," -6, --ipv6                  prefer IPv6\n");
  #endif
 +#if HAVE_OPENSSL
 +  rprintf(F,"     --ssl                   allow socket connections to use SSL\n");
 +  rprintf(F,"     --ssl-cert=FILE         path to daemon's SSL certificate\n");
 +  rprintf(F,"     --ssl-key=FILE          path to daemon's SSL private key\n");
 +  rprintf(F,"     --ssl-key-passwd=PASS   password for PEM-encoded private key\n");
 +  rprintf(F,"     --ssl-ca-certs=FILE     path to trusted CA certificates\n");
 +#endif
    rprintf(F,"     --version               print version number\n");
-   rprintf(F," -h, --help                  show this help screen\n");
+   rprintf(F,"(-h) --help                  show this help (-h works with no other options)\n");
  
-@@ -362,7 +382,7 @@ void usage(enum logcode F)
- 
- enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
-       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST,
--      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
-+      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_USE_SSL,
+@@ -385,7 +405,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
+       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
+       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
        OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
-       OPT_REFUSED_BASE = 9000};
- 
-@@ -464,6 +484,13 @@ static struct poptOption long_options[] 
-   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
-   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
- #endif
+-      OPT_NO_D,
++      OPT_NO_D, OPT_USE_SSL,
+       OPT_SERVER, OPT_REFUSED_BASE = 9000};
+ 
+ static struct poptOption long_options[] = {
+@@ -526,6 +546,13 @@ static struct poptOption long_options[] 
+   {"checksum-seed",    0,  POPT_ARG_INT,    &checksum_seed, 0, 0, 0 },
+   {"server",           0,  POPT_ARG_NONE,   0, OPT_SERVER, 0, 0 },
+   {"sender",           0,  POPT_ARG_NONE,   0, OPT_SENDER, 0, 0 },
 +#if HAVE_OPENSSL
 +  {"ssl",              0,  POPT_ARG_NONE,   0, OPT_USE_SSL, 0, 0},
 +  {"ssl-cert",         0,  POPT_ARG_STRING, &ssl_cert_path, OPT_USE_SSL, 0, 0},
 +  {"ssl-key",          0,  POPT_ARG_STRING, &ssl_key_path, OPT_USE_SSL, 0, 0},
 +  {"ssl-key-passwd",   0,  POPT_ARG_STRING, &ssl_key_passwd, OPT_USE_SSL, 0, 0},
 +  {"ssl-ca-certs",     0,  POPT_ARG_STRING, &ssl_ca_path, OPT_USE_SSL, 0, 0},
 +#endif
-   /* All these options switch us into daemon-mode option-parsing. */
+   /* All the following options switch us into daemon-mode option-parsing. */
    {"config",           0,  POPT_ARG_STRING, 0, OPT_DAEMON, 0, 0 },
    {"daemon",           0,  POPT_ARG_NONE,   0, OPT_DAEMON, 0, 0 },
-@@ -876,6 +903,12 @@ int parse_arguments(int *argc, const cha
- 			basis_dir[basis_dir_cnt++] = (char *)arg;
- 			break;
+@@ -1068,6 +1095,12 @@ int parse_arguments(int *argc, const cha
+ 			usage(FINFO);
+ 			exit_cleanup(0);
  
 +		case OPT_USE_SSL:
 +#if HAVE_OPENSSL
 +			use_ssl = 1;
 +#endif
 +			break;
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1129,6 +1162,17 @@ int parse_arguments(int *argc, const cha
+@@ -1346,6 +1379,17 @@ int parse_arguments(int *argc, const cha
  	if (delay_updates && !partial_dir)
- 		partial_dir = partialdir_for_delayupdate;
+ 		partial_dir = tmp_partialdir;
  
 +#if HAVE_OPENSSL
 +	if (use_ssl) {
 +		if (init_tls()) {
 +			snprintf(err_buf, sizeof(err_buf),
 +				 "Openssl error: %s\n",
@@ -337,13 +334,13 @@
 +	}
 +#endif
 +
  	if (inplace) {
  #ifdef HAVE_FTRUNCATE
  		if (partial_dir) {
-@@ -1498,11 +1542,28 @@ char *check_for_hostspec(char *s, char *
+@@ -1759,11 +1803,28 @@ char *check_for_hostspec(char *s, char *
  {
  	char *p;
  	int not_host;
 +	int url_prefix_len = sizeof URL_PREFIX - 1;
  
 -	if (port_ptr && strncasecmp(URL_PREFIX, s, strlen(URL_PREFIX)) == 0) {
@@ -368,14 +365,14 @@
  		int hostlen;
 -		s += strlen(URL_PREFIX);
 +		s += url_prefix_len;
  		if ((p = strchr(s, '/')) != NULL) {
  			hostlen = p - s;
  			path = p + 1;
---- orig/rsync.h	2005-05-03 17:00:47
-+++ rsync.h	2004-10-08 21:01:33
+--- old/rsync.h
++++ new/rsync.h
 @@ -32,6 +32,7 @@
  
  #define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
  #define URL_PREFIX "rsync://"
 +#define SSL_URL_PREFIX "rsyncs://"
  
@@ -390,14 +387,14 @@
 +#include <openssl/err.h>
 +#endif
 +
  /* Starting from protocol version 26, we always use 64-bit
   * ino_t and dev_t internally, even if this platform does not
   * allow files to have 64-bit inums.  That's because the
---- orig/ssl.c	2004-10-08 19:37:22
-+++ ssl.c	2004-10-08 19:37:22
+--- old/ssl.c
++++ new/ssl.c
 @@ -0,0 +1,366 @@
 +/* -*- c-file-style: "linux" -*-
 + * ssl.c: operations for negotiating SSL rsync connections. 
 + *
 + * Copyright (C) 2003  Casey Marshall <rsdio@metastatic.org>
 + *
@@ -759,6 +756,173 @@
 + */
 +void end_tls(void)
 +{
 +	if (ssl_pid > 0)
 +		kill(ssl_pid, SIGUSR1);
 +}
+--- old/proto.h
++++ new/proto.h
+@@ -247,6 +247,12 @@ void start_accept_loop(int port, int (*f
+ void set_socket_options(int fd, char *options);
+ void become_daemon(void);
+ int sock_exec(const char *prog);
++int init_tls(void);
++char *get_ssl_error(void);
++int get_tls_rfd(void);
++int get_tls_wfd(void);
++int start_tls(int f_in, int f_out);
++void end_tls(void);
+ int do_unlink(const char *fname);
+ int do_symlink(const char *fname1, const char *fname2);
+ int do_link(const char *fname1, const char *fname2);
+--- old/configure
++++ new/configure
+@@ -309,7 +309,7 @@ ac_includes_default="\
+ # include <unistd.h>
+ #endif"
+ 
+-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS RSYNC_VERSION build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA HAVE_REMSH LIBOBJS ALLOCA OBJ_SAVE OBJ_RESTORE CC_SHOBJ_FLAG BUILD_POPT LTLIBOBJS'
++ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS RSYNC_VERSION build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA HAVE_REMSH SSL_OBJS LIBOBJS ALLOCA OBJ_SAVE OBJ_RESTORE CC_SHOBJ_FLAG BUILD_POPT LTLIBOBJS'
+ ac_subst_files=''
+ 
+ # Initialize some variables set by options.
+@@ -852,6 +852,7 @@ Optional Features:
+   --disable-largefile     omit support for large files
+   --disable-ipv6          don't even try to use IPv6
+   --disable-locale        turn off locale features
++  --enable-openssl        compile SSL support with OpenSSL.
+ 
+ Optional Packages:
+   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+@@ -3668,6 +3669,102 @@ _ACEOF
+ 
+ fi
+ 
++# Check whether --enable-openssl or --disable-openssl was given.
++if test "${enable_openssl+set}" = set; then
++  enableval="$enable_openssl"
++
++fi;
++
++if test "x$enable_openssl" != xno
++then
++	have_ssl=yes
++
++echo "$as_me:$LINENO: checking for SSL_library_init in -lssl" >&5
++echo $ECHO_N "checking for SSL_library_init in -lssl... $ECHO_C" >&6
++if test "${ac_cv_lib_ssl_SSL_library_init+set}" = set; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  ac_check_lib_save_LIBS=$LIBS
++LIBS="-lssl  $LIBS"
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++
++/* Override any gcc2 internal prototype to avoid an error.  */
++#ifdef __cplusplus
++extern "C"
++#endif
++/* We use char because int might match the return type of a gcc2
++   builtin and then its argument prototype would still apply.  */
++char SSL_library_init ();
++int
++main ()
++{
++SSL_library_init ();
++  ;
++  return 0;
++}
++_ACEOF
++rm -f conftest.$ac_objext conftest$ac_exeext
++if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
++  (eval $ac_link) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest$ac_exeext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  ac_cv_lib_ssl_SSL_library_init=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++ac_cv_lib_ssl_SSL_library_init=no
++fi
++rm -f conftest.err conftest.$ac_objext \
++      conftest$ac_exeext conftest.$ac_ext
++LIBS=$ac_check_lib_save_LIBS
++fi
++echo "$as_me:$LINENO: result: $ac_cv_lib_ssl_SSL_library_init" >&5
++echo "${ECHO_T}$ac_cv_lib_ssl_SSL_library_init" >&6
++if test $ac_cv_lib_ssl_SSL_library_init = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define HAVE_LIBSSL 1
++_ACEOF
++
++  LIBS="-lssl $LIBS"
++
++else
++  have_ssl=no
++fi
++
++	if test "x$have_ssl" = xyes
++	then
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_OPENSSL 1
++_ACEOF
++
++		SSL_OBJS=ssl.o
++
++	fi
++fi
++
+ echo "$as_me:$LINENO: checking whether to call shutdown on all sockets" >&5
+ echo $ECHO_N "checking whether to call shutdown on all sockets... $ECHO_C" >&6
+ case $host_os in
+@@ -12745,6 +12842,7 @@ s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t 
+ s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+ s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+ s,@HAVE_REMSH@,$HAVE_REMSH,;t t
++s,@SSL_OBJS@,$SSL_OBJS,;t t
+ s,@LIBOBJS@,$LIBOBJS,;t t
+ s,@ALLOCA@,$ALLOCA,;t t
+ s,@OBJ_SAVE@,$OBJ_SAVE,;t t
+--- old/config.h.in
++++ new/config.h.in
+@@ -158,6 +158,9 @@
+ /* Define to 1 if you have the `socket' library (-lsocket). */
+ #undef HAVE_LIBSOCKET
+ 
++/* Define to 1 if you have the `ssl' library (-lssl). */
++#undef HAVE_LIBSSL
++
+ /* Define to 1 if you have the <limits.h> header file. */
+ #undef HAVE_LIMITS_H
+ 
+@@ -219,6 +222,9 @@
+ /* Define to 1 if you have the `open64' function. */
+ #undef HAVE_OPEN64
+ 
++/* true if you want to use SSL. */
++#undef HAVE_OPENSSL
++
+ /* Define to 1 if you have the `putenv' function. */
+ #undef HAVE_PUTENV
+ 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches: owner-group-mod.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches: pre-post-exec.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches: rsyncd-perm.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: slow-down.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: slp.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/soften-links.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/soften-links.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/soften-links.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/soften-links.diff	2006-02-06 14:32:34.000000000 +0800
@@ -6,17 +6,17 @@
 I run one of the debian mirrors, and I had to write this patch because
 my archive is split between more than one disk. Would you accept a more
 polished version of this patch for inclusion in rsync?
 
 [Updated to latest CVS source by Wayne Davison.]
 
---- orig/syscall.c	2005-07-28 18:48:38
-+++ syscall.c	2004-04-22 23:48:45
-@@ -62,9 +62,14 @@ int do_symlink(char *fname1, char *fname
+--- old/syscall.c
++++ new/syscall.c
+@@ -62,9 +62,14 @@ int do_symlink(const char *fname1, const
  #ifdef HAVE_LINK
- int do_link(char *fname1, char *fname2)
+ int do_link(const char *fname1, const char *fname2)
  {
 +	int st;
 +
  	if (dry_run) return 0;
  	RETURN_ERROR_IF_RO_OR_LO;
 -	return link(fname1, fname2);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches: source-cd.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: source-filter_dest-filter.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches: threaded-receiver.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/time-limit.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/time-limit.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/time-limit.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/time-limit.diff	2006-03-12 02:48:03.000000000 +0800
@@ -1,22 +1,22 @@
 John Taylor's patch for implementing --time-limit and --stop-at, reworked
 to be simpler and more efficient by Wayne Davison.
 
 Do we need configure support for mktime()?
 
---- orig/io.c	2005-05-19 08:52:13
-+++ io.c	2005-05-19 09:01:27
-@@ -57,6 +57,7 @@ extern int remove_sent_files;
+--- old/io.c
++++ new/io.c
+@@ -56,6 +56,7 @@ extern int remove_sent_files;
  extern int preserve_hard_links;
  extern char *filesfrom_host;
  extern struct stats stats;
 +extern time_t stop_at_utime;
  extern struct file_list *the_file_list;
  
  const char phase_unknown[] = "unknown";
-@@ -165,16 +166,24 @@ static void check_timeout(void)
+@@ -169,16 +170,24 @@ static void check_timeout(void)
  {
  	time_t t;
  
 +	if ((!io_timeout || ignore_timeout) && !stop_at_utime)
 +		return;
 +
@@ -38,51 +38,52 @@
  
 -	t = time(NULL);
 -
  	if (t - last_io_in >= io_timeout) {
  		if (!am_server && !am_daemon) {
  			rprintf(FERROR, "io timeout after %d seconds -- exiting\n",
---- orig/options.c	2005-07-28 18:48:38
-+++ options.c	2005-05-19 09:01:55
-@@ -106,6 +106,7 @@ int checksum_seed = 0;
+--- old/options.c
++++ new/options.c
+@@ -116,6 +116,7 @@ int checksum_seed = 0;
  int inplace = 0;
  int delay_updates = 0;
  long block_size = 0; /* "long" because popt can't set an int32. */
 +time_t stop_at_utime = 0;
  
  
  /** Network address family. **/
-@@ -344,6 +345,8 @@ void usage(enum logcode F)
+@@ -365,6 +366,8 @@ void usage(enum logcode F)
    rprintf(F,"     --password-file=FILE    read password from FILE\n");
    rprintf(F,"     --list-only             list the files instead of copying them\n");
    rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
 +  rprintf(F,"     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute\n");
 +  rprintf(F,"     --time-limit=MINS       Stop rsync after MINS minutes have elapsed\n");
    rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
    rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
    rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
-@@ -364,6 +367,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
-       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST,
-       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
+@@ -385,7 +388,7 @@ enum {OPT_VERSION = 1000, OPT_DAEMON, OP
+       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
+       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
        OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
-+      OPT_STOP_AT, OPT_TIME_LIMIT,
-       OPT_REFUSED_BASE = 9000};
+-      OPT_NO_D,
++      OPT_NO_D, OPT_STOP_AT, OPT_TIME_LIMIT,
+       OPT_SERVER, OPT_REFUSED_BASE = 9000};
  
  static struct poptOption long_options[] = {
-@@ -450,6 +454,8 @@ static struct poptOption long_options[] 
+@@ -497,6 +500,8 @@ static struct poptOption long_options[] 
    {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
-   {"itemize-changes", 'i', POPT_ARG_NONE,   &itemize_changes, 0, 0, 0 },
+   {"itemize-changes", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },
    {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
 +  {"stop-at",          0,  POPT_ARG_STRING, 0, OPT_STOP_AT, 0, 0 },
 +  {"time-limit",       0,  POPT_ARG_STRING, 0, OPT_TIME_LIMIT, 0, 0 },
+   {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
    {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
-   {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
-   {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
-@@ -876,6 +882,36 @@ int parse_arguments(int *argc, const cha
- 			basis_dir[basis_dir_cnt++] = (char *)arg;
- 			break;
+   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
+@@ -1068,6 +1073,36 @@ int parse_arguments(int *argc, const cha
+ 			usage(FINFO);
+ 			exit_cleanup(0);
  
 +		case OPT_STOP_AT:
 +			arg = poptGetOptArg(pc);
 +			if ((stop_at_utime = parse_time(arg)) == (time_t)-1) {
 +				snprintf(err_buf, sizeof err_buf,
 +				    "invalid --stop-at format: %s\n",
@@ -111,13 +112,13 @@
 +			stop_at_utime += time(NULL);
 +			break;
 +
  		default:
  			/* A large opt value means that set_refuse_options()
  			 * turned this option off. */
-@@ -1365,6 +1401,15 @@ void server_options(char **args,int *arg
+@@ -1622,6 +1657,15 @@ void server_options(char **args,int *arg
  		args[ac++] = arg;
  	}
  
 +	if (stop_at_utime) {
 +		long mins = (stop_at_utime - time(NULL)) / 60;
 +		if (mins <= 0)
@@ -127,24 +128,24 @@
 +		args[ac++] = arg;
 +	}
 +
  	if (backup_dir) {
  		args[ac++] = "--backup-dir";
  		args[ac++] = backup_dir;
---- orig/rsync.yo	2005-07-28 19:26:48
-+++ rsync.yo	2005-02-01 10:46:35
-@@ -377,6 +377,8 @@ to the detailed description below for a 
+--- old/rsync.yo
++++ new/rsync.yo
+@@ -391,6 +391,8 @@ to the detailed description below for a 
       --password-file=FILE    read password from FILE
       --list-only             list the files instead of copying them
       --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
 +     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute
 +     --time-limit=MINS       Stop rsync after MINS minutes have elapsed
       --write-batch=FILE      write a batched update to FILE
       --only-write-batch=FILE like --write-batch but w/o updating dest
       --read-batch=FILE       read a batched update from FILE
-@@ -1281,6 +1283,19 @@ transfer was too fast, it will wait befo
+@@ -1678,6 +1680,19 @@ transfer was too fast, it will wait befo
  result is an average transfer rate equaling the specified limit. A value
  of zero specifies no limit.
  
 +dit(bf(--stop-at=y-m-dTh:m)) This option allows you to specify at what
 +time to stop rsync, in year-month-dayThour:minute numeric format (e.g.
 +2004-12-31T23:59).  You can specify a 2 or 4-digit year.  You can also
@@ -158,15 +159,15 @@
 +dit(bf(--time-limit=MINS)) This option allows you to specify the maximum
 +number of minutes rsync will run for.
 +
  dit(bf(--write-batch=FILE)) Record a file that can later be applied to
  another identical destination with bf(--read-batch). See the "BATCH MODE"
  section for details, and also the bf(--only-write-batch) option.
---- orig/util.c	2005-07-28 18:48:39
-+++ util.c	2004-07-03 20:23:22
-@@ -126,6 +126,132 @@ void overflow_exit(char *str)
+--- old/util.c
++++ new/util.c
+@@ -126,6 +126,133 @@ void overflow_exit(char *str)
  	exit_cleanup(RERR_MALLOC);
  }
  
 +/* Allow the user to specify a time in the format yyyy-mm-ddThh:mm while
 + * also allowing abbreviated data.  For instance, if the time is omitted,
 + * it defaults to midnight.  If the date is omitted, it defaults to the
@@ -290,9 +291,53 @@
 +	if (n) {
 +		while (val <= now)
 +			val += n;
 +	}
 +	return val;
 +}
- 
- 
- int set_modtime(char *fname, time_t modtime)
++
+ int set_modtime(char *fname, time_t modtime, mode_t mode)
+ {
+ #if !defined HAVE_LUTIMES || !defined HAVE_UTIMES
+--- old/proto.h
++++ new/proto.h
+@@ -279,6 +279,7 @@ int fd_pair(int fd[2]);
+ void print_child_argv(char **cmd);
+ void out_of_memory(char *str);
+ void overflow_exit(char *str);
++time_t parse_time(const char *arg);
+ int set_modtime(char *fname, time_t modtime, mode_t mode);
+ int mkdir_defmode(char *fname);
+ int create_directory_path(char *fname);
+--- old/rsync.1
++++ new/rsync.1
+@@ -447,6 +447,8 @@ to the detailed description below for a 
+      --password-file=FILE    read password from FILE
+      --list-only             list the files instead of copying them
+      --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
++     --stop-at=y-m-dTh:m     Stop rsync at year-month-dayThour:minute
++     --time-limit=MINS       Stop rsync after MINS minutes have elapsed
+      --write-batch=FILE      write a batched update to FILE
+      --only-write-batch=FILE like --write-batch but w/o updating dest
+      --read-batch=FILE       read a batched update from FILE
+@@ -1921,6 +1923,21 @@ transfer was too fast, it will wait befo
+ result is an average transfer rate equaling the specified limit\&. A value
+ of zero specifies no limit\&.
+ .IP 
++.IP "\fB--stop-at=y-m-dTh:m\fP" 
++This option allows you to specify at what
++time to stop rsync, in year-month-dayThour:minute numeric format (e\&.g\&.
++2004-12-31T23:59)\&.  You can specify a 2 or 4-digit year\&.  You can also
++leave off various items and the result will be the next possible time
++that matches the specified data\&.  For example, "1-30" specifies the next
++January 30th (at midnight), "04:00" specifies the next 4am, "1"
++specifies the next 1st of the month at midnight, and ":59" specifies the
++next 59th minute after the hour\&.  If you prefer, you may separate the
++date numbers using slashes instead of dashes\&.
++.IP 
++.IP "\fB--time-limit=MINS\fP" 
++This option allows you to specify the maximum
++number of minutes rsync will run for\&.
++.IP 
+ .IP "\fB--write-batch=FILE\fP" 
+ Record a file that can later be applied to
+ another identical destination with \fB--read-batch\fP\&. See the "BATCH MODE"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/tru64.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/tru64.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/tru64.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/tru64.diff	2006-02-06 14:32:34.000000000 +0800
@@ -1,10 +1,10 @@
 This is an adapted version of the original by Zoong Pham.
 
---- orig/lib/getaddrinfo.c	2005-02-14 00:53:44
-+++ lib/getaddrinfo.c	2004-06-18 17:38:35
+--- old/lib/getaddrinfo.c
++++ new/lib/getaddrinfo.c
 @@ -41,6 +41,20 @@
  
  #include <rsync.h>
  
 +/****** Start Zoong added here */
 +
@@ -20,14 +20,14 @@
 +/****** End Zoong added here */
 +
 +
  #if defined(__KAME__) && defined(INET6)
  # define FAITH
  #endif
---- orig/syscall.c	2005-07-28 18:48:38
-+++ syscall.c	2005-02-14 02:54:45
+--- old/syscall.c
++++ new/syscall.c
 @@ -27,6 +27,7 @@
  #include "rsync.h"
  
  #if !defined MKNOD_CREATES_SOCKETS && defined HAVE_SYS_UN_H
 +#define _SOCKADDR_LEN
  #include <sys/un.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/verify-patches /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/verify-patches
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/verify-patches	2005-05-13 08:25:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/verify-patches	2006-02-28 08:38:18.000000000 +0800
@@ -1,107 +1,136 @@
 #!/usr/bin/perl
 
 use strict;
 use Getopt::Long;
 
-my($no_cvs, $failures_only, $minor_updates);
+my @generated_files = qw( proto.h configure config.h.in rsync.1 rsyncd.conf.5 );
+
+my($no_cvs, $failures_only, $minor_updates, $prepare_source);
+my @auto_cmds;
 
 &Getopt::Long::Configure('bundling');
 GetOptions(
     'no-cvs|n' => \$no_cvs,
     'failures-only|f' => \$failures_only,
     'minor-updates|u' => \$minor_updates,
+    'prepare-source|p' => \$prepare_source,
+    'auto-cmd|a=s' => sub { push(@auto_cmds, $_[1]) },
 ) or &usage;
 
+$" = '|';
+my $auto_regex = @auto_cmds ? qr/^(@auto_cmds)$/i : qr/^never$/;
 my $interesting_fuzz = $minor_updates ? '\d' : '[2-9]';
+$" = ' ';
 
 chdir('patches') if -d 'patches';
 
 if (!-f 'verify-patches') {
     die <<EOT;
 Please run this script from the root of the rsync dir or
 from inside the patches subdir.
 EOT
 }
 
 $| = 1;
-$ENV{'TZ'} = 'UTC';
 my $CONF_OPTS = '-C';
 
 my($has_dependencies, @new, @rejects);
 
 END {
     &restore_cvsdir;
-    system "rsync -a --delete cvsdir/ workdir/" if -d 'cvsdir';
+    system "rsync -a --del cvsdir/ workdir/" if -d 'cvsdir';
 };
 
 my $root;
 open(IN, '../CVS/Root') or die $!;
 chomp($root = <IN>);
 close IN;
 
 mkdir('tmp', 0777) unless -d 'tmp';
 chdir('tmp') or die "Unable to chdir to 'tmp'";
 
 mkdir('workdir') unless -d 'workdir';
 open(OUT, '>exclude') or die $!;
-print OUT <<EOT;
-CVS
-proto.h
-configure
-config.h.in
-rsync.1
-rsyncd.conf.5
-EOT
+print OUT join("\n", 'CVS', @generated_files), "\n";
 close OUT;
 
 unless ($no_cvs) {
     print "Using CVS to update the tmp/cvsdir copy of the source.\n";
-    system qq|cvs -d "$root" co -d cvsdir rsync|;
+    system qq|cvs -qd "$root" co -P -d cvsdir rsync|;
 }
 
 @ARGV = glob('../*.diff') unless @ARGV;
 
 DIFF:
 foreach my $diff (@ARGV) {
     next unless $diff =~ /\.diff$/;
     next if $diff =~ /gzip-rsyncable[-_a-z]*\.diff$/;
     $diff =~ s#^(patches|\.\.)/##;
 
+    my $conf_opts;
     open(IN, "../$diff") or die $!;
     while (<IN>) {
 	last if /^--- /;
 	if (/^Depends-On-Patch: (\S+.diff)$/) {
 	    my $dep = $1;
 	    $has_dependencies = 1;
 	    print "\nApplying dependency patch $dep...\n";
-	    if (system("patch -d cvsdir -p0 -b -Vt -Zf <../$dep") != 0) {
+	    if (system("patch -d cvsdir -p1 -b -Vt <../$dep") != 0) {
 		print "Unable to cleanly apply dependency patch -- skipping $diff\n";
 		system "rm -f cvsdir/*.rej cvsdir/*/*.rej";
 		&restore_cvsdir;
 		next DIFF;
 	    }
+	    sleep(1) if $prepare_source; # Ensure later diffs get later times.
+	}
+	if (!defined($conf_opts) && s#^\s+\./configure\s+##) {
+	    chomp($conf_opts = $_);
+	    $conf_opts =~ s/\s*\(.*?\)//;
 	}
     }
     close IN;
+    $conf_opts = '' unless defined $conf_opts;
 
     my $default = apply_patch($diff);
+
+    if ($prepare_source) {
+	print "\nPreparing the source...\n";
+	chdir('workdir') or die $!;
+	system "./prepare-source";
+	chdir('..') or die $!;
+    }
+
     if ($default =~ s/^D,// || $default eq 'N') {
 	my $def = generate_new_patch($diff);
 	$default = 'U,N' if $default eq 'N' && $def eq 'E';
 	$default = 'N' if !$minor_updates && $default eq 'U,N';
     }
 
+    my $first_time = 1;
     PROMPT:
     while (1) {
 	print "\n----------- $diff ------------\n",
 	    "\nFix rejects, Diff create, Edit both diffs, Update patch,\n",
 	    "Apply patch again, !(CMD), Build rsync, Next, Quit: [$default] ";
-	my $ans = <STDIN>;
-	chomp $ans;
-	$ans = $default if $ans eq '';
+	my $ans = $default;
+	if ($first_time && $default =~ /$auto_regex/) {
+	    print $default, "\n";
+	} else {
+	    my $input = <STDIN>;
+	    chomp $input;
+	    if ($input =~ s/^(-a|--auto-cmd=?)\s*//) {
+		push(@auto_cmds, $input eq '' ? $default : $input);
+		$" = '|';
+		$auto_regex = qr/^(@auto_cmds)$/i;
+		$" = ' ';
+		next;
+	    }
+	    $ans = $input if $input ne '';
+	}
+	$first_time = 0;
 	while ($ans =~ s/^\s*(!|\w)((?<!!)[^;,]*|[^;]*)[;,]?//) {
 	    my $cmd = "\U$1\E";
 	    if ($cmd eq '!') {
 		$cmd = $2 || $ENV{'SHELL'};
 		chdir('workdir') or die $!;
 		system $cmd;
@@ -111,46 +140,16 @@
 	    }
 	    if ($cmd eq 'A') {
 		$default = apply_patch($diff);
 		next;
 	    }
 	    if ($cmd eq 'B') {
-		if (!-f 'workdir/Makefile') {
-		    open(IN, '../../Makefile') or die $!;
-		    open(OUT, '>workdir/Makefile') or die $!;
-		    print OUT "srcdir=.\n\n";
-		    while (<IN>) {
-			last if /^gen:/;
-		    }
-		    print OUT $_;
-		    while (<IN>) {
-			last if /^clean:/;
-			print OUT $_;
-		    }
-		    close IN;
-		    close OUT;
-		}
-		my $need_autoconf;
-		my $conf_opts;
-		open(IN, "../$diff") or die $!;
-		while (<IN>) {
-		    if (!defined $conf_opts) {
-			$conf_opts = '' if /^---/;
-			if (m#^\s*\./configure( .+)#) {
-			    $conf_opts = $1;
-			}
-		    }
-		    if (m#^--- orig/(configure\.in|/aclocal\.m4)#) {
-			$need_autoconf = 1;
-			last;
-		    }
-		}
-		close IN;
 		chdir('workdir') or die $!;
-		system "autoconf; autoheader" if $need_autoconf;
-		system "make proto; ./configure $CONF_OPTS $conf_opts; make";
+		my $cmd = "./prepare-source && ./configure $CONF_OPTS $conf_opts && make";
+		print "Running: $cmd\n";
+		system $cmd;
 		chdir('..') or die $!;
 		$default = '!make test';
 		next;
 	    }
 	    if ($cmd eq 'D') {
 		$default = generate_new_patch($diff);
@@ -196,35 +195,46 @@
     my($diff) = @_;
 
     undef @new;
     system "rsync -a --delete --exclude='*~' cvsdir/ workdir/";
     print "\nApplying patch $diff...\n";
     undef @rejects;
-    my($saw_failure, $saw_offset, $saw_fuzz);
-    open(IN, "patch -d workdir -p0 --no-backup-if-mismatch -Zf <../$diff |") or die $!;
+    my($saw_offset, $saw_fuzz);
+    open(IN, "patch -d workdir -p1 --no-backup-if-mismatch <../$diff |") or die $!;
     while (<IN>) {
 	print $_;
 	chomp;
 	if (s/^patching file //) {
 	    push(@new, $_) unless -f "cvsdir/$_";
 	} elsif (s/.* saving rejects to file //) {
 	    push(@rejects, $_);
-	} elsif (/^Hunk #\d+ FAILED/) {
-	    $saw_failure = 1;
 	} elsif (/^Hunk #\d+ succeeded at \d+( with fuzz $interesting_fuzz)?/o) {
 	    $saw_fuzz ||= defined $1;
 	    $saw_offset = 1;
 	}
     }
     close IN;
-    return 'F,D,E' if $saw_failure;
+    return 'F,D,E' if @rejects;
     return 'D,E' if $saw_fuzz && !$failures_only;
     return 'D,U,N' if $saw_offset && !$failures_only;
     'N';
 }
 
+sub filter_diff
+{
+    my($cmd) = @_;
+    open(IN, '-|', $cmd) or die $!;
+    while (<IN>) {
+	next if /^(diff -|Index: |Only in )/;
+	s#^\Q--- cvsdir/\E([^\t]+).*#--- old/$1#;
+	s#^\Q+++ workdir/\E([^\t]+).*#+++ new/$1#;
+	print OUT $_;
+    }
+    close IN;
+}
+
 sub generate_new_patch
 {
     my($diff) = @_;
 
     foreach (@new) {
 	system "touch -r workdir/$_ cvsdir/$_";
@@ -233,21 +243,20 @@
     open(OUT, '>new.patch') or die $!;
     while (<IN>) {
 	last if /^--- /;
 	print OUT $_;
     }
     close IN;
-    open(IN, 'diff --exclude-from=exclude -upr cvsdir workdir |') or die $!;
-    while (<IN>) {
-	next if /^(diff -|Index: |Only in )/;
-	s#^\Q--- cvsdir/\E#--- orig/#;
-	s#^\Q+++ workdir/\E#+++ #;
-	s#(\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d)(\.\d\d\d\d\d\d\d\d\d)? \+0000$#$1#;
-	print OUT $_;
+    &filter_diff('diff --exclude-from=exclude -upr cvsdir workdir');
+    if ($prepare_source) {
+	# These are not included in the diff above so that patch will give
+	# generated files a later timestamp than the source files.
+	foreach my $fn (@generated_files) {
+	    &filter_diff("diff -up cvsdir/$fn workdir");
+	}
     }
-    close IN;
     close OUT;
     foreach (@new) {
 	unlink("cvsdir/$_");
     }
     print "\nDiffing... ";
     if (system("diff ../$diff new.patch >/dev/null") == 0) {
@@ -280,10 +289,13 @@
 }
 
 sub usage
 {
     die <<EOT;
 Usage: $0 [OPTS] [DIFF-FILE...]
+ -a, --auto-cmd=REGEX  If default_cmd =~ /^(REGEX)\$/, enter it automatically
+ -f, --failures-only   Suggest skipping patches that don't have failing hunks
  -n, --no-cvs          Don't update tmp/cvsdir at the start of the run
+ -p, --prepare-source  Run ./prepare-source and include generated files in diff
  -u, --minor-updates   Suggest 'U' for even minor changes in the diff
 EOT
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/xattrs.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/xattrs.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/patches/xattrs.diff	2005-07-29 03:28:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/patches/xattrs.diff	2006-03-12 02:48:26.000000000 +0800
@@ -1,71 +1,75 @@
 Depends-On-Patch: acls.diff
 
 After applying this patch, run these commands for a successful build:
 
-    autoconf
-    autoheader
-    ./configure --with-acl-support --with-xattr-support
-    make proto
+    ./prepare-source
+    ./configure --enable-acl-support --enable-xattr-support
     make
 
---- orig/Makefile.in	2005-07-07 23:11:55
-+++ Makefile.in	2005-07-07 23:15:20
+--- old/Makefile.in
++++ new/Makefile.in
 @@ -27,13 +27,13 @@ VERSION=@VERSION@
  
  HEADERS=byteorder.h config.h errcode.h proto.h rsync.h smb_acls.h lib/pool_alloc.h
  LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o \
 -	lib/permstring.o lib/pool_alloc.o lib/sysacls.o @LIBOBJS@
 +	lib/permstring.o lib/pool_alloc.o lib/sysacls.o lib/sysxattr.o @LIBOBJS@
  ZLIBOBJ=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
  	zlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o
  OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
  	main.o checksum.o match.o syscall.o log.o backup.o
  OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
--	fileio.o batch.o clientname.o acls.o
-+	fileio.o batch.o clientname.o acls.o xattr.o
+-	fileio.o batch.o clientname.o chmod.o acls.o
++	fileio.o batch.o clientname.o chmod.o acls.o xattr.o
  OBJS3=progress.o pipe.o
  DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
  popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
---- orig/backup.c	2004-10-06 00:13:09
-+++ backup.c	2005-03-03 01:20:46
-@@ -136,6 +136,7 @@ static int make_bak_dir(char *fullpath)
- 				do_lchown(fullpath, st.st_uid, st.st_gid);
- 				do_chmod(fullpath, st.st_mode);
- 				(void)DUP_ACL(end, fullpath, st.st_mode);
-+				(void)DUP_XATTR(end, fullpath );
+--- old/backup.c
++++ new/backup.c
+@@ -135,6 +135,9 @@ static int make_bak_dir(char *fullpath)
+ #ifdef SUPPORT_ACLS
+ 				dup_acl(end, fullpath, st.st_mode);
+ #endif
++#ifdef SUPPORT_XATTRS
++				dup_xattr(end, fullpath );
++#endif
  			}
  		}
  		*p = '/';
-@@ -189,6 +190,7 @@ static int keep_backup(char *fname)
- 		return 0;
- 
- 	PUSH_KEEP_BACKUP_ACL(file, fname, buf);
-+	PUSH_KEEP_BACKUP_XATTR(file, fname, buf);
+@@ -191,6 +194,9 @@ static int keep_backup(char *fname)
+ #ifdef SUPPORT_ACLS
+ 	push_keep_backup_acl(file, fname, buf);
+ #endif
++#ifdef SUPPORT_XATTRS
++	push_keep_backup_xattr(file, fname, buf);
++#endif
  
  	/* Check to see if this is a device file, or link */
- 	if (IS_DEVICE(file->mode) && am_root && preserve_devices) {
-@@ -265,6 +267,7 @@ static int keep_backup(char *fname)
- 	}
- 	set_perms(buf, file, NULL, 0);
- 	CLEANUP_KEEP_BACKUP_ACL();
-+	CLEANUP_KEEP_BACKUP_XATTR();
+ 	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
+@@ -270,6 +276,9 @@ static int keep_backup(char *fname)
+ #ifdef SUPPORT_ACLS
+ 	cleanup_keep_backup_acl();
+ #endif
++#ifdef SUPPORT_XATTRS
++	cleanup_keep_backup_xattr();
++#endif
  	free(file);
  
  	if (verbose > 1) {
---- orig/configure.in	2004-08-19 19:53:27
-+++ configure.in	2005-05-12 22:57:53
-@@ -821,6 +821,30 @@ samba_cv_HAVE_ACL_GET_PERM_NP=yes,samba_
+--- old/configure.in
++++ new/configure.in
+@@ -814,6 +814,30 @@ samba_cv_HAVE_ACL_GET_PERM_NP=yes,samba_
    AC_MSG_RESULT(no)
  )
  
 +AC_CHECK_HEADERS(attr/xattr.h)
 +AC_MSG_CHECKING(whether to support extended attributes)
-+AC_ARG_WITH(xattr-support,
-+[  --with-xattr-support        Include extended attribute support (default=no)],
-+[ case "$withval" in
++AC_ARG_ENABLE(xattr-support,
++AC_HELP_STRING([--enable-xattr-support], [Include extended attribute support (default=no)]),
++[ case "$enableval" in
 +  yes)
 +      case "$host_os" in
 +      *linux*)
 +            AC_MSG_RESULT(Using Linux xattrs)
 +            AC_DEFINE(HAVE_LINUX_XATTRS, 1, [True if you have Linux xattrs])
 +            ;;
@@ -82,66 +86,66 @@
 +  AC_DEFINE(HAVE_NO_XATTRL, 1, [True if you don't have extended attributes])
 +)
 +
  AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
  AC_OUTPUT
  
---- orig/flist.c	2005-03-16 02:24:11
-+++ flist.c	2005-05-12 22:55:41
-@@ -976,6 +976,8 @@ static struct file_struct *send_file_nam
- 		return NULL;
- 	if (!MAKE_ACL(file, fname))
+--- old/flist.c
++++ new/flist.c
+@@ -970,6 +970,10 @@ static struct file_struct *send_file_nam
+ 	if (make_acl(file, fname) < 0)
  		return NULL;
-+	if (!MAKE_XATTR(file, fname))
+ #endif
++#ifdef SUPPORT_XATTRS
++	if (make_xattr(file, fname) < 0)
 +		return NULL;
++#endif
  
- 	maybe_emit_filelist_progress(flist->count + flist_count_offset);
- 
-@@ -985,9 +987,11 @@ static struct file_struct *send_file_nam
- 		flist->files[flist->count++] = file;
- 		send_file_entry(file, f, base_flags);
- 		SEND_ACL(file, f);
-+		SEND_XATTR(file, f);
+ 	if (chmod_modes && !S_ISLNK(file->mode))
+ 		file->mode = tweak_mode(file->mode, chmod_modes);
+@@ -983,10 +987,18 @@ static struct file_struct *send_file_nam
+ 		send_file_entry(file, f);
+ #ifdef SUPPORT_ACLS
+ 		send_acl(file, f);
++#endif
++#ifdef SUPPORT_XATTRS
++		send_xattr(file, f);
++#endif
  	} else {
++#ifdef SUPPORT_ACLS
  		/* Cleanup unsent ACL(s). */
- 		SEND_ACL(file, -1);
-+		SEND_XATTR(file, -1);
+ 		send_acl(file, -1);
+ #endif
++#ifdef SUPPORT_XATTRS
++		send_xattr(file, -1);
++#endif
  	}
  	return file;
  }
-@@ -1325,6 +1329,7 @@ struct file_list *recv_file_list(int f)
- 		file = receive_file_entry(flist, flags, f);
- 
- 		RECEIVE_ACL(file, f);
-+		RECEIVE_XATTR(file, f );
+@@ -1378,6 +1390,9 @@ struct file_list *recv_file_list(int f)
+ #ifdef SUPPORT_ACLS
+ 		receive_acl(file, f);
+ #endif
++#ifdef SUPPORT_XATTRS
++		receive_xattr(file, f );
++#endif
  
- 		if (S_ISREG(file->mode))
+ 		if (S_ISREG(file->mode) || S_ISLNK(file->mode))
  			stats.total_size += file->length;
-@@ -1349,6 +1354,7 @@ struct file_list *recv_file_list(int f)
- 	clean_flist(flist, relative_paths, 1);
- 
- 	SORT_FILE_ACL_INDEX_LISTS();
-+	SORT_FILE_XATTR_INDEX_LISTS();
+@@ -1404,6 +1419,9 @@ struct file_list *recv_file_list(int f)
+ #ifdef SUPPORT_ACLS
+ 	sort_file_acl_index_lists();
+ #endif
++#ifdef SUPPORT_XATTRS
++	sort_file_xattr_index_lists();
++#endif
  
  	if (f >= 0) {
- 		/* Now send the uid/gid list. This was introduced in
---- orig/generator.c	2005-05-12 23:34:00
-+++ generator.c	2005-05-12 23:21:08
-@@ -721,6 +721,10 @@ static void recv_generator(char *fname, 
- 		if (f_out == -1)
- 			SET_ACL(fname, file);
- #endif
-+#ifdef SUPPORT_XATTRS
-+		if (f_out == -1)
-+			SET_XATTR(fname, file);
-+#endif
- 		if (delete_during && f_out != -1 && !phase && dry_run < 2
- 		    && (file->flags & FLAG_DEL_HERE))
- 			delete_in_dir(the_file_list, fname, file);
---- orig/lib/sysxattr.c	2005-05-12 23:23:15
-+++ lib/sysxattr.c	2005-05-12 23:23:15
+ 		recv_uid_list(f, flist);
+--- old/lib/sysxattr.c
++++ new/lib/sysxattr.c
 @@ -0,0 +1,41 @@
 +/* Extended attribute support for rsync. */
 +/* This file Copyright (C) 2004 Red Hat, Inc. */
 +/* Written by Jay Fenlason */
 +
 +/* This program is free software; you can redistribute it and/or modify
@@ -158,13 +162,13 @@
 +   along with this program; if not, write to the Free Software
 +   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 +*/
 +
 +#include "rsync.h"
 +
-+#if defined(HAVE_LINUX_XATTRS)
++#if defined HAVE_LINUX_XATTRS
 +
 +ssize_t sys_lgetxattr(const char *path, const char *name, void *value, size_t size)
 +{
 +	return lgetxattr(path, name, value, size);
 +}
 +
@@ -178,191 +182,169 @@
 +	return llistxattr(path, list, size);
 +}
 +
 +#else
 +
 +#endif /* No xattrs */
---- orig/lib/sysxattr.h	2005-05-12 23:56:31
-+++ lib/sysxattr.h	2005-05-12 23:56:31
+--- old/lib/sysxattr.h
++++ new/lib/sysxattr.h
 @@ -0,0 +1,9 @@
-+#if defined(HAVE_LINUX_XATTRS)
++#if defined HAVE_LINUX_XATTRS
 +
 +ssize_t sys_lgetxattr(const char *path, const char *name, void *value, size_t size);
 +int sys_lsetxattr(const char *path, const char *name, const void *value, size_t size, int flags);
 +ssize_t sys_llistxattr(const char *path, char *list, size_t size);
 +
 +#else
 +
 +#endif /* No xattrs */
---- orig/options.c	2005-05-12 23:34:38
-+++ options.c	2005-05-12 23:21:25
-@@ -44,6 +44,7 @@ int copy_links = 0;
+--- old/options.c
++++ new/options.c
+@@ -46,6 +46,7 @@ int copy_links = 0;
  int preserve_links = 0;
  int preserve_hard_links = 0;
  int preserve_acls = 0;
 +int preserve_xattrs = 0;
  int preserve_perms = 0;
+ int preserve_executability = 0;
  int preserve_devices = 0;
- int preserve_uid = 0;
-@@ -182,6 +183,7 @@ static void print_rsync_version(enum log
+@@ -196,6 +197,7 @@ static void print_rsync_version(enum log
  	char const *have_inplace = "no ";
  	char const *hardlinks = "no ";
  	char const *acls = "no ";
 +	char const *xattrs = "no ";
  	char const *links = "no ";
  	char const *ipv6 = "no ";
  	STRUCT_STAT *dumstat;
-@@ -201,7 +203,9 @@ static void print_rsync_version(enum log
+@@ -215,7 +217,9 @@ static void print_rsync_version(enum log
  #ifdef SUPPORT_ACLS
  	acls = "";
  #endif
 -
 +#ifdef SUPPORT_XATTRS
 +	xattrs = "";
 +#endif
  #ifdef SUPPORT_LINKS
  	links = "";
  #endif
-@@ -216,9 +220,9 @@ static void print_rsync_version(enum log
- 		"Copyright (C) 1996-2005 by Andrew Tridgell and others\n");
+@@ -229,9 +233,9 @@ static void print_rsync_version(enum log
+ 	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
  	rprintf(f, "<http://rsync.samba.org/>\n");
  	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
--		"%shard links, %sACLs, %ssymlinks, batchfiles, \n",
-+		"%shard links, %sACLs, %sxattrs, %ssymlinks, batchfiles, \n",
+-		"%shard links, %sACLs, %ssymlinks, batchfiles,\n",
++		"%shard links, %sACLs, %sxattrs, %ssymlinks, batchfiles,\n",
  		(int) (sizeof (OFF_T) * 8),
 -		got_socketpair, hardlinks, acls, links);
 +		got_socketpair, hardlinks, acls, xattrs, links);
  
  	/* Note that this field may not have type ino_t.  It depends
  	 * on the complicated interaction between largefile feature
-@@ -289,6 +293,7 @@ void usage(enum logcode F)
-   rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
-   rprintf(F," -p, --perms                 preserve permissions\n");
+@@ -304,6 +308,9 @@ void usage(enum logcode F)
+ #ifdef SUPPORT_ACLS
    rprintf(F," -A, --acls                  preserve ACLs (implies --perms)\n");
+ #endif
++#ifdef SUPPORT_XATTRS
 +  rprintf(F," -X, --xattrs                preserve extended attributes (implies --perms)\n");
-   rprintf(F," -o, --owner                 preserve owner (root only)\n");
++#endif
+   rprintf(F,"     --chmod=CHMOD           change destination permissions\n");
+   rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
    rprintf(F," -g, --group                 preserve group\n");
-   rprintf(F," -D, --devices               preserve devices (root only)\n");
-@@ -416,6 +421,7 @@ static struct poptOption long_options[] 
-   {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
-   {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
-   {"acls",            'A', POPT_ARG_NONE,   0,              'A', 0, 0 },
-+  {"xattrs",          'X', POPT_ARG_NONE,   0,              'X', 0, 0 },
-   {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
-   {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
-   {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
-@@ -901,6 +907,17 @@ int parse_arguments(int *argc, const cha
- #endif /* SUPPORT_ACLS */
- 			break;
+@@ -422,6 +429,9 @@ static struct poptOption long_options[] 
+   {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
+   {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
+   {"no-A",             0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
++  {"xattrs",          'X', POPT_ARG_NONE,   0, 'X', 0, 0 },
++  {"no-xattrs",        0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
++  {"no-X",             0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
+   {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
+   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+   {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
+@@ -1096,6 +1106,17 @@ int parse_arguments(int *argc, const cha
+ 			return 0;
+ #endif
  
 +		case 'X':
 +#ifdef SUPPORT_XATTRS
 +			preserve_xattrs = 1;
 +			preserve_perms = 1;
++			break;
 +#else
 +			snprintf(err_buf,sizeof(err_buf),
 +				 "extended attributes are not supported on this %s\n",
 +				 am_server ? "server" : "client");
 +			return 0;
 +#endif /* SUPPORT_XATTRS */
-+			break;
  
  		default:
  			/* A large opt value means that set_refuse_options()
-@@ -1310,6 +1327,8 @@ void server_options(char **args,int *arg
- 		argstr[x++] = 'H';
+@@ -1544,6 +1565,10 @@ void server_options(char **args,int *arg
  	if (preserve_acls)
  		argstr[x++] = 'A';
+ #endif
++#ifdef SUPPORT_XATTRS
 +	if (preserve_xattrs)
 +		argstr[x++] = 'X';
++#endif
  	if (preserve_uid)
  		argstr[x++] = 'o';
  	if (preserve_gid)
---- orig/rsync.c	2004-07-03 20:11:58
-+++ rsync.c	2005-03-03 01:31:22
-@@ -144,6 +144,14 @@ int set_perms(char *fname,struct file_st
- 		if (SET_ACL(fname, file) == 0)
- 			updated = 1;
- 	}
-+	/* If this is a directory, SET_XATTR() will be called on the cleanup
-+	 * receive_generator() pass--if we called it here, we might clobber
-+	 * writability on the directory (SELinux security contexts are stored
-+	 * in xattrs). everything else is OK to do now. */
-+	if (!S_ISDIR(st->st_mode)) {
-+		if (SET_XATTR(fname, file) == 0)
+--- old/rsync.c
++++ new/rsync.c
+@@ -224,6 +224,10 @@ int set_file_attrs(char *fname, struct f
+ 	if (set_acl(fname, file) == 0)
+ 		updated = 1;
+ #endif
++#ifdef SUPPORT_XATTRS
++	if (set_xattr(fname, file) == 0)
 +		updated = 1;
-+	}
++#endif
  
- 	if (verbose > 1 && flags & PERMS_REPORT) {
+ 	if (verbose > 1 && flags & ATTRS_REPORT) {
  		enum logcode code = daemon_log_format_has_i || dry_run
---- orig/rsync.h	2005-05-12 23:32:56
-+++ rsync.h	2005-05-12 23:19:46
-@@ -676,6 +676,38 @@ struct stats {
- #endif /* SUPPORT_ACLS */
+--- old/rsync.h
++++ new/rsync.h
+@@ -672,6 +672,14 @@ struct chmod_mode_struct;
+ #endif
  #include "smb_acls.h"
  
 +#ifdef HAVE_LINUX_XATTRS
 +#define SUPPORT_XATTRS 1
 +#endif
 +
-+#ifdef SUPPORT_XATTRS
-+#ifdef HAVE_ATTR_XATTR_H
++#if defined SUPPORT_XATTRS && defined HAVE_ATTR_XATTR_H
 +#include <attr/xattr.h>
 +#endif
-+#define MAKE_XATTR(file, fname)                        make_xattr(file, fname)
-+#define SEND_XATTR(file, f)                    send_xattr(file, f)
-+#define RECEIVE_XATTR(file, f)                 receive_xattr(file, f)
-+#define SORT_FILE_XATTR_INDEX_LISTS()          sort_file_xattr_index_lists()
-+#define SET_XATTR(fname, file)                 set_xattr(fname, file)
-+#define NEXT_XATTR_UID()                               next_xattr_uid()
-+#define XATTR_UID_MAP(uid)                     xattr_uid_map(uid)
-+#define PUSH_KEEP_BACKUP_XATTR(file, orig, dest) \
-+  push_keep_backup_xattr(file, orig, dest)
-+#define CLEANUP_KEEP_BACKUP_XATTR()            cleanup_keep_backup_xattr()
-+#define DUP_XATTR(orig, dest)          dup_xattr(orig, dest)
-+#else /* SUPPORT_XATTRS */
-+#define MAKE_XATTR(file, fname)                        1 /* checked return value */
-+#define SEND_XATTR(file, f)
-+#define RECEIVE_XATTR(file, f)
-+#define SORT_FILE_XATTR_INDEX_LISTS()
-+#define SET_XATTR(fname, file)                 0 /* checked return value */
-+#define NEXT_XATTR_UID()
-+#define XATTR_UID_MAP(uid)
-+#define PUSH_KEEP_BACKUP_XATTR(file, orig, dest)
-+#define CLEANUP_KEEP_BACKUP_XATTR()
-+#define DUP_XATTR(src, orig)           0 /* checked return value */
-+#endif /* SUPPORT_XATTRS */
 +
  #include "proto.h"
  
  /* We have replacement versions of these if they're missing. */
---- orig/rsync.yo	2004-07-03 20:11:58
-+++ rsync.yo	2005-03-03 01:33:53
-@@ -316,6 +316,7 @@ to the detailed description below for a 
-  -K, --keep-dirlinks         treat symlinked dir on receiver as dir
+--- old/rsync.yo
++++ new/rsync.yo
+@@ -322,6 +322,7 @@ to the detailed description below for a 
   -p, --perms                 preserve permissions
-  -A, --acls                  preserve ACLs (implies -p) [local option]
-+ -X, --xattrs                preserve extended attributes (implies -p) [local option]
-  -o, --owner                 preserve owner (root only)
+  -E, --executability         preserve executability
+  -A, --acls                  preserve ACLs (implies -p) [non-standard]
++ -X, --xattrs                preserve extended attrs (implies -p) [n.s.]
+      --chmod=CHMOD           change destination permissions
+  -o, --owner                 preserve owner (super-user only)
   -g, --group                 preserve group
-  -D, --devices               preserve devices (root only)
-@@ -633,6 +634,11 @@ ACLs to be the same as the local ACLs.  
- remote machine's rsync supports this option also. This is a non-standard
- option.
+@@ -802,6 +803,11 @@ dit(bf(-A, --acls)) This option causes r
+ ACLs to be the same as the source ACLs.  This nonstandard option only
+ works if the remote rsync also supports it.  bf(--acls) implies bf(--perms).
  
 +dit(bf(-X, --xattrs)) This option causes rsync to update the remote
 +extended attributes to be the same as the local ones.  This will work
 +only if the remote machine's rsync supports this option also. This is
 +a non-standard option.
 +
- dit(bf(-o, --owner)) This option causes rsync to set the owner of the
- destination file to be the same as the source file.  On most systems,
- only the super-user can set file ownership.  By default, the preservation
---- orig/xattr.c	2005-05-13 06:10:34
-+++ xattr.c	2005-05-13 06:10:34
-@@ -0,0 +1,546 @@
+ dit(bf(--chmod)) This option tells rsync to apply one or more
+ comma-separated "chmod" strings to the permission of the files in the
+ transfer.  The resulting value is treated as though it was the permissions
+--- old/xattr.c
++++ new/xattr.c
+@@ -0,0 +1,540 @@
 +/* Extended Attribute support for rsync */
 +/* Copyright (C) 2004 Red Hat, Inc */
 +/* Written by Jay Fenlason, vaguely based on the ACLs patch */
 +
 +/* This program is free software; you can redistribute it and/or modify
 +   it under the terms of the GNU General Public License as published by
@@ -467,13 +449,13 @@
 +
 +	xa1 = x1;
 +	xa2 = x2;
 +	return strcmp(xa1->name, xa2->name);
 +}
 +
-+static BOOL rsync_xal_get(const char *fname, rsync_xal *x)
++static int rsync_xal_get(const char *fname, rsync_xal *x)
 +{
 +	ssize_t name_size;
 +	ssize_t datum_size;
 +	ssize_t left;
 +	char *name;
 +	size_t len;
@@ -492,41 +474,41 @@
 +	if (name_size > (ssize_t)namebuf_len) {
 +		name_size = -1;
 +		errno = ERANGE;
 +	}
 +	if (name_size < 0) {
 +		if (errno == ENOTSUP)
-+			return False;
++			return -1;
 +		if (errno == ERANGE) {
 +			name_size = sys_llistxattr(fname, NULL, 0);
 +			if (name_size < 0) {
 +				rprintf(FERROR, "%s: rsync_xal_get: llistxattr: %s\n",
-+	 fname, strerror(errno));
-+				return False;
++					fname, strerror(errno));
++				return -1;
 +			}
 +			namebuf = realloc_array(namebuf, char, name_size + 1);
 +			if (!namebuf)
 +				out_of_memory("rsync_xal_get");
 +			namebuf_len = name_size;
 +			name_size = sys_llistxattr(fname, namebuf, namebuf_len);
 +			if (name_size < 0) {
 +				rprintf(FERROR,
 +				    "%s: rsync_xal_get: re-llistxattr failed: %s\n",
 +				    fname, strerror(errno));
-+				return False;
++				return -1;
 +			}
 +		} else {
 +			rprintf(FERROR,
 +			    "%s: rsync_xal_get: llistxattr failed: %s\n",
 +			    fname, strerror(errno));
-+			return False;
++			return -1;
 +		}
 +	}
 +	rsync_xal_free(x);
 +	if (name_size == 0)
-+		return True;
++		return 0;
 +	for (left = name_size, name = namebuf; left > 0 ; left -= len, name += len) {
 +		len = strlen(name) + 1;
 +
 +		if (x->count >= x->alloc) {
 +			size_t new_alloc;
 +			rsync_xa *new_rxas;
@@ -542,37 +524,37 @@
 +		if (datum_size > (ssize_t)datumbuf_len) {
 +			datum_size = -1;
 +			errno = ERANGE;
 +		}
 +		if (datum_size < 0) {
 +			if (errno == ENOTSUP)
-+				return False;
++				return -1;
 +			if (errno == ERANGE) {
 +				datum_size = sys_lgetxattr(fname, name, NULL, 0);
 +				if (datum_size < 0) {
 +					rprintf(FERROR,
 +					    "%s: rsync_xal_get: lgetxattr %s failed: %s\n",
 +					    fname, name, strerror(errno));
-+					return False;
++					return -1;
 +				}
 +				datumbuf = realloc_array(datumbuf, char, datum_size + 1);
 +				if (!datumbuf)
 +					out_of_memory("rsync_xal_get");
 +				datumbuf_len = datum_size;
 +				datum_size = sys_lgetxattr(fname, name, datumbuf, datumbuf_len);
 +				if (datum_size < 0) {
 +					rprintf(FERROR,
 +					    "%s: rsync_xal_get: re-lgetxattr of %s failed: %s\n",
 +					    name, fname, strerror(errno));
-+					return False;
++					return -1;
 +				}
 +			} else {
 +				rprintf(FERROR,
 +				    "%s: rsync_xal_get: lgetxattr %s failed: %s\n",
 +				    fname, name, strerror(errno));
-+				return False;
++				return -1;
 +			}
 +		}
 +		ptr = new_array(char, len + datum_size);
 +		if (!ptr)
 +			out_of_memory("rsync_xal_get");
 +		strcpy(ptr, name);
@@ -584,26 +566,26 @@
 +		x->rxas[curr_rsync_xal.count].datum = ptr + len;
 +		x->count++;
 +	}
 +	if (x->count > 1) {
 +		qsort(x->rxas, x->count, sizeof (rsync_xa), rsync_xal_compare_names);
 +	}
-+	return True;
++	return 0;
 +}
 +
 +
 +/* generate the xattr(s) for this flist entry;
 + * xattr(s) are either sent or cleaned-up by send_xattr() below */
 +
-+BOOL make_xattr(const struct file_struct *file, const char *fname)
++int make_xattr(const struct file_struct *file, const char *fname)
 +{
 +	if (!preserve_xattrs || !file)
-+		return True;
++		return 1;
 +
 +	rsync_xal_get(fname, &curr_rsync_xal);
-+	return True;
++	return 0; /* TODO:  This needs to return 1 if no xattrs changed! */
 +}
 +
 +static ssize_t rsync_xal_find_matching(void)
 +{
 +	size_t i;
 +	size_t j;
@@ -693,13 +675,13 @@
 +{
 +	char *fname;
 +	int tag;
 +
 +	if (!preserve_xattrs)
 +		return;
-+	fname = f_name(file);
++	fname = f_name(file, NULL);
 +	tag = read_byte(f);
 +	if (tag != 'X' && tag != 'x') {
 +		rprintf(FERROR,
 +		    "%s: receive_xattr: unknown extended attribute type tag: %c\n",
 +		    fname, tag);
 +		exit_cleanup(RERR_STREAMIO);
@@ -760,51 +742,49 @@
 +	} else {
 +		size_t index;
 +
 +		index = read_int(f);
 +		if (index >= rsync_xal_l.count) {
 +			rprintf(FERROR, "%s: receive_xattr: xa index %lu out of range\n",
-+fname, (unsigned long)index);
++				fname, (unsigned long)index);
 +			exit_cleanup(RERR_STREAMIO);
 +		}
 +		fxil.filexalidxs[fxil.count].xalidx = index;
 +	}
 +	fxil.count++;
 +}
 +
-+static BOOL rsync_xal_set(const char *fname, rsync_xal *x)
++static int rsync_xal_set(const char *fname, rsync_xal *x)
 +{
 +	size_t i;
-+	int status;
-+	BOOL ret;
++	int ret = 0;
 +
-+	ret = True;
 +	for (i = 0; i < x->count; i++) {
-+		status = sys_lsetxattr(fname, x->rxas[i].name, x->rxas[i].datum, x->rxas[i].datum_len, 0);
++		int status = sys_lsetxattr(fname, x->rxas[i].name, x->rxas[i].datum, x->rxas[i].datum_len, 0);
 +		if (status < 0) {
 +			rprintf(FERROR, "%s: rsync_xal_set: lsetxattr %s failed: %s\n",
 +				fname, x->rxas[i].name, strerror(errno));
-+			ret = False;
++			ret = -1;
 +		}
 +	}
 +	return ret;
 +}
 +
 +/* for duplicating xattrs on backups when using backup_dir */
 +
 +int dup_xattr(const char *orig, const char *bak)
 +{
 +	int ret;
 +
-+	ret = 0;
 +	if (!preserve_xattrs)
-+		return ret;
++		return 1;
 +
-+	ret = rsync_xal_get(orig, &backup_xal);
-+	if (ret == True)
++	if (rsync_xal_get(orig, &backup_xal) < 0)
 +		ret = rsync_xal_set(bak, &backup_xal);
++	else
++		ret = 0;
 +	rsync_xal_free(&backup_xal);
 +	return ret;
 +}
 +
 +void push_keep_backup_xattr(const struct file_struct *file, const char *orig, const char *dest)
 +{
@@ -817,13 +797,13 @@
 +	rsync_xal_get(orig, &backup_xal);
 +}
 +
 +static int set_keep_backup_xal(void)
 +{
 +	if (!preserve_xattrs)
-+		return 0;
++		return 1;
 +	return rsync_xal_set(backup_dest_fname, &backup_xal);
 +}
 +
 +void cleanup_keep_backup_xattr(void)
 +{
 +	if (!preserve_xattrs)
@@ -880,29 +860,314 @@
 +	rprintf(FERROR,
 +		"find_file_xal_index: can't find entry for file in list\n");
 +	exit_cleanup(RERR_STREAMIO);
 +	return -1;
 +}
 +
-+
 +/* set extended attributes on rsync-ed or keep_backup-ed file */
 +
 +int set_xattr(const char *fname, const struct file_struct *file)
 +{
-+	int updated;
 +	int xalidx;
 +	rsync_xal *x;
 +
-+	updated = 0;
 +	if (dry_run || !preserve_xattrs)
-+		return 0;
++		return 1;
 +	if (file == backup_orig_file) {
 +		if (!strcmp(fname, backup_dest_fname))
 +			return set_keep_backup_xal();
 +	}
 +	xalidx = find_file_xal_index(file);
 +	x = &(rsync_xal_l.rxals[xalidx]);
-+	updated = rsync_xal_set(fname, x);
-+	return updated;
++	return rsync_xal_set(fname, x);
 +}
 +
 +#endif /* SUPPORT_XATTRS */
+--- old/proto.h
++++ new/proto.h
+@@ -335,4 +335,12 @@ void bitbag_set_bit(struct bitbag *bb, i
+ void bitbag_clear_bit(struct bitbag *bb, int ndx);
+ int bitbag_check_bit(struct bitbag *bb, int ndx);
+ int bitbag_next_bit(struct bitbag *bb, int after);
++int make_xattr(const struct file_struct *file, const char *fname);
++void send_xattr(const struct file_struct *file, int f);
++void receive_xattr(struct file_struct *file, int f);
++int dup_xattr(const char *orig, const char *bak);
++void push_keep_backup_xattr(const struct file_struct *file, const char *orig, const char *dest);
++void cleanup_keep_backup_xattr(void);
++void sort_file_xattr_index_lists(void);
++int set_xattr(const char *fname, const struct file_struct *file);
+ int sys_gettimeofday(struct timeval *tv);
+--- old/configure
++++ new/configure
+@@ -853,6 +853,7 @@ Optional Features:
+   --disable-ipv6          don't even try to use IPv6
+   --disable-locale        turn off locale features
+   --enable-acl-support    Include ACL support (default=no)
++  --enable-xattr-support  Include extended attribute support (default=no)
+ 
+ Optional Packages:
+   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+@@ -12830,6 +12831,198 @@ echo "${ECHO_T}no" >&6
+ 
+ fi;
+ 
++
++for ac_header in attr/xattr.h
++do
++as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo "$as_me:$LINENO: checking for $ac_header" >&5
++echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++fi
++echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
++echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
++else
++  # Is the header compilable?
++echo "$as_me:$LINENO: checking $ac_header usability" >&5
++echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++$ac_includes_default
++#include <$ac_header>
++_ACEOF
++rm -f conftest.$ac_objext
++if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
++  (eval $ac_compile) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } &&
++	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; } &&
++	 { ac_try='test -s conftest.$ac_objext'
++  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
++  (eval $ac_try) 2>&5
++  ac_status=$?
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); }; }; then
++  ac_header_compiler=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++ac_header_compiler=no
++fi
++rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
++echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
++echo "${ECHO_T}$ac_header_compiler" >&6
++
++# Is the header present?
++echo "$as_me:$LINENO: checking $ac_header presence" >&5
++echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
++cat >conftest.$ac_ext <<_ACEOF
++/* confdefs.h.  */
++_ACEOF
++cat confdefs.h >>conftest.$ac_ext
++cat >>conftest.$ac_ext <<_ACEOF
++/* end confdefs.h.  */
++#include <$ac_header>
++_ACEOF
++if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
++  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
++  ac_status=$?
++  grep -v '^ *+' conftest.er1 >conftest.err
++  rm -f conftest.er1
++  cat conftest.err >&5
++  echo "$as_me:$LINENO: \$? = $ac_status" >&5
++  (exit $ac_status); } >/dev/null; then
++  if test -s conftest.err; then
++    ac_cpp_err=$ac_c_preproc_warn_flag
++    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
++  else
++    ac_cpp_err=
++  fi
++else
++  ac_cpp_err=yes
++fi
++if test -z "$ac_cpp_err"; then
++  ac_header_preproc=yes
++else
++  echo "$as_me: failed program was:" >&5
++sed 's/^/| /' conftest.$ac_ext >&5
++
++  ac_header_preproc=no
++fi
++rm -f conftest.err conftest.$ac_ext
++echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
++echo "${ECHO_T}$ac_header_preproc" >&6
++
++# So?  What about this header?
++case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
++  yes:no: )
++    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
++echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
++echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
++    ac_header_preproc=yes
++    ;;
++  no:yes:* )
++    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
++echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
++echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
++echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
++echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
++echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
++    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
++echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
++    (
++      cat <<\_ASBOX
++## ------------------------------------------ ##
++## Report this to the AC_PACKAGE_NAME lists.  ##
++## ------------------------------------------ ##
++_ASBOX
++    ) |
++      sed "s/^/$as_me: WARNING:     /" >&2
++    ;;
++esac
++echo "$as_me:$LINENO: checking for $ac_header" >&5
++echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
++if eval "test \"\${$as_ac_Header+set}\" = set"; then
++  echo $ECHO_N "(cached) $ECHO_C" >&6
++else
++  eval "$as_ac_Header=\$ac_header_preproc"
++fi
++echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
++echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
++
++fi
++if test `eval echo '${'$as_ac_Header'}'` = yes; then
++  cat >>confdefs.h <<_ACEOF
++#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
++_ACEOF
++
++fi
++
++done
++
++echo "$as_me:$LINENO: checking whether to support extended attributes" >&5
++echo $ECHO_N "checking whether to support extended attributes... $ECHO_C" >&6
++# Check whether --enable-xattr-support or --disable-xattr-support was given.
++if test "${enable_xattr_support+set}" = set; then
++  enableval="$enable_xattr_support"
++   case "$enableval" in
++  yes)
++      case "$host_os" in
++      *linux*)
++            echo "$as_me:$LINENO: result: Using Linux xattrs" >&5
++echo "${ECHO_T}Using Linux xattrs" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_LINUX_XATTRS 1
++_ACEOF
++
++            ;;
++      *)
++            echo "$as_me:$LINENO: result: Xattrs requested but not linux.  Good luck" >&5
++echo "${ECHO_T}Xattrs requested but not linux.  Good luck" >&6
++            ;;
++      esac
++      ;;
++  *)
++      echo "$as_me:$LINENO: result: no" >&5
++echo "${ECHO_T}no" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_NA_XATTRS 1
++_ACEOF
++
++  esac
++else
++  echo "$as_me:$LINENO: result: no" >&5
++echo "${ECHO_T}no" >&6
++
++cat >>confdefs.h <<\_ACEOF
++#define HAVE_NO_XATTRL 1
++_ACEOF
++
++
++fi;
++
+                                                   ac_config_files="$ac_config_files Makefile lib/dummy zlib/dummy popt/dummy shconfig"
+ 
+ cat >confcache <<\_ACEOF
+--- old/config.h.in
++++ new/config.h.in
+@@ -46,6 +46,9 @@
+ /* Define to 1 if you have the `asprintf' function. */
+ #undef HAVE_ASPRINTF
+ 
++/* Define to 1 if you have the <attr/xattr.h> header file. */
++#undef HAVE_ATTR_XATTR_H
++
+ /* Define to 1 if readdir() is broken */
+ #undef HAVE_BROKEN_READDIR
+ 
+@@ -185,6 +188,9 @@
+ /* Define to 1 if you have the `link' function. */
+ #undef HAVE_LINK
+ 
++/* True if you have Linux xattrs */
++#undef HAVE_LINUX_XATTRS
++
+ /* Define to 1 if you have the `locale_charset' function. */
+ #undef HAVE_LOCALE_CHARSET
+ 
+@@ -228,6 +234,9 @@
+ /* Define to 1 if you have the `mtrace' function. */
+ #undef HAVE_MTRACE
+ 
++/* True if you don't have extended attributes */
++#undef HAVE_NA_XATTRS
++
+ /* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+ #undef HAVE_NDIR_H
+ 
+@@ -240,6 +249,9 @@
+ /* true if you don't have ACLs */
+ #undef HAVE_NO_ACLS
+ 
++/* True if you don't have extended attributes */
++#undef HAVE_NO_XATTRL
++
+ /* Define to 1 if you have the `open64' function. */
+ #undef HAVE_OPEN64
+ 
+--- old/rsync.1
++++ new/rsync.1
+@@ -378,6 +378,7 @@ to the detailed description below for a 
+  -p, --perms                 preserve permissions
+  -E, --executability         preserve executability
+  -A, --acls                  preserve ACLs (implies -p) [non-standard]
++ -X, --xattrs                preserve extended attrs (implies -p) [n\&.s\&.]
+      --chmod=CHMOD           change destination permissions
+  -o, --owner                 preserve owner (super-user only)
+  -g, --group                 preserve group
+@@ -913,6 +914,12 @@ This option causes rsync to update the d
+ ACLs to be the same as the source ACLs\&.  This nonstandard option only
+ works if the remote rsync also supports it\&.  \fB--acls\fP implies \fB--perms\fP\&.
+ .IP 
++.IP "\fB-X, --xattrs\fP" 
++This option causes rsync to update the remote
++extended attributes to be the same as the local ones\&.  This will work
++only if the remote machine\&'s rsync supports this option also\&. This is
++a non-standard option\&.
++.IP 
+ .IP "\fB--chmod\fP" 
+ This option tells rsync to apply one or more
+ comma-separated "chmod" strings to the permission of the files in the
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/pipe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/pipe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/pipe.c	2005-04-10 02:59:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/pipe.c	2006-02-24 09:56:26.000000000 +0800
@@ -21,17 +21,18 @@
 
 #include "rsync.h"
 
 extern int am_sender;
 extern int am_server;
 extern int blocking_io;
-extern int orig_umask;
 extern int filesfrom_fd;
+extern mode_t orig_umask;
+extern struct chmod_mode_struct *chmod_modes;
 
 /**
- * Create a child connected to use on stdin/stdout.
+ * Create a child connected to us via its stdin/stdout.
  *
  * This is derived from CVS code
  *
  * Note that in the child STDIN is set to blocking and STDOUT
  * is set to non-blocking. This is necessary as rsh relies on stdin being blocking
  *  and ssh relies on stdout being non-blocking
@@ -75,14 +76,13 @@
 			close(from_child_pipe[1]);
 		umask(orig_umask);
 		set_blocking(STDIN_FILENO);
 		if (blocking_io > 0)
 			set_blocking(STDOUT_FILENO);
 		execvp(command[0], command);
-		rsyserr(FERROR, errno, "Failed to exec %s",
-			safe_fname(command[0]));
+		rsyserr(FERROR, errno, "Failed to exec %s", command[0]);
 		exit_cleanup(RERR_IPC);
 	}
 
 	if (close(from_child_pipe[1]) < 0 || close(to_child_pipe[0]) < 0) {
 		rsyserr(FERROR, errno, "Failed to close");
 		exit_cleanup(RERR_IPC);
@@ -108,12 +108,15 @@
 		  int (*child_main)(int, char*[]))
 {
 	pid_t pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
 
+	/* The parent process is always the sender for a local rsync. */
+	assert(am_sender);
+
 	if (fd_pair(to_child_pipe) < 0 ||
 	    fd_pair(from_child_pipe) < 0) {
 		rsyserr(FERROR, errno, "pipe");
 		exit_cleanup(RERR_IPC);
 	}
 
@@ -121,17 +124,16 @@
 	if (pid == -1) {
 		rsyserr(FERROR, errno, "fork");
 		exit_cleanup(RERR_IPC);
 	}
 
 	if (pid == 0) {
-		am_sender = !am_sender;
+		am_sender = 0;
 		am_server = 1;
-
-		if (!am_sender)
-			filesfrom_fd = -1;
+		filesfrom_fd = -1;
+		chmod_modes = NULL; /* Let the sending side handle this. */
 
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
 			rsyserr(FERROR, errno, "Failed to dup/close");
@@ -141,15 +143,12 @@
 			close(to_child_pipe[0]);
 		if (from_child_pipe[1] != STDOUT_FILENO)
 			close(from_child_pipe[1]);
 		child_main(argc, argv);
 	}
 
-	if (!am_sender)
-		filesfrom_fd = -1;
-
 	if (close(from_child_pipe[1]) < 0 ||
 	    close(to_child_pipe[0]) < 0) {
 		rsyserr(FERROR, errno, "Failed to close");
 		exit_cleanup(RERR_IPC);
 	}
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7: prepare-source
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7: prepare-source.mak
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/progress.c	2005-03-06 01:49:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/progress.c	2006-01-15 01:10:52.000000000 +0800
@@ -94,21 +94,20 @@
 
 	remain_s = (int) remain % 60;
 	remain_m = (int) (remain / 60.0) % 60;
 	remain_h = (int) (remain / 3600.0);
 
 	if (is_last) {
-		snprintf(eol, sizeof eol, "  (%d, %.1f%% of %d)\n",
+		snprintf(eol, sizeof eol, " (xfer#%d, to-check=%d/%d)\n",
 			stats.num_transferred_files,
-			(float)((stats.current_file_index+1) * 100)
-				/ stats.num_files,
+			stats.num_files - stats.current_file_index - 1,
 			stats.num_files);
 	} else
 		strcpy(eol, "\r");
-	rprintf(FINFO, "%12.0f %3d%% %7.2f%s %4d:%02d:%02d%s",
-		(double) ofs, pct, rate, units,
+	rprintf(FINFO, "%12s %3d%% %7.2f%s %4d:%02d:%02d%s",
+		human_num(ofs), pct, rate, units,
 		remain_h, remain_m, remain_s, eol);
 }
 
 void end_progress(OFF_T size)
 {
 	if (!am_server) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/proto.h	2005-07-08 03:49:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/proto.h	2006-03-12 02:25:04.000000000 +0800
@@ -1,26 +1,28 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
 int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
-void base64_encode(char *buf, int len, char *out);
+void base64_encode(char *buf, int len, char *out, int pad);
 char *auth_server(int f_in, int f_out, int module, char *host, char *addr,
 		  char *leader);
 void auth_client(int fd, char *user, char *challenge);
 char *get_backup_name(char *fname);
 int make_backup(char *fname);
 void write_stream_flags(int fd);
 void read_stream_flags(int fd);
 void write_batch_shell_file(int argc, char *argv[], int file_arg_cnt);
-void show_flist(int index, struct file_struct **fptr);
-void show_argvs(int argc, char *argv[]);
 uint32 get_checksum1(char *buf1, int32 len);
 void get_checksum2(char *buf, int32 len, char *sum);
 void file_checksum(char *fname,char *sum,OFF_T size);
 void sum_init(int seed);
 void sum_update(char *p, int32 len);
 void sum_end(char *sum);
+struct chmod_mode_struct *parse_chmod(const char *modestr,
+				      struct chmod_mode_struct **root_mode_ptr);
+int tweak_mode(int mode, struct chmod_mode_struct *chmod_modes);
+int free_chmod_mode(struct chmod_mode_struct *chmod_modes);
 void close_all(void);
 void _exit_cleanup(int code, const char *file, int line);
 void cleanup_disable(void);
 void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
 		 int fd_r, int fd_w);
 void cleanup_set_pid(pid_t pid);
@@ -65,28 +67,29 @@
 char *map_ptr(struct map_struct *map, OFF_T offset, int32 len);
 int unmap_file(struct map_struct *map);
 void init_flist(void);
 void show_flist_stats(void);
 int link_stat(const char *path, STRUCT_STAT *buffer, int follow_dirlinks);
 void flist_expand(struct file_list *flist);
-void send_file_entry(struct file_struct *file, int f, unsigned short base_flags);
 struct file_struct *make_file(char *fname, struct file_list *flist,
+			      STRUCT_STAT *stp, unsigned short flags,
 			      int filter_level);
 struct file_list *send_file_list(int f, int argc, char *argv[]);
 struct file_list *recv_file_list(int f);
 int flist_find(struct file_list *flist, struct file_struct *f);
-void clear_file(int i, struct file_list *flist);
+void clear_file(struct file_struct *file, struct file_list *flist);
 struct file_list *flist_new(int with_hlink, char *msg);
 void flist_free(struct file_list *flist);
 int f_name_cmp(struct file_struct *f1, struct file_struct *f2);
-char *f_name_to(struct file_struct *f, char *fbuf);
-char *f_name(struct file_struct *f);
+char *f_name(struct file_struct *f, char *fbuf);
 struct file_list *get_dirlist(char *dirname, int dlen,
 			      int ignore_filter_rules);
+int unchanged_attrs(struct file_struct *file, STRUCT_STAT *st);
 void itemize(struct file_struct *file, int ndx, int statret, STRUCT_STAT *st,
 	     int32 iflags, uchar fnamecmp_type, char *xname);
+int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st);
 void check_for_finished_hlinks(int itemizing, enum logcode code);
 void generate_files(int f_out, struct file_list *flist, char *local_name);
 void init_hard_links(void);
 int hard_link_check(struct file_struct *file, int ndx, char *fname,
 		    int statret, STRUCT_STAT *st, int itemizing,
 		    enum logcode code, int skip);
@@ -96,14 +99,15 @@
 void hard_link_cluster(struct file_struct *file, int master, int itemizing,
 		       enum logcode code);
 void io_set_sock_fds(int f_in, int f_out);
 void set_io_timeout(int secs);
 void set_msg_fd_in(int fd);
 void set_msg_fd_out(int fd);
+void increment_active_files(int ndx, int itemizing, enum logcode code);
+void decrement_active_files(int ndx);
 void send_msg(enum msgcode code, char *buf, int len);
-int msg_list_push(int flush_it_all);
 int get_redo_num(int itemizing, enum logcode code);
 int get_hlink_num(void);
 void io_set_filesfrom_fds(int f_in, int f_out);
 int read_filesfrom_line(int fd, char *fname);
 void io_start_buffering_out(void);
 void io_start_buffering_in(void);
@@ -134,48 +138,53 @@
 void io_start_multiplex_in(void);
 int io_multiplex_write(enum msgcode code, char *buf, size_t len);
 void close_multiplexing_in(void);
 void close_multiplexing_out(void);
 void start_write_batch(int fd);
 void stop_write_batch(void);
-char *lp_motd_file(void);
+char *lp_bind_address(void);
 char *lp_log_file(void);
+char *lp_motd_file(void);
 char *lp_pid_file(void);
 char *lp_socket_options(void);
-int lp_syslog_facility(void);
 int lp_rsync_port(void);
-char *lp_bind_address(void);
-char *lp_name(int );
+int lp_syslog_facility(void);
+char *lp_auth_users(int );
 char *lp_comment(int );
-char *lp_path(int );
-char *lp_lock_file(int );
-BOOL lp_read_only(int );
-BOOL lp_write_only(int );
-BOOL lp_list(int );
-BOOL lp_use_chroot(int );
-BOOL lp_transfer_logging(int );
-BOOL lp_ignore_errors(int );
-BOOL lp_ignore_nonreadable(int );
-char *lp_uid(int );
+char *lp_dont_compress(int );
+char *lp_exclude(int );
+char *lp_exclude_from(int );
+char *lp_filter(int );
 char *lp_gid(int );
 char *lp_hosts_allow(int );
 char *lp_hosts_deny(int );
-char *lp_auth_users(int );
-char *lp_secrets_file(int );
-BOOL lp_strict_modes(int );
-char *lp_filter(int );
-char *lp_exclude(int );
-char *lp_exclude_from(int );
 char *lp_include(int );
 char *lp_include_from(int );
+char *lp_incoming_chmod(int );
+char *lp_lock_file(int );
 char *lp_log_format(int );
+char *lp_name(int );
+char *lp_outgoing_chmod(int );
+char *lp_path(int );
+char *lp_postxfer_exec(int );
+char *lp_prexfer_exec(int );
 char *lp_refuse_options(int );
-char *lp_dont_compress(int );
-int lp_timeout(int );
+char *lp_secrets_file(int );
+char *lp_temp_dir(int );
+char *lp_uid(int );
 int lp_max_connections(int );
 int lp_max_verbosity(int );
+int lp_timeout(int );
+BOOL lp_ignore_errors(int );
+BOOL lp_ignore_nonreadable(int );
+BOOL lp_list(int );
+BOOL lp_read_only(int );
+BOOL lp_strict_modes(int );
+BOOL lp_transfer_logging(int );
+BOOL lp_use_chroot(int );
+BOOL lp_write_only(int );
 BOOL lp_load(char *pszFname, int globals_only);
 int lp_numservices(void);
 int lp_number(char *name);
 void log_init(void);
 void logfile_close(void);
 void logfile_reopen(void);
@@ -187,16 +196,17 @@
 void log_item(struct file_struct *file, struct stats *initial_stats,
 	      int iflags, char *hlink);
 void maybe_log_item(struct file_struct *file, int iflags, int itemizing,
 		    char *buf);
 void log_delete(char *fname, int mode);
 void log_exit(int code, const char *file, int line);
-void wait_process(pid_t pid, int *status);
+pid_t wait_process(pid_t pid, int *status_ptr, int flags);
 int child_main(int argc, char *argv[]);
 void start_server(int f_in, int f_out, int argc, char *argv[]);
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[]);
+RETSIGTYPE remember_children(UNUSED(int val));
 const char *get_panic_action(void);
 int main(int argc,char *argv[]);
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len);
 void match_report(void);
 void usage(enum logcode F);
 void option_error(void);
@@ -209,18 +219,21 @@
 pid_t piped_child(char **command, int *f_in, int *f_out);
 pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
 		  int (*child_main)(int, char*[]));
 void end_progress(OFF_T size);
 void show_progress(OFF_T ofs, OFF_T size);
 int recv_files(int f_in, struct file_list *flist, char *local_name);
+void setup_iconv();
 void free_sums(struct sum_struct *s);
-int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
-	      int flags);
-void sig_int(void);
-void finish_transfer(char *fname, char *fnametmp, struct file_struct *file,
-		     int ok_to_set_time, int overwriting_basis);
+mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int exists);
+int set_file_attrs(char *fname, struct file_struct *file, STRUCT_STAT *st,
+		   int flags);
+RETSIGTYPE sig_int(UNUSED(int val));
+void finish_transfer(char *fname, char *fnametmp, char *partialptr,
+		     struct file_struct *file, int ok_to_set_time,
+		     int overwriting_basis);
 const char *who_am_i(void);
 void successful_send(int ndx);
 int read_item_attrs(int f_in, int f_out, int ndx, uchar *type_ptr,
 		    char *buf, int *len_ptr);
 void send_files(struct file_list *flist, int f_out, int f_in);
 int try_bind_local(int s, int ai_family, int ai_socktype,
@@ -231,21 +244,21 @@
 			    int af_hint);
 int is_a_socket(int fd);
 void start_accept_loop(int port, int (*fn)(int, int));
 void set_socket_options(int fd, char *options);
 void become_daemon(void);
 int sock_exec(const char *prog);
-int do_unlink(char *fname);
-int do_symlink(char *fname1, char *fname2);
-int do_link(char *fname1, char *fname2);
+int do_unlink(const char *fname);
+int do_symlink(const char *fname1, const char *fname2);
+int do_link(const char *fname1, const char *fname2);
 int do_lchown(const char *path, uid_t owner, gid_t group);
 int do_mknod(char *pathname, mode_t mode, dev_t dev);
-int do_rmdir(char *pathname);
-int do_open(char *pathname, int flags, mode_t mode);
+int do_rmdir(const char *pathname);
+int do_open(const char *pathname, int flags, mode_t mode);
 int do_chmod(const char *path, mode_t mode);
-int do_rename(char *fname1, char *fname2);
+int do_rename(const char *fname1, const char *fname2);
 void trim_trailing_slashes(char *name);
 int do_mkdir(char *fname, mode_t mode);
 int do_mkstemp(char *template, mode_t perms);
 int do_stat(const char *fname, STRUCT_STAT *st);
 int do_lstat(const char *fname, STRUCT_STAT *st);
 int do_fstat(int fd, STRUCT_STAT *st);
@@ -263,18 +276,20 @@
 void set_nonblocking(int fd);
 void set_blocking(int fd);
 int fd_pair(int fd[2]);
 void print_child_argv(char **cmd);
 void out_of_memory(char *str);
 void overflow_exit(char *str);
-int set_modtime(char *fname, time_t modtime);
-int create_directory_path(char *fname, int base_umask);
+int set_modtime(char *fname, time_t modtime, mode_t mode);
+int mkdir_defmode(char *fname);
+int create_directory_path(char *fname);
 int full_write(int desc, char *ptr, size_t len);
-int copy_file(char *source, char *dest, mode_t mode);
-int robust_unlink(char *fname);
-int robust_rename(char *from, char *to, int mode);
+int copy_file(const char *source, const char *dest, mode_t mode);
+int robust_unlink(const char *fname);
+int robust_rename(char *from, char *to, char *partialptr,
+		  int mode);
 pid_t do_fork(void);
 void kill_all(int sig);
 int name_to_uid(char *name, uid_t *uid);
 int name_to_gid(char *name, gid_t *gid);
 int lock_range(int fd, int offset, int len);
 void glob_expand(char *base1, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr);
@@ -283,21 +298,26 @@
 size_t stringjoin(char *dest, size_t destsize, ...);
 int count_dir_elements(const char *p);
 unsigned int clean_fname(char *name, BOOL collapse_dot_dot);
 char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth);
 int push_dir(char *dir);
 int pop_dir(char *dir);
-char *safe_fname(const char *fname);
 char *full_fname(const char *fn);
 char *partial_dir_fname(const char *fname);
 int handle_partial_dir(const char *fname, int create);
-int u_strcmp(const char *cs1, const char *cs2);
 int unsafe_symlink(const char *dest, const char *src);
+char *human_num(int64 num);
+char *human_dnum(double dnum, int decimal_digits);
 char *timestring(time_t t);
 int msleep(int t);
-int cmp_modtime(time_t file1, time_t file2);
+int cmp_time(time_t file1, time_t file2);
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6);
 void *_new_array(unsigned int size, unsigned long num);
 void *_realloc_array(void *ptr, unsigned int size, unsigned long num);
 const char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr);
 uint32 fuzzy_distance(const char *s1, int len1, const char *s2, int len2);
+struct bitbag *bitbag_create(int max_ndx);
+void bitbag_set_bit(struct bitbag *bb, int ndx);
+void bitbag_clear_bit(struct bitbag *bb, int ndx);
+int bitbag_check_bit(struct bitbag *bb, int ndx);
+int bitbag_next_bit(struct bitbag *bb, int after);
 int sys_gettimeofday(struct timeval *tv);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/receiver.c	2005-04-14 09:42:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/receiver.c	2006-02-25 00:43:44.000000000 +0800
@@ -31,99 +31,35 @@
 extern int csum_length;
 extern int read_batch;
 extern int write_batch;
 extern int batch_gen_fd;
 extern int protocol_version;
 extern int relative_paths;
-extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int preserve_perms;
-extern int io_error;
 extern int basis_dir_cnt;
 extern int make_backups;
 extern int cleanup_got_literal;
 extern int remove_sent_files;
-extern int module_id;
-extern int ignore_errors;
-extern int orig_umask;
+extern int append_mode;
+extern int sparse_files;
 extern int keep_partial;
 extern int checksum_seed;
 extern int inplace;
 extern int delay_updates;
 extern struct stats stats;
 extern char *log_format;
 extern char *tmpdir;
 extern char *partial_dir;
 extern char *basis_dir[];
 extern struct file_list *the_file_list;
 extern struct filter_list_struct server_filter_list;
 
-#define SLOT_SIZE	(16*1024)	/* Desired size in bytes */
-#define PER_SLOT_BITS	(SLOT_SIZE * 8) /* Number of bits per slot */
-#define PER_SLOT_INTS	(SLOT_SIZE / 4) /* Number of int32s per slot */
-
-static uint32 **delayed_bits = NULL;
-static int delayed_slot_cnt = 0;
+static struct bitbag *delayed_bits = NULL;
 static int phase = 0;
 
-static void init_delayed_bits(int max_ndx)
-{
-	delayed_slot_cnt = (max_ndx + PER_SLOT_BITS - 1) / PER_SLOT_BITS;
-
-	if (!(delayed_bits = (uint32**)calloc(delayed_slot_cnt, sizeof (uint32*))))
-		out_of_memory("set_delayed_bit");
-}
-
-static void set_delayed_bit(int ndx)
-{
-	int slot = ndx / PER_SLOT_BITS;
-	ndx %= PER_SLOT_BITS;
-
-	if (!delayed_bits[slot]) {
-		if (!(delayed_bits[slot] = (uint32*)calloc(PER_SLOT_INTS, 4)))
-			out_of_memory("set_delayed_bit");
-	}
-
-	delayed_bits[slot][ndx/32] |= 1u << (ndx % 32);
-}
-
-/* Call this with -1 to start checking from 0.  Returns -1 at the end. */
-static int next_delayed_bit(int after)
-{
-	uint32 bits, mask;
-	int i, ndx = after + 1;
-	int slot = ndx / PER_SLOT_BITS;
-	ndx %= PER_SLOT_BITS;
-
-	mask = (1u << (ndx % 32)) - 1;
-	for (i = ndx / 32; slot < delayed_slot_cnt; slot++, i = mask = 0) {
-		if (!delayed_bits[slot])
-			continue;
-		for ( ; i < PER_SLOT_INTS; i++, mask = 0) {
-			if (!(bits = delayed_bits[slot][i] & ~mask))
-				continue;
-			/* The xor magic figures out the lowest enabled bit in
-			 * bits, and the switch quickly computes log2(bit). */
-			switch (bits ^ (bits & (bits-1))) {
-#define LOG2(n) case 1u << n: return slot*PER_SLOT_BITS + i*32 + n
-			    LOG2(0);  LOG2(1);  LOG2(2);  LOG2(3);
-			    LOG2(4);  LOG2(5);  LOG2(6);  LOG2(7);
-			    LOG2(8);  LOG2(9);  LOG2(10); LOG2(11);
-			    LOG2(12); LOG2(13); LOG2(14); LOG2(15);
-			    LOG2(16); LOG2(17); LOG2(18); LOG2(19);
-			    LOG2(20); LOG2(21); LOG2(22); LOG2(23);
-			    LOG2(24); LOG2(25); LOG2(26); LOG2(27);
-			    LOG2(28); LOG2(29); LOG2(30); LOG2(31);
-			}
-			return -1; /* impossible... */
-		}
-	}
-
-	return -1;
-}
-
 
 /*
  * get_tmpname() - create a tmp filename for a given filename
  *
  *   If a tmpdir is defined, use that as the directory to
  *   put it in.  Otherwise, the tmp filename is in the same
@@ -168,14 +104,13 @@
 	fnametmp[length++] = '.';
 	fnametmp[length] = '\0';		/* always NULL terminated */
 
 	maxname = MIN(MAXPATHLEN - 7 - length, NAME_MAX - 8);
 
 	if (maxname < 1) {
-		rprintf(FERROR, "temporary filename too long: %s\n",
-			safe_fname(fname));
+		rprintf(FERROR, "temporary filename too long: %s\n", fname);
 		fnametmp[0] = '\0';
 		return 0;
 	}
 
 	strlcpy(fnametmp + length, f, maxname);
 	strcat(fnametmp + length, ".XXXXXX");
@@ -202,19 +137,45 @@
 
 	if (fd_r >= 0 && size_r > 0) {
 		int32 read_size = MAX(sum.blength * 2, 16*1024);
 		mapbuf = map_file(fd_r, size_r, read_size, sum.blength);
 		if (verbose > 2) {
 			rprintf(FINFO, "recv mapped %s of size %.0f\n",
-				safe_fname(fname_r), (double)size_r);
+				fname_r, (double)size_r);
 		}
 	} else
 		mapbuf = NULL;
 
 	sum_init(checksum_seed);
 
+	if (append_mode) {
+		OFF_T j;
+		sum.flength = (OFF_T)sum.count * sum.blength;
+		if (sum.remainder)
+			sum.flength -= sum.blength - sum.remainder;
+		for (j = CHUNK_SIZE; j < sum.flength; j += CHUNK_SIZE) {
+			if (do_progress)
+				show_progress(offset, total_size);
+			sum_update(map_ptr(mapbuf, offset, CHUNK_SIZE),
+				   CHUNK_SIZE);
+			offset = j;
+		}
+		if (offset < sum.flength) {
+			int32 len = sum.flength - offset;
+			if (do_progress)
+				show_progress(offset, total_size);
+			sum_update(map_ptr(mapbuf, offset, len), len);
+			offset = sum.flength;
+		}
+		if (fd != -1 && do_lseek(fd, offset, SEEK_SET) != offset) {
+			rsyserr(FERROR, errno, "lseek failed on %s",
+				full_fname(fname));
+			exit_cleanup(RERR_FILEIO);
+		}
+	}
+
 	while ((i = recv_token(f_in, &data)) != 0) {
 		if (do_progress)
 			show_progress(offset, total_size);
 
 		if (i > 0) {
 			if (verbose > 3) {
@@ -312,50 +273,49 @@
 
 static void handle_delayed_updates(struct file_list *flist, char *local_name)
 {
 	char *fname, *partialptr, numbuf[4];
 	int i;
 
-	for (i = -1; (i = next_delayed_bit(i)) >= 0; ) {
+	for (i = -1; (i = bitbag_next_bit(delayed_bits, i)) >= 0; ) {
 		struct file_struct *file = flist->files[i];
-		fname = local_name ? local_name : f_name(file);
+		fname = local_name ? local_name : f_name(file, NULL);
 		if ((partialptr = partial_dir_fname(fname)) != NULL) {
 			if (make_backups && !make_backup(fname))
 				continue;
 			if (verbose > 2) {
 				rprintf(FINFO, "renaming %s to %s\n",
-					safe_fname(partialptr),
-					safe_fname(fname));
+					partialptr, fname);
 			}
+			/* We don't use robust_rename() here because the
+			 * partial-dir must be on the same drive. */
 			if (do_rename(partialptr, fname) < 0) {
 				rsyserr(FERROR, errno,
 					"rename failed for %s (from %s)",
-					full_fname(fname),
-					safe_fname(partialptr));
+					full_fname(fname), partialptr);
 			} else {
 				if (remove_sent_files
 				    || (preserve_hard_links
 				     && file->link_u.links)) {
 					SIVAL(numbuf, 0, i);
 					send_msg(MSG_SUCCESS,numbuf,4);
 				}
-				handle_partial_dir(partialptr,
-						   PDIR_DELETE);
+				handle_partial_dir(partialptr, PDIR_DELETE);
 			}
 		}
 	}
 }
 
 static int get_next_gen_i(int batch_gen_fd, int next_gen_i, int desired_i)
 {
 	while (next_gen_i < desired_i) {
 		if (next_gen_i >= 0) {
 			rprintf(FINFO,
 				"(No batched update for%s \"%s\")\n",
 				phase ? " resend of" : "",
-				safe_fname(f_name(the_file_list->files[next_gen_i])));
+				f_name(the_file_list->files[next_gen_i], NULL));
 		}
 		next_gen_i = read_int(batch_gen_fd);
 		if (next_gen_i == -1)
 			next_gen_i = the_file_list->count;
 	}
 	return next_gen_i;
@@ -392,13 +352,13 @@
 	if (flist->hlink_pool) {
 		pool_destroy(flist->hlink_pool);
 		flist->hlink_pool = NULL;
 	}
 
 	if (delay_updates)
-		init_delayed_bits(flist->count);
+		delayed_bits = bitbag_create(flist->count);
 
 	while (1) {
 		cleanup_disable();
 
 		i = read_int(f_in);
 		if (i == -1) {
@@ -414,25 +374,29 @@
 				rprintf(FINFO, "recv_files phase=%d\n", phase);
 			if (phase == 2 && delay_updates)
 				handle_delayed_updates(flist, local_name);
 			send_msg(MSG_DONE, "", 0);
 			if (keep_partial && !partial_dir)
 				make_backups = 0; /* prevents double backup */
+			if (append_mode) {
+				append_mode = 0;
+				sparse_files = 0;
+			}
 			continue;
 		}
 
 		iflags = read_item_attrs(f_in, -1, i, &fnamecmp_type,
 					 xname, &xlen);
 		if (iflags == ITEM_IS_NEW) /* no-op packet */
 			continue;
 
 		file = flist->files[i];
-		fname = local_name ? local_name : f_name_to(file, fbuf);
+		fname = local_name ? local_name : f_name(file, fbuf);
 
 		if (verbose > 2)
-			rprintf(FINFO, "recv_files(%s)\n", safe_fname(fname));
+			rprintf(FINFO, "recv_files(%s)\n", fname);
 
 		if (!(iflags & ITEM_TRANSFER)) {
 			maybe_log_item(file, iflags, itemizing, xname);
 			continue;
 		}
 		if (phase == 2) {
@@ -467,14 +431,15 @@
 			continue;
 		}
 
 		if (read_batch) {
 			next_gen_i = get_next_gen_i(batch_gen_fd, next_gen_i, i);
 			if (i < next_gen_i) {
-				rprintf(FINFO, "(Skipping batched update for \"%s\")\n",
-					safe_fname(fname));
+				rprintf(FINFO,
+					"(Skipping batched update for \"%s\")\n",
+					fname);
 				discard_receive_data(f_in, file->length);
 				continue;
 			}
 			next_gen_i = -1;
 		}
 
@@ -569,22 +534,22 @@
 
 		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
 			close(fd1);
 			fd1 = -1;
 		}
 
-		if (fd1 != -1 && !preserve_perms) {
-			/* if the file exists already and we aren't preserving
-			 * permissions then act as though the remote end sent
-			 * us the file permissions we already have */
-			file->mode = st.st_mode;
+		/* If we're not preserving permissions, change the file-list's
+		 * mode based on the local permissions and some heuristics. */
+		if (!preserve_perms) {
+			int exists = fd1 != -1;
+			file->mode = dest_mode(file->mode, st.st_mode, exists);
 		}
 
 		/* We now check to see if we are writing file "inplace" */
 		if (inplace)  {
-			fd2 = do_open(fname, O_WRONLY|O_CREAT, 0);
+			fd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);
 			if (fd2 == -1) {
 				rsyserr(FERROR, errno, "open %s failed",
 					full_fname(fname));
 				discard_receive_data(f_in, file->length);
 				if (fd1 != -1)
 					close(fd1);
@@ -607,13 +572,13 @@
 			fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
 
 			/* in most cases parent directories will already exist
 			 * because their information should have been previously
 			 * transferred, but that may not be the case with -R */
 			if (fd2 == -1 && relative_paths && errno == ENOENT
-			    && create_directory_path(fnametmp, orig_umask) == 0) {
+			    && create_directory_path(fnametmp) == 0) {
 				/* Get back to name with XXXXXX in it. */
 				get_tmpname(fnametmp, fname);
 				fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
 			}
 			if (fd2 == -1) {
 				rsyserr(FERROR, errno, "mkstemp %s failed",
@@ -621,21 +586,21 @@
 				discard_receive_data(f_in, file->length);
 				if (fd1 != -1)
 					close(fd1);
 				continue;
 			}
 
-			if (partialptr)
+			if (keep_partial)
 				cleanup_set(fnametmp, partialptr, file, fd1, fd2);
 		}
 
 		/* log the transfer */
 		if (log_before_transfer)
 			log_item(file, &initial_stats, iflags, NULL);
 		else if (!am_server && verbose && do_progress)
-			rprintf(FINFO, "%s\n", safe_fname(fname));
+			rprintf(FINFO, "%s\n", fname);
 
 		/* recv file data */
 		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
 				       fname, fd2, file->length);
 
 		if (!log_before_transfer)
@@ -647,23 +612,26 @@
 			rsyserr(FERROR, errno, "close failed on %s",
 				full_fname(fnametmp));
 			exit_cleanup(RERR_FILEIO);
 		}
 
 		if ((recv_ok && (!delay_updates || !partialptr)) || inplace) {
-			finish_transfer(fname, fnametmp, file, recv_ok, 1);
-			if (partialptr != fname && fnamecmp == partialptr) {
+			if (partialptr == fname || *partial_dir == '/')
+				partialptr = NULL;
+			finish_transfer(fname, fnametmp, partialptr,
+					file, recv_ok, 1);
+			if (fnamecmp == partialptr) {
 				do_unlink(partialptr);
 				handle_partial_dir(partialptr, PDIR_DELETE);
 			}
 		} else if (keep_partial && partialptr
 		    && handle_partial_dir(partialptr, PDIR_CREATE)) {
-			finish_transfer(partialptr, fnametmp, file, recv_ok,
-					!partial_dir);
+			finish_transfer(partialptr, fnametmp, NULL,
+					file, recv_ok, !partial_dir);
 			if (delay_updates && recv_ok) {
-				set_delayed_bit(i);
+				bitbag_set_bit(delayed_bits, i);
 				recv_ok = -1;
 			}
 		} else {
 			partialptr = NULL;
 			do_unlink(fnametmp);
 		}
@@ -692,14 +660,13 @@
 				} else {
 					errstr = "WARNING";
 					redostr = " (will try again)";
 				}
 				rprintf(msgtype,
 					"%s: %s failed verification -- update %s%s.\n",
-					errstr, safe_fname(fname),
-					keptstr, redostr);
+					errstr, fname, keptstr, redostr);
 			}
 			if (!phase) {
 				SIVAL(numbuf, 0, i);
 				send_msg(MSG_REDO, numbuf, 4);
 			}
 		}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsync.1	2005-07-29 03:31:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.1	2006-03-12 02:25:07.000000000 +0800
@@ -1,24 +1,26 @@
-.TH "rsync" "1" "28 Jul 2005" "" "" 
+.TH "rsync" "1" "11 Mar 2006" "" "" 
 .SH "NAME" 
 rsync \- faster, flexible replacement for rcp
 .SH "SYNOPSIS" 
 .PP 
+rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. DEST
+.PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST:DEST
 .PP 
-rsync [OPTION]\&.\&.\&. [USER@]HOST:SRC [DEST]
+rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST::DEST
 .PP 
-rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. DEST
+rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. rsync://[USER@]HOST[:PORT]/DEST
 .PP 
-rsync [OPTION]\&.\&.\&. [USER@]HOST::SRC [DEST]
+rsync [OPTION]\&.\&.\&. SRC
 .PP 
-rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST::DEST
+rsync [OPTION]\&.\&.\&. [USER@]HOST:SRC [DEST]
 .PP 
-rsync [OPTION]\&.\&.\&. rsync://[USER@]HOST[:PORT]/SRC [DEST]
+rsync [OPTION]\&.\&.\&. [USER@]HOST::SRC [DEST]
 .PP 
-rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. rsync://[USER@]HOST[:PORT]/DEST
+rsync [OPTION]\&.\&.\&. rsync://[USER@]HOST[:PORT]/SRC [DEST]
 .PP 
 .SH "DESCRIPTION" 
 .PP 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speed up file transfers when the destination file is being
@@ -37,13 +39,13 @@
 exclude and exclude-from options similar to GNU tar
 .IP o 
 a CVS exclude mode for ignoring the same files that CVS would ignore
 .IP o 
 can use any transparent remote shell, including ssh or rsh
 .IP o 
-does not require root privileges
+does not require super-user privileges
 .IP o 
 pipelining of file transfers to minimize latency costs
 .IP o 
 support for anonymous or authenticated rsync daemons (ideal for
 mirroring)
 .PP 
@@ -59,14 +61,14 @@
 a host specification\&.  Contacting an rsync daemon directly happens when the
 source or destination path contains a double colon (::) separator after a
 host specification, OR when an rsync:// URL is specified (see also the
 "USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION" section for
 an exception to this latter rule)\&.
 .PP 
-As a special case, if a remote source is specified without a destination,
-the remote files are listed in an output format similar to "ls -l"\&.
+As a special case, if a single source arg is specified without a
+destination, the files are listed in an output format similar to "ls -l"\&.
 .PP 
 As expected, if neither the source or destination path specify a remote
 host, the copy occurs locally (see also the \fB--list-only\fP option)\&.
 .PP 
 .SH "SETUP" 
 .PP 
@@ -78,15 +80,12 @@
 for its communications, but it may have been configured to use a
 different remote shell by default, such as rsh or remsh\&.
 .PP 
 You can also specify any remote shell you like, either by using the \fB-e\fP
 command line option, or by setting the RSYNC_RSH environment variable\&.
 .PP 
-One common substitute is to use ssh, which offers a high degree of
-security\&.
-.PP 
 Note that rsync must be installed on both the source and destination
 machines\&.
 .PP 
 .SH "USAGE" 
 .PP 
 You use rsync in the same way you use rcp\&. You must specify a source
@@ -147,18 +146,20 @@
 .RE 
 .PP 
 You can also use rsync in local-only mode, where both the source and
 destination don\&'t have a \&':\&' in the name\&. In this case it behaves like
 an improved copy command\&.
 .PP 
+Finally, you can list all the (listable) modules available from a
+particular rsync daemon by leaving off the module name:
+.PP 
 .RS 
 \f(CWrsync somehost\&.mydomain\&.com::\fP
 .RE 
 .PP 
-This would list all the anonymous rsync modules available on the host
-somehost\&.mydomain\&.com\&.  (See the following section for more details\&.)
+See the following section for more details\&.
 .PP 
 .SH "ADVANCED USAGE" 
 .PP 
 The syntax for requesting multiple files from a remote host involves using
 quoted spaces in the SRC\&.  Some examples:
 .PP 
@@ -205,22 +206,24 @@
 that:
 .PP 
 .IP o 
 you either use a double colon :: instead of a single colon to
 separate the hostname from the path, or you use an rsync:// URL\&.
 .IP o 
-the first word after the :: is a module name\&.
+the first word of the "path" is actually a module name\&.
 .IP o 
 the remote daemon may print a message of the day when you
 connect\&.
 .IP o 
 if you specify no path name on the remote daemon then the
 list of accessible paths on the daemon will be shown\&.
 .IP o 
 if you specify no local destination then a listing of the
 specified files on the remote daemon is provided\&.
+.IP o 
+you must not specify the \fB--rsh\fP (\fB-e\fP) option\&.
 .PP 
 An example that copies all the files in a remote module named "src":
 .PP 
 
 .nf 
  
@@ -273,13 +276,14 @@
  
 
 .PP 
 If you need to specify a different remote-shell user, keep in mind that the
 user@ prefix in front of the host is specifying the rsync-user value (for a
 module that requires user-based authentication)\&.  This means that you must
-give the \&'-l user\&' option to ssh when specifying the remote-shell:
+give the \&'-l user\&' option to ssh when specifying the remote-shell, as in
+this example that uses the short version of the \fB--rsh\fP option:
 .PP 
 
 .nf 
  
     rsync -av -e "ssh -l ssh-user" rsync-user@host::module /dest
 .fi 
@@ -350,84 +354,95 @@
  
 
  -v, --verbose               increase verbosity
  -q, --quiet                 suppress non-error messages
  -c, --checksum              skip based on checksum, not mod-time & size
  -a, --archive               archive mode; same as -rlptgoD (no -H)
+     --no-OPTION             turn off an implied OPTION (e\&.g\&. --no-D)
  -r, --recursive             recurse into directories
  -R, --relative              use relative path names
-     --no-relative           turn off --relative
-     --no-implied-dirs       don\&'t send implied dirs with -R
+     --no-implied-dirs       don\&'t send implied dirs with --relative
  -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir=DIR        make backups into hierarchy based in DIR
      --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                skip files that are newer on the receiver
      --inplace               update destination files in-place
+     --append                append data onto shorter files
  -d, --dirs                  transfer directories without recursing
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            transform symlink into referent file/dir
      --copy-unsafe-links     only "unsafe" symlinks are transformed
      --safe-links            ignore symlinks that point outside the tree
- -H, --hard-links            preserve hard links
+ -k, --copy-dirlinks         transform symlink to dir into referent dir
  -K, --keep-dirlinks         treat symlinked dir on receiver as dir
+ -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
- -o, --owner                 preserve owner (root only)
+ -E, --executability         preserve executability
+     --chmod=CHMOD           change destination permissions
+ -o, --owner                 preserve owner (super-user only)
  -g, --group                 preserve group
- -D, --devices               preserve devices (root only)
+     --devices               preserve device files (super-user only)
+     --specials              preserve special files
+ -D                          same as --devices --specials
  -t, --times                 preserve times
  -O, --omit-dir-times        omit directories when preserving times
+     --super                 receiver attempts super-user activities
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy files whole (without rsync algorithm)
-     --no-whole-file         always use incremental rsync algorithm
  -x, --one-file-system       don\&'t cross filesystem boundaries
  -B, --block-size=SIZE       force a fixed checksum block-size
  -e, --rsh=COMMAND           specify the remote shell to use
      --rsync-path=PROGRAM    specify the rsync to run on remote machine
-     --existing              only update files that already exist
+     --existing              ignore non-existing files on receiving side
      --ignore-existing       ignore files that already exist on receiver
      --remove-sent-files     sent files/symlinks are removed from sender
      --del                   an alias for --delete-during
      --delete                delete files that don\&'t exist on sender
      --delete-before         receiver deletes before transfer (default)
      --delete-during         receiver deletes during xfer, not before
      --delete-after          receiver deletes after transfer, not before
      --delete-excluded       also delete excluded files on receiver
      --ignore-errors         delete even if there are I/O errors
      --force                 force deletion of dirs even if not empty
      --max-delete=NUM        don\&'t delete more than NUM files
      --max-size=SIZE         don\&'t transfer any file larger than SIZE
+     --min-size=SIZE         don\&'t transfer any file smaller than SIZE
      --partial               keep partially transferred files
      --partial-dir=DIR       put a partially transferred file into DIR
      --delay-updates         put all updated files into place at end
+ -m, --prune-empty-dirs      prune empty directory chains from file-list
      --numeric-ids           don\&'t map uid/gid values by user/group name
      --timeout=TIME          set I/O timeout in seconds
  -I, --ignore-times          don\&'t skip files that match size and time
      --size-only             skip files that match in size
      --modify-window=NUM     compare mod-times with reduced accuracy
  -T, --temp-dir=DIR          create temporary files in directory DIR
  -y, --fuzzy                 find similar file for basis if no dest file
      --compare-dest=DIR      also compare received files relative to DIR
      --copy-dest=DIR         \&.\&.\&. and include copies of unchanged files
      --link-dest=DIR         hardlink to files in DIR when unchanged
  -z, --compress              compress file data during the transfer
+     --compress-level=NUM    explicitly set compression level
  -C, --cvs-exclude           auto-ignore files in the same way CVS does
  -f, --filter=RULE           add a file-filtering RULE
  -F                          same as --filter=\&'dir-merge /\&.rsync-filter\&'
                              repeated: --filter=\&'- \&.rsync-filter\&'
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     read exclude patterns from FILE
      --include=PATTERN       don\&'t exclude files matching PATTERN
      --include-from=FILE     read include patterns from FILE
      --files-from=FILE       read list of source-file names from FILE
  -0, --from0                 all *from/filter files are delimited by 0s
      --address=ADDRESS       bind address for outgoing socket to daemon
      --port=PORT             specify double-colon alternate port number
+     --sockopts=OPTIONS      specify custom TCP options
      --blocking-io           use blocking I/O for the remote shell
-     --no-blocking-io        turn off blocking I/O when it is default
      --stats                 give some file-transfer stats
+ -8, --8-bit-output          leave high-bit chars unescaped in output
+ -h, --human-readable        output numbers in a human-readable format
      --progress              show progress during transfer
  -P                          same as --partial --progress
  -i, --itemize-changes       output a change-summary for all updates
      --log-format=FORMAT     output filenames using the specified format
      --password-file=FILE    read password from FILE
      --list-only             list the files instead of copying them
@@ -437,13 +452,14 @@
      --read-batch=FILE       read a batched update from FILE
      --protocol=NUM          force an older protocol version to be used
      --checksum-seed=NUM     set block/file checksum seed (advanced)
  -4, --ipv4                  prefer IPv4
  -6, --ipv6                  prefer IPv6
      --version               print version number
- -h, --help                  show this help screen
+(-h) --help                  show this help (see below for -h comment)
+
 .fi 
  
 
 .PP 
 Rsync can also be run as a daemon, in which case the following options are
 accepted: 
@@ -453,31 +469,35 @@
      --daemon                run as an rsync daemon
      --address=ADDRESS       bind to the specified address
      --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
      --config=FILE           specify alternate rsyncd\&.conf file
      --no-detach             do not detach from the parent
      --port=PORT             listen on alternate port number
+     --sockopts=OPTIONS      specify custom TCP options
  -v, --verbose               increase verbosity
  -4, --ipv4                  prefer IPv4
  -6, --ipv6                  prefer IPv6
- -h, --help                  show this help screen
+ -h, --help                  show this help (if used after --daemon)
+
 .fi 
  
 
 .PP 
 .SH "OPTIONS" 
 .PP 
 rsync uses the GNU long options package\&. Many of the command line
 options have two variants, one short and one long\&.  These are shown
 below, separated by commas\&. Some options only have a long variant\&.
 The \&'=\&' for options that take a parameter is optional; whitespace
 can be used instead\&.
 .PP 
-.IP "\fB-h, --help\fP" 
+.IP "\fB--help\fP" 
 Print a short help page describing the options
-available in rsync\&.
+available in rsync and exit\&.  For backward-compatibility with older
+versions of rsync, the help will also be output if you use the \fB-h\fP
+option without any other args\&.
 .IP 
 .IP "\fB--version\fP" 
 print the rsync version number and exit\&.
 .IP 
 .IP "\fB-v, --verbose\fP" 
 This option increases the amount of information you
@@ -523,87 +543,158 @@
 to set this to a larger value in some situations\&.  In particular, when
 transferring to or from an MS Windows FAT filesystem (which represents
 times with a 2-second resolution), \fB--modify-window=1\fP is useful
 (allowing times to differ by up to 1 second)\&.
 .IP 
 .IP "\fB-c, --checksum\fP" 
-This forces the sender to checksum all files using
-a 128-bit MD4 checksum before transfer\&. The checksum is then
-explicitly checked on the receiver and any files of the same name
-which already exist and have the same checksum and size on the
-receiver are not transferred\&.  This option can be quite slow\&.
+This forces the sender to checksum \fIevery\fP
+regular file using a 128-bit MD4 checksum\&.  It does this during the initial
+file-system scan as it builds the list of all available files\&. The receiver
+then checksums its version of each file (if it exists and it has the same
+size as its sender-side counterpart) in order to decide which files need to
+be updated: files with either a changed size or a changed checksum are
+selected for transfer\&.  Since this whole-file checksumming of all files on
+both sides of the connection occurs in addition to the automatic checksum
+verifications that occur during a file\&'s transfer, this option can be quite
+slow\&.
+.IP 
+Note that rsync always verifies that each \fItransferred\fP file was correctly
+reconstructed on the receiving side by checking its whole-file checksum, but
+that automatic after-the-transfer verification has nothing to do with this
+option\&'s before-the-transfer "Does this file need to be updated?" check\&.
 .IP 
 .IP "\fB-a, --archive\fP" 
 This is equivalent to \fB-rlptgoD\fP\&. It is a quick
 way of saying you want recursion and want to preserve almost
-everything\&.  The only exception to this is if \fB--files-from\fP was
+everything (with -H being a notable omission)\&.
+The only exception to the above equivalence is when \fB--files-from\fP is
 specified, in which case \fB-r\fP is not implied\&.
 .IP 
 Note that \fB-a\fP \fBdoes not preserve hardlinks\fP, because
 finding multiply-linked files is expensive\&.  You must separately
 specify \fB-H\fP\&.
 .IP 
+.IP "--no-OPTION" 
+You may turn off one or more implied options by prefixing
+the option name with "no-"\&.  Not all options may be prefixed with a "no-":
+only options that are implied by other options (e\&.g\&. \fB--no-D\fP,
+\fB--no-perms\fP) or have different defaults in various circumstances
+(e\&.g\&. \fB--no-whole-file\fP, \fB--no-blocking-io\fP, \fB--no-dirs\fP)\&.  You may
+specify either the short or the long option name after the "no-" prefix
+(e\&.g\&. \fB--no-R\fP is the same as \fB--no-relative\fP)\&.
+.IP 
+For example: if you want to use \fB-a\fP (\fB--archive\fP) but don\&'t want
+\fB-o\fP (\fB--owner\fP), instead of converting \fB-a\fP into \fB-rlptgD\fP, you
+could specify \fB-a --no-o\fP (or \fB-a --no-owner\fP)\&.
+.IP 
+The order of the options is important:  if you specify \fB--no-r -a\fP, the
+\fB-r\fP option would end up being turned on, the opposite of \fB-a --no-r\fP\&.
+Note also that the side-effects of the \fB--files-from\fP option are NOT
+positional, as it affects the default state of several options and slightly
+changes the meaning of \fB-a\fP (see the \fB--files-from\fP option for more
+details)\&.
+.IP 
 .IP "\fB-r, --recursive\fP" 
 This tells rsync to copy directories
 recursively\&.  See also \fB--dirs\fP (\fB-d\fP)\&.
 .IP 
 .IP "\fB-R, --relative\fP" 
 Use relative paths\&. This means that the full path
 names specified on the command line are sent to the server rather than
 just the last parts of the filenames\&. This is particularly useful when
 you want to send several different directories at the same time\&. For
-example, if you used the command
+example, if you used this command:
 .IP 
 .RS 
-\f(CW   rsync /foo/bar/foo\&.c remote:/tmp/\fP
+\f(CW   rsync -av /foo/bar/baz\&.c remote:/tmp/\fP
 .RE 
 .IP 
-then this would create a file called foo\&.c in /tmp/ on the remote
+\&.\&.\&. this would create a file named baz\&.c in /tmp/ on the remote
 machine\&. If instead you used
 .IP 
 .RS 
-\f(CW   rsync -R /foo/bar/foo\&.c remote:/tmp/\fP
+\f(CW   rsync -avR /foo/bar/baz\&.c remote:/tmp/\fP
 .RE 
 .IP 
-then a file called /tmp/foo/bar/foo\&.c would be created on the remote
+then a file named /tmp/foo/bar/baz\&.c would be created on the remote
 machine -- the full path name is preserved\&.  To limit the amount of
-path information that is sent, do something like this:
+path information that is sent, you have a couple options:  (1) With
+a modern rsync on the sending side (beginning with 2\&.6\&.7), you can
+insert a dot and a slash into the source path, like this:
 .IP 
 .RS 
-\f(CW   cd /foo\fP
-.br 
-\f(CW   rsync -R bar/foo\&.c remote:/tmp/\fP
-.br 
+\f(CW   rsync -avR /foo/\&./bar/baz\&.c remote:/tmp/\fP
+.RE 
+.IP 
+That would create /tmp/bar/baz\&.c on the remote machine\&.  (Note that the
+dot must be followed by a slash, so "/foo/\&." would not be abbreviated\&.)
+(2) For older rsync versions, you would need to use a chdir to limit the
+source path\&.  For example, when pushing files:
+.IP 
+.RS 
+\f(CW   (cd /foo; rsync -avR bar/baz\&.c remote:/tmp/) \fP
 .RE 
 .IP 
-That would create /tmp/bar/foo\&.c on the remote machine\&.
+(Note that the parens put the two commands into a sub-shell, so that the
+"cd" command doesn\&'t remain in effect for future commands\&.)
+If you\&'re pulling files, use this idiom (which doesn\&'t work with an
+rsync daemon):
 .IP 
-.IP "\fB--no-relative\fP" 
-Turn off the \fB--relative\fP option\&.  This is only
-needed if you want to use \fB--files-from\fP without its implied \fB--relative\fP
-file processing\&.
+.RS 
+\f(CW   rsync -avR --rsync-path="cd /foo; rsync" \e \fP
+.br 
+\f(CW       remote:bar/baz\&.c /tmp/\fP
+.RE 
 .IP 
 .IP "\fB--no-implied-dirs\fP" 
-When combined with the \fB--relative\fP option, the
-implied directories in each path are not explicitly duplicated as part
-of the transfer\&.  This makes the transfer more optimal and also allows
-the two sides to have non-matching symlinks in the implied part of the
-path\&.  For instance, if you transfer the file "/path/foo/file" with \fB-R\fP,
-the default is for rsync to ensure that "/path" and "/path/foo" on the
-destination exactly match the directories/symlinks of the source\&.  Using
-the \fB--no-implied-dirs\fP option would omit both of these implied dirs,
-which means that if "/path" was a real directory on one machine and a
-symlink of the other machine, rsync would not try to change this\&.
+This option affects the default behavior of the
+\fB--relative\fP option\&.  When it is specified, the attributes of the implied
+directories from the source names are not included in the transfer\&.  This
+means that the corresponding path elements on the destination system are
+left unchanged if they exist, and any missing implied directories are
+created with default attributes\&.  This even allows these implied path
+elements to have big differences, such as being a symlink to a directory on
+one side of the transfer, and a real directory on the other side\&.
+.IP 
+For instance, if a command-line arg or a files-from entry told rsync to
+transfer the file "path/foo/file", the directories "path" and "path/foo"
+are implied when \fB--relative\fP is used\&.  If "path/foo" is a symlink to
+"bar" on the destination system, the receiving rsync would ordinarily
+delete "path/foo", recreate it as a directory, and receive the file into
+the new directory\&.  With \fB--no-implied-dirs\fP, the receiving rsync updates
+"path/foo/file" using the existing path elements, which means that the file
+ends up being created in "path/bar"\&.  Another way to accomplish this link
+preservation is to use the \fB--keep-dirlinks\fP option (which will also
+affect symlinks to directories in the rest of the transfer)\&.
+.IP 
+In a similar but opposite scenario, if the transfer of "path/foo/file" is
+requested and "path/foo" is a symlink on the sending side, running without
+\fB--no-implied-dirs\fP would cause rsync to transform "path/foo" on the
+receiving side into an identical symlink, and then attempt to transfer
+"path/foo/file", which might fail if the duplicated symlink did not point
+to a directory on the receiving side\&.  Another way to avoid this sending of
+a symlink as an implied directory is to use \fB--copy-unsafe-links\fP, or
+\fB--copy-dirlinks\fP (both of which also affect symlinks in the rest of the
+transfer -- see their descriptions for full details)\&.
 .IP 
 .IP "\fB-b, --backup\fP" 
 With this option, preexisting destination files are
 renamed as each file is transferred or deleted\&.  You can control where the
 backup file goes and what (if any) suffix gets appended using the
 \fB--backup-dir\fP and \fB--suffix\fP options\&.
-Note that if you don\&'t specify \fB--backup-dir\fP, the \fB--omit-dir-times\fP
-option will be enabled\&.
+.IP 
+Note that if you don\&'t specify \fB--backup-dir\fP, (1) the
+\fB--omit-dir-times\fP option will be implied, and (2) if \fB--delete\fP is
+also in effect (without \fB--delete-excluded\fP), rsync will add a "protect"
+filter-rule for the backup suffix to the end of all your existing excludes
+(e\&.g\&. -f "P *~")\&.  This will prevent previously backed-up files from being
+deleted\&.  Note that if you are supplying your own filter rules, you may
+need to manually insert your own exclude/protect rule somewhere higher up
+in the list so that it has a high enough priority to be effective (e\&.g\&., if
+your rules specify a trailing inclusion/exclusion of \&'*\&', the auto-added
+rule would never be reached)\&.
 .IP 
 .IP "\fB--backup-dir=DIR\fP" 
 In combination with the \fB--backup\fP option, this
 tells rsync to store all backups in the specified directory\&. This is
 very useful for incremental backups\&.  You can additionally
 specify a backup suffix using the \fB--suffix\fP option
@@ -650,102 +741,223 @@
 WARNING: The file\&'s data will be in an inconsistent state during the
 transfer (and possibly afterward if the transfer gets interrupted), so you
 should not use this option to update files that are in use\&.  Also note that
 rsync will be unable to update a file in-place that is not writable by the
 receiving user\&.
 .IP 
+.IP "\fB--append\fP" 
+This causes rsync to update a file by appending data onto
+the end of the file, which presumes that the data that already exists on
+the receiving side is identical with the start of the file on the sending
+side\&.  If that is not true, the file will fail the checksum test, and the
+resend will do a normal \fB--inplace\fP update to correct the mismatched data\&.
+Only files on the receiving side that are shorter than the corresponding
+file on the sending side (as well as new files) are sent\&.
+Implies \fB--inplace\fP, but does not conflict with \fB--sparse\fP (though the
+\fB--sparse\fP option will be auto-disabled if a resend of the already-existing
+data is required)\&.
+.IP 
 .IP "\fB-d, --dirs\fP" 
 Tell the sending side to include any directories that
 are encountered\&.  Unlike \fB--recursive\fP, a directory\&'s contents are not copied
-unless the directory was specified on the command-line as either "\&." or a
-name with a trailing slash (e\&.g\&. "foo/")\&.  Without this option or the
+unless the directory name specified is "\&." or ends with a trailing slash
+(e\&.g\&. "\&.", "dir/\&.", "dir/", etc\&.)\&.  Without this option or the
 \fB--recursive\fP option, rsync will skip all directories it encounters (and
-output a message to that effect for each one)\&.
+output a message to that effect for each one)\&.  If you specify both
+\fB--dirs\fP and \fB--recursive\fP, \fB--recursive\fP takes precedence\&.
 .IP 
 .IP "\fB-l, --links\fP" 
 When symlinks are encountered, recreate the
 symlink on the destination\&.
 .IP 
 .IP "\fB-L, --copy-links\fP" 
-When symlinks are encountered, the file that
+When symlinks are encountered, the item that
 they point to (the referent) is copied, rather than the symlink\&.  In older
 versions of rsync, this option also had the side-effect of telling the
 receiving side to follow symlinks, such as symlinks to directories\&.  In a
 modern rsync such as this one, you\&'ll need to specify \fB--keep-dirlinks\fP (\fB-K\fP)
 to get this extra behavior\&.  The only exception is when sending files to
 an rsync that is too old to understand \fB-K\fP -- in that case, the \fB-L\fP option
 will still have the side-effect of \fB-K\fP on that older receiving rsync\&.
 .IP 
 .IP "\fB--copy-unsafe-links\fP" 
 This tells rsync to copy the referent of
 symbolic links that point outside the copied tree\&.  Absolute symlinks
 are also treated like ordinary files, and so are any symlinks in the
-source path itself when \fB--relative\fP is used\&.
+source path itself when \fB--relative\fP is used\&.  This option has no
+additional effect if \fB--copy-links\fP was also specified\&.
 .IP 
 .IP "\fB--safe-links\fP" 
 This tells rsync to ignore any symbolic links
 which point outside the copied tree\&. All absolute symlinks are
 also ignored\&. Using this option in conjunction with \fB--relative\fP may
 give unexpected results\&.
 .IP 
+.IP "\fB-K, --copy-dirlinks\fP" 
+This option causes the sending side to treat
+a symlink to a directory as though it were a real directory\&.  This is
+useful if you don\&'t want symlinks to non-directories to be affected, as
+they would be using \fB--copy-links\fP\&.
+.IP 
+Without this option, if the sending side has replaced a directory with a
+symlink to a directory, the receiving side will delete anything that is in
+the way of the new symlink, including a directory hierarchy (as long as
+\fB--force\fP or \fB--delete\fP is in effect)\&.
+.IP 
+See also \fB--keep-dirlinks\fP for an analogous option for the receiving
+side\&.
+.IP 
+.IP "\fB-K, --keep-dirlinks\fP" 
+This option causes the receiving side to treat
+a symlink to a directory as though it were a real directory, but only if it
+matches a real directory from the sender\&.  Without this option, the
+receiver\&'s symlink would be deleted and replaced with a real directory\&.
+.IP 
+For example, suppose you transfer a directory "foo" that contains a file
+"file", but "foo" is a symlink to directory "bar" on the receiver\&.  Without
+\fB--keep-dirlinks\fP, the receiver deletes symlink "foo", recreates it as a
+directory, and receives the file into the new directory\&.  With
+\fB--keep-dirlinks\fP, the receiver keeps the symlink and "file" ends up in
+"bar"\&.
+.IP 
+See also \fB--copy-dirlinks\fP for an analogous option for the sending side\&.
+.IP 
 .IP "\fB-H, --hard-links\fP" 
-This tells rsync to recreate hard  links  on
-the  remote system  to  be the same as the local system\&. Without this
-option hard links are treated like regular files\&.
+This tells rsync to look for hard-linked files in
+the transfer and link together the corresponding files on the receiving
+side\&.  Without this option, hard-linked files in the transfer are treated
+as though they were separate files\&.
 .IP 
 Note that rsync can only detect hard links if both parts of the link
 are in the list of files being sent\&.
 .IP 
-This option can be quite slow, so only use it if you need it\&.
+.IP "\fB-p, --perms\fP" 
+This option causes the receiving rsync to set the
+destination permissions to be the same as the source permissions\&.  (See
+also the \fB--chmod\fP option for a way to modify what rsync considers to
+be the source permissions\&.)
 .IP 
-.IP "\fB-K, --keep-dirlinks\fP" 
-On the receiving side, if a symlink is
-pointing to a directory, it will be treated as matching a directory
-from the sender\&.
+When this option is \fIoff\fP, permissions are set as follows:
 .IP 
-.IP "\fB-W, --whole-file\fP" 
-With this option the incremental rsync algorithm
-is not used and the whole file is sent as-is instead\&.  The transfer may be
-faster if this option is used when the bandwidth between the source and
-destination machines is higher than the bandwidth to disk (especially when the
-"disk" is actually a networked filesystem)\&.  This is the default when both
-the source and destination are specified as local paths\&.
+.RS 
+.IP o 
+Existing files (including updated files) retain their existing
+permissions, though the \fB--executability\fP option might change just
+the execute permission for the file\&.
+.IP o 
+New files get their "normal" permission bits set to the source
+file\&'s permissions masked with the receiving end\&'s umask setting, and
+their special permission bits disabled except in the case where a new
+directory inherits a setgid bit from its parent directory\&.
+.RE 
 .IP 
-.IP "\fB--no-whole-file\fP" 
-Turn off \fB--whole-file\fP, for use when it is the
-default\&.
+Thus, when \fB--perms\fP and \fB--executability\fP are both disabled,
+rsync\&'s behavior is the same as that of other file-copy utilities,
+such as \fBcp\fP(1) and \fBtar\fP(1)\&.
 .IP 
-.IP "\fB-p, --perms\fP" 
-This option causes rsync to set the destination
-permissions to be the same as the source permissions\&.
+In summary: to give destination files (both old and new) the source
+permissions, use \fB--perms\fP\&.  To give new files the destination-default
+permissions (while leaving existing files unchanged), make sure that the
+\fB--perms\fP option is off and use \fB--chmod=ugo=rwX\fP (which ensures that
+all non-masked bits get enabled)\&.  If you\&'d care to make this latter
+behavior easier to type, you could define a popt alias for it, such as
+putting this line in the file ~/\&.popt (this defines the \fB-s\fP option,
+and includes --no-g to use the default group of the destination dir):
+.IP 
+.RS 
+\f(CW   rsync alias -s --no-p --no-g --chmod=ugo=rwX\fP
+.RE 
+.IP 
+You could then use this new option in a command such as this one:
+.IP 
+.RS 
+\f(CW   rsync -asv src/ dest/\fP
+.RE 
+.IP 
+(Caveat: make sure that \fB-a\fP does not follow \fB-s\fP, or it will re-enable
+the "--no-*" options\&.)
+.IP 
+The preservation of the destination\&'s setgid bit on newly-created
+directories when \fB--perms\fP is off was added in rsync 2\&.6\&.7\&.  Older rsync
+versions erroneously preserved the three special permission bits for
+newly-created files when \fB--perms\fP was off, while overriding the
+destination\&'s setgid bit setting on a newly-created directory\&.  (Keep in
+mind that it is the version of the receiving rsync that affects this
+behavior\&.)
+.IP 
+.IP "\fB-E, --executability\fP" 
+This option causes rsync to preserve the
+executability (or non-executability) of regular files when \fB--perms\fP is
+not enabled\&.  A regular file is considered to be executable if at least one
+\&'x\&' is turned on in its permissions\&.  When an existing destination file\&'s
+executability differs from that of the corresponding source file, rsync
+modifies the destination file\&'s permissions as follows:
 .IP 
-Without this option, all existing files (including updated files) retain
-their existing permissions, while each new file gets its permissions set
-based on the source file\&'s permissions, but masked by the receiving end\&'s
-umask setting
-(which is the same behavior as other file-copy utilities, such as cp)\&.
+.RS 
+.IP o 
+To make a file non-executable, rsync turns off all its \&'x\&'
+permissions\&.
+.IP o 
+To make a file executable, rsync turns on each \&'x\&' permission that
+has a corresponding \&'r\&' permission enabled\&.
+.RE 
+.IP 
+If \fB--perms\fP is enabled, this option is ignored\&.
+.IP 
+.IP "\fB--chmod\fP" 
+This option tells rsync to apply one or more
+comma-separated "chmod" strings to the permission of the files in the
+transfer\&.  The resulting value is treated as though it was the permissions
+that the sending side supplied for the file, which means that this option
+can seem to have no effect on existing files if \fB--perms\fP is not enabled\&.
+.IP 
+In addition to the normal parsing rules specified in the \fBchmod\fP(1)
+manpage, you can specify an item that should only apply to a directory by
+prefixing it with a \&'D\&', or specify an item that should only apply to a
+file by prefixing it with a \&'F\&'\&.  For example:
+.IP 
+.RS 
+--chmod=Dg+s,ug+w,Fo-w,+X
+.RE 
+.IP 
+It is also legal to specify multiple \fB--chmod\fP options, as each
+additional option is just appended to the list of changes to make\&.
+.IP 
+See the \fB--perms\fP and \fB--executability\fP options for how the resulting
+permission value can be applied to the files in the transfer\&.
 .IP 
 .IP "\fB-o, --owner\fP" 
 This option causes rsync to set the owner of the
-destination file to be the same as the source file\&.  On most systems,
-only the super-user can set file ownership\&.  By default, the preservation
-is done by name, but may fall back to using the ID number in some
-circumstances\&.  See the \fB--numeric-ids\fP option for a full discussion\&.
+destination file to be the same as the source file\&.  By default, the
+preservation is done by name, but may fall back to using the ID number
+in some circumstances (see the \fB--numeric-ids\fP option for a full
+discussion)\&.
+This option has no effect if the receiving rsync is not run as the
+super-user and \fB--super\fP is not specified\&.
 .IP 
 .IP "\fB-g, --group\fP" 
 This option causes rsync to set the group of the
 destination file to be the same as the source file\&.  If the receiving
-program is not running as the super-user, only groups that the
+program is not running as the super-user (or with the \fB--no-super\fP
+option), only groups that the
 receiver is a member of will be preserved\&.  By default, the preservation
 is done by name, but may fall back to using the ID number in some
 circumstances\&.  See the \fB--numeric-ids\fP option for a full discussion\&.
 .IP 
-.IP "\fB-D, --devices\fP" 
+.IP "\fB--devices\fP" 
 This option causes rsync to transfer character and
-block device information to the remote system to recreate these
-devices\&. This option is only available to the super-user\&.
+block device files to the remote system to recreate these devices\&.
+This option has no effect if the receiving rsync is not run as the
+super-user and \fB--super\fP is not specified\&.
+.IP 
+.IP "\fB--specials\fP" 
+This option causes rsync to transfer special files
+such as named sockets and fifos\&.
+.IP 
+.IP "\fB-D\fP" 
+The \fB-D\fP option is equivalent to \fB--devices\fP \fB--specials\fP\&.
 .IP 
 .IP "\fB-t, --times\fP" 
 This tells rsync to transfer modification times along
 with the files and update them on the remote system\&.  Note that if this
 option is not used, the optimization that excludes files that have not been
 modified cannot be effective; in other words, a missing \fB-t\fP or \fB-a\fP will
@@ -756,36 +968,72 @@
 .IP "\fB-O, --omit-dir-times\fP" 
 This tells rsync to omit directories when
 it is preserving modification times (see \fB--times\fP)\&.  If NFS is sharing
 the directories on the receiving side, it is a good idea to use \fB-O\fP\&.
 This option is inferred if you use \fB--backup\fP without \fB--backup-dir\fP\&.
 .IP 
-.IP "\fB-n, --dry-run\fP" 
-This tells rsync to not do any file transfers,
-instead it will just report the actions it would have taken\&.
+.IP "\fB--super\fP" 
+This tells the receiving side to attempt super-user
+activities even if the receiving rsync wasn\&'t run by the super-user\&.  These
+activities include: preserving users via the \fB--owner\fP option, preserving
+all groups (not just the current user\&'s groups) via the \fB--groups\fP
+option, and copying devices via the \fB--devices\fP option\&.  This is useful
+for systems that allow such activities without being the super-user, and
+also for ensuring that you will get errors if the receiving side isn\&'t
+being running as the super-user\&.  To turn off super-user activities, the
+super-user can use \fB--no-super\fP\&.
 .IP 
 .IP "\fB-S, --sparse\fP" 
 Try to handle sparse files efficiently so they take
-up less space on the destination\&.
+up less space on the destination\&.  Conflicts with \fB--inplace\fP because it\&'s
+not possible to overwrite data in a sparse fashion\&.
 .IP 
 NOTE: Don\&'t use this option when the destination is a Solaris "tmpfs"
 filesystem\&. It doesn\&'t seem to handle seeks over null regions
 correctly and ends up corrupting the files\&.
 .IP 
+.IP "\fB-n, --dry-run\fP" 
+This tells rsync to not do any file transfers,
+instead it will just report the actions it would have taken\&.
+.IP 
+.IP "\fB-W, --whole-file\fP" 
+With this option the incremental rsync algorithm
+is not used and the whole file is sent as-is instead\&.  The transfer may be
+faster if this option is used when the bandwidth between the source and
+destination machines is higher than the bandwidth to disk (especially when the
+"disk" is actually a networked filesystem)\&.  This is the default when both
+the source and destination are specified as local paths\&.
+.IP 
 .IP "\fB-x, --one-file-system\fP" 
-This tells rsync not to cross filesystem
-boundaries  when recursing\&.  This  is useful for transferring the
-contents of only one filesystem\&.
-.IP 
-.IP "\fB--existing\fP" 
-This tells rsync not to create any new files --
-only update files that already exist on the destination\&.
+This tells rsync to avoid crossing a
+filesystem boundary when recursing\&.  This does not limit the user\&'s ability
+to specify items to copy from multiple filesystems, just rsync\&'s recursion
+through the hierarchy of each directory that the user specified, and also
+the analogous recursion on the receiving side during deletion\&.  Also keep
+in mind that rsync treats a "bind" mount to the same device as being on the
+same filesystem\&.
+.IP 
+If this option is repeated, rsync omits all mount-point directories from
+the copy\&.  Otherwise, it includes an empty directory at each mount-point it
+encounters (using the attributes of the mounted directory because those of
+the underlying mount-point directory are inaccessible)\&.
+.IP 
+If rsync has been told to collapse symlinks (via \fB--copy-links\fP or
+\fB--copy-unsafe-links\fP), a symlink to a directory on another device is
+treated like a mount-point\&.  Symlinks to non-directories are unaffected
+by this option\&.
+.IP 
+.IP "\fB--existing, --ignore-non-existing\fP" 
+This tells rsync to skip
+updating files that do not exist yet on the destination\&.  If this option is
+combined with the \fB--ignore-existing\fP option, no files will be updated
+(which can be useful if all you want to do is to delete missing files)\&.
 .IP 
 .IP "\fB--ignore-existing\fP" 
-This tells rsync not to update files that already exist on
-the destination\&.
+This tells rsync to skip updating files that
+already exist on the destination\&.  See also \fB--ignore-non-existing\fP\&.
 .IP 
 .IP "\fB--remove-sent-files\fP" 
 This tells rsync to remove from the sending
 side the files and/or symlinks that are newly created or whose content is
 updated on the receiving side\&.  Directories and devices are not removed,
 nor are files/symlinks whose attributes are merely changed\&.
@@ -799,13 +1047,15 @@
 by the shell and rsync thus gets a request to transfer individual files, not
 the files\&' parent directory\&.  Files that are excluded from transfer are
 also excluded from being deleted unless you use the \fB--delete-excluded\fP
 option or mark the rules as only matching on the sending side (see the
 include/exclude modifiers in the FILTER RULES section)\&.
 .IP 
-This option has no effect unless directory recursion is enabled\&.
+Prior to rsync 2\&.6\&.7, this option would have no effect unless \fB--recursive\fP
+was in effect\&.  Beginning with 2\&.6\&.7, deletions will also occur when \fB--dirs\fP
+(\fB-d\fP) is in effect, but only for directories whose contents are being copied\&.
 .IP 
 This option can be dangerous if used incorrectly!  It is a very good idea
 to run first using the \fB--dry-run\fP option (\fB-n\fP) to see what files would be
 deleted to make sure important files aren\&'t listed\&.
 .IP 
 If the sending side detects any I/O errors, then the deletion of any
@@ -858,28 +1108,48 @@
 .IP 
 .IP "\fB--ignore-errors\fP" 
 Tells \fB--delete\fP to go ahead and delete files
 even when there are I/O errors\&.
 .IP 
 .IP "\fB--force\fP" 
-This options tells rsync to delete directories even if
-they are not empty when they are to be replaced by non-directories\&.  This
-is only relevant without \fB--delete\fP because deletions are now done depth-first\&.
-Requires the \fB--recursive\fP option (which is implied by \fB-a\fP) to have any effect\&.
+This option tells rsync to delete a non-empty directory
+when it is to be replaced by a non-directory\&.  This is only relevant if
+deletions are not active (see \fB--delete\fP for details)\&.
+.IP 
+Note for older rsync versions: \fB--force\fP used to still be required when
+using \fB--delete-after\fP, and it used to be non-functional unless the
+\fB--recursive\fP option was also enabled\&.
 .IP 
 .IP "\fB--max-delete=NUM\fP" 
 This tells rsync not to delete more than NUM
 files or directories (NUM must be non-zero)\&.
 This is useful when mirroring very large trees to prevent disasters\&.
 .IP 
 .IP "\fB--max-size=SIZE\fP" 
 This tells rsync to avoid transferring any
 file that is larger than the specified SIZE\&. The SIZE value can be
-suffixed with a letter to indicate a size multiplier (K, M, or G) and
+suffixed with a string to indicate a size multiplier, and
 may be a fractional value (e\&.g\&. "\fB--max-size=1\&.5m\fP")\&.
 .IP 
+The suffixes are as follows: "K" (or "KiB") is a kibibyte (1024),
+"M" (or "MiB") is a mebibyte (1024*1024), and "G" (or "GiB") is a
+gibibyte (1024*1024*1024)\&.
+If you want the multiplier to be 1000 instead of 1024, use "KB",
+"MB", or "GB"\&.  (Note: lower-case is also accepted for all values\&.)
+Finally, if the suffix ends in either "+1" or "-1", the value will
+be offset by one byte in the indicated direction\&.
+.IP 
+Examples: --max-size=1\&.5mb-1 is 1499999 bytes, and --max-size=2g+1 is
+2147483649 bytes\&.
+.IP 
+.IP "\fB--min-size=SIZE\fP" 
+This tells rsync to avoid transferring any
+file that is smaller than the specified SIZE, which can help in not
+transferring small, junk files\&.
+See the \fB--max-size\fP option for a description of SIZE\&.
+.IP 
 .IP "\fB-B, --block-size=BLOCKSIZE\fP" 
 This forces the block size used in
 the rsync algorithm to a fixed value\&.  It is normally selected based on
 the size of each file being updated\&.  See the technical report for details\&.
 .IP 
 .IP "\fB-e, --rsh=COMMAND\fP" 
@@ -893,16 +1163,25 @@
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
 running rsync daemon on the remote host\&.  See the section "USING
 RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION" above\&.
 .IP 
 Command-line arguments are permitted in COMMAND provided that COMMAND is
-presented to rsync as a single argument\&.  For example:
+presented to rsync as a single argument\&.  You must use spaces (not tabs
+or other whitespace) to separate the command and args from each other,
+and you can use single- and/or double-quotes to preserve spaces in an
+argument (but not backslashes)\&.  Note that doubling a single-quote
+inside a single-quoted string gives you a single-quote; likewise for
+double-quotes (though you need to pay attention to which quotes your
+shell is parsing and which quotes rsync is parsing)\&.  Some examples:
 .IP 
 .RS 
-\f(CW   -e "ssh -p 2234"\fP
+\f(CW    -e \&'ssh -p 2234\&'\fP
+.br 
+\f(CW    -e \&'ssh -o "ProxyCommand nohup ssh firewall nc -w1 %h %p"\&'\fP
+.br 
 .RE 
 .IP 
 (Note that ssh users can alternately customize site-specific connect
 options in their \&.ssh/config file\&.)
 .IP 
 You can also choose the remote shell program using the RSYNC_RSH
@@ -975,22 +1254,22 @@
 .IP 
 .IP "\fB-F\fP" 
 The \fB-F\fP option is a shorthand for adding two \fB--filter\fP rules to
 your command\&.  The first time it is used is a shorthand for this rule:
 .IP 
 .RS 
-\f(CW   --filter=\&': /\&.rsync-filter\&'\fP
+\f(CW   --filter=\&'dir-merge /\&.rsync-filter\&'\fP
 .RE 
 .IP 
 This tells rsync to look for per-directory \&.rsync-filter files that have
 been sprinkled through the hierarchy and use their rules to filter the
 files in the transfer\&.  If \fB-F\fP is repeated, it is a shorthand for this
 rule:
 .IP 
 .RS 
-\f(CW   --filter=\&'- \&.rsync-filter\&'\fP
+\f(CW   --filter=\&'exclude \&.rsync-filter\&'\fP
 .RE 
 .IP 
 This filters out the \&.rsync-filter files themselves from the transfer\&.
 .IP 
 See the FILTER RULES section for detailed information on how these options
 work\&.
@@ -1000,48 +1279,53 @@
 \fB--filter\fP option that defaults to an exclude rule and does not allow
 the full rule-parsing syntax of normal filter rules\&.
 .IP 
 See the FILTER RULES section for detailed information on this option\&.
 .IP 
 .IP "\fB--exclude-from=FILE\fP" 
-This option is similar to the \fB--exclude\fP
-option, but instead it adds all exclude patterns listed in the file
-FILE to the exclude list\&.  Blank lines in FILE and lines starting with
-\&';\&' or \&'#\&' are ignored\&.
-If \fIFILE\fP is \fB-\fP the list will be read from standard input\&.
+This option is related to the \fB--exclude\fP
+option, but it specifies a FILE that contains exclude patterns (one per line)\&.
+Blank lines in the file and lines starting with \&';\&' or \&'#\&' are ignored\&.
+If \fIFILE\fP is \fB-\fP, the list will be read from standard input\&.
 .IP 
 .IP "\fB--include=PATTERN\fP" 
 This option is a simplified form of the
 \fB--filter\fP option that defaults to an include rule and does not allow
 the full rule-parsing syntax of normal filter rules\&.
 .IP 
 See the FILTER RULES section for detailed information on this option\&.
 .IP 
 .IP "\fB--include-from=FILE\fP" 
-This specifies a list of include patterns
-from a file\&.
-If \fIFILE\fP is "-" the list will be read from standard input\&.
+This option is related to the \fB--include\fP
+option, but it specifies a FILE that contains include patterns (one per line)\&.
+Blank lines in the file and lines starting with \&';\&' or \&'#\&' are ignored\&.
+If \fIFILE\fP is \fB-\fP, the list will be read from standard input\&.
 .IP 
 .IP "\fB--files-from=FILE\fP" 
 Using this option allows you to specify the
-exact list of files to transfer (as read from the specified FILE or "-"
+exact list of files to transfer (as read from the specified FILE or \fB-\fP
 for standard input)\&.  It also tweaks the default behavior of rsync to make
 transferring just the specified files and directories easier:
 .IP 
 .RS 
 .IP o 
 The \fB--relative\fP (\fB-R\fP) option is implied, which preserves the path
 information that is specified for each item in the file (use
-\fB--no-relative\fP if you want to turn that off)\&.
+\fB--no-relative\fP or \fB--no-R\fP if you want to turn that off)\&.
 .IP o 
 The \fB--dirs\fP (\fB-d\fP) option is implied, which will create directories
 specified in the list on the destination rather than noisily skipping
-them\&.
+them (use \fB--no-dirs\fP or \fB--no-d\fP if you want to turn that off)\&.
 .IP o 
 The \fB--archive\fP (\fB-a\fP) option\&'s behavior does not imply \fB--recursive\fP
 (\fB-r\fP), so specify it explicitly, if you want it\&.
+.IP o 
+These side-effects change the default state of rsync, so the position
+of the \fB--files-from\fP option on the command-line has no bearing on how
+other options are parsed (e\&.g\&. \fB-a\fP works the same before or after
+\fB--files-from\fP, as does \fB--no-R\fP and all other options)\&.
 .RE 
 .IP 
 The file names that are read from the FILE are all relative to the
 source dir -- any leading slashes are removed and no "\&.\&." references are
 allowed to go higher than the source dir\&.  For example, take this
 command:
@@ -1083,15 +1367,42 @@
 merged files specified in a \fB--filter\fP rule\&.
 It does not affect \fB--cvs-exclude\fP (since all names read from a \&.cvsignore
 file are split on whitespace)\&.
 .IP 
 .IP "\fB-T, --temp-dir=DIR\fP" 
 This option instructs rsync to use DIR as a
-scratch directory when creating temporary copies of the files
-transferred on the receiving side\&.  The default behavior is to create
-the temporary files in the receiving directory\&.
+scratch directory when creating temporary copies of the files transferred
+on the receiving side\&.  The default behavior is to create each temporary
+file in the same directory as the associated destination file\&.
+.IP 
+This option is most often used when the receiving disk partition does not
+have enough free space to hold a copy of the largest file in the transfer\&.
+In this case (i\&.e\&. when the scratch directory in on a different disk
+partition), rsync will not be able to rename each received temporary file
+over the top of the associated destination file, but instead must copy it
+into place\&.  Rsync does this by copying the file over the top of the
+destination file, which means that the destination file will contain
+truncated data during this copy\&.  If this were not done this way (even if
+the destination file were first removed, the data locally copied to a
+temporary file in the destination directory, and then renamed into place)
+it would be possible for the old file to continue taking up disk space (if
+someone had it open), and thus there might not be enough room to fit the
+new version on the disk at the same time\&.
+.IP 
+If you are using this option for reasons other than a shortage of disk
+space, you may wish to combine it with the \fB--delay-updates\fP option,
+which will ensure that all copied files get put into subdirectories in the
+destination hierarchy, awaiting the end of the transfer\&.  If you don\&'t
+have enough room to duplicate all the arriving files on the destination
+partition, another way to tell rsync that you aren\&'t overly concerned
+about disk space is to use the \fB--partial-dir\fP option with a relative
+path; because this tells rsync that it is OK to stash off a copy of a
+single file in a subdir in the destination hierarchy, rsync will use the
+partial-dir as a staging area to bring over the copied file, and then
+rename it into place from there\&. (Specifying a \fB--partial-dir\fP with
+an absolute path does not have this side-effect\&.)
 .IP 
 .IP "\fB-y, --fuzzy\fP" 
 This option tells rsync that it should look for a
 basis file for any destination file that is missing\&.  The current algorithm
 looks in the same directory as the destination file for either a file that
 has an identical size and modified-time, or a similarly-named file\&.  If
@@ -1157,26 +1468,31 @@
 selected to try to speed up the transfer\&.
 .IP 
 If \fIDIR\fP is a relative path, it is relative to the destination directory\&.
 See also \fB--compare-dest\fP and \fB--copy-dest\fP\&.
 .IP 
 Note that rsync versions prior to 2\&.6\&.1 had a bug that could prevent
-\fB--link-dest\fP from working properly for a non-root user when \fB-o\fP was specified
-(or implied by \fB-a\fP)\&.  You can work-around this bug by avoiding the \fB-o\fP option
-when sending to an old rsync\&.
+\fB--link-dest\fP from working properly for a non-super-user when \fB-o\fP was
+specified (or implied by \fB-a\fP)\&.  You can work-around this bug by avoiding
+the \fB-o\fP option when sending to an old rsync\&.
 .IP 
 .IP "\fB-z, --compress\fP" 
 With this option, rsync compresses the file data
 as it is sent to the destination machine, which reduces the amount of data
 being transmitted -- something that is useful over a slow connection\&.
 .IP 
-Note this this option typically achieves better compression ratios that can
+Note that this option typically achieves better compression ratios than can
 be achieved by using a compressing remote shell or a compressing transport
 because it takes advantage of the implicit information in the matching data
 blocks that are not explicitly sent over the connection\&.
 .IP 
+.IP "\fB--compress-level=NUM\fP" 
+Explicitly set the compression level to use
+(see \fB--compress\fP) instead of letting it default\&.  If NUM is non-zero,
+the \fB--compress\fP option is implied\&.
+.IP 
 .IP "\fB--numeric-ids\fP" 
 With this option rsync will transfer numeric group
 and user IDs rather than using user and group names and mapping them
 at both ends\&.
 .IP 
 By default rsync will use the username and groupname to determine
@@ -1206,56 +1522,67 @@
 This specifies an alternate TCP port number to use
 rather than the default of 873\&.  This is only needed if you are using the
 double-colon (::) syntax to connect with an rsync daemon (since the URL
 syntax has a way to specify the port as a part of the URL)\&.  See also this
 option in the \fB--daemon\fP mode section\&.
 .IP 
+.IP "\fB--sockopts\fP" 
+This option can provide endless fun for people
+who like to tune their systems to the utmost degree\&. You can set all
+sorts of socket options which may make transfers faster (or
+slower!)\&. Read the man page for the setsockopt() system call for
+details on some of the options you may be able to set\&. By default no
+special socket options are set\&. This only affects direct socket
+connections to a remote rsync daemon\&.  This option also exists in the
+\fB--daemon\fP mode section\&.
+.IP 
 .IP "\fB--blocking-io\fP" 
 This tells rsync to use blocking I/O when launching
 a remote shell transport\&.  If the remote shell is either rsh or remsh,
 rsync defaults to using
 blocking I/O, otherwise it defaults to using non-blocking I/O\&.  (Note that
 ssh prefers non-blocking I/O\&.)
 .IP 
-.IP "\fB--no-blocking-io\fP" 
-Turn off \fB--blocking-io\fP, for use when it is the
-default\&.
-.IP 
 .IP "\fB-i, --itemize-changes\fP" 
 Requests a simple itemized list of the
 changes that are being made to each file, including attribute changes\&.
 This is exactly the same as specifying \fB--log-format=\&'%i %n%L\&'\fP\&.
+If you repeat the option, unchanged files will also be output, but only
+if the receiving rsync is at least version 2\&.6\&.7 (you can use \fB-vv\fP
+with older versions of rsync, but that also turns on the output of other
+verbose messages)\&.
 .IP 
 The "%i" escape has a cryptic output that is 9 letters long\&.  The general
-format is like the string \fBUXcstpoga\fP), where \fBU\fP is replaced by the
-kind of update being done, \fBX\fP is replaced by the file-type, and the
+format is like the string \fBYXcstpogz\fP, where \fBY\fP is replaced by the
+type of update being done, \fBX\fP is replaced by the file-type, and the
 other letters represent attributes that may be output if they are being
 modified\&.
 .IP 
-The update types that replace the \fBU\fP are as follows:
+The update types that replace the \fBY\fP are as follows:
 .IP 
 .RS 
 .IP o 
 A \fB<\fP means that a file is being transferred to the remote host
 (sent)\&.
 .IP o 
 A \fB>\fP means that a file is being transferred to the local host
 (received)\&.
 .IP o 
 A \fBc\fP means that a local change/creation is occurring for the item
 (such as the creation of a directory or the changing of a symlink, etc\&.)\&.
 .IP o 
-A \fBh\fP means that the item is a hard-link to another item (requires
+A \fBh\fP means that the item is a hard link to another item (requires
 \fB--hard-links\fP)\&.
 .IP o 
 A \fB\&.\fP means that the item is not being updated (though it might
 have attributes that are being modified)\&.
 .RE 
 .IP 
 The file-types that replace the \fBX\fP are: \fBf\fP for a file, a \fBd\fP for a
-directory, an \fBL\fP for a symlink, and a \fBD\fP for a device\&.
+directory, an \fBL\fP for a symlink, a \fBD\fP for a device, and a \fBS\fP for a
+special file (e\&.g\&. named sockets and fifos)\&.
 .IP 
 The other letters in the string above are the actual letters that
 will be output if the associated attribute for the item is being updated or
 a "\&." for no change\&.  Three exceptions to this are: (1) a newly created
 item replaces each letter with a "+", (2) an identical item replaces the
 dots with spaces, and (3) an unknown attribute replaces each letter with
@@ -1278,19 +1605,18 @@
 without \fB--times\fP\&.
 .IP o 
 A \fBp\fP means the permissions are different and are being updated to
 the sender\&'s value (requires \fB--perms\fP)\&.
 .IP o 
 An \fBo\fP means the owner is different and is being updated to the
-sender\&'s value (requires \fB--owner\fP and root privileges)\&.
+sender\&'s value (requires \fB--owner\fP and super-user privileges)\&.
 .IP o 
 A \fBg\fP means the group is different and is being updated to the
 sender\&'s value (requires \fB--group\fP and the authority to set the group)\&.
 .IP o 
-The \fBa\fP is reserved for a future enhanced version that supports
-extended file attributes, such as ACLs\&.
+The \fBz\fP slot is reserved for future use\&.
 .RE 
 .IP 
 One other output is possible:  when deleting files, the "%i" will output
 the string "*deleting" for each item that is being removed (assuming that
 you are talking to a recent enough rsync that it logs deletions instead of
 outputting them as a verbose message)\&.
@@ -1302,20 +1628,20 @@
 a percent (%) character\&.  For a list of the possible escape characters, see
 the "log format" setting in the rsyncd\&.conf manpage\&.  (Note that this
 option does not affect what a daemon logs to its logfile\&.)
 .IP 
 Specifying this option will mention each file, dir, etc\&. that gets updated
 in a significant way (a transferred file, a recreated symlink/device, or a
-touched directory) unless the itemized-changes escape (%i) is included in
+touched directory) unless the itemize-changes escape (%i) is included in
 the string, in which case the logging of names increases to mention any
 item that is changed in any way (as long as the receiving side is at least
-2\&.6\&.4)\&.  See the \fB--itemized-changes\fP option for a description of the
+2\&.6\&.4)\&.  See the \fB--itemize-changes\fP option for a description of the
 output of "%i"\&.
 .IP 
 The \fB--verbose\fP option implies a format of "%n%L", but you can use
-\fB--log-format\fP without bv(--verbose) if you like, or you can override
+\fB--log-format\fP without \fB--verbose\fP if you like, or you can override
 the format of its per-file output using this option\&.
 .IP 
 Rsync will output the log-format string prior to a file\&'s transfer unless
 one of the transfer-statistic escapes is requested, in which case the
 logging is done at the end of the file\&'s transfer\&.  When this late logging
 is in effect and \fB--progress\fP is also specified, rsync will also output
@@ -1324,61 +1650,129 @@
 .IP 
 .IP "\fB--stats\fP" 
 This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data\&.
 .IP 
+The current statistics are as follows: 
+.IP o 
+\fBNumber of files\fP is the count of all "files" (in the generic
+sense), which includes directories, symlinks, etc\&.
+.IP o 
+\fBNumber of files transferred\fP is the count of normal files that
+were updated via the rsync algorithm, which does not include created
+dirs, symlinks, etc\&.
+.IP o 
+\fBTotal file size\fP is the total sum of all file sizes in the transfer\&.
+This does not count any size for directories or special files, but does
+include the size of symlinks\&.
+.IP o 
+\fBTotal transferred file size\fP is the total sum of all files sizes
+for just the transferred files\&.
+.IP o 
+\fBLiteral data\fP is how much unmatched file-update data we had to
+send to the receiver for it to recreate the updated files\&.
+.IP o 
+\fBMatched data\fP is how much data the receiver got locally when
+recreating the updated files\&.
+.IP o 
+\fBFile list size\fP is how big the file-list data was when the sender
+sent it to the receiver\&.  This is smaller than the in-memory size for the
+file list due to some compressing of duplicated data when rsync sends the
+list\&.
+.IP o 
+\fBFile list generation time\fP is the number of seconds that the
+sender spent creating the file list\&.  This requires a modern rsync on the
+sending side for this to be present\&.
+.IP o 
+\fBFile list transfer time\fP is the number of seconds that the sender
+spent sending the file list to the receiver\&.
+.IP o 
+\fBTotal bytes sent\fP is the count of all the bytes that rsync sent
+from the client side to the server side\&.
+.IP o 
+\fBTotal bytes received\fP is the count of all non-message bytes that
+rsync received by the client side from the server side\&.  "Non-message"
+bytes means that we don\&'t count the bytes for a verbose message that the
+server sent to us, which makes the stats more consistent\&.
+.IP 
+.IP "\fB-8, --8-bit-output\fP" 
+This tells rsync to leave all high-bit characters
+unescaped in the output instead of trying to test them to see if they\&'re
+valid in the current locale and escaping the invalid ones\&.  All control
+characters (but never tabs) are always escaped, regardless of this option\&'s
+setting\&.
+.IP 
+The escape idiom that started in 2\&.6\&.7 is to output a literal backslash (\e)
+and a hash (#), followed by exactly 3 octal digits\&.  For example, a newline
+would output as "\e#012"\&.  A literal backslash that is in a filename is not
+escaped unless it is followed by a hash and 3 digits (0-9)\&.
+.IP 
+.IP "\fB-h, --human-readable\fP" 
+Output numbers in a more human-readable format\&.
+This makes big numbers output using larger units, with a K, M, or G suffix\&.  If
+this option was specified once, these units are K (1000), M (1000*1000), and
+G (1000*1000*1000); if the option is repeated, the units are powers of 1024
+instead of 1000\&.
+.IP 
 .IP "\fB--partial\fP" 
 By default, rsync will delete any partially
 transferred file if the transfer is interrupted\&. In some circumstances
 it is more desirable to keep partially transferred files\&. Using the
 \fB--partial\fP option tells rsync to keep the partial file which should
 make a subsequent transfer of the rest of the file much faster\&.
 .IP 
 .IP "\fB--partial-dir=DIR\fP" 
 A better way to keep partial files than the
 \fB--partial\fP option is to specify a \fIDIR\fP that will be used to hold the
 partial data (instead of writing it out to the destination file)\&.
 On the next transfer, rsync will use a file found in this
-dir as data to speed up the resumption of the transfer and then deletes it
+dir as data to speed up the resumption of the transfer and then delete it
 after it has served its purpose\&.
+.IP 
 Note that if \fB--whole-file\fP is specified (or implied), any partial-dir
 file that is found for a file that is being updated will simply be removed
 (since
 rsync is sending files without using the incremental rsync algorithm)\&.
 .IP 
 Rsync will create the \fIDIR\fP if it is missing (just the last dir -- not
 the whole path)\&.  This makes it easy to use a relative path (such as
 "\fB--partial-dir=\&.rsync-partial\fP") to have rsync create the
 partial-directory in the destination file\&'s directory when needed, and then
 remove it again when the partial file is deleted\&.
 .IP 
-If the partial-dir value is not an absolute path, rsync will also add a directory
-\fB--exclude\fP of this value at the end of all your existing excludes\&.  This
-will prevent partial-dir files from being transferred and also prevent the
-untimely deletion of partial-dir items on the receiving side\&.  An example:
-the above \fB--partial-dir\fP option would add an "\fB--exclude=\&.rsync-partial/\fP"
-rule at the end of any other filter rules\&.  Note that if you are
-supplying your own filter rules, you may need to manually insert a
-rule for this directory exclusion somewhere higher up in the list so that
-it has a high enough priority to be effective (e\&.g\&., if your rules specify
-a trailing \fB--exclude=\&'*\&'\fP rule, the auto-added rule would never be
-reached)\&.
+If the partial-dir value is not an absolute path, rsync will add an exclude
+rule at the end of all your existing excludes\&.  This will prevent the
+sending of any partial-dir files that may exist on the sending side, and
+will also prevent the untimely deletion of partial-dir items on the
+receiving side\&.  An example: the above \fB--partial-dir\fP option would add
+the equivalent of "\fB--exclude=\&.rsync-partial/\fP" at the end of any other
+filter rules\&.
+.IP 
+If you are supplying your own exclude rules, you may need to add your own
+exclude/hide/protect rule for the partial-dir because (1) the auto-added
+rule may be ineffective at the end of your other rules, or (2) you may wish
+to override rsync\&'s exclude choice\&.  For instance, if you want to make
+rsync clean-up any left-over partial-dirs that may be lying around, you
+should specify \fB--delete-after\fP and add a "risk" filter rule, e\&.g\&.
+\fB-f \&'R \&.rsync-partial/\&'\fP\&.  (Avoid using \fB--delete-before\fP or
+\fB--delete-during\fP unless you don\&'t need rsync to use any of the
+left-over partial-dir data during the current run\&.)
 .IP 
 IMPORTANT: the \fB--partial-dir\fP should not be writable by other users or it
 is a security risk\&.  E\&.g\&. AVOID "/tmp"\&.
 .IP 
 You can also set the partial-dir value the RSYNC_PARTIAL_DIR environment
 variable\&.  Setting this in the environment does not force \fB--partial\fP to be
-enabled, but rather it effects where partial files go when \fB--partial\fP is
+enabled, but rather it affects where partial files go when \fB--partial\fP is
 specified\&.  For instance, instead of using \fB--partial-dir=\&.rsync-tmp\fP
 along with \fB--progress\fP, you could set RSYNC_PARTIAL_DIR=\&.rsync-tmp in your
 environment and then just use the \fB-P\fP option to turn on the use of the
-\&.rsync-tmp dir for partial transfers\&.  The only time that the \fB--partial\fP
-option does not look for this environment value is (1) when \fB--inplace\fP was
-specified (since \fB--inplace\fP conflicts with \fB--partial-dir\fP), or (2) when
+\&.rsync-tmp dir for partial transfers\&.  The only times that the \fB--partial\fP
+option does not look for this environment value are (1) when \fB--inplace\fP was
+specified (since \fB--inplace\fP conflicts with \fB--partial-dir\fP), and (2) when
 \fB--delay-updates\fP was specified (see below)\&.
 .IP 
 For the purposes of the daemon-config\&'s "refuse options" setting,
 \fB--partial-dir\fP does \fInot\fP imply \fB--partial\fP\&.  This is so that a
 refusal of the \fB--partial\fP option can be used to disallow the overwriting
 of destination files with a partial transfer, while still allowing the
@@ -1387,30 +1781,69 @@
 .IP "\fB--delay-updates\fP" 
 This option puts the temporary file from each
 updated file into a holding directory until the end of the
 transfer, at which time all the files are renamed into place in rapid
 succession\&.  This attempts to make the updating of the files a little more
 atomic\&.  By default the files are placed into a directory named "\&.~tmp~" in
-each file\&'s destination directory, but you can override this by specifying
-the \fB--partial-dir\fP option\&.  (Note that RSYNC_PARTIAL_DIR has no effect
-on this value, nor is \fB--partial-dir\fP considered to be implied for the
-purposes of the daemon-config\&'s "refuse options" setting\&.)
-Conflicts with \fB--inplace\fP\&.
+each file\&'s destination directory, but if you\&'ve specified the
+\fB--partial-dir\fP option, that directory will be used instead\&.  See the
+comments in the \fB--partial-dir\fP section for a discussion of how this
+"\&.~tmp~" dir will be excluded from the transfer, and what you can do if
+you wnat rsync to cleanup old "\&.~tmp~" dirs that might be lying around\&.
+Conflicts with \fB--inplace\fP and \fB--append\fP\&.
 .IP 
 This option uses more memory on the receiving side (one bit per file
 transferred) and also requires enough free disk space on the receiving
 side to hold an additional copy of all the updated files\&.  Note also that
-you should not use an absolute path to \fB--partial-dir\fP unless there is no
+you should not use an absolute path to \fB--partial-dir\fP unless (1)
+there is no
 chance of any of the files in the transfer having the same name (since all
 the updated files will be put into a single directory if the path is
-absolute)\&.
+absolute)
+and (2) there are no mount points in the hierarchy (since the
+delayed updates will fail if they can\&'t be renamed into place)\&.
 .IP 
 See also the "atomic-rsync" perl script in the "support" subdir for an
 update algorithm that is even more atomic (it uses \fB--link-dest\fP and a
 parallel hierarchy of files)\&.
 .IP 
+.IP "\fB-m, --prune-empty-dirs\fP" 
+This option tells the receiving rsync to get
+rid of empty directories from the file-list, including nested directories
+that have no non-directory children\&.  This is useful for avoiding the
+creation of a bunch of useless directories when the sending rsync is
+recursively scanning a hierarchy of files using include/exclude/filter
+rules\&.
+.IP 
+Because the file-list is actually being pruned, this option also affects
+what directories get deleted when a delete is active\&.  However, keep in
+mind that excluded files and directories can prevent existing items from
+being deleted (because an exclude hides source files and protects
+destination files)\&.
+.IP 
+You can prevent the pruning of certain empty directories from the file-list
+by using a global "protect" filter\&.  For instance, this option would ensure
+that the directory "emptydir" was kept in the file-list:
+.IP 
+.RS 
+--filter \&'protect emptydir/\&'
+.RE 
+.IP 
+Here\&'s an example that copies all \&.pdf files in a hierarchy, only creating
+the necessary destination directories to hold the \&.pdf files, and ensures
+that any superfluous files and directories in the destination are removed
+(note the hide filter of non-directories being used instead of an exclude):
+.IP 
+.RS 
+rsync -avm --del --include=\&'*\&.pdf\&' -f \&'hide,! */\&' src/ dest
+.RE 
+.IP 
+If you didn\&'t want to remove superfluous destination files, the more
+time-honored options of "--include=\&'*/\&' --exclude=\&'*\&'" would work fine
+in place of the hide-filter (if that is more natural to you)\&.
+.IP 
 .IP "\fB--progress\fP" 
 This option tells rsync to print information
 showing the progress of the transfer\&. This gives a bored user
 something to watch\&.
 Implies \fB--verbose\fP if it wasn\&'t already specified\&.
 .IP 
@@ -1457,19 +1890,30 @@
 transport, not when using a remote shell as the transport\&. The file
 must not be world readable\&. It should contain just the password as a
 single line\&.
 .IP 
 .IP "\fB--list-only\fP" 
 This option will cause the source files to be listed
-instead of transferred\&.  This option is inferred if there is no destination
-specified, so you don\&'t usually need to use it explicitly\&.  However, it can
-come in handy for a user that wants to avoid the "\fB-r --exclude=\&'/*/*\&'\fP"
-options that rsync might use as a compatibility kluge when generating a
-non-recursive listing, or to list the files that are involved in a local
-copy (since the destination path is not optional for a local copy, you
-must specify this option explicitly and still include a destination)\&.
+instead of transferred\&.  This option is inferred if there is a single source
+arg and no destination specified, so its main uses are: (1) to turn a copy
+command that includes a
+destination arg into a file-listing command, (2) to be able to specify more
+than one local source arg (note: be sure to include the destination), or
+(3) to avoid the automatically added "\fB-r --exclude=\&'/*/*\&'\fP" options that
+rsync usually uses as a compatibility kluge when generating a non-recursive
+listing\&.  Caution: keep in mind that a source arg with a wild-card is expanded
+by the shell into multiple args, so it is never safe to try to list such an arg
+without using this option\&.  For example:
+.IP 
+
+.nf 
+ 
+    rsync -av --list-only foo* dest/
+.fi 
+ 
+
 .IP 
 .IP "\fB--bwlimit=KBPS\fP" 
 This option allows you to specify a maximum
 transfer rate in kilobytes per second\&. This option is most effective when
 using rsync with large files (several megabytes and up)\&. Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
@@ -1500,13 +1944,13 @@
 into the batch file without having to flow over the wire to the receiver
 (when pulling, the sender is remote, and thus can\&'t write the batch)\&.
 .IP 
 .IP "\fB--read-batch=FILE\fP" 
 Apply all of the changes stored in FILE, a
 file previously generated by \fB--write-batch\fP\&.
-If \fIFILE\fP is "-" the batch data will be read from standard input\&.
+If \fIFILE\fP is \fB-\fP, the batch data will be read from standard input\&.
 See the "BATCH MODE" section for details\&.
 .IP 
 .IP "\fB--protocol=NUM\fP" 
 Force an older protocol version to be used\&.  This
 is useful for creating a batch file that is compatible with an older
 version of rsync\&.  For instance, if rsync 2\&.6\&.4 is being used with the
@@ -1563,13 +2007,13 @@
 client version of this option (above) for some extra details\&.
 .IP 
 .IP "\fB--config=FILE\fP" 
 This specifies an alternate config file than
 the default\&.  This is only relevant when \fB--daemon\fP is specified\&.
 The default is /etc/rsyncd\&.conf unless the daemon is running over
-a remote shell program and the remote user is not root; in that case
+a remote shell program and the remote user is not the super-user; in that case
 the default is rsyncd\&.conf in the current directory (typically $HOME)\&.
 .IP 
 .IP "\fB--no-detach\fP" 
 When running as a daemon, this option instructs
 rsync to not detach itself and become a background process\&.  This
 option is required when running as a service on Cygwin, and may also
@@ -1581,12 +2025,16 @@
 .IP 
 .IP "\fB--port=PORT\fP" 
 This specifies an alternate TCP port number for the
 daemon to listen on rather than the default of 873\&.  See also the "port"
 global option in the rsyncd\&.conf manpage\&.
 .IP 
+.IP "\fB--sockopts\fP" 
+This overrides the \fBsocket options\fP setting in the
+rsyncd\&.conf file and has the same syntax\&.
+.IP 
 .IP "\fB-v, --verbose\fP" 
 This option increases the amount of information the
 daemon logs during its startup phase\&.  After the client connects, the
 daemon\&'s verbosity level will be controlled by the options that the client
 used and the "max verbosity" setting in the module\&'s config section\&.
 .IP 
@@ -1682,13 +2130,13 @@
 .PP 
 .IP o 
 if the pattern starts with a / then it is anchored to a
 particular spot in the hierarchy of files, otherwise it is matched
 against the end of the pathname\&.  This is similar to a leading ^ in
 regular expressions\&.
-Thus "/foo" would match a file called "foo" at either the "root of the
+Thus "/foo" would match a file named "foo" at either the "root of the
 transfer" (for a global rule) or in the merge-file\&'s directory (for a
 per-directory rule)\&.
 An unqualified "foo" would match any file or directory named "foo"
 anywhere in the tree because the algorithm is applied recursively from
 the
 top down; it behaves as if each path component gets a turn at being the
@@ -1697,27 +2145,41 @@
 named "sub"\&.  See the section on ANCHORING INCLUDE/EXCLUDE PATTERNS for
 a full discussion of how to specify a pattern that matches at the root
 of the transfer\&.
 .IP o 
 if the pattern ends with a / then it will only match a
 directory, not a file, link, or device\&.
+.IP 
+.IP o 
+rsync chooses between doing a simple string match and wildcard
+matching by checking if the pattern contains one of these three wildcard
+characters: \&'*\&', \&'?\&', and \&'[\&' \&.
 .IP o 
-if the pattern contains a wildcard character from the set
-*?[ then expression matching is applied using the shell filename
-matching rules\&. Otherwise a simple string match is used\&.
+a \&'*\&' matches any non-empty path component (it stops at slashes)\&.
 .IP o 
-the double asterisk pattern "**" will match slashes while a
-single asterisk pattern "*" will stop at slashes\&.
+use \&'**\&' to match anything, including slashes\&.
 .IP o 
-if the pattern contains a / (not counting a trailing /) or a "**"
+a \&'?\&' matches any character except a slash (/)\&.
+.IP o 
+a \&'[\&' introduces a character class, such as [a-z] or [[:alpha:]]\&.
+.IP o 
+in a wildcard pattern, a backslash can be used to escape a wildcard
+character, but it is matched literally when no wildcards are present\&.
+.IP o 
+if the pattern contains a / (not counting a trailing /) or a "**",
 then it is matched against the full pathname, including any leading
 directories\&. If the pattern doesn\&'t contain a / or a "**", then it is
 matched only against the final component of the filename\&.
 (Remember that the algorithm is applied recursively so "full filename"
 can actually be any portion of a path from the starting directory on
 down\&.)
+.IP o 
+a trailing "dir_name/***" will match both the directory (as if
+"dir_name/" had been specified) and all the files in the directory
+(as if "dir_name/**" had been specified)\&.  (This behavior is new for
+version 2\&.6\&.7\&.)
 .PP 
 Note that, when using the \fB--recursive\fP (\fB-r\fP) option (which is implied by
 \fB-a\fP), every subcomponent of every path is visited from the top down, so
 include/exclude patterns get applied recursively to each subcomponent\&'s
 full name (e\&.g\&. to include "/foo/bar/baz" the subcomponents "/foo" and
 "/foo/bar" must not be excluded)\&.
@@ -1738,13 +2200,14 @@
 .RE 
 .PP 
 This fails because the parent directory "some" is excluded by the \&'*\&'
 rule, so rsync never visits any of the files in the "some" or "some/path"
 directories\&.  One solution is to ask for all directories in the hierarchy
 to be included by using a single rule: "+ */" (put it somewhere before the
-"- *" rule)\&.  Another solution is to add specific include rules for all
+"- *" rule), and perhaps use the \fB--prune-empty-dirs\fP option\&.  Another
+solution is to add specific include rules for all
 the parent dirs that need to be visited\&.  For instance, this set of rules
 works fine:
 .PP 
 .RS 
 \f(CW+ /some/\fP
 .br 
@@ -1760,24 +2223,26 @@
 .PP 
 Here are some examples of exclude/include matching:
 .PP 
 .IP o 
 "- *\&.o" would exclude all filenames matching *\&.o
 .IP o 
-"- /foo" would exclude a file called foo in the transfer-root directory
+"- /foo" would exclude a file (or directory) named foo in the
+transfer-root directory
 .IP o 
-"- foo/" would exclude any directory called foo
+"- foo/" would exclude any directory named foo
 .IP o 
-"- /foo/*/bar" would exclude any file called bar two
-levels below a directory called foo in the transfer-root directory
+"- /foo/*/bar" would exclude any file named bar which is at two
+levels below a directory named foo in the transfer-root directory
 .IP o 
-"- /foo/**/bar" would exclude any file called bar two
-or more levels below a directory called foo in the transfer-root directory
+"- /foo/**/bar" would exclude any file named bar two
+or more levels below a directory named foo in the transfer-root directory
 .IP o 
 The combination of "+ */", "+ *\&.c", and "- *" would include all
-directories and C source files but nothing else\&.
+directories and C source files but nothing else (see also the
+\fB--prune-empty-dirs\fP option)
 .IP o 
 The combination of "+ foo/", "+ foo/bar\&.c", and "- *" would include
 only the foo directory and foo/bar\&.c (the foo directory must be
 explicitly included or it would be excluded by the "*")
 .PP 
 .SH "MERGE-FILE FILTER RULES" 
@@ -1836,25 +2301,27 @@
 of the normal line-splitting\&.  This also turns off comments\&.  Note: the
 space that separates the prefix from the rule is treated specially, so
 "- foo + bar" is parsed as two rules (assuming that prefix-parsing wasn\&'t
 also disabled)\&.
 .IP o 
 You may also specify any of the modifiers for the "+" or "-" rules
-(below) in order  to have the rules that are read-in from the file
+(below) in order to have the rules that are read in from the file
 default to having that modifier set\&.  For instance, "merge,-/ \&.excl" would
 treat the contents of \&.excl as absolute-path excludes,
 while "dir-merge,s \&.filt" and ":sC" would each make all their
 per-directory rules apply only on the sending side\&.
 .PP 
 The following modifiers are accepted after a "+" or "-":
 .PP 
 .IP o 
-A "/" specifies that the include/exclude should be treated as an
-absolute path, relative to the root of the filesystem\&.  For example,
+A "/" specifies that the include/exclude rule should be matched
+against the absolute pathname of the current item\&.  For example,
 "-/ /etc/passwd" would exclude the passwd file any time the transfer
-was sending files from the "/etc" directory\&.
+was sending files from the "/etc" directory, and "-/ subdir/foo"
+would always exclude "foo" when it is in a dir named "subdir", even
+if "foo" is at the root of the current transfer\&.
 .IP o 
 A "!" specifies that the include/exclude should take effect if
 the pattern fails to match\&.  For instance, "-! */" would exclude all
 non-directories\&.
 .IP o 
 A \fBC\fP is used to indicate that all the global CVS-exclude rules
@@ -1904,13 +2371,13 @@
 \f(CW- *\&.o\fP
 .br 
 .RE 
 .PP 
 This will merge the contents of the /home/user/\&.global-filter file at the
 start of the list and also turns the "\&.rules" filename into a per-directory
-filter file\&.  All rules read-in prior to the start of the directory scan
+filter file\&.  All rules read in prior to the start of the directory scan
 follow the global anchoring rules (i\&.e\&. a leading slash matches at the root
 of the transfer)\&.
 .PP 
 If a per-directory merge-file is specified with a path that is a parent
 directory of the first transfer directory, rsync will scan all the parent
 dirs from that starting point to the transfer directory for the indicated
@@ -2393,13 +2860,13 @@
 .SH "SEE ALSO" 
 .PP 
 rsyncd\&.conf(5)
 .PP 
 .SH "BUGS" 
 .PP 
-times are transferred as unix time_t values
+times are transferred as *nix time_t values
 .PP 
 When transferring to FAT filesystems rsync may re-sync
 unmodified files\&.
 See the comments on the \fB--modify-window\fP option\&.
 .PP 
 file permissions, devices, etc\&. are transferred as native numerical
@@ -2409,13 +2876,13 @@
 .PP 
 Please report bugs! See the website at
 http://rsync\&.samba\&.org/
 .PP 
 .SH "VERSION" 
 .PP 
-This man page is current for version 2\&.6\&.6 of rsync\&.
+This man page is current for version 2\&.6\&.7 of rsync\&.
 .PP 
 .SH "CREDITS" 
 .PP 
 rsync is distributed under the GNU public license\&.  See the file
 COPYING for details\&.
 .PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsync.c	2005-03-15 01:06:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.c	2006-02-24 09:56:26.000000000 +0800
@@ -18,43 +18,115 @@
 */
 
 /* this file contains code used by more than one part of the rsync
    process */
 
 #include "rsync.h"
+#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+#include <iconv.h>
+#endif
+#if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
+#include <libcharset.h>
+#elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
+#include <langinfo.h>
+#endif
 
 extern int verbose;
 extern int dry_run;
 extern int daemon_log_format_has_i;
+extern int preserve_perms;
+extern int preserve_executability;
 extern int preserve_times;
 extern int omit_dir_times;
 extern int am_root;
 extern int am_server;
 extern int am_sender;
 extern int am_generator;
 extern int am_starting_up;
+extern int allow_8bit_chars;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int inplace;
 extern int keep_dirlinks;
 extern int make_backups;
+extern mode_t orig_umask;
 extern struct stats stats;
+extern struct chmod_mode_struct *daemon_chmod_modes;
+
+#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+iconv_t ic_chck = (iconv_t)-1;
+
+static const char *default_charset(void)
+{
+#if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
+	return locale_charset();
+#elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
+	return nl_langinfo(CODESET);
+#else
+	return ""; /* Works with (at the very least) gnu iconv... */
+#endif
+}
+
+void setup_iconv()
+{
+	if (!am_server && !allow_8bit_chars) {
+		const char *defset = default_charset();
+
+		/* It's OK if this fails... */
+		ic_chck = iconv_open(defset, defset);
 
+		if (verbose > 3) {
+			if (ic_chck == (iconv_t)-1) {
+				rprintf(FINFO,
+					"note: iconv_open(\"%s\", \"%s\") failed (%d)"
+					" -- using isprint() instead of iconv().\n",
+					defset, defset, errno);
+			} else {
+				rprintf(FINFO,
+					"note: iconv_open(\"%s\", \"%s\") succeeded.\n",
+					defset, defset);
+			}
+		}
+	}
+}
+#endif
 
 /*
   free a sums struct
   */
 void free_sums(struct sum_struct *s)
 {
 	if (s->sums) free(s->sums);
 	free(s);
 }
 
+/* This is only called when we aren't preserving permissions.  Figure out what
+ * the permissions should be and return them merged back into the mode. */
+mode_t dest_mode(mode_t flist_mode, mode_t cur_mode, int exists)
+{
+	/* If the file already exists, we'll return the local permissions,
+	 * possibly tweaked by the --executability option. */
+	if (exists) {
+		if (preserve_executability && S_ISREG(flist_mode)) {
+			/* If the source file is executable, grant execute
+			 * rights to everyone who can read, but ONLY if the
+			 * file isn't already executable. */
+			if (!(flist_mode & 0111))
+				cur_mode &= ~0111;
+			else if (!(cur_mode & 0111))
+				cur_mode |= (cur_mode & 0444) >> 2;
+		}
+	} else
+		cur_mode = flist_mode & ACCESSPERMS & ~orig_umask;
+	if (daemon_chmod_modes && !S_ISLNK(flist_mode))
+		cur_mode = tweak_mode(cur_mode, daemon_chmod_modes);
+	return (flist_mode & ~CHMOD_BITS) | (cur_mode & CHMOD_BITS);
+}
 
-int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
-	      int flags)
+int set_file_attrs(char *fname, struct file_struct *file, STRUCT_STAT *st,
+		   int flags)
 {
 	int updated = 0;
 	STRUCT_STAT st2;
 	int change_uid, change_gid;
 
 	if (!st) {
@@ -63,25 +135,32 @@
 		if (link_stat(fname, &st2, 0) < 0) {
 			rsyserr(FERROR, errno, "stat %s failed",
 				full_fname(fname));
 			return 0;
 		}
 		st = &st2;
+		if (!preserve_perms && S_ISDIR(file->mode)
+		 && st->st_mode & S_ISGID) {
+			/* We just created this directory and its setgid
+			 * bit is on, so make sure it stays on. */
+			file->mode |= S_ISGID;
+		}
 	}
 
-	if (!preserve_times || S_ISLNK(st->st_mode)
-	 || (S_ISDIR(st->st_mode) && omit_dir_times))
-		flags |= PERMS_SKIP_MTIME;
-	if (!(flags & PERMS_SKIP_MTIME)
-	    && cmp_modtime(st->st_mtime, file->modtime) != 0) {
-		if (set_modtime(fname,file->modtime) != 0) {
+	if (!preserve_times || (S_ISDIR(st->st_mode) && omit_dir_times))
+		flags |= ATTRS_SKIP_MTIME;
+	if (!(flags & ATTRS_SKIP_MTIME)
+	    && cmp_time(st->st_mtime, file->modtime) != 0) {
+		int ret = set_modtime(fname, file->modtime, st->st_mode);
+		if (ret < 0) {
 			rsyserr(FERROR, errno, "failed to set times on %s",
 				full_fname(fname));
 			return 0;
 		}
-		updated = 1;
+		if (ret == 0) /* ret == 1 if symlink could not be set */
+			updated = 1;
 	}
 
 	change_uid = am_root && preserve_uid && st->st_uid != file->uid;
 	change_gid = preserve_gid && file->gid != GID_NONE
 		&& st->st_gid != file->gid;
 #if !defined HAVE_LCHOWN && !defined CHOWN_MODIFIES_SYMLINK
@@ -91,19 +170,19 @@
 #endif
 	if (change_uid || change_gid) {
 		if (verbose > 2) {
 			if (change_uid) {
 				rprintf(FINFO,
 					"set uid of %s from %ld to %ld\n",
-					safe_fname(fname),
+					fname,
 					(long)st->st_uid, (long)file->uid);
 			}
 			if (change_gid) {
 				rprintf(FINFO,
 					"set gid of %s from %ld to %ld\n",
-					safe_fname(fname),
+					fname,
 					(long)st->st_gid, (long)file->gid);
 			}
 		}
 		if (do_lchown(fname,
 		    change_uid ? file->uid : st->st_uid,
 		    change_gid ? file->gid : st->st_gid) != 0) {
@@ -122,37 +201,37 @@
 				  keep_dirlinks && S_ISDIR(st->st_mode));
 		}
 		updated = 1;
 	}
 
 #ifdef HAVE_CHMOD
-	if (!S_ISLNK(st->st_mode)) {
-		if ((st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS)) {
-			updated = 1;
-			if (do_chmod(fname,(file->mode & CHMOD_BITS)) != 0) {
-				rsyserr(FERROR, errno, "failed to set permissions on %s",
-					full_fname(fname));
-				return 0;
-			}
+	if ((st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS)) {
+		int ret = do_chmod(fname, file->mode);
+		if (ret < 0) {
+			rsyserr(FERROR, errno,
+				"failed to set permissions on %s",
+				full_fname(fname));
+			return 0;
 		}
+		if (ret == 0) /* ret == 1 if symlink could not be set */
+			updated = 1;
 	}
 #endif
 
-	if (verbose > 1 && flags & PERMS_REPORT) {
+	if (verbose > 1 && flags & ATTRS_REPORT) {
 		enum logcode code = daemon_log_format_has_i || dry_run
 				  ? FCLIENT : FINFO;
 		if (updated)
-			rprintf(code, "%s\n", safe_fname(fname));
+			rprintf(code, "%s\n", fname);
 		else
-			rprintf(code, "%s is uptodate\n", safe_fname(fname));
+			rprintf(code, "%s is uptodate\n", fname);
 	}
 	return updated;
 }
 
-
-void sig_int(void)
+RETSIGTYPE sig_int(UNUSED(int val))
 {
 	/* KLUGE: if the user hits Ctrl-C while ssh is prompting
 	 * for a password, then our cleanup's sending of a SIGUSR1
 	 * signal to all our children may kill ssh before it has a
 	 * chance to restore the tty settings (i.e. turn echo back
 	 * on).  By sleeping for a short time, ssh gets a bigger
@@ -160,51 +239,67 @@
 	 * not ssh waiting for a password, then this tiny delay
 	 * shouldn't hurt anything. */
 	msleep(400);
 	exit_cleanup(RERR_SIGNAL);
 }
 
-
-/* finish off a file transfer, renaming the file and setting the permissions
-   and ownership */
-void finish_transfer(char *fname, char *fnametmp, struct file_struct *file,
-		     int ok_to_set_time, int overwriting_basis)
+/* Finish off a file transfer: renaming the file and setting the file's
+ * attributes (e.g. permissions, ownership, etc.).  If partialptr is not
+ * NULL and the robust_rename() call is forced to copy the temp file, we
+ * stage the file into the partial-dir and then rename it into place. */
+void finish_transfer(char *fname, char *fnametmp, char *partialptr,
+		     struct file_struct *file, int ok_to_set_time,
+		     int overwriting_basis)
 {
 	int ret;
 
 	if (inplace) {
 		if (verbose > 2)
-			rprintf(FINFO, "finishing %s\n", safe_fname(fname));
-		goto do_set_perms;
+			rprintf(FINFO, "finishing %s\n", fname);
+		fnametmp = fname;
+		goto do_set_file_attrs;
 	}
 
 	if (make_backups && overwriting_basis && !make_backup(fname))
 		return;
 
 	/* Change permissions before putting the file into place. */
-	set_perms(fnametmp, file, NULL, ok_to_set_time ? 0 : PERMS_SKIP_MTIME);
+	set_file_attrs(fnametmp, file, NULL,
+		       ok_to_set_time ? 0 : ATTRS_SKIP_MTIME);
 
 	/* move tmp file over real file */
-	if (verbose > 2) {
-		rprintf(FINFO, "renaming %s to %s\n",
-			safe_fname(fnametmp), safe_fname(fname));
-	}
-	ret = robust_rename(fnametmp, fname, file->mode & INITACCESSPERMS);
+	if (verbose > 2)
+		rprintf(FINFO, "renaming %s to %s\n", fnametmp, fname);
+	ret = robust_rename(fnametmp, fname, partialptr,
+			    file->mode & INITACCESSPERMS);
 	if (ret < 0) {
 		rsyserr(FERROR, errno, "%s %s -> \"%s\"",
-		    ret == -2 ? "copy" : "rename",
-		    full_fname(fnametmp), safe_fname(fname));
+			ret == -2 ? "copy" : "rename",
+			full_fname(fnametmp), fname);
 		do_unlink(fnametmp);
 		return;
 	}
 	if (ret == 0) {
 		/* The file was moved into place (not copied), so it's done. */
 		return;
 	}
-    do_set_perms:
-	set_perms(fname, file, NULL, ok_to_set_time ? 0 : PERMS_SKIP_MTIME);
+	/* The file was copied, so tweak the perms of the copied file.  If it
+	 * was copied to partialptr, move it into its final destination. */
+	fnametmp = partialptr ? partialptr : fname;
+
+  do_set_file_attrs:
+	set_file_attrs(fnametmp, file, NULL,
+		       ok_to_set_time ? 0 : ATTRS_SKIP_MTIME);
+
+	if (partialptr) {
+		if (do_rename(fnametmp, fname) < 0) {
+			rsyserr(FERROR, errno, "rename %s -> \"%s\"",
+				full_fname(fnametmp), fname);
+		} else
+			handle_partial_dir(partialptr, PDIR_DELETE);
+	}
 }
 
 const char *who_am_i(void)
 {
 	if (am_starting_up)
 		return am_server ? "server" : "client";
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsyncd.conf.5	2005-07-29 03:31:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsyncd.conf.5	2006-03-12 02:25:08.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsyncd\&.conf" "5" "28 Jul 2005" "" "" 
+.TH "rsyncd\&.conf" "5" "11 Mar 2006" "" "" 
 .SH "NAME" 
 rsyncd\&.conf \- configuration file for rsync in daemon mode
 .SH "SYNOPSIS" 
 .PP 
 rsyncd\&.conf
 .PP 
@@ -131,13 +131,14 @@
 .IP "\fBsocket options\fP" 
 This option can provide endless fun for people
 who like to tune their systems to the utmost degree\&. You can set all
 sorts of socket options which may make transfers faster (or
 slower!)\&. Read the man page for the setsockopt() system call for
 details on some of the options you may be able to set\&. By default no
-special socket options are set\&.
+special socket options are set\&.  These settings are superseded by the
+\fB--sockopts\fP command-line option\&.
 .IP 
 .PP 
 .SH "MODULE OPTIONS" 
 .PP 
 After the global options you should define a number of modules, each
 module exports a directory tree as a symbolic name\&. Modules are
@@ -178,13 +179,13 @@
 able to copy the IDs, just as if the \fB--numeric-ids\fP option had been
 specified\&.
 .IP 
 Note that you are free to setup user/group information in the chroot area
 differently from your normal system\&.  For example, you could abbreviate
 the list of users and groups\&.  Also, you can protect this information from
-being downloaded/uploaded by adding an exclude rule to the rsync\&.conf file
+being downloaded/uploaded by adding an exclude rule to the rsyncd\&.conf file
 (e\&.g\&. "exclude = /etc/**")\&.  Note that having the exclusion affect uploads
 is a relatively new feature in rsync, so make sure your daemon is
 at least 2\&.6\&.3 to effect this\&.  Also note that it is safest to exclude a
 directory and all its contents combining the rule "/some/dir/" with the
 rule "/some/dir/**" just to be sure that rsync will not allow deeper
 access to some of the excluded files inside the directory (rsync tries to
@@ -290,21 +291,42 @@
 The "include from" option specifies a filename
 on the daemon that contains include patterns, one per line\&. This is
 only superficially equivalent to the client specifying the
 \fB--include-from\fP option with a equivalent file\&.
 See the "exclude" option above\&.
 .IP 
+.IP "\fBincoming chmod\fP" 
+This option allows you to specify a set of
+comma-separated chmod strings that will affect the permissions of all
+incoming files (files that are being received by the daemon)\&.  These
+changes happen after all other permission calculations, and this will
+even override destination-default and/or existing permissions when the
+client does not specify \fB--perms\fP\&.
+See the description of the \fB--chmod\fP rsync option and the \fBchmod\fP(1)
+manpage for information on the format of this string\&.
+.IP 
+.IP "\fBoutgoing chmod\fP" 
+This option allows you to specify a set of
+comma-separated chmod strings that will affect the permissions of all
+outgoing files (files that are being sent out from the daemon)\&.  These
+changes happen first, making the sent permissions appear to be different
+than those stored in the filesystem itself\&.  For instance, you could
+disable group write permissions on the server while having it appear to
+be on to the clients\&.
+See the description of the \fB--chmod\fP rsync option and the \fBchmod\fP(1)
+manpage for information on the format of this string\&.
+.IP 
 .IP "\fBauth users\fP" 
 The "auth users" option specifies a comma and
 space-separated list of usernames that will be allowed to connect to
 this module\&. The usernames do not need to exist on the local
 system\&. The usernames may also contain shell wildcard characters\&. If
 "auth users" is set then the client will be challenged to supply a
 username and password to connect to the module\&. A challenge response
 authentication protocol is used for this exchange\&. The plain text
-usernames are passwords are stored in the file specified by the
+usernames and passwords are stored in the file specified by the
 "secrets file" option\&. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync")\&.
 .IP 
 See also the "CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL
 PROGRAM" section in rsync(1) for information on how handle an
 rsyncd\&.conf-level username that differs from the remote-shell-level
@@ -432,44 +454,49 @@
 rsyncstats\&.)
 .IP 
 The single-character escapes that are understood are as follows:
 .IP 
 .RS 
 .IP o 
-%h for the remote host name
+%a the remote IP address
 .IP o 
-%a for the remote IP address
+%b the number of bytes actually transferred 
 .IP o 
-%l for the length of the file in bytes
+%B the permission bits of the file (e\&.g\&. rwxrwxrwt)
 .IP o 
-%p for the process ID of this rsync session
+%c the checksum bytes received for this file (only when sending)
 .IP o 
-%o for the operation, which is "send", "recv", or "del\&."
-(the latter includes the trailing period)
+%f the filename (long form on sender; no trailing "/")
 .IP o 
-%f for the filename (long form on sender; no trailing "/")
+%G the gid of the file (decimal) or "DEFAULT"
 .IP o 
-%n for the filename (short form; trailing "/" on dir)
+%h the remote host name
 .IP o 
-%L either the string " -> SYMLINK", or " => HARDLINK" or an
-empty string (where \fBSYMLINK\fP or \fBHARDLINK\fP is a filename)
+%i an itemized list of what is being updated
 .IP o 
-%P for the module path
+%l the length of the file in bytes
 .IP o 
-%m for the module name
+%L the string " -> SYMLINK", " => HARDLINK", or "" (where \fBSYMLINK\fP or \fBHARDLINK\fP is a filename)
 .IP o 
-%t for the current date time
+%m the module name
 .IP o 
-%u for the authenticated username (or the null string)
+%M the last-modified time of the file
 .IP o 
-%b for the number of bytes actually transferred 
+%n the filename (short form; trailing "/" on dir)
 .IP o 
-%c when sending files this gives the number of checksum bytes
-received for this file
+%o the operation, which is "send", "recv", or "del\&." (the latter includes the trailing period)
 .IP o 
-%i an itemized list of what is being updated
+%p the process ID of this rsync session
+.IP o 
+%P the module path
+.IP o 
+%t the current date time
+.IP o 
+%u the authenticated username or an empty string
+.IP o 
+%U the uid of the file (decimal)
 .RE 
 .IP 
 For a list of what the characters mean that are output by "%i", see the
 \fB--itemize-changes\fP option in the rsync manpage\&.
 .IP 
 Note that some of the logged output changes when talking with older
@@ -519,21 +546,60 @@
 The "dont compress" option takes a space-separated list of
 case-insensitive wildcard patterns\&. Any source filename matching one
 of the patterns will not be compressed during transfer\&.
 .IP 
 The default setting is \f(CW*\&.gz *\&.tgz *\&.zip *\&.z *\&.rpm *\&.deb *\&.iso *\&.bz2 *\&.tbz\fP
 .IP 
+.IP "\fBpre-xfer exec\fP, \fBpost-xfer exec\fP" 
+You may specify a command to be run
+before and/or after the transfer\&.  If the \fBpre-xfer exec\fP command fails, the
+transfer is aborted before it begins\&.
+.IP 
+The following environment variables will be set, though some are
+specific to the pre-xfer or the post-xfer environment:
+.IP 
+.RS 
+.IP o 
+\fBRSYNC_MODULE_NAME\fP: The name of the module being accessed\&.
+.IP o 
+\fBRSYNC_MODULE_PATH\fP: The path configured for the module\&.
+.IP o 
+\fBRSYNC_HOST_ADDR\fP: The accessing host\&'s IP address\&.
+.IP o 
+\fBRSYNC_HOST_NAME\fP: The accessing host\&'s name\&.
+.IP o 
+\fBRSYNC_USER_NAME\fP: The accessing user\&'s name (empty if no user)\&.
+.IP o 
+\fBRSYNC_REQUEST\fP: (pre-xfer only) The module/path info specified
+by the user (note that the user can specify multiple source files,
+so the request can be something like "mod/path1 mod/path2", etc\&.)\&.
+.IP o 
+\fBRSYNC_ARG#\fP: (pre-xfer only) The pre-request arguments are set
+in these numbered values\&. RSYNC_ARG0 is always "rsyncd", and the last
+value contains a single period\&.
+.IP o 
+\fBRSYNC_EXIT_STATUS\fP: (post-xfer only) rsync\&'s exit value\&.  This will be 0 for a
+successful run, a positive value for an error that rsync returned
+(e\&.g\&. 23=partial xfer), or a -1 if rsync failed to exit properly\&.
+.IP o 
+\fBRSYNC_RAW_STATUS\fP: (post-xfer only) the raw exit value from waitpid()\&.
+.RE 
+.IP 
+Even though the commands can be associated with a particular module, they
+are run using the permissions of the user that started the daemon (not the
+module\&'s uid/gid setting) without any chroot restrictions\&.
+.IP 
 .PP 
 .SH "AUTHENTICATION STRENGTH" 
 .PP 
 The authentication protocol used in rsync is a 128 bit MD4 based
-challenge response system\&. Although I believe that no one has ever
-demonstrated a brute-force break of this sort of system you should
-realize that this is not a "military strength" authentication system\&.
-It should be good enough for most purposes but if you want really top
-quality security then I recommend that you run rsync over ssh\&.
+challenge response system\&. This is fairly weak protection, though (with
+at least one brute-force hash-finding algorithm publicly available), so
+if you want really top-quality security, then I recommend that you run
+rsync over ssh\&.  (Yes, a future version of rsync will switch over to a
+stronger hashing method\&.)
 .PP 
 Also note that the rsync daemon protocol does not currently provide any
 encryption of the data that is transferred over the connection\&. Only
 authentication is provided\&. Use ssh as the transport if you want
 encryption\&.
 .PP 
@@ -619,13 +685,13 @@
 .PP 
 Please report bugs! The rsync bug tracking system is online at
 http://rsync\&.samba\&.org/
 .PP 
 .SH "VERSION" 
 .PP 
-This man page is current for version 2\&.6\&.6 of rsync\&.
+This man page is current for version 2\&.6\&.7 of rsync\&.
 .PP 
 .SH "CREDITS" 
 .PP 
 rsync is distributed under the GNU public license\&.  See the file
 COPYING for details\&.
 .PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsyncd.conf.yo	2005-07-29 03:31:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsyncd.conf.yo	2006-03-12 02:25:04.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(28 Jul 2005)()()
+manpage(rsyncd.conf)(5)(11 Mar 2006)()()
 manpagename(rsyncd.conf)(configuration file for rsync in daemon mode)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -113,13 +113,14 @@
 
 dit(bf(socket options)) This option can provide endless fun for people
 who like to tune their systems to the utmost degree. You can set all
 sorts of socket options which may make transfers faster (or
 slower!). Read the man page for the setsockopt() system call for
 details on some of the options you may be able to set. By default no
-special socket options are set.
+special socket options are set.  These settings are superseded by the
+bf(--sockopts) command-line option.
 
 enddit()
 
 
 manpagesection(MODULE OPTIONS)
 
@@ -160,13 +161,13 @@
 able to copy the IDs, just as if the bf(--numeric-ids) option had been
 specified.
 
 Note that you are free to setup user/group information in the chroot area
 differently from your normal system.  For example, you could abbreviate
 the list of users and groups.  Also, you can protect this information from
-being downloaded/uploaded by adding an exclude rule to the rsync.conf file
+being downloaded/uploaded by adding an exclude rule to the rsyncd.conf file
 (e.g. "exclude = /etc/**").  Note that having the exclusion affect uploads
 is a relatively new feature in rsync, so make sure your daemon is
 at least 2.6.3 to effect this.  Also note that it is safest to exclude a
 directory and all its contents combining the rule "/some/dir/" with the
 rule "/some/dir/**" just to be sure that rsync will not allow deeper
 access to some of the excluded files inside the directory (rsync tries to
@@ -259,20 +260,39 @@
 dit(bf(include from)) The "include from" option specifies a filename
 on the daemon that contains include patterns, one per line. This is
 only superficially equivalent to the client specifying the
 bf(--include-from) option with a equivalent file.
 See the "exclude" option above.
 
+dit(bf(incoming chmod)) This option allows you to specify a set of
+comma-separated chmod strings that will affect the permissions of all
+incoming files (files that are being received by the daemon).  These
+changes happen after all other permission calculations, and this will
+even override destination-default and/or existing permissions when the
+client does not specify bf(--perms).
+See the description of the bf(--chmod) rsync option and the bf(chmod)(1)
+manpage for information on the format of this string.
+
+dit(bf(outgoing chmod)) This option allows you to specify a set of
+comma-separated chmod strings that will affect the permissions of all
+outgoing files (files that are being sent out from the daemon).  These
+changes happen first, making the sent permissions appear to be different
+than those stored in the filesystem itself.  For instance, you could
+disable group write permissions on the server while having it appear to
+be on to the clients.
+See the description of the bf(--chmod) rsync option and the bf(chmod)(1)
+manpage for information on the format of this string.
+
 dit(bf(auth users)) The "auth users" option specifies a comma and
 space-separated list of usernames that will be allowed to connect to
 this module. The usernames do not need to exist on the local
 system. The usernames may also contain shell wildcard characters. If
 "auth users" is set then the client will be challenged to supply a
 username and password to connect to the module. A challenge response
 authentication protocol is used for this exchange. The plain text
-usernames are passwords are stored in the file specified by the
+usernames and passwords are stored in the file specified by the
 "secrets file" option. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync").
 
 See also the "CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL
 PROGRAM" section in rsync(1) for information on how handle an
 rsyncd.conf-level username that differs from the remote-shell-level
@@ -383,30 +403,31 @@
 in the rsync source code distribution in the "support" subdirectory:
 rsyncstats.)
 
 The single-character escapes that are understood are as follows:
 
 quote(itemize(
-  it() %h for the remote host name
-  it() %a for the remote IP address
-  it() %l for the length of the file in bytes
-  it() %p for the process ID of this rsync session
-  it() %o for the operation, which is "send", "recv", or "del."
-  (the latter includes the trailing period)
-  it() %f for the filename (long form on sender; no trailing "/")
-  it() %n for the filename (short form; trailing "/" on dir)
-  it() %L either the string " -> SYMLINK", or " => HARDLINK" or an
-  empty string (where bf(SYMLINK) or bf(HARDLINK) is a filename)
-  it() %P for the module path
-  it() %m for the module name
-  it() %t for the current date time
-  it() %u for the authenticated username (or the null string)
-  it() %b for the number of bytes actually transferred 
-  it() %c when sending files this gives the number of checksum bytes
-    received for this file
+  it() %a the remote IP address
+  it() %b the number of bytes actually transferred 
+  it() %B the permission bits of the file (e.g. rwxrwxrwt)
+  it() %c the checksum bytes received for this file (only when sending)
+  it() %f the filename (long form on sender; no trailing "/")
+  it() %G the gid of the file (decimal) or "DEFAULT"
+  it() %h the remote host name
   it() %i an itemized list of what is being updated
+  it() %l the length of the file in bytes
+  it() %L the string " -> SYMLINK", " => HARDLINK", or "" (where bf(SYMLINK) or bf(HARDLINK) is a filename)
+  it() %m the module name
+  it() %M the last-modified time of the file
+  it() %n the filename (short form; trailing "/" on dir)
+  it() %o the operation, which is "send", "recv", or "del." (the latter includes the trailing period)
+  it() %p the process ID of this rsync session
+  it() %P the module path
+  it() %t the current date time
+  it() %u the authenticated username or an empty string
+  it() %U the uid of the file (decimal)
 ))
 
 For a list of what the characters mean that are output by "%i", see the
 bf(--itemize-changes) option in the rsync manpage.
 
 Note that some of the logged output changes when talking with older
@@ -451,22 +472,51 @@
 The "dont compress" option takes a space-separated list of
 case-insensitive wildcard patterns. Any source filename matching one
 of the patterns will not be compressed during transfer.
 
 The default setting is tt(*.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz)
 
+dit(bf(pre-xfer exec), bf(post-xfer exec)) You may specify a command to be run
+before and/or after the transfer.  If the bf(pre-xfer exec) command fails, the
+transfer is aborted before it begins.
+
+The following environment variables will be set, though some are
+specific to the pre-xfer or the post-xfer environment:
+
+quote(itemize(
+  it() bf(RSYNC_MODULE_NAME): The name of the module being accessed.
+  it() bf(RSYNC_MODULE_PATH): The path configured for the module.
+  it() bf(RSYNC_HOST_ADDR): The accessing host's IP address.
+  it() bf(RSYNC_HOST_NAME): The accessing host's name.
+  it() bf(RSYNC_USER_NAME): The accessing user's name (empty if no user).
+  it() bf(RSYNC_REQUEST): (pre-xfer only) The module/path info specified
+  by the user (note that the user can specify multiple source files,
+  so the request can be something like "mod/path1 mod/path2", etc.).
+  it() bf(RSYNC_ARG#): (pre-xfer only) The pre-request arguments are set
+  in these numbered values. RSYNC_ARG0 is always "rsyncd", and the last
+  value contains a single period.
+  it() bf(RSYNC_EXIT_STATUS): (post-xfer only) rsync's exit value.  This will be 0 for a
+  successful run, a positive value for an error that rsync returned
+  (e.g. 23=partial xfer), or a -1 if rsync failed to exit properly.
+  it() bf(RSYNC_RAW_STATUS): (post-xfer only) the raw exit value from waitpid().
+))
+
+Even though the commands can be associated with a particular module, they
+are run using the permissions of the user that started the daemon (not the
+module's uid/gid setting) without any chroot restrictions.
+
 enddit()
 
 manpagesection(AUTHENTICATION STRENGTH)
 
 The authentication protocol used in rsync is a 128 bit MD4 based
-challenge response system. Although I believe that no one has ever
-demonstrated a brute-force break of this sort of system you should
-realize that this is not a "military strength" authentication system.
-It should be good enough for most purposes but if you want really top
-quality security then I recommend that you run rsync over ssh.
+challenge response system. This is fairly weak protection, though (with
+at least one brute-force hash-finding algorithm publicly available), so
+if you want really top-quality security, then I recommend that you run
+rsync over ssh.  (Yes, a future version of rsync will switch over to a
+stronger hashing method.)
 
 Also note that the rsync daemon protocol does not currently provide any
 encryption of the data that is transferred over the connection. Only
 authentication is provided. Use ssh as the transport if you want
 encryption.
 
@@ -538,13 +588,13 @@
 
 Please report bugs! The rsync bug tracking system is online at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 2.6.6 of rsync.
+This man page is current for version 2.6.7 of rsync.
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsync.h	2005-05-04 01:00:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.h	2006-02-28 05:11:56.000000000 +0800
@@ -55,18 +55,18 @@
 #define XMIT_SAME_DEV (1<<10)
 #define XMIT_RDEV_MINOR_IS_SMALL (1<<11)
 
 /* These flags are used in the live flist data. */
 
 #define FLAG_TOP_DIR (1<<0)
+#define FLAG_SENT (1<<1)	/* sender */
 #define FLAG_HLINK_EOL (1<<1)	/* receiver/generator */
-#define FLAG_MOUNT_POINT (1<<2)	/* sender */
-#define FLAG_NO_FUZZY (1<<2)	/* generator */
+#define FLAG_MOUNT_POINT (1<<2)	/* sender/generator */
 #define FLAG_DEL_HERE (1<<3)	/* receiver/generator */
-#define FLAG_SENT (1<<3)	/* sender */
 #define FLAG_HLINK_TOL (1<<4)	/* receiver/generator */
+#define FLAG_NO_FUZZY (1<<5)	/* generator */
 
 /* update this if you make incompatible changes */
 #define PROTOCOL_VERSION 29
 
 /* We refuse to interoperate with versions that are not in this range.
  * Note that we assume we'll work with later versions: the onus is on
@@ -112,15 +112,16 @@
 #define SERVER_FILTERS	1
 #define ALL_FILTERS	2
 
 #define XFLG_FATAL_ERRORS	(1<<0)
 #define XFLG_OLD_PREFIXES	(1<<1)
 #define XFLG_ANCHORED2ABS	(1<<2)
+#define XFLG_ABS_IF_SLASH	(1<<3)
 
-#define PERMS_REPORT		(1<<0)
-#define PERMS_SKIP_MTIME	(1<<1)
+#define ATTRS_REPORT		(1<<0)
+#define ATTRS_SKIP_MTIME	(1<<1)
 
 #define FULL_FLUSH	1
 #define NORMAL_FLUSH	0
 
 #define PDIR_CREATE	1
 #define PDIR_DELETE	0
@@ -130,17 +131,12 @@
 #define FNAMECMP_BASIS_DIR_HIGH 0x7F
 #define FNAMECMP_FNAME		0x80
 #define FNAMECMP_PARTIAL_DIR	0x81
 #define FNAMECMP_BACKUP 	0x82
 #define FNAMECMP_FUZZY		0x83
 
-/* For calling delete_file() */
-#define DEL_NO_RECURSE		(1<<1)
-#define DEL_FORCE_RECURSE	(1<<2) /* recurse even w/o --force */
-#define DEL_TERSE		(1<<3)
-
 /* For use by the itemize_changes code */
 #define ITEM_REPORT_CHECKSUM (1<<1)
 #define ITEM_REPORT_SIZE (1<<2)
 #define ITEM_REPORT_TIME (1<<3)
 #define ITEM_REPORT_PERMS (1<<4)
 #define ITEM_REPORT_OWNER (1<<5)
@@ -149,30 +145,30 @@
 #define ITEM_BASIS_TYPE_FOLLOWS (1<<11)
 #define ITEM_XNAME_FOLLOWS (1<<12)
 #define ITEM_IS_NEW (1<<13)
 #define ITEM_LOCAL_CHANGE (1<<14)
 #define ITEM_TRANSFER (1<<15)
 /* These are outside the range of the transmitted flags. */
-#define ITEM_NO_DEST_AND_NO_UPDATE (1<<16) /* used by itemize() */
 #define ITEM_MISSING_DATA (1<<16)	   /* used by log_formatted() */
 #define ITEM_DELETED (1<<17)		   /* used by log_formatted() */
 
 #define SIGNIFICANT_ITEM_FLAGS (~(\
 	ITEM_BASIS_TYPE_FOLLOWS | ITEM_XNAME_FOLLOWS | ITEM_LOCAL_CHANGE))
 
 
-/* Log-message categories.  FLOG and FCLIENT are only used on the daemon
- * side for custom logging -- they don't get sent over the socket. */
-enum logcode { FERROR=1, FINFO=2, FLOG=3, FCLIENT=4 };
+/* Log-message categories.  Only FERROR and FINFO get sent over the socket.
+ * FLOG and FCLIENT are only used on the daemon side for custom logging,
+ * while FNAME is only used on the client side. */
+enum logcode { FERROR=1, FINFO=2, FLOG=3, FCLIENT=4, FNAME=5, FSOCKERR=6 };
 
 /* Messages types that are sent over the message channel.  The logcode
  * values must all be present here with identical numbers. */
 enum msgcode {
 	MSG_DATA=0,	/* raw data on the multiplexed stream */
 	MSG_ERROR=FERROR, MSG_INFO=FINFO, /* remote logging */
-	MSG_LOG=FLOG, MSG_FCLIENT=FCLIENT, /* sibling logging */
+	MSG_LOG=FLOG, MSG_SOCKERR=FSOCKERR, /* sibling logging */
 	MSG_REDO=9,	/* reprocess indicated flist index */
 	MSG_SUCCESS=100,/* successfully updated indicated flist index */
 	MSG_DELETED=101,/* successfully deleted a file on receiving side */
 	MSG_DONE=86	/* current phase is done */
 };
 
@@ -316,12 +312,16 @@
 #endif
 
 #ifdef HAVE_COMPAT_H
 #include <compat.h>
 #endif
 
+#ifdef HAVE_LIMITS_H
+# include <limits.h>
+#endif
+
 #include <assert.h>
 
 #include "lib/pool_alloc.h"
 
 #define BOOL int
 
@@ -460,12 +460,20 @@
 #define BLOCKSUM_BIAS 10
 
 #ifndef MAXPATHLEN
 #define MAXPATHLEN 1024
 #endif
 
+/* We want a roomy line buffer that can hold more than MAXPATHLEN,
+ * and significantly more than an overly short MAXPATHLEN. */
+#if MAXPATHLEN < 4096
+#define BIGPATHBUFLEN (4096+1024)
+#else
+#define BIGPATHBUFLEN (MAXPATHLEN+1024)
+#endif
+
 #ifndef NAME_MAX
 #define NAME_MAX 255
 #endif
 
 #ifndef INADDR_NONE
 #define INADDR_NONE 0xffffffff
@@ -549,12 +557,13 @@
 #define SUMFLG_SAME_OFFSET	(1<<0)
 
 struct sum_buf {
 	OFF_T offset;		/**< offset in file of this chunk */
 	int32 len;		/**< length of chunk of file */
 	uint32 sum1;	        /**< simple checksum */
+	int32 chain;		/**< next hash-table collision */
 	short flags;		/**< flag bits */
 	char sum2[SUM_LENGTH];	/**< checksum  */
 };
 
 struct sum_struct {
 	OFF_T flength;		/**< total file length */
@@ -576,28 +585,29 @@
 	int fd;			/* File Descriptor			*/
 	int status;		/* first errno from read errors		*/
 };
 
 #define MATCHFLG_WILD		(1<<0) /* pattern has '*', '[', and/or '?' */
 #define MATCHFLG_WILD2		(1<<1) /* pattern has '**' */
-#define MATCHFLG_WILD2_PREFIX	(1<<2) /* pattern starts with '**' */
-#define MATCHFLG_ABS_PATH	(1<<3) /* path-match on absolute path */
-#define MATCHFLG_INCLUDE	(1<<4) /* this is an include, not an exclude */
-#define MATCHFLG_DIRECTORY	(1<<5) /* this matches only directories */
-#define MATCHFLG_CLEAR_LIST 	(1<<6) /* this item is the "!" token */
+#define MATCHFLG_WILD2_PREFIX	(1<<2) /* pattern starts with "**" */
+#define MATCHFLG_WILD3_SUFFIX	(1<<3) /* pattern ends with "***" */
+#define MATCHFLG_ABS_PATH	(1<<4) /* path-match on absolute path */
+#define MATCHFLG_INCLUDE	(1<<5) /* this is an include, not an exclude */
+#define MATCHFLG_DIRECTORY	(1<<6) /* this matches only directories */
 #define MATCHFLG_WORD_SPLIT	(1<<7) /* split rules on whitespace */
 #define MATCHFLG_NO_INHERIT	(1<<8) /* don't inherit these rules */
 #define MATCHFLG_NO_PREFIXES	(1<<9) /* parse no prefixes from patterns */
 #define MATCHFLG_MERGE_FILE	(1<<10)/* specifies a file to merge */
 #define MATCHFLG_PERDIR_MERGE	(1<<11)/* merge-file is searched per-dir */
 #define MATCHFLG_EXCLUDE_SELF	(1<<12)/* merge-file name should be excluded */
 #define MATCHFLG_FINISH_SETUP	(1<<13)/* per-dir merge file needs setup */
 #define MATCHFLG_NEGATE 	(1<<14)/* rule matches when pattern does not */
 #define MATCHFLG_CVS_IGNORE	(1<<15)/* rule was -C or :C */
 #define MATCHFLG_SENDER_SIDE	(1<<16)/* rule applies to the sending side */
 #define MATCHFLG_RECEIVER_SIDE	(1<<17)/* rule applies to the receiving side */
+#define MATCHFLG_CLEAR_LIST 	(1<<18)/* this item is the "!" token */
 
 #define MATCHFLGS_FROM_CONTAINER (MATCHFLG_ABS_PATH | MATCHFLG_INCLUDE \
 				| MATCHFLG_DIRECTORY | MATCHFLG_SENDER_SIDE \
 				| MATCHFLG_NEGATE | MATCHFLG_RECEIVER_SIDE)
 
 struct filter_struct {
@@ -628,19 +638,29 @@
 	int flist_size;
 	int num_files;
 	int num_transferred_files;
 	int current_file_index;
 };
 
+struct chmod_mode_struct;
 
 #include "byteorder.h"
 #include "lib/mdfour.h"
 #include "lib/wildmatch.h"
 #include "lib/permstring.h"
 #include "lib/addrinfo.h"
 
+#if !defined __GNUC__ || defined __APPLE__
+/* Apparently the OS X port of gcc gags on __attribute__.
+ *
+ * <http://www.opensource.apple.com/bugs/X/gcc/2512150.html> */
+#define __attribute__(x)
+#endif
+
+#define UNUSED(x) x __attribute__((__unused__))
+
 #include "proto.h"
 
 /* We have replacement versions of these if they're missing. */
 #ifndef HAVE_ASPRINTF
 int asprintf(char **ptr, const char *format, ...);
 #endif
@@ -678,13 +698,18 @@
 #define SUPPORT_LINKS 1
 #endif
 #ifdef HAVE_LINK
 #define SUPPORT_HARD_LINKS 1
 #endif
 
-#define SIGNAL_CAST (RETSIGTYPE (*)())
+#ifdef HAVE_SIGACTION
+#define SIGACTION(n,h) sigact.sa_handler=(h), sigaction((n),&sigact,NULL)
+#define signal(n,h) we_need_to_call_SIGACTION_not_signal(n,h)
+#else
+#define SIGACTION(n,h) signal(n,h)
+#endif
 
 #ifndef EWOULDBLOCK
 #define EWOULDBLOCK EAGAIN
 #endif
 
 #ifndef STDIN_FILENO
@@ -775,29 +800,22 @@
 #endif
 
 #ifndef INADDR_NONE
 #define INADDR_NONE 0xffffffff
 #endif
 
-#define IS_DEVICE(mode) (S_ISCHR(mode) || S_ISBLK(mode) || S_ISSOCK(mode) || S_ISFIFO(mode))
+#define IS_SPECIAL(mode) (S_ISSOCK(mode) || S_ISFIFO(mode))
+#define IS_DEVICE(mode) (S_ISCHR(mode) || S_ISBLK(mode))
 
 /* Initial mask on permissions given to temporary files.  Mask off setuid
      bits and group access because of potential race-condition security
      holes, and mask other access because mode 707 is bizarre */
 #define INITACCESSPERMS 0700
 
 /* handler for null strings in printf format */
-#define NS(s) ((s)?safe_fname(s):"<NULL>")
-
-#if !defined __GNUC__ || defined __APPLE__
-/* Apparently the OS X port of gcc gags on __attribute__.
- *
- * <http://www.opensource.apple.com/bugs/X/gcc/2512150.html> */
-#define __attribute__(x)
-
-#endif
+#define NS(s) ((s)?(s):"<NULL>")
 
 /* Convenient wrappers for malloc and realloc.  Use them. */
 #define new(type) ((type *)malloc(sizeof(type)))
 #define new_array(type, num) ((type *)_new_array(sizeof(type), (num)))
 #define realloc_array(ptr, type, num) ((type *)_realloc_array((ptr), sizeof(type), (num)))
 
@@ -857,10 +875,6 @@
 int inet_pton(int af, const char *src, void *dst);
 #endif
 
 #ifdef MAINTAINER_MODE
 const char *get_panic_action(void);
 #endif
-
-#define UNUSED(x) x __attribute__((__unused__))
-
-extern const char *io_write_phase, *io_read_phase;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/rsync.yo	2005-07-29 03:31:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/rsync.yo	2006-03-12 02:25:04.000000000 +0800
@@ -1,24 +1,26 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(28 Jul 2005)()()
+manpage(rsync)(1)(11 Mar 2006)()()
 manpagename(rsync)(faster, flexible replacement for rcp)
 manpagesynopsis()
 
+rsync [OPTION]... SRC [SRC]... DEST
+
 rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
 
-rsync [OPTION]... [USER@]HOST:SRC [DEST]
+rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST
 
-rsync [OPTION]... SRC [SRC]... DEST
+rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST
 
-rsync [OPTION]... [USER@]HOST::SRC [DEST]
+rsync [OPTION]... SRC
 
-rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST
+rsync [OPTION]... [USER@]HOST:SRC [DEST]
 
-rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
+rsync [OPTION]... [USER@]HOST::SRC [DEST]
 
-rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST
+rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
 
 manpagedescription()
 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speed up file transfers when the destination file is being
@@ -33,13 +35,13 @@
 
 itemize(
   it() support for copying links, devices, owners, groups, and permissions
   it() exclude and exclude-from options similar to GNU tar
   it() a CVS exclude mode for ignoring the same files that CVS would ignore
   it() can use any transparent remote shell, including ssh or rsh
-  it() does not require root privileges
+  it() does not require super-user privileges
   it() pipelining of file transfers to minimize latency costs
   it() support for anonymous or authenticated rsync daemons (ideal for
        mirroring)
 )
 
 manpagesection(GENERAL)
@@ -54,14 +56,14 @@
 a host specification.  Contacting an rsync daemon directly happens when the
 source or destination path contains a double colon (::) separator after a
 host specification, OR when an rsync:// URL is specified (see also the
 "USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION" section for
 an exception to this latter rule).
 
-As a special case, if a remote source is specified without a destination,
-the remote files are listed in an output format similar to "ls -l".
+As a special case, if a single source arg is specified without a
+destination, the files are listed in an output format similar to "ls -l".
 
 As expected, if neither the source or destination path specify a remote
 host, the copy occurs locally (see also the bf(--list-only) option).
 
 manpagesection(SETUP)
 
@@ -73,15 +75,12 @@
 for its communications, but it may have been configured to use a
 different remote shell by default, such as rsh or remsh.
 
 You can also specify any remote shell you like, either by using the bf(-e)
 command line option, or by setting the RSYNC_RSH environment variable.
 
-One common substitute is to use ssh, which offers a high degree of
-security.
-
 Note that rsync must be installed on both the source and destination
 machines.
 
 manpagesection(USAGE)
 
 You use rsync in the same way you use rcp. You must specify a source
@@ -132,16 +131,18 @@
 )
 
 You can also use rsync in local-only mode, where both the source and
 destination don't have a ':' in the name. In this case it behaves like
 an improved copy command.
 
+Finally, you can list all the (listable) modules available from a
+particular rsync daemon by leaving off the module name:
+
 quote(tt(rsync somehost.mydomain.com::))
 
-This would list all the anonymous rsync modules available on the host
-somehost.mydomain.com.  (See the following section for more details.)
+See the following section for more details.
 
 manpagesection(ADVANCED USAGE)
 
 The syntax for requesting multiple files from a remote host involves using
 quoted spaces in the SRC.  Some examples:
 
@@ -181,19 +182,20 @@
 Using rsync in this way is the same as using it with a remote shell except
 that:
 
 itemize(
 	it() you either use a double colon :: instead of a single colon to
 	separate the hostname from the path, or you use an rsync:// URL.
-	it() the first word after the :: is a module name.
+	it() the first word of the "path" is actually a module name.
 	it() the remote daemon may print a message of the day when you
 	connect.
 	it() if you specify no path name on the remote daemon then the
 	list of accessible paths on the daemon will be shown.
 	it() if you specify no local destination then a listing of the
 	specified files on the remote daemon is provided.
+	it() you must not specify the bf(--rsh) (bf(-e)) option.
 )
 
 An example that copies all the files in a remote module named "src":
 
 verb(    rsync -av host::src /dest)
 
@@ -235,13 +237,14 @@
 
 verb(    rsync -av --rsh=ssh host::module /dest)
 
 If you need to specify a different remote-shell user, keep in mind that the
 user@ prefix in front of the host is specifying the rsync-user value (for a
 module that requires user-based authentication).  This means that you must
-give the '-l user' option to ssh when specifying the remote-shell:
+give the '-l user' option to ssh when specifying the remote-shell, as in
+this example that uses the short version of the bf(--rsh) option:
 
 verb(    rsync -av -e "ssh -l ssh-user" rsync-user@host::module /dest)
 
 The "ssh-user" will be used at the ssh level; the "rsync-user" will be
 used to log-in to the "module".
 
@@ -295,84 +298,95 @@
 Here is a short summary of the options available in rsync. Please refer
 to the detailed description below for a complete description.  verb(
  -v, --verbose               increase verbosity
  -q, --quiet                 suppress non-error messages
  -c, --checksum              skip based on checksum, not mod-time & size
  -a, --archive               archive mode; same as -rlptgoD (no -H)
+     --no-OPTION             turn off an implied OPTION (e.g. --no-D)
  -r, --recursive             recurse into directories
  -R, --relative              use relative path names
-     --no-relative           turn off --relative
-     --no-implied-dirs       don't send implied dirs with -R
+     --no-implied-dirs       don't send implied dirs with --relative
  -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir=DIR        make backups into hierarchy based in DIR
      --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                skip files that are newer on the receiver
      --inplace               update destination files in-place
+     --append                append data onto shorter files
  -d, --dirs                  transfer directories without recursing
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            transform symlink into referent file/dir
      --copy-unsafe-links     only "unsafe" symlinks are transformed
      --safe-links            ignore symlinks that point outside the tree
- -H, --hard-links            preserve hard links
+ -k, --copy-dirlinks         transform symlink to dir into referent dir
  -K, --keep-dirlinks         treat symlinked dir on receiver as dir
+ -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
- -o, --owner                 preserve owner (root only)
+ -E, --executability         preserve executability
+     --chmod=CHMOD           change destination permissions
+ -o, --owner                 preserve owner (super-user only)
  -g, --group                 preserve group
- -D, --devices               preserve devices (root only)
+     --devices               preserve device files (super-user only)
+     --specials              preserve special files
+ -D                          same as --devices --specials
  -t, --times                 preserve times
  -O, --omit-dir-times        omit directories when preserving times
+     --super                 receiver attempts super-user activities
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy files whole (without rsync algorithm)
-     --no-whole-file         always use incremental rsync algorithm
  -x, --one-file-system       don't cross filesystem boundaries
  -B, --block-size=SIZE       force a fixed checksum block-size
  -e, --rsh=COMMAND           specify the remote shell to use
      --rsync-path=PROGRAM    specify the rsync to run on remote machine
-     --existing              only update files that already exist
+     --existing              ignore non-existing files on receiving side
      --ignore-existing       ignore files that already exist on receiver
      --remove-sent-files     sent files/symlinks are removed from sender
      --del                   an alias for --delete-during
      --delete                delete files that don't exist on sender
      --delete-before         receiver deletes before transfer (default)
      --delete-during         receiver deletes during xfer, not before
      --delete-after          receiver deletes after transfer, not before
      --delete-excluded       also delete excluded files on receiver
      --ignore-errors         delete even if there are I/O errors
      --force                 force deletion of dirs even if not empty
      --max-delete=NUM        don't delete more than NUM files
      --max-size=SIZE         don't transfer any file larger than SIZE
+     --min-size=SIZE         don't transfer any file smaller than SIZE
      --partial               keep partially transferred files
      --partial-dir=DIR       put a partially transferred file into DIR
      --delay-updates         put all updated files into place at end
+ -m, --prune-empty-dirs      prune empty directory chains from file-list
      --numeric-ids           don't map uid/gid values by user/group name
      --timeout=TIME          set I/O timeout in seconds
  -I, --ignore-times          don't skip files that match size and time
      --size-only             skip files that match in size
      --modify-window=NUM     compare mod-times with reduced accuracy
  -T, --temp-dir=DIR          create temporary files in directory DIR
  -y, --fuzzy                 find similar file for basis if no dest file
      --compare-dest=DIR      also compare received files relative to DIR
      --copy-dest=DIR         ... and include copies of unchanged files
      --link-dest=DIR         hardlink to files in DIR when unchanged
  -z, --compress              compress file data during the transfer
+     --compress-level=NUM    explicitly set compression level
  -C, --cvs-exclude           auto-ignore files in the same way CVS does
  -f, --filter=RULE           add a file-filtering RULE
  -F                          same as --filter='dir-merge /.rsync-filter'
                              repeated: --filter='- .rsync-filter'
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     read exclude patterns from FILE
      --include=PATTERN       don't exclude files matching PATTERN
      --include-from=FILE     read include patterns from FILE
      --files-from=FILE       read list of source-file names from FILE
  -0, --from0                 all *from/filter files are delimited by 0s
      --address=ADDRESS       bind address for outgoing socket to daemon
      --port=PORT             specify double-colon alternate port number
+     --sockopts=OPTIONS      specify custom TCP options
      --blocking-io           use blocking I/O for the remote shell
-     --no-blocking-io        turn off blocking I/O when it is default
      --stats                 give some file-transfer stats
+ -8, --8-bit-output          leave high-bit chars unescaped in output
+ -h, --human-readable        output numbers in a human-readable format
      --progress              show progress during transfer
  -P                          same as --partial --progress
  -i, --itemize-changes       output a change-summary for all updates
      --log-format=FORMAT     output filenames using the specified format
      --password-file=FILE    read password from FILE
      --list-only             list the files instead of copying them
@@ -382,38 +396,43 @@
      --read-batch=FILE       read a batched update from FILE
      --protocol=NUM          force an older protocol version to be used
      --checksum-seed=NUM     set block/file checksum seed (advanced)
  -4, --ipv4                  prefer IPv4
  -6, --ipv6                  prefer IPv6
      --version               print version number
- -h, --help                  show this help screen)
+(-h) --help                  show this help (see below for -h comment)
+)
 
 Rsync can also be run as a daemon, in which case the following options are
 accepted: verb(
      --daemon                run as an rsync daemon
      --address=ADDRESS       bind to the specified address
      --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
      --config=FILE           specify alternate rsyncd.conf file
      --no-detach             do not detach from the parent
      --port=PORT             listen on alternate port number
+     --sockopts=OPTIONS      specify custom TCP options
  -v, --verbose               increase verbosity
  -4, --ipv4                  prefer IPv4
  -6, --ipv6                  prefer IPv6
- -h, --help                  show this help screen)
+ -h, --help                  show this help (if used after --daemon)
+)
 
 manpageoptions()
 
 rsync uses the GNU long options package. Many of the command line
 options have two variants, one short and one long.  These are shown
 below, separated by commas. Some options only have a long variant.
 The '=' for options that take a parameter is optional; whitespace
 can be used instead.
 
 startdit()
-dit(bf(-h, --help)) Print a short help page describing the options
-available in rsync.
+dit(bf(--help)) Print a short help page describing the options
+available in rsync and exit.  For backward-compatibility with older
+versions of rsync, the help will also be output if you use the bf(-h)
+option without any other args.
 
 dit(bf(--version)) print the rsync version number and exit.
 
 dit(bf(-v, --verbose)) This option increases the amount of information you
 are given during the transfer.  By default, rsync works silently. A
 single bf(-v) will give you information about what files are being
@@ -452,75 +471,143 @@
 value.  This is normally 0 (for an exact match), but you may find it useful
 to set this to a larger value in some situations.  In particular, when
 transferring to or from an MS Windows FAT filesystem (which represents
 times with a 2-second resolution), bf(--modify-window=1) is useful
 (allowing times to differ by up to 1 second).
 
-dit(bf(-c, --checksum)) This forces the sender to checksum all files using
-a 128-bit MD4 checksum before transfer. The checksum is then
-explicitly checked on the receiver and any files of the same name
-which already exist and have the same checksum and size on the
-receiver are not transferred.  This option can be quite slow.
+dit(bf(-c, --checksum)) This forces the sender to checksum em(every)
+regular file using a 128-bit MD4 checksum.  It does this during the initial
+file-system scan as it builds the list of all available files. The receiver
+then checksums its version of each file (if it exists and it has the same
+size as its sender-side counterpart) in order to decide which files need to
+be updated: files with either a changed size or a changed checksum are
+selected for transfer.  Since this whole-file checksumming of all files on
+both sides of the connection occurs in addition to the automatic checksum
+verifications that occur during a file's transfer, this option can be quite
+slow.
+
+Note that rsync always verifies that each em(transferred) file was correctly
+reconstructed on the receiving side by checking its whole-file checksum, but
+that automatic after-the-transfer verification has nothing to do with this
+option's before-the-transfer "Does this file need to be updated?" check.
 
 dit(bf(-a, --archive)) This is equivalent to bf(-rlptgoD). It is a quick
 way of saying you want recursion and want to preserve almost
-everything.  The only exception to this is if bf(--files-from) was
+everything (with -H being a notable omission).
+The only exception to the above equivalence is when bf(--files-from) is
 specified, in which case bf(-r) is not implied.
 
 Note that bf(-a) bf(does not preserve hardlinks), because
 finding multiply-linked files is expensive.  You must separately
 specify bf(-H).
 
+dit(--no-OPTION) You may turn off one or more implied options by prefixing
+the option name with "no-".  Not all options may be prefixed with a "no-":
+only options that are implied by other options (e.g. bf(--no-D),
+bf(--no-perms)) or have different defaults in various circumstances
+(e.g. bf(--no-whole-file), bf(--no-blocking-io), bf(--no-dirs)).  You may
+specify either the short or the long option name after the "no-" prefix
+(e.g. bf(--no-R) is the same as bf(--no-relative)).
+
+For example: if you want to use bf(-a) (bf(--archive)) but don't want
+bf(-o) (bf(--owner)), instead of converting bf(-a) into bf(-rlptgD), you
+could specify bf(-a --no-o) (or bf(-a --no-owner)).
+
+The order of the options is important:  if you specify bf(--no-r -a), the
+bf(-r) option would end up being turned on, the opposite of bf(-a --no-r).
+Note also that the side-effects of the bf(--files-from) option are NOT
+positional, as it affects the default state of several options and slightly
+changes the meaning of bf(-a) (see the bf(--files-from) option for more
+details).
+
 dit(bf(-r, --recursive)) This tells rsync to copy directories
 recursively.  See also bf(--dirs) (bf(-d)).
 
 dit(bf(-R, --relative)) Use relative paths. This means that the full path
 names specified on the command line are sent to the server rather than
 just the last parts of the filenames. This is particularly useful when
 you want to send several different directories at the same time. For
-example, if you used the command
+example, if you used this command:
 
-quote(tt(   rsync /foo/bar/foo.c remote:/tmp/))
+quote(tt(   rsync -av /foo/bar/baz.c remote:/tmp/))
 
-then this would create a file called foo.c in /tmp/ on the remote
+... this would create a file named baz.c in /tmp/ on the remote
 machine. If instead you used
 
-quote(tt(   rsync -R /foo/bar/foo.c remote:/tmp/))
+quote(tt(   rsync -avR /foo/bar/baz.c remote:/tmp/))
 
-then a file called /tmp/foo/bar/foo.c would be created on the remote
+then a file named /tmp/foo/bar/baz.c would be created on the remote
 machine -- the full path name is preserved.  To limit the amount of
-path information that is sent, do something like this:
+path information that is sent, you have a couple options:  (1) With
+a modern rsync on the sending side (beginning with 2.6.7), you can
+insert a dot and a slash into the source path, like this:
+
+quote(tt(   rsync -avR /foo/./bar/baz.c remote:/tmp/))
+
+That would create /tmp/bar/baz.c on the remote machine.  (Note that the
+dot must be followed by a slash, so "/foo/." would not be abbreviated.)
+(2) For older rsync versions, you would need to use a chdir to limit the
+source path.  For example, when pushing files:
+
+quote(tt(   (cd /foo; rsync -avR bar/baz.c remote:/tmp/) ))
+
+(Note that the parens put the two commands into a sub-shell, so that the
+"cd" command doesn't remain in effect for future commands.)
+If you're pulling files, use this idiom (which doesn't work with an
+rsync daemon):
 
 quote(
-tt(   cd /foo)nl()
-tt(   rsync -R bar/foo.c remote:/tmp/)nl()
+tt(   rsync -avR --rsync-path="cd /foo; rsync" \ )nl()
+tt(       remote:bar/baz.c /tmp/)
 )
 
-That would create /tmp/bar/foo.c on the remote machine.
-
-dit(bf(--no-relative)) Turn off the bf(--relative) option.  This is only
-needed if you want to use bf(--files-from) without its implied bf(--relative)
-file processing.
-
-dit(bf(--no-implied-dirs)) When combined with the bf(--relative) option, the
-implied directories in each path are not explicitly duplicated as part
-of the transfer.  This makes the transfer more optimal and also allows
-the two sides to have non-matching symlinks in the implied part of the
-path.  For instance, if you transfer the file "/path/foo/file" with bf(-R),
-the default is for rsync to ensure that "/path" and "/path/foo" on the
-destination exactly match the directories/symlinks of the source.  Using
-the bf(--no-implied-dirs) option would omit both of these implied dirs,
-which means that if "/path" was a real directory on one machine and a
-symlink of the other machine, rsync would not try to change this.
+dit(bf(--no-implied-dirs)) This option affects the default behavior of the
+bf(--relative) option.  When it is specified, the attributes of the implied
+directories from the source names are not included in the transfer.  This
+means that the corresponding path elements on the destination system are
+left unchanged if they exist, and any missing implied directories are
+created with default attributes.  This even allows these implied path
+elements to have big differences, such as being a symlink to a directory on
+one side of the transfer, and a real directory on the other side.
+
+For instance, if a command-line arg or a files-from entry told rsync to
+transfer the file "path/foo/file", the directories "path" and "path/foo"
+are implied when bf(--relative) is used.  If "path/foo" is a symlink to
+"bar" on the destination system, the receiving rsync would ordinarily
+delete "path/foo", recreate it as a directory, and receive the file into
+the new directory.  With bf(--no-implied-dirs), the receiving rsync updates
+"path/foo/file" using the existing path elements, which means that the file
+ends up being created in "path/bar".  Another way to accomplish this link
+preservation is to use the bf(--keep-dirlinks) option (which will also
+affect symlinks to directories in the rest of the transfer).
+
+In a similar but opposite scenario, if the transfer of "path/foo/file" is
+requested and "path/foo" is a symlink on the sending side, running without
+bf(--no-implied-dirs) would cause rsync to transform "path/foo" on the
+receiving side into an identical symlink, and then attempt to transfer
+"path/foo/file", which might fail if the duplicated symlink did not point
+to a directory on the receiving side.  Another way to avoid this sending of
+a symlink as an implied directory is to use bf(--copy-unsafe-links), or
+bf(--copy-dirlinks) (both of which also affect symlinks in the rest of the
+transfer -- see their descriptions for full details).
 
 dit(bf(-b, --backup)) With this option, preexisting destination files are
 renamed as each file is transferred or deleted.  You can control where the
 backup file goes and what (if any) suffix gets appended using the
 bf(--backup-dir) and bf(--suffix) options.
-Note that if you don't specify bf(--backup-dir), the bf(--omit-dir-times)
-option will be enabled.
+
+Note that if you don't specify bf(--backup-dir), (1) the
+bf(--omit-dir-times) option will be implied, and (2) if bf(--delete) is
+also in effect (without bf(--delete-excluded)), rsync will add a "protect"
+filter-rule for the backup suffix to the end of all your existing excludes
+(e.g. -f "P *~").  This will prevent previously backed-up files from being
+deleted.  Note that if you are supplying your own filter rules, you may
+need to manually insert your own exclude/protect rule somewhere higher up
+in the list so that it has a high enough priority to be effective (e.g., if
+your rules specify a trailing inclusion/exclusion of '*', the auto-added
+rule would never be reached).
 
 dit(bf(--backup-dir=DIR)) In combination with the bf(--backup) option, this
 tells rsync to store all backups in the specified directory. This is
 very useful for incremental backups.  You can additionally
 specify a backup suffix using the bf(--suffix) option
 (otherwise the files backed up in the specified directory
@@ -563,89 +650,196 @@
 WARNING: The file's data will be in an inconsistent state during the
 transfer (and possibly afterward if the transfer gets interrupted), so you
 should not use this option to update files that are in use.  Also note that
 rsync will be unable to update a file in-place that is not writable by the
 receiving user.
 
+dit(bf(--append)) This causes rsync to update a file by appending data onto
+the end of the file, which presumes that the data that already exists on
+the receiving side is identical with the start of the file on the sending
+side.  If that is not true, the file will fail the checksum test, and the
+resend will do a normal bf(--inplace) update to correct the mismatched data.
+Only files on the receiving side that are shorter than the corresponding
+file on the sending side (as well as new files) are sent.
+Implies bf(--inplace), but does not conflict with bf(--sparse) (though the
+bf(--sparse) option will be auto-disabled if a resend of the already-existing
+data is required).
+
 dit(bf(-d, --dirs)) Tell the sending side to include any directories that
 are encountered.  Unlike bf(--recursive), a directory's contents are not copied
-unless the directory was specified on the command-line as either "." or a
-name with a trailing slash (e.g. "foo/").  Without this option or the
+unless the directory name specified is "." or ends with a trailing slash
+(e.g. ".", "dir/.", "dir/", etc.).  Without this option or the
 bf(--recursive) option, rsync will skip all directories it encounters (and
-output a message to that effect for each one).
+output a message to that effect for each one).  If you specify both
+bf(--dirs) and bf(--recursive), bf(--recursive) takes precedence.
 
 dit(bf(-l, --links)) When symlinks are encountered, recreate the
 symlink on the destination.
 
-dit(bf(-L, --copy-links)) When symlinks are encountered, the file that
+dit(bf(-L, --copy-links)) When symlinks are encountered, the item that
 they point to (the referent) is copied, rather than the symlink.  In older
 versions of rsync, this option also had the side-effect of telling the
 receiving side to follow symlinks, such as symlinks to directories.  In a
 modern rsync such as this one, you'll need to specify bf(--keep-dirlinks) (bf(-K))
 to get this extra behavior.  The only exception is when sending files to
 an rsync that is too old to understand bf(-K) -- in that case, the bf(-L) option
 will still have the side-effect of bf(-K) on that older receiving rsync.
 
 dit(bf(--copy-unsafe-links)) This tells rsync to copy the referent of
 symbolic links that point outside the copied tree.  Absolute symlinks
 are also treated like ordinary files, and so are any symlinks in the
-source path itself when bf(--relative) is used.
+source path itself when bf(--relative) is used.  This option has no
+additional effect if bf(--copy-links) was also specified.
 
 dit(bf(--safe-links)) This tells rsync to ignore any symbolic links
 which point outside the copied tree. All absolute symlinks are
 also ignored. Using this option in conjunction with bf(--relative) may
 give unexpected results.
 
-dit(bf(-H, --hard-links)) This tells rsync to recreate hard  links  on
-the  remote system  to  be the same as the local system. Without this
-option hard links are treated like regular files.
+dit(bf(-K, --copy-dirlinks)) This option causes the sending side to treat
+a symlink to a directory as though it were a real directory.  This is
+useful if you don't want symlinks to non-directories to be affected, as
+they would be using bf(--copy-links).
+
+Without this option, if the sending side has replaced a directory with a
+symlink to a directory, the receiving side will delete anything that is in
+the way of the new symlink, including a directory hierarchy (as long as
+bf(--force) or bf(--delete) is in effect).
+
+See also bf(--keep-dirlinks) for an analogous option for the receiving
+side.
+
+dit(bf(-K, --keep-dirlinks)) This option causes the receiving side to treat
+a symlink to a directory as though it were a real directory, but only if it
+matches a real directory from the sender.  Without this option, the
+receiver's symlink would be deleted and replaced with a real directory.
+
+For example, suppose you transfer a directory "foo" that contains a file
+"file", but "foo" is a symlink to directory "bar" on the receiver.  Without
+bf(--keep-dirlinks), the receiver deletes symlink "foo", recreates it as a
+directory, and receives the file into the new directory.  With
+bf(--keep-dirlinks), the receiver keeps the symlink and "file" ends up in
+"bar".
+
+See also bf(--copy-dirlinks) for an analogous option for the sending side.
+
+dit(bf(-H, --hard-links)) This tells rsync to look for hard-linked files in
+the transfer and link together the corresponding files on the receiving
+side.  Without this option, hard-linked files in the transfer are treated
+as though they were separate files.
 
 Note that rsync can only detect hard links if both parts of the link
 are in the list of files being sent.
 
-This option can be quite slow, so only use it if you need it.
+dit(bf(-p, --perms)) This option causes the receiving rsync to set the
+destination permissions to be the same as the source permissions.  (See
+also the bf(--chmod) option for a way to modify what rsync considers to
+be the source permissions.)
 
-dit(bf(-K, --keep-dirlinks)) On the receiving side, if a symlink is
-pointing to a directory, it will be treated as matching a directory
-from the sender.
+When this option is em(off), permissions are set as follows:
 
-dit(bf(-W, --whole-file)) With this option the incremental rsync algorithm
-is not used and the whole file is sent as-is instead.  The transfer may be
-faster if this option is used when the bandwidth between the source and
-destination machines is higher than the bandwidth to disk (especially when the
-"disk" is actually a networked filesystem).  This is the default when both
-the source and destination are specified as local paths.
+quote(itemize(
+  it() Existing files (including updated files) retain their existing
+  permissions, though the bf(--executability) option might change just
+  the execute permission for the file.
+  it() New files get their "normal" permission bits set to the source
+  file's permissions masked with the receiving end's umask setting, and
+  their special permission bits disabled except in the case where a new
+  directory inherits a setgid bit from its parent directory.
+))
+
+Thus, when bf(--perms) and bf(--executability) are both disabled,
+rsync's behavior is the same as that of other file-copy utilities,
+such as bf(cp)(1) and bf(tar)(1).
+
+In summary: to give destination files (both old and new) the source
+permissions, use bf(--perms).  To give new files the destination-default
+permissions (while leaving existing files unchanged), make sure that the
+bf(--perms) option is off and use bf(--chmod=ugo=rwX) (which ensures that
+all non-masked bits get enabled).  If you'd care to make this latter
+behavior easier to type, you could define a popt alias for it, such as
+putting this line in the file ~/.popt (this defines the bf(-s) option,
+and includes --no-g to use the default group of the destination dir):
+
+quote(tt(   rsync alias -s --no-p --no-g --chmod=ugo=rwX))
+
+You could then use this new option in a command such as this one:
+
+quote(tt(   rsync -asv src/ dest/))
+
+(Caveat: make sure that bf(-a) does not follow bf(-s), or it will re-enable
+the "--no-*" options.)
+
+The preservation of the destination's setgid bit on newly-created
+directories when bf(--perms) is off was added in rsync 2.6.7.  Older rsync
+versions erroneously preserved the three special permission bits for
+newly-created files when bf(--perms) was off, while overriding the
+destination's setgid bit setting on a newly-created directory.  (Keep in
+mind that it is the version of the receiving rsync that affects this
+behavior.)
+
+dit(bf(-E, --executability)) This option causes rsync to preserve the
+executability (or non-executability) of regular files when bf(--perms) is
+not enabled.  A regular file is considered to be executable if at least one
+'x' is turned on in its permissions.  When an existing destination file's
+executability differs from that of the corresponding source file, rsync
+modifies the destination file's permissions as follows:
+
+quote(itemize(
+  it() To make a file non-executable, rsync turns off all its 'x'
+  permissions.
+  it() To make a file executable, rsync turns on each 'x' permission that
+  has a corresponding 'r' permission enabled.
+))
+
+If bf(--perms) is enabled, this option is ignored.
 
-dit(bf(--no-whole-file)) Turn off bf(--whole-file), for use when it is the
-default.
+dit(bf(--chmod)) This option tells rsync to apply one or more
+comma-separated "chmod" strings to the permission of the files in the
+transfer.  The resulting value is treated as though it was the permissions
+that the sending side supplied for the file, which means that this option
+can seem to have no effect on existing files if bf(--perms) is not enabled.
+
+In addition to the normal parsing rules specified in the bf(chmod)(1)
+manpage, you can specify an item that should only apply to a directory by
+prefixing it with a 'D', or specify an item that should only apply to a
+file by prefixing it with a 'F'.  For example:
 
-dit(bf(-p, --perms)) This option causes rsync to set the destination
-permissions to be the same as the source permissions.
+quote(--chmod=Dg+s,ug+w,Fo-w,+X)
 
-Without this option, all existing files (including updated files) retain
-their existing permissions, while each new file gets its permissions set
-based on the source file's permissions, but masked by the receiving end's
-umask setting
-(which is the same behavior as other file-copy utilities, such as cp).
+It is also legal to specify multiple bf(--chmod) options, as each
+additional option is just appended to the list of changes to make.
+
+See the bf(--perms) and bf(--executability) options for how the resulting
+permission value can be applied to the files in the transfer.
 
 dit(bf(-o, --owner)) This option causes rsync to set the owner of the
-destination file to be the same as the source file.  On most systems,
-only the super-user can set file ownership.  By default, the preservation
-is done by name, but may fall back to using the ID number in some
-circumstances.  See the bf(--numeric-ids) option for a full discussion.
+destination file to be the same as the source file.  By default, the
+preservation is done by name, but may fall back to using the ID number
+in some circumstances (see the bf(--numeric-ids) option for a full
+discussion).
+This option has no effect if the receiving rsync is not run as the
+super-user and bf(--super) is not specified.
 
 dit(bf(-g, --group)) This option causes rsync to set the group of the
 destination file to be the same as the source file.  If the receiving
-program is not running as the super-user, only groups that the
+program is not running as the super-user (or with the bf(--no-super)
+option), only groups that the
 receiver is a member of will be preserved.  By default, the preservation
 is done by name, but may fall back to using the ID number in some
 circumstances.  See the bf(--numeric-ids) option for a full discussion.
 
-dit(bf(-D, --devices)) This option causes rsync to transfer character and
-block device information to the remote system to recreate these
-devices. This option is only available to the super-user.
+dit(bf(--devices)) This option causes rsync to transfer character and
+block device files to the remote system to recreate these devices.
+This option has no effect if the receiving rsync is not run as the
+super-user and bf(--super) is not specified.
+
+dit(bf(--specials)) This option causes rsync to transfer special files
+such as named sockets and fifos.
+
+dit(bf(-D)) The bf(-D) option is equivalent to bf(--devices) bf(--specials).
 
 dit(bf(-t, --times)) This tells rsync to transfer modification times along
 with the files and update them on the remote system.  Note that if this
 option is not used, the optimization that excludes files that have not been
 modified cannot be effective; in other words, a missing bf(-t) or bf(-a) will
 cause the next transfer to behave as if it used bf(-I), causing all files to be
@@ -654,32 +848,65 @@
 
 dit(bf(-O, --omit-dir-times)) This tells rsync to omit directories when
 it is preserving modification times (see bf(--times)).  If NFS is sharing
 the directories on the receiving side, it is a good idea to use bf(-O).
 This option is inferred if you use bf(--backup) without bf(--backup-dir).
 
-dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
-instead it will just report the actions it would have taken.
+dit(bf(--super)) This tells the receiving side to attempt super-user
+activities even if the receiving rsync wasn't run by the super-user.  These
+activities include: preserving users via the bf(--owner) option, preserving
+all groups (not just the current user's groups) via the bf(--groups)
+option, and copying devices via the bf(--devices) option.  This is useful
+for systems that allow such activities without being the super-user, and
+also for ensuring that you will get errors if the receiving side isn't
+being running as the super-user.  To turn off super-user activities, the
+super-user can use bf(--no-super).
 
 dit(bf(-S, --sparse)) Try to handle sparse files efficiently so they take
-up less space on the destination.
+up less space on the destination.  Conflicts with bf(--inplace) because it's
+not possible to overwrite data in a sparse fashion.
 
 NOTE: Don't use this option when the destination is a Solaris "tmpfs"
 filesystem. It doesn't seem to handle seeks over null regions
 correctly and ends up corrupting the files.
 
-dit(bf(-x, --one-file-system)) This tells rsync not to cross filesystem
-boundaries  when recursing.  This  is useful for transferring the
-contents of only one filesystem.
-
-dit(bf(--existing)) This tells rsync not to create any new files --
-only update files that already exist on the destination.
-
-dit(bf(--ignore-existing))
-This tells rsync not to update files that already exist on
-the destination.
+dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
+instead it will just report the actions it would have taken.
+
+dit(bf(-W, --whole-file)) With this option the incremental rsync algorithm
+is not used and the whole file is sent as-is instead.  The transfer may be
+faster if this option is used when the bandwidth between the source and
+destination machines is higher than the bandwidth to disk (especially when the
+"disk" is actually a networked filesystem).  This is the default when both
+the source and destination are specified as local paths.
+
+dit(bf(-x, --one-file-system)) This tells rsync to avoid crossing a
+filesystem boundary when recursing.  This does not limit the user's ability
+to specify items to copy from multiple filesystems, just rsync's recursion
+through the hierarchy of each directory that the user specified, and also
+the analogous recursion on the receiving side during deletion.  Also keep
+in mind that rsync treats a "bind" mount to the same device as being on the
+same filesystem.
+
+If this option is repeated, rsync omits all mount-point directories from
+the copy.  Otherwise, it includes an empty directory at each mount-point it
+encounters (using the attributes of the mounted directory because those of
+the underlying mount-point directory are inaccessible).
+
+If rsync has been told to collapse symlinks (via bf(--copy-links) or
+bf(--copy-unsafe-links)), a symlink to a directory on another device is
+treated like a mount-point.  Symlinks to non-directories are unaffected
+by this option.
+
+dit(bf(--existing, --ignore-non-existing)) This tells rsync to skip
+updating files that do not exist yet on the destination.  If this option is
+combined with the bf(--ignore-existing) option, no files will be updated
+(which can be useful if all you want to do is to delete missing files).
+
+dit(bf(--ignore-existing)) This tells rsync to skip updating files that
+already exist on the destination.  See also bf(--ignore-non-existing).
 
 dit(bf(--remove-sent-files)) This tells rsync to remove from the sending
 side the files and/or symlinks that are newly created or whose content is
 updated on the receiving side.  Directories and devices are not removed,
 nor are files/symlinks whose attributes are merely changed.
 
@@ -691,13 +918,15 @@
 by the shell and rsync thus gets a request to transfer individual files, not
 the files' parent directory.  Files that are excluded from transfer are
 also excluded from being deleted unless you use the bf(--delete-excluded)
 option or mark the rules as only matching on the sending side (see the
 include/exclude modifiers in the FILTER RULES section).
 
-This option has no effect unless directory recursion is enabled.
+Prior to rsync 2.6.7, this option would have no effect unless bf(--recursive)
+was in effect.  Beginning with 2.6.7, deletions will also occur when bf(--dirs)
+(bf(-d)) is in effect, but only for directories whose contents are being copied.
 
 This option can be dangerous if used incorrectly!  It is a very good idea
 to run first using the bf(--dry-run) option (bf(-n)) to see what files would be
 deleted to make sure important files aren't listed.
 
 If the sending side detects any I/O errors, then the deletion of any
@@ -744,26 +973,45 @@
 bf(--delete-excluded).
 See bf(--delete) (which is implied) for more details on file-deletion.
 
 dit(bf(--ignore-errors)) Tells bf(--delete) to go ahead and delete files
 even when there are I/O errors.
 
-dit(bf(--force)) This options tells rsync to delete directories even if
-they are not empty when they are to be replaced by non-directories.  This
-is only relevant without bf(--delete) because deletions are now done depth-first.
-Requires the bf(--recursive) option (which is implied by bf(-a)) to have any effect.
+dit(bf(--force)) This option tells rsync to delete a non-empty directory
+when it is to be replaced by a non-directory.  This is only relevant if
+deletions are not active (see bf(--delete) for details).
+
+Note for older rsync versions: bf(--force) used to still be required when
+using bf(--delete-after), and it used to be non-functional unless the
+bf(--recursive) option was also enabled.
 
 dit(bf(--max-delete=NUM)) This tells rsync not to delete more than NUM
 files or directories (NUM must be non-zero).
 This is useful when mirroring very large trees to prevent disasters.
 
 dit(bf(--max-size=SIZE)) This tells rsync to avoid transferring any
 file that is larger than the specified SIZE. The SIZE value can be
-suffixed with a letter to indicate a size multiplier (K, M, or G) and
+suffixed with a string to indicate a size multiplier, and
 may be a fractional value (e.g. "bf(--max-size=1.5m)").
 
+The suffixes are as follows: "K" (or "KiB") is a kibibyte (1024),
+"M" (or "MiB") is a mebibyte (1024*1024), and "G" (or "GiB") is a
+gibibyte (1024*1024*1024).
+If you want the multiplier to be 1000 instead of 1024, use "KB",
+"MB", or "GB".  (Note: lower-case is also accepted for all values.)
+Finally, if the suffix ends in either "+1" or "-1", the value will
+be offset by one byte in the indicated direction.
+
+Examples: --max-size=1.5mb-1 is 1499999 bytes, and --max-size=2g+1 is
+2147483649 bytes.
+
+dit(bf(--min-size=SIZE)) This tells rsync to avoid transferring any
+file that is smaller than the specified SIZE, which can help in not
+transferring small, junk files.
+See the bf(--max-size) option for a description of SIZE.
+
 dit(bf(-B, --block-size=BLOCKSIZE)) This forces the block size used in
 the rsync algorithm to a fixed value.  It is normally selected based on
 the size of each file being updated.  See the technical report for details.
 
 dit(bf(-e, --rsh=COMMAND)) This option allows you to choose an alternative
 remote shell program to use for communication between the local and
@@ -775,15 +1023,24 @@
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
 running rsync daemon on the remote host.  See the section "USING
 RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION" above.
 
 Command-line arguments are permitted in COMMAND provided that COMMAND is
-presented to rsync as a single argument.  For example:
+presented to rsync as a single argument.  You must use spaces (not tabs
+or other whitespace) to separate the command and args from each other,
+and you can use single- and/or double-quotes to preserve spaces in an
+argument (but not backslashes).  Note that doubling a single-quote
+inside a single-quoted string gives you a single-quote; likewise for
+double-quotes (though you need to pay attention to which quotes your
+shell is parsing and which quotes rsync is parsing).  Some examples:
 
-quote(tt(   -e "ssh -p 2234"))
+quote(
+tt(    -e 'ssh -p 2234')nl()
+tt(    -e 'ssh -o "ProxyCommand nohup ssh firewall nc -w1 %h %p"')nl()
+)
 
 (Note that ssh users can alternately customize site-specific connect
 options in their .ssh/config file.)
 
 You can also choose the remote shell program using the RSYNC_RSH
 environment variable, which accepts the same range of values as bf(-e).
@@ -844,62 +1101,66 @@
 
 See the FILTER RULES section for detailed information on this option.
 
 dit(bf(-F)) The bf(-F) option is a shorthand for adding two bf(--filter) rules to
 your command.  The first time it is used is a shorthand for this rule:
 
-quote(tt(   --filter=': /.rsync-filter'))
+quote(tt(   --filter='dir-merge /.rsync-filter'))
 
 This tells rsync to look for per-directory .rsync-filter files that have
 been sprinkled through the hierarchy and use their rules to filter the
 files in the transfer.  If bf(-F) is repeated, it is a shorthand for this
 rule:
 
-quote(tt(   --filter='- .rsync-filter'))
+quote(tt(   --filter='exclude .rsync-filter'))
 
 This filters out the .rsync-filter files themselves from the transfer.
 
 See the FILTER RULES section for detailed information on how these options
 work.
 
 dit(bf(--exclude=PATTERN)) This option is a simplified form of the
 bf(--filter) option that defaults to an exclude rule and does not allow
 the full rule-parsing syntax of normal filter rules.
 
 See the FILTER RULES section for detailed information on this option.
 
-dit(bf(--exclude-from=FILE)) This option is similar to the bf(--exclude)
-option, but instead it adds all exclude patterns listed in the file
-FILE to the exclude list.  Blank lines in FILE and lines starting with
-';' or '#' are ignored.
-If em(FILE) is bf(-) the list will be read from standard input.
+dit(bf(--exclude-from=FILE)) This option is related to the bf(--exclude)
+option, but it specifies a FILE that contains exclude patterns (one per line).
+Blank lines in the file and lines starting with ';' or '#' are ignored.
+If em(FILE) is bf(-), the list will be read from standard input.
 
 dit(bf(--include=PATTERN)) This option is a simplified form of the
 bf(--filter) option that defaults to an include rule and does not allow
 the full rule-parsing syntax of normal filter rules.
 
 See the FILTER RULES section for detailed information on this option.
 
-dit(bf(--include-from=FILE)) This specifies a list of include patterns
-from a file.
-If em(FILE) is "-" the list will be read from standard input.
+dit(bf(--include-from=FILE)) This option is related to the bf(--include)
+option, but it specifies a FILE that contains include patterns (one per line).
+Blank lines in the file and lines starting with ';' or '#' are ignored.
+If em(FILE) is bf(-), the list will be read from standard input.
 
 dit(bf(--files-from=FILE)) Using this option allows you to specify the
-exact list of files to transfer (as read from the specified FILE or "-"
+exact list of files to transfer (as read from the specified FILE or bf(-)
 for standard input).  It also tweaks the default behavior of rsync to make
 transferring just the specified files and directories easier:
 
 quote(itemize(
   it() The bf(--relative) (bf(-R)) option is implied, which preserves the path
   information that is specified for each item in the file (use
-  bf(--no-relative) if you want to turn that off).
+  bf(--no-relative) or bf(--no-R) if you want to turn that off).
   it() The bf(--dirs) (bf(-d)) option is implied, which will create directories
   specified in the list on the destination rather than noisily skipping
-  them.
+  them (use bf(--no-dirs) or bf(--no-d) if you want to turn that off).
   it() The bf(--archive) (bf(-a)) option's behavior does not imply bf(--recursive)
   (bf(-r)), so specify it explicitly, if you want it.
+  it() These side-effects change the default state of rsync, so the position
+  of the bf(--files-from) option on the command-line has no bearing on how
+  other options are parsed (e.g. bf(-a) works the same before or after
+  bf(--files-from), as does bf(--no-R) and all other options).
 ))
 
 The file names that are read from the FILE are all relative to the
 source dir -- any leading slashes are removed and no ".." references are
 allowed to go higher than the source dir.  For example, take this
 command:
@@ -935,15 +1196,42 @@
 This affects bf(--exclude-from), bf(--include-from), bf(--files-from), and any
 merged files specified in a bf(--filter) rule.
 It does not affect bf(--cvs-exclude) (since all names read from a .cvsignore
 file are split on whitespace).
 
 dit(bf(-T, --temp-dir=DIR)) This option instructs rsync to use DIR as a
-scratch directory when creating temporary copies of the files
-transferred on the receiving side.  The default behavior is to create
-the temporary files in the receiving directory.
+scratch directory when creating temporary copies of the files transferred
+on the receiving side.  The default behavior is to create each temporary
+file in the same directory as the associated destination file.
+
+This option is most often used when the receiving disk partition does not
+have enough free space to hold a copy of the largest file in the transfer.
+In this case (i.e. when the scratch directory in on a different disk
+partition), rsync will not be able to rename each received temporary file
+over the top of the associated destination file, but instead must copy it
+into place.  Rsync does this by copying the file over the top of the
+destination file, which means that the destination file will contain
+truncated data during this copy.  If this were not done this way (even if
+the destination file were first removed, the data locally copied to a
+temporary file in the destination directory, and then renamed into place)
+it would be possible for the old file to continue taking up disk space (if
+someone had it open), and thus there might not be enough room to fit the
+new version on the disk at the same time.
+
+If you are using this option for reasons other than a shortage of disk
+space, you may wish to combine it with the bf(--delay-updates) option,
+which will ensure that all copied files get put into subdirectories in the
+destination hierarchy, awaiting the end of the transfer.  If you don't
+have enough room to duplicate all the arriving files on the destination
+partition, another way to tell rsync that you aren't overly concerned
+about disk space is to use the bf(--partial-dir) option with a relative
+path; because this tells rsync that it is OK to stash off a copy of a
+single file in a subdir in the destination hierarchy, rsync will use the
+partial-dir as a staging area to bring over the copied file, and then
+rename it into place from there. (Specifying a bf(--partial-dir) with
+an absolute path does not have this side-effect.)
 
 dit(bf(-y, --fuzzy)) This option tells rsync that it should look for a
 basis file for any destination file that is missing.  The current algorithm
 looks in the same directory as the destination file for either a file that
 has an identical size and modified-time, or a similarly-named file.  If
 found, rsync uses the fuzzy basis file to try to speed up the transfer.
@@ -1003,25 +1291,29 @@
 selected to try to speed up the transfer.
 
 If em(DIR) is a relative path, it is relative to the destination directory.
 See also bf(--compare-dest) and bf(--copy-dest).
 
 Note that rsync versions prior to 2.6.1 had a bug that could prevent
-bf(--link-dest) from working properly for a non-root user when bf(-o) was specified
-(or implied by bf(-a)).  You can work-around this bug by avoiding the bf(-o) option
-when sending to an old rsync.
+bf(--link-dest) from working properly for a non-super-user when bf(-o) was
+specified (or implied by bf(-a)).  You can work-around this bug by avoiding
+the bf(-o) option when sending to an old rsync.
 
 dit(bf(-z, --compress)) With this option, rsync compresses the file data
 as it is sent to the destination machine, which reduces the amount of data
 being transmitted -- something that is useful over a slow connection.
 
-Note this this option typically achieves better compression ratios that can
+Note that this option typically achieves better compression ratios than can
 be achieved by using a compressing remote shell or a compressing transport
 because it takes advantage of the implicit information in the matching data
 blocks that are not explicitly sent over the connection.
 
+dit(bf(--compress-level=NUM)) Explicitly set the compression level to use
+(see bf(--compress)) instead of letting it default.  If NUM is non-zero,
+the bf(--compress) option is implied.
+
 dit(bf(--numeric-ids)) With this option rsync will transfer numeric group
 and user IDs rather than using user and group names and mapping them
 at both ends.
 
 By default rsync will use the username and groupname to determine
 what ownership to give files. The special uid 0 and the special group
@@ -1047,48 +1339,59 @@
 dit(bf(--port=PORT)) This specifies an alternate TCP port number to use
 rather than the default of 873.  This is only needed if you are using the
 double-colon (::) syntax to connect with an rsync daemon (since the URL
 syntax has a way to specify the port as a part of the URL).  See also this
 option in the bf(--daemon) mode section.
 
+dit(bf(--sockopts)) This option can provide endless fun for people
+who like to tune their systems to the utmost degree. You can set all
+sorts of socket options which may make transfers faster (or
+slower!). Read the man page for the setsockopt() system call for
+details on some of the options you may be able to set. By default no
+special socket options are set. This only affects direct socket
+connections to a remote rsync daemon.  This option also exists in the
+bf(--daemon) mode section.
+
 dit(bf(--blocking-io)) This tells rsync to use blocking I/O when launching
 a remote shell transport.  If the remote shell is either rsh or remsh,
 rsync defaults to using
 blocking I/O, otherwise it defaults to using non-blocking I/O.  (Note that
 ssh prefers non-blocking I/O.)
 
-dit(bf(--no-blocking-io)) Turn off bf(--blocking-io), for use when it is the
-default.
-
 dit(bf(-i, --itemize-changes)) Requests a simple itemized list of the
 changes that are being made to each file, including attribute changes.
 This is exactly the same as specifying bf(--log-format='%i %n%L').
+If you repeat the option, unchanged files will also be output, but only
+if the receiving rsync is at least version 2.6.7 (you can use bf(-vv)
+with older versions of rsync, but that also turns on the output of other
+verbose messages).
 
 The "%i" escape has a cryptic output that is 9 letters long.  The general
-format is like the string bf(UXcstpoga)), where bf(U) is replaced by the
-kind of update being done, bf(X) is replaced by the file-type, and the
+format is like the string bf(YXcstpogz), where bf(Y) is replaced by the
+type of update being done, bf(X) is replaced by the file-type, and the
 other letters represent attributes that may be output if they are being
 modified.
 
-The update types that replace the bf(U) are as follows:
+The update types that replace the bf(Y) are as follows:
 
 quote(itemize(
   it() A bf(<) means that a file is being transferred to the remote host
   (sent).
   it() A bf(>) means that a file is being transferred to the local host
   (received).
   it() A bf(c) means that a local change/creation is occurring for the item
   (such as the creation of a directory or the changing of a symlink, etc.).
-  it() A bf(h) means that the item is a hard-link to another item (requires
+  it() A bf(h) means that the item is a hard link to another item (requires
   bf(--hard-links)).
   it() A bf(.) means that the item is not being updated (though it might
   have attributes that are being modified).
 ))
 
 The file-types that replace the bf(X) are: bf(f) for a file, a bf(d) for a
-directory, an bf(L) for a symlink, and a bf(D) for a device.
+directory, an bf(L) for a symlink, a bf(D) for a device, and a bf(S) for a
+special file (e.g. named sockets and fifos).
 
 The other letters in the string above are the actual letters that
 will be output if the associated attribute for the item is being updated or
 a "." for no change.  Three exceptions to this are: (1) a newly created
 item replaces each letter with a "+", (2) an identical item replaces the
 dots with spaces, and (3) an unknown attribute replaces each letter with
@@ -1106,17 +1409,16 @@
   means that the time will be set to the transfer time, which happens
   anytime a symlink is transferred, or when a file or device is transferred
   without bf(--times).
   it() A bf(p) means the permissions are different and are being updated to
   the sender's value (requires bf(--perms)).
   it() An bf(o) means the owner is different and is being updated to the
-  sender's value (requires bf(--owner) and root privileges).
+  sender's value (requires bf(--owner) and super-user privileges).
   it() A bf(g) means the group is different and is being updated to the
   sender's value (requires bf(--group) and the authority to set the group).
-  it() The bf(a) is reserved for a future enhanced version that supports
-  extended file attributes, such as ACLs.
+  it() The bf(z) slot is reserved for future use.
 ))
 
 One other output is possible:  when deleting files, the "%i" will output
 the string "*deleting" for each item that is being removed (assuming that
 you are talking to a recent enough rsync that it logs deletions instead of
 outputting them as a verbose message).
@@ -1127,20 +1429,20 @@
 a percent (%) character.  For a list of the possible escape characters, see
 the "log format" setting in the rsyncd.conf manpage.  (Note that this
 option does not affect what a daemon logs to its logfile.)
 
 Specifying this option will mention each file, dir, etc. that gets updated
 in a significant way (a transferred file, a recreated symlink/device, or a
-touched directory) unless the itemized-changes escape (%i) is included in
+touched directory) unless the itemize-changes escape (%i) is included in
 the string, in which case the logging of names increases to mention any
 item that is changed in any way (as long as the receiving side is at least
-2.6.4).  See the bf(--itemized-changes) option for a description of the
+2.6.4).  See the bf(--itemize-changes) option for a description of the
 output of "%i".
 
 The bf(--verbose) option implies a format of "%n%L", but you can use
-bf(--log-format) without bv(--verbose) if you like, or you can override
+bf(--log-format) without bf(--verbose) if you like, or you can override
 the format of its per-file output using this option.
 
 Rsync will output the log-format string prior to a file's transfer unless
 one of the transfer-statistic escapes is requested, in which case the
 logging is done at the end of the file's transfer.  When this late logging
 is in effect and bf(--progress) is also specified, rsync will also output
@@ -1148,24 +1450,74 @@
 (followed, of course, by the log-format output).
 
 dit(bf(--stats)) This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data.
 
+The current statistics are as follows: itemize(
+  it() bf(Number of files) is the count of all "files" (in the generic
+  sense), which includes directories, symlinks, etc.
+  it() bf(Number of files transferred) is the count of normal files that
+  were updated via the rsync algorithm, which does not include created
+  dirs, symlinks, etc.
+  it() bf(Total file size) is the total sum of all file sizes in the transfer.
+  This does not count any size for directories or special files, but does
+  include the size of symlinks.
+  it() bf(Total transferred file size) is the total sum of all files sizes
+  for just the transferred files.
+  it() bf(Literal data) is how much unmatched file-update data we had to
+  send to the receiver for it to recreate the updated files.
+  it() bf(Matched data) is how much data the receiver got locally when
+  recreating the updated files.
+  it() bf(File list size) is how big the file-list data was when the sender
+  sent it to the receiver.  This is smaller than the in-memory size for the
+  file list due to some compressing of duplicated data when rsync sends the
+  list.
+  it() bf(File list generation time) is the number of seconds that the
+  sender spent creating the file list.  This requires a modern rsync on the
+  sending side for this to be present.
+  it() bf(File list transfer time) is the number of seconds that the sender
+  spent sending the file list to the receiver.
+  it() bf(Total bytes sent) is the count of all the bytes that rsync sent
+  from the client side to the server side.
+  it() bf(Total bytes received) is the count of all non-message bytes that
+  rsync received by the client side from the server side.  "Non-message"
+  bytes means that we don't count the bytes for a verbose message that the
+  server sent to us, which makes the stats more consistent.
+)
+
+dit(bf(-8, --8-bit-output)) This tells rsync to leave all high-bit characters
+unescaped in the output instead of trying to test them to see if they're
+valid in the current locale and escaping the invalid ones.  All control
+characters (but never tabs) are always escaped, regardless of this option's
+setting.
+
+The escape idiom that started in 2.6.7 is to output a literal backslash (\)
+and a hash (#), followed by exactly 3 octal digits.  For example, a newline
+would output as "\#012".  A literal backslash that is in a filename is not
+escaped unless it is followed by a hash and 3 digits (0-9).
+
+dit(bf(-h, --human-readable)) Output numbers in a more human-readable format.
+This makes big numbers output using larger units, with a K, M, or G suffix.  If
+this option was specified once, these units are K (1000), M (1000*1000), and
+G (1000*1000*1000); if the option is repeated, the units are powers of 1024
+instead of 1000.
+
 dit(bf(--partial)) By default, rsync will delete any partially
 transferred file if the transfer is interrupted. In some circumstances
 it is more desirable to keep partially transferred files. Using the
 bf(--partial) option tells rsync to keep the partial file which should
 make a subsequent transfer of the rest of the file much faster.
 
 dit(bf(--partial-dir=DIR)) A better way to keep partial files than the
 bf(--partial) option is to specify a em(DIR) that will be used to hold the
 partial data (instead of writing it out to the destination file).
 On the next transfer, rsync will use a file found in this
-dir as data to speed up the resumption of the transfer and then deletes it
+dir as data to speed up the resumption of the transfer and then delete it
 after it has served its purpose.
+
 Note that if bf(--whole-file) is specified (or implied), any partial-dir
 file that is found for a file that is being updated will simply be removed
 (since
 rsync is sending files without using the incremental rsync algorithm).
 
 Rsync will create the em(DIR) if it is missing (just the last dir -- not
@@ -1171,36 +1523,42 @@
 Rsync will create the em(DIR) if it is missing (just the last dir -- not
 the whole path).  This makes it easy to use a relative path (such as
 "bf(--partial-dir=.rsync-partial)") to have rsync create the
 partial-directory in the destination file's directory when needed, and then
 remove it again when the partial file is deleted.
 
-If the partial-dir value is not an absolute path, rsync will also add a directory
-bf(--exclude) of this value at the end of all your existing excludes.  This
-will prevent partial-dir files from being transferred and also prevent the
-untimely deletion of partial-dir items on the receiving side.  An example:
-the above bf(--partial-dir) option would add an "bf(--exclude=.rsync-partial/)"
-rule at the end of any other filter rules.  Note that if you are
-supplying your own filter rules, you may need to manually insert a
-rule for this directory exclusion somewhere higher up in the list so that
-it has a high enough priority to be effective (e.g., if your rules specify
-a trailing bf(--exclude='*') rule, the auto-added rule would never be
-reached).
+If the partial-dir value is not an absolute path, rsync will add an exclude
+rule at the end of all your existing excludes.  This will prevent the
+sending of any partial-dir files that may exist on the sending side, and
+will also prevent the untimely deletion of partial-dir items on the
+receiving side.  An example: the above bf(--partial-dir) option would add
+the equivalent of "bf(--exclude=.rsync-partial/)" at the end of any other
+filter rules.
+
+If you are supplying your own exclude rules, you may need to add your own
+exclude/hide/protect rule for the partial-dir because (1) the auto-added
+rule may be ineffective at the end of your other rules, or (2) you may wish
+to override rsync's exclude choice.  For instance, if you want to make
+rsync clean-up any left-over partial-dirs that may be lying around, you
+should specify bf(--delete-after) and add a "risk" filter rule, e.g.
+bf(-f 'R .rsync-partial/').  (Avoid using bf(--delete-before) or
+bf(--delete-during) unless you don't need rsync to use any of the
+left-over partial-dir data during the current run.)
 
 IMPORTANT: the bf(--partial-dir) should not be writable by other users or it
 is a security risk.  E.g. AVOID "/tmp".
 
 You can also set the partial-dir value the RSYNC_PARTIAL_DIR environment
 variable.  Setting this in the environment does not force bf(--partial) to be
-enabled, but rather it effects where partial files go when bf(--partial) is
+enabled, but rather it affects where partial files go when bf(--partial) is
 specified.  For instance, instead of using bf(--partial-dir=.rsync-tmp)
 along with bf(--progress), you could set RSYNC_PARTIAL_DIR=.rsync-tmp in your
 environment and then just use the bf(-P) option to turn on the use of the
-.rsync-tmp dir for partial transfers.  The only time that the bf(--partial)
-option does not look for this environment value is (1) when bf(--inplace) was
-specified (since bf(--inplace) conflicts with bf(--partial-dir)), or (2) when
+.rsync-tmp dir for partial transfers.  The only times that the bf(--partial)
+option does not look for this environment value are (1) when bf(--inplace) was
+specified (since bf(--inplace) conflicts with bf(--partial-dir)), and (2) when
 bf(--delay-updates) was specified (see below).
 
 For the purposes of the daemon-config's "refuse options" setting,
 bf(--partial-dir) does em(not) imply bf(--partial).  This is so that a
 refusal of the bf(--partial) option can be used to disallow the overwriting
 of destination files with a partial transfer, while still allowing the
@@ -1208,30 +1566,64 @@
 
 dit(bf(--delay-updates)) This option puts the temporary file from each
 updated file into a holding directory until the end of the
 transfer, at which time all the files are renamed into place in rapid
 succession.  This attempts to make the updating of the files a little more
 atomic.  By default the files are placed into a directory named ".~tmp~" in
-each file's destination directory, but you can override this by specifying
-the bf(--partial-dir) option.  (Note that RSYNC_PARTIAL_DIR has no effect
-on this value, nor is bf(--partial-dir) considered to be implied for the
-purposes of the daemon-config's "refuse options" setting.)
-Conflicts with bf(--inplace).
+each file's destination directory, but if you've specified the
+bf(--partial-dir) option, that directory will be used instead.  See the
+comments in the bf(--partial-dir) section for a discussion of how this
+".~tmp~" dir will be excluded from the transfer, and what you can do if
+you wnat rsync to cleanup old ".~tmp~" dirs that might be lying around.
+Conflicts with bf(--inplace) and bf(--append).
 
 This option uses more memory on the receiving side (one bit per file
 transferred) and also requires enough free disk space on the receiving
 side to hold an additional copy of all the updated files.  Note also that
-you should not use an absolute path to bf(--partial-dir) unless there is no
+you should not use an absolute path to bf(--partial-dir) unless (1)
+there is no
 chance of any of the files in the transfer having the same name (since all
 the updated files will be put into a single directory if the path is
-absolute).
+absolute)
+and (2) there are no mount points in the hierarchy (since the
+delayed updates will fail if they can't be renamed into place).
 
 See also the "atomic-rsync" perl script in the "support" subdir for an
 update algorithm that is even more atomic (it uses bf(--link-dest) and a
 parallel hierarchy of files).
 
+dit(bf(-m, --prune-empty-dirs)) This option tells the receiving rsync to get
+rid of empty directories from the file-list, including nested directories
+that have no non-directory children.  This is useful for avoiding the
+creation of a bunch of useless directories when the sending rsync is
+recursively scanning a hierarchy of files using include/exclude/filter
+rules.
+
+Because the file-list is actually being pruned, this option also affects
+what directories get deleted when a delete is active.  However, keep in
+mind that excluded files and directories can prevent existing items from
+being deleted (because an exclude hides source files and protects
+destination files).
+
+You can prevent the pruning of certain empty directories from the file-list
+by using a global "protect" filter.  For instance, this option would ensure
+that the directory "emptydir" was kept in the file-list:
+
+quote(    --filter 'protect emptydir/')
+
+Here's an example that copies all .pdf files in a hierarchy, only creating
+the necessary destination directories to hold the .pdf files, and ensures
+that any superfluous files and directories in the destination are removed
+(note the hide filter of non-directories being used instead of an exclude):
+
+quote(     rsync -avm --del --include='*.pdf' -f 'hide,! */' src/ dest)
+
+If you didn't want to remove superfluous destination files, the more
+time-honored options of "--include='*/' --exclude='*'" would work fine
+in place of the hide-filter (if that is more natural to you).
+
 dit(bf(--progress)) This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
 Implies bf(--verbose) if it wasn't already specified.
 
 When the file is transferring, the data looks like this:
@@ -1262,19 +1654,24 @@
 is only useful when accessing an rsync daemon using the built in
 transport, not when using a remote shell as the transport. The file
 must not be world readable. It should contain just the password as a
 single line.
 
 dit(bf(--list-only)) This option will cause the source files to be listed
-instead of transferred.  This option is inferred if there is no destination
-specified, so you don't usually need to use it explicitly.  However, it can
-come in handy for a user that wants to avoid the "bf(-r --exclude='/*/*')"
-options that rsync might use as a compatibility kluge when generating a
-non-recursive listing, or to list the files that are involved in a local
-copy (since the destination path is not optional for a local copy, you
-must specify this option explicitly and still include a destination).
+instead of transferred.  This option is inferred if there is a single source
+arg and no destination specified, so its main uses are: (1) to turn a copy
+command that includes a
+destination arg into a file-listing command, (2) to be able to specify more
+than one local source arg (note: be sure to include the destination), or
+(3) to avoid the automatically added "bf(-r --exclude='/*/*')" options that
+rsync usually uses as a compatibility kluge when generating a non-recursive
+listing.  Caution: keep in mind that a source arg with a wild-card is expanded
+by the shell into multiple args, so it is never safe to try to list such an arg
+without using this option.  For example:
+
+verb(    rsync -av --list-only foo* dest/)
 
 dit(bf(--bwlimit=KBPS)) This option allows you to specify a maximum
 transfer rate in kilobytes per second. This option is most effective when
 using rsync with large files (several megabytes and up). Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
 transfer was too fast, it will wait before sending the next data block. The
@@ -1301,13 +1698,13 @@
 system because this allows the batched data to be diverted from the sender
 into the batch file without having to flow over the wire to the receiver
 (when pulling, the sender is remote, and thus can't write the batch).
 
 dit(bf(--read-batch=FILE)) Apply all of the changes stored in FILE, a
 file previously generated by bf(--write-batch).
-If em(FILE) is "-" the batch data will be read from standard input.
+If em(FILE) is bf(-), the batch data will be read from standard input.
 See the "BATCH MODE" section for details.
 
 dit(bf(--protocol=NUM)) Force an older protocol version to be used.  This
 is useful for creating a batch file that is compatible with an older
 version of rsync.  For instance, if rsync 2.6.4 is being used with the
 bf(--write-batch) option, but rsync 2.6.3 is what will be used to run the
@@ -1359,13 +1756,13 @@
 requested value will be rounded down if they try to exceed it.  See the
 client version of this option (above) for some extra details.
 
 dit(bf(--config=FILE)) This specifies an alternate config file than
 the default.  This is only relevant when bf(--daemon) is specified.
 The default is /etc/rsyncd.conf unless the daemon is running over
-a remote shell program and the remote user is not root; in that case
+a remote shell program and the remote user is not the super-user; in that case
 the default is rsyncd.conf in the current directory (typically $HOME).
 
 dit(bf(--no-detach)) When running as a daemon, this option instructs
 rsync to not detach itself and become a background process.  This
 option is required when running as a service on Cygwin, and may also
 be useful when rsync is supervised by a program such as
@@ -1375,12 +1772,15 @@
 sshd.
 
 dit(bf(--port=PORT)) This specifies an alternate TCP port number for the
 daemon to listen on rather than the default of 873.  See also the "port"
 global option in the rsyncd.conf manpage.
 
+dit(bf(--sockopts)) This overrides the bf(socket options) setting in the
+rsyncd.conf file and has the same syntax.
+
 dit(bf(-v, --verbose)) This option increases the amount of information the
 daemon logs during its startup phase.  After the client connects, the
 daemon's verbosity level will be controlled by the options that the client
 used and the "max verbosity" setting in the module's config section.
 
 dit(bf(-4, --ipv4) or bf(-6, --ipv6)) Tells rsync to prefer IPv4/IPv6
@@ -1463,13 +1863,13 @@
 
 itemize(
   it() if the pattern starts with a / then it is anchored to a
   particular spot in the hierarchy of files, otherwise it is matched
   against the end of the pathname.  This is similar to a leading ^ in
   regular expressions.
-  Thus "/foo" would match a file called "foo" at either the "root of the
+  Thus "/foo" would match a file named "foo" at either the "root of the
   transfer" (for a global rule) or in the merge-file's directory (for a
   per-directory rule).
   An unqualified "foo" would match any file or directory named "foo"
   anywhere in the tree because the algorithm is applied recursively from
   the
   top down; it behaves as if each path component gets a turn at being the
@@ -1477,24 +1877,33 @@
   any point in the hierarchy where a "foo" was found within a directory
   named "sub".  See the section on ANCHORING INCLUDE/EXCLUDE PATTERNS for
   a full discussion of how to specify a pattern that matches at the root
   of the transfer.
   it() if the pattern ends with a / then it will only match a
   directory, not a file, link, or device.
-  it() if the pattern contains a wildcard character from the set
-  *?[ then expression matching is applied using the shell filename
-  matching rules. Otherwise a simple string match is used.
-  it() the double asterisk pattern "**" will match slashes while a
-  single asterisk pattern "*" will stop at slashes.
-  it() if the pattern contains a / (not counting a trailing /) or a "**"
+
+  it() rsync chooses between doing a simple string match and wildcard
+  matching by checking if the pattern contains one of these three wildcard
+  characters: '*', '?', and '[' .
+  it() a '*' matches any non-empty path component (it stops at slashes).
+  it() use '**' to match anything, including slashes.
+  it() a '?' matches any character except a slash (/).
+  it() a '[' introduces a character class, such as [a-z] or [[:alpha:]].
+  it() in a wildcard pattern, a backslash can be used to escape a wildcard
+  character, but it is matched literally when no wildcards are present.
+  it() if the pattern contains a / (not counting a trailing /) or a "**",
   then it is matched against the full pathname, including any leading
   directories. If the pattern doesn't contain a / or a "**", then it is
   matched only against the final component of the filename.
   (Remember that the algorithm is applied recursively so "full filename"
   can actually be any portion of a path from the starting directory on
   down.)
+  it() a trailing "dir_name/***" will match both the directory (as if
+  "dir_name/" had been specified) and all the files in the directory
+  (as if "dir_name/**" had been specified).  (This behavior is new for
+  version 2.6.7.)
 )
 
 Note that, when using the bf(--recursive) (bf(-r)) option (which is implied by
 bf(-a)), every subcomponent of every path is visited from the top down, so
 include/exclude patterns get applied recursively to each subcomponent's
 full name (e.g. to include "/foo/bar/baz" the subcomponents "/foo" and
@@ -1513,13 +1922,14 @@
 )
 
 This fails because the parent directory "some" is excluded by the '*'
 rule, so rsync never visits any of the files in the "some" or "some/path"
 directories.  One solution is to ask for all directories in the hierarchy
 to be included by using a single rule: "+ */" (put it somewhere before the
-"- *" rule).  Another solution is to add specific include rules for all
+"- *" rule), and perhaps use the bf(--prune-empty-dirs) option.  Another
+solution is to add specific include rules for all
 the parent dirs that need to be visited.  For instance, this set of rules
 works fine:
 
 quote(
 tt(+ /some/)nl()
 tt(+ /some/path/)nl()
@@ -1529,20 +1939,22 @@
 )
 
 Here are some examples of exclude/include matching:
 
 itemize(
   it() "- *.o" would exclude all filenames matching *.o
-  it() "- /foo" would exclude a file called foo in the transfer-root directory
-  it() "- foo/" would exclude any directory called foo
-  it() "- /foo/*/bar" would exclude any file called bar two
-  levels below a directory called foo in the transfer-root directory
-  it() "- /foo/**/bar" would exclude any file called bar two
-  or more levels below a directory called foo in the transfer-root directory
+  it() "- /foo" would exclude a file (or directory) named foo in the
+  transfer-root directory
+  it() "- foo/" would exclude any directory named foo
+  it() "- /foo/*/bar" would exclude any file named bar which is at two
+  levels below a directory named foo in the transfer-root directory
+  it() "- /foo/**/bar" would exclude any file named bar two
+  or more levels below a directory named foo in the transfer-root directory
   it() The combination of "+ */", "+ *.c", and "- *" would include all
-  directories and C source files but nothing else.
+  directories and C source files but nothing else (see also the
+  bf(--prune-empty-dirs) option)
   it() The combination of "+ foo/", "+ foo/bar.c", and "- *" would include
   only the foo directory and foo/bar.c (the foo directory must be
   explicitly included or it would be excluded by the "*")
 )
 
 manpagesection(MERGE-FILE FILTER RULES)
@@ -1590,26 +2002,28 @@
   it() A bf(w) specifies that the rules are word-split on whitespace instead
   of the normal line-splitting.  This also turns off comments.  Note: the
   space that separates the prefix from the rule is treated specially, so
   "- foo + bar" is parsed as two rules (assuming that prefix-parsing wasn't
   also disabled).
   it() You may also specify any of the modifiers for the "+" or "-" rules
-  (below) in order  to have the rules that are read-in from the file
+  (below) in order to have the rules that are read in from the file
   default to having that modifier set.  For instance, "merge,-/ .excl" would
   treat the contents of .excl as absolute-path excludes,
   while "dir-merge,s .filt" and ":sC" would each make all their
   per-directory rules apply only on the sending side.
 )
 
 The following modifiers are accepted after a "+" or "-":
 
 itemize(
-  it() A "/" specifies that the include/exclude should be treated as an
-  absolute path, relative to the root of the filesystem.  For example,
+  it() A "/" specifies that the include/exclude rule should be matched
+  against the absolute pathname of the current item.  For example,
   "-/ /etc/passwd" would exclude the passwd file any time the transfer
-  was sending files from the "/etc" directory.
+  was sending files from the "/etc" directory, and "-/ subdir/foo"
+  would always exclude "foo" when it is in a dir named "subdir", even
+  if "foo" is at the root of the current transfer.
   it() A "!" specifies that the include/exclude should take effect if
   the pattern fails to match.  For instance, "-! */" would exclude all
   non-directories.
   it() A bf(C) is used to indicate that all the global CVS-exclude rules
   should be inserted as excludes in place of the "-C".  No arg should
   follow.
@@ -1651,13 +2065,13 @@
 tt(+ *.[ch])nl()
 tt(- *.o)nl()
 )
 
 This will merge the contents of the /home/user/.global-filter file at the
 start of the list and also turns the ".rules" filename into a per-directory
-filter file.  All rules read-in prior to the start of the directory scan
+filter file.  All rules read in prior to the start of the directory scan
 follow the global anchoring rules (i.e. a leading slash matches at the root
 of the transfer).
 
 If a per-directory merge-file is specified with a path that is a parent
 directory of the first transfer directory, rsync will scan all the parent
 dirs from that starting point to the transfer directory for the indicated
@@ -1969,13 +2383,13 @@
 dit(bf(--links --copy-unsafe-links)) Turn all unsafe symlinks into files
 and duplicate all safe symlinks.
 
 dit(bf(--copy-unsafe-links)) Turn all unsafe symlinks into files, noisily
 skip all safe symlinks.
 
-dit(bf(--links --safe-links))  Duplicate safe symlinks and skip unsafe
+dit(bf(--links --safe-links)) Duplicate safe symlinks and skip unsafe
 ones.
 
 dit(bf(--links)) Duplicate all symlinks.
 
 manpagediagnostics()
 
@@ -2059,13 +2473,13 @@
 manpageseealso()
 
 rsyncd.conf(5)
 
 manpagebugs()
 
-times are transferred as unix time_t values
+times are transferred as *nix time_t values
 
 When transferring to FAT filesystems rsync may re-sync
 unmodified files.
 See the comments on the bf(--modify-window) option.
 
 file permissions, devices, etc. are transferred as native numerical
@@ -2075,13 +2489,13 @@
 
 Please report bugs! See the website at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 2.6.6 of rsync.
+This man page is current for version 2.6.7 of rsync.
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/runtests.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/runtests.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/runtests.sh	2005-02-21 05:04:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/runtests.sh	2006-02-05 03:44:19.000000000 +0800
@@ -82,13 +82,13 @@
 # about which Unix features they use.
 
 # We cannot count on Make exporting variables to commands, unless
 # they're explicitly given on the command line.
 
 # Also, we can't count on 'cp -a' or 'mkdir -p', although they're
-# pretty handy.
+# pretty handy (see function makepath for the latter).
 
 # I think some of the GNU documentation suggests that we shouldn't
 # rely on shell functions.  However, the Bash manual seems to say that
 # they're in POSIX 1003.2, and since the build farm relies on them
 # they're probably working on most machines we really care about.
 
@@ -97,12 +97,14 @@
 
 # BSD machines tend not to have "head" or "seq".
 
 # You cannot do "export VAR=VALUE" all on one line; the export must be
 # separate from the assignment.  (SCO SysV)
 
+# Don't rely on grep -q, as that doesn't work everywhere -- just redirect
+# stdout to /dev/null to keep it quiet.
 
 
 # STILL TO DO:
 
 # We need a good protection against tests that hang indefinitely.
 # Perhaps some combination of starting them in the background, wait,
@@ -121,12 +123,13 @@
 
 set -e
 
 . "./shconfig"
 
 RUNSHFLAGS='-e'
+export RUNSHFLAGS
 
 # for Solaris
 [ -d /usr/xpg4/bin ] && PATH="/usr/xpg4/bin/:$PATH"
 
 if [ "x$loglevel" != x ] && [ "$loglevel" -gt 8 ]; then
     if set -x; then
@@ -157,12 +160,18 @@
 if [ "x$preserve_scratch" = xyes ]; then
     echo "    preserve_scratch=yes"
 else
     echo "    preserve_scratch=no"
 fi    
 
+# We'll use setfacl if it's around and it supports the -k option.
+if setfacl --help 2>/dev/null | grep ' -k,' >/dev/null; then
+    setfacl=setfacl
+else
+    setfacl=true
+fi
 
 if [ ! -f "$rsync_bin" ]; then
     echo "rsync_bin $rsync_bin is not a file" >&2
     exit 2
 fi
 
@@ -191,12 +200,15 @@
 
 export scratchdir suitedir
 
 prep_scratch() {
     [ -d "$scratchdir" ] && rm -rf "$scratchdir"
     mkdir "$scratchdir"
+    # Get rid of default ACLs and dir-setgid to avoid confusing some tests.
+    $setfacl -k "$scratchdir"
+    chmod g-s "$scratchdir"
     return 0
 }
 
 maybe_discard_scratch() {
     [ x"$preserve_scratch" != xyes ] && [ -d "$scratchdir" ] && rm -rf "$scratchdir"
     return 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/sender.c	2005-05-19 16:52:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/sender.c	2006-01-15 04:26:24.000000000 +0800
@@ -24,12 +24,13 @@
 extern int am_server;
 extern int am_daemon;
 extern int log_before_transfer;
 extern int log_format_has_i;
 extern int daemon_log_format_has_i;
 extern int csum_length;
+extern int append_mode;
 extern int io_error;
 extern int allowed_lull;
 extern int protocol_version;
 extern int remove_sent_files;
 extern int updating_basis_file;
 extern int make_backups;
@@ -69,12 +70,19 @@
 
 	if (verbose > 3) {
 		rprintf(FINFO, "count=%.0f n=%ld rem=%ld\n",
 			(double)s->count, (long)s->blength, (long)s->remainder);
 	}
 
+	if (append_mode) {
+		s->flength = (OFF_T)s->count * s->blength;
+		if (s->remainder)
+			s->flength -= s->blength - s->remainder;
+		return s;
+	}
+
 	if (s->count == 0)
 		return(s);
 
 	if (!(s->sums = new_array(struct sum_buf, s->count)))
 		out_of_memory("receive_sums");
 
@@ -122,17 +130,15 @@
 		return;
 	if (file->dir.root) {
 		offset = stringjoin(fname, sizeof fname,
 				    file->dir.root, "/", NULL);
 	} else
 		offset = 0;
-	f_name_to(file, fname + offset);
-	if (remove_sent_files && do_unlink(fname) == 0 && verbose > 1) {
-		rprintf(FINFO, "sender removed %s\n",
-			safe_fname(fname + offset));
-	}
+	f_name(file, fname + offset);
+	if (remove_sent_files && do_unlink(fname) == 0 && verbose > 1)
+		rprintf(FINFO, "sender removed %s\n", fname + offset);
 }
 
 static void write_ndx_and_attrs(int f_out, int ndx, int iflags,
 				uchar fnamecmp_type, char *buf, int len)
 {
 	write_int(f_out, ndx);
@@ -228,12 +234,13 @@
 			if (verbose > 2)
 				rprintf(FINFO, "send_files phase=%d\n", phase);
 			write_int(f_out, -1);
 			/* For inplace: redo phase turns off the backup
 			 * flag so that we do a regular inplace send. */
 			make_backups = 0;
+			append_mode = 0;
 			continue;
 		}
 
 		iflags = read_item_attrs(f_in, f_out, i, &fnamecmp_type,
 					 xname, &xlen);
 		if (iflags == ITEM_IS_NEW) /* no-op packet */
@@ -244,13 +251,13 @@
 			/* N.B. We're sure that this fits, so offset is OK. */
 			offset = strlcpy(fname, file->dir.root, sizeof fname);
 			if (!offset || fname[offset-1] != '/')
 				fname[offset++] = '/';
 		} else
 			offset = 0;
-		fname2 = f_name_to(file, fname + offset);
+		fname2 = f_name(file, fname + offset);
 
 		if (verbose > 2)
 			rprintf(FINFO, "send_files(%d, %s)\n", i, fname);
 
 		if (!(iflags & ITEM_TRANSFER)) {
 			maybe_log_item(file, iflags, itemizing, xname);
@@ -319,28 +326,26 @@
 			mbuf = map_file(fd, st.st_size, read_size, s->blength);
 		} else
 			mbuf = NULL;
 
 		if (verbose > 2) {
 			rprintf(FINFO, "send_files mapped %s of size %.0f\n",
-				safe_fname(fname), (double)st.st_size);
+				fname, (double)st.st_size);
 		}
 
 		write_ndx_and_attrs(f_out, i, iflags, fnamecmp_type,
 				    xname, xlen);
 		write_sum_head(f_xfer, s);
 
-		if (verbose > 2) {
-			rprintf(FINFO, "calling match_sums %s\n",
-				safe_fname(fname));
-		}
+		if (verbose > 2)
+			rprintf(FINFO, "calling match_sums %s\n", fname);
 
 		if (log_before_transfer)
 			log_item(file, &initial_stats, iflags, NULL);
 		else if (!am_server && verbose && do_progress)
-			rprintf(FINFO, "%s\n", safe_fname(fname2));
+			rprintf(FINFO, "%s\n", fname2);
 
 		set_compression(fname);
 
 		match_sums(f_xfer, s, mbuf, st.st_size);
 		if (do_progress)
 			end_progress(st.st_size);
@@ -358,16 +363,14 @@
 			}
 		}
 		close(fd);
 
 		free_sums(s);
 
-		if (verbose > 2) {
-			rprintf(FINFO, "sender finished %s\n",
-				safe_fname(fname));
-		}
+		if (verbose > 2)
+			rprintf(FINFO, "sender finished %s\n", fname);
 
 		/* Flag that we actually sent this entry. */
 		file->flags |= FLAG_SENT;
 	}
 	make_backups = save_make_backups;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/socket.c	2005-04-15 00:08:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/socket.c	2006-03-07 16:46:29.000000000 +0800
@@ -33,12 +33,16 @@
 
 #include "rsync.h"
 
 extern char *bind_address;
 extern int default_af_hint;
 
+#ifdef HAVE_SIGACTION
+static struct sigaction sigact;
+#endif
+
 /**
  * Establish a proxy connection on an open socket to a web proxy by
  * using the CONNECT method. If proxy_user and proxy_pass are not NULL,
  * they are used to authenticate to the proxy using the "Basic"
  * proxy-authorization protocol
  **/
@@ -51,19 +55,19 @@
 
 	if (proxy_user && proxy_pass) {
 		stringjoin(buffer, sizeof buffer,
 			 proxy_user, ":", proxy_pass, NULL);
 		len = strlen(buffer);
 
-		if ((len*8 + 5) / 6 >= (int)sizeof authbuf) {
+		if ((len*8 + 5) / 6 >= (int)sizeof authbuf - 3) {
 			rprintf(FERROR,
 				"authentication information is too long\n");
 			return -1;
 		}
 
-		base64_encode(buffer, len, authbuf);
+		base64_encode(buffer, len, authbuf, 1);
 		authhdr = "\r\nProxy-Authorization: Basic ";
 	} else {
 		*authbuf = '\0';
 		authhdr = "";
 	}
 
@@ -430,21 +434,27 @@
 
 static RETSIGTYPE sigchld_handler(UNUSED(int val))
 {
 #ifdef WNOHANG
 	while (waitpid(-1, NULL, WNOHANG) > 0) {}
 #endif
+#ifndef HAVE_SIGACTION
 	signal(SIGCHLD, sigchld_handler);
+#endif
 }
 
 
 void start_accept_loop(int port, int (*fn)(int, int))
 {
 	fd_set deffds;
 	int *sp, maxfd, i;
 
+#ifdef HAVE_SIGACTION
+	sigact.sa_flags = SA_NOCLDSTOP;
+#endif
+
 	/* open an incoming socket */
 	sp = open_socket_in(SOCK_STREAM, port, bind_address, default_af_hint);
 	if (sp == NULL)
 		exit_cleanup(RERR_SOCKETIO);
 
 	/* ready to listen */
@@ -497,13 +506,13 @@
 			}
 		}
 
 		if (fd < 0)
 			continue;
 
-		signal(SIGCHLD, sigchld_handler);
+		SIGACTION(SIGCHLD, sigchld_handler);
 
 		if ((pid = fork()) == 0) {
 			int ret;
 			for (i = 0; sp[i] >= 0; i++)
 				close(sp[i]);
 			/* Re-open log file in child before possibly giving
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/support: files-to-excludes
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/support: logfilter
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/support/rsyncstats /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/support/rsyncstats
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/support/rsyncstats	2005-02-20 03:36:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/support/rsyncstats	2006-02-02 18:20:13.000000000 +0800
@@ -9,13 +9,13 @@
 #
 # Andrew Tridgell, October 1998
 
 use Getopt::Long;
 
 # You may wish to edit the next line to customize for your default log file.
-$usage_file = "/var/adm/rsyncd.log";
+$usage_file = "/var/log/rsyncd.log";
 
 # Edit the following lines for default report settings.
 # Entries defined here will be over-ridden by the command line.
 
 $hourly_report = 0; 
 $domain_report = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/support/savetransfer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/support/savetransfer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/support/savetransfer.c	2005-02-14 10:34:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/support/savetransfer.c	2005-12-20 00:57:55.000000000 +0800
@@ -4,26 +4,19 @@
  *
  * Usage: savetransfer [-i|-o] OUTPUT_FILE PROGRAM [ARGS...]
  * -i  Save the input going to PROGRAM to the OUTPUT_FILE
  * -o  Save the output coming from PROGRAM to the OUTPUT_FILE
  *
  * If you want to capture the flow of data for an rsync command, use one of
- * the following commands (the first two are push commands, the last two are
- * pull commands):
+ * the following commands (the resulting files should be identical):
  *
- * rsync -av --rsh="savetransfer -i /tmp/from.sender ssh"
- *   --rsync-path="savetransfer -i /tmp/to.receiver rsync" FILES HOST:DEST
+ * rsync -av --rsh="savetransfer -i /tmp/to.server ssh"
+ *   --rsync-path="savetransfer -i /tmp/from.client rsync" SOURCE DEST
  *
- * rsync -av --rsh="savetransfer -o /tmp/to.sender ssh"
- *   --rsync-path="savetransfer -o /tmp/from.generator rsync" FILES HOST:DEST
- *
- * rsync -av --rsh="savetransfer -i /tmp/from.generator ssh"
- *   --rsync-path="savetransfer -i /tmp/to.sender rsync" HOST:FILES DEST
- *
- * rsync -av --rsh="savetransfer -o /tmp/to.receiver ssh"
- *   --rsync-path="savetransfer -o /tmp/from.sender rsync" HOST:FILES DEST
+ * rsync -av --rsh="savetransfer -o /tmp/from.server ssh"
+ *   --rsync-path="savetransfer -o /tmp/to.client rsync" SOURCE DEST
  *
  * Note that this program aborts after 30 seconds of inactivity, so you'll need
  * to change it if that is not enough dead time for your transfer.  Also, some
  * of the above commands will not notice that the transfer is done (if we're
  * saving the input to a PROGRAM and the PROGRAM goes away:  we won't notice
  * that it's gone unless more data comes in) -- when this happens it will delay
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/syscall.c	2005-04-06 10:08:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/syscall.c	2006-01-30 02:52:53.000000000 +0800
@@ -42,28 +42,28 @@
 			return -1; \
 		} \
 	} while (0)
 
 #define RETURN_ERROR_IF_RO_OR_LO RETURN_ERROR_IF(read_only || list_only, EROFS)
 
-int do_unlink(char *fname)
+int do_unlink(const char *fname)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	return unlink(fname);
 }
 
-int do_symlink(char *fname1, char *fname2)
+int do_symlink(const char *fname1, const char *fname2)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	return symlink(fname1, fname2);
 }
 
 #ifdef HAVE_LINK
-int do_link(char *fname1, char *fname2)
+int do_link(const char *fname1, const char *fname2)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	return link(fname1, fname2);
 }
 #endif
@@ -101,30 +101,34 @@
 
 		if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0
 		    || (unlink(pathname) < 0 && errno != ENOENT)
 		    || (bind(sock, (struct sockaddr*)&saddr, sizeof saddr)) < 0)
 			return -1;
 		close(sock);
+#ifdef HAVE_CHMOD
 		return do_chmod(pathname, mode);
+#else
+		return 0;
+#endif
 	}
 #endif
 #ifdef HAVE_MKNOD
 	return mknod(pathname, mode, dev);
 #else
 	return -1;
 #endif
 }
 
-int do_rmdir(char *pathname)
+int do_rmdir(const char *pathname)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	return rmdir(pathname);
 }
 
-int do_open(char *pathname, int flags, mode_t mode)
+int do_open(const char *pathname, int flags, mode_t mode)
 {
 	if (flags != O_RDONLY) {
 		RETURN_ERROR_IF(dry_run, 0);
 		RETURN_ERROR_IF_RO_OR_LO;
 	}
 
@@ -134,20 +138,27 @@
 #ifdef HAVE_CHMOD
 int do_chmod(const char *path, mode_t mode)
 {
 	int code;
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
-	code = chmod(path, mode);
+	if (S_ISLNK(mode)) {
+#ifdef HAVE_LCHMOD
+		code = lchmod(path, mode & CHMOD_BITS);
+#else
+		code = 1;
+#endif
+	} else
+		code = chmod(path, mode & CHMOD_BITS);
 	if (code != 0 && preserve_perms)
 	    return code;
 	return 0;
 }
 #endif
 
-int do_rename(char *fname1, char *fname2)
+int do_rename(const char *fname1, const char *fname2)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	return rename(fname1, fname2);
 }
 
@@ -241,13 +249,17 @@
 #endif
 }
 
 OFF_T do_lseek(int fd, OFF_T offset, int whence)
 {
 #ifdef HAVE_LSEEK64
+#if !SIZEOF_OFF64_T
+	OFF_T lseek64();
+#else
 	off64_t lseek64();
+#endif
 	return lseek64(fd, offset, whence);
 #else
 	return lseek(fd, offset, whence);
 #endif
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/batch-mode.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/batch-mode.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/batch-mode.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/batch-mode.test	2006-02-04 01:58:48.000000000 +0800
@@ -6,14 +6,12 @@
 # COPYING).
 
 # Test rsync's --write-batch and --read-batch options
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 hands_setup
 
 cd "$tmpdir"
 
 # Build chkdir for the daemon tests using a normal rsync and an --exclude.
 $RSYNC -av --exclude=foobar.baz "$fromdir/" "$chkdir/"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/chgrp.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/chgrp.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/chgrp.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/chgrp.test	2006-02-04 01:58:48.000000000 +0800
@@ -8,14 +8,12 @@
 # Test that rsync with -gr will preserve groups when the user running
 # the test is a member of them.  Hopefully they're in at least one
 # test.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 # Build some hardlinks
 
 mygrps="`rsync_getgroups`" || fail "Can't get groups"
 mkdir "$fromdir"
 
 for g in $mygrps
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite: chmod-option.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/chmod-temp-dir.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/chmod-temp-dir.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/chmod-temp-dir.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/chmod-temp-dir.test	2006-02-05 03:29:13.000000000 +0800
@@ -1,21 +1,19 @@
 #! /bin/sh
 
 # Copyright (C) 2004 by Wayne Davison <wayned@samba.org>
 
-# This program is distributable under the terms of the GNU GPL see
+# This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test that various read-only and set[ug]id permissions work properly,
 # even when using a --temp-dir option (which we try to point at a
 # different filesystem than the destination dir).
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 hands_setup
 
 tmpdir2=/tmp
 sdev=`$TOOLDIR/getfsdev $scratchdir`
 tdev=`$TOOLDIR/getfsdev $tmpdir2`
 if [ x$sdev = x$tdev ]; then
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/chmod.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/chmod.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/chmod.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/chmod.test	2006-02-05 03:29:13.000000000 +0800
@@ -1,21 +1,19 @@
 #! /bin/sh
 
 # Copyright (C) 2004 by Wayne Davison <wayned@samba.org>
 
-# This program is distributable under the terms of the GNU GPL see
+# This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test that various read-only and set[ug]id permissions work properly,
 # even when using a --temp-dir option (which we try to point at a
 # different filesystem than the destination dir).
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 hands_setup
 
 chmod 440 "$fromdir/text"
 chmod 500 "$fromdir/dir/text"
 e="$fromdir/dir/subdir/foobar.baz"
 chmod 6450 "$e" || chmod 2450 "$e" || chmod 1450 "$e" || chmod 450 "$e"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/chown.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/chown.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/chown.test	2005-03-18 10:10:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/chown.test	2006-02-04 01:58:48.000000000 +0800
@@ -10,14 +10,12 @@
 
 # We don't know what users will be present on this system, so we just
 # use random numeric uids and gids.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 case `id -u` in
 '') ;; # If "id" failed, try to continue...
 0)  ;;
 *)  if [ -f /usr/bin/fakeroot ]; then
 	echo "Let's try re-running the script under fakeroot..."
 	exec /usr/bin/fakeroot /bin/sh "$0"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/compare-dest.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/compare-dest.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/compare-dest.test	2005-03-12 01:36:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/compare-dest.test	2006-02-05 03:29:13.000000000 +0800
@@ -1,24 +1,22 @@
 #! /bin/sh
 
 # Copyright (C) 2004 by Wayne Davison <wayned@samba.org>
 
-# This program is distributable under the terms of the GNU GPL see
+# This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test rsync handling of the --compare-dest option.
 
 . "$suitedir/rsync.fns"
 
 alt1dir="$tmpdir/alt1"
 alt2dir="$tmpdir/alt2"
 
 # Build some files/dirs/links to copy
 
-set -x
-
 hands_setup
 
 # Setup the alt and chk dirs
 $RSYNC -av --include=text --include='*/' --exclude='*' "$fromdir/" "$alt1dir/"
 $RSYNC -av --include=etc-ltr-list --include='*/' --exclude='*' "$fromdir/" "$alt2dir/"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/daemon-gzip-download.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/daemon-gzip-download.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/daemon-gzip-download.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/daemon-gzip-download.test	2006-02-04 01:58:48.000000000 +0800
@@ -23,14 +23,12 @@
 
 build_rsyncd_conf
 
 RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
-set -x
-
 hands_setup
 
 # Build chkdir with a normal rsync and an --exclude.
 $RSYNC -av --exclude=foobar.baz "$fromdir/" "$chkdir/"
 
 checkit "$RSYNC -avvvvz localhost::test-from/ \"$todir/\"" "$chkdir" "$todir"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/daemon-gzip-upload.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/daemon-gzip-upload.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/daemon-gzip-upload.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/daemon-gzip-upload.test	2006-02-04 01:58:48.000000000 +0800
@@ -17,14 +17,12 @@
 
 build_rsyncd_conf
 
 RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
-set -x
-
 hands_setup
 
 # Build chkdir with a normal rsync and an --exclude.
 $RSYNC -av --exclude=foobar.baz "$fromdir/" "$chkdir/"
 
 checkit "$RSYNC -avvvvz \"$fromdir/\" localhost::test-to/" "$chkdir" "$todir"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/delete.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/delete.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/delete.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/delete.test	2006-02-05 03:29:13.000000000 +0800
@@ -1,19 +1,17 @@
 #! /bin/sh
 
 # Copyright (C) 2005 by Wayne Davison <wayned@samba.org>
 
-# This program is distributable under the terms of the GNU GPL see
+# This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test rsync handling of various delete directives.  
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 hands_setup
 
 makepath "$chkdir"
 
 # Create two chk dirs, one with a copy of the source files, and one with
 # what we expect to be left behind by the copy using --remove-sent-files.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/devices.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/devices.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/devices.test	2005-03-18 10:10:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/devices.test	2006-02-09 09:17:01.000000000 +0800
@@ -6,34 +6,88 @@
 # COPYING).
 
 # Test rsync handling of devices.  This can only run if you're root.
 
 . "$suitedir/rsync.fns"
 
+chkfile="$scratchdir/rsync.chk"
+outfile="$scratchdir/rsync.out"
+
 # Build some hardlinks
 
 case `id -u` in
 '') ;; # If "id" failed, try to continue...
 0)  ;;
 *)  if [ -f /usr/bin/fakeroot ]; then
 	echo "Let's try re-running the script under fakeroot..."
-	exec /usr/bin/fakeroot /bin/sh "$0"
+	exec /usr/bin/fakeroot /bin/sh $RUNSHFLAGS "$0"
     fi
     test_skipped "Rsync won't copy devices unless we're root"
     ;;
 esac
 
 # TODO: Need to test whether hardlinks are possible on this OS/filesystem
 
 mkdir "$fromdir"
+mkdir "$todir"
 mknod "$fromdir/char" c 41 67  || test_skipped "Can't create char device node unless root"
 mknod "$fromdir/char2" c 42 68  || test_skipped "Can't create char device node unless root"
 mknod "$fromdir/char3" c 42 69  || test_skipped "Can't create char device node unless root"
 mknod "$fromdir/block" b 42 69 || test_skipped "Can't create block device node unless root"
 mknod "$fromdir/block2" b 42 73 || test_skipped "Can't create block device node unless root"
 mknod "$fromdir/block3" b 105 73 || test_skipped "Can't create block device node unless root"
+ln "$fromdir/block3" "$fromdir/block2.5" || echo "Skipping hard-linked device test..."
 mkfifo "$fromdir/fifo" || test_skipped "Can't run mkfifo"
+touch -r "$fromdir/block" "$fromdir/block2"
 
-checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" skip_file_diff
+$RSYNC -ai "$fromdir/block" "$todir/block2" \
+    | tee "$outfile"
+cat <<EOT >"$chkfile"
+cD+++++++ block
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 1 failed"
+
+$RSYNC -ai "$fromdir/block2" "$todir/block" \
+    | tee "$outfile"
+cat <<EOT >"$chkfile"
+cD+++++++ block2
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 2 failed"
+
+sleep 1
+
+$RSYNC -Di "$fromdir/block3" "$todir/block" \
+    | tee "$outfile"
+cat <<EOT >"$chkfile"
+cD..T.... block3
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 3 failed"
+
+$RSYNC -aiHvv "$fromdir/" "$todir/" \
+    | tee "$outfile"
+filter_outfile
+cat <<EOT >"$chkfile"
+.d..t.... ./
+cD..t.... block
+cD....... block2
+cD+++++++ block3
+hD+++++++ block2.5 => block3
+cD+++++++ char
+cD+++++++ char2
+cD+++++++ char3
+cS+++++++ fifo
+EOT
+if test ! -b "$fromdir/block2.5"; then
+    sed -e '/block2\.5/d' \
+	<"$chkfile" >"$chkfile.new"
+    mv "$chkfile.new" "$chkfile"
+fi
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 4 failed"
+
+echo "check how the directory listings compare with diff:"
+echo ""
+( cd "$fromdir" && rsync_ls_lR . ) > "$tmpdir/ls-from"
+( cd "$todir" && rsync_ls_lR . ) > "$tmpdir/ls-to"
+diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite: dir-sgid.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/duplicates.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/duplicates.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/duplicates.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/duplicates.test	2006-02-05 03:29:13.000000000 +0800
@@ -1,11 +1,11 @@
 #! /bin/sh
 
 # Copyright (C) 2002 by Martin Pool <mbp@samba.org>
 
-# This program is distributable under the terms of the GNU GPL see
+# This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test rsync handling of duplicate filenames.  
 
 # It's quite possible that the user might specify the same source file
 # more than once on the command line, perhaps through shell variables
@@ -18,14 +18,12 @@
 # always rename-and-replace the new copy, they can't affect us.
 
 # This test is not great, because it is a timing-dependent bug.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 # Build some hardlinks
 
 mkdir "$fromdir"
 name1="$fromdir/name1"
 name2="$fromdir/name2"
 echo "This is the file" > "$name1"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/exclude.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/exclude.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/exclude.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/exclude.test	2006-02-05 03:29:13.000000000 +0800
@@ -1,47 +1,48 @@
 #! /bin/sh
 
 # Copyright (C) 2003, 2004, 2005 by Wayne Davison <wayned@samba.org>
 
-# This program is distributable under the terms of the GNU GPL see
+# This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test rsync handling of exclude/include directives.  
 
 # Test some of the more obscure wildcard handling of exclude/include
 # processing.
 
 . "$suitedir/rsync.fns"
 
-HOME="$scratchdir"
 CVSIGNORE='*.junk'
-export HOME CVSIGNORE
-
-set -x
+export CVSIGNORE
 
 # Build some files/dirs/links to copy
 
 makepath "$fromdir/foo/down/to/you"
+makepath "$fromdir/foo/sub"
 makepath "$fromdir/bar/down/to/foo/too"
 makepath "$fromdir/bar/down/to/bar/baz"
 makepath "$fromdir/mid/for/foo/and/that/is/who"
+makepath "$fromdir/new/keep/this"
+makepath "$fromdir/new/lose/this"
 cat >"$fromdir/.filt" <<EOF
 exclude down
 : .filt-temp
 clear
 - .filt
 - *.bak
 - *.old
 EOF
-echo kept >"$fromdir/foo/file1"
+echo filtered-1 >"$fromdir/foo/file1"
 echo removed >"$fromdir/foo/file2"
 echo cvsout >"$fromdir/foo/file2.old"
 cat >"$fromdir/foo/.filt" <<EOF
 include .filt
-- file1
+- /file1
 EOF
+echo not-filtered-1 >"$fromdir/foo/sub/file1"
 cat >"$fromdir/bar/.filt" <<EOF
 - home-cvs-exclude
 dir-merge .filt2
 + to
 EOF
 echo cvsout >"$fromdir/bar/down/to/home-cvs-exclude"
@@ -84,14 +85,18 @@
 !
 # If the second line of these two lines does anything, it's a bug.
 + **/bar
 - /bar
 # This should match against the whole path, not just the name.
 + foo**too
-# This should float at the end of the path.
+# These should float at the end of the path.
++ foo/s?b/
 - foo/*/
+# Test how /** differs from /***
+- new/keep/**
+- new/lose/***
 # Test some normal excludes.  Competing lines are paired.
 + t[o]/
 - to
 + file4
 - file[2-9]
 - /mid/for/foo/extra
@@ -106,12 +111,14 @@
 checkit "$RSYNC -avv \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
 
 sleep 1 # Ensures that the rm commands will tweak the directory times.
 
 rm -r "$chkdir"/foo/down
 rm -r "$chkdir"/mid/for/foo/and
+rm -r "$chkdir"/new/keep/this
+rm -r "$chkdir"/new/lose
 rm "$chkdir"/foo/file[235-9]
 rm "$chkdir"/bar/down/to/foo/to "$chkdir"/bar/down/to/foo/file[235-9]
 rm "$chkdir"/mid/for/foo/extra
 
 # Un-tweak the directory times in our first (weak) exclude test (though
 # it's a good test of the --existing option).
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite: executability.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/fuzzy.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/fuzzy.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/fuzzy.test	2005-03-15 06:17:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/fuzzy.test	2006-02-05 03:29:13.000000000 +0800
@@ -1,19 +1,17 @@
 #! /bin/sh
 
 # Copyright (C) 2005 by Wayne Davison <wayned@samba.org>
 
-# This program is distributable under the terms of the GNU GPL see
+# This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test rsync handling of the --fuzzy option.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 mkdir "$fromdir"
 mkdir "$todir"
 
 cp -p "$srcdir"/rsync.c "$fromdir"/rsync.c
 cp -p "$fromdir"/rsync.c "$todir"/rsync2.c
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/hardlinks.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/hardlinks.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/hardlinks.test	2005-04-27 00:25:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/hardlinks.test	2006-02-04 01:58:48.000000000 +0800
@@ -9,14 +9,12 @@
 # not detect symlinks and they get split into different files.  If you
 # specify -H, then hard links are detected and recreated as hardlinks
 # on the other end.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 # Build some hardlinks
 
 fromdir="$scratchdir/from"
 todir="$scratchdir/to"
 
 # TODO: Need to test whether hardlinks are possible on this OS/filesystem
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/itemize.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/itemize.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/itemize.test	2005-06-24 10:14:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/itemize.test	2006-02-09 09:17:01.000000000 +0800
@@ -1,38 +1,23 @@
 #! /bin/sh
 
 # Copyright (C) 2005 by Wayne Davison <wayned@samba.org>
 
-# This program is distributable under the terms of the GNU GPL see
+# This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
 # Test the output of various copy commands to ensure itemized output
 # and double-verbose output is correct.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 lddir="$tmpdir/ld"
 
 chkfile="$scratchdir/rsync.chk"
 outfile="$scratchdir/rsync.out"
 
-# This is only called if rsync was run with -v or -vv (not -i alone).
-# Higher levels of -v would require more filtering.
-filter_outfile() {
-    sed -e '/^building file list /d' \
-	-e '/^created directory /d' \
-	-e '/^done$/d' \
-	-e '/ --whole-file$/d' \
-	-e '/^total: /d' \
-	-e '/^$/,$d' \
-	<"$outfile" >"$outfile.new"
-    mv "$outfile.new" "$outfile"
-}
-
 makepath "$fromdir/foo"
 makepath "$fromdir/bar/baz"
 cp -p "$srcdir/configure.in" "$fromdir/foo/config1"
 cp -p "$srcdir/config.h.in" "$fromdir/foo/config2"
 cp -p "$srcdir/rsync.h" "$fromdir/bar/baz/rsync"
 chmod 600 "$fromdir"/foo/config? "$fromdir/bar/baz/rsync"
@@ -149,30 +134,138 @@
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
 .d..t.... ./
 cd+++++++ bar/
 cd+++++++ bar/baz/
-cf....... bar/baz/rsync
+cf        bar/baz/rsync
 cd+++++++ foo/
-cf....... foo/config1
-cf....... foo/config2
-hf+++++++ foo/extra => foo/config1
-cL+++++++ foo/sym -> ../bar/baz/rsync
+cf        foo/config1
+cf        foo/config2
+hf        foo/extra => foo/config1
+cL..T.... foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 8 failed"
 
 rm -rf "$todir"
-$RSYNC -iplrtH --link-dest="$lddir" "$fromdir/" "$todir/" \
+$RSYNC -iplrtH --copy-dest="$lddir" "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
 .d..t.... ./
 cd+++++++ bar/
 cd+++++++ bar/baz/
 cd+++++++ foo/
-hf+++++++ foo/extra => foo/config1
-cL+++++++ foo/sym -> ../bar/baz/rsync
+hf        foo/extra => foo/config1
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 9 failed"
 
+rm -rf "$todir"
+$RSYNC -vvplrtH --copy-dest="$lddir" "$fromdir/" "$todir/" \
+    | tee "$outfile"
+filter_outfile
+cat <<EOT >"$chkfile"
+./
+bar/
+bar/baz/
+bar/baz/rsync is uptodate
+foo/
+foo/config1 is uptodate
+foo/config2 is uptodate
+"foo/extra" is a hard link
+foo/extra => foo/config1
+foo/sym is uptodate
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 10 failed"
+
+rm -rf "$todir"
+$RSYNC -ivvplrtH --link-dest="$lddir" "$fromdir/" "$todir/" \
+    | tee "$outfile"
+filter_outfile
+cat <<EOT >"$chkfile"
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+hf        bar/baz/rsync
+cd+++++++ foo/
+hf        foo/config1
+hf        foo/config2
+hf        foo/extra => foo/config1
+hL        foo/sym -> ../bar/baz/rsync
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 11 failed"
+
+rm -rf "$todir"
+$RSYNC -iplrtH --link-dest="$lddir" "$fromdir/" "$todir/" \
+    | tee "$outfile"
+cat <<EOT >"$chkfile"
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+cd+++++++ foo/
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 12 failed"
+
+rm -rf "$todir"
+$RSYNC -vvplrtH --link-dest="$lddir" "$fromdir/" "$todir/" \
+    | tee "$outfile"
+filter_outfile
+cat <<EOT >"$chkfile"
+./
+bar/
+bar/baz/
+bar/baz/rsync is uptodate
+foo/
+foo/config1 is uptodate
+foo/config2 is uptodate
+"foo/extra" is a hard link
+foo/sym is uptodate
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 13 failed"
+
+rm -rf "$todir"
+$RSYNC -ivvplrtH --compare-dest="$lddir" "$fromdir/" "$todir/" \
+    | tee "$outfile"
+filter_outfile
+# TODO fix really-old problem when combining -H with --compare-dest:
+# missing output for foo/extra hard-link (and it might not be updated)!
+cat <<EOT >"$chkfile"
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+.f        bar/baz/rsync
+cd+++++++ foo/
+.f        foo/config1
+.f        foo/config2
+.L        foo/sym -> ../bar/baz/rsync
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 14 failed"
+
+rm -rf "$todir"
+$RSYNC -iplrtH --compare-dest="$lddir" "$fromdir/" "$todir/" \
+    | tee "$outfile"
+cat <<EOT >"$chkfile"
+.d..t.... ./
+cd+++++++ bar/
+cd+++++++ bar/baz/
+cd+++++++ foo/
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 15 failed"
+
+rm -rf "$todir"
+$RSYNC -vvplrtH --compare-dest="$lddir" "$fromdir/" "$todir/" \
+    | tee "$outfile"
+filter_outfile
+cat <<EOT >"$chkfile"
+./
+bar/
+bar/baz/
+bar/baz/rsync is uptodate
+foo/
+foo/config1 is uptodate
+foo/config2 is uptodate
+"foo/extra" is a hard link
+foo/sym is uptodate
+EOT
+diff $diffopt "$chkfile" "$outfile" || test_fail "test 16 failed"
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/longdir.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/longdir.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/longdir.test	2005-03-24 00:04:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/longdir.test	2006-02-04 01:58:48.000000000 +0800
@@ -4,14 +4,12 @@
 # Copyright (C) 2001 by Martin Pool <mbp@samba.org>
 #
 # This program is distributable under the terms of the GNU GPL (see COPYING)
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 hands_setup
 
 longname=This-is-a-directory-with-a-stupidly-long-name-created-in-an-attempt-to-provoke-an-error-found-in-2.0.11-that-should-hopefully-never-appear-again-if-this-test-does-its-job
 longdir="$fromdir/$longname/$longname/$longname"
 
 makepath "$longdir" || test_skipped "unable to create long directory"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/merge.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/merge.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/merge.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/merge.test	2006-02-04 01:58:48.000000000 +0800
@@ -6,14 +6,12 @@
 # COPYING).
 
 # Make sure we can merge files from multiple directories into one.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 # Build some files/dirs/links to copy
 
 from1dir="${fromdir}1"
 from2dir="${fromdir}2"
 from3dir="${fromdir}3"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/rsync.fns /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/rsync.fns
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/rsync.fns	2005-06-11 04:04:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/rsync.fns	2006-02-05 03:27:07.000000000 +0800
@@ -29,33 +29,59 @@
 if diff -u "$srcdir/testsuite/rsync.fns" "$srcdir/testsuite/rsync.fns" >/dev/null 2>&1; then
     diffopt="-u"
 else
     diffopt="-c"
 fi
 
+HOME="$scratchdir"
+export HOME
+
 runtest() {
     echo $ECHO_N "Test $1: $ECHO_C"
     if eval "$2"
     then
 	echo "$ECHO_T	done."
 	return 0
     else
 	echo "$ECHO_T failed!"
 	return 1
     fi
 }
 
+# Call this if you want to filter out verbose messages (-v or -vv) from
+# the output of an rsync run (whittling the output down to just the file
+# messages).  This isn't needed if you use -i without -v.
+filter_outfile() {
+    sed -e '/^building file list /d' \
+	-e '/^created directory /d' \
+	-e '/^done$/d' \
+	-e '/ --whole-file$/d' \
+	-e '/^total: /d' \
+	-e '/^$/,$d' \
+	<"$outfile" >"$outfile.new"
+    mv "$outfile.new" "$outfile"
+}
+
 printmsg() {
     echo "$1"
 }
 
-
 rsync_ls_lR() {
     find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls"
 }
 
+check_perms() {
+    perms=`"$TOOLDIR/tls" "$1" | sed 's/^[-d]\(.........\).*/\1/'`
+    if test $perms = $2; then
+	return 0
+    fi
+    echo "permissions: $perms on $1"
+    echo "should be:   $2"
+    test_fail "failed test $3"
+}
+
 rsync_getgroups() { 
     "$TOOLDIR/getgroups"
 }
 
 
 ####################
@@ -115,13 +141,13 @@
 }
 
 
 ####################
 # Many machines do not have "mkdir -p", so we have to build up long paths.
 # How boring.  
-makepath () {
+makepath() {
     echo "        makepath $1"
     p="$1"
     (
 	# Absolut Unix.
 	if echo $p | grep '^/' >/dev/null
 	then
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/symlink-ignore.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/symlink-ignore.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/symlink-ignore.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/symlink-ignore.test	2006-02-04 01:58:48.000000000 +0800
@@ -7,14 +7,12 @@
 
 # Test rsync's somewhat over-featured symlink control: the default
 # behaviour is that symlinks should not be copied at all.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 build_symlinks || test_fail "failed to build symlinks"
 
 # Copy recursively, but without -l or -L or -a, and all the symlinks
 # should be missing.
 $RSYNC -r "$fromdir/" "$todir" || test_fail "$RSYNC returned $?"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/trimslash.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/trimslash.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/trimslash.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/trimslash.test	2006-02-04 01:58:48.000000000 +0800
@@ -6,14 +6,12 @@
 # COPYING).
 
 # Test tiny function to trim trailing slashes.
 
 . "$suitedir/rsync.fns"
 
-set -x
-
 "$TOOLDIR/trimslash" "/usr/local/bin" "/usr/local/bin/" "/usr/local/bin///" \
 	"//a//" "////" \
         "/Users/Wierd Macintosh Name/// Ooh, translucent plastic/" \
 	> "$scratchdir/slash.out"
 diff $diffopt "$scratchdir/slash.out" - <<EOF
 /usr/local/bin
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/unsafe-links.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/unsafe-links.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/unsafe-links.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/unsafe-links.test	2006-02-04 01:58:48.000000000 +0800
@@ -29,14 +29,12 @@
 touch "from/unsafe/unsafefile"
 
 ln -s ../files/file1 "from/safe/links/"
 ln -s ../files/file2 "from/safe/links/"
 ln -s ../../unsafe/unsafefile "from/safe/links/"
 
-set -x
-
 echo "rsync with relative path and just -a";
 $RSYNC -avv from/safe/ to
 test_symlink to/links/file1
 test_symlink to/links/file2
 test_symlink to/links/unsafefile
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/wildmatch.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/wildmatch.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/testsuite/wildmatch.test	2005-02-27 03:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/testsuite/wildmatch.test	2006-02-04 01:58:48.000000000 +0800
@@ -6,15 +6,18 @@
 # COPYING).
 
 # Test the wildmatch functionality
 
 . "$suitedir/rsync.fns"
 
-set -x
-
-"$TOOLDIR/wildtest" "$srcdir/wildtest.txt" >"$scratchdir/wild.out"
-diff $diffopt "$scratchdir/wild.out" - <<EOF
+# This test exercises the wildmatch() function (with no options) and the
+# wildmatch_join() function (using -x and/or -e).
+for opts in "" -x1 "-x1 -e1" "-x1 -e1se" -x2 "-x2 -ese" -x3 "-x3 -e1" -x4 "-x4 -e2e" -x5 "-x5 -es"; do
+    echo Running wildtest with "$opts"
+    "$TOOLDIR/wildtest" $opts "$srcdir/wildtest.txt" >"$scratchdir/wild.out"
+    diff $diffopt "$scratchdir/wild.out" - <<EOF
 No wildmatch errors found.
 EOF
+done
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/tls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/tls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/tls.c	2005-01-20 03:30:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/tls.c	2005-09-22 01:42:15.000000000 +0800
@@ -97,18 +97,18 @@
 	permstring(permbuf, buf.st_mode);
 
 	if (buf.st_mtime) {
 		mt = gmtime(&buf.st_mtime);
 
 		sprintf(datebuf, "%04d-%02d-%02d %02d:%02d:%02d",
-			mt->tm_year + 1900,
-			mt->tm_mon + 1,
-			mt->tm_mday,
-			mt->tm_hour,
-			mt->tm_min,
-			mt->tm_sec);
+			(int)mt->tm_year + 1900,
+			(int)mt->tm_mon + 1,
+			(int)mt->tm_mday,
+			(int)mt->tm_hour,
+			(int)mt->tm_min,
+			(int)mt->tm_sec);
 	} else {
 		strcpy(datebuf, "                   ");
 	}
 
 	/* TODO: Perhaps escape special characters in fname? */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/TODO	2005-03-01 11:11:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/TODO	2006-02-04 04:49:25.000000000 +0800
@@ -1,85 +1,64 @@
 -*- indented-text -*-
 
-BUGS ---------------------------------------------------------------
-Do not rely on having a group called "nobody"
-
 FEATURES ------------------------------------------------------------
 Use chroot only if supported
 Allow supplementary groups in rsyncd.conf			2002/04/09
 Handling IPv6 on old machines
-Other IPv6 stuff:
+Other IPv6 stuff
 Add ACL support							2001/12/02
-Lazy directory creation
 proxy authentication						2002/01/23
 SOCKS								2002/01/23
 FAT support
-Allow forcing arbitrary permissions				2002/03/12
 --diff						david.e.sewell	2002/03/15
 Add daemon --no-fork option
-Create more granular verbosity				jw	2003/05/15
+Create more granular verbosity					2003/05/15
 
 DOCUMENTATION --------------------------------------------------------
 Keep list of open issues and todos on the web site
 Perhaps redo manual as SGML
 
 LOGGING --------------------------------------------------------------
 Memory accounting
 Improve error messages
-Better statistics:					Rasmus	2002/03/08
+Better statistics					Rasmus	2002/03/08
 Perhaps flush stdout like syslog
-Log deamon sessions that just list modules
 Log child death on signal
-Log errors with function that reports process of origin
 verbose output					David Stein	2001/12/20
 internationalization
 
 DEVELOPMENT --------------------------------------------------------
 Handling duplicate names
 Use generic zlib						2002/02/25
-TDB:								2002/03/12
+TDB								2002/03/12
 Splint								2002/03/12
 
 PERFORMANCE ----------------------------------------------------------
-File list structure in memory
 Traverse just one directory at a time
 Allow skipping MD4 file_sum					2002/04/08
 Accelerate MD4
 
 TESTING --------------------------------------------------------------
 Torture test
 Cross-test versions						2001/08/22
 Test on kernel source
 Test large files
 Create mutator program for testing
 Create configure option to enable dangerous tests
-If tests are skipped, say why.
-Test daemon feature to disallow particular options.
 Create pipe program for testing
 Create test makefile target for some tests
 
 RELATED PROJECTS -----------------------------------------------------
 rsyncsh
 http://rsync.samba.org/rsync-and-debian/
 rsyncable gzip patch
 rsyncsplit as alternative to real integration with gzip?
 reverse rsync over HTTP Range
 
 
 
-BUGS ---------------------------------------------------------------
-
-
-Do not rely on having a group called "nobody"
-
-  http://www.linuxbase.org/spec/refspecs/LSB_1.1.0/gLSB/usernames.html
-
-  On Debian it's "nogroup"
-
-                      --          --
-
 FEATURES ------------------------------------------------------------
 
 
 Use chroot only if supported
 
   If the platform doesn't support it, then don't even try.
@@ -130,13 +109,13 @@
 
   We could drop the rather large lib/getaddrinfo files.
 
                       --          --
 
 
-Other IPv6 stuff:
+Other IPv6 stuff
   
   Implement suggestions from http://www.kame.net/newsletter/19980604/
   and ftp://ftp.iij.ad.jp/pub/RFC/rfc2553.txt
 
   If a host has multiple addresses, then listen try to connect to all
   in order until we get through.  (getaddrinfo may return multiple
@@ -156,21 +135,12 @@
   Possibly can share some code with Samba.
   NOTE: there is a patch that implements this in the "patches" subdir.
 
                       --          --
 
 
-Lazy directory creation
-
-  With the current common --include '*/' --exclude '*' pattern, people
-  can end up with many empty directories.  We might avoid this by
-  lazily creating such directories.
-
-                      --          --
-
-
 proxy authentication						2002/01/23
 
   Allow RSYNC_PROXY to be http://user:pass@proxy.foo:3128/, and do
   HTTP Basic Proxy-Authentication.
 
   Multiple schemes are possible, up to and including the insanity that
@@ -196,41 +166,12 @@
   I guess the code to do this is currently #ifdef'd on Windows;
   perhaps we ought to intelligently fall back to it on Unix too.
 
                       --          --
 
 
-Allow forcing arbitrary permissions				2002/03/12
-
-  On 12 Mar 2002, Dave Dykstra <dwd@bell-labs.com> wrote:
-  > If we would add an option to do that functionality, I
-  > would vote for one that was more general which could mask
-  > off any set of permission bits and possibly add any set of
-  > bits.  Perhaps a chmod-like syntax if it could be
-  > implemented simply.
-
-  I think that would be good too.  For example, people uploading files
-  to a web server might like to say
-
-  rsync -avzP --chmod a+rX ./ sourcefrog.net:/home/www/sourcefrog/
-
-  Ideally the patch would implement as many of the gnu chmod semantics
-  as possible.  I think the mode parser should be a separate function
-  that passes back something like (mask,set) description to the rest
-  of the program.  For bonus points there would be a test case for the
-  parser.
-
-  Possibly also --chown
-
-  (Debian #23628)
-
-  NOTE: there is a patch that implements this in the "patches" subdir.
-
-                      --          --
-
-
 --diff						david.e.sewell	2002/03/15
 
   Allow people to specify the diff command.  (Might want to use wdiff,
   gnudiff, etc.)
 
   Just diff the temporary file with the destination file, and delete
@@ -249,13 +190,13 @@
   daemon-monitoring process that tries to restart the service when the
   parent exits.
 
                       --          --
 
 
-Create more granular verbosity				jw	2003/05/15
+Create more granular verbosity					2003/05/15
 
   Control output with the --report option.
 
   The option takes as a single argument (no whitespace) a
   comma delimited lists of keywords.
 
@@ -319,20 +260,16 @@
   work, but it would certainly make our messages more helpful.
 
   What happens if a directory is missing -x attributes.  Do we lose
   our load?  (Debian #28416) Probably fixed now, but a test case would
   be good.
 
-  When running as a daemon, some errors should both be returned to the
-  user and logged.  This will make interacting with a daemon less
-  cryptic.
-
                       --          --
 
 
-Better statistics:					Rasmus	2002/03/08
+Better statistics					Rasmus	2002/03/08
 
   <Rasmus>
       hey, how about an rsync option that just gives you the
       summary without the list of files?  And perhaps gives
       more information like the number of new files, number
       of changed, deleted, etc. ?
@@ -352,37 +289,20 @@
   monitor progress in a log file can do so more easily.  See
   http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=48108
 
                       --          --
 
 
-Log deamon sessions that just list modules
-
-  At the connections that just get a list of modules are not logged,
-  but they should be.
-
-                      --          --
-
-
 Log child death on signal
 
   If a child of the rsync daemon dies with a signal, we should notice
   that when we reap it and log a message.
 
                       --          --
 
 
-Log errors with function that reports process of origin
-
-  Use a separate function for reporting errors; prefix it with
-  "rsync:" or "rsync(remote)", or perhaps even "rsync(local
-  generator): ".
-
-                      --          --
-
-
 verbose output					David Stein	2001/12/20
   
   At end of transfer, show how many files were or were not transferred
   correctly.
 
                       --          --
@@ -442,13 +362,13 @@
   do this is to just disable gzip (with a warning) when talking to old
   versions.
 
                       --          --
 
 
-TDB:								2002/03/12
+TDB								2002/03/12
 
   Rather than storing the file list in memory, store it in a TDB.
 
   This *might* make memory usage lower while building the file list.
 
   Hashtable lookup will mean files are not transmitted in order,
@@ -469,26 +389,12 @@
   really interesting for other projects.
 
                       --          --
 
 PERFORMANCE ----------------------------------------------------------
 
-File list structure in memory
-
-  Rather than one big array, perhaps have a tree in memory mirroring
-  the directory tree.
-
-  This might make sorting much faster!  (I'm not sure it's a big CPU
-  problem, mind you.)
-
-  It might also reduce memory use in storing repeated directory names
-  -- again I'm not sure this is a problem.
-
-                      --          --
-
-
 Traverse just one directory at a time
 
   Traverse just one directory at a time.  Tridge says it's possible.
 
   At the moment rsync reads the whole file list into memory at the
   start, which makes us use a lot of memory and also not pipeline
@@ -583,22 +489,12 @@
 
 Create configure option to enable dangerous tests
 
                       --          --
 
 
-If tests are skipped, say why.
-
-                      --          --
-
-
-Test daemon feature to disallow particular options.
-
-                      --          --
-
-
 Create pipe program for testing
 
   Create pipe program that makes slow/jerky connections for
   testing Versions of read() and write() that corrupt the
   stream, or abruptly fail
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/token.c	2005-02-14 16:28:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/token.c	2005-12-30 15:19:16.000000000 +0800
@@ -19,52 +19,66 @@
 
 #include "rsync.h"
 #include "zlib/zlib.h"
 
 extern int do_compression;
 extern int module_id;
+extern int def_compress_level;
 
-static int compression_level = Z_DEFAULT_COMPRESSION;
+static int compression_level, per_file_default_level;
 
 /* determine the compression level based on a wildcard filename list */
 void set_compression(char *fname)
 {
-	char *dont;
-	char *tok;
+	static char *match_list;
+	char *s;
 
 	if (!do_compression)
 		return;
 
-	compression_level = Z_DEFAULT_COMPRESSION;
-	dont = lp_dont_compress(module_id);
-
-	if (!dont || !*dont)
-		return;
-
-	if (dont[0] == '*' && !dont[1]) {
-		/* an optimization to skip the rest of this routine */
-		compression_level = 0;
-		return;
+	if (!match_list) {
+		char *t, *f = lp_dont_compress(module_id);
+		int len = strlen(f);
+		if (!(match_list = t = new_array(char, len + 2)))
+			out_of_memory("set_compression");
+		while (*f) {
+			if (*f == ' ') {
+				f++;
+				continue;
+			}
+			do {
+				if (isupper(*(unsigned char *)f))
+					*t++ = tolower(*(unsigned char *)f);
+				else
+					*t++ = *f;
+			} while (*++f != ' ' && *f);
+			*t++ = '\0';
+		}
+		/* Optimize a match-string of "*". */
+		if (t - match_list == 2 && match_list[0] == '*') {
+			t = match_list;
+			per_file_default_level = 0;
+		} else
+			per_file_default_level = def_compress_level;
+		*t++ = '\0';
 	}
 
-	dont = strdup(dont);
-	fname = strdup(fname);
-	if (!dont || !fname)
+	compression_level = per_file_default_level;
+
+	if (!*match_list)
 		return;
 
-	strlower(dont);
-	strlower(fname);
+	if ((s = strrchr(fname, '/')) != NULL)
+		fname = s + 1;
 
-	for (tok = strtok(dont, " "); tok; tok = strtok(NULL, " ")) {
-		if (wildmatch(tok, fname)) {
+	for (s = match_list; *s; s += strlen(s) + 1) {
+		if (iwildmatch(s, fname)) {
 			compression_level = 0;
 			break;
 		}
 	}
-	free(dont);
-	free(fname);
 }
 
 /* non-compressing recv token */
 static int32 simple_recv_token(int f, char **data)
 {
 	static int32 residue;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/t_stub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/t_stub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/t_stub.c	2005-01-25 18:39:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/t_stub.c	2006-02-24 09:56:29.000000000 +0800
@@ -25,12 +25,15 @@
  * This file contains really simple implementations for rsync global
  * functions, so that module test harnesses can run standalone.
  **/
 
 int modify_window = 0;
 int module_id = -1;
+int relative_paths = 0;
+int human_readable = 0;
+mode_t orig_umask = 002;
 char *partial_dir;
 struct filter_list_struct server_filter_list;
 
  void rprintf(UNUSED(enum logcode code), const char *format, ...)
 {
 	va_list ap;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/uidlist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/uidlist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/uidlist.c	2005-02-14 08:53:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/uidlist.c	2006-01-26 01:10:29.000000000 +0800
@@ -334,14 +333,13 @@
 				out_of_memory("recv_uid_list");
 			read_sbuf(f, name, len);
 			recv_add_gid(id, name); /* node keeps name's memory */
 		}
 	}
 
-	/* now convert the uid/gid of all files in the list to the mapped
-	 * uid/gid */
+	/* Now convert all the uids/gids from sender values to our values. */
 	if (am_root && preserve_uid && !numeric_ids) {
 		for (i = 0; i < flist->count; i++)
 			flist->files[i]->uid = match_uid(flist->files[i]->uid);
 	}
 	if (preserve_gid && (!am_root || !numeric_ids)) {
 		for (i = 0; i < flist->count; i++)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/util.c	2005-07-08 03:49:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/util.c	2006-02-24 17:34:44.000000000 +0800
@@ -28,12 +28,15 @@
 #include "rsync.h"
 
 extern int verbose;
 extern int dry_run;
 extern int module_id;
 extern int modify_window;
+extern int relative_paths;
+extern int human_readable;
+extern mode_t orig_umask;
 extern char *partial_dir;
 extern struct filter_list_struct server_filter_list;
 
 int sanitize_paths = 0;
 
 
@@ -102,21 +103,20 @@
 		* is not a great quoting algorithm, but it's
 		* sufficient for a log message. */
 		if (strspn(*cmd, "abcdefghijklmnopqrstuvwxyz"
 			   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
 			   "0123456789"
 			   ",.-_=+@/") != strlen(*cmd)) {
-			rprintf(FINFO, "\"%s\" ", safe_fname(*cmd));
+			rprintf(FINFO, "\"%s\" ", *cmd);
 		} else {
-			rprintf(FINFO, "%s ", safe_fname(*cmd));
+			rprintf(FINFO, "%s ", *cmd);
 		}
 	}
 	rprintf(FINFO, "\n");
 }
 
-
 void out_of_memory(char *str)
 {
 	rprintf(FERROR, "ERROR: out of memory in %s\n", str);
 	exit_cleanup(RERR_MALLOC);
 }
 
@@ -123,72 +123,94 @@
 void overflow_exit(char *str)
 {
 	rprintf(FERROR, "ERROR: buffer overflow in %s\n", str);
 	exit_cleanup(RERR_MALLOC);
 }
 
-
-
-int set_modtime(char *fname, time_t modtime)
+int set_modtime(char *fname, time_t modtime, mode_t mode)
 {
+#if !defined HAVE_LUTIMES || !defined HAVE_UTIMES
+	if (S_ISLNK(mode))
+		return 1;
+#endif
+
 	if (verbose > 2) {
 		rprintf(FINFO, "set modtime of %s to (%ld) %s",
-			safe_fname(fname), (long)modtime,
+			fname, (long)modtime,
 			asctime(localtime(&modtime)));
 	}
 
 	if (dry_run)
 		return 0;
 
 	{
-#ifdef HAVE_UTIMBUF
+#ifdef HAVE_UTIMES
+		struct timeval t[2];
+		t[0].tv_sec = time(NULL);
+		t[0].tv_usec = 0;
+		t[1].tv_sec = modtime;
+		t[1].tv_usec = 0;
+# ifdef HAVE_LUTIMES
+		if (S_ISLNK(mode))
+			return lutimes(fname, t);
+# endif
+		return utimes(fname, t);
+#elif defined HAVE_UTIMBUF
 		struct utimbuf tbuf;
 		tbuf.actime = time(NULL);
 		tbuf.modtime = modtime;
 		return utime(fname,&tbuf);
 #elif defined HAVE_UTIME
 		time_t t[2];
 		t[0] = time(NULL);
 		t[1] = modtime;
 		return utime(fname,t);
 #else
-		struct timeval t[2];
-		t[0].tv_sec = time(NULL);
-		t[0].tv_usec = 0;
-		t[1].tv_sec = modtime;
-		t[1].tv_usec = 0;
-		return utimes(fname,t);
+#error No file-time-modification routine found!
 #endif
 	}
 }
 
+/* This creates a new directory with default permissions.  Since there
+ * might be some directory-default permissions affecting this, we can't
+ * force the permissions directly using the original umask and mkdir(). */
+int mkdir_defmode(char *fname)
+{
+	int ret;
 
-/**
-   Create any necessary directories in fname. Unfortunately we don't know
-   what perms to give the directory when this is called so we need to rely
-   on the umask
-**/
-int create_directory_path(char *fname, int base_umask)
+	umask(orig_umask);
+	ret = do_mkdir(fname, ACCESSPERMS);
+	umask(0);
+
+	return ret;
+}
+
+/* Create any necessary directories in fname.  Any missing directories are
+ * created with default permissions. */
+int create_directory_path(char *fname)
 {
 	char *p;
+	int ret = 0;
 
 	while (*fname == '/')
 		fname++;
 	while (strncmp(fname, "./", 2) == 0)
 		fname += 2;
 
+	umask(orig_umask);
 	p = fname;
 	while ((p = strchr(p,'/')) != NULL) {
-		*p = 0;
-		do_mkdir(fname, 0777 & ~base_umask);
-		*p = '/';
-		p++;
+		*p = '\0';
+		if (do_mkdir(fname, ACCESSPERMS) < 0 && errno != EEXIST)
+		    ret = -1;
+		*p++ = '/';
 	}
-	return 0;
-}
+	umask(0);
 
+	return ret;
+}
 
 /**
  * Write @p len bytes at @p ptr to descriptor @p desc, retrying if
  * interrupted.
  *
  * @retval len upon success
@@ -239,18 +260,17 @@
 		n_chars = read(desc, ptr, len);
 	} while (n_chars < 0 && errno == EINTR);
 
 	return n_chars;
 }
 
-
 /** Copy a file.
  *
  * This is used in conjunction with the --temp-dir, --backup, and
  * --copy-dest options. */
-int copy_file(char *source, char *dest, mode_t mode)
+int copy_file(const char *source, const char *dest, mode_t mode)
 {
 	int ifd;
 	int ofd;
 	char buf[1024 * 8];
 	int len;   /* Number of bytes read into `buf'. */
 
@@ -313,13 +333,13 @@
  * Note that successive rsync runs will shuffle the filenames around a
  * bit as long as the file is still busy; this is because this function
  * does not know if the unlink call is due to a new file coming in, or
  * --delete trying to remove old .rsyncNNN files, hence it renames it
  * each time.
  **/
-int robust_unlink(char *fname)
+int robust_unlink(const char *fname)
 {
 #ifndef ETXTBSY
 	return do_unlink(fname);
 #else
 	static int counter = 1;
 	int rc, pos, start;
@@ -348,27 +368,30 @@
 		if (++counter >= MAX_RENAMES)
 			counter = 1;
 	} while ((rc = access(path, 0)) == 0 && counter != start);
 
 	if (verbose > 0) {
 		rprintf(FINFO,"renaming %s to %s because of text busy\n",
-			safe_fname(fname), safe_fname(path));
+			fname, path);
 	}
 
 	/* maybe we should return rename()'s exit status? Nah. */
 	if (do_rename(fname, path) != 0) {
 		errno = ETXTBSY;
 		return -1;
 	}
 	return 0;
 #endif
 }
 
 /* Returns 0 on successful rename, 1 if we successfully copied the file
- * across filesystems, -2 if copy_file() failed, and -1 on other errors. */
-int robust_rename(char *from, char *to, int mode)
+ * across filesystems, -2 if copy_file() failed, and -1 on other errors.
+ * If partialptr is not NULL and we need to do a copy, copy the file into
+ * the active partial-dir instead of over the destination file. */
+int robust_rename(char *from, char *to, char *partialptr,
+		  int mode)
 {
 	int tries = 4;
 
 	while (tries--) {
 		if (do_rename(from, to) == 0)
 			return 0;
@@ -378,12 +401,17 @@
 		case ETXTBSY:
 			if (robust_unlink(to) != 0)
 				return -1;
 			break;
 #endif
 		case EXDEV:
+			if (partialptr) {
+				if (!handle_partial_dir(partialptr,PDIR_CREATE))
+					return -1;
+				to = partialptr;
+			}
 			if (copy_file(from, to, mode) != 0)
 				return -2;
 			do_unlink(from);
 			return 1;
 		default:
 			return -1;
@@ -514,13 +539,12 @@
 	if (!*s)
 		s = ".";
 	s = argv[argc++] = strdup(s);
 	filter_server_path(s);
 #else
 	glob_t globbuf;
-	int i;
 
 	if (maxargs <= argc)
 		return;
 	if (!*s)
 		s = ".";
 
@@ -539,15 +563,15 @@
 		*argv_ptr = argv;
 		*maxargs_ptr = maxargs;
 	}
 	if (globbuf.gl_pathc == 0)
 		argv[argc++] = s;
 	else {
-		int j = globbuf.gl_pathc;
+		int i;
 		free(s);
-		for (i = 0; i < j; i++) {
+		for (i = 0; i < (int)globbuf.gl_pathc; i++) {
 			if (!(argv[argc++] = strdup(globbuf.gl_pathv[i])))
 				out_of_memory("glob_expand_one");
 		}
 	}
 	globfree(&globbuf);
 #endif
@@ -742,13 +766,13 @@
  * ALWAYS collapses ".." elements (except for those at the start of the
  * string up to "depth" deep).  If the resulting name would be empty,
  * change it into a ".". */
 char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth)
 {
 	char *start, *sanp;
-	int rlen = 0;
+	int rlen = 0, leave_one_dotdir = relative_paths;
 
 	if (dest != p) {
 		int plen = strlen(p);
 		if (*p == '/') {
 			if (!rootdir)
 				rootdir = lp_path(module_id);
@@ -777,15 +801,19 @@
 		}
 		/* this loop iterates once per filename component in p.
 		 * both p (and sanp if the original had a slash) should
 		 * always be left pointing after a slash
 		 */
 		if (*p == '.' && (p[1] == '/' || p[1] == '\0')) {
-			/* skip "." component */
-			p++;
-			continue;
+			if (leave_one_dotdir && p[1])
+				leave_one_dotdir = 0;
+			else {
+				/* skip "." component */
+				p++;
+				continue;
+			}
 		}
 		if (*p == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\0')) {
 			/* ".." component followed by slash or end */
 			if (depth <= 0 || sanp != start) {
 				p += 2;
 				if (sanp != start) {
@@ -874,49 +902,12 @@
 	if (curr_dir_len >= sizeof curr_dir)
 		curr_dir_len = sizeof curr_dir - 1;
 
 	return 1;
 }
 
-/* Return the filename, turning any non-printable characters into escaped
- * characters (e.g. \n -> \012, \ -> \\).  This ensures that outputting it
- * cannot generate an empty line nor corrupt the screen.  This function can
- * return only MAX_SAFE_NAMES values at a time!  The returned value can be
- * longer than MAXPATHLEN (because we may be trying to output an error about
- * a too-long filename)! */
-char *safe_fname(const char *fname)
-{
-#define MAX_SAFE_NAMES 4
-	static char fbuf[MAX_SAFE_NAMES][MAXPATHLEN*2];
-	static int ndx = 0;
-	int limit = sizeof fbuf / MAX_SAFE_NAMES - 1;
-	char *t;
-
-	ndx = (ndx + 1) % MAX_SAFE_NAMES;
-	for (t = fbuf[ndx]; *fname; fname++) {
-		if (*fname == '\\') {
-			if ((limit -= 2) < 0)
-				break;
-			*t++ = '\\';
-			*t++ = '\\';
-		} else if (!isprint(*(uchar*)fname)) {
-			if ((limit -= 4) < 0)
-				break;
-			sprintf(t, "\\%03o", *(uchar*)fname);
-			t += 4;
-		} else {
-			if (--limit < 0)
-				break;
-			*t++ = *fname;
-		}
-	}
-	*t = '\0';
-
-	return fbuf[ndx];
-}
-
 /**
  * Return a quoted string with the full pathname of the indicated filename.
  * The string " (in MODNAME)" may also be appended.  The returned pointer
  * remains valid until the next time full_fname() is called.
  **/
 char *full_fname(const char *fn)
@@ -925,13 +916,12 @@
 	char *m1, *m2, *m3;
 	char *p1, *p2;
 
 	if (result)
 		free(result);
 
-	fn = safe_fname(fn);
 	if (*fn == '/')
 		p1 = p2 = "";
 	else {
 		p1 = curr_dir;
 		for (p2 = p1; *p2 == '/'; p2++) {}
 		if (*p2)
@@ -1020,28 +1010,12 @@
 		do_rmdir(dir);
 	*fn = '/';
 
 	return 1;
 }
 
-/** We need to supply our own strcmp function for file list comparisons
-   to ensure that signed/unsigned usage is consistent between machines. */
-int u_strcmp(const char *cs1, const char *cs2)
-{
-	const uchar *s1 = (const uchar *)cs1;
-	const uchar *s2 = (const uchar *)cs2;
-
-	while (*s1 && *s2 && (*s1 == *s2)) {
-		s1++; s2++;
-	}
-
-	return (int)*s1 - (int)*s2;
-}
-
-
-
 /**
  * Determine if a symlink points outside the current directory tree.
  * This is considered "unsafe" because e.g. when mirroring somebody
  * else's machine it might allow them to establish a symlink to
  * /etc/passwd, and then read it through a web server.
  *
@@ -1100,35 +1074,91 @@
 	if (strcmp(name, "..") == 0)
 		depth--;
 
 	return (depth < 0);
 }
 
+/* Return the int64 number as a string.  If the --human-readable option was
+ * specified, we may output the number in K, M, or G units.  We can return
+ * up to 4 buffers at a time. */
+char *human_num(int64 num)
+{
+	static char bufs[4][128]; /* more than enough room */
+	static unsigned int n;
+	char *s;
+
+	n = (n + 1) % (sizeof bufs / sizeof bufs[0]);
+
+	if (human_readable) {
+		char units = '\0';
+		int mult = human_readable == 1 ? 1000 : 1024;
+		double dnum = 0;
+		if (num > mult*mult*mult) {
+			dnum = (double)num / (mult*mult*mult);
+			units = 'G';
+		} else if (num > mult*mult) {
+			dnum = (double)num / (mult*mult);
+			units = 'M';
+		} else if (num > mult) {
+			dnum = (double)num / mult;
+			units = 'K';
+		}
+		if (units) {
+			sprintf(bufs[n], "%.2f%c", dnum, units);
+			return bufs[n];
+		}
+	}
+
+	s = bufs[n] + sizeof bufs[0] - 1;
+	*s = '\0';
+
+	if (!num)
+		*--s = '0';
+	while (num) {
+		*--s = (num % 10) + '0';
+		num /= 10;
+	}
+	return s;
+}
+
+/* Return the double number as a string.  If the --human-readable option was
+ * specified, we may output the number in K, M, or G units.  We use a buffer
+ * from human_num() to return our result. */
+char *human_dnum(double dnum, int decimal_digits)
+{
+	char *buf = human_num(dnum);
+	int len = strlen(buf);
+	if (isdigit(*(uchar*)(buf+len-1))) {
+		/* There's extra room in buf prior to the start of the num. */
+		buf -= decimal_digits + 1;
+		snprintf(buf, len + decimal_digits + 2, "%.*f", decimal_digits, dnum);
+	}
+	return buf;
+}
 
 /**
  * Return the date and time as a string
  **/
 char *timestring(time_t t)
 {
 	static char TimeBuf[200];
 	struct tm *tm = localtime(&t);
+	char *p;
 
 #ifdef HAVE_STRFTIME
 	strftime(TimeBuf, sizeof TimeBuf - 1, "%Y/%m/%d %H:%M:%S", tm);
 #else
 	strlcpy(TimeBuf, asctime(tm), sizeof TimeBuf);
 #endif
 
-	if (TimeBuf[strlen(TimeBuf)-1] == '\n') {
-		TimeBuf[strlen(TimeBuf)-1] = 0;
-	}
+	if ((p = strchr(TimeBuf, '\n')) != NULL)
+		*p = '\0';
 
-	return(TimeBuf);
+	return TimeBuf;
 }
 
-
 /**
  * Sleep for a specified number of milliseconds.
  *
  * Always returns TRUE.  (In the future it might return FALSE if
  * interrupted.)
  **/
@@ -1151,25 +1181,22 @@
 			(t2.tv_usec - t1.tv_usec)/1000;
 	}
 
 	return True;
 }
 
-
-/**
- * Determine if two file modification times are equivalent (either
- * exact or in the modification timestamp window established by
- * --modify-window).
+/* Determine if two time_t values are equivalent (either exact, or in
+ * the modification timestamp window established by --modify-window).
  *
  * @retval 0 if the times should be treated as the same
  *
  * @retval +1 if the first is later
  *
  * @retval -1 if the 2nd is later
  **/
-int cmp_modtime(time_t file1, time_t file2)
+int cmp_time(time_t file1, time_t file2)
 {
 	if (file2 > file1) {
 		if (file2 - file1 <= modify_window)
 			return 0;
 		return -1;
 	}
@@ -1335,6 +1361,98 @@
 			diag = left;
 		}
 	}
 
 	return a[len2-1];
 }
+
+#define BB_SLOT_SIZE     (16*1024)          /* Desired size in bytes */
+#define BB_PER_SLOT_BITS (BB_SLOT_SIZE * 8) /* Number of bits per slot */
+#define BB_PER_SLOT_INTS (BB_SLOT_SIZE / 4) /* Number of int32s per slot */
+
+struct bitbag {
+    uint32 **bits;
+    int slot_cnt;
+};
+
+struct bitbag *bitbag_create(int max_ndx)
+{
+	struct bitbag *bb = new(struct bitbag);
+	bb->slot_cnt = (max_ndx + BB_PER_SLOT_BITS - 1) / BB_PER_SLOT_BITS;
+
+	if (!(bb->bits = (uint32**)calloc(bb->slot_cnt, sizeof (uint32*))))
+		out_of_memory("bitbag_create");
+
+	return bb;
+}
+
+void bitbag_set_bit(struct bitbag *bb, int ndx)
+{
+	int slot = ndx / BB_PER_SLOT_BITS;
+	ndx %= BB_PER_SLOT_BITS;
+
+	if (!bb->bits[slot]) {
+		if (!(bb->bits[slot] = (uint32*)calloc(BB_PER_SLOT_INTS, 4)))
+			out_of_memory("bitbag_set_bit");
+	}
+
+	bb->bits[slot][ndx/32] |= 1u << (ndx % 32);
+}
+
+#if 0 /* not needed yet */
+void bitbag_clear_bit(struct bitbag *bb, int ndx)
+{
+	int slot = ndx / BB_PER_SLOT_BITS;
+	ndx %= BB_PER_SLOT_BITS;
+
+	if (!bb->bits[slot])
+		return;
+
+	bb->bits[slot][ndx/32] &= ~(1u << (ndx % 32));
+}
+
+int bitbag_check_bit(struct bitbag *bb, int ndx)
+{
+	int slot = ndx / BB_PER_SLOT_BITS;
+	ndx %= BB_PER_SLOT_BITS;
+
+	if (!bb->bits[slot])
+		return 0;
+
+	return bb->bits[slot][ndx/32] & (1u << (ndx % 32)) ? 1 : 0;
+}
+#endif
+
+/* Call this with -1 to start checking from 0.  Returns -1 at the end. */
+int bitbag_next_bit(struct bitbag *bb, int after)
+{
+	uint32 bits, mask;
+	int i, ndx = after + 1;
+	int slot = ndx / BB_PER_SLOT_BITS;
+	ndx %= BB_PER_SLOT_BITS;
+
+	mask = (1u << (ndx % 32)) - 1;
+	for (i = ndx / 32; slot < bb->slot_cnt; slot++, i = mask = 0) {
+		if (!bb->bits[slot])
+			continue;
+		for ( ; i < BB_PER_SLOT_INTS; i++, mask = 0) {
+			if (!(bits = bb->bits[slot][i] & ~mask))
+				continue;
+			/* The xor magic figures out the lowest enabled bit in
+			 * bits, and the switch quickly computes log2(bit). */
+			switch (bits ^ (bits & (bits-1))) {
+#define LOG2(n) case 1u << n: return slot*BB_PER_SLOT_BITS + i*32 + n
+			    LOG2(0);  LOG2(1);  LOG2(2);  LOG2(3);
+			    LOG2(4);  LOG2(5);  LOG2(6);  LOG2(7);
+			    LOG2(8);  LOG2(9);  LOG2(10); LOG2(11);
+			    LOG2(12); LOG2(13); LOG2(14); LOG2(15);
+			    LOG2(16); LOG2(17); LOG2(18); LOG2(19);
+			    LOG2(20); LOG2(21); LOG2(22); LOG2(23);
+			    LOG2(24); LOG2(25); LOG2(26); LOG2(27);
+			    LOG2(28); LOG2(29); LOG2(30); LOG2(31);
+			}
+			return -1; /* impossible... */
+		}
+	}
+
+	return -1;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/wildtest.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/wildtest.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/wildtest.c	2004-02-08 02:40:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/wildtest.c	2006-01-27 06:32:59.000000000 +0800
@@ -4,29 +4,35 @@
 
 /*#define COMPARE_WITH_FNMATCH*/
 
 #define WILD_TEST_ITERATIONS
 #include "lib/wildmatch.c"
 
-#include "popt.h"
+#include <popt.h>
 
 #ifdef COMPARE_WITH_FNMATCH
 #include <fnmatch.h>
 
 int fnmatch_errors = 0;
 #endif
 
 int wildmatch_errors = 0;
 
 typedef char bool;
 
 int output_iterations = 0;
+int explode_mod = 0;
+int empties_mod = 0;
+int empty_at_start = 0;
+int empty_at_end = 0;
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"iterations",     'i', POPT_ARG_NONE,   &output_iterations, 0, 0, 0},
+  {"empties",        'e', POPT_ARG_STRING, 0, 'e', 0, 0},
+  {"explode",        'x', POPT_ARG_INT,    &explode_mod, 0, 0, 0},
   {0,0,0,0, 0, 0, 0}
 };
 
 /* match just at the start of string (anchored tests) */
 static void
 run_test(int line, bool matches, bool same_as_fnmatch,
@@ -37,13 +43,34 @@
     bool fn_matched;
     int flags = strstr(pattern, "**")? 0 : FNM_PATHNAME;
 #else
     same_as_fnmatch = 0; /* Get rid of unused-variable compiler warning. */
 #endif
 
-    matched = wildmatch(pattern, text);
+    if (explode_mod) {
+	char buf[MAXPATHLEN*2], *texts[MAXPATHLEN];
+	int pos = 0, cnt = 0, ndx = 0, len = strlen(text);
+
+	if (empty_at_start)
+	    texts[ndx++] = "";
+	/* An empty string must turn into at least one empty array item. */
+	while (1) {
+	    texts[ndx] = buf + ndx * (explode_mod + 1);
+	    strlcpy(texts[ndx++], text + pos, explode_mod + 1);
+	    if (pos + explode_mod >= len)
+		break;
+	    pos += explode_mod;
+	    if (!(++cnt % empties_mod))
+		texts[ndx++] = "";
+	}
+	if (empty_at_end)
+	    texts[ndx++] = "";
+	texts[ndx] = NULL;
+	matched = wildmatch_array(pattern, (const char**)texts, 0);
+    } else
+	matched = wildmatch(pattern, text);
 #ifdef COMPARE_WITH_FNMATCH
     fn_matched = !fnmatch(pattern, text, flags);
 #endif
     if (matched != matches) {
 	printf("wildmatch failure on line %d:\n  %s\n  %s\n  expected %s match\n",
 	       line, text, pattern, matches? "a" : "NO");
@@ -63,30 +90,44 @@
 }
 
 int
 main(int argc, char **argv)
 {
     char buf[2048], *s, *string[2], *end[2];
+    const char *arg;
     FILE *fp;
     int opt, line, i, flag[2];
     poptContext pc = poptGetContext("wildtest", argc, (const char**)argv,
 				    long_options, 0);
 
     while ((opt = poptGetNextOpt(pc)) != -1) {
 	switch (opt) {
+	  case 'e':
+	    arg = poptGetOptArg(pc);
+	    empties_mod = atoi(arg);
+	    if (strchr(arg, 's'))
+		empty_at_start = 1;
+	    if (strchr(arg, 'e'))
+		empty_at_end = 1;
+	    if (!explode_mod)
+		explode_mod = 1024;
+	    break;
 	  default:
 	    fprintf(stderr, "%s: %s\n",
 		    poptBadOption(pc, POPT_BADOPTION_NOALIAS),
 		    poptStrerror(opt));
 	    exit(1);
 	}
     }
 
+    if (explode_mod && !empties_mod)
+	empties_mod = 1024;
+
     argv = (char**)poptGetArgs(pc);
     if (!argv || argv[1]) {
-	fprintf(stderr, "Usage: wildtest TESTFILE\n");
+	fprintf(stderr, "Usage: wildtest [OPTIONS] TESTFILE\n");
 	exit(1);
     }
 
     if ((fp = fopen(*argv, "r")) == NULL) {
 	fprintf(stderr, "Unable to open %s\n", *argv);
 	exit(1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/wildtest.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/wildtest.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.6/wildtest.txt	2003-07-14 23:46:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.7/wildtest.txt	2005-12-19 10:30:59.000000000 +0800
@@ -47,12 +47,16 @@
 0 1 foo			**/foo
 1 1 /foo		**/foo
 1 1 bar/baz/foo		**/foo
 0 1 bar/baz/foo		*/foo
 0 0 foo/bar/baz		**/bar*
 1 1 deep/foo/bar/baz	**/bar/*
+0 1 deep/foo/bar/baz/	**/bar/*
+1 1 deep/foo/bar/baz/	**/bar/**
+0 1 deep/foo/bar	**/bar/*
+1 1 deep/foo/bar/	**/bar/**
 1 1 foo/bar/baz		**/bar**
 1 1 foo/bar/baz/x	*/bar/**
 0 0 deep/foo/bar/baz/x	*/bar/**
 1 1 deep/foo/bar/baz/x	**/bar/*/*
 
 # Various additional tests
