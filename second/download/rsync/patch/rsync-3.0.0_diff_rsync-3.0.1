diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/clientserver.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/clientserver.c	2008-03-31 06:44:46.000000000 +0800
@@ -19,22 +19,25 @@
  * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 #include "ifuncs.h"
 
+extern int quiet;
 extern int verbose;
 extern int dry_run;
 extern int output_motd;
 extern int list_only;
 extern int am_sender;
 extern int am_server;
 extern int am_daemon;
 extern int am_root;
 extern int rsync_port;
+extern int protect_args;
 extern int ignore_errors;
+extern int preserve_xattrs;
 extern int kluge_around_eof;
 extern int daemon_over_rsh;
 extern int sanitize_paths;
 extern int numeric_ids;
 extern int filesfrom_fd;
 extern int remote_protocol;
@@ -50,13 +53,13 @@
 extern char *sockopts;
 extern char *config_file;
 extern char *logfile_format;
 extern char *files_from;
 extern char *tmpdir;
 extern struct chmod_mode_struct *chmod_modes;
-extern struct filter_list_struct server_filter_list;
+extern struct filter_list_struct daemon_filter_list;
 extern char curr_dir[];
 #ifdef ICONV_OPTION
 extern char *iconv_opt;
 extern iconv_t ic_send, ic_recv;
 #endif
 
@@ -208,13 +211,13 @@
 	int i, modlen;
 	char line[BIGPATHBUFLEN];
 	char *sargs[MAX_ARGS];
 	int sargc = 0;
 	char *p, *modname;
 
-	assert(argc > 0);
+	assert(argc > 0 && *argv != NULL);
 
 	if (**argv == '/') {
 		rprintf(FERROR,
 			"ERROR: The remote path must start with a module name\n");
 		return -1;
 	}
@@ -310,43 +313,56 @@
 			rprintf(FINFO, "%s\n", line);
 	}
 	kluge_around_eof = 0;
 
 	if (rl_nulls) {
 		for (i = 0; i < sargc; i++) {
+			if (!sargs[i]) /* stop at --protect-args NULL */
+				break;
 			write_sbuf(f_out, sargs[i]);
 			write_byte(f_out, 0);
 		}
 		write_byte(f_out, 0);
 	} else {
 		for (i = 0; i < sargc; i++)
 			io_printf(f_out, "%s\n", sargs[i]);
 		write_sbuf(f_out, "\n");
 	}
 
+	if (protect_args)
+		send_protected_args(f_out, sargs);
+
 	if (protocol_version < 23) {
 		if (protocol_version == 22 || !am_sender)
 			io_start_multiplex_in();
 	}
 
 	free(modname);
 
 	return 0;
 }
 
 static char *finish_pre_exec(pid_t pid, int fd, char *request,
-			     int argc, char *argv[])
+			     char **early_argv, char **argv)
 {
-	int j, status = -1;
+	int j = 0, status = -1;
 
 	if (!request)
 		request = "(NONE)";
 
 	write_buf(fd, request, strlen(request)+1);
-	for (j = 0; j < argc; j++)
+	if (early_argv) {
+		for ( ; *early_argv; early_argv++)
+			write_buf(fd, *early_argv, strlen(*early_argv)+1);
+		j = 1; /* Skip arg0 name in argv. */
+	}
+	for ( ; argv[j]; j++) {
 		write_buf(fd, argv[j], strlen(argv[j])+1);
+		if (argv[j][0] == '.' && argv[j][1] == '\0')
+			break;
+	}
 	write_byte(fd, 0);
 
 	close(fd);
 
 	if (wait_process(pid, &status, 0) < 0
 	 || !WIFEXITED(status) || WEXITSTATUS(status) != 0) {
@@ -380,14 +396,14 @@
 
 	return bp - buf;
 }
 
 static int rsync_module(int f_in, int f_out, int i, char *addr, char *host)
 {
-	int argc, opt_cnt;
-	char **argv, *chroot_path = NULL;
+	int argc;
+	char **argv, **orig_argv, **orig_early_argv, *chroot_path = NULL;
 	char line[BIGPATHBUFLEN];
 	uid_t uid = (uid_t)-2;  /* canonically "nobody" */
 	gid_t gid = (gid_t)-2;
 	char *p, *err_msg = NULL;
 	char *name = lp_name(i);
 	int use_chroot = lp_use_chroot(i);
@@ -486,25 +502,25 @@
 
 	module_dir = lp_path(i);
 	if (use_chroot) {
 		if ((p = strstr(module_dir, "/./")) != NULL) {
 			*p = '\0';
 			p += 2;
-		} else if ((p = strdup("/")) == NULL)
+		} else if ((p = strdup("/")) == NULL) /* MEMORY LEAK */
 			out_of_memory("rsync_module");
 	}
 
-	/* We do a push_dir() that doesn't actually call chdir()
+	/* We do a change_dir() that doesn't actually call chdir()
 	 * just to make a relative path absolute. */
 	strlcpy(line, curr_dir, sizeof line);
-	if (!push_dir(module_dir, 1))
+	if (!change_dir(module_dir, CD_SKIP_CHDIR))
 		goto chdir_failed;
 	if (strcmp(curr_dir, module_dir) != 0
 	 && (module_dir = strdup(curr_dir)) == NULL)
 		out_of_memory("rsync_module");
-	push_dir(line, 1); /* Restore curr_dir. */
+	change_dir(line, CD_SKIP_CHDIR); /* Restore curr_dir. */
 
 	if (use_chroot) {
 		chroot_path = module_dir;
 		module_dir = p; /* p is "/" or our inside-chroot path */
 	}
 	module_dirlen = clean_fname(module_dir, CFN_COLLAPSE_DOT_DOT_DIRS | CFN_DROP_TRAILING_DOT_DIR);
@@ -513,31 +529,31 @@
 		module_dirlen = 0;
 		set_filter_dir("/", 1);
 	} else
 		set_filter_dir(module_dir, module_dirlen);
 
 	p = lp_filter(i);
-	parse_rule(&server_filter_list, p, MATCHFLG_WORD_SPLIT,
-		   XFLG_ABS_IF_SLASH);
+	parse_rule(&daemon_filter_list, p, MATCHFLG_WORD_SPLIT,
+		   XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3);
 
 	p = lp_include_from(i);
-	parse_filter_file(&server_filter_list, p, MATCHFLG_INCLUDE,
-	    XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
+	parse_filter_file(&daemon_filter_list, p, MATCHFLG_INCLUDE,
+	    XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
 
 	p = lp_include(i);
-	parse_rule(&server_filter_list, p,
+	parse_rule(&daemon_filter_list, p,
 		   MATCHFLG_INCLUDE | MATCHFLG_WORD_SPLIT,
-		   XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES);
+		   XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES);
 
 	p = lp_exclude_from(i);
-	parse_filter_file(&server_filter_list, p, 0,
-	    XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
+	parse_filter_file(&daemon_filter_list, p, 0,
+	    XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES | XFLG_FATAL_ERRORS);
 
 	p = lp_exclude(i);
-	parse_rule(&server_filter_list, p, MATCHFLG_WORD_SPLIT,
-		   XFLG_ABS_IF_SLASH | XFLG_OLD_PREFIXES);
+	parse_rule(&daemon_filter_list, p, MATCHFLG_WORD_SPLIT,
+		   XFLG_ABS_IF_SLASH | XFLG_DIR2WILD3 | XFLG_OLD_PREFIXES);
 
 	log_init(1);
 
 #ifdef HAVE_PUTENV
 	if (*lp_prexfer_exec(i) || *lp_postxfer_exec(i)) {
 		char *modname, *modpath, *hostaddr, *hostname, *username;
@@ -654,31 +670,31 @@
 		 */
 		if (chroot(chroot_path)) {
 			rsyserr(FLOG, errno, "chroot %s failed", chroot_path);
 			io_printf(f_out, "@ERROR: chroot failed\n");
 			return -1;
 		}
-		if (!push_dir(module_dir, 0))
+		if (!change_dir(module_dir, CD_NORMAL))
 			goto chdir_failed;
 		if (module_dirlen)
 			sanitize_paths = 1;
 	} else {
-		if (!push_dir(module_dir, 0)) {
+		if (!change_dir(module_dir, CD_NORMAL)) {
 		  chdir_failed:
 			rsyserr(FLOG, errno, "chdir %s failed\n", module_dir);
 			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 		sanitize_paths = 1;
 	}
 
 	if ((munge_symlinks = lp_munge_symlinks(i)) < 0)
 		munge_symlinks = !use_chroot || module_dirlen;
 	if (munge_symlinks) {
 		STRUCT_STAT st;
-		if (stat(SYMLINK_PREFIX, &st) == 0 && S_ISDIR(st.st_mode)) {
+		if (do_stat(SYMLINK_PREFIX, &st) == 0 && S_ISDIR(st.st_mode)) {
 			rprintf(FLOG, "Symlink munging is unsupported when a %s directory exists.\n",
 				SYMLINK_PREFIX);
 			io_printf(f_out, "@ERROR: daemon security issue -- contact admin\n", name);
 			exit_cleanup(RERR_UNSUPPORTED);
 		}
 	}
@@ -727,30 +743,46 @@
 			tmpdir = NULL;
 		}
 	}
 
 	io_printf(f_out, "@RSYNCD: OK\n");
 
-	opt_cnt = read_args(f_in, name, line, sizeof line, rl_nulls, &argv, &argc, &request);
+	read_args(f_in, name, line, sizeof line, rl_nulls, &argv, &argc, &request);
+	orig_argv = argv;
+
+	verbose = 0; /* future verbosity is controlled by client options */
+	ret = parse_arguments(&argc, (const char ***) &argv);
+	if (protect_args && ret) {
+		orig_early_argv = orig_argv;
+		protect_args = 2;
+		read_args(f_in, name, line, sizeof line, 1, &argv, &argc, &request);
+		orig_argv = argv;
+		ret = parse_arguments(&argc, (const char ***) &argv);
+	} else
+		orig_early_argv = NULL;
 
 	if (pre_exec_pid) {
 		err_msg = finish_pre_exec(pre_exec_pid, pre_exec_fd, request,
-					  opt_cnt, argv);
+					  orig_early_argv, orig_argv);
 	}
 
-	verbose = 0; /* future verbosity is controlled by client options */
-	ret = parse_arguments(&argc, (const char ***) &argv, 0);
+	if (orig_early_argv)
+		free(orig_early_argv);
+
 	am_server = 1; /* Don't let someone try to be tricky. */
+	quiet = 0;
 	if (lp_ignore_errors(module_id))
 		ignore_errors = 1;
 	if (write_batch < 0)
 		dry_run = 1;
 
-	if (lp_fake_super(i))
+	if (lp_fake_super(i)) {
+		if (preserve_xattrs > 1)
+			preserve_xattrs = 1;
 		am_root = -1;
-	else if (am_root < 0) /* Treat --fake-super from client as --super. */
+	} else if (am_root < 0) /* Treat --fake-super from client as --super. */
 		am_root = 2;
 
 	if (filesfrom_fd == 0)
 		filesfrom_fd = f_in;
 
 	if (request) {
@@ -861,12 +893,23 @@
 	}
 
 	if (protocol_version >= 25)
 		io_printf(fd,"@RSYNCD: EXIT\n");
 }
 
+static int load_config(int globals_only)
+{
+	if (!config_file) {
+		if (am_server && am_root <= 0)
+			config_file = RSYNCD_USERCONF;
+		else
+			config_file = RSYNCD_SYSCONF;
+	}
+	return lp_load(config_file, globals_only);
+}
+
 /* this is called when a connection is established to a client
    and we want to start talking. The setup of the system is done from
    here */
 int start_daemon(int f_in, int f_out)
 {
 	char line[1024];
@@ -876,13 +919,13 @@
 	io_set_sock_fds(f_in, f_out);
 
 	/* We must load the config file before calling any function that
 	 * might cause log-file output to occur.  This ensures that the
 	 * "log file" param gets honored for the 2 non-forked use-cases
 	 * (when rsync is run by init and run by a remote shell). */
-	if (!lp_load(config_file, 0))
+	if (!load_config(0))
 		exit_cleanup(RERR_SYNTAX);
 
 	addr = client_addr(f_in);
 	host = client_name(f_in);
 	rprintf(FLOG, "connect from %s (%s)\n", host, addr);
 
@@ -985,19 +1028,12 @@
 		open("/dev/null", O_RDWR);
 	}
 }
 
 int daemon_main(void)
 {
-	if (!config_file) {
-		if (am_server && am_root <= 0)
-			config_file = RSYNCD_USERCONF;
-		else
-			config_file = RSYNCD_SYSCONF;
-	}
-
 	if (is_a_socket(STDIN_FILENO)) {
 		int i;
 
 		/* we are running via inetd - close off stdout and
 		 * stderr so that library functions (and getopt) don't
 		 * try to use them. Redirect them to /dev/null */
@@ -1006,13 +1042,13 @@
 			open("/dev/null", O_RDWR);
 		}
 
 		return start_daemon(STDIN_FILENO, STDIN_FILENO);
 	}
 
-	if (!lp_load(config_file, 1)) {
+	if (!load_config(1)) {
 		fprintf(stderr, "Failed to parse config file: %s\n", config_file);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (no_detach)
 		create_pid_file();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/compat.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/compat.c	2008-03-11 12:39:01.000000000 +0800
@@ -268,12 +268,16 @@
 			fprintf(stderr,
 			    "Incompatible options specified for inc-recursive %s.\n",
 			    read_batch ? "batch file" : "connection");
 			exit_cleanup(RERR_SYNTAX);
 		}
 		need_messages_from_generator = 1;
+#if defined HAVE_LUTIMES && defined HAVE_UTIMES
+	} else if (!am_sender) {
+		receiver_symlink_times = 1;
+#endif
 	}
 
 	if (need_unsorted_flist && (!am_sender || inc_recurse))
 		unsort_ndx = ++file_extra_cnt;
 
 	if (partial_dir && *partial_dir != '/' && (!am_server || local_server)) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/config.h.in	2008-03-02 04:12:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/config.h.in	2008-04-04 13:54:27.000000000 +0800
@@ -17,12 +17,15 @@
    */
 #undef CRAY_STACKSEG_END
 
 /* Define to 1 if using `alloca.c'. */
 #undef C_ALLOCA
 
+/* Used to make "checker" understand that FD_ZERO() clears memory. */
+#undef FORCE_FD_ZERO_MEMSET
+
 /* Define to the type of elements in the array set by `getgroups'. Usually
    this is either `int' or `gid_t'. */
 #undef GETGROUPS_T
 
 /* Define to 1 if the `getpgrp' function requires zero arguments. */
 #undef GETPGRP_VOID
@@ -128,18 +131,12 @@
 /* Define to 1 if gettimeofday() takes a time-zone arg */
 #undef HAVE_GETTIMEOFDAY_TZ
 
 /* Define to 1 if you have the `getxattr' function. */
 #undef HAVE_GETXATTR
 
-/* Define to 1 if you have the `glob' function. */
-#undef HAVE_GLOB
-
-/* Define to 1 if you have the <glob.h> header file. */
-#undef HAVE_GLOB_H
-
 /* Define to 1 if you have the <grp.h> header file. */
 #undef HAVE_GRP_H
 
 /* true if you have HPUX ACLs */
 #undef HAVE_HPUX_ACLS
 
@@ -280,12 +277,18 @@
 /* True if you have Mac OS X xattrs */
 #undef HAVE_OSX_XATTRS
 
 /* Define to 1 if the system has the type `pid_t'. */
 #undef HAVE_PID_T
 
+/* Define to 1 if you have the <popt.h> header file. */
+#undef HAVE_POPT_H
+
+/* Define to 1 if you have the <popt/popt.h> header file. */
+#undef HAVE_POPT_POPT_H
+
 /* true if you have posix ACLs */
 #undef HAVE_POSIX_ACLS
 
 /* Define to 1 if you have the `putenv' function. */
 #undef HAVE_PUTENV
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/configure.in	2008-03-02 04:12:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/configure.in	2008-04-04 13:37:01.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.59)
 
-RSYNC_VERSION=3.0.0
+RSYNC_VERSION=3.0.1
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -308,14 +308,16 @@
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
-    sys/un.h sys/attr.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
-    netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h)
+    sys/un.h sys/attr.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
+    netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h \
+    sys/acl.h acl/libacl.h attr/xattr.h sys/xattr.h sys/extattr.h \
+    popt.h popt/popt.h)
 AC_HEADER_MAJOR
 
 AC_CACHE_CHECK([if makedev takes 3 args],rsync_cv_MAKEDEV_TAKES_3_ARGS,[
 AC_TRY_RUN([
 #include <sys/types.h>
 #ifdef MAJOR_IN_MKDEV
@@ -545,13 +547,13 @@
 dnl AC_FUNC_MEMCMP
 
 AC_FUNC_UTIME_NULL
 AC_FUNC_ALLOCA
 AC_CHECK_FUNCS(waitpid wait4 getcwd strdup chown chmod lchmod mknod mkfifo \
     fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \
-    memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
+    memmove lchown vsnprintf snprintf vasprintf asprintf setsid strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
     setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
     strerror putenv iconv_open locale_charset nl_langinfo getxattr \
     extattr_get_link sigaction sigprocmask setattrlist)
 
 dnl cygwin iconv.h defines iconv_open as libiconv_open
@@ -651,12 +653,21 @@
     AC_DEFINE(HAVE_SOCKETPAIR, 1, [Define to 1 if you have the "socketpair" function])
 fi
 
 if test x"$with_included_popt" != x"yes"; then
     AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])
 fi
+if test x"$ac_cv_header_popt_popt_h" = x"yes"; then
+    # If the system has /usr/include/popt/popt.h, we enable the
+    # included popt because an attempt to "#include <popt/popt.h>"
+    # would use our included header file anyway (due to -I.), and
+    # might conflict with the system popt.
+    with_included_popt=yes
+elif test x"$ac_cv_header_popt_h" != x"yes"; then
+    with_included_popt=yes
+fi
 
 AC_MSG_CHECKING([whether to use included libpopt])
 if test x"$with_included_popt" = x"yes"; then
     AC_MSG_RESULT($srcdir/popt)
     BUILD_POPT='$(popt_OBJS)'
     CFLAGS="$CFLAGS -I$srcdir/popt"
@@ -822,13 +833,12 @@
 AC_SUBST(OBJ_SAVE)
 AC_SUBST(OBJ_RESTORE)
 AC_SUBST(CC_SHOBJ_FLAG)
 AC_SUBST(BUILD_POPT)
 AC_SUBST(MAKE_MAN)
 
-AC_CHECK_HEADERS(sys/acl.h acl/libacl.h)
 AC_CHECK_FUNCS(_acl __acl _facl __facl)
 #################################################
 # check for ACL support
 
 AC_MSG_CHECKING([whether to support ACLs])
 AC_ARG_ENABLE(acl-support,
@@ -904,16 +914,12 @@
 	    fi
 	fi
 	;;
     esac
 fi
 
-AC_CHECK_HEADERS(attr/xattr.h)
-AC_CHECK_HEADERS(sys/xattr.h)
-AC_CHECK_HEADERS(sys/extattr.h)
-
 #################################################
 # check for extended attribute support
 AC_MSG_CHECKING(whether to support extended attributes)
 AC_ARG_ENABLE(xattr-support,
     AC_HELP_STRING([--disable-xattr-support],
 	    [disable extended attributes]),
@@ -949,12 +955,29 @@
 	    AC_MSG_RESULT(No extended attribute support found)
 	fi
 	;;
     esac
 fi
 
+if test x"$enable_acl_support" = x"no" -o x"$enable_xattr_support" = x"no" -o x"$enable_iconv" = x"no"; then
+    AC_MSG_CHECKING([whether $CC supports -Wno-unused-parameter])
+    OLD_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -Wno-unused-parameter"
+    AC_COMPILE_IFELSE([ ], [rsync_warn_flag=yes], [rsync_warn_flag=no])
+    AC_MSG_RESULT([$rsync_warn_flag])
+    if test x"$rsync_warn_flag" = x"no"; then
+	CFLAGS="$OLD_CFLAGS"
+    fi
+fi
+
+case "$CC" in
+' checker'*|checker*)
+    AC_DEFINE(FORCE_FD_ZERO_MEMSET, 1, [Used to make "checker" understand that FD_ZERO() clears memory.])
+    ;;
+esac
+
 AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
 AC_OUTPUT
 
 AC_MSG_RESULT()
 AC_MSG_RESULT([    rsync ${RSYNC_VERSION} configuration successful])
 AC_MSG_RESULT()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/configure.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/configure.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/configure.sh	2008-03-02 04:12:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/configure.sh	2008-04-04 13:54:27.000000000 +0800
@@ -1728,13 +1728,13 @@
 
 
 ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=3.0.0
+RSYNC_VERSION=3.0.1
 
 { echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
 echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -5524,17 +5524,25 @@
 
 
 
 
 
 
+
+
+
+
+
+
 for ac_header in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
-    sys/un.h sys/attr.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
-    netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h
+    sys/un.h sys/attr.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
+    netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h \
+    sys/acl.h acl/libacl.h attr/xattr.h sys/xattr.h sys/extattr.h \
+    popt.h popt/popt.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
   { echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
@@ -14785,16 +14793,15 @@
 
 
 
 
 
 
-
 for ac_func in waitpid wait4 getcwd strdup chown chmod lchmod mknod mkfifo \
     fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \
-    memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
+    memmove lchown vsnprintf snprintf vasprintf asprintf setsid strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
     setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
     strerror putenv iconv_open locale_charset nl_langinfo getxattr \
     extattr_get_link sigaction sigprocmask setattrlist
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
@@ -15524,12 +15531,21 @@
 
 else
   with_included_popt=yes
 fi
 
 fi
+if test x"$ac_cv_header_popt_popt_h" = x"yes"; then
+    # If the system has /usr/include/popt/popt.h, we enable the
+    # included popt because an attempt to "#include <popt/popt.h>"
+    # would use our included header file anyway (due to -I.), and
+    # might conflict with the system popt.
+    with_included_popt=yes
+elif test x"$ac_cv_header_popt_h" != x"yes"; then
+    with_included_popt=yes
+fi
 
 { echo "$as_me:$LINENO: checking whether to use included libpopt" >&5
 echo $ECHO_N "checking whether to use included libpopt... $ECHO_C" >&6; }
 if test x"$with_included_popt" = x"yes"; then
     { echo "$as_me:$LINENO: result: $srcdir/popt" >&5
 echo "${ECHO_T}$srcdir/popt" >&6; }
@@ -16126,153 +16142,12 @@
 
 
 
 
 
 
-for ac_header in sys/acl.h acl/libacl.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-
 
 
 for ac_func in _acl __acl _facl __facl
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 { echo "$as_me:$LINENO: checking for $ac_func" >&5
@@ -16686,37 +16561,92 @@
 	    fi
 	fi
 	;;
     esac
 fi
 
-
-for ac_header in attr/xattr.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+#################################################
+# check for extended attribute support
+{ echo "$as_me:$LINENO: checking whether to support extended attributes" >&5
+echo $ECHO_N "checking whether to support extended attributes... $ECHO_C" >&6; }
+# Check whether --enable-xattr-support was given.
+if test "${enable_xattr_support+set}" = set; then
+  enableval=$enable_xattr_support;
+else
+  case "$ac_cv_func_getxattr$ac_cv_func_extattr_get_link" in
+	*yes*) enable_xattr_support=maybe ;;
+	*) enable_xattr_support=no ;;
+	esac
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+
+
+
+if test x"$enable_xattr_support" = x"no"; then
+    { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
 else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+    case "$host_os" in
+    *linux*)
+	{ echo "$as_me:$LINENO: result: Using Linux xattrs" >&5
+echo "${ECHO_T}Using Linux xattrs" >&6; }
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_LINUX_XATTRS 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+
+	cat >>confdefs.h <<\_ACEOF
+#define SUPPORT_XATTRS 1
+_ACEOF
+
+	;;
+    darwin*)
+	{ echo "$as_me:$LINENO: result: Using OS X xattrs" >&5
+echo "${ECHO_T}Using OS X xattrs" >&6; }
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_OSX_XATTRS 1
+_ACEOF
+
+	cat >>confdefs.h <<\_ACEOF
+#define SUPPORT_XATTRS 1
+_ACEOF
+
+	;;
+    freebsd*)
+	{ echo "$as_me:$LINENO: result: Using FreeBSD extattrs" >&5
+echo "${ECHO_T}Using FreeBSD extattrs" >&6; }
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_FREEBSD_XATTRS 1
+_ACEOF
+
+	cat >>confdefs.h <<\_ACEOF
+#define SUPPORT_XATTRS 1
+_ACEOF
+
+	;;
+    *)
+	if test x"$enable_xattr_support" = x"yes"; then
+	    { { echo "$as_me:$LINENO: error: Failed to find extended attribute support" >&5
+echo "$as_me: error: Failed to find extended attribute support" >&2;}
+   { (exit 1); exit 1; }; }
+	else
+	    { echo "$as_me:$LINENO: result: No extended attribute support found" >&5
+echo "${ECHO_T}No extended attribute support found" >&6; }
+	fi
+	;;
+    esac
+fi
+
+if test x"$enable_acl_support" = x"no" -o x"$enable_xattr_support" = x"no" -o x"$enable_iconv" = x"no"; then
+    { echo "$as_me:$LINENO: checking whether $CC supports -Wno-unused-parameter" >&5
+echo $ECHO_N "checking whether $CC supports -Wno-unused-parameter... $ECHO_C" >&6; }
+    OLD_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -Wno-unused-parameter"
+    cat >conftest.$ac_ext <<_ACEOF
+
 _ACEOF
 rm -f conftest.$ac_objext
 if { (ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
@@ -16729,462 +16659,37 @@
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
+  rsync_warn_flag=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+	rsync_warn_flag=no
 fi
 
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+    { echo "$as_me:$LINENO: result: $rsync_warn_flag" >&5
+echo "${ECHO_T}$rsync_warn_flag" >&6; }
+    if test x"$rsync_warn_flag" = x"no"; then
+	CFLAGS="$OLD_CFLAGS"
+    fi
+fi
 
-# Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
+case "$CC" in
+' checker'*|checker*)
+
+cat >>confdefs.h <<\_ACEOF
+#define FORCE_FD_ZERO_MEMSET 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
 
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in sys/xattr.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in sys/extattr.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-#################################################
-# check for extended attribute support
-{ echo "$as_me:$LINENO: checking whether to support extended attributes" >&5
-echo $ECHO_N "checking whether to support extended attributes... $ECHO_C" >&6; }
-# Check whether --enable-xattr-support was given.
-if test "${enable_xattr_support+set}" = set; then
-  enableval=$enable_xattr_support;
-else
-  case "$ac_cv_func_getxattr$ac_cv_func_extattr_get_link" in
-	*yes*) enable_xattr_support=maybe ;;
-	*) enable_xattr_support=no ;;
-	esac
-fi
-
-
-
-if test x"$enable_xattr_support" = x"no"; then
-    { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-else
-    case "$host_os" in
-    *linux*)
-	{ echo "$as_me:$LINENO: result: Using Linux xattrs" >&5
-echo "${ECHO_T}Using Linux xattrs" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_LINUX_XATTRS 1
-_ACEOF
-
-	cat >>confdefs.h <<\_ACEOF
-#define SUPPORT_XATTRS 1
-_ACEOF
-
-	;;
-    darwin*)
-	{ echo "$as_me:$LINENO: result: Using OS X xattrs" >&5
-echo "${ECHO_T}Using OS X xattrs" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_OSX_XATTRS 1
-_ACEOF
-
-	cat >>confdefs.h <<\_ACEOF
-#define SUPPORT_XATTRS 1
-_ACEOF
-
-	;;
-    freebsd*)
-	{ echo "$as_me:$LINENO: result: Using FreeBSD extattrs" >&5
-echo "${ECHO_T}Using FreeBSD extattrs" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_FREEBSD_XATTRS 1
-_ACEOF
-
-	cat >>confdefs.h <<\_ACEOF
-#define SUPPORT_XATTRS 1
-_ACEOF
-
-	;;
-    *)
-	if test x"$enable_xattr_support" = x"yes"; then
-	    { { echo "$as_me:$LINENO: error: Failed to find extended attribute support" >&5
-echo "$as_me: error: Failed to find extended attribute support" >&2;}
-   { (exit 1); exit 1; }; }
-	else
-	    { echo "$as_me:$LINENO: result: No extended attribute support found" >&5
-echo "${ECHO_T}No extended attribute support found" >&6; }
-	fi
-	;;
-    esac
-fi
 
 ac_config_files="$ac_config_files Makefile lib/dummy zlib/dummy popt/dummy shconfig"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/exclude.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/exclude.c	2008-03-27 05:01:52.000000000 +0800
@@ -40,21 +40,23 @@
 extern char curr_dir[];
 extern unsigned int curr_dir_len;
 extern unsigned int module_dirlen;
 
 struct filter_list_struct filter_list = { 0, 0, "" };
 struct filter_list_struct cvs_filter_list = { 0, 0, " [global CVS]" };
-struct filter_list_struct server_filter_list = { 0, 0, " [daemon]" };
+struct filter_list_struct daemon_filter_list = { 0, 0, " [daemon]" };
 
 /* Need room enough for ":MODS " prefix plus some room to grow. */
 #define MAX_RULE_PREFIX (16)
 
 #define MODIFIERS_MERGE_FILE "-+Cenw"
 #define MODIFIERS_INCL_EXCL "/!Crsp"
 #define MODIFIERS_HIDE_PROTECT "/!p"
 
+#define SLASH_WILD3_SUFFIX "/***"
+
 /* The dirbuf is set by push_local_filters() to the current subdirectory
  * relative to curr_dir that is being processed.  The path always has a
  * trailing slash appended, and the variable dirbuf_len contains the length
  * of this path prefix.  The path is always absolute. */
 static char dirbuf[MAXPATHLEN+1];
 static unsigned int dirbuf_len = 0;
@@ -116,13 +118,13 @@
  * is not null-terminated. */
 static void add_rule(struct filter_list_struct *listp, const char *pat,
 		     unsigned int pat_len, uint32 mflags, int xflags)
 {
 	struct filter_struct *ret;
 	const char *cp;
-	unsigned int ex_len;
+	unsigned int pre_len, suf_len, slash_cnt = 0;
 
 	if (verbose > 2) {
 		rprintf(FINFO, "[%s] add_rule(%s%.*s%s)%s\n",
 			who_am_i(), get_rule_prefix(mflags, pat, 0, NULL),
 			(int)pat_len, pat,
 			(mflags & MATCHFLG_DIRECTORY) ? "/" : "",
@@ -142,28 +144,57 @@
 		}
 	}
 
 	if (!(ret = new0(struct filter_struct)))
 		out_of_memory("add_rule");
 
+	if (pat_len > 1 && pat[pat_len-1] == '/') {
+		pat_len--;
+		mflags |= MATCHFLG_DIRECTORY;
+	}
+
+	for (cp = pat; cp < pat + pat_len; cp++) {
+		if (*cp == '/')
+			slash_cnt++;
+	}
+
 	if (!(mflags & (MATCHFLG_ABS_PATH | MATCHFLG_MERGE_FILE))
 	 && ((xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH) && *pat == '/')
-	  || (xflags & XFLG_ABS_IF_SLASH && strchr(pat, '/') != NULL))) {
+	  || (xflags & XFLG_ABS_IF_SLASH && slash_cnt))) {
 		mflags |= MATCHFLG_ABS_PATH;
 		if (*pat == '/')
-			ex_len = dirbuf_len - module_dirlen - 1;
+			pre_len = dirbuf_len - module_dirlen - 1;
 		else
-			ex_len = 0;
+			pre_len = 0;
+	} else
+		pre_len = 0;
+
+	/* The daemon wants dir-exclude rules to get an appended "/" + "***". */
+	if (xflags & XFLG_DIR2WILD3
+	 && BITS_SETnUNSET(mflags, MATCHFLG_DIRECTORY, MATCHFLG_INCLUDE)) {
+		mflags &= ~MATCHFLG_DIRECTORY;
+		suf_len = sizeof SLASH_WILD3_SUFFIX - 1;
 	} else
-		ex_len = 0;
-	if (!(ret->pattern = new_array(char, ex_len + pat_len + 1)))
+		suf_len = 0;
+
+	if (!(ret->pattern = new_array(char, pre_len + pat_len + suf_len + 1)))
 		out_of_memory("add_rule");
-	if (ex_len)
-		memcpy(ret->pattern, dirbuf + module_dirlen, ex_len);
-	strlcpy(ret->pattern + ex_len, pat, pat_len + 1);
-	pat_len += ex_len;
+	if (pre_len) {
+		memcpy(ret->pattern, dirbuf + module_dirlen, pre_len);
+		for (cp = ret->pattern; cp < ret->pattern + pre_len; cp++) {
+			if (*cp == '/')
+				slash_cnt++;
+		}
+	}
+	strlcpy(ret->pattern + pre_len, pat, pat_len + 1);
+	pat_len += pre_len;
+	if (suf_len) {
+		memcpy(ret->pattern + pat_len, SLASH_WILD3_SUFFIX, suf_len+1);
+		pat_len += suf_len;
+		slash_cnt++;
+	}
 
 	if (strpbrk(ret->pattern, "*[?")) {
 		mflags |= MATCHFLG_WILD;
 		if ((cp = strstr(ret->pattern, "**")) != NULL) {
 			mflags |= MATCHFLG_WILD2;
 			/* If the pattern starts with **, note that. */
@@ -175,17 +206,12 @@
 			 && ret->pattern[pat_len-2] == '*'
 			 && ret->pattern[pat_len-1] == '*')
 				mflags |= MATCHFLG_WILD3_SUFFIX;
 		}
 	}
 
-	if (pat_len > 1 && ret->pattern[pat_len-1] == '/') {
-		ret->pattern[pat_len-1] = 0;
-		mflags |= MATCHFLG_DIRECTORY;
-	}
-
 	if (mflags & MATCHFLG_PERDIR_MERGE) {
 		struct filter_list_struct *lp;
 		unsigned int len;
 		int i;
 
 		if ((cp = strrchr(ret->pattern, '/')) != NULL)
@@ -223,16 +249,14 @@
 						struct filter_struct *,
 						mergelist_size);
 			if (!mergelist_parents)
 				out_of_memory("add_rule");
 		}
 		mergelist_parents[mergelist_cnt++] = ret;
-	} else {
-		for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
-			ret->u.slash_cnt++;
-	}
+	} else
+		ret->u.slash_cnt = slash_cnt;
 
 	ret->match_flags = mflags;
 
 	if (!listp->tail) {
 		ret->next = listp->head;
 		listp->head = listp->tail = ret;
@@ -292,31 +316,32 @@
 		/* null-terminate the name if it isn't already */
 		if (len_ptr && merge_file[*len_ptr]) {
 			char *to = fn == buf ? tmpbuf : buf;
 			strlcpy(to, merge_file, *len_ptr + 1);
 			merge_file = to;
 		}
-		if (!sanitize_path(fn, merge_file, r, dirbuf_depth)) {
+		if (!sanitize_path(fn, merge_file, r, dirbuf_depth, SP_DEFAULT)) {
 			rprintf(FERROR, "merge-file name overflows: %s\n",
 				merge_file);
 			return NULL;
 		}
 		fn_len = strlen(fn);
 	} else {
 		strlcpy(fn, merge_file, len_ptr ? *len_ptr + 1 : MAXPATHLEN);
 		fn_len = clean_fname(fn, CFN_COLLAPSE_DOT_DOT_DIRS);
 	}
 
 	/* If the name isn't in buf yet, it's wasn't absolute. */
 	if (fn != buf) {
-		if (dirbuf_len + fn_len >= MAXPATHLEN) {
+		int d_len = dirbuf_len - prefix_skip;
+		if (d_len + fn_len >= MAXPATHLEN) {
 			rprintf(FERROR, "merge-file name overflows: %s\n", fn);
 			return NULL;
 		}
-		memcpy(buf, dirbuf + prefix_skip, dirbuf_len - prefix_skip);
-		memcpy(buf + dirbuf_len - prefix_skip, fn, fn_len + 1);
+		memcpy(buf, dirbuf + prefix_skip, d_len);
+		memcpy(buf + d_len, fn, fn_len + 1);
 		fn_len = clean_fname(buf, CFN_COLLAPSE_DOT_DOT_DIRS);
 	}
 
 	if (len_ptr)
 		*len_ptr = fn_len;
 	return buf;
@@ -514,19 +539,19 @@
 	}
 
 	cur_depth = dir_depth;
 	filt_array[cur_depth] = push_local_filters(dname, dlen);
 }
 
-static int rule_matches(char *fname, struct filter_struct *ex, int name_is_dir)
+static int rule_matches(const char *fname, struct filter_struct *ex, int name_is_dir)
 {
 	int slash_handling, str_cnt = 0, anchored_match = 0;
 	int ret_match = ex->match_flags & MATCHFLG_NEGATE ? 0 : 1;
 	char *p, *pattern = ex->pattern;
 	const char *strings[16]; /* more than enough */
-	char *name = fname + (*fname == '/');
+	const char *name = fname + (*fname == '/');
 
 	if (!*name)
 		return 0;
 
 	if (!ex->u.slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
 		/* If the pattern does not have any slashes AND it does
@@ -593,60 +618,61 @@
 	}
 
 	return !ret_match;
 }
 
 
-static void report_filter_result(char const *name,
+static void report_filter_result(enum logcode code, char const *name,
                                  struct filter_struct const *ent,
                                  int name_is_dir, const char *type)
 {
 	/* If a trailing slash is present to match only directories,
 	 * then it is stripped out by add_rule().  So as a special
 	 * case we add it back in here. */
 
 	if (verbose >= 2) {
 		static char *actions[2][2]
 		    = { {"show", "hid"}, {"risk", "protect"} };
 		const char *w = who_am_i();
-		rprintf(FINFO, "[%s] %sing %s %s because of pattern %s%s%s\n",
+		rprintf(code, "[%s] %sing %s %s because of pattern %s%s%s\n",
 		    w, actions[*w!='s'][!(ent->match_flags&MATCHFLG_INCLUDE)],
 		    name_is_dir ? "directory" : "file", name, ent->pattern,
 		    ent->match_flags & MATCHFLG_DIRECTORY ? "/" : "", type);
 	}
 }
 
 
 /*
  * Return -1 if file "name" is defined to be excluded by the specified
  * exclude list, 1 if it is included, and 0 if it was not matched.
  */
-int check_filter(struct filter_list_struct *listp, char *name, int name_is_dir)
+int check_filter(struct filter_list_struct *listp, enum logcode code,
+		 const char *name, int name_is_dir)
 {
 	struct filter_struct *ent;
 
 	for (ent = listp->head; ent; ent = ent->next) {
 		if (ignore_perishable && ent->match_flags & MATCHFLG_PERISHABLE)
 			continue;
 		if (ent->match_flags & MATCHFLG_PERDIR_MERGE) {
-			int rc = check_filter(ent->u.mergelist, name,
+			int rc = check_filter(ent->u.mergelist, code, name,
 					      name_is_dir);
 			if (rc)
 				return rc;
 			continue;
 		}
 		if (ent->match_flags & MATCHFLG_CVS_IGNORE) {
-			int rc = check_filter(&cvs_filter_list, name,
+			int rc = check_filter(&cvs_filter_list, code, name,
 					      name_is_dir);
 			if (rc)
 				return rc;
 			continue;
 		}
 		if (rule_matches(name, ent, name_is_dir)) {
-			report_filter_result(name, ent, name_is_dir,
-					      listp->debug_type);
+			report_filter_result(code, name, ent, name_is_dir,
+					     listp->debug_type);
 			return ent->match_flags & MATCHFLG_INCLUDE ? 1 : -1;
 		}
 	}
 
 	return 0;
 }
@@ -1006,16 +1032,16 @@
 	int word_split = mflags & MATCHFLG_WORD_SPLIT;
 
 	if (!fname || !*fname)
 		return;
 
 	if (*fname != '-' || fname[1] || am_server) {
-		if (server_filter_list.head) {
+		if (daemon_filter_list.head) {
 			strlcpy(line, fname, sizeof line);
 			clean_fname(line, CFN_COLLAPSE_DOT_DOT_DIRS);
-			if (check_filter(&server_filter_list, line, 0) < 0)
+			if (check_filter(&daemon_filter_list, FLOG, line, 0) < 0)
 				fp = NULL;
 			else
 				fp = fopen(line, "rb");
 		} else
 			fp = fopen(fname, "rb");
 	} else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/flist.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/flist.c	2008-03-31 22:46:47.000000000 +0800
@@ -73,13 +73,13 @@
 
 extern char curr_dir[MAXPATHLEN];
 
 extern struct chmod_mode_struct *chmod_modes;
 
 extern struct filter_list_struct filter_list;
-extern struct filter_list_struct server_filter_list;
+extern struct filter_list_struct daemon_filter_list;
 
 #ifdef ICONV_OPTION
 extern int filesfrom_convert;
 extern iconv_t ic_send, ic_recv;
 #endif
 
@@ -94,13 +94,13 @@
 int flist_cnt = 0; /* how many (non-tmp) file list objects exist */
 int file_total = 0; /* total of all active items over all file-lists */
 int flist_eof = 0; /* all the file-lists are now known */
 
 #define NORMAL_NAME 0
 #define SLASH_ENDING_NAME 1
-#define DOT_NAME 2
+#define DOTDIR_NAME 2
 
 /* Starting from protocol version 26, we always use 64-bit ino_t and dev_t
  * internally, even if this platform does not allow files to have 64-bit inums.
  * The only exception is if we're on a platform with no 64-bit type at all.
  *
  * Because we use read_longint() to get these off the wire, if you transfer
@@ -229,39 +229,63 @@
 	return 0;
 #else
 	return x_stat(path, stp, NULL);
 #endif
 }
 
+static inline int is_daemon_excluded(const char *fname, int is_dir)
+{
+	if (daemon_filter_list.head
+	 && check_filter(&daemon_filter_list, FLOG, fname, is_dir) < 0) {
+		errno = ENOENT;
+		return 1;
+	}
+	return 0;
+}
+
+static inline int path_is_daemon_excluded(char *path, int ignore_filename)
+{
+	if (daemon_filter_list.head) {
+		char *slash = path;
+
+		while ((slash = strchr(slash+1, '/')) != NULL) {
+			int ret;
+			*slash = '\0';
+			ret = check_filter(&daemon_filter_list, FLOG, path, 1);
+			*slash = '/';
+			if (ret < 0) {
+				errno = ENOENT;
+				return 1;
+			}
+		}
+
+		if (!ignore_filename
+		 && check_filter(&daemon_filter_list, FLOG, path, 1) < 0) {
+			errno = ENOENT;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
 /* This function is used to check if a file should be included/excluded
  * from the list of files based on its name and type etc.  The value of
  * filter_level is set to either SERVER_FILTERS or ALL_FILTERS. */
-static int is_excluded(char *fname, int is_dir, int filter_level)
+static int is_excluded(const char *fname, int is_dir, int filter_level)
 {
 #if 0 /* This currently never happens, so avoid a useless compare. */
 	if (filter_level == NO_FILTERS)
 		return 0;
 #endif
-	if (fname) {
-		/* never exclude '.', even if somebody does --exclude '*' */
-		if (fname[0] == '.' && !fname[1])
-			return 0;
-		/* Handle the -R version of the '.' dir. */
-		if (fname[0] == '/') {
-			int len = strlen(fname);
-			if (fname[len-1] == '.' && fname[len-2] == '/')
-				return 0;
-		}
-	}
-	if (server_filter_list.head
-	    && check_filter(&server_filter_list, fname, is_dir) < 0)
+	if (is_daemon_excluded(fname, is_dir))
 		return 1;
 	if (filter_level != ALL_FILTERS)
 		return 0;
 	if (filter_list.head
-	    && check_filter(&filter_list, fname, is_dir) < 0)
+	    && check_filter(&filter_list, FINFO, fname, is_dir) < 0)
 		return 1;
 	return 0;
 }
 
 static void send_directory(int f, struct file_list *flist,
 			   char *fbuf, int len, int flags);
@@ -312,86 +335,77 @@
 	if (flist->pool_boundary == ptr)
 		flist->pool_boundary = NULL; /* list didn't use any pool memory */
 	else
 		flist->pool_boundary = ptr;
 }
 
-int push_pathname(const char *dir, int len)
-{
-	if (dir == pathname)
-		return 1;
+/* Call this with EITHER (1) "file, NULL, 0" to chdir() to the file's
+ * F_PATHNAME(), or (2) "NULL, dir, dirlen" to chdir() to the supplied dir,
+ * with dir == NULL taken to be the starting directory, and dirlen < 0
+ * indicating that strdup(dir) should be called and then the -dirlen length
+ * value checked to ensure that it is not daemon-excluded. */
+int change_pathname(struct file_struct *file, const char *dir, int dirlen)
+{
+	if (dirlen < 0) {
+		char *cpy = strdup(dir);
+		if (*cpy != '/')
+			change_dir(orig_dir, CD_SKIP_CHDIR);
+		if (path_is_daemon_excluded(cpy, 0))
+			goto chdir_error;
+		dir = cpy;
+		dirlen = -dirlen;
+	} else {
+		if (file) {
+			if (pathname == F_PATHNAME(file))
+				return 1;
+			dir = F_PATHNAME(file);
+			if (dir)
+				dirlen = strlen(dir);
+		} else if (pathname == dir)
+			return 1;
+		if (dir && *dir != '/')
+			change_dir(orig_dir, CD_SKIP_CHDIR);
+	}
 
-	if (!orig_dir)
-		orig_dir = strdup(curr_dir);
+	pathname = dir;
+	pathname_len = dirlen;
 
-	if (pathname && !pop_dir(orig_dir)) {
-		rsyserr(FERROR, errno, "pop_dir %s failed",
-			full_fname(orig_dir));
-		exit_cleanup(RERR_FILESELECT);
-	}
+	if (!dir)
+		dir = orig_dir;
 
-	if (dir && !push_dir(dir, 0)) {
+	if (!change_dir(dir, CD_NORMAL)) {
+	  chdir_error:
 		io_error |= IOERR_GENERAL;
-		rsyserr(FERROR, errno, "push_dir %s failed in %s",
-			full_fname(dir), curr_dir);
+		rsyserr(FERROR, errno, "change_dir %s failed", full_fname(dir));
+		if (dir != orig_dir)
+			change_dir(orig_dir, CD_NORMAL);
+		pathname = NULL;
+		pathname_len = 0;
 		return 0;
 	}
 
-	pathname = dir;
-	pathname_len = len >= 0 ? len : dir ? (int)strlen(dir) : 0;
-
 	return 1;
 }
 
-static void send_file_entry(int f, struct file_struct *file, int ndx, int first_ndx)
+static void send_file_entry(int f, const char *fname, struct file_struct *file, int ndx, int first_ndx)
 {
 	static time_t modtime;
 	static mode_t mode;
 #ifdef SUPPORT_HARD_LINKS
 	static int64 dev;
 #endif
 	static dev_t rdev;
 	static uint32 rdev_major;
 	static uid_t uid;
 	static gid_t gid;
 	static const char *user_name, *group_name;
 	static char lastname[MAXPATHLEN];
-	char fname[MAXPATHLEN];
 	int first_hlink_ndx = -1;
 	int l1, l2;
 	int xflags;
 
-#ifdef ICONV_OPTION
-	if (ic_send != (iconv_t)-1) {
-		xbuf outbuf, inbuf;
-
-		INIT_CONST_XBUF(outbuf, fname);
-
-		if (file->dirname) {
-			INIT_XBUF_STRLEN(inbuf, (char*)file->dirname);
-			outbuf.size -= 2; /* Reserve room for '/' & 1 more char. */
-			if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0)
-				goto convert_error;
-			outbuf.size += 2;
-			outbuf.buf[outbuf.len++] = '/';
-		}
-
-		INIT_XBUF_STRLEN(inbuf, (char*)file->basename);
-		if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0) {
-		  convert_error:
-			io_error |= IOERR_GENERAL;
-			rprintf(FINFO,
-			    "[%s] cannot convert filename: %s (%s)\n",
-			    who_am_i(), f_name(file, fname), strerror(errno));
-			return;
-		}
-		outbuf.buf[outbuf.len] = '\0';
-	} else
-#endif
-		f_name(file, fname);
-
 	/* Initialize starting value of xflags. */
 	if (protocol_version >= 30 && S_ISDIR(file->mode)) {
 		dir_count++;
 		if (file->flags & FLAG_CONTENT_DIR)
 			xflags = file->flags & FLAG_TOP_DIR;
 		else if (file->flags & FLAG_IMPLIED_DIR)
@@ -421,34 +435,30 @@
 				rdev_major = major(rdev);
 			if (protocol_version < 30 && (uint32)minor(rdev) <= 0xFFu)
 				xflags |= XMIT_RDEV_MINOR_8_pre30;
 		}
 	} else if (protocol_version < 28)
 		rdev = MAKEDEV(0, 0);
-	if (preserve_uid) {
-		if ((uid_t)F_OWNER(file) == uid && *lastname)
-			xflags |= XMIT_SAME_UID;
-		else {
-			uid = F_OWNER(file);
-			if (!numeric_ids) {
-				user_name = add_uid(uid);
-				if (inc_recurse && user_name)
-					xflags |= XMIT_USER_NAME_FOLLOWS;
-			}
+	if (!preserve_uid || ((uid_t)F_OWNER(file) == uid && *lastname))
+		xflags |= XMIT_SAME_UID;
+	else {
+		uid = F_OWNER(file);
+		if (!numeric_ids) {
+			user_name = add_uid(uid);
+			if (inc_recurse && user_name)
+				xflags |= XMIT_USER_NAME_FOLLOWS;
 		}
 	}
-	if (preserve_gid) {
-		if ((gid_t)F_GROUP(file) == gid && *lastname)
-			xflags |= XMIT_SAME_GID;
-		else {
-			gid = F_GROUP(file);
-			if (!numeric_ids) {
-				group_name = add_gid(gid);
-				if (inc_recurse && group_name)
-					xflags |= XMIT_GROUP_NAME_FOLLOWS;
-			}
+	if (!preserve_gid || ((gid_t)F_GROUP(file) == gid && *lastname))
+		xflags |= XMIT_SAME_GID;
+	else {
+		gid = F_GROUP(file);
+		if (!numeric_ids) {
+			group_name = add_gid(gid);
+			if (inc_recurse && group_name)
+				xflags |= XMIT_GROUP_NAME_FOLLOWS;
 		}
 	}
 	if (file->modtime == modtime)
 		xflags |= XMIT_SAME_TIME;
 	else
 		modtime = file->modtime;
@@ -459,21 +469,20 @@
 			struct ht_int64_node *np = idev_find(tmp_dev, tmp_ino);
 			first_hlink_ndx = (int32)(long)np->data - 1;
 			if (first_hlink_ndx < 0) {
 				np->data = (void*)(long)(first_ndx + ndx + 1);
 				xflags |= XMIT_HLINK_FIRST;
 			}
-			xflags |= XMIT_HLINKED;
 		} else {
 			if (tmp_dev == dev) {
 				if (protocol_version >= 28)
 					xflags |= XMIT_SAME_DEV_pre30;
 			} else
 				dev = tmp_dev;
-			xflags |= XMIT_HLINKED;
 		}
+		xflags |= XMIT_HLINKED;
 	}
 #endif
 
 	for (l1 = 0;
 	    lastname[l1] && (fname[l1] == lastname[l1]) && (l1 < 255);
 	    l1++) {}
@@ -672,16 +681,17 @@
 			outbuf.len = 0;
 		}
 		outbuf.buf[outbuf.len] = '\0';
 	}
 #endif
 
-	clean_fname(thisname, 0);
+	if (*thisname)
+		clean_fname(thisname, 0);
 
 	if (sanitize_paths)
-		sanitize_path(thisname, thisname, "", 0);
+		sanitize_path(thisname, thisname, "", 0, SP_DEFAULT);
 
 	if ((basename = strrchr(thisname, '/')) != NULL) {
 		int len = basename++ - thisname;
 		if (len != lastdir_len || memcmp(thisname, lastdir, len) != 0) {
 			lastdir = new_array(char, len + 1);
 			memcpy(lastdir, thisname, len);
@@ -816,15 +826,15 @@
 		if (xflags & XMIT_HLINKED)
 			extra_len += (inc_recurse+1) * EXTRA_LEN;
 	}
 #endif
 
 #ifdef SUPPORT_ACLS
-	/* We need one or two index int32s when we're preserving ACLs. */
-	if (preserve_acls)
-		extra_len += (S_ISDIR(mode) ? 2 : 1) * EXTRA_LEN;
+	/* Directories need an extra int32 for the default ACL. */
+	if (preserve_acls && S_ISDIR(mode))
+		extra_len += EXTRA_LEN;
 #endif
 
 	if (always_checksum && S_ISREG(mode))
 		extra_len += SUM_EXTRA_CNT * EXTRA_LEN;
 
 	if (file_length > 0xFFFFFFFFu && S_ISREG(mode))
@@ -851,13 +861,12 @@
 	memset(bp, 0, extra_len + FILE_STRUCT_LEN);
 	bp += extra_len;
 	file = (struct file_struct *)bp;
 	bp += FILE_STRUCT_LEN;
 
 	memcpy(bp, basename, basename_len);
-	bp += basename_len + linkname_len; /* skip space for symlink too */
 
 #ifdef SUPPORT_HARD_LINKS
 	if (xflags & XMIT_HLINKED)
 		file->flags |= FLAG_HLINKED;
 #endif
 	file->modtime = (time_t)modtime;
@@ -916,25 +925,25 @@
 		DEV_MAJOR(devp) = major(rdev);
 		DEV_MINOR(devp) = minor(rdev);
 	}
 
 #ifdef SUPPORT_LINKS
 	if (linkname_len) {
-		bp = (char*)file->basename + basename_len;
+		bp += basename_len;
 		if (first_hlink_ndx >= flist->ndx_start) {
 			struct file_struct *first = flist->files[first_hlink_ndx - flist->ndx_start];
 			memcpy(bp, F_SYMLINK(first), linkname_len);
 		} else if (munge_symlinks) {
 			strlcpy(bp, SYMLINK_PREFIX, linkname_len);
 			bp += SYMLINK_PREFIX_LEN;
 			linkname_len -= SYMLINK_PREFIX_LEN;
 			read_sbuf(f, bp, linkname_len - 1);
 		} else {
 			read_sbuf(f, bp, linkname_len - 1);
 			if (sanitize_paths)
-				sanitize_path(bp, bp, "", lastdir_depth);
+				sanitize_path(bp, bp, "", lastdir_depth, SP_DEFAULT);
 		}
 	}
 #endif
 
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && xflags & XMIT_HLINKED) {
@@ -1011,21 +1020,22 @@
 	char linkname[MAXPATHLEN];
 	int alloc_len, basename_len, linkname_len;
 	int extra_len = file_extra_cnt * EXTRA_LEN;
 	const char *basename;
 	alloc_pool_t *pool;
 	STRUCT_STAT st;
+	int excl_ret;
 	char *bp;
 
 	if (strlcpy(thisname, fname, sizeof thisname) >= sizeof thisname) {
 		rprintf(FINFO, "skipping overly long name: %s\n", fname);
 		return NULL;
 	}
 	clean_fname(thisname, 0);
 	if (sanitize_paths)
-		sanitize_path(thisname, thisname, "", 0);
+		sanitize_path(thisname, thisname, "", 0, SP_DEFAULT);
 
 	if (stp && S_ISDIR(stp->st_mode)) {
 		st = *stp; /* Needed for "symlink/." with --relative. */
 		*linkname = '\0'; /* make IBM code checker happy */
 	} else if (readlink_stat(thisname, &st, linkname) != 0) {
 		int save_errno = errno;
@@ -1093,13 +1103,23 @@
 			flags |= FLAG_MOUNT_DIR;
 			flags &= ~FLAG_CONTENT_DIR;
 		}
 	} else
 		flags &= ~FLAG_CONTENT_DIR;
 
-	if (is_excluded(thisname, S_ISDIR(st.st_mode) != 0, filter_level)) {
+	if (S_ISDIR(st.st_mode)) {
+		if (flags & FLAG_DOTDIR_NAME) {
+			/* A "." fname (or "/." fname in relative mode) is
+			 * never excluded.  No other trailing-dotdir names
+			 * are possible. */
+			excl_ret = 0;
+		} else
+			excl_ret = is_excluded(thisname, 1, filter_level);
+	} else
+		excl_ret = is_excluded(thisname, 0, filter_level);
+	if (excl_ret) {
 		if (ignore_perishable)
 			non_perishable_cnt++;
 		return NULL;
 	}
 
 	if (lp_ignore_nonreadable(module_id)) {
@@ -1120,14 +1140,20 @@
 			extra_len += DIRNODE_EXTRA_CNT * EXTRA_LEN;
 			if (relative_paths)
 				extra_len += PTR_EXTRA_CNT * EXTRA_LEN;
 			pool = dir_flist->file_pool;
 		} else
 			pool = flist->file_pool;
-	} else
+	} else {
+#ifdef SUPPORT_ACLS
+		/* Directories need an extra int32 for the default ACL. */
+		if (preserve_acls && S_ISDIR(st.st_mode))
+			extra_len += EXTRA_LEN;
+#endif
 		pool = NULL;
+	}
 
 	if (verbose > 2) {
 		rprintf(FINFO, "[%s] make_file(%s,*,%d)\n",
 			who_am_i(), thisname, filter_level);
 	}
 
@@ -1169,13 +1195,12 @@
 	memset(bp, 0, extra_len + FILE_STRUCT_LEN);
 	bp += extra_len;
 	file = (struct file_struct *)bp;
 	bp += FILE_STRUCT_LEN;
 
 	memcpy(bp, basename, basename_len);
-	bp += basename_len + linkname_len; /* skip space for symlink too */
 
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && flist && flist->prev) {
 		if (protocol_version >= 28
 		 ? (!S_ISDIR(st.st_mode) && st.st_nlink > 1)
 		 : S_ISREG(st.st_mode)) {
@@ -1207,22 +1232,23 @@
 		F_GROUP(file) = st.st_gid;
 
 	if (basename != thisname)
 		file->dirname = lastdir;
 
 #ifdef SUPPORT_LINKS
-	if (linkname_len) {
-		bp = (char*)file->basename + basename_len;
-		memcpy(bp, linkname, linkname_len);
-	}
+	if (linkname_len)
+		memcpy(bp + basename_len, linkname, linkname_len);
 #endif
 
 	if (always_checksum && am_sender && S_ISREG(st.st_mode))
 		file_checksum(thisname, tmp_sum, st.st_size);
 
-	F_PATHNAME(file) = pathname;
+	if (am_sender)
+		F_PATHNAME(file) = pathname;
+	else if (!pool)
+		F_DEPTH(file) = extra_len / EXTRA_LEN;
 
 	/* This code is only used by the receiver when it is building
 	 * a list of files for a delete pass. */
 	if (keep_dirlinks && linkname_len && flist) {
 		STRUCT_STAT st2;
 		int save_mode = file->mode;
@@ -1252,58 +1278,81 @@
 	return file;
 }
 
 /* Only called for temporary file_struct entries created by make_file(). */
 void unmake_file(struct file_struct *file)
 {
-	int extra_cnt = file_extra_cnt + LEN64_BUMP(file);
-#if EXTRA_ROUNDING > 0
-	if (extra_cnt & EXTRA_ROUNDING)
-		extra_cnt = (extra_cnt | EXTRA_ROUNDING) + 1;
-#endif
-	free(REQ_EXTRA(file, extra_cnt));
+	free(REQ_EXTRA(file, F_DEPTH(file)));
 }
 
 static struct file_struct *send_file_name(int f, struct file_list *flist,
-					  char *fname, STRUCT_STAT *stp,
+					  const char *fname, STRUCT_STAT *stp,
 					  int flags, int filter_level)
 {
 	struct file_struct *file;
-#if defined SUPPORT_ACLS || defined SUPPORT_XATTRS
-	stat_x sx;
-#endif
 
 	file = make_file(fname, flist, stp, flags, filter_level);
 	if (!file)
 		return NULL;
 
 	if (chmod_modes && !S_ISLNK(file->mode))
 		file->mode = tweak_mode(file->mode, chmod_modes);
 
+	if (f >= 0) {
+		char fbuf[MAXPATHLEN];
+#if defined SUPPORT_ACLS || defined SUPPORT_XATTRS
+		stat_x sx;
+#endif
+
+#ifdef ICONV_OPTION
+		if (ic_send != (iconv_t)-1) {
+			xbuf outbuf, inbuf;
+
+			INIT_CONST_XBUF(outbuf, fbuf);
+
+			if (file->dirname) {
+				INIT_XBUF_STRLEN(inbuf, (char*)file->dirname);
+				outbuf.size -= 2; /* Reserve room for '/' & 1 more char. */
+				if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0)
+					goto convert_error;
+				outbuf.size += 2;
+				outbuf.buf[outbuf.len++] = '/';
+			}
+
+			INIT_XBUF_STRLEN(inbuf, (char*)file->basename);
+			if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0) {
+			  convert_error:
+				io_error |= IOERR_GENERAL;
+				rprintf(FINFO,
+				    "[%s] cannot convert filename: %s (%s)\n",
+				    who_am_i(), f_name(file, fbuf), strerror(errno));
+				return NULL;
+			}
+			outbuf.buf[outbuf.len] = '\0';
+		} else
+#endif
+			f_name(file, fbuf);
+
 #ifdef SUPPORT_ACLS
-	if (preserve_acls && !S_ISLNK(file->mode) && f >= 0) {
-		sx.st.st_mode = file->mode;
-		sx.acc_acl = sx.def_acl = NULL;
-		if (get_acl(fname, &sx) < 0)
-			return NULL;
-	}
+		if (preserve_acls && !S_ISLNK(file->mode)) {
+			sx.st.st_mode = file->mode;
+			sx.acc_acl = sx.def_acl = NULL;
+			if (get_acl(fname, &sx) < 0)
+				return NULL;
+		}
 #endif
 #ifdef SUPPORT_XATTRS
-	if (preserve_xattrs && f >= 0) {
-		sx.xattr = NULL;
-		if (get_xattr(fname, &sx) < 0)
-			return NULL;
-	}
+		if (preserve_xattrs) {
+			sx.xattr = NULL;
+			if (get_xattr(fname, &sx) < 0)
+				return NULL;
+		}
 #endif
 
-	maybe_emit_filelist_progress(flist->used + flist_count_offset);
+		send_file_entry(f, fbuf, file, flist->used, flist->ndx_start);
 
-	flist_expand(flist, 1);
-	flist->files[flist->used++] = file;
-	if (f >= 0) {
-		send_file_entry(f, file, flist->used - 1, flist->ndx_start);
 #ifdef SUPPORT_ACLS
 		if (preserve_acls && !S_ISLNK(file->mode)) {
 			send_acl(&sx, f);
 			free_acl(&sx);
 		}
 #endif
@@ -1311,12 +1360,18 @@
 		if (preserve_xattrs) {
 			F_XATTR(file) = send_xattr(&sx, f);
 			free_xattr(&sx);
 		}
 #endif
 	}
+
+	maybe_emit_filelist_progress(flist->used + flist_count_offset);
+
+	flist_expand(flist, 1);
+	flist->files[flist->used++] = file;
+
 	return file;
 }
 
 static void send_if_directory(int f, struct file_list *flist,
 			      struct file_struct *file,
 			      char *fbuf, unsigned int ol,
@@ -1518,59 +1573,80 @@
 		/* send_if_directory() bumps flist->used, so use "end". */
 		for (i = start; i <= end; i++)
 			send_if_directory(f, flist, flist->files[i], fbuf, len, flags);
 	}
 }
 
-static char lastpath[MAXPATHLEN] = "";
-static int lastpath_len = 0;
-static struct file_struct *lastpath_struct;
-
 static void send_implied_dirs(int f, struct file_list *flist, char *fname,
 			      char *start, char *limit, int flags, char name_type)
 {
+	static char lastpath[MAXPATHLEN] = "";
+	static int lastpath_len = 0;
+	static struct file_struct *lastpath_struct = NULL;
 	struct file_struct *file;
 	item_list *relname_list;
 	relnamecache **rnpp;
-	char *slash;
-	int len, need_new_dir;
+	int len, need_new_dir, depth = 0;
 	struct filter_list_struct save_filter_list = filter_list;
 
 	flags = (flags | FLAG_IMPLIED_DIR) & ~(FLAG_TOP_DIR | FLAG_CONTENT_DIR);
 	filter_list.head = filter_list.tail = NULL; /* Don't filter implied dirs. */
 
 	if (inc_recurse) {
 		if (lastpath_struct && F_PATHNAME(lastpath_struct) == pathname
 		 && lastpath_len == limit - fname
 		 && strncmp(lastpath, fname, lastpath_len) == 0)
 			need_new_dir = 0;
 		else
 			need_new_dir = 1;
-	} else
+	} else {
+		char *tp = fname, *lp = lastpath;
+		/* Skip any initial directories in our path that we
+		 * have in common with lastpath. */
+		assert(start == fname);
+		for ( ; ; tp++, lp++) {
+			if (tp == limit) {
+				if (*lp == '/' || *lp == '\0')
+					goto done;
+				break;
+			}
+			if (*lp != *tp)
+				break;
+			if (*tp == '/') {
+				start = tp;
+				depth++;
+			}
+		}
 		need_new_dir = 1;
+	}
 
 	if (need_new_dir) {
 		int save_copy_links = copy_links;
 		int save_xfer_dirs = xfer_dirs;
+		char *slash;
 
 		copy_links = xfer_dirs = 1;
 
 		*limit = '\0';
 
 		for (slash = start; (slash = strchr(slash+1, '/')) != NULL; ) {
 			*slash = '\0';
-			send_file_name(f, flist, fname, NULL, flags, ALL_FILTERS);
+			file = send_file_name(f, flist, fname, NULL, flags, ALL_FILTERS);
+			depth++;
+			if (!inc_recurse && file && S_ISDIR(file->mode))
+				change_local_filter_dir(fname, strlen(fname), depth);
 			*slash = '/';
 		}
 
 		file = send_file_name(f, flist, fname, NULL, flags, ALL_FILTERS);
 		if (inc_recurse) {
 			if (file && !S_ISDIR(file->mode))
 				file = NULL;
 			lastpath_struct = file;
-		}
+		} else if (file && S_ISDIR(file->mode))
+			change_local_filter_dir(fname, strlen(fname), ++depth);
 
 		strlcpy(lastpath, fname, sizeof lastpath);
 		lastpath_len = limit - fname;
 
 		*limit = '/';
 
@@ -1608,16 +1684,14 @@
 	int len, dlen, flags = FLAG_DIVERT_DIRS | FLAG_CONTENT_DIR;
 	size_t j;
 
 	f_name(file, fbuf);
 	dlen = strlen(fbuf);
 
-	if (F_PATHNAME(file) != pathname) {
-		if (!push_pathname(F_PATHNAME(file), -1))
-			exit_cleanup(RERR_FILESELECT);
-	}
+	if (!change_pathname(file, NULL, 0))
+		exit_cleanup(RERR_FILESELECT);
 
 	change_local_filter_dir(fbuf, dlen, send_dir_depth);
 
 	if (file->flags & FLAG_CONTENT_DIR) {
 		if (one_file_system) {
 			STRUCT_STAT st;
@@ -1776,29 +1850,33 @@
 	char *p, *dir;
 	struct file_list *flist;
 	struct timeval start_tv, end_tv;
 	int64 start_write;
 	int use_ff_fd = 0;
 	int disable_buffering;
-	int flags = recurse ? FLAG_CONTENT_DIR : 0;
+	int arg_flags, flags = recurse ? FLAG_CONTENT_DIR : 0;
 	int reading_remotely = filesfrom_host != NULL;
 	int rl_flags = (reading_remotely ? 0 : RL_DUMP_COMMENTS)
 #ifdef ICONV_OPTION
 		     | (filesfrom_convert ? RL_CONVERT : 0)
 #endif
 		     | (eol_nulls || reading_remotely ? RL_EOL_NULLS : 0);
+	int implied_dot_dir = 0;
 
 	rprintf(FLOG, "building file list\n");
 	if (show_filelist_p())
 		start_filelist_progress("building file list");
 	else if (inc_recurse && verbose && !am_server)
 		rprintf(FCLIENT, "sending incremental file list\n");
 
 	start_write = stats.total_written;
 	gettimeofday(&start_tv, NULL);
 
+	if (!orig_dir)
+		orig_dir = strdup(curr_dir);
+
 	if (relative_paths && protocol_version >= 30)
 		implied_dirs = 1; /* We send flagged implied dirs */
 
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && protocol_version >= 30 && !cur_flist)
 		init_hard_links();
@@ -1810,33 +1888,33 @@
 		flags |= FLAG_DIVERT_DIRS;
 	} else
 		dir_flist = cur_flist;
 
 	disable_buffering = io_start_buffering_out(f);
 	if (filesfrom_fd >= 0) {
-		if (argv[0] && !push_dir(argv[0], 0)) {
-			rsyserr(FERROR_XFER, errno, "push_dir %s failed in %s",
-				full_fname(argv[0]), curr_dir);
+		if (argv[0] && !change_dir(argv[0], CD_NORMAL)) {
+			rsyserr(FERROR_XFER, errno, "change_dir %s failed",
+				full_fname(argv[0]));
 			exit_cleanup(RERR_FILESELECT);
 		}
 		use_ff_fd = 1;
 	}
 
 	while (1) {
 		char fbuf[MAXPATHLEN], *fn, name_type;
 
 		if (use_ff_fd) {
 			if (read_line(filesfrom_fd, fbuf, sizeof fbuf, rl_flags) == 0)
 				break;
-			sanitize_path(fbuf, fbuf, "", 0);
+			sanitize_path(fbuf, fbuf, "", 0, SP_KEEP_DOT_DIRS);
 		} else {
 			if (argc-- == 0)
 				break;
 			strlcpy(fbuf, *argv++, MAXPATHLEN);
 			if (sanitize_paths)
-				sanitize_path(fbuf, fbuf, "", 0);
+				sanitize_path(fbuf, fbuf, "", 0, SP_KEEP_DOT_DIRS);
 		}
 
 		len = strlen(fbuf);
 		if (relative_paths) {
 			/* We clean up fbuf below. */
 			name_type = NORMAL_NAME;
@@ -1847,23 +1925,23 @@
 			} else {
 				if (len + 1 >= MAXPATHLEN)
 					overflow_exit("send_file_list");
 				fbuf[len++] = '.';
 				fbuf[len] = '\0';
 			}
-			name_type = DOT_NAME;
+			name_type = DOTDIR_NAME;
 		} else if (len > 1 && fbuf[len-1] == '.' && fbuf[len-2] == '.'
 		    && (len == 2 || fbuf[len-3] == '/')) {
 			if (len + 2 >= MAXPATHLEN)
 				overflow_exit("send_file_list");
 			fbuf[len++] = '/';
 			fbuf[len++] = '.';
 			fbuf[len] = '\0';
-			name_type = DOT_NAME;
+			name_type = DOTDIR_NAME;
 		} else if (fbuf[len-1] == '.' && (len == 1 || fbuf[len-2] == '/'))
-			name_type = DOT_NAME;
+			name_type = DOTDIR_NAME;
 		else
 			name_type = NORMAL_NAME;
 
 		dir = NULL;
 
 		if (!relative_paths) {
@@ -1880,35 +1958,44 @@
 				fn = fbuf;
 		} else {
 			if ((p = strstr(fbuf, "/./")) != NULL) {
 				*p = '\0';
 				if (p == fbuf)
 					dir = "/";
-				else
+				else {
 					dir = fbuf;
+					clean_fname(dir, 0);
+				}
 				fn = p + 3;
 				while (*fn == '/')
 					fn++;
 				if (!*fn)
 					*--fn = '\0'; /* ensure room for '.' */
 			} else
 				fn = fbuf;
-			len = clean_fname(fn, CFN_KEEP_LEADING_DOT_DIR
-					    | CFN_KEEP_TRAILING_SLASH
+			/* A leading ./ can be used in relative mode to affect
+			 * the dest dir without its name being in the path. */
+			if (*fn == '.' && fn[1] == '/' && !implied_dot_dir) {
+				send_file_name(f, flist, ".", NULL,
+				    (flags | FLAG_IMPLIED_DIR) & ~FLAG_CONTENT_DIR,
+				    ALL_FILTERS);
+				implied_dot_dir = 1;
+			}
+			len = clean_fname(fn, CFN_KEEP_TRAILING_SLASH
 					    | CFN_DROP_TRAILING_DOT_DIR);
 			if (len == 1) {
 				if (fn[0] == '/') {
 					fn = "/.";
 					len = 2;
-					name_type = DOT_NAME;
+					name_type = DOTDIR_NAME;
 				} else if (fn[0] == '.')
-					name_type = DOT_NAME;
+					name_type = DOTDIR_NAME;
 			} else if (fn[len-1] == '/') {
 				fn[--len] = '\0';
 				if (len == 1 && *fn == '.')
-					name_type = DOT_NAME;
+					name_type = DOTDIR_NAME;
 				else
 					name_type = SLASH_ENDING_NAME;
 			}
 			/* Reject a ".." dir in the active part of the path. */
 			for (p = fn; (p = strstr(p, "..")) != NULL; p += 2) {
 				if ((p[2] == '/' || p[2] == '\0')
@@ -1921,28 +2008,30 @@
 			}
 		}
 
 		if (!*fn) {
 			len = 1;
 			fn = ".";
-			name_type = DOT_NAME;
+			name_type = DOTDIR_NAME;
 		}
 
 		dirlen = dir ? strlen(dir) : 0;
 		if (dirlen != lastdir_len || memcmp(lastdir, dir, dirlen) != 0) {
-			if (!push_pathname(dir ? strdup(dir) : NULL, dirlen))
+			if (!change_pathname(NULL, dir, -dirlen))
 				continue;
 			lastdir = pathname;
 			lastdir_len = pathname_len;
-		} else if (!push_pathname(lastdir, lastdir_len))
+		} else if (!change_pathname(NULL, lastdir, lastdir_len))
 			continue;
 
 		if (fn != fbuf)
 			memmove(fbuf, fn, len + 1);
 
-		if (link_stat(fbuf, &st, copy_dirlinks || name_type != NORMAL_NAME) != 0) {
+		if (link_stat(fbuf, &st, copy_dirlinks || name_type != NORMAL_NAME) != 0
+		 || (name_type != DOTDIR_NAME && is_daemon_excluded(fbuf, S_ISDIR(st.st_mode)))
+		 || (relative_paths && path_is_daemon_excluded(fbuf, 1))) {
 			io_error |= IOERR_GENERAL;
 			rsyserr(FERROR_XFER, errno, "link_stat %s failed",
 				full_fname(fbuf));
 			continue;
 		}
 
@@ -1962,45 +2051,39 @@
 				if (fn == p)
 					continue;
 			}
 		} else if (implied_dirs && (p=strrchr(fbuf,'/')) && p != fbuf) {
 			/* Send the implied directories at the start of the
 			 * source spec, so we get their permissions right. */
-			char *lp = lastpath, *slash = fbuf;
-			*p = '\0';
-			/* Skip any initial directories in our path that we
-			 * have in common with lastpath. */
-			for (fn = fbuf; *fn && *lp == *fn; lp++, fn++) {
-				if (*fn == '/')
-					slash = fn;
-			}
-			*p = '/';
-			if (fn != p || (*lp && *lp != '/'))
-				send_implied_dirs(f, flist, fbuf, slash, p, flags, 0);
+			send_implied_dirs(f, flist, fbuf, fbuf, p, flags, 0);
 		}
 
 		if (one_file_system)
 			filesystem_dev = st.st_dev;
 
+		arg_flags = name_type == DOTDIR_NAME ? FLAG_DOTDIR_NAME : 0;
+
 		if (recurse || (xfer_dirs && name_type != NORMAL_NAME)) {
 			struct file_struct *file;
-			int top_flags = FLAG_TOP_DIR | FLAG_CONTENT_DIR | flags;
+			arg_flags |= FLAG_TOP_DIR | FLAG_CONTENT_DIR;
 			file = send_file_name(f, flist, fbuf, &st,
-					      top_flags, ALL_FILTERS);
+					      arg_flags | flags, ALL_FILTERS);
+			if (!file)
+				continue;
 			if (inc_recurse) {
-				if (name_type == DOT_NAME && file) {
+				if (name_type == DOTDIR_NAME) {
 					if (send_dir_depth < 0) {
 						send_dir_depth = 0;
 						change_local_filter_dir(fbuf, len, send_dir_depth);
 					}
 					send_directory(f, flist, fbuf, len, flags);
 				}
-			} else if (file)
+			} else
 				send_if_directory(f, flist, file, fbuf, len, flags);
 		} else
-			send_file_name(f, flist, fbuf, &st, flags, ALL_FILTERS);
+			send_file_name(f, flist, fbuf, &st, arg_flags | flags, ALL_FILTERS);
 	}
 
 	gettimeofday(&end_tv, NULL);
 	stats.flist_buildtime = (int64)(end_tv.tv_sec - start_tv.tv_sec) * 1000
 			      + (end_tv.tv_usec - start_tv.tv_usec) / 1000;
 	if (stats.flist_buildtime == 0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/generator.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/generator.c	2008-03-29 01:30:11.000000000 +0800
@@ -24,13 +24,12 @@
 
 extern int verbose;
 extern int dry_run;
 extern int do_xfers;
 extern int stdout_format_has_i;
 extern int logfile_format_has_i;
-extern int receiver_symlink_times;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
 extern int inc_recurse;
 extern int do_progress;
 extern int relative_paths;
@@ -95,25 +94,26 @@
 extern mode_t orig_umask;
 extern uid_t our_uid;
 extern char *backup_dir;
 extern char *backup_suffix;
 extern int backup_suffix_len;
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
-extern struct filter_list_struct server_filter_list;
+extern struct filter_list_struct daemon_filter_list;
 
 int ignore_perishable = 0;
 int non_perishable_cnt = 0;
 int maybe_ATTRS_REPORT = 0;
 
 static dev_t dev_zero;
 static int deletion_count = 0; /* used to implement --max-delete */
 static int deldelay_size = 0, deldelay_cnt = 0;
 static char *deldelay_buf = NULL;
 static int deldelay_fd = -1;
 static int lull_mod;
 static int dir_tweaking;
+static int symlink_timeset_failed_flags;
 static int need_retouch_dir_times;
 static int need_retouch_dir_perms;
 static const char *solo_file = NULL;
 
 /* For calling delete_item() and delete_dir_contents(). */
 #define DEL_NO_UID_WRITE 	(1<<0) /* file/dir has our uid w/o write perm */
@@ -132,14 +132,18 @@
 };
 
 enum delret {
     DR_SUCCESS = 0, DR_FAILURE, DR_AT_LIMIT, DR_NOT_EMPTY
 };
 
-/* Forward declaration for delete_item(). */
+/* Forward declarations. */
 static enum delret delete_dir_contents(char *fname, uint16 flags);
+#ifdef SUPPORT_HARD_LINKS
+static void handle_skipped_hlink(struct file_struct *file, int itemizing,
+				 enum logcode code, int f_out);
+#endif
 
 static int is_backup_file(char *fn)
 {
 	int k = strlen(fn) - backup_suffix_len;
 	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
 }
@@ -276,13 +280,13 @@
 	flags = (flags & ~(DEL_RECURSE|DEL_MAKE_ROOM|DEL_NO_UID_WRITE))
 	      | DEL_DIR_IS_EMPTY;
 
 	for (j = dirlist->used; j--; ) {
 		struct file_struct *fp = dirlist->files[j];
 
-		if (fp->flags & FLAG_MOUNT_DIR) {
+		if (fp->flags & FLAG_MOUNT_DIR && S_ISDIR(fp->mode)) {
 			if (verbose > 1) {
 				rprintf(FINFO,
 				    "mount point, %s, pins parent directory\n",
 				    f_name(fp, NULL));
 			}
 			ret = DR_NOT_EMPTY;
@@ -508,13 +512,13 @@
 	/* If an item in dirlist is not found in flist, delete it
 	 * from the filesystem. */
 	for (i = dirlist->used; i--; ) {
 		struct file_struct *fp = dirlist->files[i];
 		if (!F_IS_ACTIVE(fp))
 			continue;
-		if (fp->flags & FLAG_MOUNT_DIR) {
+		if (fp->flags & FLAG_MOUNT_DIR && S_ISDIR(fp->mode)) {
 			if (verbose > 1)
 				rprintf(FINFO, "cannot delete mount point: %s\n",
 					f_name(fp, NULL));
 			continue;
 		}
 		if (flist_find(cur_flist, fp) < 0) {
@@ -550,16 +554,19 @@
 	if (dry_run > 1 || list_only)
 		return;
 
 	for (j = 0; j < cur_flist->used; j++) {
 		struct file_struct *file = cur_flist->sorted[j];
 
-		if (!(file->flags & FLAG_CONTENT_DIR))
+		f_name(file, fbuf);
+
+		if (!(file->flags & FLAG_CONTENT_DIR)) {
+			change_local_filter_dir(fbuf, strlen(fbuf), F_DEPTH(file));
 			continue;
+		}
 
-		f_name(file, fbuf);
 		if (verbose > 1 && file->flags & FLAG_TOP_DIR)
 			rprintf(FINFO, "deleting in %s\n", fbuf);
 
 		if (link_stat(fbuf, &st, keep_dirlinks) < 0
 		 || !S_ISDIR(st.st_mode))
 			continue;
@@ -579,16 +586,17 @@
 		;
 	} else
 #endif
 	if (preserve_times && cmp_time(sxp->st.st_mtime, file->modtime) != 0)
 		return 0;
 
-	if (preserve_perms && !BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))
-		return 0;
-
-	if (preserve_executability && ((sxp->st.st_mode & 0111 ? 1 : 0) ^ (file->mode & 0111 ? 1 : 0)))
+	if (preserve_perms) {
+		if (!BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))
+			return 0;
+	} else if (preserve_executability
+	 && ((sxp->st.st_mode & 0111 ? 1 : 0) ^ (file->mode & 0111 ? 1 : 0)))
 		return 0;
 
 	if (am_root && uid_ndx && sxp->st.st_uid != (uid_t)F_OWNER(file))
 		return 0;
 
 	if (gid_ndx && !(file->flags & FLAG_SKIP_GROUP) && sxp->st.st_gid != (gid_t)F_GROUP(file))
@@ -619,30 +627,37 @@
 	     const char *xname)
 {
 	if (statret >= 0) { /* A from-dest-dir statret can == 1! */
 		int keep_time = !preserve_times ? 0
 		    : S_ISDIR(file->mode) ? preserve_times > 1 :
 #if defined HAVE_LUTIMES && defined HAVE_UTIMES
-		    (receiver_symlink_times && !(file->flags & FLAG_TIME_FAILED)) ||
-#endif
+		    1;
+#else
 		    !S_ISLNK(file->mode);
+#endif
 
 		if (S_ISREG(file->mode) && F_LENGTH(file) != sxp->st.st_size)
 			iflags |= ITEM_REPORT_SIZE;
-		if ((iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !keep_time
-		  && !(iflags & ITEM_MATCHED)
+		if (file->flags & FLAG_TIME_FAILED) { /* symlinks only */
+			if (iflags & ITEM_LOCAL_CHANGE)
+				iflags |= symlink_timeset_failed_flags;
+		} else if (keep_time
+		 ? cmp_time(file->modtime, sxp->st.st_mtime) != 0
+		 : iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !(iflags & ITEM_MATCHED)
 		  && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
-		 || (keep_time && cmp_time(file->modtime, sxp->st.st_mtime) != 0))
 			iflags |= ITEM_REPORT_TIME;
 #if !defined HAVE_LCHMOD && !defined HAVE_SETATTRLIST
 		if (S_ISLNK(file->mode)) {
 			;
 		} else
 #endif
-		if ((preserve_perms || preserve_executability)
-		 && !BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))
+		if (preserve_perms) {
+			if (!BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))
+				iflags |= ITEM_REPORT_PERMS;
+		} else if (preserve_executability
+		 && ((sxp->st.st_mode & 0111 ? 1 : 0) ^ (file->mode & 0111 ? 1 : 0)))
 			iflags |= ITEM_REPORT_PERMS;
 		if (uid_ndx && am_root && (uid_t)F_OWNER(file) != sxp->st.st_uid)
 			iflags |= ITEM_REPORT_OWNER;
 		if (gid_ndx && !(file->flags & FLAG_SKIP_GROUP)
 		    && sxp->st.st_gid != (gid_t)F_GROUP(file))
 			iflags |= ITEM_REPORT_GROUP;
@@ -1152,14 +1167,13 @@
 		} else
 #endif
 			match_level = 2;
 		if (itemizing && stdout_format_has_i
 		 && (verbose > 1 || stdout_format_has_i > 1)) {
 			int chg = compare_dest && type != TYPE_DIR ? 0
-			    : ITEM_LOCAL_CHANGE
-			     + (match_level == 3 ? ITEM_XNAME_FOLLOWS : 0);
+			    : ITEM_LOCAL_CHANGE + (match_level == 3 ? ITEM_XNAME_FOLLOWS : 0);
 			char *lp = match_level == 3 ? "" : NULL;
 			itemize(cmpbuf, file, ndx, 0, sxp, chg + ITEM_MATCHED, 0, lp);
 		}
 		if (verbose > 1 && maybe_ATTRS_REPORT) {
 			rprintf(FCLIENT, "%s%s is uptodate\n",
 				fname, type == TYPE_DIR ? "/" : "");
@@ -1199,40 +1213,51 @@
 	}
 }
 
 static int phase = 0;
 static int dflt_perms;
 
+static int implied_dirs_are_missing;
+/* Helper for recv_generator's skip_dir and dry_missing_dir tests. */
+static BOOL is_below(struct file_struct *file, struct file_struct *subtree)
+{
+	return F_DEPTH(file) > F_DEPTH(subtree)
+		&& (!implied_dirs_are_missing || f_name_has_prefix(file, subtree));
+}
+
 /* Acts on the indicated item in cur_flist whose name is fname.  If a dir,
  * make sure it exists, and has the right permissions/timestamp info.  For
  * all other non-regular files (symlinks, etc.) we create them here.  For
  * regular files that have changed, we try to find a basis file and then
  * start sending checksums.  The ndx is the file's unique index value.
  *
- * When fname is non-null, it must point to a MAXPATHLEN buffer!
+ * The fname parameter must point to a MAXPATHLEN buffer!  (e.g it gets
+ * passed to delete_item(), which can use it during a recursive delete.)
  *
  * Note that f_out is set to -1 when doing final directory-permission and
  * modification-time repair. */
 static void recv_generator(char *fname, struct file_struct *file, int ndx,
 			   int itemizing, enum logcode code, int f_out)
 {
-	static int missing_below = -1, excluded_below = -1;
 	static const char *parent_dirname = "";
-	static struct file_struct *missing_dir = NULL, *excluded_dir = NULL;
+	/* Missing dir not created due to --dry-run; will still be scanned. */
+	static struct file_struct *dry_missing_dir = NULL;
+	/* Missing dir whose contents are skipped altogether due to
+	 * --ignore-non-existing, daemon exclude, or mkdir failure. */
+	static struct file_struct *skip_dir = NULL;
 	static struct file_list *fuzzy_dirlist = NULL;
 	static int need_fuzzy_dirlist = 0;
 	struct file_struct *fuzzy_file = NULL;
 	int fd = -1, f_copy = -1;
 	stat_x sx, real_sx;
 	STRUCT_STAT partial_st;
 	struct file_struct *back_file = NULL;
 	int statret, real_ret, stat_errno;
 	char *fnamecmp, *partialptr, *backupptr = NULL;
 	char fnamecmpbuf[MAXPATHLEN];
 	uchar fnamecmp_type;
-	int implied_dirs_are_missing = relative_paths && !implied_dirs && protocol_version < 30;
 	int del_opts = delete_mode || force_delete ? DEL_RECURSE : 0;
 	int is_dir = !S_ISDIR(file->mode) ? 0
 		   : inc_recurse && ndx != cur_flist->ndx_start - 1 ? -1
 		   : 1;
 
 	if (verbose > 2)
@@ -1243,47 +1268,42 @@
 		 || (is_dir && !implied_dirs && file->flags & FLAG_IMPLIED_DIR))
 			return;
 		list_file_entry(file);
 		return;
 	}
 
-	if (server_filter_list.head) {
-		int filtered = check_filter(&server_filter_list, fname, is_dir) < 0;
-		if (is_dir < 0 && filtered)
-			return;
-		if (excluded_below >= 0) {
-			if (F_DEPTH(file) > excluded_below
-			 && (!implied_dirs_are_missing || f_name_has_prefix(file, excluded_dir)))
-				goto skipping;
-			excluded_below = -1;
-		}
-		if (filtered) {
-			if (is_dir) {
-				excluded_below = F_DEPTH(file);
-				excluded_dir = file;
-			}
-		  skipping:
-			rprintf(FERROR_XFER,
-				"skipping daemon-excluded file \"%s\"\n",
-				fname);
+	if (skip_dir) {
+		if (is_below(file, skip_dir)) {
+			if (is_dir)
+				file->flags |= FLAG_MISSING_DIR;
+#ifdef SUPPORT_HARD_LINKS
+			else if (F_IS_HLINKED(file))
+				handle_skipped_hlink(file, itemizing, code, f_out);
+#endif
 			return;
 		}
+		skip_dir = NULL;
 	}
 
-	if (missing_below >= 0) {
-		if (F_DEPTH(file) <= missing_below
-		 || (implied_dirs_are_missing && !f_name_has_prefix(file, missing_dir))) {
-			if (dry_run)
-				dry_run--;
-			missing_below = -1;
-		} else if (!dry_run) {
+	if (daemon_filter_list.head) {
+		if (check_filter(&daemon_filter_list, FLOG, fname, is_dir) < 0) {
+			if (is_dir < 0)
+				return;
+#ifdef SUPPORT_HARD_LINKS
+			if (F_IS_HLINKED(file))
+				handle_skipped_hlink(file, itemizing, code, f_out);
+#endif
+			rprintf(FERROR_XFER,
+				"skipping daemon-excluded %s \"%s\"\n",
+				is_dir ? "directory" : "file", fname);
 			if (is_dir)
-				file->flags |= FLAG_MISSING_DIR;
+				goto skipping_dir_contents;
 			return;
 		}
 	}
+
 #ifdef SUPPORT_ACLS
 	sx.acc_acl = sx.def_acl = NULL;
 #endif
 #ifdef SUPPORT_XATTRS
 	sx.xattr = NULL;
 #endif
@@ -1284,29 +1304,34 @@
 #ifdef SUPPORT_ACLS
 	sx.acc_acl = sx.def_acl = NULL;
 #endif
 #ifdef SUPPORT_XATTRS
 	sx.xattr = NULL;
 #endif
-	if (dry_run > 1) {
+	if (dry_run > 1 || (dry_missing_dir && is_below(file, dry_missing_dir))) {
+	  parent_is_dry_missing:
 		if (fuzzy_dirlist) {
 			flist_free(fuzzy_dirlist);
 			fuzzy_dirlist = NULL;
 		}
 		parent_dirname = "";
 		statret = -1;
 		stat_errno = ENOENT;
 	} else {
 		const char *dn = file->dirname ? file->dirname : ".";
+		dry_missing_dir = NULL;
 		if (parent_dirname != dn && strcmp(parent_dirname, dn) != 0) {
 			if (relative_paths && !implied_dirs
-			 && do_stat(dn, &sx.st) < 0
-			 && create_directory_path(fname) < 0) {
-				rsyserr(FERROR_XFER, errno,
-					"recv_generator: mkdir %s failed",
-					full_fname(dn));
+			 && do_stat(dn, &sx.st) < 0) {
+				if (dry_run)
+					goto parent_is_dry_missing;
+				if (create_directory_path(fname) < 0) {
+					rsyserr(FERROR_XFER, errno,
+						"recv_generator: mkdir %s failed",
+						full_fname(dn));
+				}
 			}
 			if (fuzzy_dirlist) {
 				flist_free(fuzzy_dirlist);
 				fuzzy_dirlist = NULL;
 			}
 			if (fuzzy_basis)
@@ -1329,31 +1354,41 @@
 	}
 
 	if (ignore_non_existing > 0 && statret == -1 && stat_errno == ENOENT) {
 		if (is_dir) {
 			if (is_dir < 0)
 				return;
-			if (missing_below < 0) {
-				if (dry_run)
-					dry_run++;
-				missing_below = F_DEPTH(file);
-				missing_dir = file;
-			}
+			skip_dir = file;
 			file->flags |= FLAG_MISSING_DIR;
 		}
+#ifdef SUPPORT_HARD_LINKS
+		else if (F_IS_HLINKED(file))
+			handle_skipped_hlink(file, itemizing, code, f_out);
+#endif
 		if (verbose > 1) {
 			rprintf(FINFO, "not creating new %s \"%s\"\n",
 				is_dir ? "directory" : "file", fname);
 		}
 		return;
 	}
 
 	if (statret == 0 && !(sx.st.st_mode & S_IWUSR)
 	 && !am_root && sx.st.st_uid == our_uid)
 		del_opts |= DEL_NO_UID_WRITE;
 
+	if (ignore_existing > 0 && statret == 0
+	 && (!is_dir || !S_ISDIR(sx.st.st_mode))) {
+		if (verbose > 1 && is_dir >= 0)
+			rprintf(FINFO, "%s exists\n", fname);
+#ifdef SUPPORT_HARD_LINKS
+		if (F_IS_HLINKED(file))
+			handle_skipped_hlink(file, itemizing, code, f_out);
+#endif
+		goto cleanup;
+	}
+
 	if (is_dir) {
 		if (!implied_dirs && file->flags & FLAG_IMPLIED_DIR)
 			goto cleanup;
 		if (is_dir < 0) {
 			/* In inc_recurse mode we want to make sure any missing
 			 * directories get created while we're still processing
@@ -1375,16 +1410,16 @@
 		 * (perhaps recursively) create it. */
 		if (statret == 0 && !S_ISDIR(sx.st.st_mode)) {
 			if (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_DIR) != 0)
 				goto skipping_dir_contents;
 			statret = -1;
 		}
-		if (dry_run && statret != 0 && missing_below < 0) {
-			missing_below = F_DEPTH(file);
-			missing_dir = file;
-			dry_run++;
+		if (dry_run && statret != 0) {
+			if (!dry_missing_dir)
+				dry_missing_dir = file;
+			file->flags |= FLAG_MISSING_DIR;
 		}
 		real_ret = statret;
 		real_sx = sx;
 		if (file->flags & FLAG_DIR_CREATED)
 			statret = -1;
 		if (!preserve_perms) { /* See comment in non-dir code below. */
@@ -1411,14 +1446,13 @@
 				rsyserr(FERROR_XFER, errno,
 					"recv_generator: mkdir %s failed",
 					full_fname(fname));
 			  skipping_dir_contents:
 				rprintf(FERROR,
 				    "*** Skipping any contents from this failed directory ***\n");
-				missing_below = F_DEPTH(file);
-				missing_dir = file;
+				skip_dir = file;
 				file->flags |= FLAG_MISSING_DIR;
 				goto cleanup;
 			}
 		}
 		if (set_file_attrs(fname, file, real_ret ? NULL : &real_sx, NULL, 0)
 		    && verbose && code != FNONE && f_out != -1)
@@ -1445,15 +1479,19 @@
 			if (one_file_system) {
 				uint32 *devp = F_DIR_DEV_P(file);
 				DEV_MAJOR(devp) = major(real_sx.st.st_dev);
 				DEV_MINOR(devp) = minor(real_sx.st.st_dev);
 			}
 		}
-		else if (delete_during && f_out != -1 && !phase && dry_run < 2
-		    && (file->flags & FLAG_CONTENT_DIR))
-			delete_in_dir(fname, file, &real_sx.st.st_dev);
+		else if (delete_during && f_out != -1 && !phase
+		    && !(file->flags & FLAG_MISSING_DIR)) {
+			if (file->flags & FLAG_CONTENT_DIR)
+				delete_in_dir(fname, file, &real_sx.st.st_dev);
+			else
+				change_local_filter_dir(fname, strlen(fname), F_DEPTH(file));
+		}
 		goto cleanup;
 	}
 
 	/* If we're not preserving permissions, change the file-list's
 	 * mode based on the local permissions and some heuristics. */
 	if (!preserve_perms) {
@@ -1531,13 +1569,13 @@
 			rsyserr(FERROR_XFER, errno, "symlink %s -> \"%s\" failed",
 				full_fname(fname), sl);
 		} else {
 			set_file_attrs(fname, file, NULL, NULL, 0);
 			if (itemizing) {
 				itemize(fname, file, ndx, statret, &sx,
-					ITEM_LOCAL_CHANGE, 0, NULL);
+					ITEM_LOCAL_CHANGE|ITEM_REPORT_CHANGE, 0, NULL);
 			}
 			if (code != FNONE && verbose)
 				rprintf(code, "%s -> %s\n", fname, sl);
 #ifdef SUPPORT_HARD_LINKS
 			if (preserve_hard_links && F_IS_HLINKED(file))
 				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
@@ -1615,13 +1653,13 @@
 			rsyserr(FERROR_XFER, errno, "mknod %s failed",
 				full_fname(fname));
 		} else {
 			set_file_attrs(fname, file, NULL, NULL, 0);
 			if (itemizing) {
 				itemize(fname, file, ndx, statret, &sx,
-					ITEM_LOCAL_CHANGE, 0, NULL);
+					ITEM_LOCAL_CHANGE|ITEM_REPORT_CHANGE, 0, NULL);
 			}
 			if (code != FNONE && verbose)
 				rprintf(code, "%s\n", fname);
 #ifdef SUPPORT_HARD_LINKS
 			if (preserve_hard_links && F_IS_HLINKED(file))
 				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
@@ -1653,22 +1691,20 @@
 				fname = f_name(file, NULL);
 			rprintf(FINFO, "%s is under min-size\n", fname);
 		}
 		goto cleanup;
 	}
 
-	if (ignore_existing > 0 && statret == 0) {
-		if (verbose > 1)
-			rprintf(FINFO, "%s exists\n", fname);
-		goto cleanup;
-	}
-
 	if (update_only > 0 && statret == 0
 	    && cmp_time(sx.st.st_mtime, file->modtime) > 0) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s is newer\n", fname);
+#ifdef SUPPORT_HARD_LINKS
+		if (F_IS_HLINKED(file))
+			handle_skipped_hlink(file, itemizing, code, f_out);
+#endif
 		goto cleanup;
 	}
 
 	fnamecmp = fname;
 	fnamecmp_type = FNAMECMP_FNAME;
 
@@ -1702,13 +1738,13 @@
 	    && S_ISREG(partial_st.st_mode)) {
 		if (statret != 0)
 			goto prepare_to_open;
 	} else
 		partialptr = NULL;
 
-	if (statret != 0 && fuzzy_dirlist && dry_run <= 1) {
+	if (statret != 0 && fuzzy_dirlist) {
 		int j = find_fuzzy(file, fuzzy_dirlist);
 		if (j >= 0) {
 			fuzzy_file = fuzzy_dirlist->files[j];
 			f_name(fuzzy_file, fnamecmpbuf);
 			if (verbose > 2) {
 				rprintf(FINFO, "fuzzy basis selected for %s: %s\n",
@@ -1732,15 +1768,12 @@
 			goto notify_others;
 		rsyserr(FERROR_XFER, stat_errno, "recv_generator: failed to stat %s",
 			full_fname(fname));
 		goto cleanup;
 	}
 
-	if (append_mode > 0 && sx.st.st_size >= F_LENGTH(file))
-		goto cleanup;
-
 	if (fnamecmp_type <= FNAMECMP_BASIS_DIR_HIGH)
 		;
 	else if (fnamecmp_type == FNAMECMP_FUZZY)
 		;
 	else if (unchanged_file(fnamecmp, file, &sx.st)) {
 		if (partialptr) {
@@ -1759,12 +1792,20 @@
 	  return_with_success:
 		if (!dry_run)
 			send_msg_int(MSG_SUCCESS, ndx);
 		goto cleanup;
 	}
 
+	if (append_mode > 0 && sx.st.st_size >= F_LENGTH(file)) {
+#ifdef SUPPORT_HARD_LINKS
+		if (F_IS_HLINKED(file))
+			handle_skipped_hlink(file, itemizing, code, f_out);
+#endif
+		goto cleanup;
+	}
+
   prepare_to_open:
 	if (partialptr) {
 		sx.st = partial_st;
 		fnamecmp = partialptr;
 		fnamecmp_type = FNAMECMP_PARTIAL_DIR;
 		statret = 0;
@@ -1846,25 +1887,25 @@
 	}
 
 	if (verbose > 2)
 		rprintf(FINFO, "generating and sending sums for %d\n", ndx);
 
   notify_others:
-	if (remove_source_files && !delay_updates && !phase)
+	if (remove_source_files && !delay_updates && !phase && !dry_run)
 		increment_active_files(ndx, itemizing, code);
 	if (inc_recurse && !dry_run)
 		cur_flist->in_progress++;
 #ifdef SUPPORT_HARD_LINKS
 	if (preserve_hard_links && F_IS_HLINKED(file))
 		file->flags |= FLAG_FILE_SENT;
 #endif
 	write_ndx(f_out, ndx);
 	if (itemizing) {
 		int iflags = ITEM_TRANSFER;
 		if (always_checksum > 0)
-			iflags |= ITEM_REPORT_CHECKSUM;
+			iflags |= ITEM_REPORT_CHANGE;
 		if (fnamecmp_type != FNAMECMP_FNAME)
 			iflags |= ITEM_BASIS_TYPE_FOLLOWS;
 		if (fnamecmp_type == FNAMECMP_FUZZY)
 			iflags |= ITEM_XNAME_FOLLOWS;
 		itemize(fnamecmp, file, -1, real_ret, &real_sx, iflags, fnamecmp_type,
 			fuzzy_file ? fuzzy_file->basename : NULL);
@@ -1915,12 +1956,34 @@
 	if (preserve_xattrs)
 		free_xattr(&sx);
 #endif
 	return;
 }
 
+#ifdef SUPPORT_HARD_LINKS
+static void handle_skipped_hlink(struct file_struct *file, int itemizing,
+				 enum logcode code, int f_out)
+{
+	char fbuf[MAXPATHLEN];
+	int new_last_ndx;
+	struct file_list *save_flist = cur_flist;
+
+	/* If we skip the last item in a chain of links and there was a
+	 * prior non-skipped hard-link waiting to finish, finish it now. */
+	if ((new_last_ndx = skip_hard_link(file, &cur_flist)) < 0)
+		return;
+
+	file = cur_flist->files[new_last_ndx - cur_flist->ndx_start];
+	cur_flist->in_progress--; /* undo prior increment */
+	f_name(file, fbuf);
+	recv_generator(fbuf, file, new_last_ndx, itemizing, code, f_out);
+
+	cur_flist = save_flist;
+}
+#endif
+
 static void touch_up_dirs(struct file_list *flist, int ndx)
 {
 	static int counter = 0;
 	struct file_struct *file;
 	char *fname;
 	int i, start, end;
@@ -1946,14 +2009,18 @@
 		if (!F_IS_ACTIVE(file) || file->flags & FLAG_MISSING_DIR
 		 || (!need_retouch_dir_times && file->mode & S_IWUSR))
 			continue;
 		fname = f_name(file, NULL);
 		if (!(file->mode & S_IWUSR))
 			do_chmod(fname, file->mode);
-		if (need_retouch_dir_times)
-			set_modtime(fname, file->modtime, file->mode);
+		if (need_retouch_dir_times) {
+			STRUCT_STAT st;
+			if (link_stat(fname, &st, 0) == 0
+			 && cmp_time(st.st_mtime, file->modtime) != 0)
+				set_modtime(fname, file->modtime, file->mode);
+		}
 		if (allowed_lull && !(counter % lull_mod))
 			maybe_send_keepalive();
 		else if (!(counter & 0xFF))
 			maybe_flush_socket(0);
 	}
 }
@@ -2065,12 +2132,15 @@
 		code = FINFO;
 	}
 	solo_file = local_name;
 	dir_tweaking = !(list_only || solo_file || dry_run);
 	need_retouch_dir_times = preserve_times > 1;
 	lull_mod = allowed_lull * 5;
+	symlink_timeset_failed_flags = ITEM_REPORT_TIME
+	    | (protocol_version >= 30 || !am_server ? ITEM_REPORT_TIMEFAIL : 0);
+	implied_dirs_are_missing = relative_paths && !implied_dirs && protocol_version < 30;
 
 	if (verbose > 2)
 		rprintf(FINFO, "generator starting pid=%ld\n", (long)getpid());
 
 	if (delete_before && !solo_file && cur_flist->used > 0)
 		do_delete_pass();
@@ -2109,22 +2179,24 @@
 
 		if (inc_recurse && cur_flist->parent_ndx >= 0) {
 			struct file_struct *fp = dir_flist->files[cur_flist->parent_ndx];
 			f_name(fp, fbuf);
 			ndx = cur_flist->ndx_start - 1;
 			recv_generator(fbuf, fp, ndx, itemizing, code, f_out);
-			if (delete_during && dry_run < 2 && !list_only) {
-				if (BITS_SETnUNSET(fp->flags, FLAG_CONTENT_DIR, FLAG_MISSING_DIR)) {
+			if (delete_during && dry_run < 2 && !list_only
+			 && !(fp->flags & FLAG_MISSING_DIR)) {
+				if (fp->flags & FLAG_CONTENT_DIR) {
 					dev_t dirdev;
 					if (one_file_system) {
 						uint32 *devp = F_DIR_DEV_P(fp);
 						dirdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
 					} else
 						dirdev = MAKEDEV(0, 0);
-					delete_in_dir(f_name(fp, fbuf), fp, &dirdev);
-				}
+					delete_in_dir(fbuf, fp, &dirdev);
+				} else
+					change_local_filter_dir(fbuf, strlen(fbuf), F_DEPTH(fp));
 			}
 		}
 		for (i = cur_flist->low; i <= cur_flist->high; i++) {
 			struct file_struct *file = cur_flist->sorted[i];
 
 			if (!F_IS_ACTIVE(file))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/hlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/hlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/hlink.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/hlink.c	2008-03-27 07:12:39.000000000 +0800
@@ -122,18 +122,22 @@
 				node->data = new_array0(char, 5);
 				assert(gnum >= hlink_flist->ndx_start);
 				file->flags |= FLAG_HLINK_FIRST;
 				prev = -1;
 			} else if (CVAL(node->data, 0) == 0) {
 				struct file_list *flist;
-				struct file_struct *fp;
 				prev = IVAL(node->data, 1);
 				flist = flist_for_ndx(prev);
-				assert(flist != NULL);
-				fp = flist->files[prev - flist->ndx_start];
-				fp->flags &= ~FLAG_HLINK_LAST;
+				if (flist)
+					flist->files[prev - flist->ndx_start]->flags &= ~FLAG_HLINK_LAST;
+				else {
+					/* We skipped all prior files in this
+					 * group, so mark this as a "first". */
+					file->flags |= FLAG_HLINK_FIRST;
+					prev = -1;
+				}
 			} else
 				prev = -1;
 		} else {
 			file->flags |= FLAG_HLINK_FIRST;
 			prev = -1;
 		}
@@ -237,27 +241,48 @@
 		return 0;
 	}
 	return -1;
 }
 
 /* Figure out if a prior entry is still there or if we just have a
- * cached name for it.  Never called with a FLAG_HLINK_FIRST entry. */
-static char *check_prior(int prev_ndx, int gnum, struct file_list **flist_p)
+ * cached name for it. */
+static char *check_prior(struct file_struct *file, int gnum,
+			 int *prev_ndx_p, struct file_list **flist_p)
 {
-	struct file_list *flist = flist_for_ndx(prev_ndx);
+	struct file_struct *fp;
 	struct ht_int32_node *node;
+	int prev_ndx = F_HL_PREV(file);
 
-	if (flist) {
-		*flist_p = flist;
-		return NULL;
-	}
-
-	node = hashtable_find(prior_hlinks, gnum, 0);
-	assert(node != NULL && node->data);
-	assert(CVAL(node->data, 0) != 0);
-	return node->data;
+	while (1) {
+		struct file_list *flist;
+		if (prev_ndx < 0
+		 || (flist = flist_for_ndx(prev_ndx)) == NULL)
+			break;
+		fp = flist->files[prev_ndx - flist->ndx_start];
+		if (!(fp->flags & FLAG_SKIP_HLINK)) {
+			*prev_ndx_p = prev_ndx;
+			*flist_p = flist;
+			return NULL;
+		}
+		F_HL_PREV(file) = prev_ndx = F_HL_PREV(fp);
+	}
+
+	if ((node = hashtable_find(prior_hlinks, gnum, 0)) != NULL) {
+		assert(node->data != NULL);
+		if (CVAL(node->data, 0) != 0) {
+			*prev_ndx_p = -1;
+			*flist_p = NULL;
+			return node->data;
+		}
+		/* The prior file must have been skipped. */
+		F_HL_PREV(file) = -1;
+	}
+
+	*prev_ndx_p = -1;
+	*flist_p = NULL;
+	return NULL;
 }
 
 /* Only called if FLAG_HLINKED is set and FLAG_HLINK_FIRST is not.  Returns:
  * 0 = process the file, 1 = skip the file, -1 = error occurred. */
 int hard_link_check(struct file_struct *file, int ndx, const char *fname,
 		    int statret, stat_x *sxp, int itemizing,
@@ -265,18 +290,26 @@
 {
 	STRUCT_STAT prev_st;
 	char namebuf[MAXPATHLEN], altbuf[MAXPATHLEN];
 	char *realname, *prev_name;
 	struct file_list *flist;
 	int gnum = inc_recurse ? F_HL_GNUM(file) : -1;
-	int prev_ndx = F_HL_PREV(file);
+	int prev_ndx;
 
-	prev_name = realname = check_prior(prev_ndx, gnum, &flist);
+	prev_name = realname = check_prior(file, gnum, &prev_ndx, &flist);
 
 	if (!prev_name) {
-		struct file_struct *prev_file = flist->files[prev_ndx - flist->ndx_start];
+		struct file_struct *prev_file;
+
+		if (!flist) {
+			/* The previous file was skipped, so this one is
+			 * treated as if it were the first in its group. */
+			return 0;
+		}
+
+		prev_file = flist->files[prev_ndx - flist->ndx_start];
 
 		/* Is the previous link not complete yet? */
 		if (!(prev_file->flags & FLAG_HLINK_DONE)) {
 			/* Is the previous link being transferred? */
 			if (prev_file->flags & FLAG_FILE_SENT) {
 				/* Add ourselves to the list of files that will
@@ -291,14 +324,14 @@
 			return 0;
 		}
 
 		/* There is a finished file to link with! */
 		if (!(prev_file->flags & FLAG_HLINK_FIRST)) {
 			/* The previous previous is FIRST when prev is not. */
-			prev_ndx = F_HL_PREV(prev_file);
-			prev_name = realname = check_prior(prev_ndx, gnum, &flist);
+			prev_name = realname = check_prior(prev_file, gnum, &prev_ndx, &flist);
+			assert(prev_name != NULL || flist != NULL);
 			/* Update our previous pointer to point to the FIRST. */
 			F_HL_PREV(file) = prev_ndx;
 		}
 
 		if (!prev_name) {
 			int alt_dest;
@@ -471,7 +504,28 @@
 		assert(CVAL(node->data, 0) == 0);
 		free(node->data);
 		if (!(node->data = strdup(our_name)))
 			out_of_memory("finish_hard_link");
 	}
 }
+
+int skip_hard_link(struct file_struct *file, struct file_list **flist_p)
+{
+	struct file_list *flist;
+	int prev_ndx;
+
+	file->flags |= FLAG_SKIP_HLINK;
+	if (!(file->flags & FLAG_HLINK_LAST))
+		return -1;
+
+	check_prior(file, F_HL_GNUM(file), &prev_ndx, &flist);
+	if (prev_ndx >= 0) {
+		file = flist->files[prev_ndx - flist->ndx_start];
+		if (file->flags & (FLAG_HLINK_DONE|FLAG_FILE_SENT))
+			return -1;
+		file->flags |= FLAG_HLINK_LAST;
+		*flist_p = flist;
+	}
+
+	return prev_ndx;
+}
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/ifuncs.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/ifuncs.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/ifuncs.h	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/ifuncs.h	2008-03-21 22:26:25.000000000 +0800
@@ -54,12 +54,22 @@
 	if ((mode & (_S_IFMT)) == 0120000)
 		return (mode & ~(_S_IFMT)) | _S_IFLNK;
 #endif
 	return mode;
 }
 
+static inline char *
+d_name(struct dirent *di)
+{
+#ifdef HAVE_BROKEN_READDIR
+	return (di->d_name - 2);
+#else
+	return di->d_name;
+#endif
+}
+
 static inline int
 isDigit(const char *ptr)
 {
 	return isdigit(*(unsigned char *)ptr);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/io.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/io.c	2008-03-25 00:54:04.000000000 +0800
@@ -42,12 +42,13 @@
 extern int am_sender;
 extern int am_generator;
 extern int inc_recurse;
 extern int io_error;
 extern int eol_nulls;
 extern int flist_eof;
+extern int list_only;
 extern int read_batch;
 extern int csum_length;
 extern int protect_args;
 extern int checksum_seed;
 extern int protocol_version;
 extern int remove_source_files;
@@ -101,20 +102,24 @@
 static xbuf iconv_buf = EMPTY_XBUF;
 #endif
 static int defer_forwarding_messages = 0, defer_forwarding_keep = 0;
 static int select_timeout = SELECT_TIMEOUT;
 static int active_filecnt = 0;
 static OFF_T active_bytecnt = 0;
+static int first_message = 1;
 
 static char int_byte_extra[64] = {
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* (00 - 3F)/4 */
 	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* (40 - 7F)/4 */
 	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* (80 - BF)/4 */
 	2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, /* (C0 - FF)/4 */
 };
 
+#define REMOTE_OPTION_ERROR "rsync: on remote machine: -"
+#define REMOTE_OPTION_ERROR2 ": unknown option"
+
 enum festatus { FES_SUCCESS, FES_REDO, FES_NO_SEND };
 
 static void readfd(int fd, char *buffer, size_t N);
 static void writefd(int fd, const char *buf, size_t len);
 static void writefd_unbuffered(int fd, const char *buf, size_t len);
 static void mplex_write(int fd, enum msgcode code, const char *buf, size_t len, int convert);
@@ -318,12 +323,42 @@
 			defer_forwarding_messages--;
 			free(m);
 		}
 	}
 }
 
+static void check_for_d_option_error(const char *msg)
+{
+	static char rsync263_opts[] = "BCDHIKLPRSTWabceghlnopqrtuvxz";
+	char *colon;
+	int saw_d = 0;
+
+	if (*msg != 'r'
+	 || strncmp(msg, REMOTE_OPTION_ERROR, sizeof REMOTE_OPTION_ERROR - 1) != 0)
+		return;
+
+	msg += sizeof REMOTE_OPTION_ERROR - 1;
+	if (*msg == '-' || (colon = strchr(msg, ':')) == NULL
+	 || strncmp(colon, REMOTE_OPTION_ERROR2, sizeof REMOTE_OPTION_ERROR2 - 1) != 0)
+		return;
+
+	for ( ; *msg != ':'; msg++) {
+		if (*msg == 'd')
+			saw_d = 1;
+		else if (*msg == 'e')
+			break;
+		else if (strchr(rsync263_opts, *msg) == NULL)
+			return;
+	}
+
+	if (saw_d) {
+		rprintf(FWARNING,
+		    "*** Try using \"--old-d\" if remote rsync is <= 2.6.3 ***\n");
+	}
+}
+
 /* Read a message from the MSG_* fd and handle it.  This is called either
  * during the early stages of being a local sender (up through the sending
  * of the file list) or when we're the generator (to fetch the messages
  * from the receiver). */
 static void read_msg_fd(void)
 {
@@ -835,14 +870,14 @@
 	}
 #endif
 
 	return s - buf;
 }
 
-int read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,
-	      char ***argv_p, int *argc_p, char **request_p)
+void read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,
+	       char ***argv_p, int *argc_p, char **request_p)
 {
 	int maxargs = MAX_ARGS;
 	int dot_pos = 0;
 	int argc = 0;
 	char **argv, *p;
 	int rl_flags = (rl_nulls ? RL_EOL_NULLS : 0);
@@ -850,20 +885,20 @@
 #ifdef ICONV_OPTION
 	rl_flags |= (protect_args && ic_recv != (iconv_t)-1 ? RL_CONVERT : 0);
 #endif
 
 	if (!(argv = new_array(char *, maxargs)))
 		out_of_memory("read_args");
-	if (mod_name)
+	if (mod_name && !protect_args)
 		argv[argc++] = "rsyncd";
 
 	while (1) {
 		if (read_line(f_in, buf, bufsiz, rl_flags) == 0)
 			break;
 
-		if (argc == maxargs) {
+		if (argc == maxargs-1) {
 			maxargs += MAX_ARGS;
 			if (!(argv = realloc_array(argv, char *, maxargs)))
 				out_of_memory("read_args");
 		}
 
 		if (dot_pos) {
@@ -880,17 +915,18 @@
 				out_of_memory("read_args");
 			argv[argc++] = p;
 			if (*p == '.' && p[1] == '\0')
 				dot_pos = argc;
 		}
 	}
+	argv[argc] = NULL;
+
+	glob_expand(NULL, NULL, NULL, NULL);
 
 	*argc_p = argc;
 	*argv_p = argv;
-
-	return dot_pos ? dot_pos : argc;
 }
 
 int io_start_buffering_out(int f_out)
 {
 	if (iobuf_out) {
 		assert(f_out == iobuf_f_out);
@@ -1116,12 +1152,19 @@
 					"multiplexing overflow %d:%ld [%s]\n",
 					tag, (long)msg_bytes, who_am_i());
 				exit_cleanup(RERR_STREAMIO);
 			}
 			read_loop(fd, line, msg_bytes);
 			rwrite((enum logcode)tag, line, msg_bytes, 1);
+			if (first_message) {
+				if (list_only && !am_sender && tag == 1) {
+					line[msg_bytes] = '\0';
+					check_for_d_option_error(line);
+				}
+				first_message = 0;
+			}
 			break;
 		default:
 			rprintf(FERROR, "unexpected tag %d [%s]\n",
 				tag, who_am_i());
 			exit_cleanup(RERR_STREAMIO);
 		}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/log.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/log.c	2008-03-11 12:39:01.000000000 +0800
@@ -629,21 +629,27 @@
 			}
 			n  = c = buf2 + MAXPATHLEN - 32;
 			c[0] = iflags & ITEM_LOCAL_CHANGE
 			      ? iflags & ITEM_XNAME_FOLLOWS ? 'h' : 'c'
 			     : !(iflags & ITEM_TRANSFER) ? '.'
 			     : !local_server && *op == 's' ? '<' : '>';
-			c[1] = S_ISDIR(file->mode) ? 'd'
-			     : IS_SPECIAL(file->mode) ? 'S'
-			     : IS_DEVICE(file->mode) ? 'D'
-			     : S_ISLNK(file->mode) ? 'L' : 'f';
-			c[2] = !(iflags & ITEM_REPORT_CHECKSUM) ? '.' : 'c';
-			c[3] = !(iflags & ITEM_REPORT_SIZE) ? '.' : 's';
-			c[4] = !(iflags & ITEM_REPORT_TIME) ? '.'
-			     : !preserve_times || (!receiver_symlink_times && S_ISLNK(file->mode))
-			     ? 'T' : 't';
+			if (S_ISLNK(file->mode)) {
+				c[1] = 'L';
+				c[3] = '.';
+				c[4] = !(iflags & ITEM_REPORT_TIME) ? '.'
+				     : !preserve_times || !receiver_symlink_times
+				    || (iflags & ITEM_REPORT_TIMEFAIL) ? 'T' : 't';
+			} else {
+				c[1] = S_ISDIR(file->mode) ? 'd'
+				     : IS_SPECIAL(file->mode) ? 'S'
+				     : IS_DEVICE(file->mode) ? 'D' : 'f';
+				c[3] = !(iflags & ITEM_REPORT_SIZE) ? '.' : 's';
+				c[4] = !(iflags & ITEM_REPORT_TIME) ? '.'
+				     : !preserve_times ? 'T' : 't';
+			}
+			c[2] = !(iflags & ITEM_REPORT_CHANGE) ? '.' : 'c';
 			c[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
 			c[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
 			c[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
 			c[8] = !(iflags & ITEM_REPORT_ATIME) ? '.' : 'u';
 			c[9] = !(iflags & ITEM_REPORT_ACL) ? '.' : 'a';
 			c[10] = !(iflags & ITEM_REPORT_XATTR) ? '.' : 'x';
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/main.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/main.c	2008-03-31 06:44:46.000000000 +0800
@@ -75,16 +75,13 @@
 extern char *rsync_path;
 extern char *shell_cmd;
 extern char *batch_name;
 extern char *password_file;
 extern char curr_dir[MAXPATHLEN];
 extern struct file_list *first_flist;
-extern struct filter_list_struct server_filter_list;
-#ifdef ICONV_OPTION
-extern iconv_t ic_send;
-#endif
+extern struct filter_list_struct daemon_filter_list;
 
 uid_t our_uid;
 int local_server = 0;
 int daemon_over_rsh = 0;
 mode_t orig_umask = 0;
 int batch_gen_fd = -1;
@@ -331,23 +328,23 @@
 /* Start the remote shell.   cmd may be NULL to use the default. */
 static pid_t do_cmd(char *cmd, char *machine, char *user, char **remote_argv, int remote_argc,
 		    int *f_in_p, int *f_out_p)
 {
 	int i, argc = 0;
 	char *args[MAX_ARGS];
-	pid_t ret;
+	pid_t pid;
 	int dash_l_set = 0;
 
 	if (!read_batch && !local_server) {
 		char *t, *f, in_quote = '\0';
 		char *rsh_env = getenv(RSYNC_RSH_ENV);
 		if (!cmd)
 			cmd = rsh_env;
 		if (!cmd)
 			cmd = RSYNC_RSH;
-		cmd = strdup(cmd);
+		cmd = strdup(cmd); /* MEMORY LEAK */
 		if (!cmd)
 			goto oom;
 
 		for (t = f = cmd; *f; f++) {
 			if (*f == ' ')
 				continue;
@@ -450,70 +447,36 @@
 			rsyserr(FERROR, errno, "pipe");
 			exit_cleanup(RERR_IPC);
 		}
 		batch_gen_fd = from_gen_pipe[0];
 		*f_out_p = from_gen_pipe[1];
 		*f_in_p = batch_fd;
-		ret = -1; /* no child pid */
+		pid = (pid_t)-1; /* no child pid */
 #ifdef ICONV_CONST
 		setup_iconv();
 #endif
 	} else if (local_server) {
 		/* If the user didn't request --[no-]whole-file, force
 		 * it on, but only if we're not batch processing. */
 		if (whole_file < 0 && !write_batch)
 			whole_file = 1;
 		set_allow_inc_recurse();
-		ret = local_child(argc, args, f_in_p, f_out_p, child_main);
+		pid = local_child(argc, args, f_in_p, f_out_p, child_main);
 #ifdef ICONV_CONST
 		setup_iconv();
 #endif
 	} else {
+		pid = piped_child(args, f_in_p, f_out_p);
 #ifdef ICONV_CONST
 		setup_iconv();
 #endif
-		if (protect_args) {
-			int fd;
-#ifdef ICONV_OPTION
-			int convert = ic_send != (iconv_t)-1;
-			xbuf outbuf, inbuf;
-
-			if (convert)
-				alloc_xbuf(&outbuf, 1024);
-#endif
-
-			ret = piped_child(args, f_in_p, f_out_p);
-
-			for (i = 0; args[i]; i++) {} /* find first NULL */
-			args[i] = "rsync"; /* set a new arg0 */
-			if (verbose > 1)
-				print_child_argv("protected args:", args + i + 1);
-			fd = *f_out_p;
-			do {
-#ifdef ICONV_OPTION
-				if (convert) {
-					INIT_XBUF_STRLEN(inbuf, args[i]);
-					iconvbufs(ic_send, &inbuf, &outbuf,
-						  ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE);
-					outbuf.buf[outbuf.len] = '\0';
-					write_buf(fd, outbuf.buf, outbuf.len + 1);
-					outbuf.len = 0;
-				} else
-#endif
-					write_buf(fd, args[i], strlen(args[i]) + 1);
-			} while (args[++i]);
-			write_byte(fd, 0);
-#ifdef ICONV_OPTION
-			if (convert)
-				free(outbuf.buf);
-#endif
-		} else
-			ret = piped_child(args, f_in_p, f_out_p);
+		if (protect_args)
+			send_protected_args(*f_out_p, args);
 	}
 
-	return ret;
+	return pid;
 
   oom:
 	out_of_memory("do_cmd");
 	return 0; /* not reached */
 }
 
@@ -541,18 +504,26 @@
 			file_total, NS(dest_path));
 	}
 
 	if (!dest_path || list_only)
 		return NULL;
 
+	if (daemon_filter_list.head
+	 && (check_filter(&daemon_filter_list, FLOG, dest_path, 0 != 0) < 0
+	  || check_filter(&daemon_filter_list, FLOG, dest_path, 1 != 0) < 0)) {
+		rprintf(FERROR, "skipping daemon-excluded destination \"%s\"\n",
+			dest_path);
+		exit_cleanup(RERR_FILESELECT);
+	}
+
 	/* See what currently exists at the destination. */
 	if ((statret = do_stat(dest_path, &st)) == 0) {
 		/* If the destination is a dir, enter it and use mode 1. */
 		if (S_ISDIR(st.st_mode)) {
-			if (!push_dir(dest_path, 0)) {
-				rsyserr(FERROR, errno, "push_dir#1 %s failed",
+			if (!change_dir(dest_path, CD_NORMAL)) {
+				rsyserr(FERROR, errno, "change_dir#1 %s failed",
 					full_fname(dest_path));
 				exit_cleanup(RERR_FILESELECT);
 			}
 			return NULL;
 		}
 		if (file_total > 1) {
@@ -605,14 +576,14 @@
 
 		if (dry_run) {
 			/* Indicate that dest dir doesn't really exist. */
 			dry_run++;
 		}
 
-		if (!push_dir(dest_path, dry_run > 1)) {
-			rsyserr(FERROR, errno, "push_dir#2 %s failed",
+		if (!change_dir(dest_path, dry_run > 1 ? CD_SKIP_CHDIR : CD_NORMAL)) {
+			rsyserr(FERROR, errno, "change_dir#2 %s failed",
 				full_fname(dest_path));
 			exit_cleanup(RERR_FILESELECT);
 		}
 
 		return NULL;
 	}
@@ -625,14 +596,14 @@
 		return dest_path;
 
 	if (cp == dest_path)
 		dest_path = "/";
 
 	*cp = '\0';
-	if (!push_dir(dest_path, 0)) {
-		rsyserr(FERROR, errno, "push_dir#3 %s failed",
+	if (!change_dir(dest_path, CD_NORMAL)) {
+		rsyserr(FERROR, errno, "change_dir#3 %s failed",
 			full_fname(dest_path));
 		exit_cleanup(RERR_FILESELECT);
 	}
 	*cp = '/';
 
 	return cp + 1;
@@ -718,14 +689,14 @@
 		    remove_source_files == 1 ? "source" : "sent");
 		exit_cleanup(RERR_SYNTAX);
 		return;
 	}
 
 	if (!relative_paths) {
-		if (!push_dir(dir, 0)) {
-			rsyserr(FERROR, errno, "push_dir#3 %s failed",
+		if (!change_dir(dir, CD_NORMAL)) {
+			rsyserr(FERROR, errno, "change_dir#3 %s failed",
 				full_fname(dir));
 			exit_cleanup(RERR_FILESELECT);
 		}
 	}
 	argc--;
 	argv++;
@@ -888,14 +859,14 @@
 	}
 
 	if (argc > 0) {
 		char *dir = argv[0];
 		argc--;
 		argv++;
-		if (!am_daemon && !push_dir(dir, 0)) {
-			rsyserr(FERROR, errno, "push_dir#4 %s failed",
+		if (!am_daemon && !change_dir(dir, CD_NORMAL)) {
+			rsyserr(FERROR, errno, "change_dir#4 %s failed",
 				full_fname(dir));
 			exit_cleanup(RERR_FILESELECT);
 		}
 	}
 
 	if (protocol_version >= 30)
@@ -928,31 +899,31 @@
 
 	/* Now that we know what our destination directory turned out to be,
 	 * we can sanitize the --link-/copy-/compare-dest args correctly. */
 	if (sanitize_paths) {
 		char **dir_p;
 		for (dir_p = basis_dir; *dir_p; dir_p++)
-			*dir_p = sanitize_path(NULL, *dir_p, NULL, curr_dir_depth);
+			*dir_p = sanitize_path(NULL, *dir_p, NULL, curr_dir_depth, SP_DEFAULT);
 		if (partial_dir)
-			partial_dir = sanitize_path(NULL, partial_dir, NULL, curr_dir_depth);
+			partial_dir = sanitize_path(NULL, partial_dir, NULL, curr_dir_depth, SP_DEFAULT);
 	}
 	check_alt_basis_dirs();
 
-	if (server_filter_list.head) {
+	if (daemon_filter_list.head) {
 		char **dir_p;
-		struct filter_list_struct *elp = &server_filter_list;
+		struct filter_list_struct *elp = &daemon_filter_list;
 
 		for (dir_p = basis_dir; *dir_p; dir_p++) {
 			char *dir = *dir_p;
 			if (*dir == '/')
 				dir += module_dirlen;
-			if (check_filter(elp, dir, 1) < 0)
+			if (check_filter(elp, FLOG, dir, 1) < 0)
 				goto options_rejected;
 		}
 		if (partial_dir && *partial_dir == '/'
-		 && check_filter(elp, partial_dir + module_dirlen, 1) < 0) {
+		 && check_filter(elp, FLOG, partial_dir + module_dirlen, 1) < 0) {
 		    options_rejected:
 			rprintf(FERROR,
 				"Your options have been rejected by the server.\n");
 			exit_cleanup(RERR_SYNTAX);
 		}
 	}
@@ -1064,17 +1035,12 @@
 		if (protocol_version >= 23)
 			io_start_multiplex_in();
 		if (need_messages_from_generator)
 			io_start_multiplex_out();
 	}
 
-	if (argc == 0) {
-		list_only |= 1;
-		xfer_dirs |= 1;
-	}
-
 	send_filter_list(read_batch ? -1 : f_out);
 
 	if (filesfrom_fd >= 0) {
 		io_set_filesfrom_fds(filesfrom_fd, f_out);
 		filesfrom_fd = -1;
 	}
@@ -1179,14 +1145,12 @@
 				p = argv[--argc];
 				remote_argv = argv + argc;
 			} else {
 				static char *dotarg[1] = { "." };
 				p = dotarg[0];
 				remote_argv = dotarg;
-				list_only |= 1;
-				xfer_dirs |= 1;
 			}
 			remote_argc = 1;
 
 			path = check_for_hostspec(p, &shell_machine, &rsync_port);
 			if (path && filesfrom_host && *filesfrom_host
 			    && strcmp(filesfrom_host, shell_machine) != 0) {
@@ -1252,16 +1216,12 @@
 				else
 					rprintf(FERROR, "All source args must use the same port number.\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
 			remote_argv[i] = arg;
 		}
-		if (argc == 0) {
-			list_only |= 1;
-			xfer_dirs |= 1;
-		}
 	}
 
 	if (daemon_over_rsh < 0)
 		return start_socket_client(shell_machine, remote_argc, remote_argv, argc, argv);
 
 	if (password_file && !daemon_over_rsh) {
@@ -1444,13 +1404,13 @@
 	orig_umask = umask(0);
 
 #if defined CONFIG_LOCALE && defined HAVE_SETLOCALE
 	setlocale(LC_CTYPE, "");
 #endif
 
-	if (!parse_arguments(&argc, (const char ***) &argv, 1)) {
+	if (!parse_arguments(&argc, (const char ***) &argv)) {
 		/* FIXME: We ought to call the same error-handling
 		 * code here, rather than relying on getopt. */
 		option_error();
 		exit_cleanup(RERR_SYNTAX);
 	}
 
@@ -1465,17 +1425,17 @@
 	 * see the EPIPE. */
 	SIGACTION(SIGPIPE, SIG_IGN);
 #ifdef SIGXFSZ
 	SIGACTION(SIGXFSZ, SIG_IGN);
 #endif
 
-	/* Initialize push_dir here because on some old systems getcwd
+	/* Initialize change_dir() here because on some old systems getcwd
 	 * (implemented by forking "pwd" and reading its output) doesn't
 	 * work when there are other child processes.  Also, on all systems
 	 * that implement getcwd that way "pwd" can't be found after chroot. */
-	push_dir(NULL, 0);
+	change_dir(NULL, CD_NORMAL);
 
 	init_flist();
 
 	if ((write_batch || read_batch) && !am_server) {
 		if (write_batch)
 			write_batch_shell_file(orig_argc, orig_argv, argc);
@@ -1509,13 +1468,13 @@
 		return daemon_main();
 
 	if (am_server && protect_args) {
 		char buf[MAXPATHLEN];
 		protect_args = 2;
 		read_args(STDIN_FILENO, NULL, buf, sizeof buf, 1, &argv, &argc, NULL);
-		if (!parse_arguments(&argc, (const char ***) &argv, 1)) {
+		if (!parse_arguments(&argc, (const char ***) &argv)) {
 			option_error();
 			exit_cleanup(RERR_SYNTAX);
 		}
 	}
 
 	if (argc < 1) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/Makefile.in	2008-02-13 09:29:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/Makefile.in	2008-03-21 14:30:09.000000000 +0800
@@ -79,25 +79,27 @@
 $(CHECK_OBJS): $(HEADERS)
 
 flist.o: rounding.h
 
 rounding.h: rounding.c rsync.h
 	@for r in 0 1 3; do \
-	    if $(CC) $(CFLAGS) $(LDFLAGS) -o rounding -DEXTRA_ROUNDING=$$r -I. $(srcdir)/rounding.c >/dev/null 2>&1; then \
+	    if $(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o rounding -DEXTRA_ROUNDING=$$r -I. $(srcdir)/rounding.c >rounding.out 2>&1; then \
 		echo "#define EXTRA_ROUNDING $$r" >rounding.h; \
 		if test -f "$$HOME/build_farm/build_test.fns"; then \
 		    echo "EXTRA_ROUNDING is $$r" >&2; \
 		fi; \
 		break; \
 	    fi; \
 	done
 	@rm -f rounding
 	@if test -f rounding.h; then : ; else \
-	    echo "Failed to create rounding.h!"; \
+	    cat rounding.out 1>&2; \
+	    echo "Failed to create rounding.h!" 1>&2; \
 	    exit 1; \
 	fi
+	@rm -f rounding.out
 
 tls$(EXEEXT): $(TLS_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TLS_OBJ) $(LIBS)
 
 getgroups$(EXEEXT): getgroups.o
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getgroups.o $(LIBS)
@@ -106,13 +108,13 @@
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getfsdev.o $(LIBS)
 
 TRIMSLASH_OBJ = trimslash.o syscall.o lib/compat.o lib/snprintf.o
 trimslash$(EXEEXT): $(TRIMSLASH_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
 
-T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o t_stub.o lib/compat.o lib/snprintf.o
+T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o t_stub.o lib/compat.o lib/snprintf.o lib/wildmatch.o
 t_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(T_UNSAFE_OBJ) $(LIBS)
 
 gen: conf proto.h man
 
 gensend: gen
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/NEWS	2008-03-02 04:12:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/NEWS	2008-04-04 13:37:01.000000000 +0800
@@ -1,341 +1,136 @@
-NEWS for rsync 3.0.0 (1 Mar 2008)
-Protocol: 30 (changed)
-Changes since 2.6.9:
+NEWS for rsync 3.0.1 (3 Apr 2008)
+Protocol: 30 (unchanged)
+Changes since 3.0.0:
 
   NOTABLE CHANGES IN BEHAVIOR:
 
-    - The handling of implied directories when using --relative has changed to
-      send them as directories (e.g. no implied dir is ever sent as a symlink).
-      This avoids unexpected behavior and should not adversely affect most
-      people.  If you're one of those rare individuals who relied upon having
-      an implied dir be duplicated as a symlink, you should specify the
-      transfer of the symlink and the transfer of the referent directory as
-      separate args.  (See also --keep-dirlinks and --no-implied-dirs.)
-      Also, exclude rules no longer have a partial effect on implied dirs.
-
-    - Requesting a remote file-listing without specifying -r (--recursive) now
-      sends the -d (--dirs) option to the remote rsync rather than sending -r
-      along with an extra exclude of /*/*.  If the remote rsync does not
-      understand the -d option (i.e. it is 2.6.3 or older), you will need to
-      either turn off -d (--no-d), or specify  -r --exclude='/*/*'  manually.
-
-    - In --dry-run mode, the last line of the verbose summary text is output
-      with a "(DRY RUN)" suffix to help remind you that no updates were made.
-      Similarly, --only-write-batch outputs "(BATCH ONLY)".
-
-    - A writable rsync daemon with "use chroot" disabled now defaults to a
-      symlink-munging behavior designed to make symlinks safer while also
-      allowing absolute symlinks to be stored and retrieved.  This also has
-      the effect of making symlinks unusable while they're in the daemon's
-      hierarchy.  See the daemon's "munge symlinks" parameter for details.
-
-    - Starting up an extra copy of an rsync daemon will not clobber the pidfile
-      for the running daemon -- if the pidfile exists, the new daemon will exit
-      with an error.  This means that your wrapper script that starts the rsync
-      daemon should be made to handle lock-breaking (if you want any automatic
-      breaking of locks to be done).
+    - Added the 'c'-flag to the itemizing of non-regular files so that the
+      itemized output doesn't get hidden if there were no attribute changes,
+      and also so that the itemizing of a --copy-links run will distinguish
+      between copying an identical non-regular file and the creation of a
+      revised version with a new value (e.g. a changed symlink referent, a
+      new device number, etc.).
 
   BUG FIXES:
 
-    - A daemon with "use chroot = no" and excluded items listed in the daemon
-      config file now properly checks an absolute-path arg specified for these
-      options:  --compare-dest, --link-dest, --copy-dest, --partial-dir,
-      --backup-dir, --temp-dir, and --files-from.
+    - Fixed a crash bug when a single-use rsync daemon (via remote shell) was
+      run without specifying a --config=FILE option.
 
-    - A daemon can now be told to disable all user- and group-name translation
-      on a per-module basis.  This avoids a potential problem with a writable
-      daemon module that has "use chroot" enabled -- if precautions weren't
-      taken, a user could try to add a missing library and get rsync to use
-      it.  This makes rsync safer by default, and more configurable when id-
-      translation is not desired.  See the daemon's "numeric ids" parameter
-      for full details.
+    - Fixed a crash when backing up a directory that has a default ACL.
 
-    - A chroot daemon can now indicate which part of its path should affect the
-      chroot call, and which part should become an inside-chroot path for the
-      module.  This allows you to have outside-the-transfer paths (such as for
-      libraries) even when you enable chroot protection.  The idiom used in the
-      rsyncd.conf file is:  path = /chroot/dirs/./dirs/inside
+    - Fixed a bug in the handling of xattr values that could cause rsync to
+      not think that a file's extended attributes are up-to-date.
 
-    - If a file's data arrived successfully on the receiving side but the
-      rename of the temporary file to the destination file failed AND the
-      --remove-source-files (or the deprecated --remove-sent-files) option
-      was specified, rsync no longer erroneously removes the associated
-      source file.
+    - Fixed the working of --fake-super with --link-dest and --xattrs.
 
-    - Fixed the output of -ii when combined with one of the --*-dest options:
-      it now itemizes all the items, not just the changed ones.
+    - Fixed a hang when combining --dry-run with --remove-source-files.
 
-    - Made the output of all file types consistent when using a --*-dest
-      option.  Prior versions would output too many creation events for
-      matching items.
+    - Fixed a bug with --iconv's handling of files that cannot be converted:
+      a failed name can no longer cause a transfer failure.
 
-    - The code that waits for a child pid now handles being interrupted by a
-      signal.  This fixes a problem with the pre-xfer exec function not being
-      able to get the exit status from the script.
+    - Fixed the building of the rounding.h file on systems that need custom
+      CPPFLAGS to be used.  Also improved the error reporting if the building
+      of rounding.h fails.
 
-    - A negated filter rule (i.e. with a '!' modifier) no longer loses the
-      negation when sending the filter rules to the remote rsync.
+    - Fixed the use of the --protect-args (-s) option when talking to a daemon.
 
-    - Fixed a problem with the --out-format (aka --log-format) option %f:  it
-      no longer outputs superfluous directory info for a non-daemon rsync.
+    - Fixed the --ignore-existing option's protection of files on the receiver
+      that are non-regular files on the sender (e.g. if a symlink or a dir on
+      the sender is trying to replace a file on the receiver).  The reverse
+      protection (protecting a dir/symlink/device from being replaced by a
+      file) was already working.
 
-    - Fixed a problem with -vv (double --verbose) and --stats when "pushing"
-      files (which includes local copies).  Version 2.6.9 would complete the
-      copy, but exit with an error when the receiver output its memory stats.
+    - Fixed an assert failure if --hard-links is combined with an option that
+      can skip a file in a set of hard-linked files (i.e. --ignore-existing,
+      --append, etc.), without skipping all the files in the set.
 
-    - If --password-file is used on a non-daemon transfer, rsync now complains
-      and exits.  This should help users figure out that they can't use this
-      option to control a remote shell's password prompt.
+    - Avoid setting the modify time on a directory that already has the right
+      modify time set.  This avoids tweaking the dir's ctime.
 
-    - Make sure that directory permissions of a newly-created destination
-      directory are handled right when --perms is left off.
+    - Improved the daemon-exclude handling to do a better job of applying the
+      exclude rules to path entries.  It also sends the user an error just as
+      if the files were actually missing (instead of silently ignoring the
+      user's args), and avoids sending the user the filter-action messages
+      for these non-user-initiated rules.
 
-    - The itemized output of a newly-created destination directory is now
-      output as a creation event, not a change event.
+    - Fixed some glitches with the dry-run code's missing-directory
+      handling, including a problem when combined with --fuzzy.
 
-    - Improved --hard-link so that more corner cases are handled correctly
-      when combined with options such as --link-dest and/or --ignore-existing.
+    - Fixed some glitches with the skipped-directory handling.
 
-    - The --append option no longer updates a file that has the same size.
+    - Fixed the 'T'-flag itemizing of symlinks when --time isn't preserved.
 
-    - Fixed a bug when combining --backup and --backup-dir with --inplace:
-      any missing backup directories are now created.
+    - Fixed a glitch in the itemizing of permissions with the -E option.
 
-    - Fixed a bug when using --backup and --inplace with --whole-file or
-      --read-batch: backup files are actually created now.
+    - The --append option's restricting of transfers to those that add data no
+      longer prevents the updating of non-content changes to otherwise up-to-
+      date files (i.e. those with the same content but differing permissions,
+      ownership, xattrs, etc.).
 
-    - The daemon pidfile is checked and created sooner in the startup sequence.
+    - Don't allow --fake-super to be specified with -XX (double --xattrs)
+      because the options conflict.  If a daemon has "fake super" enabled,
+      it automatically downgrades a -XX request to -X.
 
-    - If a daemon module's "path" value is not an absolute pathname, the code
-      now makes it absolute internally (making it work properly).
+    - Fixed a couple bugs in the parsing of daemon-config excludes that could
+      make a floating exclude rule get treated as matching an absolute path.
 
-    - Ensure that a temporary file always has owner-write permission while we
-      are writing to it.  This avoids problems with some network filesystems
-      when transfering read-only files.
+    - A daemon doesn't try to auto-refuse the "iconv" option if iconv-support
+      wasn't compiled in to the daemon (avoiding a warning in the logs).
 
-    - Any errors output about password-file reading no longer cause an error at
-      the end of the run about a partial transfer.
+    - Fixed the inclusion of per-dir merge files from implied dirs.
 
-    - The --read-batch option for protocol 30 now ensures that several more
-      options are set correctly for the current batch file:  --iconv, --acls,
-      --xattrs, --inplace, --append, and --append-verify.
-
-    - Using --only-write-batch to a daemon receiver now works properly (older
-      versions would update some files while writing the batch).
-
-    - Avoid outputting a "file has vanished" message when the file is a broken
-      symlink and --copy-unsafe-links or --copy-dirlinks is used (the code
-      already handled this for --copy-links).
-
-    - Fixed the combination of --only-write-batch and --dry-run.
-
-    - Fixed rsync's ability to remove files that are not writable by the file's
-      owner when rsync is running as the same user.
+    - Fixed the support/rrsync script to work with the latest options that
+      rsync sends (including its flag-specifying use of -e to the server).
 
   ENHANCEMENTS:
 
-    - A new incremental-recursion algorithm is now used when rsync is talking
-      to another 3.x version.  This starts the transfer going more quickly
-      (before all the files have been found), and requires much less memory.
-      See the --recursive option in the manpage for some restrictions.
-
-    - Lowered memory use in the non-incremental-recursion algorithm for typical
-      option values (usually saving from 21-29 bytes per file).
-
-    - The default --delete algorithm is now --delete-during when talking to a
-      3.x rsync.  This is a faster scan than using --delete-before (which is
-      the default when talking to older rsync versions), and is compatible with
-      the new incremental recursion mode.
-
-    - Rsync now allows multiple remote-source args to be specified rather than
-      having to rely on a special space-splitting side-effect of the remote-
-      shell.  Additional remote args must specify the same host or an empty one
-      (e.g. empty:  :file1  or  ::module/file2).  For example, this means that
-      local use of brace expansion now works:  rsync -av host:dir/{f1,f2} .
-
-    - Added the --protect-args (-s) option, that tells rsync to send most of
-      the command-line args at the start of the transfer rather than as args
-      to the remote-shell command.  This protects them from space-splitting,
-      and only interprets basic wildcard special shell characters (*?[).
-
-    - Added the --delete-delay option, which is a more efficient way to delete
-      files at the end of the transfer without needing a separate delete pass.
-
-    - Added the --acls (-A) option to preserve Access Control Lists.  This is
-      an improved version of the prior patch that was available, and it even
-      supports OS X ACLs.  If you need to have backward compatibility with old,
-      ACL-patched versions of rsync, apply the acls.diff file from the patches
-      dir.
-
-    - Added the --xattrs (-X) option to preserve extended attributes.  This is
-      an improved version of the prior patch that was available, and it even
-      supports OS X xattrs (which includes their resource fork data).  If you
-      need to have backward compatibility with old, xattr-patched versions of
-      rsync, apply the xattrs.diff file from the patches dir.
-
-    - Added the --fake-super option that allows a non-super user to preserve
-      all attributes of a file by using a special extended-attribute idiom.
-      It even supports the storing of foreign ACL data on your backup server.
-      There is also an analogous "fake super" parameter for an rsync daemon.
-
-    - Added the --iconv option, which allows rsync to convert filenames from
-      one character-set to another during the transfer.  The default is to
-      make this feature available as long as your system has iconv_open().
-      If compilation fails, specify --disable-iconv to configure, and then
-      rebuild.  If you want rsync to perform character-set conversions by
-      default, you can specify --enable-iconv=CONVERT_STRING with the default
-      value for the --iconv option that you wish to use.  For example,
-      "--enable-iconv=." is a good choice.  See the rsync manpage for an
-      explanation of the --iconv option's settings.
-
-    - A new daemon config parameter, "charset", lets you control the character-
-      set that is used during an --iconv transfer to/from a daemon module.  You
-      can also set your daemon to refuse "no-iconv" if you want to force the
-      client to use an --iconv transfer (requiring an rsync 3.x client).
-
-    - Added the --skip-compress=LIST option to override the default list of
-      file suffixes that will not be compressed when using --compress (-z).
-
-    - The daemon's default for "dont compress" was extended to include:
-	  *.7z *.mp[34] *.mov *.avi *.ogg *.jpg *.jpeg
-      The name-matching routine was also optimized to run more quickly.
-
-    - The --max-delete option now outputs a warning if it skipped any file
-      deletions, including a count of how many deletions were skipped.  (Older
-      versions just silently stopped deleting things.)
-
-    - You may specify --max-delete=0 to a 3.0.0 client to request that it warn
-      about extraneous files without deleting anything.  If you're not sure
-      what version the client is, you can use the less-obvious --max-delete=-1,
-      as both old and new versions will treat that as the same request (though
-      older versions don't warn).
-
-    - The --hard-link option now uses less memory on both the sending and
-      receiving side for all protocol versions.  For protocol 30, the use of a
-      hashtable on the sending side allows us to more efficiently convey to the
-      receiver what files are linked together.  This reduces the amount of data
-      sent over the socket by a considerable margin (rather than adding more
-      data), and limits the in-memory storage of the device+inode information
-      to just the sending side for the new protocol 30, or to the receiving
-      side when speaking an older protocol (note that older rsync versions kept
-      the device+inode information on both sides).
-
-    - The filter rules now support a perishable ("p") modifier that marks rules
-      that should not have an effect in a directory that is being deleted.  e.g.
-      -f '-p .svn/' would only affect "live" .svn directories.
-
-    - Rsync checks all the alternate-destination args for validity (e.g.
-      --link-dest).  This lets the user know when they specified a directory
-      that does not exist.
-
-    - If we get an error setting the time on a symlink, we don't complain about
-      it anymore (since some operating systems don't support that, and it's not
-      that important).
-
-    - Protocol 30 now uses MD5 checksums instead of MD4.
-
-    - Changed the --append option to not checksum the existing data in the
-      destination file, which speeds up file appending.
-
-    - Added the --append-verify option, which works like the older --append
-      option (verifying the existing data in the destination file).  For
-      compatibility with older rsync versions, any use of --append that is
-      talking protocol 29 or older will revert to the --append-verify method.
-
-    - Added the --contimeout=SECONDS option that lets the user specify a
-      connection timeout for rsync daemon access.
-
-    - Documented and extended the support for the RSYNC_CONNECT_PROG variable
-      that can be used to enhance the client side of a daemon connection.
-
-    - Improved the dashes and double-quotes in the nroff manpage output.
-
-    - Rsync now supports a lot more --no-OPTION override options.
-
-  INTERNAL:
+    - Added the --old-dirs (--old-d) option to make it easier for a user to
+      ask for file-listings with older rsync versions (this is easier than
+      having to type "-r --exclude='/*/*'" manually).
 
-    - The file-list sorting algorithm now uses a sort that keeps any same-
-      named items in the same order as they were specified.  This allows
-      rsync to always ensure that the first of the duplicates is the one
-      that will be included in the copy.  The new sort is also faster
-      than the glibc version of qsort() and mergesort().
+    - When getting an error while asking an older rsync daemon for a file
+      listing, rsync will try to notice if the error is a rejection of the
+      --dirs (-d) option and let the user know how to work around the issue.
 
-    - Rsync now supports the transfer of 64-bit timestamps (time_t values).
+    - Added a few more --no-OPTION overrides.
 
-    - Made the file-deletion code use a little less stack when recursing
-      through a directory hierarchy of extraneous files.
+    - Improved the documentation of the --append option.
 
-    - Fixed a build problem with older (2.x) versions of gcc.
+    - Improved the documentation of the filter/exclude/include daemon
+      parameters.
 
-    - Added some isType() functions that make dealing with signed characters
-      easier without forcing variables via casts.
-
-    - Changed strcat/strcpy/sprintf function calls to use safer versions.
-
-    - Upgraded the included popt version to 1.10.2 and improved its use of
-      string-handling functions.
-
-    - Added missing prototypes for compatibility functions from the lib dir.
-
-    - Configure determines if iconv() has a const arg, allowing us to avoid a
-      compiler warning.
-
-    - Made the sending of some numbers more efficient for protocol 30.
+  INTERNAL:
 
-    - Make sure that a daemon process doesn't mind if the client was weird and
-      omitted the --server option.
+    - Fixed a couple minor bugs in the included popt library (ones which I
+      sent to the official popt project for inclusion in the 1.14 release).
 
-    - There are more internal logging categories available in protocol 30 than
-      the age-old FINFO and FERROR, including FERROR_XFER and FWARN.  These new
-      categories allow some errors and warnings to go to stderr without causing
-      an erroneous end-of-run warning about some files not being able to be
-      transferred.
+    - Fixed a stat() call that should have been do_stat() so that the proper
+      normal/64-bit stat() function gets called.  (Was in an area that should
+      not have caused problems, though.)
+
+    - Changed the file-glob code to do a directory scan without using the
+      "glob" and "glob.h".  This lets us do the globbing with less memory
+      churn, and also avoid adding daemon-excluded items to the returned
+      args.
 
-    - Improved the use of "const" on pointers.
+  DEVELOPER RELATED:
 
-    - Improved J.W.'s pool_alloc routines to add a way of incrementally freeing
-      older sections of a pool's memory.
+    - The configure script tries to get the user's compiler to not warn about
+      unused function parameters if the build is not including one or more of
+      the ACL/xattrs/iconv features.
 
-    - The getaddrinfo.c compatibility code in the "lib" dir was replaced with
-      some new code (derived from samba, derived from PostgreSQL) that has a
-      better license than the old code.
+    - The configure script now has better checks for figuring out if the
+      included popt code should be used or not.
 
-  DEVELOPER RELATED:
+    - Fixed two testsuite glitches: avoid a failure if someone's "cd" command
+      outputs the current directory when cd-ing to a relative path, and made
+      the itemized test query how rsync was built to determine if it should
+      expect hard-linked symlinks or not.
 
-    - Rsync is now licensed under the GPLv3 or later.
+    - Updated the testsuite to verify that various bug fixes remain fixed.
 
-    - Rsync is now being maintained in a "git" repository instead of CVS
-      (though the old CVS repository still exists for historical access).
-      Several maintenance scripts were updated to work with git.
-
-    - Generated files are no longer committed into the source repository.  The
-      autoconf and autoheader commands are now automatically run during the
-      normal use of "configure" and "make".  The latest dev versions of all
-      generated files can also be copied from the samba.org web site (see the
-      prepare-source script's fetch option).
-
-    - The "patches" directory of diff files is now built from branches in the
-      rsync git repository (branch patch/FOO creates file patches/FOO.diff).
-      This directory is now distributed in a separate separate tar file named
-      rsync-patches-VERSION.tar.gz instead of the main rsync-VERSION.tar.gz.
-
-    - The proto.h file is now built using a simple perl script rather than a
-      complex awk script, which proved to be more widely compatible.
-
-    - When running the tests, we now put our per-test temp dirs into a sub-
-      directory named testtmp (which is created, if missing).  This allows
-      someone to symlink the testtmp directory to another filesystem (which is
-      useful if the build dir's filesystem does not support ACLs and xattrs,
-      but another filesystem does).
-
-    - Rsync now has a way of handling protocol-version changes during the
-      development of a new protocol version.  This causes any out-of-sync
-      versions to speak an older protocol rather than fail in a cryptic manner.
-      This addition makes it safer to deploy a pre-release version that may
-      interact with the public.  This new exchange of sub-version info does not
-      interfere with the {MIN,MAX}_PROTOCOL_VERSION checking algorithm (which
-      does not have enough range to allow the main protocol number to be
-      incremented for every minor tweak in that happens during development).
+    - The RPM spec file was updated to have: (1) comments for how to use the
+      rsync-patch tar file, and (2) an /etc/xinetd.d/rsync file.
 
-    - The csprotocol.txt file was updated to mention the daemon protocol change
-      in the 3.0.0 release.
+    - Updated the build scripts to work with a revised FTP directory
+      structure.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/OLDNEWS	2008-03-02 04:12:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/OLDNEWS	2008-04-04 13:37:01.000000000 +0800
@@ -1,6 +1,349 @@
+NEWS for rsync 3.0.0 (1 Mar 2008)
+Protocol: 30 (changed)
+Changes since 2.6.9:
+
+  NOTABLE CHANGES IN BEHAVIOR:
+
+    - The handling of implied directories when using --relative has changed to
+      send them as directories (e.g. no implied dir is ever sent as a symlink).
+      This avoids unexpected behavior and should not adversely affect most
+      people.  If you're one of those rare individuals who relied upon having
+      an implied dir be duplicated as a symlink, you should specify the
+      transfer of the symlink and the transfer of the referent directory as
+      separate args.  (See also --keep-dirlinks and --no-implied-dirs.)
+      Also, exclude rules no longer have a partial effect on implied dirs.
+
+    - Requesting a remote file-listing without specifying -r (--recursive) now
+      sends the -d (--dirs) option to the remote rsync rather than sending -r
+      along with an extra exclude of /*/*.  If the remote rsync does not
+      understand the -d option (i.e. it is 2.6.3 or older), you will need to
+      either turn off -d (--no-d), or specify  -r --exclude='/*/*'  manually.
+
+    - In --dry-run mode, the last line of the verbose summary text is output
+      with a "(DRY RUN)" suffix to help remind you that no updates were made.
+      Similarly, --only-write-batch outputs "(BATCH ONLY)".
+
+    - A writable rsync daemon with "use chroot" disabled now defaults to a
+      symlink-munging behavior designed to make symlinks safer while also
+      allowing absolute symlinks to be stored and retrieved.  This also has
+      the effect of making symlinks unusable while they're in the daemon's
+      hierarchy.  See the daemon's "munge symlinks" parameter for details.
+
+    - Starting up an extra copy of an rsync daemon will not clobber the pidfile
+      for the running daemon -- if the pidfile exists, the new daemon will exit
+      with an error.  This means that your wrapper script that starts the rsync
+      daemon should be made to handle lock-breaking (if you want any automatic
+      breaking of locks to be done).
+
+  BUG FIXES:
+
+    - A daemon with "use chroot = no" and excluded items listed in the daemon
+      config file now properly checks an absolute-path arg specified for these
+      options:  --compare-dest, --link-dest, --copy-dest, --partial-dir,
+      --backup-dir, --temp-dir, and --files-from.
+
+    - A daemon can now be told to disable all user- and group-name translation
+      on a per-module basis.  This avoids a potential problem with a writable
+      daemon module that has "use chroot" enabled -- if precautions weren't
+      taken, a user could try to add a missing library and get rsync to use
+      it.  This makes rsync safer by default, and more configurable when id-
+      translation is not desired.  See the daemon's "numeric ids" parameter
+      for full details.
+
+    - A chroot daemon can now indicate which part of its path should affect the
+      chroot call, and which part should become an inside-chroot path for the
+      module.  This allows you to have outside-the-transfer paths (such as for
+      libraries) even when you enable chroot protection.  The idiom used in the
+      rsyncd.conf file is:  path = /chroot/dirs/./dirs/inside
+
+    - If a file's data arrived successfully on the receiving side but the
+      rename of the temporary file to the destination file failed AND the
+      --remove-source-files (or the deprecated --remove-sent-files) option
+      was specified, rsync no longer erroneously removes the associated
+      source file.
+
+    - Fixed the output of -ii when combined with one of the --*-dest options:
+      it now itemizes all the items, not just the changed ones.
+
+    - Made the output of all file types consistent when using a --*-dest
+      option.  Prior versions would output too many creation events for
+      matching items.
+
+    - The code that waits for a child pid now handles being interrupted by a
+      signal.  This fixes a problem with the pre-xfer exec function not being
+      able to get the exit status from the script.
+
+    - A negated filter rule (i.e. with a '!' modifier) no longer loses the
+      negation when sending the filter rules to the remote rsync.
+
+    - Fixed a problem with the --out-format (aka --log-format) option %f:  it
+      no longer outputs superfluous directory info for a non-daemon rsync.
+
+    - Fixed a problem with -vv (double --verbose) and --stats when "pushing"
+      files (which includes local copies).  Version 2.6.9 would complete the
+      copy, but exit with an error when the receiver output its memory stats.
+
+    - If --password-file is used on a non-daemon transfer, rsync now complains
+      and exits.  This should help users figure out that they can't use this
+      option to control a remote shell's password prompt.
+
+    - Make sure that directory permissions of a newly-created destination
+      directory are handled right when --perms is left off.
+
+    - The itemized output of a newly-created destination directory is now
+      output as a creation event, not a change event.
+
+    - Improved --hard-link so that more corner cases are handled correctly
+      when combined with options such as --link-dest and/or --ignore-existing.
+
+    - The --append option no longer updates a file that has the same size.
+
+    - Fixed a bug when combining --backup and --backup-dir with --inplace:
+      any missing backup directories are now created.
+
+    - Fixed a bug when using --backup and --inplace with --whole-file or
+      --read-batch: backup files are actually created now.
+
+    - The daemon pidfile is checked and created sooner in the startup sequence.
+
+    - If a daemon module's "path" value is not an absolute pathname, the code
+      now makes it absolute internally (making it work properly).
+
+    - Ensure that a temporary file always has owner-write permission while we
+      are writing to it.  This avoids problems with some network filesystems
+      when transfering read-only files.
+
+    - Any errors output about password-file reading no longer cause an error at
+      the end of the run about a partial transfer.
+
+    - The --read-batch option for protocol 30 now ensures that several more
+      options are set correctly for the current batch file:  --iconv, --acls,
+      --xattrs, --inplace, --append, and --append-verify.
+
+    - Using --only-write-batch to a daemon receiver now works properly (older
+      versions would update some files while writing the batch).
+
+    - Avoid outputting a "file has vanished" message when the file is a broken
+      symlink and --copy-unsafe-links or --copy-dirlinks is used (the code
+      already handled this for --copy-links).
+
+    - Fixed the combination of --only-write-batch and --dry-run.
+
+    - Fixed rsync's ability to remove files that are not writable by the file's
+      owner when rsync is running as the same user.
+
+  ENHANCEMENTS:
+
+    - A new incremental-recursion algorithm is now used when rsync is talking
+      to another 3.x version.  This starts the transfer going more quickly
+      (before all the files have been found), and requires much less memory.
+      See the --recursive option in the manpage for some restrictions.
+
+    - Lowered memory use in the non-incremental-recursion algorithm for typical
+      option values (usually saving from 21-29 bytes per file).
+
+    - The default --delete algorithm is now --delete-during when talking to a
+      3.x rsync.  This is a faster scan than using --delete-before (which is
+      the default when talking to older rsync versions), and is compatible with
+      the new incremental recursion mode.
+
+    - Rsync now allows multiple remote-source args to be specified rather than
+      having to rely on a special space-splitting side-effect of the remote-
+      shell.  Additional remote args must specify the same host or an empty one
+      (e.g. empty:  :file1  or  ::module/file2).  For example, this means that
+      local use of brace expansion now works:  rsync -av host:dir/{f1,f2} .
+
+    - Added the --protect-args (-s) option, that tells rsync to send most of
+      the command-line args at the start of the transfer rather than as args
+      to the remote-shell command.  This protects them from space-splitting,
+      and only interprets basic wildcard special shell characters (*?[).
+
+    - Added the --delete-delay option, which is a more efficient way to delete
+      files at the end of the transfer without needing a separate delete pass.
+
+    - Added the --acls (-A) option to preserve Access Control Lists.  This is
+      an improved version of the prior patch that was available, and it even
+      supports OS X ACLs.  If you need to have backward compatibility with old,
+      ACL-patched versions of rsync, apply the acls.diff file from the patches
+      dir.
+
+    - Added the --xattrs (-X) option to preserve extended attributes.  This is
+      an improved version of the prior patch that was available, and it even
+      supports OS X xattrs (which includes their resource fork data).  If you
+      need to have backward compatibility with old, xattr-patched versions of
+      rsync, apply the xattrs.diff file from the patches dir.
+
+    - Added the --fake-super option that allows a non-super user to preserve
+      all attributes of a file by using a special extended-attribute idiom.
+      It even supports the storing of foreign ACL data on your backup server.
+      There is also an analogous "fake super" parameter for an rsync daemon.
+
+    - Added the --iconv option, which allows rsync to convert filenames from
+      one character-set to another during the transfer.  The default is to
+      make this feature available as long as your system has iconv_open().
+      If compilation fails, specify --disable-iconv to configure, and then
+      rebuild.  If you want rsync to perform character-set conversions by
+      default, you can specify --enable-iconv=CONVERT_STRING with the default
+      value for the --iconv option that you wish to use.  For example,
+      "--enable-iconv=." is a good choice.  See the rsync manpage for an
+      explanation of the --iconv option's settings.
+
+    - A new daemon config parameter, "charset", lets you control the character-
+      set that is used during an --iconv transfer to/from a daemon module.  You
+      can also set your daemon to refuse "no-iconv" if you want to force the
+      client to use an --iconv transfer (requiring an rsync 3.x client).
+
+    - Added the --skip-compress=LIST option to override the default list of
+      file suffixes that will not be compressed when using --compress (-z).
+
+    - The daemon's default for "dont compress" was extended to include:
+	  *.7z *.mp[34] *.mov *.avi *.ogg *.jpg *.jpeg
+      The name-matching routine was also optimized to run more quickly.
+
+    - The --max-delete option now outputs a warning if it skipped any file
+      deletions, including a count of how many deletions were skipped.  (Older
+      versions just silently stopped deleting things.)
+
+    - You may specify --max-delete=0 to a 3.0.0 client to request that it warn
+      about extraneous files without deleting anything.  If you're not sure
+      what version the client is, you can use the less-obvious --max-delete=-1,
+      as both old and new versions will treat that as the same request (though
+      older versions don't warn).
+
+    - The --hard-link option now uses less memory on both the sending and
+      receiving side for all protocol versions.  For protocol 30, the use of a
+      hashtable on the sending side allows us to more efficiently convey to the
+      receiver what files are linked together.  This reduces the amount of data
+      sent over the socket by a considerable margin (rather than adding more
+      data), and limits the in-memory storage of the device+inode information
+      to just the sending side for the new protocol 30, or to the receiving
+      side when speaking an older protocol (note that older rsync versions kept
+      the device+inode information on both sides).
+
+    - The filter rules now support a perishable ("p") modifier that marks rules
+      that should not have an effect in a directory that is being deleted.  e.g.
+      -f '-p .svn/' would only affect "live" .svn directories.
+
+    - Rsync checks all the alternate-destination args for validity (e.g.
+      --link-dest).  This lets the user know when they specified a directory
+      that does not exist.
+
+    - If we get an ENOSYS error setting the time on a symlink, we don't
+      complain about it anymore (for those systems that even support the
+      setting of the modify-time on a symlink).
+
+    - Protocol 30 now uses MD5 checksums instead of MD4.
+
+    - Changed the --append option to not checksum the existing data in the
+      destination file, which speeds up file appending.
+
+    - Added the --append-verify option, which works like the older --append
+      option (verifying the existing data in the destination file).  For
+      compatibility with older rsync versions, any use of --append that is
+      talking protocol 29 or older will revert to the --append-verify method.
+
+    - Added the --contimeout=SECONDS option that lets the user specify a
+      connection timeout for rsync daemon access.
+
+    - Documented and extended the support for the RSYNC_CONNECT_PROG variable
+      that can be used to enhance the client side of a daemon connection.
+
+    - Improved the dashes and double-quotes in the nroff manpage output.
+
+    - Rsync now supports a lot more --no-OPTION override options.
+
+  INTERNAL:
+
+    - The file-list sorting algorithm now uses a sort that keeps any same-
+      named items in the same order as they were specified.  This allows
+      rsync to always ensure that the first of the duplicates is the one
+      that will be included in the copy.  The new sort is also faster
+      than the glibc version of qsort() and mergesort().
+
+    - Rsync now supports the transfer of 64-bit timestamps (time_t values).
+
+    - Made the file-deletion code use a little less stack when recursing
+      through a directory hierarchy of extraneous files.
+
+    - Fixed a build problem with older (2.x) versions of gcc.
+
+    - Added some isType() functions that make dealing with signed characters
+      easier without forcing variables via casts.
+
+    - Changed strcat/strcpy/sprintf function calls to use safer versions.
+
+    - Upgraded the included popt version to 1.10.2 and improved its use of
+      string-handling functions.
+
+    - Added missing prototypes for compatibility functions from the lib dir.
+
+    - Configure determines if iconv() has a const arg, allowing us to avoid a
+      compiler warning.
+
+    - Made the sending of some numbers more efficient for protocol 30.
+
+    - Make sure that a daemon process doesn't mind if the client was weird and
+      omitted the --server option.
+
+    - There are more internal logging categories available in protocol 30 than
+      the age-old FINFO and FERROR, including FERROR_XFER and FWARN.  These new
+      categories allow some errors and warnings to go to stderr without causing
+      an erroneous end-of-run warning about some files not being able to be
+      transferred.
+
+    - Improved the use of "const" on pointers.
+
+    - Improved J.W.'s pool_alloc routines to add a way of incrementally freeing
+      older sections of a pool's memory.
+
+    - The getaddrinfo.c compatibility code in the "lib" dir was replaced with
+      some new code (derived from samba, derived from PostgreSQL) that has a
+      better license than the old code.
+
+  DEVELOPER RELATED:
+
+    - Rsync is now licensed under the GPLv3 or later.
+
+    - Rsync is now being maintained in a "git" repository instead of CVS
+      (though the old CVS repository still exists for historical access).
+      Several maintenance scripts were updated to work with git.
+
+    - Generated files are no longer committed into the source repository.  The
+      autoconf and autoheader commands are now automatically run during the
+      normal use of "configure" and "make".  The latest dev versions of all
+      generated files can also be copied from the samba.org web site (see the
+      prepare-source script's fetch option).
+
+    - The "patches" directory of diff files is now built from branches in the
+      rsync git repository (branch patch/FOO creates file patches/FOO.diff).
+      This directory is now distributed in a separate separate tar file named
+      rsync-patches-VERSION.tar.gz instead of the main rsync-VERSION.tar.gz.
+
+    - The proto.h file is now built using a simple perl script rather than a
+      complex awk script, which proved to be more widely compatible.
+
+    - When running the tests, we now put our per-test temp dirs into a sub-
+      directory named testtmp (which is created, if missing).  This allows
+      someone to symlink the testtmp directory to another filesystem (which is
+      useful if the build dir's filesystem does not support ACLs and xattrs,
+      but another filesystem does).
+
+    - Rsync now has a way of handling protocol-version changes during the
+      development of a new protocol version.  This causes any out-of-sync
+      versions to speak an older protocol rather than fail in a cryptic manner.
+      This addition makes it safer to deploy a pre-release version that may
+      interact with the public.  This new exchange of sub-version info does not
+      interfere with the {MIN,MAX}_PROTOCOL_VERSION checking algorithm (which
+      does not have enough range to allow the main protocol number to be
+      incremented for every minor tweak in that happens during development).
+
+    - The csprotocol.txt file was updated to mention the daemon protocol change
+      in the 3.0.0 release.
+
+
 NEWS for rsync 2.6.9 (6 Nov 2006)
 Protocol: 29 (unchanged)
 Changes since 2.6.8:
 
   BUG FIXES:
 
@@ -2241,12 +2584,13 @@
     * The existing test.sh script by Phil Hands has been merged into a
       test framework that works from both "make check" and the Samba
       build farm.
 
 Partial Protocol History
 	RELEASE DATE	VER.	DATE OF COMMIT*	PROTOCOL
+	03 Apr 2008	3.0.1			30
 	01 Mar 2008	3.0.0	11 Nov 2006	30
 	06 Nov 2006	2.6.9			29
 	22 Apr 2006	2.6.8			29
 	11 Mar 2006	2.6.7			29
 	28 Jul 2005	2.6.6			29
 	01 Jun 2005	2.6.5			29
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/options.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/options.c	2008-03-30 23:05:50.000000000 +0800
@@ -22,17 +22,18 @@
 #include "rsync.h"
 #include "ifuncs.h"
 #include <popt.h>
 #include "zlib/zlib.h"
 
 extern int module_id;
+extern int local_server;
 extern int sanitize_paths;
 extern int daemon_over_rsh;
 extern unsigned int module_dirlen;
 extern struct filter_list_struct filter_list;
-extern struct filter_list_struct server_filter_list;
+extern struct filter_list_struct daemon_filter_list;
 
 int make_backups = 0;
 
 /**
  * If 1, send the whole file as literal data rather than trying to
  * create an incremental diff.
@@ -256,13 +257,13 @@
 #if defined HAVE_LUTIMES && defined HAVE_UTIMES
 	symtimes = "";
 #endif
 
 	rprintf(f, "%s  version %s  protocol version %d%s\n",
 		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION, subprotocol);
-	rprintf(f, "Copyright (C) 1996-2007 by Andrew Tridgell, Wayne Davison, and others.\n");
+	rprintf(f, "Copyright (C) 1996-2008 by Andrew Tridgell, Wayne Davison, and others.\n");
 	rprintf(f, "Web site: http://rsync.samba.org/\n");
 	rprintf(f, "Capabilities:\n");
 	rprintf(f, "    %d-bit files, %d-bit inums, %d-bit timestamps, %d-bit long ints,\n",
 		(int)(sizeof (OFF_T) * 8),
 		(int)(sizeof dumstat->st_ino * 8), /* Don't check ino_t! */
 		(int)(sizeof (time_t) * 8),
@@ -471,12 +472,14 @@
   {"no-inc-recursive", 0,  POPT_ARG_VAL,    &allow_inc_recurse, 0, 0, 0 },
   {"i-r",              0,  POPT_ARG_VAL,    &allow_inc_recurse, 1, 0, 0 },
   {"no-i-r",           0,  POPT_ARG_VAL,    &allow_inc_recurse, 0, 0, 0 },
   {"dirs",            'd', POPT_ARG_VAL,    &xfer_dirs, 2, 0, 0 },
   {"no-dirs",          0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },
   {"no-d",             0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },
+  {"old-dirs",         0,  POPT_ARG_VAL,    &xfer_dirs, 4, 0, 0 },
+  {"old-d",            0,  POPT_ARG_VAL,    &xfer_dirs, 4, 0, 0 },
   {"perms",           'p', POPT_ARG_VAL,    &preserve_perms, 1, 0, 0 },
   {"no-perms",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
   {"no-p",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
   {"executability",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },
   {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
   {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
@@ -533,28 +536,33 @@
   {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
   {"existing",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
   {"ignore-non-existing",0,POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
   {"ignore-existing",  0,  POPT_ARG_NONE,   &ignore_existing, 0, 0, 0 },
   {"max-size",         0,  POPT_ARG_STRING, &max_size_arg, OPT_MAX_SIZE, 0, 0 },
   {"min-size",         0,  POPT_ARG_STRING, &min_size_arg, OPT_MIN_SIZE, 0, 0 },
-  {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
-  {"inplace",          0,  POPT_ARG_NONE,   &inplace, 0, 0, 0 },
+  {"sparse",          'S', POPT_ARG_VAL,    &sparse_files, 1, 0, 0 },
+  {"no-sparse",        0,  POPT_ARG_VAL,    &sparse_files, 0, 0, 0 },
+  {"no-S",             0,  POPT_ARG_VAL,    &sparse_files, 0, 0, 0 },
+  {"inplace",          0,  POPT_ARG_VAL,    &inplace, 1, 0, 0 },
+  {"no-inplace",       0,  POPT_ARG_VAL,    &inplace, 0, 0, 0 },
   {"append",           0,  POPT_ARG_NONE,   0, OPT_APPEND, 0, 0 },
   {"append-verify",    0,  POPT_ARG_VAL,    &append_mode, 2, 0, 0 },
   {"no-append",        0,  POPT_ARG_VAL,    &append_mode, 0, 0, 0 },
   {"del",              0,  POPT_ARG_NONE,   &delete_during, 0, 0, 0 },
   {"delete",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },
   {"delete-before",    0,  POPT_ARG_NONE,   &delete_before, 0, 0, 0 },
   {"delete-during",    0,  POPT_ARG_VAL,    &delete_during, 1, 0, 0 },
   {"delete-delay",     0,  POPT_ARG_VAL,    &delete_during, 2, 0, 0 },
   {"delete-after",     0,  POPT_ARG_NONE,   &delete_after, 0, 0, 0 },
   {"delete-excluded",  0,  POPT_ARG_NONE,   &delete_excluded, 0, 0, 0 },
   {"remove-sent-files",0,  POPT_ARG_VAL,    &remove_source_files, 2, 0, 0 }, /* deprecated */
   {"remove-source-files",0,POPT_ARG_VAL,    &remove_source_files, 1, 0, 0 },
-  {"force",            0,  POPT_ARG_NONE,   &force_delete, 0, 0, 0 },
-  {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
+  {"force",            0,  POPT_ARG_VAL,    &force_delete, 1, 0, 0 },
+  {"no-force",         0,  POPT_ARG_VAL,    &force_delete, 0, 0, 0 },
+  {"ignore-errors",    0,  POPT_ARG_VAL,    &ignore_errors, 1, 0, 0 },
+  {"no-ignore-errors", 0,  POPT_ARG_VAL,    &ignore_errors, 0, 0, 0 },
   {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
   {0,                 'F', POPT_ARG_NONE,   0, 'F', 0, 0 },
   {"filter",          'f', POPT_ARG_STRING, 0, OPT_FILTER, 0, 0 },
   {"exclude",          0,  POPT_ARG_STRING, 0, OPT_EXCLUDE, 0, 0 },
   {"include",          0,  POPT_ARG_STRING, 0, OPT_INCLUDE, 0, 0 },
   {"exclude-from",     0,  POPT_ARG_STRING, 0, OPT_EXCLUDE_FROM, 0, 0 },
@@ -567,27 +575,31 @@
   {"no-checksum",      0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
   {"no-c",             0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
-  {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
+  {"fuzzy",           'y', POPT_ARG_VAL,    &fuzzy_basis, 1, 0, 0 },
+  {"no-fuzzy",         0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
+  {"no-y",             0,  POPT_ARG_VAL,    &fuzzy_basis, 0, 0, 0 },
   {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
   {"no-compress",      0,  POPT_ARG_VAL,    &do_compression, 0, 0, 0 },
-  {"skip-compress",    0,  POPT_ARG_STRING, &skip_compress, 0, 0, 0 },
   {"no-z",             0,  POPT_ARG_VAL,    &do_compression, 0, 0, 0 },
+  {"skip-compress",    0,  POPT_ARG_STRING, &skip_compress, 0, 0, 0 },
   {"compress-level",   0,  POPT_ARG_INT,    &def_compress_level, 'z', 0, 0 },
   {0,                 'P', POPT_ARG_NONE,   0, 'P', 0, 0 },
   {"progress",         0,  POPT_ARG_VAL,    &do_progress, 1, 0, 0 },
   {"no-progress",      0,  POPT_ARG_VAL,    &do_progress, 0, 0, 0 },
   {"partial",          0,  POPT_ARG_VAL,    &keep_partial, 1, 0, 0 },
   {"no-partial",       0,  POPT_ARG_VAL,    &keep_partial, 0, 0, 0 },
   {"partial-dir",      0,  POPT_ARG_STRING, &partial_dir, 0, 0, 0 },
   {"delay-updates",    0,  POPT_ARG_VAL,    &delay_updates, 1, 0, 0 },
   {"no-delay-updates", 0,  POPT_ARG_VAL,    &delay_updates, 0, 0, 0 },
-  {"prune-empty-dirs",'m', POPT_ARG_NONE,   &prune_empty_dirs, 0, 0, 0 },
+  {"prune-empty-dirs",'m', POPT_ARG_VAL,    &prune_empty_dirs, 1, 0, 0 },
+  {"no-prune-empty-dirs",0,POPT_ARG_VAL,    &prune_empty_dirs, 0, 0, 0 },
+  {"no-m",             0,  POPT_ARG_VAL,    &prune_empty_dirs, 0, 0, 0 },
   {"log-file",         0,  POPT_ARG_STRING, &logfile_name, 0, 0, 0 },
   {"log-file-format",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },
   {"out-format",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 },
   {"log-format",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 }, /* DEPRECATED */
   {"itemize-changes", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },
   {"no-itemize-changes",0, POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },
@@ -610,22 +622,25 @@
   {"no-s",             0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},
   {"numeric-ids",      0,  POPT_ARG_VAL,    &numeric_ids, 1, 0, 0 },
   {"no-numeric-ids",   0,  POPT_ARG_VAL,    &numeric_ids, 0, 0, 0 },
   {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
   {"no-timeout",       0,  POPT_ARG_VAL,    &io_timeout, 0, 0, 0 },
   {"contimeout",       0,  POPT_ARG_INT,    &connect_timeout, 0, 0, 0 },
+  {"no-contimeout",    0,  POPT_ARG_VAL,    &connect_timeout, 0, 0, 0 },
   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
   {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
 #ifdef ICONV_OPTION
   {"iconv",            0,  POPT_ARG_STRING, &iconv_opt, 0, 0, 0 },
   {"no-iconv",         0,  POPT_ARG_NONE,   0, OPT_NO_ICONV, 0, 0 },
 #endif
   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
-  {"8-bit-output",    '8', POPT_ARG_NONE,   &allow_8bit_chars, 0, 0, 0 },
+  {"8-bit-output",    '8', POPT_ARG_VAL,    &allow_8bit_chars, 1, 0, 0 },
+  {"no-8-bit-output",  0,  POPT_ARG_VAL,    &allow_8bit_chars, 0, 0, 0 },
+  {"no-8",             0,  POPT_ARG_VAL,    &allow_8bit_chars, 0, 0, 0 },
   {"qsort",            0,  POPT_ARG_NONE,   &use_qsort, 0, 0, 0 },
   {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
   {"sockopts",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },
   {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
@@ -874,26 +889,28 @@
  *
  * @retval 1 if all options are OK; with globals set to appropriate
  * values
  *
  * @retval 0 on error, with err_buf containing an explanation
  **/
-int parse_arguments(int *argc_p, const char ***argv_p, int frommain)
+int parse_arguments(int *argc_p, const char ***argv_p)
 {
 	static poptContext pc;
 	char *ref = lp_refuse_options(module_id);
 	const char *arg, **argv = *argv_p;
 	int argc = *argc_p;
 	int opt;
 
 	if (ref && *ref)
 		set_refuse_options(ref);
 	if (am_daemon) {
 		set_refuse_options("log-file*");
+#ifdef ICONV_OPTION
 		if (!*lp_charset(module_id))
 			set_refuse_options("iconv");
+#endif
 	}
 
 #ifdef ICONV_OPTION
 	if (!am_daemon && !protect_args && (arg = getenv("RSYNC_ICONV")) != NULL && *arg)
 		iconv_opt = strdup(arg);
 #endif
@@ -1014,23 +1031,23 @@
 			break;
 
 		case OPT_EXCLUDE_FROM:
 		case OPT_INCLUDE_FROM:
 			arg = poptGetOptArg(pc);
 			if (sanitize_paths)
-				arg = sanitize_path(NULL, arg, NULL, 0);
-			if (server_filter_list.head) {
+				arg = sanitize_path(NULL, arg, NULL, 0, SP_DEFAULT);
+			if (daemon_filter_list.head) {
 				int rej;
 				char *dir, *cp = strdup(arg);
 				if (!cp)
 					out_of_memory("parse_arguments");
 				if (!*cp)
 					goto options_rejected;
 				dir = cp + (*cp == '/' ? module_dirlen : 0);
 				clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
-				rej = check_filter(&server_filter_list, dir, 0) < 0;
+				rej = check_filter(&daemon_filter_list, FLOG, dir, 0) < 0;
 				free(cp);
 				if (rej)
 					goto options_rejected;
 			}
 			parse_filter_file(&filter_list, arg,
 				opt == OPT_INCLUDE_FROM ? MATCHFLG_INCLUDE : 0,
@@ -1077,14 +1094,13 @@
 
 		case 'v':
 			verbose++;
 			break;
 
 		case 'q':
-			if (frommain)
-				quiet++;
+			quiet++;
 			break;
 
 		case 'x':
 			one_file_system++;
 			break;
 
@@ -1256,13 +1272,13 @@
 				 poptBadOption(pc, POPT_BADOPTION_NOALIAS),
 				 poptStrerror(opt));
 			return 0;
 		}
 	}
 
-	if (human_readable && argc == 2) {
+	if (human_readable && argc == 2 && !am_server) {
 		/* Allow the old meaning of 'h' (--help) on its own. */
 		usage(FINFO);
 		exit_cleanup(0);
 	}
 
 #ifdef ICONV_OPTION
@@ -1275,18 +1291,17 @@
 	if (refused_no_iconv && !iconv_opt) {
 		create_refuse_error(refused_no_iconv);
 		return 0;
 	}
 #endif
 
-	if (protect_args == 1) {
-		if (!frommain)
-			protect_args = 0;
-		else if (am_server)
-			return 1;
-	}
+	if (protect_args == 1 && am_server)
+		return 1;
+
+	*argv_p = argv = poptGetArgs(pc);
+	*argc_p = argc = count_args(argv);
 
 #ifndef SUPPORT_LINKS
 	if (preserve_links && !am_sender) {
 		snprintf(err_buf, sizeof err_buf,
 			 "symlinks are not supported on this %s\n",
 			 am_server ? "server" : "client");
@@ -1300,13 +1315,19 @@
 			 "hard links are not supported on this %s\n",
 			 am_server ? "server" : "client");
 		return 0;
 	}
 #endif
 
-#ifndef SUPPORT_XATTRS
+#ifdef SUPPORT_XATTRS
+	if (am_root < 0 && preserve_xattrs > 1) {
+		snprintf(err_buf, sizeof err_buf,
+			 "--fake-super conflicts with -XX\n");
+		return 0;
+	}
+#else
 	if (am_root < 0) {
 		snprintf(err_buf, sizeof err_buf,
 			 "--fake-super requires an rsync with extended attributes enabled\n");
 		return 0;
 	}
 #endif
@@ -1363,14 +1384,22 @@
 		if (recurse == 1) /* preserve recurse == 2 */
 			recurse = 0;
 		if (xfer_dirs < 0)
 			xfer_dirs = 1;
 	}
 
-	if (xfer_dirs < 1)
-		xfer_dirs = recurse || list_only;
+	if (argc < 2 && !read_batch && !am_server)
+		list_only |= 1;
+
+	if (xfer_dirs >= 4) {
+		parse_rule(&filter_list, "- /*/*", 0, 0);
+		recurse = xfer_dirs = 1;
+	} else if (recurse)
+		xfer_dirs = 1;
+	else if (xfer_dirs < 0)
+		xfer_dirs = list_only ? 1 : 0;
 
 	if (relative_paths < 0)
 		relative_paths = files_from? 1 : 0;
 	if (!relative_paths)
 		implied_dirs = 0;
 
@@ -1413,42 +1442,39 @@
 			create_refuse_error(refused_delete);
 			return 0;
 		}
 		need_messages_from_generator = 1;
 	}
 
-	*argv_p = argv = poptGetArgs(pc);
-	*argc_p = argc = count_args(argv);
-
 	if (sanitize_paths) {
 		int i;
 		for (i = argc; i-- > 0; )
-			argv[i] = sanitize_path(NULL, argv[i], "", 0);
+			argv[i] = sanitize_path(NULL, argv[i], "", 0, SP_KEEP_DOT_DIRS);
 		if (tmpdir)
-			tmpdir = sanitize_path(NULL, tmpdir, NULL, 0);
+			tmpdir = sanitize_path(NULL, tmpdir, NULL, 0, SP_DEFAULT);
 		if (backup_dir)
-			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0);
+			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0, SP_DEFAULT);
 	}
-	if (server_filter_list.head && !am_sender) {
-		struct filter_list_struct *elp = &server_filter_list;
+	if (daemon_filter_list.head && !am_sender) {
+		struct filter_list_struct *elp = &daemon_filter_list;
 		if (tmpdir) {
 			char *dir;
 			if (!*tmpdir)
 				goto options_rejected;
 			dir = tmpdir + (*tmpdir == '/' ? module_dirlen : 0);
 			clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
-			if (check_filter(elp, dir, 1) < 0)
+			if (check_filter(elp, FLOG, dir, 1) < 0)
 				goto options_rejected;
 		}
 		if (backup_dir) {
 			char *dir;
 			if (!*backup_dir)
 				goto options_rejected;
 			dir = backup_dir + (*backup_dir == '/' ? module_dirlen : 0);
 			clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
-			if (check_filter(elp, dir, 1) < 0)
+			if (check_filter(elp, FLOG, dir, 1) < 0)
 				goto options_rejected;
 		}
 	}
 
 	if (!backup_suffix)
 		backup_suffix = backup_dir ? "" : BACKUP_SUFFIX;
@@ -1631,20 +1657,20 @@
 				snprintf(err_buf, sizeof err_buf,
 					"Invalid --files-from remote filename\n");
 				return 0;
 			}
 		} else {
 			if (sanitize_paths)
-				files_from = sanitize_path(NULL, files_from, NULL, 0);
-			if (server_filter_list.head) {
+				files_from = sanitize_path(NULL, files_from, NULL, 0, SP_DEFAULT);
+			if (daemon_filter_list.head) {
 				char *dir;
 				if (!*files_from)
 					goto options_rejected;
 				dir = files_from + (*files_from == '/' ? module_dirlen : 0);
 				clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
-				if (check_filter(&server_filter_list, dir, 0) < 0)
+				if (check_filter(&daemon_filter_list, FLOG, dir, 0) < 0)
 					goto options_rejected;
 			}
 			filesfrom_fd = open(files_from, O_RDONLY|O_BINARY);
 			if (filesfrom_fd < 0) {
 				snprintf(err_buf, sizeof err_buf,
 					"failed to open files-from file %s: %s\n",
@@ -1708,14 +1734,14 @@
 	if (update_only)
 		argstr[x++] = 'u';
 	if (!do_xfers) /* Note: NOT "dry_run"! */
 		argstr[x++] = 'n';
 	if (preserve_links)
 		argstr[x++] = 'l';
-	if ((list_only && !recurse) || xfer_dirs > 1
-	 || (xfer_dirs && !recurse && delete_mode && am_sender))
+	if ((xfer_dirs >= 2 && xfer_dirs < 4)
+	 || (xfer_dirs && !recurse && (list_only || (delete_mode && am_sender))))
 		argstr[x++] = 'd';
 	if (am_sender) {
 		if (keep_dirlinks)
 			argstr[x++] = 'K';
 		if (prune_empty_dirs)
 			argstr[x++] = 'm';
@@ -1812,13 +1838,13 @@
 		if (asprintf(&arg, "--iconv=%s", set) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 #endif
 
-	if (protect_args) /* initial args break here */
+	if (protect_args && !local_server) /* unprotected args stop here */
 		args[ac++] = NULL;
 
 	if (list_only > 1)
 		args[ac++] = "--list-only";
 
 	/* This makes sure that the remote rsync can handle deleting with -d
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/packaging: bin
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/lsb/rsync.spec	2008-03-02 04:12:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/packaging/lsb/rsync.spec	2008-04-04 13:37:01.000000000 +0800
@@ -1,12 +1,15 @@
 Summary: A fast, versatile, remote (and local) file-copying tool
 Name: rsync
-Version: 3.0.0
+Version: 3.0.1
+%define fullversion %{version}
 Release: 1
+%define srcdir src
 Group: Applications/Internet
-Source:	http://rsync.samba.org/ftp/rsync/rsync-%{version}.tar.gz
+Source0: http://rsync.samba.org/ftp/rsync/%{srcdir}/rsync-%{fullversion}.tar.gz
+Source1: http://rsync.samba.org/ftp/rsync/%{srcdir}/rsync-patches-%{fullversion}.tar.gz
 URL: http://rsync.samba.org/
 
 Prefix: %{_prefix}
 BuildRoot: /var/tmp/%{name}-root
 License: GPL
 
@@ -19,31 +22,50 @@
 which reduces the amount of data sent over the network by sending only the
 differences between the source files and the existing files in the
 destination.  Rsync is widely used for backups and mirroring and as an
 improved copy command for everyday use.
 
 %prep
-%setup -q
+# Choose one -- setup source only, or setup source + rsync-patches:
+%setup -q -n rsync-%{fullversion}
+#%setup -q -b1 -n rsync-%{fullversion}
+
+# If you you used "%setup -q -b1", choose the patches you wish to apply:
+#patch -p1 <patches/acls.diff
+#patch -p1 <patches/xattrs.diff
+#patch -p1 <patches/remote-option.diff
+#patch -p1 <patches/db.diff
 
 %build
+#./prepare-source
 %configure
 
 make
 
 %install
 rm -rf $RPM_BUILD_ROOT
 
 %makeinstall
 
+mkdir -p $RPM_BUILD_ROOT/etc/xinetd.d
+install -m 644 packaging/lsb/rsync.xinetd $RPM_BUILD_ROOT/etc/xinetd.d/rsync
+
+#install -p -m 755 support/rsyncdb $RPM_BUILD_ROOT/usr/bin/rsyncdb
+
 %clean
 rm -rf $RPM_BUILD_ROOT
 
 %files
 %defattr(-,root,root)
 %doc COPYING README tech_report.tex
-%{_prefix}/bin/rsync
+%config(noreplace) /etc/xinetd.d/rsync
+%{_prefix}/bin/rsync*
 %{_mandir}/man1/rsync.1*
 %{_mandir}/man5/rsyncd.conf.5*
 
 %changelog
-* Sat Mar 01 2008 Wayne Davison <wayned@samba.org>
-Released 3.0.0.
+* Thu Apr 03 2008 Wayne Davison <wayned@samba.org>
+Released 3.0.1.
+
+* Fri Mar 21 2008 Wayne Davison <wayned@samba.org>
+Added installation of /etc/xinetd.d/rsync file and some commented-out
+lines that demonstrate how to use the rsync-patches tar file.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/packaging/lsb: rsync.xinetd
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/nightly-rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/packaging/nightly-rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/nightly-rsync	2008-01-12 05:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/packaging/nightly-rsync	2008-03-08 08:25:05.000000000 +0800
@@ -11,14 +11,14 @@
 # HTML man pages in the nightly dir, and then rsync the changes to the
 # samba.org server.
 
 use Getopt::Long;
 use Date::Format;
 
-# Where the local copy of /home/ftp/pub/rsync/nightly should be updated.
-our $dest = $ENV{HOME} . '/samba-rsync-ftp/nightly';
+# Where the local copy of /home/ftp/pub/rsync/dev/nightly should be updated.
+our $dest = $ENV{HOME} . '/samba-rsync-ftp/dev/nightly';
 our $nightly_symlink = "$dest/rsync-HEAD.tar.gz";
 
 our($make_tar, $upload, $help_opt);
 &Getopt::Long::Configure('bundling');
 &usage if !&GetOptions(
     'make-tar|t' => \$make_tar,
@@ -101,13 +101,13 @@
 
 if ($upload) {
     my $opt = '';
     if (defined $ENV{RSYNC_PARTIAL_DIR}) {
 	$opt = " -f 'R $ENV{RSYNC_PARTIAL_DIR}'";
     }
-    system "rsync$opt -aviHP --delete-after . samba.org:/home/ftp/pub/rsync/nightly";
+    system "rsync$opt -aviHP --delete-after . samba.org:/home/ftp/pub/rsync/dev/nightly";
 }
 
 exit;
 
 sub usage
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/release-rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/packaging/release-rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/release-rsync	2008-03-02 04:00:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/packaging/release-rsync	2008-04-02 03:55:27.000000000 +0800
@@ -4,22 +4,31 @@
 # This script expects the directory ~/samba-rsync-ftp to exist and to be a
 # copy of the /home/ftp/pub/rsync dir on samba.org.  When the script is done,
 # the git repository in the current directory will be updated, and the local
 # ~/samba-rsync-ftp dir will be ready to be rsynced to samba.org.
 
 use Cwd;
+use Term::ReadKey;
 use Date::Format;
 
 my $dest = $ENV{HOME} . '/samba-rsync-ftp';
+my $passfile = $ENV{HOME} . '/.rsyncpass';
+my $path = $ENV{PATH};
 
-my $cl_today = time2str('* %a %b %d %Y', time);
-my $ztoday = time2str('%d %b %Y', time);
+my $now = time;
+my $cl_today = time2str('* %a %b %d %Y', $now);
+my $year = time2str('%Y', $now);
+my $ztoday = time2str('%d %b %Y', $now);
 (my $today = $ztoday) =~ s/^0//;
 
 my $curdir = Cwd::cwd;
 
+END {
+    unlink($passfile);
+}
+
 my @extra_files;
 open(IN, '<', 'Makefile.in') or die "Couldn't open Makefile.in: $!\n";
 while (<IN>) {
     if (s/^GENFILES=//) {
 	while (s/\\$//) {
 	    $_ .= <IN>;
@@ -46,114 +55,151 @@
 open(IN, '-|', 'git status') or die $!;
 my $status = join('', <IN>);
 close IN;
 die "The checkout is not clean:\n", $status unless $status =~ /\nnothing to commit \(working directory clean\)/;
 die "The checkout is not on the master branch.\n" unless $status =~ /^# On branch master\n/;
 
-my $lastversion;
+my $confversion;
 open(IN, '<', 'configure.in') or die $!;
 while (<IN>) {
     if (/^RSYNC_VERSION=(.*)/) {
-	$lastversion = $1;
+	$confversion = $1;
 	last;
     }
 }
 close IN;
+die "Unable to find RSYNC_VERSION in configure.in\n" unless defined $confversion;
 
 open(IN, '<', 'OLDNEWS') or die $!;
 $_ = <IN>;
 close IN;
-my($lastrelease) = /(\d+\.\d+\.\d+)/;
+my($lastversion) = /(\d+\.\d+\.\d+)/;
 
-$lastversion = $lastrelease if $lastversion =~ /dev$/;
-my $version = $lastversion;
+my $version = $confversion;
 $version =~ s/dev/pre1/ || $version =~ s/pre(\d+)/ 'pre' . ($1 + 1) /e;
 
 print "Please enter the version number of this release: [$version] ";
 chomp($_ = <STDIN>);
 if ($_ eq '.') {
     $version =~ s/pre\d+//;
 } elsif ($_ ne '') {
     $version = $_;
 }
-$lastversion = $lastrelease unless $version =~ s/[-.]*pre[-.]*/pre/;
+die "Invalid version: `$version'\n" unless $version =~ /^[\d.]+(pre\d+)?$/;
+
+if (`git tag -l v$version` ne '') {
+    print "Tag v$version already exists.\n\nDelete tag or quit? [q/del] ";
+    $_ = <STDIN>;
+    exit 1 unless /^del/i;
+    system "git tag -d v$version";
+}
+
+if ($version =~ s/[-.]*pre[-.]*/pre/ && $confversion !~ /dev$/) {
+    $lastversion = $confversion;
+}
 
 print "Enter the previous version to produce a patch against: [$lastversion] ";
 chomp($_ = <STDIN>);
 $lastversion = $_ if $_ ne '';
 $lastversion =~ s/[-.]*pre[-.]*/pre/;
 
-my $release = 1;
+my $pre = $version =~ /(pre\d+)/ ? $1 : '';
+
+my $release = $pre ? '0.1' : '1';
 print "Please enter the RPM release number of this release: [$release] ";
 chomp($_ = <STDIN>);
 $release = $_ if $_ ne '';
+$release .= ".$pre" if $pre;
 
-my $diffdir;
-my $skipping;
+my($srcdir,$srcdiffdir,$lastsrcdir,$skipping);
 if ($lastversion =~ /pre/) {
-    if ($version !~ /pre/) {
+    if (!$pre) {
 	die "You should not diff a release version against a pre-release version.\n";
     }
-    $diffdir = "$dest/old-previews";
+    $srcdir = $srcdiffdir = $lastsrcdir = 'src-previews';
     $skipping = ' ** SKIPPING **';
-} elsif ($version =~ /pre/) {
-    $diffdir = $dest;
+} elsif ($pre) {
+    $srcdir = $srcdiffdir = 'src-previews';
+    $lastsrcdir = 'src';
     $skipping = ' ** SKIPPING **';
 } else {
-    $diffdir = "$dest/old-versions";
+    $srcdir = $lastsrcdir = 'src';
+    $srcdiffdir = 'src-diffs';
     $skipping = '';
 }
 
 print "\n", $break, <<EOT;
 \$version is "$version"
 \$lastversion is "$lastversion"
 \$dest is "$dest"
 \$curdir is "$curdir"
-\$diffdir is "$diffdir"
+\$srcdir is "$srcdir"
+\$srcdiffdir is "$srcdiffdir"
+\$lastsrcdir is "$lastsrcdir"
 \$release is "$release"
 
 About to:
     - make sure that SUBPROTOCOL_VERSION is 0$skipping
     - tweak the version in configure.in and the spec files
     - tweak NEWS and OLDNEWS to update the release date$skipping
-    - tweak the date in the *.yo files and generate the man pages
+    - tweak the date in the *.yo files and generate the manpages
     - generate configure.sh, config.h.in, and proto.h
     - page through the differences
 
 EOT
 print "<Press Enter to continue> ";
 $_ = <STDIN>;
 
-my @tweak_files = ( glob('packaging/*.spec'), glob('packaging/*/*.spec'),
-		    glob('*.yo'), qw( configure.in ) );
+(my $finalversion = $version) =~ s/pre\d+//;
+my %specvars = ( 'Version:' => $finalversion, 'Release:' => $release,
+		 '%define fullversion' => "\%{version}$pre", 'Released' => "$version.",
+		 '%define srcdir' => $srcdir );
+my @tweak_files = ( glob('packaging/*.spec'), glob('packaging/*/*.spec'), glob('*.yo'),
+		    qw( configure.in rsync.h NEWS OLDNEWS options.c ) );
 
-if ($version !~ /pre/) {
-    push(@tweak_files, qw( rsync.h NEWS OLDNEWS ));
-}
 foreach my $fn (@tweak_files) {
     open(IN, '<', $fn) or die $!;
     undef $/; $_ = <IN>; $/ = "\n";
     close IN;
     if ($fn =~ /configure/) {
-	s/^RSYNC_VERSION=.*/RSYNC_VERSION=$version/m;
+	s/^RSYNC_VERSION=.*/RSYNC_VERSION=$version/m
+	    or die "Unable to update RSYNC_VERSION in $fn\n";
     } elsif ($fn =~ /\.spec/) {
-	s/^(Version:) .*/$1 $version/m;
-	s/^(Release:) .*/$1 $release/m;
-	s/^(Released) .*/$1 $version./m;
-	s/^\* \w\w\w \w\w\w \d\d \d\d\d\d (.*)/$cl_today $1/m;
+	while (my($str, $val) = each %specvars) {
+	    s/^\Q$str\E .*/$str $val/m
+		or die "Unable to update $str in $fn\n";
+	}
+	s/^\* \w\w\w \w\w\w \d\d \d\d\d\d (.*)/$cl_today $1/m
+	    or die "Unable to update ChangeLog header in $fn\n";
     } elsif ($fn =~ /\.yo/) {
-	s/^(manpage\([^)]+\)\(\d+\)\()[^)]+(\).*)/$1$today$2/m;
-	s/^(This man ?page is current for version) \S+ (of rsync)/$1 $version $2/m;
-    } elsif ($fn eq 'NEWS') {
-	s/^(NEWS for rsync \Q$version\E) \(UNRELEASED\)\s*\n/$1 ($today)\n/mi
-	    or die "Couldn't update NEWS file with release date!\n";
+	s/^(manpage\([^)]+\)\(\d+\)\()[^)]+(\).*)/$1$today$2/m
+	    or die "Unable to update date in manpage() header in $fn\n";
+	s/^(This man ?page is current for version) \S+ (of rsync)/$1 $version $2/m
+	    or die "Unable to update current version info in $fn\n";
     } elsif ($fn eq 'rsync.h') {
-	s/(#define\s+SUBPROTOCOL_VERSION)\s+\d+/$1 0/;
+	s/(#define\s+SUBPROTOCOL_VERSION)\s+\d+/$1 0/
+	    or die "Unable to find SUBPROTOCOL_VERSION define in $fn\n";
+	next if $pre;
+    } elsif ($fn eq 'NEWS') {
+	s/^(NEWS for rsync \Q$finalversion\E) \(UNRELEASED\)\s*\n/$1 ($today)\n/mi
+	    or die "The first line of $fn is not in the right format.  It must be:\n"
+		 . "NEWS for rsync $finalversion (UNRELEASED)\n";
+	next if $pre;
     } elsif ($fn eq 'OLDNEWS') {
-	s/^\t\S\S\s\S\S\S\s\d\d\d\d(\t\Q$version\E)/\t$ztoday$1/m
-	    or die "Couldn't update OLDNEWS file with release date!\n";
+	s/^\t\S\S\s\S\S\S\s\d\d\d\d(\t\Q$finalversion\E)/\t$ztoday$1/m
+	    or die "Unable to find \"?? ??? $year\t$finalversion\" line in $fn\n";
+	next if $pre;
+    } elsif ($fn eq 'options.c') {
+	if (s/(Copyright \(C\) 2002-)(\d+)( Wayne Davison)/$1$year$3/
+	 && $2 ne $year) {
+	    die "Copyright comments need to be updated to $year in all files!\n";
+	}
+	# Adjust the year in the --version output.
+	s/(rprintf\(f, "Copyright \(C\) 1996-)(\d+)/$1$year/
+	    or die "Unable to find Copyright string in --version output of $fn\n";
+	next if $2 eq $year;
     } else {
 	die "Unrecognized file in \@tweak_files: $fn\n";
     }
     open(OUT, '>', $fn) or die $!;
     print OUT $_;
     close OUT;
@@ -162,118 +208,138 @@
 print $break;
 system "git diff --color | less -p '^diff .*'";
 
 my $srctar_name = "rsync-$version.tar.gz";
 my $pattar_name = "rsync-patches-$version.tar.gz";
 my $diff_name = "rsync-$lastversion-$version.diffs.gz";
-my $srctar_file = "$dest/$srctar_name";
-my $pattar_file = "$dest/$pattar_name";
-my $diff_file = "$dest/$diff_name";
-my $lasttar_file = "$dest/rsync-$lastversion.tar.gz";
+my $srctar_file = "$dest/$srcdir/$srctar_name";
+my $pattar_file = "$dest/$srcdir/$pattar_name";
+my $diff_file = "$dest/$srcdiffdir/$diff_name";
+my $news_file = "$dest/$srcdir/rsync-$version-NEWS";
+my $lasttar_file = "$dest/$lastsrcdir/rsync-$lastversion.tar.gz";
 
 print $break, <<EOT;
 
 About to:
-    - commit all changes
-    - tag this release as v$version
-    - move the old tar/diff files into the appropriate old-* dirs
-    - hard-link the moved tar/diff files on samba.org
+    - commit all version changes
+    - merge the master branch into the patch/* branches
+    - update the files in the "patches" dir and OPTIONALLY
+      (if you type 'y') to launch a shell for each patch
+
+EOT
+print "<Press Enter OR 'y' to continue> ";
+my $ans = <STDIN>;
+
+system "git commit -a -m 'Preparing for release of $version'" and exit 1;
+
+print "Updating files in \"patches\" dir ...\n";
+system "support/patch-update";
+
+if ($ans =~ /^y/i) {
+    print "\nVisiting all \"patch/*\" branches ...\n";
+    system "support/patch-update --shell";
+}
+
+print $break, <<EOT;
+
+About to:
+    - create signed tag for this release: v$version
+    - create release diffs, "$diff_name"
     - create release tar, "$srctar_name"
+    - generate rsync-$version/patches/* files
     - create patches tar, "$pattar_name"
-    - create release diffs, "$diff_name"
-    - update patch branches and generate patch/* files
-    - update README, *NEWS, TODO, and ChangeLog
-    - update rsync*.html man pages
+    - update top-level README, *NEWS, TODO, and ChangeLog
+    - update top-level rsync*.html manpages
     - gpg-sign the release files
+    - update hard-linked top-level release files$skipping
 
 EOT
 print "<Press Enter to continue> ";
 $_ = <STDIN>;
 
-system "git commit -a -m 'Preparing for release of $version'" and exit 1;
-print "\nSign the tag:";
-system "git tag -s -m 'Version $version.' v$version" and exit 1;
+my $passphrase;
+while (1) {
+    ReadMode('noecho');
+    print "\nEnter your GPG pass-phrase: ";
+    chomp($passphrase = <STDIN>);
+    ReadMode(0);
+    print "\n";
+
+    # Briefly create a temp file with the passphrase for git's tagging use.
+    my $oldmask = umask 077;
+    unlink($passfile);
+    open(OUT, '>', $passfile) or die $!;
+    print OUT $passphrase, "\n";
+    close OUT;
+    umask $oldmask;
+    $ENV{'GPG_PASSFILE'} = $passfile;
 
-# Extract some files from the old tar before we do the shuffle.
+    # We want to use our passphrase-providing "gpg" script, so modify the PATH.
+    $ENV{PATH} = "packaging/bin:$path";
+    $_ = `git tag -s -m 'Version $version.' v$version 2>&1`;
+    $ENV{PATH} = $path;
+    unlink($passfile);
+    print $_;
+    next if /bad passphrase/;
+    last unless /failed/;
+    exit 1;
+}
+
+# Extract the generated files from the old tar.
 @_ = @extra_files;
 map { s#^#rsync-$lastversion/# } @_;
 system "tar xzf $lasttar_file @_";
 rename("rsync-$lastversion", 'a');
 
-# When creating a pre-release after a normal release, there's nothing to move.
-if ($diffdir ne $dest) {
-    chdir($dest) or die $!;
-
-    print "Shuffling old files ...\n";
-
-    # We need to run this regardless of $lastversion's "pre"ness.
-    my @moved_files;
-    foreach my $fn (glob('rsync*pre*.tar.gz*'), glob('rsync*pre*-NEWS')) {
-	link($fn, "old-previews/$fn") or die $!;
-	push(@moved_files, $fn);
-    }
-
-    if ($version !~ /pre/) {
-	foreach my $fn (glob('rsync*.tar.gz*'), glob('rsync*-NEWS')) {
-	    next if $fn =~ /^rsync.*pre/;
-	    link($fn, "old-versions/$fn") or die $!;
-	    push(@moved_files, $fn);
-	}
-
-	foreach my $fn (glob('rsync*pre*.diffs.gz*')) {
-	    unlink($fn);
-	}
-
-	foreach my $fn (glob('rsync*.diffs.gz*')) {
-	    link($fn, "old-patches/$fn") or die $!;
-	    push(@moved_files, $fn);
-	}
-    }
-
-    # Optimize our future upload (in the absence of --detect-renamed) by
-    # using rsync to hard-link the above files on samba.org.
-    system "rsync -avHOC --include='rsync*.gz*' --include='old-*/' --exclude='*' . samba.org:/home/ftp/pub/rsync";
-    foreach (@moved_files) {
-	unlink($_);
-    }
-
-    chdir($curdir) or die $!;
-}
-
 print "Creating $diff_file ...\n";
 system "./config.status Makefile; make gen; rsync -a @extra_files b/";
 my $sed_script = 's:^((---|\+\+\+) [ab]/[^\t]+)\t.*:\1:';
 system "(git diff v$lastversion v$version; diff -upN a b | sed -r '$sed_script') | gzip -9 >$diff_file";
 system "rm -rf a";
 rename('b', "rsync-$version");
 
 print "Creating $srctar_file ...\n";
 system "git archive --format=tar --prefix=rsync-$version/ v$version | tar xf -";
 system "support/git-set-file-times --prefix=rsync-$version/";
 system "fakeroot tar czf $srctar_file rsync-$version; rm -rf rsync-$version";
 
+print "Updating files in \"rsync-$version/patches\" dir ...\n";
 mkdir("rsync-$version", 0755);
 mkdir("rsync-$version/patches", 0755);
 system "support/patch-update --skip-check --gen=rsync-$version/patches";
+
+print "Creating $pattar_file ...\n";
 system "fakeroot tar chzf $pattar_file rsync-$version/patches; rm -rf rsync-$version";
 
 print "Updating the other files in $dest ...\n";
 system "rsync -a README NEWS OLDNEWS TODO $dest";
-unlink("$dest/rsync-$version-NEWS");
-link("$dest/NEWS", "$dest/rsync-$version-NEWS");
+unlink($news_file);
+link("$dest/NEWS", $news_file);
 system "git log --name-status | gzip -9 >$dest/ChangeLog.gz";
 
 system "yodl2html -o $dest/rsync.html rsync.yo";
 system "yodl2html -o $dest/rsyncd.conf.html rsyncd.conf.yo";
 
-chdir($dest) or die $!;
-my $cnt = 0;
-foreach my $fn ($srctar_name, $pattar_name, $diff_name) {
-    print ++$cnt, ". Sign file \"$fn\":";
-    system "gpg -ba $fn";
+foreach my $fn ($srctar_file, $pattar_file, $diff_file) {
+    unlink("$fn.asc");
+    open(GPG, '|-', "gpg --batch --passphrase-fd=0 -ba $fn") or die $!;
+    print GPG $passphrase, "\n";
+    close GPG;
+}
+
+if (!$pre) {
+    system "rm $dest/rsync-*{.tar.gz,.asc,-NEWS} $dest/src-preview/rsync-*diffs.gz";
+
+    foreach my $fn ($srctar_file, "$srctar_file.asc",
+		    $pattar_file, "$pattar_file.asc",
+		    $diff_file, "$diff_file.asc", $news_file) {
+	(my $top_fn = $fn) =~ s#/src(-\w+)?/#/#;
+	link($fn, $top_fn);
+    }
 }
+
 print $break, <<'EOT';
 
 Local changes are done.  When you're satisfied, push the git repository
 and rsync the release files.  Remember to announce the release on *BOTH*
 rsync-announce@lists.samba.org and rsync@lists.samba.org (and the web)!
 EOT
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popt.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/popt/popt.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popt.c	2006-11-23 11:28:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/popt/popt.c	2008-03-09 03:02:40.000000000 +0800
@@ -806,22 +806,26 @@
 		for (oe = optString; *oe && *oe != '='; oe++)
 		    {};
 		if (*oe == '=') {
 		    *oe++ = '\0';
 		    /* XXX longArg is mapped back to persistent storage. */
 		    longArg = origOptString + (oe - localOptString);
-		}
+		} else
+		    oe = NULL;
 
 		opt = findOption(con->options, optString, '\0', &cb, &cbData,
 				 singleDash);
 		if (!opt && !singleDash)
 		    return POPT_ERROR_BADOPT;
+		if (!opt && oe)
+		    oe[-1] = '='; /* restore overwritten '=' */
 	    }
 
 	    if (!opt) {
 		con->os->nextCharArg = origOptString + 1;
+		longArg = NULL;
 	    } else {
 		if (con->os == con->optionStack &&
 		   opt->argInfo & POPT_ARGFLAG_STRIP)
 		{
 		    canstrip = 1;
 		    poptStripArg(con, thisopt);
@@ -853,13 +857,13 @@
 	    if (!opt)
 		return POPT_ERROR_BADOPT;
 	    shorty = 1;
 
 	    origOptString++;
 	    if (*origOptString != '\0')
-		con->os->nextCharArg = origOptString;
+		con->os->nextCharArg = origOptString + (*origOptString == '=');
 	}
 	/*@=branchstate@*/
 
 	if (opt == NULL) return POPT_ERROR_BADOPT;	/* XXX can't happen */
 	if (opt->arg && (opt->argInfo & POPT_ARG_MASK) == POPT_ARG_NONE) {
 	    if (poptSaveInt((int *)opt->arg, opt->argInfo, 1L))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popthelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/popt/popthelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popthelp.c	2006-11-09 10:55:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/popt/popthelp.c	2008-03-09 03:02:40.000000000 +0800
@@ -118,13 +118,13 @@
     if (opt == (poptHelpOptions + 1) || opt == (poptHelpOptions + 2))
 	if (opt->argDescrip) return POPT_(opt->argDescrip);
 
     if (opt->argDescrip) return D_(translation_domain, opt->argDescrip);
 
     switch (opt->argInfo & POPT_ARG_MASK) {
-    case POPT_ARG_NONE:		return POPT_("NONE");
+    /*case POPT_ARG_NONE:	return POPT_("NONE");*/ /* impossible */
 #ifdef	DYING
     case POPT_ARG_VAL:		return POPT_("VAL");
 #else
     case POPT_ARG_VAL:		return NULL;
 #endif
     case POPT_ARG_INT:		return POPT_("INT");
@@ -764,12 +764,15 @@
 	/*@requires maxRead(str) >= 0 @*/
 {
     /* bufsize larger then the ascii set, lazy alloca on top level call. */
     char * s = (str != NULL ? str : memset(alloca(300), 0, 300));
     int len = 0;
 
+    if (s == NULL)
+	return 0;
+
 /*@-boundswrite@*/
     if (opt != NULL)
     for (; (opt->longName || opt->shortName || opt->arg); opt++) {
 	if (opt->shortName && !(opt->argInfo & POPT_ARG_MASK))
 	    s[strlen(s)] = opt->shortName;
 	else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/poptparse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/popt/poptparse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/poptparse.c	2006-11-10 11:34:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/popt/poptparse.c	2008-03-09 03:02:40.000000000 +0800
@@ -160,14 +160,16 @@
 
 	/* loop until first non-space char or EOL */
 	while( *p != '\0' && isSpace(p) )
 	    p++;
 
 	linelen = strlen(p);
-	if (linelen >= maxlinelen-1)
+	if (linelen >= maxlinelen-1) {
+	    free(argstr);
 	    return POPT_ERROR_OVERFLOW;	/* XXX line too long */
+	}
 
 	if (*p == '\0' || *p == '\n') continue;	/* line is empty */
 	if (*p == '#') continue;		/* comment line */
 
 	q = p;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/proto.h	2008-03-02 04:12:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/proto.h	2008-04-04 13:57:25.000000000 +0800
@@ -59,13 +59,14 @@
 void setup_protocol(int f_out,int f_in);
 int claim_connection(char *fname, int max_connections);
 void set_filter_dir(const char *dir, unsigned int dirlen);
 void *push_local_filters(const char *dir, unsigned int dirlen);
 void pop_local_filters(void *mem);
 void change_local_filter_dir(const char *dname, int dlen, int dir_depth);
-int check_filter(struct filter_list_struct *listp, char *name, int name_is_dir);
+int check_filter(struct filter_list_struct *listp, enum logcode code,
+		 const char *name, int name_is_dir);
 void parse_rule(struct filter_list_struct *listp, const char *pattern,
 		uint32 mflags, int xflags);
 void parse_filter_file(struct filter_list_struct *listp, const char *fname,
 		       uint32 mflags, int xflags);
 char *get_rule_prefix(int match_flags, const char *pat, int for_xfer,
 		      unsigned int *plen_ptr);
@@ -78,13 +79,13 @@
 			    int32 blk_size);
 char *map_ptr(struct map_struct *map, OFF_T offset, int32 len);
 int unmap_file(struct map_struct *map);
 void init_flist(void);
 void show_flist_stats(void);
 int link_stat(const char *path, STRUCT_STAT *stp, int follow_dirlinks);
-int push_pathname(const char *dir, int len);
+int change_pathname(struct file_struct *file, const char *dir, int dirlen);
 struct file_struct *make_file(const char *fname, struct file_list *flist,
 			      STRUCT_STAT *stp, int flags, int filter_level);
 void unmake_file(struct file_struct *file);
 void send_extra_file_list(int f, int at_least);
 struct file_list *send_file_list(int f, int argc, char *argv[]);
 struct file_list *recv_file_list(int f);
@@ -117,26 +118,27 @@
 		    enum logcode code);
 int hard_link_one(struct file_struct *file, const char *fname,
 		  const char *oldname, int terse);
 void finish_hard_link(struct file_struct *file, const char *fname, int fin_ndx,
 		      STRUCT_STAT *stp, int itemizing, enum logcode code,
 		      int alt_dest);
+int skip_hard_link(struct file_struct *file, struct file_list **flist_p);
 void io_set_sock_fds(int f_in, int f_out);
 void set_io_timeout(int secs);
 void set_msg_fd_in(int fd);
 void set_msg_fd_out(int fd);
 void increment_active_files(int ndx, int itemizing, enum logcode code);
 int send_msg(enum msgcode code, const char *buf, int len, int convert);
 void send_msg_int(enum msgcode code, int num);
 void wait_for_receiver(void);
 int get_redo_num(void);
 int get_hlink_num(void);
 void io_set_filesfrom_fds(int f_in, int f_out);
 int read_line(int fd, char *buf, size_t bufsiz, int flags);
-int read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,
-	      char ***argv_p, int *argc_p, char **request_p);
+void read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,
+	       char ***argv_p, int *argc_p, char **request_p);
 int io_start_buffering_out(int f_out);
 int io_start_buffering_in(int f_in);
 void io_end_buffering_in(void);
 void io_end_buffering_out(void);
 void maybe_flush_socket(int important);
 void maybe_send_keepalive(void);
@@ -244,13 +246,13 @@
 const char *get_panic_action(void);
 int main(int argc,char *argv[]);
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len);
 void match_report(void);
 void usage(enum logcode F);
 void option_error(void);
-int parse_arguments(int *argc_p, const char ***argv_p, int frommain);
+int parse_arguments(int *argc_p, const char ***argv_p);
 void server_options(char **args, int *argc_p);
 char *check_for_hostspec(char *s, char **host_ptr, int *port_ptr);
 BOOL pm_process( char *FileName,
                  BOOL (*sfunc)(char *),
                  BOOL (*pfunc)(char *, char *) );
 pid_t piped_child(char **command, int *f_in, int *f_out);
@@ -261,12 +263,13 @@
 void show_progress(OFF_T ofs, OFF_T size);
 int get_tmpname(char *fnametmp, const char *fname);
 int open_tmpfile(char *fnametmp, const char *fname, struct file_struct *file);
 int recv_files(int f_in, char *local_name);
 void setup_iconv(void);
 int iconvbufs(iconv_t ic, xbuf *in, xbuf *out, int flags);
+void send_protected_args(int fd, char *args[]);
 int read_ndx_and_attrs(int f_in, int *iflag_ptr, uchar *type_ptr,
 		       char *buf, int *len_ptr);
 void free_sums(struct sum_struct *s);
 mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms,
 		 int exists);
 int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
@@ -303,13 +306,12 @@
 int do_mkdir(char *fname, mode_t mode);
 int do_mkstemp(char *template, mode_t perms);
 int do_stat(const char *fname, STRUCT_STAT *st);
 int do_lstat(const char *fname, STRUCT_STAT *st);
 int do_fstat(int fd, STRUCT_STAT *st);
 OFF_T do_lseek(int fd, OFF_T offset, int whence);
-char *d_name(struct dirent *di);
 void set_compression(const char *fname);
 void send_token(int f, int32 token, struct map_struct *buf, OFF_T offset,
 		int32 n, int32 toklen);
 int32 recv_token(int f, char **data);
 void see_token(char *data, int32 toklen);
 uid_t match_uid(uid_t uid);
@@ -337,22 +339,22 @@
 		  int mode);
 pid_t do_fork(void);
 void kill_all(int sig);
 int name_to_uid(const char *name, uid_t *uid_p);
 int name_to_gid(const char *name, gid_t *gid_p);
 int lock_range(int fd, int offset, int len);
-void glob_expand(char *s, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr);
-void glob_expand_module(char *base1, char *arg, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr);
+int glob_expand(const char *arg, char ***argv_p, int *argc_p, int *maxargs_p);
+void glob_expand_module(char *base1, char *arg, char ***argv_p, int *argc_p, int *maxargs_p);
 void strlower(char *s);
 size_t pathjoin(char *dest, size_t destsize, const char *p1, const char *p2);
 size_t stringjoin(char *dest, size_t destsize, ...);
 int count_dir_elements(const char *p);
 unsigned int clean_fname(char *name, int flags);
-char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth);
-int push_dir(const char *dir, int set_path_only);
-int pop_dir(const char *dir);
+char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth,
+		    int flags);
+int change_dir(const char *dir, int set_path_only);
 char *full_fname(const char *fn);
 char *partial_dir_fname(const char *fname);
 int handle_partial_dir(const char *fname, int create);
 int unsafe_symlink(const char *dest, const char *src);
 char *human_num(int64 num);
 char *human_dnum(double dnum, int decimal_digits);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/receiver.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/receiver.c	2008-03-25 01:14:59.000000000 +0800
@@ -52,13 +52,13 @@
 extern mode_t orig_umask;
 extern struct stats stats;
 extern char *tmpdir;
 extern char *partial_dir;
 extern char *basis_dir[];
 extern struct file_list *cur_flist, *first_flist, *dir_flist;
-extern struct filter_list_struct server_filter_list;
+extern struct filter_list_struct daemon_filter_list;
 
 static struct bitbag *delayed_bits = NULL;
 static int phase = 0, redoing = 0;
 /* We're either updating the basis file or an identical copy: */
 static int updating_basis_or_equiv;
 
@@ -486,14 +486,14 @@
 			set_current_file_index(file, ndx);
 		stats.num_transferred_files++;
 		stats.total_transferred_size += F_LENGTH(file);
 
 		cleanup_got_literal = 0;
 
-		if (server_filter_list.head
-		    && check_filter(&server_filter_list, fname, 0) < 0) {
+		if (daemon_filter_list.head
+		    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {
 			rprintf(FERROR, "attempt to hack rsync failed.\n");
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		if (!do_xfers) { /* log the transfer */
 			log_item(FCLIENT, file, &stats, iflags, NULL);
@@ -552,14 +552,14 @@
 				}
 				pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
 					 basis_dir[fnamecmp_type], fname);
 				fnamecmp = fnamecmpbuf;
 				break;
 			}
-			if (!fnamecmp || (server_filter_list.head
-			  && check_filter(&server_filter_list, fname, 0) < 0)) {
+			if (!fnamecmp || (daemon_filter_list.head
+			  && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {
 				fnamecmp = fname;
 				fnamecmp_type = FNAMECMP_FNAME;
 			}
 		} else {
 			/* Reminder: --inplace && --partial-dir are never
 			 * enabled at the same time. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.1	2008-03-02 04:12:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsync.1	2008-04-04 13:57:07.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsync" "1" "1 Mar 2008" "" ""
+.TH "rsync" "1" "3 Apr 2008" "" ""
 .SH "NAME"
 rsync \(em a fast, versatile, remote (and local) file-copying tool
 .SH "SYNOPSIS"
 
 .PP 
 .nf 
@@ -835,15 +835,18 @@
 receiving user.
 .IP 
 .IP "\fB\-\-append\fP"
 This causes rsync to update a file by appending data onto
 the end of the file, which presumes that the data that already exists on
 the receiving side is identical with the start of the file on the sending
-side.  Any files that are the same size or shorter on the receiving size
-are skipped.  Files that do not yet exist on the receiving side are also
-sent, since they are considered to have 0 length.  Implies \fB\-\-inplace\fP,
+side.  If a file needs to be transferred and its size on the receiver is
+the same or longer than the size on the sender, the file is skipped.  This
+does not interfere with the updating of a file's non-content attributes
+(e.g. permissions, ownership, etc.) when the file does not need to be
+transferred, nor does it affect the updating of any non-regular files.
+Implies \fB\-\-inplace\fP,
 but does not conflict with \fB\-\-sparse\fP (since it is always extending a
 file's length).
 .IP 
 .IP "\fB\-\-append\-verify\fP"
 This works just like the \fB\-\-append\fP option, but
 the existing data on the receiving side is included in the full-file
@@ -862,17 +865,21 @@
 unless the directory name specified is \(lq.\(rq or ends with a trailing slash
 (e.g. \(lq.\(rq, \(lqdir/.\(rq, \(lqdir/\(rq, etc.).  Without this option or the
 \fB\-\-recursive\fP option, rsync will skip all directories it encounters (and
 output a message to that effect for each one).  If you specify both
 \fB\-\-dirs\fP and \fB\-\-recursive\fP, \fB\-\-recursive\fP takes precedence.
 .IP 
-This option is implied by the \fB\-\-list\-only\fP option (including an implied
+The \fB\-\-dirs\fP option is implied by the \fB\-\-files\-from\fP option
+or the \fB\-\-list\-only\fP option (including an implied
 \fB\-\-list\-only\fP usage) if \fB\-\-recursive\fP wasn't specified (so that
 directories are seen in the listing).  Specify \fB\-\-no\-dirs\fP (or \fB\-\-no\-d\fP)
-if you want to override this.  This option is also implied by
-\fB\-\-files\-from\fP.
+if you want to turn this off.
+.IP 
+There is also a backward-compatibility helper option, \fB\-\-old\-dirs\fP (or
+\fB\-\-old\-d\fP) that tells rsync to use a hack of \(lq\-r \-\-exclude='/*/*'\(rq to get
+an older rsync to list a single directory without recursing.
 .IP 
 .IP "\fB\-l, \-\-links\fP"
 When symlinks are encountered, recreate the
 symlink on the destination.
 .IP 
 .IP "\fB\-L, \-\-copy\-links\fP"
@@ -1921,23 +1928,28 @@
 a \(lq?\(rq (this can happen when talking to an older rsync).
 .IP 
 The attribute that is associated with each letter is as follows:
 .IP 
 .RS 
 .IP o 
-A \fBc\fP means the checksum of the file is different and will be
-updated by the file transfer (requires \fB\-\-checksum\fP).
+A \fBc\fP means either that a regular file has a different checksum
+(requires \fB\-\-checksum\fP) or that a symlink, device, or special file has
+a changed value.
+Note that if you are sending files to an rsync prior to 3.0.1, this
+change flag will be present only for checksum-differing regular files.
 .IP o 
-A \fBs\fP means the size of the file is different and will be updated
+A \fBs\fP means the size of a regular file is different and will be updated
 by the file transfer.
 .IP o 
 A \fBt\fP means the modification time is different and is being updated
 to the sender's value (requires \fB\-\-times\fP).  An alternate value of \fBT\fP
 means that the modification time will be set to the transfer time, which happens
 when a file/symlink/device is updated without \fB\-\-times\fP and when a
 symlink is changed and the receiver can't set its time.
+(Note: when using an rsync 3.0.0 client, you might see the \fBs\fP flag combined
+with \fBt\fP instead of the proper \fBT\fP flag for this time-setting failure.)
 .IP o 
 A \fBp\fP means the permissions are different and are being updated to
 the sender's value (requires \fB\-\-perms\fP).
 .IP o 
 An \fBo\fP means the owner is different and is being updated to the
 sender's value (requires \fB\-\-owner\fP and super-user privileges).
@@ -3357,13 +3369,13 @@
 Please report bugs! See the web site at
 http://rsync.samba.org/
 .PP 
 .SH "VERSION"
 
 .PP 
-This man page is current for version 3.0.0 of rsync.
+This man page is current for version 3.0.1 of rsync.
 .PP 
 .SH "INTERNAL OPTIONS"
 
 .PP 
 The options \fB\-\-server\fP and \fB\-\-sender\fP are used internally by rsync,
 and should never be typed by a user under normal circumstances.  Some
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsync.c	2008-03-17 11:39:16.000000000 +0800
@@ -38,13 +38,12 @@
 extern int am_server;
 extern int am_sender;
 extern int am_generator;
 extern int am_starting_up;
 extern int allow_8bit_chars;
 extern int protocol_version;
-extern int receiver_symlink_times;
 extern int uid_ndx;
 extern int gid_ndx;
 extern int inc_recurse;
 extern int inplace;
 extern int flist_eof;
 extern int keep_dirlinks;
@@ -203,12 +202,48 @@
 	out->len = obuf - out->buf - out->pos;
 
 	return errno ? -1 : 0;
 }
 #endif
 
+void send_protected_args(int fd, char *args[])
+{
+	int i;
+#ifdef ICONV_OPTION
+	int convert = ic_send != (iconv_t)-1;
+	xbuf outbuf, inbuf;
+
+	if (convert)
+		alloc_xbuf(&outbuf, 1024);
+#endif
+
+	for (i = 0; args[i]; i++) {} /* find first NULL */
+	args[i] = "rsync"; /* set a new arg0 */
+	if (verbose > 1)
+		print_child_argv("protected args:", args + i + 1);
+	do {
+#ifdef ICONV_OPTION
+		if (convert) {
+			INIT_XBUF_STRLEN(inbuf, args[i]);
+			iconvbufs(ic_send, &inbuf, &outbuf,
+				  ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE);
+			outbuf.buf[outbuf.len] = '\0';
+			write_buf(fd, outbuf.buf, outbuf.len + 1);
+			outbuf.len = 0;
+		} else
+#endif
+			write_buf(fd, args[i], strlen(args[i]) + 1);
+	} while (args[++i]);
+	write_byte(fd, 0);
+
+#ifdef ICONV_OPTION
+	if (convert)
+		free(outbuf.buf);
+#endif
+}
+
 int read_ndx_and_attrs(int f_in, int *iflag_ptr, uchar *type_ptr,
 		       char *buf, int *len_ptr)
 {
 	int len, iflags = 0;
 	struct file_list *flist;
 	uchar fnamecmp_type = FNAMECMP_FNAME;
@@ -397,13 +432,13 @@
 			rsyserr(FERROR_XFER, errno, "failed to set times on %s",
 				full_fname(fname));
 			goto cleanup;
 		}
 		if (ret == 0) /* ret == 1 if symlink could not be set */
 			updated = 1;
-		else if (receiver_symlink_times)
+		else
 			file->flags |= FLAG_TIME_FAILED;
 	}
 
 	change_uid = am_root && uid_ndx && sxp->st.st_uid != (uid_t)F_OWNER(file);
 	change_gid = gid_ndx && !(file->flags & FLAG_SKIP_GROUP)
 		  && sxp->st.st_gid != (gid_t)F_GROUP(file);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsyncd.conf.5	2008-03-02 04:12:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsyncd.conf.5	2008-04-04 13:54:34.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsyncd.conf" "5" "1 Mar 2008" "" ""
+.TH "rsyncd.conf" "5" "3 Apr 2008" "" ""
 .SH "NAME"
 rsyncd.conf \(em configuration file for rsync in daemon mode
 .SH "SYNOPSIS"
 
 .PP 
 rsyncd.conf
@@ -353,66 +353,64 @@
 Setting \(lqfake super = yes\(rq for a module causes the
 daemon side to behave as if the \fB\-\-fake\-user\fP command-line option had
 been specified.  This allows the full attributes of a file to be stored
 without having to have the daemon actually running as root.
 .IP 
 .IP "\fBfilter\fP"
-The \(lqfilter\(rq option allows you to specify a space-separated
-list of filter rules that the daemon will not allow to be read or written.
-This is only superficially equivalent to the client specifying these
-patterns with the \fB\-\-filter\fP option.  Only one \(lqfilter\(rq option may be
-specified, but it may contain as many rules as you like, including
-merge-file rules.  Note that per-directory merge-file rules do not provide
-as much protection as global rules, but they can be used to make \fB\-\-delete\fP
-work better when a client downloads the daemon's files (if the per-dir
-merge files are included in the transfer).
+The daemon has its own filter chain that determines what files
+it will let the client access.  This chain is not sent to the client and is
+independent of any filters the client may have specified.  Files excluded by
+the daemon filter chain (\fBdaemon-excluded\fP files) are treated as non-existent
+if the client tries to pull them, are skipped with an error message if the
+client tries to push them (triggering exit code 23), and are never deleted from
+the module.  You can use daemon filters to prevent clients from downloading or
+tampering with private administrative files, such as files you may add to
+support uid/gid name translations.
+.IP 
+The daemon filter chain is built from the \(lqfilter\(rq, \(lqinclude from\(rq, \(lqinclude\(rq,
+\(lqexclude from\(rq, and \(lqexclude\(rq parameters, in that order of priority.  Anchored
+patterns are anchored at the root of the module.  To prevent access to an
+entire subtree, for example, \(lq/secret\(rq, you \fImust\fP exclude everything in the
+subtree; the easiest way to do this is with a triple-star pattern like
+\(lq/secret/***\(rq.
+.IP 
+The \(lqfilter\(rq parameter takes a space-separated list of daemon filter rules,
+though it is smart enough to know not to split a token at an internal space in
+a rule (e.g. \(lq\- /foo  \(em /bar\(rq is parsed as two rules).  You may specify one or
+more merge-file rules using the normal syntax.  Only one \(lqfilter\(rq parameter can
+apply to a given module in the config file, so put all the rules you want in a
+single parameter.  Note that per-directory merge-file rules do not provide as
+much protection as global rules, but they can be used to make \fB\-\-delete\fP work
+better during a client download operation if the per-dir merge files are
+included in the transfer and the client requests that they be used.
 .IP 
 .IP "\fBexclude\fP"
-The \(lqexclude\(rq option allows you to specify a
-space-separated list of patterns that the daemon will not allow to be read
-or written.  This is only superficially equivalent to the client
-specifying these patterns with the \fB\-\-exclude\fP option.  Only one \(lqexclude\(rq
-option may be specified, but you can use \(lq\-\(rq and \(lq+\(rq before patterns to
-specify exclude/include.
-.IP 
-Because this exclude list is not passed to the client it only applies on
-the daemon: that is, it excludes files received by a client when receiving
-from a daemon and files deleted on a daemon when sending to a daemon, but
-it doesn't exclude files from being deleted on a client when receiving
-from a daemon.
-.IP 
-When you want to exclude a directory and all its contents, it is safest to
-use a rule that does both, such as \(lq/some/dir/***\(rq (the three stars tells
-rsync to exclude the directory itself and everything inside it).  This is
-better than just excluding the directory alone with \(lq/some/dir/\(rq, as it
-helps to guard against attempts to trick rsync into accessing files deeper
-in the hierarchy.
-.IP 
-.IP "\fBexclude from\fP"
-The \(lqexclude from\(rq option specifies a filename
-on the daemon that contains exclude patterns, one per line.
-This is only superficially equivalent
-to the client specifying the \fB\-\-exclude\-from\fP option with an equivalent file.
-See the \(lqexclude\(rq option above.
+The \(lqexclude\(rq parameter takes a space-separated list of daemon
+exclude patterns.  As with the client \fB\-\-exclude\fP option, patterns can be
+qualified with \(lq\- \(rq or \(lq+ \(rq to explicitly indicate exclude/include.  Only one
+\(lqexclude\(rq parameter can apply to a given module.  See the \(lqfilter\(rq parameter
+for a description of how excluded files affect the daemon.
 .IP 
 .IP "\fBinclude\fP"
-The \(lqinclude\(rq option allows you to specify a
-space-separated list of patterns which rsync should not exclude. This is
-only superficially equivalent to the client specifying these patterns with
-the \fB\-\-include\fP option because it applies only on the daemon.  This is
-useful as it allows you to build up quite complex exclude/include rules.
-Only one \(lqinclude\(rq option may be specified, but you can use \(lq+\(rq and \(lq\-\(rq
-before patterns to switch include/exclude.  See the \(lqexclude\(rq option
-above.
+Use an \(lqinclude\(rq to override the effects of the \(lqexclude\(rq
+parameter.  Only one \(lqinclude\(rq parameter can apply to a given module.  See the
+\(lqfilter\(rq parameter for a description of how excluded files affect the daemon.
+.IP 
+.IP "\fBexclude from\fP"
+The \(lqexclude from\(rq parameter specifies the name of a file
+on the daemon that contains daemon exclude patterns, one per line.  Only one
+\(lqexclude from\(rq parameter can apply to a given module; if you have multiple
+exclude-from files, you can specify them as a merge file in the \(lqfilter\(rq
+parameter.  See the \(lqfilter\(rq parameter for a description of how excluded files
+affect the daemon.
 .IP 
 .IP "\fBinclude from\fP"
-The \(lqinclude from\(rq option specifies a filename
-on the daemon that contains include patterns, one per line. This is
-only superficially equivalent to the client specifying the
-\fB\-\-include\-from\fP option with a equivalent file.
-See the \(lqexclude\(rq option above.
+Analogue of \(lqexclude from\(rq for a file of daemon include
+patterns.  Only one \(lqinclude from\(rq parameter can apply to a given module.  See
+the \(lqfilter\(rq parameter for a description of how excluded files affect the
+daemon.
 .IP 
 .IP "\fBincoming chmod\fP"
 This option allows you to specify a set of
 comma-separated chmod strings that will affect the permissions of all
 incoming files (files that are being received by the daemon).  These
 changes happen after all other permission calculations, and this will
@@ -515,13 +513,13 @@
 \f(CW    fe80::%link1/ffff:ffff:ffff:ffff::\fP
 .br 
 .RE
 
 .IP 
 You can also combine \(lqhosts allow\(rq with a separate \(lqhosts deny\(rq
-option. If both options are specified then the \(lqhosts allow\(rq option s
+option. If both options are specified then the \(lqhosts allow\(rq option is
 checked first and a match results in the client being able to
 connect. The \(lqhosts deny\(rq option is then checked and a match means
 that the host is rejected. If the host does not match either the
 \(lqhosts allow\(rq or the \(lqhosts deny\(rq patterns then it is allowed to
 connect.
 .IP 
@@ -820,13 +818,13 @@
 Please report bugs! The rsync bug tracking system is online at
 http://rsync.samba.org/
 .PP 
 .SH "VERSION"
 
 .PP 
-This man page is current for version 3.0.0 of rsync.
+This man page is current for version 3.0.1 of rsync.
 .PP 
 .SH "CREDITS"
 
 .PP 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsyncd.conf.yo	2008-03-02 04:12:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsyncd.conf.yo	2008-04-04 13:37:01.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(1 Mar 2008)()()
+manpage(rsyncd.conf)(5)(3 Apr 2008)()()
 manpagename(rsyncd.conf)(configuration file for rsync in daemon mode)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -311,62 +311,60 @@
 
 dit(bf(fake super)) Setting "fake super = yes" for a module causes the
 daemon side to behave as if the bf(--fake-user) command-line option had
 been specified.  This allows the full attributes of a file to be stored
 without having to have the daemon actually running as root.
 
-dit(bf(filter)) The "filter" option allows you to specify a space-separated
-list of filter rules that the daemon will not allow to be read or written.
-This is only superficially equivalent to the client specifying these
-patterns with the bf(--filter) option.  Only one "filter" option may be
-specified, but it may contain as many rules as you like, including
-merge-file rules.  Note that per-directory merge-file rules do not provide
-as much protection as global rules, but they can be used to make bf(--delete)
-work better when a client downloads the daemon's files (if the per-dir
-merge files are included in the transfer).
-
-dit(bf(exclude)) The "exclude" option allows you to specify a
-space-separated list of patterns that the daemon will not allow to be read
-or written.  This is only superficially equivalent to the client
-specifying these patterns with the bf(--exclude) option.  Only one "exclude"
-option may be specified, but you can use "-" and "+" before patterns to
-specify exclude/include.
-
-Because this exclude list is not passed to the client it only applies on
-the daemon: that is, it excludes files received by a client when receiving
-from a daemon and files deleted on a daemon when sending to a daemon, but
-it doesn't exclude files from being deleted on a client when receiving
-from a daemon.
-
-When you want to exclude a directory and all its contents, it is safest to
-use a rule that does both, such as "/some/dir/***" (the three stars tells
-rsync to exclude the directory itself and everything inside it).  This is
-better than just excluding the directory alone with "/some/dir/", as it
-helps to guard against attempts to trick rsync into accessing files deeper
-in the hierarchy.
-
-dit(bf(exclude from)) The "exclude from" option specifies a filename
-on the daemon that contains exclude patterns, one per line.
-This is only superficially equivalent
-to the client specifying the bf(--exclude-from) option with an equivalent file.
-See the "exclude" option above.
-
-dit(bf(include)) The "include" option allows you to specify a
-space-separated list of patterns which rsync should not exclude. This is
-only superficially equivalent to the client specifying these patterns with
-the bf(--include) option because it applies only on the daemon.  This is
-useful as it allows you to build up quite complex exclude/include rules.
-Only one "include" option may be specified, but you can use "+" and "-"
-before patterns to switch include/exclude.  See the "exclude" option
-above.
-
-dit(bf(include from)) The "include from" option specifies a filename
-on the daemon that contains include patterns, one per line. This is
-only superficially equivalent to the client specifying the
-bf(--include-from) option with a equivalent file.
-See the "exclude" option above.
+dit(bf(filter)) The daemon has its own filter chain that determines what files
+it will let the client access.  This chain is not sent to the client and is
+independent of any filters the client may have specified.  Files excluded by
+the daemon filter chain (bf(daemon-excluded) files) are treated as non-existent
+if the client tries to pull them, are skipped with an error message if the
+client tries to push them (triggering exit code 23), and are never deleted from
+the module.  You can use daemon filters to prevent clients from downloading or
+tampering with private administrative files, such as files you may add to
+support uid/gid name translations.
+
+The daemon filter chain is built from the "filter", "include from", "include",
+"exclude from", and "exclude" parameters, in that order of priority.  Anchored
+patterns are anchored at the root of the module.  To prevent access to an
+entire subtree, for example, "/secret", you em(must) exclude everything in the
+subtree; the easiest way to do this is with a triple-star pattern like
+"/secret/***".
+
+The "filter" parameter takes a space-separated list of daemon filter rules,
+though it is smart enough to know not to split a token at an internal space in
+a rule (e.g. "- /foo  - /bar" is parsed as two rules).  You may specify one or
+more merge-file rules using the normal syntax.  Only one "filter" parameter can
+apply to a given module in the config file, so put all the rules you want in a
+single parameter.  Note that per-directory merge-file rules do not provide as
+much protection as global rules, but they can be used to make bf(--delete) work
+better during a client download operation if the per-dir merge files are
+included in the transfer and the client requests that they be used.
+
+dit(bf(exclude)) The "exclude" parameter takes a space-separated list of daemon
+exclude patterns.  As with the client bf(--exclude) option, patterns can be
+qualified with "- " or "+ " to explicitly indicate exclude/include.  Only one
+"exclude" parameter can apply to a given module.  See the "filter" parameter
+for a description of how excluded files affect the daemon.
+
+dit(bf(include)) Use an "include" to override the effects of the "exclude"
+parameter.  Only one "include" parameter can apply to a given module.  See the
+"filter" parameter for a description of how excluded files affect the daemon.
+
+dit(bf(exclude from)) The "exclude from" parameter specifies the name of a file
+on the daemon that contains daemon exclude patterns, one per line.  Only one
+"exclude from" parameter can apply to a given module; if you have multiple
+exclude-from files, you can specify them as a merge file in the "filter"
+parameter.  See the "filter" parameter for a description of how excluded files
+affect the daemon.
+
+dit(bf(include from)) Analogue of "exclude from" for a file of daemon include
+patterns.  Only one "include from" parameter can apply to a given module.  See
+the "filter" parameter for a description of how excluded files affect the
+daemon.
 
 dit(bf(incoming chmod)) This option allows you to specify a set of
 comma-separated chmod strings that will affect the permissions of all
 incoming files (files that are being received by the daemon).  These
 changes happen after all other permission calculations, and this will
 even override destination-default and/or existing permissions when the
@@ -453,13 +451,13 @@
 tt(    fe80::1%link1)nl()
 tt(    fe80::%link1/64)nl()
 tt(    fe80::%link1/ffff:ffff:ffff:ffff::)nl()
 )
 
 You can also combine "hosts allow" with a separate "hosts deny"
-option. If both options are specified then the "hosts allow" option s
+option. If both options are specified then the "hosts allow" option is
 checked first and a match results in the client being able to
 connect. The "hosts deny" option is then checked and a match means
 that the host is rejected. If the host does not match either the
 "hosts allow" or the "hosts deny" patterns then it is allowed to
 connect.
 
@@ -699,13 +697,13 @@
 
 Please report bugs! The rsync bug tracking system is online at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 3.0.0 of rsync.
+This man page is current for version 3.0.1 of rsync.
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.h	2008-03-02 04:12:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsync.h	2008-03-31 06:44:46.000000000 +0800
@@ -64,13 +64,14 @@
 /* These flags are used in the live flist data. */
 
 #define FLAG_TOP_DIR (1<<0)	/* sender/receiver/generator */
 #define FLAG_FILE_SENT (1<<1)	/* sender/receiver/generator */
 #define FLAG_DIR_CREATED (1<<1)	/* generator */
 #define FLAG_CONTENT_DIR (1<<2)	/* sender/receiver/generator */
-#define FLAG_MOUNT_DIR (1<<3)	/* sender/generator */
+#define FLAG_MOUNT_DIR (1<<3)	/* sender/generator (dirs only) */
+#define FLAG_SKIP_HLINK (1<<3)	/* receiver/generator (w/FLAG_HLINKED) */
 #define FLAG_DUPLICATE (1<<4)	/* sender */
 #define FLAG_MISSING_DIR (1<<4)	/* generator */
 #define FLAG_HLINKED (1<<5)	/* receiver/generator (checked on all types) */
 #define FLAG_HLINK_FIRST (1<<6)	/* receiver/generator (w/FLAG_HLINKED) */
 #define FLAG_IMPLIED_DIR (1<<6)	/* sender/receiver/generator (dirs only) */
 #define FLAG_HLINK_LAST (1<<7)	/* receiver/generator */
@@ -79,12 +80,13 @@
 #define FLAG_SKIP_GROUP (1<<10)	/* receiver/generator */
 #define FLAG_TIME_FAILED (1<<11)/* generator */
 
 /* These flags are passed to functions but not stored. */
 
 #define FLAG_DIVERT_DIRS (1<<16)/* sender */
+#define FLAG_DOTDIR_NAME (1<<17)/* sender */
 
 #define BITS_SET(val,bits) (((val) & (bits)) == (bits))
 #define BITS_SETnUNSET(val,onbits,offbits) (((val) & ((onbits)|(offbits))) == (onbits))
 #define BITS_EQUAL(b1,b2,mask) (((unsigned)(b1) & (unsigned)(mask)) \
 			     == ((unsigned)(b2) & (unsigned)(mask)))
 
@@ -141,14 +143,15 @@
 #define NO_FILTERS	0
 #define SERVER_FILTERS	1
 #define ALL_FILTERS	2
 
 #define XFLG_FATAL_ERRORS	(1<<0)
 #define XFLG_OLD_PREFIXES	(1<<1)
-#define XFLG_ANCHORED2ABS	(1<<2)
-#define XFLG_ABS_IF_SLASH	(1<<3)
+#define XFLG_ANCHORED2ABS	(1<<2) /* leading slash indicates absolute */
+#define XFLG_ABS_IF_SLASH	(1<<3) /* leading or interior slash is absolute */
+#define XFLG_DIR2WILD3		(1<<4) /* dir/ match gets trailing *** added */
 
 #define ATTRS_REPORT		(1<<0)
 #define ATTRS_SKIP_MTIME	(1<<1)
 
 #define FULL_FLUSH	1
 #define NORMAL_FLUSH	0
@@ -163,14 +166,15 @@
 #define FNAMECMP_PARTIAL_DIR	0x81
 #define FNAMECMP_BACKUP 	0x82
 #define FNAMECMP_FUZZY		0x83
 
 /* For use by the itemize_changes code */
 #define ITEM_REPORT_ATIME (1<<0)
-#define ITEM_REPORT_CHECKSUM (1<<1)
-#define ITEM_REPORT_SIZE (1<<2)
+#define ITEM_REPORT_CHANGE (1<<1)
+#define ITEM_REPORT_SIZE (1<<2)     /* regular files only */
+#define ITEM_REPORT_TIMEFAIL (1<<2) /* symlinks only */
 #define ITEM_REPORT_TIME (1<<3)
 #define ITEM_REPORT_PERMS (1<<4)
 #define ITEM_REPORT_OWNER (1<<5)
 #define ITEM_REPORT_GROUP (1<<6)
 #define ITEM_REPORT_ACL (1<<7)
 #define ITEM_REPORT_XATTR (1<<8)
@@ -184,17 +188,23 @@
 #define ITEM_DELETED (1<<17)		   /* used by log_formatted() */
 #define ITEM_MATCHED (1<<18)		   /* used by itemize() */
 
 #define SIGNIFICANT_ITEM_FLAGS (~(\
 	ITEM_BASIS_TYPE_FOLLOWS | ITEM_XNAME_FOLLOWS | ITEM_LOCAL_CHANGE))
 
-#define CFN_KEEP_LEADING_DOT_DIR (1<<0)
+#define CFN_KEEP_DOT_DIRS (1<<0)
 #define CFN_KEEP_TRAILING_SLASH (1<<1)
 #define CFN_DROP_TRAILING_DOT_DIR (1<<2)
 #define CFN_COLLAPSE_DOT_DOT_DIRS (1<<3)
 
+#define SP_DEFAULT 0
+#define SP_KEEP_DOT_DIRS (1<<0)
+
+#define CD_NORMAL 0
+#define CD_SKIP_CHDIR 1
+
 /* Log-message categories.  FLOG only goes to the log file, not the client;
  * FCLIENT is the opposite. */
 enum logcode {
     FNONE=0, /* never sent */
     FERROR_XFER=1, FINFO=2, /* sent over socket for any protocol */
     FERROR=3, FWARNING=4, /* sent over socket for protocols >= 30 */
@@ -328,16 +338,12 @@
 /* apparently AIX needs this for S_ISLNK */
 #ifndef S_ISLNK
 #include <sys/mode.h>
 #endif
 #endif
 
-#ifdef HAVE_GLOB_H
-#include <glob.h>
-#endif
-
 /* these are needed for the uid/gid mapping code */
 #include <pwd.h>
 #include <grp.h>
 
 #include <stdarg.h>
 #include <netinet/in.h>
@@ -1102,12 +1108,17 @@
 #ifdef HAVE_GETEGID
 #define MY_GID() getegid()
 #else
 #define MY_GID() getgid()
 #endif
 
+#ifdef FORCE_FD_ZERO_MEMSET
+#undef FD_ZERO
+#define FD_ZERO(fdsetp) memset(fdsetp, 0, sizeof (fd_set))
+#endif
+
 extern int verbose;
 
 #ifndef HAVE_INET_NTOP
 const char *inet_ntop(int af, const void *src, char *dst, size_t size);
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.yo	2008-03-02 04:12:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/rsync.yo	2008-04-04 13:37:01.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(1 Mar 2008)()()
+manpage(rsync)(1)(3 Apr 2008)()()
 manpagename(rsync)(a fast, versatile, remote (and local) file-copying tool)
 manpagesynopsis()
 
 verb(Local:  rsync [OPTION...] SRC... [DEST]
 
 Access via remote shell:
@@ -720,15 +720,18 @@
 rsync will be unable to update a file in-place that is not writable by the
 receiving user.
 
 dit(bf(--append)) This causes rsync to update a file by appending data onto
 the end of the file, which presumes that the data that already exists on
 the receiving side is identical with the start of the file on the sending
-side.  Any files that are the same size or shorter on the receiving size
-are skipped.  Files that do not yet exist on the receiving side are also
-sent, since they are considered to have 0 length.  Implies bf(--inplace),
+side.  If a file needs to be transferred and its size on the receiver is
+the same or longer than the size on the sender, the file is skipped.  This
+does not interfere with the updating of a file's non-content attributes
+(e.g. permissions, ownership, etc.) when the file does not need to be
+transferred, nor does it affect the updating of any non-regular files.
+Implies bf(--inplace),
 but does not conflict with bf(--sparse) (since it is always extending a
 file's length).
 
 dit(bf(--append-verify)) This works just like the bf(--append) option, but
 the existing data on the receiving side is included in the full-file
 checksum verification step, which will cause a file to be resent if the
@@ -745,17 +748,21 @@
 unless the directory name specified is "." or ends with a trailing slash
 (e.g. ".", "dir/.", "dir/", etc.).  Without this option or the
 bf(--recursive) option, rsync will skip all directories it encounters (and
 output a message to that effect for each one).  If you specify both
 bf(--dirs) and bf(--recursive), bf(--recursive) takes precedence.
 
-This option is implied by the bf(--list-only) option (including an implied
+The bf(--dirs) option is implied by the bf(--files-from) option
+or the bf(--list-only) option (including an implied
 bf(--list-only) usage) if bf(--recursive) wasn't specified (so that
 directories are seen in the listing).  Specify bf(--no-dirs) (or bf(--no-d))
-if you want to override this.  This option is also implied by
-bf(--files-from).
+if you want to turn this off.
+
+There is also a backward-compatibility helper option, bf(--old-dirs) (or
+bf(--old-d)) that tells rsync to use a hack of "-r --exclude='/*/*'" to get
+an older rsync to list a single directory without recursing.
 
 dit(bf(-l, --links)) When symlinks are encountered, recreate the
 symlink on the destination.
 
 dit(bf(-L, --copy-links)) When symlinks are encountered, the item that
 they point to (the referent) is copied, rather than the symlink.  In older
@@ -1671,21 +1678,26 @@
 dots with spaces, and (3) an unknown attribute replaces each letter with
 a "?" (this can happen when talking to an older rsync).
 
 The attribute that is associated with each letter is as follows:
 
 quote(itemization(
-  it() A bf(c) means the checksum of the file is different and will be
-  updated by the file transfer (requires bf(--checksum)).
-  it() A bf(s) means the size of the file is different and will be updated
+  it() A bf(c) means either that a regular file has a different checksum
+  (requires bf(--checksum)) or that a symlink, device, or special file has
+  a changed value.
+  Note that if you are sending files to an rsync prior to 3.0.1, this
+  change flag will be present only for checksum-differing regular files.
+  it() A bf(s) means the size of a regular file is different and will be updated
   by the file transfer.
   it() A bf(t) means the modification time is different and is being updated
   to the sender's value (requires bf(--times)).  An alternate value of bf(T)
   means that the modification time will be set to the transfer time, which happens
   when a file/symlink/device is updated without bf(--times) and when a
   symlink is changed and the receiver can't set its time.
+  (Note: when using an rsync 3.0.0 client, you might see the bf(s) flag combined
+  with bf(t) instead of the proper bf(T) flag for this time-setting failure.)
   it() A bf(p) means the permissions are different and are being updated to
   the sender's value (requires bf(--perms)).
   it() An bf(o) means the owner is different and is being updated to the
   sender's value (requires bf(--owner) and super-user privileges).
   it() A bf(g) means the group is different and is being updated to the
   sender's value (requires bf(--group) and the authority to set the group).
@@ -2861,13 +2873,13 @@
 
 Please report bugs! See the web site at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 3.0.0 of rsync.
+This man page is current for version 3.0.1 of rsync.
 
 manpagesection(INTERNAL OPTIONS)
 
 The options bf(--server) and bf(--sender) are used internally by rsync,
 and should never be typed by a user under normal circumstances.  Some
 awareness of these options may be needed in certain scenarios, such as
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/sender.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/sender.c	2008-03-31 06:44:46.000000000 +0800
@@ -132,13 +132,13 @@
 			"INTERNAL ERROR: unable to find flist for item %d\n",
 			ndx);
 		return;
 	}
 
 	file = flist->files[ndx - flist->ndx_start];
-	if (!push_pathname(F_PATHNAME(file), -1))
+	if (!change_pathname(file, NULL, 0))
 		return;
 	f_name(file, fname);
 
 	if (do_unlink(fname) == 0) {
 		if (verbose > 1)
 			rprintf(FINFO, "sender removed %s\n", fname);
@@ -218,13 +218,13 @@
 		if (F_PATHNAME(file)) {
 			path = F_PATHNAME(file);
 			slash = "/";
 		} else {
 			path = slash = "";
 		}
-		if (!push_pathname(F_PATHNAME(file), -1))
+		if (!change_pathname(file, NULL, 0))
 			continue;
 		f_name(file, fname);
 
 		if (verbose > 2)
 			rprintf(FINFO, "send_files(%d, %s%s%s)\n", ndx, path,slash,fname);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/cull_options /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/support/cull_options
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/cull_options	2007-09-17 14:02:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/support/cull_options	2008-03-05 14:51:56.000000000 +0800
@@ -1,19 +1,25 @@
 #!/usr/bin/perl
 # This script outputs some perl code that parses all possible options
 # that the code in options.c might send to the server.  This perl code
 # is included in the rrsync script.
 use strict;
 
-our(%short_no_arg, %short_with_num, %long_opt);
+our %short_no_arg;
+our %short_with_num;
+our %long_opt = (
+    'no-i-r' => 0,
+    'fake-super' => 0,
+    'log-file' => 3,
+);
 our $last_long_opt;
 
 open(IN, '../options.c') or die "Unable to open ../options.c: $!\n";
 
 while (<IN>) {
-    if (/\Qargstr[x++]\E = '(.)'/) {
+    if (/\Qargstr[x++]\E = '([^.ie])'/) {
 	$short_no_arg{$1} = 1;
 	undef $last_long_opt;
     } elsif (/\Qasprintf(\E[^,]+, "-([a-zA-Z0-9])\%l?[ud]"/) {
 	$short_with_num{$1} = 1;
 	undef $last_long_opt;
     } elsif (/\Qargs[ac++]\E = "--([^"=]+)"/) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/patch-update /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/support/patch-update
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/patch-update	2008-02-25 05:19:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/support/patch-update	2008-03-25 11:30:09.000000000 +0800
@@ -11,12 +11,13 @@
 my $patches_dir = 'patches';
 my $tmp_dir = "patches.$$";
 
 &Getopt::Long::Configure('bundling');
 &usage if !&GetOptions(
     'skip-check' => \( my $skip_branch_check ),
+    'shell|s' => \( my $launch_shell ),
     'gen:s' => \( my $incl_generated_files ),
     'help|h' => \( my $help_opt ),
 );
 &usage if $help_opt;
 
 if (defined $incl_generated_files) {
@@ -24,19 +25,16 @@
     $incl_generated_files = 1;
 }
 
 die "No '$patches_dir' directory was found.\n" unless -d $patches_dir;
 die "No '.git' directory present in the current dir.\n" unless -d '.git';
 
-open(IN, '-|', 'git status') or die $!;
-my $status = join('', <IN>);
-close IN;
-unless ($skip_branch_check) {
-    die "The checkout is not clean:\n", $status unless $status =~ /\nnothing to commit \(working directory clean\)/;
+my($status, $is_clean, $starting_branch) = &check_git_status;
+if (!$skip_branch_check && !$is_clean) {
+    die "The checkout is not clean:\n", $status;
 }
-my($starting_branch) = $status =~ /^# On branch (.+)\n/;
 
 my @extra_files;
 open(IN, '<', 'Makefile.in') or die "Couldn't open Makefile.in: $!\n";
 while (<IN>) {
     if (s/^GENFILES=//) {
 	while (s/\\$//) {
@@ -52,25 +50,27 @@
     die "'$tmp_dir' must not exist in the current directory.\n" if -e $tmp_dir;
     mkdir($tmp_dir, 0700) or die "Unable to mkdir($tmp_dir): $!\n";
     system "./config.status Makefile && make gen && rsync -a @extra_files $tmp_dir/master/" and exit 1;
 }
 my $last_touch = time;
 
-my(@patches, %local_patch);
+my(%patches, %local_patch);
 
 # Start by finding all patches so that we can load all possible parents.
 open(PIPE, '-|', 'git', 'branch', '-a') or die $!;
 while (<PIPE>) {
     if (m# origin/patch/(.*)#) {
-	push(@patches, $1);
+	$patches{$1} = 1;
     } elsif (m# patch/(.*)#) {
-	$local_patch{$1} = 1;
+	$patches{$1} = $local_patch{$1} = 1;
     }
 }
 close PIPE;
 
+my @patches = sort keys %patches;
+
 my(%parent, %description);
 foreach my $patch (@patches) {
     my $branch = ($local_patch{$patch} ? '' : 'origin/') . "patch/$patch";
     my $desc = '';
     open(PIPE, '-|', 'git', 'diff', '-U1000', "master...$branch", '--', "PATCH.$patch") or die $!;
     while (<PIPE>) {
@@ -96,13 +96,13 @@
     }
 }
 
 my %completed;
 foreach my $patch (@patches) {
     next if $completed{$patch}++;
-    update_patch($patch);
+    last unless update_patch($patch);
 }
 
 if ($incl_generated_files) {
     system "rm -rf $tmp_dir";
 }
 
@@ -127,28 +127,39 @@
     }
 
     print "======== $patch ========\n";
 
     sleep 1 if $incl_generated_files && $last_touch == time;
     if ($local_patch{$patch}) {
-	system "git checkout patch/$patch" and exit 1;
+	system "git checkout patch/$patch" and return 0;
     } else {
-	system "git checkout --track -b patch/$patch origin/patch/$patch" and exit 1;
+	system "git checkout --track -b patch/$patch origin/patch/$patch" and return 0;
     }
 
-    open(OUT, '>', "$patches_dir/$patch.diff") or die $!;
-    print OUT $description{$patch}, "\n";
-
-    if (system("git merge $parent") != 0) {
-	print qq|"git merge $parent" incomplete -- please fix.\n|;
+    my $ok = system("git merge $parent") == 0;
+    if (!$ok || $launch_shell) {
+	print qq|"git merge $parent" incomplete -- please fix.\n| if !$ok;
 	$ENV{PS1} = "[$parent] patch/$patch: ";
-	system $ENV{SHELL} and exit 1;
+	while (1) {
+	    if (system($ENV{SHELL}) != 0) {
+		print "Abort? [n/y] ";
+		$_ = <STDIN>;
+		next unless /^y/i;
+		return 0;
+	    }
+	    ($status, $is_clean) = &check_git_status;
+	    last if $is_clean;
+	    print $status;
+	}
     }
 
+    open(OUT, '>', "$patches_dir/$patch.diff") or die $!;
+    print OUT $description{$patch}, "\n";
+
     if ($incl_generated_files) {
-	system "./config.status Makefile && make gen && rsync -a @extra_files $tmp_dir/$patch/" and exit 1;
+	system "./config.status Makefile && make gen && rsync -a @extra_files $tmp_dir/$patch/";
     }
     $last_touch = time;
 
     open(PIPE, '-|', 'git', 'diff', $parent) or die $!;
     DIFF: while (<PIPE>) {
 	while (m{^diff --git a/PATCH}) {
@@ -172,16 +183,28 @@
 	    print OUT $_;
 	}
 	close PIPE;
     }
 
     close OUT;
+
+    1;
 }
 
 exit;
 
+sub check_git_status
+{
+    open(IN, '-|', 'git status') or die $!;
+    my $status = join('', <IN>);
+    close IN;
+    my $is_clean = $status =~ /\nnothing to commit \(working directory clean\)/;
+    my($starting_branch) = $status =~ /^# On branch (.+)\n/;
+    ($status, $is_clean, $starting_branch);
+}
+
 sub usage
 {
     die <<EOT;
 Usage: patch-update [OPTIONS]
 
 --gen[=DIR]   Include generated files.  Optional dest DIR overrides "patches".
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/rrsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/support/rrsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/rrsync	2007-09-17 14:02:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/support/rrsync	2008-03-20 07:44:11.000000000 +0800
@@ -36,12 +36,13 @@
 # SSH_ORIGINAL_COMMAND=rsync --server --sender -vlogDtpr --partial . ARGS # pull
 # SSH_CONNECTION=client_addr client_port server_port
 
 my $command = $ENV{SSH_ORIGINAL_COMMAND};
 die "$0: Not invoked via sshd\n$Usage"	unless defined $command;
 die "$0: SSH_ORIGINAL_COMMAND='$command' is not rsync\n" unless $command =~ s/^rsync\s+//;
+die "$0: --server option is not first\n" unless $command =~ /^--server\s/;
 our $am_sender = $command =~ /^--server\s+--sender\s/; # Restrictive on purpose!
 die "$0 -ro: sending to read-only server not allowed\n" if $ro && !$am_sender;
 
 ### START of options data produced by the cull_options script. ###
 
 # These options are the only options that rsync might send to the server,
@@ -62,31 +63,33 @@
   'bwlimit' => 1,
   'checksum-seed' => 1,
   'compare-dest' => 2,
   'compress-level' => 1,
   'copy-dest' => 2,
   'copy-unsafe-links' => 0,
-  'daemon' => 0,
+  'daemon' => -1,
   'delay-updates' => 0,
   'delete' => 0,
   'delete-after' => 0,
   'delete-before' => 0,
   'delete-delay' => 0,
   'delete-during' => 0,
   'delete-excluded' => 0,
   'existing' => 0,
+  'fake-super' => 0,
   'files-from' => 3,
   'force' => 0,
   'from0' => 0,
   'fuzzy' => 0,
   'iconv' => 1,
   'ignore-errors' => 0,
   'ignore-existing' => 0,
   'inplace' => 0,
   'link-dest' => 2,
   'list-only' => 0,
+  'log-file' => 3,
   'log-format' => 1,
   'max-delete' => 1,
   'max-size' => 1,
   'min-size' => 1,
   'modify-window' => 1,
   'no-i-r' => 0,
@@ -107,12 +110,13 @@
   'skip-compress' => 1,
   'specials' => 0,
   'suffix' => 1,
   'super' => 0,
   'temp-dir' => 2,
   'timeout' => 1,
+  'use-qsort' => 0,
 );
 
 ### END of options data produced by the cull_options script. ###
 
 if ($short_disabled ne '') {
     $short_no_arg =~ s/[$short_disabled]//go;
@@ -136,13 +140,13 @@
     $check_type = 0;
   } elsif ($in_options) {
     push(@opts, $_);
     if ($_ eq '.') {
       $in_options = 0;
     } else {
-      next if /^-$short_no_arg+(e\d+\.\d+)?$/o || /^-$short_with_num\d+$/o;
+      next if /^-$short_no_arg+(e\d*\.\w*)?$/o || /^-$short_with_num\d+$/o;
 
       my($opt,$arg) = /^--([^=]+)(?:=(.*))?$/;
       my $disabled;
       if (defined $opt) {
 	my $ct = $long_opt{$opt};
 	last unless defined $ct;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/syscall.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/syscall.c	2008-03-21 22:26:25.000000000 +0800
@@ -164,15 +164,15 @@
 		attrList.commonattr = ATTR_CMN_ACCESSMASK;
 		code = setattrlist(path, &attrList, &m, sizeof m, FSOPT_NOFOLLOW);
 #else
 		code = 1;
 #endif
 	} else
-		code = chmod(path, mode & CHMOD_BITS);
+		code = chmod(path, mode & CHMOD_BITS); /* DISCOURAGED FUNCTION */
 	if (code != 0 && (preserve_perms || preserve_executability))
-	    return code;
+		return code;
 	return 0;
 }
 #endif
 
 int do_rename(const char *fname1, const char *fname2)
 {
@@ -279,15 +279,6 @@
 #endif
 	return lseek64(fd, offset, whence);
 #else
 	return lseek(fd, offset, whence);
 #endif
 }
-
-char *d_name(struct dirent *di)
-{
-#ifdef HAVE_BROKEN_READDIR
-	return (di->d_name - 2);
-#else
-	return di->d_name;
-#endif
-}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/daemon.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/daemon.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/daemon.test	2002-12-24 15:25:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/daemon.test	2008-03-04 10:33:11.000000000 +0800
@@ -21,12 +21,33 @@
 
 # TODO: Put the common framework in a common file, so that we can have
 # subtests fail and keep going.
 
 . "$suitedir/rsync.fns"
 
+SSH="$scratchdir/pretend-ssh"
+
+cat >"$SSH" <<'EOT'
+while : ; do
+    case "$1" in
+    -*) shift ;;
+    localhost) shift; break ;;
+    *) exit 1 ;;
+    esac
+done
+
+eval "${@}"
+EOT
+chmod +x "$SSH"
+
 build_rsyncd_conf
 
+cd "$scratchdir"
+
+ln -s test-rsyncd.conf rsyncd.conf
+
+$RSYNC -ve $SSH --rsync-path="$RSYNC" localhost::
+
 RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
 $RSYNC -v localhost::
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/devices.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/devices.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/devices.test	2008-02-28 09:57:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/devices.test	2008-03-15 22:26:46.000000000 +0800
@@ -94,23 +94,23 @@
 
 sleep 1
 
 $RSYNC -Di "$fromdir/block3" "$todir/block" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cD..T.$dots block3
+cDc.T.$dots block3
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 3 failed"
 
 $RSYNC -aiHvv "$fromdir/" "$todir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
 .d..t.$dots ./
-cD..t.$dots block
-cD$allspace block2
+cDc.t.$dots block
+cDc...$dots block2
 cD$all_plus block3
 hD$all_plus block2.5 => block3
 cD$all_plus char
 cD$all_plus char2
 cD$all_plus char3
 cS$all_plus fifo
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/hardlinks.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/hardlinks.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/hardlinks.test	2007-09-04 14:57:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/hardlinks.test	2008-03-29 01:40:17.000000000 +0800
@@ -35,15 +35,26 @@
 
 echo "extra extra" >>"$todir/name1"
 
 checkit "$RSYNC -aHivv --no-whole-file '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 # Add a new link in a new subdirectory to test that we don't try to link
-# the files before the directory gets created.
-mkdir "$fromdir/subdir"
-ln "$name1" "$fromdir/subdir/new-file"
+# the files before the directory gets created.  We also create a bunch of
+# extra files to ensure that an incremental-recursion transfer works across
+# distant files.
+makepath "$fromdir/subdir/down/deep"
+
+files=''
+for x in 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z; do
+    for y in 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z; do
+	files="$files $x$y"
+    done
+done
+(cd "$fromdir/subdir"; touch $files)
+
+ln "$name1" "$fromdir/subdir/down/deep/new-file"
 rm "$todir/text"
 
 checkit "$RSYNC -aHivv '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 # Do some duplicate copies using --link-dest and --copy-dest to test that
 # we hard-link all locally-inherited items.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/itemize.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/itemize.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/itemize.test	2008-02-28 09:57:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/itemize.test	2008-03-11 12:39:01.000000000 +0800
@@ -22,22 +22,21 @@
 cp -p "$srcdir/rsync.h" "$fromdir/bar/baz/rsync"
 chmod 600 "$fromdir"/foo/config? "$fromdir/bar/baz/rsync"
 umask 0
 ln -s ../bar/baz/rsync "$fromdir/foo/sym"
 umask 022
 ln "$fromdir/foo/config1" "$fromdir/foo/extra"
+rm -f "$to2dir"
 
-# Check if the OS can hard-link symlinks or not.
-# (Note: the link we check MUST NOT point to a valid file!)
-ln -s no-such-dir "$to2dir"
-if ln "$to2dir" "$to2dir.test" 2>/dev/null; then
+# Check if rsync is set to hard-link symlinks.
+confile=`echo "$scratchdir" | sed 's;/testtmp/itemize$;/config.h;'`
+if egrep '^#define CAN_HARDLINK_SYMLINK 1' "$confile" >/dev/null; then
     L=hL
 else
     L=cL
 fi
-rm -f "$to2dir" "$to2dir.test"
 
 # Check if rsync can preserve time on symlinks
 case "$RSYNC" in
 *protocol=2*)
     T=.T
     ;;
@@ -94,13 +93,13 @@
     | tee "$outfile"
 cat <<EOT >"$chkfile"
 .f..tp$dots bar/baz/rsync
 .d..t.$dots foo/
 .f..t.$dots foo/config1
 >fcstp$dots foo/config2
-cL.$T.$dots foo/sym -> ../bar/baz/rsync
+cLc$T.$dots foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 3 failed"
 
 cp -p "$srcdir/configure.in" "$fromdir/foo/config2"
 chmod 600 "$fromdir/foo/config2"
 # Lack of -t is for unchanged hard-link stress-test!
@@ -155,14 +154,14 @@
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 7 failed"
 
 $RSYNC -ivvplrtH --copy-dest=../to "$fromdir/" "$to2dir/" \
     | tee "$outfile"
 filter_outfile
 case `tail -1 "$outfile"` in
-cL..t*)
-    sym_dots="..t.$dots"
+cLc.t*)
+    sym_dots="c.t.$dots"
     L_sym_dots="cL$sym_dots"
     is_uptodate='-> ../bar/baz/rsync'
     echo "cL$sym_dots foo/sym $is_uptodate" >"$chkfile.extra"
     L=cL
     ;;
 *)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/merge.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/merge.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/merge.test	2007-05-25 22:32:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/merge.test	2008-03-05 13:46:27.000000000 +0800
@@ -48,10 +48,10 @@
 # Get rid of any directory-time differences
 $RSYNC -av --existing -f 'exclude,! */' from1/ from2/
 $RSYNC -av --existing -f 'exclude,! */' from2/ from3/
 $RSYNC -av --existing -f 'exclude,! */' from1/ chk/
 $RSYNC -av --existing -f 'exclude,! */' from3/ chk/
 
-checkit "$RSYNC -avv deep/arg-test shallow from1/ from2/ from3/ to/" chk to
+checkit "$RSYNC -avv deep/arg-test shallow from1/ from2/ from3/ to/" "$chkdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite: missing.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/xattrs.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/xattrs.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/xattrs.test	2008-01-13 14:16:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/testsuite/xattrs.test	2008-03-08 09:13:38.000000000 +0800
@@ -17,23 +17,25 @@
 	shift 2
 	xattr -s "$xnam" "$xval" "${@}"
     }
     xls() {
 	xattr -l "${@}"
     }
+    RUSR='rsync.nonuser'
     ;;
 *)
     xset() {
 	xnam="$1"
 	xval="$2"
 	shift 2
 	setfattr -n "$xnam" -v "$xval" "${@}"
     }
     xls() {
 	getfattr -d "${@}"
     }
+    RUSR='user.rsync'
     ;;
 esac
 
 makepath "$fromdir/foo/bar"
 echo now >"$fromdir/file0"
 echo something >"$fromdir/file1"
@@ -62,43 +64,50 @@
 xset user.bar bar file2
 xset user.long 'a long attribute for our new file that tests to ensure that this works' file2
 
 xset user.foo 'new foo' foo/file3 foo/bar/file5
 xset user.bar 'new bar' foo/file3 foo/bar/file5
 xset user.long 'this is also a long attribute that will be truncated in the initial data send' foo/file3 foo/bar/file5
-xset user.equal 'this long attribute should remain the same and not need to be transferred' foo/file3 foo/bar/file5
+xset $RUSR.equal 'this long attribute should remain the same and not need to be transferred' foo/file3 foo/bar/file5
 
 xset user.short 'old short' "$chkdir/file1"
 xset user.extra 'remove me' "$chkdir/file1"
 
 xset user.foo 'old foo' "$chkdir/foo/file3"
-xset user.equal 'this long attribute should remain the same and not need to be transferred' "$chkdir/foo/file3"
+xset $RUSR.equal 'this long attribute should remain the same and not need to be transferred' "$chkdir/foo/file3"
 
 xls $files >"$scratchdir/xattrs.txt"
 
 # OK, let's try a simple xattr copy.
-checkit "$RSYNC -avX . '$chkdir/'" "$fromdir" "$chkdir"
+checkit "$RSYNC -avX --super . '$chkdir/'" "$fromdir" "$chkdir"
 
 cd "$chkdir"
 xls $files | diff $diffopt "$scratchdir/xattrs.txt" -
 
 cd "$fromdir"
 
-checkit "$RSYNC -aiX --copy-dest=../chk . ../to" "$fromdir" "$todir"
+checkit "$RSYNC -aiX --super --copy-dest=../chk . ../to" "$fromdir" "$todir"
 
 cd "$todir"
 xls $files | diff $diffopt "$scratchdir/xattrs.txt" -
 
 cd "$fromdir"
 xset user.nice 'this is nice, but different' file1
 
 xls $files >"$scratchdir/xattrs.txt"
 
 rm -rf "$todir"
 
-checkit "$RSYNC -aiX --link-dest=../chk . ../to" "$chkdir" "$todir"
+checkit "$RSYNC -aiX --fake-super --link-dest=../chk . ../to" "$chkdir" "$todir"
 
 cd "$todir"
 xls $files | diff $diffopt "$scratchdir/xattrs.txt" -
 
+sed -n -e '/\.\/file1$/d' -e '/^[^ ][^ ]*  *[^ ][^ ]*  *[^ ][^ ]*  *1 /p' "$scratchdir/ls-to" >"$scratchdir/ls-diff"
+if [ -s "$scratchdir/ls-diff" ]; then
+    echo "Missing hard links on:"
+    cat "$scratchdir/ls-diff"
+    exit 1
+fi
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/tls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/tls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/tls.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/tls.c	2008-03-15 13:55:59.000000000 +0800
@@ -32,13 +32,13 @@
  *
  * A key requirement for this program is that the output be "very
  * reproducible."  So we mask away information that can accidentally
  * change. */
 
 #include "rsync.h"
-#include "popt.h"
+#include <popt.h>
 #include "lib/sysxattrs.h"
 
 #define PROGRAM "tls"
 
 /* These are to make syscall.o shut up. */
 int dry_run = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/t_stub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/t_stub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/t_stub.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/t_stub.c	2008-03-25 01:14:59.000000000 +0800
@@ -26,13 +26,13 @@
 int relative_paths = 0;
 int human_readable = 0;
 int module_dirlen = 0;
 mode_t orig_umask = 002;
 char *partial_dir;
 char *module_dir;
-struct filter_list_struct server_filter_list;
+struct filter_list_struct daemon_filter_list;
 
  void rprintf(UNUSED(enum logcode code), const char *format, ...)
 {
 	va_list ap;
 	va_start(ap, format);
 	vfprintf(stderr, format, ap);
@@ -53,14 +53,14 @@
 {
 	fprintf(stderr, "exit(%d): %s(%d)\n",
 		code, file, line);
 	exit(code);
 }
 
- int check_filter(UNUSED(struct filter_list_struct *listp), UNUSED(char *name),
-		   UNUSED(int name_is_dir))
+ int check_filter(UNUSED(struct filter_list_struct *listp), UNUSED(enum logcode code),
+		  UNUSED(const char *name), UNUSED(int name_is_dir))
 {
 	/* This function doesn't really get called in this test context, so
 	 * just return 0. */
 	return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/util.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/util.c	2008-03-31 06:44:46.000000000 +0800
@@ -30,13 +30,13 @@
 extern int relative_paths;
 extern int human_readable;
 extern char *module_dir;
 extern unsigned int module_dirlen;
 extern mode_t orig_umask;
 extern char *partial_dir;
-extern struct filter_list_struct server_filter_list;
+extern struct filter_list_struct daemon_filter_list;
 
 int sanitize_paths = 0;
 
 char curr_dir[MAXPATHLEN];
 unsigned int curr_dir_len;
 int curr_dir_depth; /* This is only set for a sanitizing daemon. */
@@ -500,88 +500,178 @@
 	lock.l_len = len;
 	lock.l_pid = 0;
 
 	return fcntl(fd,F_SETLK,&lock) == 0;
 }
 
-static int filter_server_path(char *arg)
-{
-	char *s;
+#define ENSURE_MEMSPACE(buf, type, sz, req) \
+	if ((req) > sz && !(buf = realloc_array(buf, type, sz = MAX(sz * 2, req)))) \
+		out_of_memory("glob_expand")
+
+static inline void call_glob_match(const char *name, int len, int from_glob,
+				   char *arg, int abpos, int fbpos);
+
+static struct glob_data {
+	char *arg_buf, *filt_buf, **argv;
+	int absize, fbsize, maxargs, argc;
+} glob;
+
+static void glob_match(char *arg, int abpos, int fbpos)
+{
+	int len;
+	char *slash;
+
+	while (*arg == '.' && arg[1] == '/') {
+		if (fbpos < 0) {
+			ENSURE_MEMSPACE(glob.filt_buf, char, glob.fbsize, glob.absize);
+			memcpy(glob.filt_buf, glob.arg_buf, abpos + 1);
+			fbpos = abpos;
+		}
+		ENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, abpos + 3);
+		glob.arg_buf[abpos++] = *arg++;
+		glob.arg_buf[abpos++] = *arg++;
+		glob.arg_buf[abpos] = '\0';
+	}
+	if ((slash = strchr(arg, '/')) != NULL) {
+		*slash = '\0';
+		len = slash - arg;
+	} else
+		len = strlen(arg);
+	if (strpbrk(arg, "*?[")) {
+		struct dirent *di;
+		DIR *d;
+
+		if (!(d = opendir(abpos ? glob.arg_buf : ".")))
+			return;
+		while ((di = readdir(d)) != NULL) {
+			char *dname = d_name(di);
+			if (dname[0] == '.' && (dname[1] == '\0'
+			  || (dname[1] == '.' && dname[2] == '\0')))
+				continue;
+			if (!wildmatch(arg, dname))
+				continue;
+			call_glob_match(dname, strlen(dname), 1,
+					slash ? arg + len + 1 : NULL,
+					abpos, fbpos);
+		}
+		closedir(d);
+	} else {
+		call_glob_match(arg, len, 0,
+				slash ? arg + len + 1 : NULL,
+				abpos, fbpos);
+	}
+	if (slash)
+		*slash = '/';
+}
+
+static inline void call_glob_match(const char *name, int len, int from_glob,
+				   char *arg, int abpos, int fbpos)
+{
+	char *use_buf;
+
+	ENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, abpos + len + 2);
+	memcpy(glob.arg_buf + abpos, name, len);
+	abpos += len;
+	glob.arg_buf[abpos] = '\0';
+
+	if (fbpos >= 0) {
+		ENSURE_MEMSPACE(glob.filt_buf, char, glob.fbsize, fbpos + len + 2);
+		memcpy(glob.filt_buf + fbpos, name, len);
+		fbpos += len;
+		glob.filt_buf[fbpos] = '\0';
+		use_buf = glob.filt_buf;
+	} else
+		use_buf = glob.arg_buf;
 
-	if (server_filter_list.head) {
-		for (s = arg; (s = strchr(s, '/')) != NULL; ) {
-			*s = '\0';
-			if (check_filter(&server_filter_list, arg, 1) < 0) {
-				/* We must leave arg truncated! */
-				return 1;
-			}
-			*s++ = '/';
+	if (from_glob || arg) {
+		STRUCT_STAT st;
+		int is_dir;
+
+		if (do_stat(glob.arg_buf, &st) != 0)
+			return;
+		is_dir = S_ISDIR(st.st_mode) != 0;
+		if (arg && !is_dir)
+			return;
+
+		if (daemon_filter_list.head
+		 && check_filter(&daemon_filter_list, FLOG, use_buf, is_dir) < 0)
+			return;
+	}
+
+	if (arg) {
+		glob.arg_buf[abpos++] = '/';
+		glob.arg_buf[abpos] = '\0';
+		if (fbpos >= 0) {
+			glob.filt_buf[fbpos++] = '/';
+			glob.filt_buf[fbpos] = '\0';
 		}
+		glob_match(arg, abpos, fbpos);
+	} else {
+		ENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, glob.argc + 1);
+		if (!(glob.argv[glob.argc++] = strdup(glob.arg_buf)))
+			out_of_memory("glob_match");
 	}
-	return 0;
 }
 
-void glob_expand(char *s, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr)
+/* This routine performs wild-card expansion of the pathname in "arg".  Any
+ * daemon-excluded files/dirs will not be matched by the wildcards.  Returns 0
+ * if a wild-card string is the only returned item (due to matching nothing). */
+int glob_expand(const char *arg, char ***argv_p, int *argc_p, int *maxargs_p)
 {
-	char **argv = *argv_ptr;
-	int argc = *argc_ptr;
-	int maxargs = *maxargs_ptr;
-#if !defined HAVE_GLOB || !defined HAVE_GLOB_H
-	if (argc == maxargs) {
-		maxargs += MAX_ARGS;
-		if (!(argv = realloc_array(argv, char *, maxargs)))
-			out_of_memory("glob_expand");
-		*argv_ptr = argv;
-		*maxargs_ptr = maxargs;
-	}
-	if (!*s)
-		s = ".";
-	s = argv[argc++] = strdup(s);
-	filter_server_path(s);
-#else
-	glob_t globbuf;
+	int ret, save_argc;
+	char *s;
 
-	if (maxargs <= argc)
-		return;
-	if (!*s)
-		s = ".";
+	if (!arg) {
+		if (glob.filt_buf)
+			free(glob.filt_buf);
+		free(glob.arg_buf);
+		memset(&glob, 0, sizeof glob);
+		return -1;
+	}
 
 	if (sanitize_paths)
-		s = sanitize_path(NULL, s, "", 0);
-	else
-		s = strdup(s);
-	if (!s)
-		out_of_memory("glob_expand");
-
-	memset(&globbuf, 0, sizeof globbuf);
-	if (!filter_server_path(s))
-		glob(s, 0, NULL, &globbuf);
-	if (MAX((int)globbuf.gl_pathc, 1) > maxargs - argc) {
-		maxargs += globbuf.gl_pathc + MAX_ARGS;
-		if (!(argv = realloc_array(argv, char *, maxargs)))
+		s = sanitize_path(NULL, arg, "", 0, SP_KEEP_DOT_DIRS);
+	else {
+		s = strdup(arg);
+		if (!s)
 			out_of_memory("glob_expand");
-		*argv_ptr = argv;
-		*maxargs_ptr = maxargs;
+		clean_fname(s, CFN_KEEP_DOT_DIRS
+			     | CFN_KEEP_TRAILING_SLASH
+			     | CFN_COLLAPSE_DOT_DOT_DIRS);
 	}
-	if (globbuf.gl_pathc == 0)
-		argv[argc++] = s;
-	else {
-		int i;
+
+	ENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, MAXPATHLEN);
+	*glob.arg_buf = '\0';
+
+	glob.argc = save_argc = *argc_p;
+	glob.argv = *argv_p;
+	glob.maxargs = *maxargs_p;
+
+	ENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, 100);
+
+	glob_match(s, 0, -1);
+
+	/* The arg didn't match anything, so add the failed arg to the list. */
+	if (glob.argc == save_argc) {
+		ENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, glob.argc + 1);
+		glob.argv[glob.argc++] = s;
+		ret = 0;
+	} else {
 		free(s);
-		for (i = 0; i < (int)globbuf.gl_pathc; i++) {
-			if (!(argv[argc++] = strdup(globbuf.gl_pathv[i])))
-				out_of_memory("glob_expand");
-		}
+		ret = 1;
 	}
-	globfree(&globbuf);
-#endif
-	*argc_ptr = argc;
+
+	*maxargs_p = glob.maxargs;
+	*argv_p = glob.argv;
+	*argc_p = glob.argc;
+
+	return ret;
 }
 
 /* This routine is only used in daemon mode. */
-void glob_expand_module(char *base1, char *arg, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr)
+void glob_expand_module(char *base1, char *arg, char ***argv_p, int *argc_p, int *maxargs_p)
 {
 	char *p, *s;
 	char *base = base1;
 	int base_len = strlen(base);
 
 	if (!arg || !*arg)
@@ -597,13 +687,13 @@
 		out_of_memory("glob_expand_module");
 	base_len++;
 
 	for (s = arg; *s; s = p + base_len) {
 		if ((p = strstr(s, base)) != NULL)
 			*p = '\0'; /* split it at this point */
-		glob_expand(s, argv_ptr, argc_ptr, maxargs_ptr);
+		glob_expand(s, argv_p, argc_p, maxargs_p);
 		if (!p)
 			break;
 	}
 
 	free(arg);
 	free(base);
@@ -684,42 +774,42 @@
 			cnt++;
 		}
 	}
 	return cnt;
 }
 
-/* Turns multiple adjacent slashes into a single slash, drops interior "."
- * elements, drops an intial "./" unless CFN_KEEP_LEADING_DOT_DIR is flagged,
- * will even drop a trailing '.' after a '/' if CFN_DROP_TRAILING_DOT_DIR is
- * flagged, removes a trailing slash (perhaps after removing the aforementioned
- * dot) unless CFN_KEEP_TRAILING_SLASH is flagged, will even collapse ".."
- * elements (except at the start of the string) if CFN_COLLAPSE_DOT_DOT_DIRS
- * is flagged.  If the resulting name would be empty, we return ".". */
+/* Turns multiple adjacent slashes into a single slash, drops all leading or
+ * interior "." elements unless CFN_KEEP_DOT_DIRS is flagged.  Will also drop
+ * a trailing '.' after a '/' if CFN_DROP_TRAILING_DOT_DIR is flagged, removes
+ * a trailing slash (perhaps after removing the aforementioned dot) unless
+ * CFN_KEEP_TRAILING_SLASH is flagged, and will also collapse ".." elements
+ * (except at the start) if CFN_COLLAPSE_DOT_DOT_DIRS is flagged.  If the
+ * resulting name would be empty, returns ".". */
 unsigned int clean_fname(char *name, int flags)
 {
 	char *limit = name - 1, *t = name, *f = name;
 	int anchored;
 
 	if (!name)
 		return 0;
 
 	if ((anchored = *f == '/') != 0)
 		*t++ = *f++;
-	else if (flags & CFN_KEEP_LEADING_DOT_DIR && *f == '.' && f[1] == '/') {
+	else if (flags & CFN_KEEP_DOT_DIRS && *f == '.' && f[1] == '/') {
 		*t++ = *f++;
 		*t++ = *f++;
 	}
 	while (*f) {
 		/* discard extra slashes */
 		if (*f == '/') {
 			f++;
 			continue;
 		}
 		if (*f == '.') {
 			/* discard interior "." dirs */
-			if (f[1] == '/') {
+			if (f[1] == '/' && !(flags & CFN_KEEP_DOT_DIRS)) {
 				f += 2;
 				continue;
 			}
 			if (f[1] == '\0' && flags & CFN_DROP_TRAILING_DOT_DIR)
 				break;
 			/* collapse ".." dirs */
@@ -770,16 +860,17 @@
  *
  * Turns multiple adjacent slashes into a single slash, gets rid of "." dir
  * elements (INCLUDING a trailing dot dir), PRESERVES a trailing slash, and
  * ALWAYS collapses ".." elements (except for those at the start of the
  * string up to "depth" deep).  If the resulting name would be empty,
  * change it into a ".". */
-char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth)
+char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth,
+		    int flags)
 {
 	char *start, *sanp;
-	int rlen = 0, leave_one_dotdir = relative_paths;
+	int rlen = 0, drop_dot_dirs = !relative_paths || !(flags & SP_KEEP_DOT_DIRS);
 
 	if (dest != p) {
 		int plen = strlen(p);
 		if (*p == '/') {
 			if (!rootdir)
 				rootdir = module_dir;
@@ -796,43 +887,42 @@
 			memcpy(dest, rootdir, rlen);
 			if (rlen > 1)
 				dest[rlen++] = '/';
 		}
 	}
 
+	if (drop_dot_dirs) {
+		while (*p == '.' && p[1] == '/')
+			p += 2;
+	}
+
 	start = sanp = dest + rlen;
+	/* This loop iterates once per filename component in p, pointing at
+	 * the start of the name (past any prior slash) for each iteration. */
 	while (*p) {
 		/* discard leading or extra slashes */
 		if (*p == '/') {
 			p++;
 			continue;
 		}
-		/* this loop iterates once per filename component in p.
-		 * both p (and sanp if the original had a slash) should
-		 * always be left pointing after a slash
-		 */
-		if (*p == '.' && (p[1] == '/' || p[1] == '\0')) {
-			if (leave_one_dotdir && p[1])
-				leave_one_dotdir = 0;
-			else {
+		if (drop_dot_dirs) {
+			if (*p == '.' && (p[1] == '/' || p[1] == '\0')) {
 				/* skip "." component */
 				p++;
 				continue;
 			}
 		}
 		if (*p == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\0')) {
 			/* ".." component followed by slash or end */
 			if (depth <= 0 || sanp != start) {
 				p += 2;
 				if (sanp != start) {
 					/* back up sanp one level */
 					--sanp; /* now pointing at slash */
-					while (sanp > start && sanp[-1] != '/') {
-						/* skip back up to slash */
+					while (sanp > start && sanp[-1] != '/')
 						sanp--;
-					}
 				}
 				continue;
 			}
 			/* allow depth levels of .. at the beginning */
 			depth--;
 			/* move the virtual beginning to leave the .. alone */
@@ -850,13 +940,13 @@
 	return dest;
 }
 
 /* Like chdir(), but it keeps track of the current directory (in the
  * global "curr_dir"), and ensures that the path size doesn't overflow.
  * Also cleans the path using the clean_fname() function. */
-int push_dir(const char *dir, int set_path_only)
+int change_dir(const char *dir, int set_path_only)
 {
 	static int initialised;
 	unsigned int len;
 
 	if (!initialised) {
 		initialised = 1;
@@ -868,59 +958,43 @@
 		return 0;
 
 	len = strlen(dir);
 	if (len == 1 && *dir == '.')
 		return 1;
 
-	if ((*dir == '/' ? len : curr_dir_len + 1 + len) >= sizeof curr_dir) {
-		errno = ENAMETOOLONG;
-		return 0;
-	}
-
-	if (!set_path_only && chdir(dir))
-		return 0;
-
 	if (*dir == '/') {
+		if (len >= sizeof curr_dir) {
+			errno = ENAMETOOLONG;
+			return 0;
+		}
+		if (!set_path_only && chdir(dir))
+			return 0;
 		memcpy(curr_dir, dir, len + 1);
-		curr_dir_len = len;
 	} else {
-		curr_dir[curr_dir_len++] = '/';
-		memcpy(curr_dir + curr_dir_len, dir, len + 1);
-		curr_dir_len += len;
+		if (curr_dir_len + 1 + len >= sizeof curr_dir) {
+			errno = ENAMETOOLONG;
+			return 0;
+		}
+		curr_dir[curr_dir_len] = '/';
+		memcpy(curr_dir + curr_dir_len + 1, dir, len + 1);
+
+		if (!set_path_only && chdir(curr_dir)) {
+			curr_dir[curr_dir_len] = '\0';
+			return 0;
+		}
 	}
 
 	curr_dir_len = clean_fname(curr_dir, CFN_COLLAPSE_DOT_DOT_DIRS);
 	if (sanitize_paths) {
 		if (module_dirlen > curr_dir_len)
 			module_dirlen = curr_dir_len;
 		curr_dir_depth = count_dir_elements(curr_dir + module_dirlen);
 	}
 
 	if (verbose >= 5 && !set_path_only)
-		rprintf(FINFO, "[%s] push_dir(%s)\n", who_am_i(), curr_dir);
-
-	return 1;
-}
-
-/**
- * Reverse a push_dir() call.  You must pass in an absolute path
- * that was copied from a prior value of "curr_dir".
- **/
-int pop_dir(const char *dir)
-{
-	if (chdir(dir))
-		return 0;
-
-	curr_dir_len = strlcpy(curr_dir, dir, sizeof curr_dir);
-	if (curr_dir_len >= sizeof curr_dir)
-		curr_dir_len = sizeof curr_dir - 1;
-	if (sanitize_paths)
-		curr_dir_depth = count_dir_elements(curr_dir + module_dirlen);
-
-	if (verbose >= 5)
-		rprintf(FINFO, "[%s] pop_dir(%s)\n", who_am_i(), curr_dir);
+		rprintf(FINFO, "[%s] change_dir(%s)\n", who_am_i(), curr_dir);
 
 	return 1;
 }
 
 /**
  * Return a quoted string with the full pathname of the indicated filename.
@@ -974,19 +1048,19 @@
 			sz -= len;
 		}
 	} else
 		fn = fname;
 	if ((int)pathjoin(t, sz, partial_dir, fn) >= sz)
 		return NULL;
-	if (server_filter_list.head) {
+	if (daemon_filter_list.head) {
 		t = strrchr(partial_fname, '/');
 		*t = '\0';
-		if (check_filter(&server_filter_list, partial_fname, 1) < 0)
+		if (check_filter(&daemon_filter_list, FLOG, partial_fname, 1) < 0)
 			return NULL;
 		*t = '/';
-		if (check_filter(&server_filter_list, partial_fname, 0) < 0)
+		if (check_filter(&daemon_filter_list, FLOG, partial_fname, 0) < 0)
 			return NULL;
 	}
 
 	return partial_fname;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/xattrs.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/xattrs.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/xattrs.c	2008-03-02 04:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.1/xattrs.c	2008-03-08 08:41:09.000000000 +0800
@@ -59,15 +59,18 @@
 #else
 #define MIGHT_NEED_RPRE am_root
 #define RSYNC_PREFIX "rsync."
 #endif
 #define RPRE_LEN ((int)sizeof RSYNC_PREFIX - 1)
 
-#define XSTAT_ATTR RSYNC_PREFIX "%stat"
-#define XACC_ACL_ATTR RSYNC_PREFIX "%aacl"
-#define XDEF_ACL_ATTR RSYNC_PREFIX "%dacl"
+#define XSTAT_SUFFIX "stat"
+#define XSTAT_ATTR RSYNC_PREFIX "%" XSTAT_SUFFIX
+#define XACC_ACL_SUFFIX "aacl"
+#define XACC_ACL_ATTR RSYNC_PREFIX "%" XACC_ACL_SUFFIX
+#define XDEF_ACL_SUFFIX "dacl"
+#define XDEF_ACL_ATTR RSYNC_PREFIX "%" XDEF_ACL_SUFFIX
 
 typedef struct {
 	char *datum, *name;
 	size_t datum_len, name_len;
 	int num;
 } rsync_xa;
@@ -228,13 +231,16 @@
 #endif
 
 		/* No rsync.%FOO attributes are copied w/o 2 -X options. */
 		if (name_len > RPRE_LEN && name[RPRE_LEN] == '%'
 		 && HAS_PREFIX(name, RSYNC_PREFIX)) {
 			if ((am_sender && preserve_xattrs < 2)
-			 || (am_root < 0 && strcmp(name, XSTAT_ATTR) == 0))
+			 || (am_root < 0
+			  && (strcmp(name+RPRE_LEN+1, XSTAT_SUFFIX) == 0
+			   || strcmp(name+RPRE_LEN+1, XACC_ACL_SUFFIX) == 0
+			   || strcmp(name+RPRE_LEN+1, XDEF_ACL_SUFFIX) == 0)))
 				continue;
 		}
 
 		datum_len = name_len; /* Pass extra size to get_xattr_data() */
 		if (!(ptr = get_xattr_data(fname, name, &datum_len, 0)))
 			return -1;
@@ -250,20 +256,12 @@
 				out_of_memory("rsync_xal_get");
 			*ptr = XSTATE_ABBREV;
 			sum_end(ptr + 1);
 		} else
 			name_offset = datum_len;
 
-#ifdef HAVE_LINUX_XATTRS
-		if (am_root < 0 && name_len > RPRE_LEN && name[RPRE_LEN] != '%'
-		 && HAS_PREFIX(name, RSYNC_PREFIX)) {
-			name += RPRE_LEN;
-			name_len -= RPRE_LEN;
-		}
-#endif
-
 		rxa = EXPAND_ITEM_LIST(xalp, rsync_xa, RSYNC_XAL_INITIAL);
 		rxa->name = ptr + name_offset;
 		memcpy(rxa->name, name, name_len);
 		rxa->datum = ptr;
 		rxa->name_len = name_len;
 		rxa->datum_len = datum_len;
@@ -349,31 +347,38 @@
 
 	if (ndx < 0) {
 		rsync_xa *rxa;
 		int count = sxp->xattr->count;
 		write_varint(f, count);
 		for (rxa = sxp->xattr->items; count--; rxa++) {
+			size_t name_len = rxa->name_len;
+			const char *name = rxa->name;
+			/* Strip the rsync prefix from disguised namespaces. */
+			if (name_len > RPRE_LEN
 #ifdef HAVE_LINUX_XATTRS
-			write_varint(f, rxa->name_len);
+			 && am_root < 0
+#endif
+			 && name[RPRE_LEN] != '%' && HAS_PREFIX(name, RSYNC_PREFIX)) {
+				name += RPRE_LEN;
+				name_len -= RPRE_LEN;
+			}
+#ifndef HAVE_LINUX_XATTRS
+			else {
+				/* Put everything else in the user namespace. */
+				name_len += UPRE_LEN;
+			}
+#endif
+			write_varint(f, name_len);
 			write_varint(f, rxa->datum_len);
-			write_buf(f, rxa->name, rxa->name_len);
-#else
-			/* We strip the rsync prefix from disguised namespaces
-			 * and put everything else in the user namespace. */
-			if (HAS_PREFIX(rxa->name, RSYNC_PREFIX)
-			 && rxa->name[RPRE_LEN] != '%') {
-				write_varint(f, rxa->name_len - RPRE_LEN);
-				write_varint(f, rxa->datum_len);
-				write_buf(f, rxa->name + RPRE_LEN, rxa->name_len - RPRE_LEN);
-			} else {
-				write_varint(f, rxa->name_len + UPRE_LEN);
-				write_varint(f, rxa->datum_len);
+#ifndef HAVE_LINUX_XATTRS
+			if (name_len > rxa->name_len) {
 				write_buf(f, USER_PREFIX, UPRE_LEN);
-				write_buf(f, rxa->name, rxa->name_len);
+				name_len -= UPRE_LEN;
 			}
 #endif
+			write_buf(f, name, name_len);
 			if (rxa->datum_len > MAX_FULL_DATUM)
 				write_buf(f, rxa->datum + 1, MAX_DIGEST_LEN);
 			else
 				write_buf(f, rxa->datum, rxa->datum_len);
 		}
 		ndx = rsync_xal_l.count; /* pre-incremented count */
@@ -571,12 +576,17 @@
 
 /* receive and build the rsync_xattr_lists */
 void receive_xattr(struct file_struct *file, int f)
 {
 	static item_list temp_xattr = EMPTY_ITEM_LIST;
 	int count, num;
+#ifdef HAVE_LINUX_XATTRS
+	int need_sort = 0;
+#else
+	int need_sort = 1;
+#endif
 	int ndx = read_varint(f);
 
 	if (ndx < 0 || (size_t)ndx > rsync_xal_l.count) {
 		rprintf(FERROR, "receive_xattr: xa index %d out of"
 			" range for %s\n", ndx, f_name(file, NULL));
 		exit_cleanup(RERR_STREAMIO);
@@ -621,12 +631,13 @@
 				free(ptr);
 				continue;
 			}
 			name -= RPRE_LEN;
 			name_len += RPRE_LEN;
 			memcpy(name, RSYNC_PREFIX, RPRE_LEN);
+			need_sort = 1;
 		}
 #else
 		/* This OS only has a user namespace, so we either
 		 * strip the user prefix, or we put a non-user
 		 * namespace inside our rsync hierarchy. */
 		if (HAS_PREFIX(name, USER_PREFIX)) {
@@ -652,12 +663,15 @@
 		rxa->datum = ptr;
 		rxa->name_len = name_len;
 		rxa->datum_len = datum_len;
 		rxa->num = num;
 	}
 
+	if (need_sort && count > 1)
+		qsort(temp_xattr.items, count, sizeof (rsync_xa), rsync_xal_compare_names);
+
 	ndx = rsync_xal_l.count; /* pre-incremented count */
 	rsync_xal_store(&temp_xattr); /* adds item to rsync_xal_l */
 
 	F_XATTR(file) = ndx;
 }
 
@@ -681,13 +695,14 @@
 			 const char *fnamecmp, stat_x *sxp)
 {
 	rsync_xa *rxas = xalp->items;
 	ssize_t list_len;
 	size_t i, len;
 	char *name, *ptr, sum[MAX_DIGEST_LEN];
-	int name_len, ret = 0;
+	size_t name_len;
+	int ret = 0;
 
 	/* This puts the current name list into the "namebuf" buffer. */
 	if ((list_len = get_xattr_names(fname)) < 0)
 		return -1;
 
 	for (i = 0; i < xalp->count; i++) {
