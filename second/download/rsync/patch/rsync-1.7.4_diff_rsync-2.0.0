Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: access.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: acconfig.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: authenticate.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/checksum.c	1998-03-26 12:51:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/checksum.c	1998-05-14 15:07:51.000000000 +0800
@@ -31,13 +31,13 @@
   (inspired by Mark Adler's Adler-32 checksum)
   */
 uint32 get_checksum1(char *buf1,int len)
 {
     int i;
     uint32 s1, s2;
-    signed char *buf = (signed char *)buf1;
+    schar *buf = (schar *)buf1;
 
     s1 = s2 = 0;
     for (i = 0; i < (len-4); i+=4) {
 	s2 += 4*(s1 + buf[i]) + 3*buf[i+1] + 2*buf[i+2] + buf[i+3] + 
 	  10*CHAR_OFFSET;
 	s1 += (buf[i+0] + buf[i+1] + buf[i+2] + buf[i+3] + 4*CHAR_OFFSET); 
@@ -90,19 +90,19 @@
     MDupdate(&MD, buf1+i, (len-i)*8);
 
   sum_put(&MD,sum);
 }
 
 
-void file_checksum(char *fname,char *sum,off_t size)
+void file_checksum(char *fname,char *sum,OFF_T size)
 {
-  off_t i;
+  OFF_T i;
   MDstruct MD;
   struct map_struct *buf;
   int fd;
-  off_t len = size;
+  OFF_T len = size;
   char tmpchunk[CSUM_CHUNK];
 
   bzero(sum,csum_length);
 
   fd = open(fname,O_RDONLY);
   if (fd == -1) return;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: clientserver.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/compat.c	1998-03-26 12:51:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/compat.c	1998-05-14 15:07:51.000000000 +0800
@@ -37,38 +37,40 @@
 
 extern int remote_version;
 extern int verbose;
 
 void setup_protocol(int f_out,int f_in)
 {
-  if (am_server) {
-    remote_version = read_int(f_in);
-    write_int(f_out,PROTOCOL_VERSION);
-    write_flush(f_out);
-  } else {
-    write_int(f_out,PROTOCOL_VERSION);
-    write_flush(f_out);
-    remote_version = read_int(f_in);
-  }
-
-  if (remote_version < MIN_PROTOCOL_VERSION ||
-      remote_version > MAX_PROTOCOL_VERSION) {
-    fprintf(FERROR,"protocol version mismatch - is your shell clean?\n");
-    exit_cleanup(1);
-  }	
-
-  if (verbose > 2)
-	  fprintf(FINFO, "local_version=%d remote_version=%d\n",
-		  PROTOCOL_VERSION, remote_version);
-
-  if (remote_version >= 12) {
-    if (am_server) {
-      checksum_seed = time(NULL);
-      write_int(f_out,checksum_seed);
-    } else {
-      checksum_seed = read_int(f_in);
-    }
-  }
-
-  checksum_init();
+	if (remote_version == 0) {
+		if (am_server) {
+			remote_version = read_int(f_in);
+			write_int(f_out,PROTOCOL_VERSION);
+			write_flush(f_out);
+		} else {
+			write_int(f_out,PROTOCOL_VERSION);
+			write_flush(f_out);
+			remote_version = read_int(f_in);
+		}
+	}
+
+	if (remote_version < MIN_PROTOCOL_VERSION ||
+	    remote_version > MAX_PROTOCOL_VERSION) {
+		rprintf(FERROR,"protocol version mismatch - is your shell clean?\n");
+		exit_cleanup(1);
+	}	
+	
+	if (verbose > 2)
+		rprintf(FINFO, "local_version=%d remote_version=%d\n",
+			PROTOCOL_VERSION, remote_version);
+	
+	if (remote_version >= 12) {
+		if (am_server) {
+			checksum_seed = time(NULL);
+			write_int(f_out,checksum_seed);
+		} else {
+			checksum_seed = read_int(f_in);
+		}
+	}
+	
+	checksum_init();
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/config.h.in	1998-03-26 12:51:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/config.h.in	1998-05-14 15:07:51.000000000 +0800
@@ -1,115 +1,224 @@
 /* config.h.in.  Generated automatically from configure.in by autoheader.  */
 
-/* compiler specifics */
-#undef const
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#undef gid_t
+
+/* Define if your system has a working fnmatch function.  */
+#undef HAVE_FNMATCH
+
+/* Define if you have a working `mmap' system call.  */
+#undef HAVE_MMAP
+
+/* Define if your struct stat has st_rdev.  */
+#undef HAVE_ST_RDEV
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+#undef HAVE_SYS_WAIT_H
+
+/* Define if utime(file, NULL) sets file's timestamp to the present.  */
+#undef HAVE_UTIME_NULL
+
+/* Define as __inline if that's what the C compiler calls it.  */
 #undef inline
-#undef HAVE_INLINE
 
-/* defines for basic types */
-#undef gid_t
+/* Define to `int' if <sys/types.h> doesn't define.  */
 #undef mode_t
+
+/* Define to `long' if <sys/types.h> doesn't define.  */
 #undef off_t
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
 #undef pid_t
+
+/* Define as the return type of signal handlers (int or void).  */
+#undef RETSIGTYPE
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
 #undef size_t
+
+/* Define if you have the ANSI C header files.  */
+#undef STDC_HEADERS
+
+/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+#undef TIME_WITH_SYS_TIME
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
 #undef uid_t
 
-/* The number of bytes in some types  */
-#undef SIZEOF_LONG
+#undef HAVE_BROKEN_READDIR
+#undef HAVE_ERRNO_DECL
+#undef HAVE_LONGLONG
+#undef HAVE_OFF64_T
+#undef HAVE_REMSH
+#undef HAVE_UNSIGNED_CHAR
+#undef HAVE_UTIMBUF
+#undef ino_t
+#undef HAVE_CONNECT
+
+/* The number of bytes in a int.  */
 #undef SIZEOF_INT
+
+/* The number of bytes in a long.  */
+#undef SIZEOF_LONG
+
+/* The number of bytes in a short.  */
 #undef SIZEOF_SHORT
 
-/* defines for header files */
-#undef HAVE_SYS_WAIT_H
-#undef HAVE_FCNTL_H
-#undef HAVE_SYS_FCNTL_H
-#undef HAVE_SYS_SELECT_H
-#undef HAVE_SYS_PARAM_H
-#undef TIME_WITH_SYS_TIME
-#undef HAVE_DIRENT_H
-#undef HAVE_MALLOC_H
-#undef HAVE_SYS_DIR_H
-#undef HAVE_SYS_TIME_H
-#undef HAVE_SYS_TIMES_H
-#undef HAVE_UNISTD_H
-#undef HAVE_GRP_H
-#undef HAVE_CTYPE_H
-#undef HAVE_SYS_FILIO_H
-#undef HAVE_SYS_IOCTL_H
-#undef HAVE_UTIME_H
-#undef HAVE_STRING_H
-#undef HAVE_STDLIB_H
-#undef HAVE_SYS_SOCKET_H
-#undef HAVE_SYS_MODE_H
+/* Define if you have the bcopy function.  */
+#undef HAVE_BCOPY
 
-/* specific functions */
-#undef HAVE_FCHMOD
+/* Define if you have the bzero function.  */
+#undef HAVE_BZERO
+
+/* Define if you have the chmod function.  */
 #undef HAVE_CHMOD
-#undef HAVE_MKNOD
+
+/* Define if you have the chown function.  */
+#undef HAVE_CHOWN
+
+/* Define if you have the fchmod function.  */
+#undef HAVE_FCHMOD
+
+/* Define if you have the fstat function.  */
 #undef HAVE_FSTAT
+
+/* Define if you have the getcwd function.  */
+#undef HAVE_GETCWD
+
+/* Define if you have the getopt_long function.  */
+#undef HAVE_GETOPT_LONG
+
+/* Define if you have the getpagesize function.  */
+#undef HAVE_GETPAGESIZE
+
+/* Define if you have the glob function.  */
+#undef HAVE_GLOB
+
+/* Define if you have the lchown function.  */
+#undef HAVE_LCHOWN
+
+/* Define if you have the link function.  */
+#undef HAVE_LINK
+
+/* Define if you have the memmove function.  */
+#undef HAVE_MEMMOVE
+
+/* Define if you have the mkdir function.  */
+#undef HAVE_MKDIR
+
+/* Define if you have the mknod function.  */
+#undef HAVE_MKNOD
+
+/* Define if you have the pipe function.  */
+#undef HAVE_PIPE
+
+/* Define if you have the readlink function.  */
+#undef HAVE_READLINK
+
+/* Define if you have the setlinebuf function.  */
+#undef HAVE_SETLINEBUF
+
+/* Define if you have the setsid function.  */
+#undef HAVE_SETSID
+
+/* Define if you have the strchr function.  */
 #undef HAVE_STRCHR
+
+/* Define if you have the strdup function.  */
 #undef HAVE_STRDUP
+
+/* Define if you have the strerror function.  */
 #undef HAVE_STRERROR
+
+/* Define if you have the strtok function.  */
 #undef HAVE_STRTOK
-#undef HAVE_WAITPID
-#undef HAVE_BCOPY
-#undef HAVE_BZERO
-#undef HAVE_READLINK
-#undef HAVE_LINK
+
+/* Define if you have the utime function.  */
 #undef HAVE_UTIME
+
+/* Define if you have the utimes function.  */
 #undef HAVE_UTIMES
-#undef HAVE_GETOPT_LONG
-#undef HAVE_FNMATCH
-#undef HAVE_LONGLONG
-#undef HAVE_UTIMBUF
-#undef HAVE_MEMMOVE
-#undef HAVE_MMAP
-#undef HAVE_LCHOWN
-#undef HAVE_SETLINEBUF
-#undef HAVE_GETCWD
 
-/* specific programs */
-#undef HAVE_REMSH
+/* Define if you have the vsnprintf function.  */
+#undef HAVE_VSNPRINTF
 
-#ifndef HAVE_MEMMOVE
-#define memmove(d,s,n) bcopy(s,d,n)
-#endif
+/* Define if you have the waitpid function.  */
+#undef HAVE_WAITPID
 
+/* Define if you have the <compat.h> header file.  */
+#undef HAVE_COMPAT_H
 
-/* for signal declarations */
-#undef RETSIGTYPE
+/* Define if you have the <ctype.h> header file.  */
+#undef HAVE_CTYPE_H
 
-/* needed for mknod */
-#undef HAVE_ST_RDEV
+/* Define if you have the <dirent.h> header file.  */
+#undef HAVE_DIRENT_H
 
-/* Define if the system does not provide POSIX.1 features except
-   with this defined.  */
-#undef _POSIX_1_SOURCE
+/* Define if you have the <fcntl.h> header file.  */
+#undef HAVE_FCNTL_H
 
-/* Define if you need to in order for stat and other things to work.  */
-#undef _POSIX_SOURCE
+/* Define if you have the <grp.h> header file.  */
+#undef HAVE_GRP_H
 
-/* Define as the return type of signal handlers (int or void).  */
-#undef RETSIGTYPE
+/* Define if you have the <ndir.h> header file.  */
+#undef HAVE_NDIR_H
 
-/* pgrp info */
-#undef GETPGRP_VOID
-#undef SETPGRP_VOID
+/* Define if you have the <stdlib.h> header file.  */
+#undef HAVE_STDLIB_H
 
-/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+/* Define if you have the <string.h> header file.  */
+#undef HAVE_STRING_H
 
-/* HP/UX source */
-#undef _HPUX_SOURCE
+/* Define if you have the <sys/dir.h> header file.  */
+#undef HAVE_SYS_DIR_H
 
-/* Use the "union wait" union to get process status from wait3/waitpid */
-#undef HAVE_UNION_WAIT
+/* Define if you have the <sys/fcntl.h> header file.  */
+#undef HAVE_SYS_FCNTL_H
 
-/* Define if <errno.h> contains a declaration for extern int errno */
-#undef HAVE_ERRNO_DECL
+/* Define if you have the <sys/filio.h> header file.  */
+#undef HAVE_SYS_FILIO_H
+
+/* Define if you have the <sys/ioctl.h> header file.  */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define if you have the <sys/mode.h> header file.  */
+#undef HAVE_SYS_MODE_H
+
+/* Define if you have the <sys/ndir.h> header file.  */
+#undef HAVE_SYS_NDIR_H
+
+/* Define if you have the <sys/param.h> header file.  */
+#undef HAVE_SYS_PARAM_H
+
+/* Define if you have the <sys/select.h> header file.  */
+#undef HAVE_SYS_SELECT_H
+
+/* Define if you have the <sys/socket.h> header file.  */
+#undef HAVE_SYS_SOCKET_H
+
+/* Define if you have the <sys/time.h> header file.  */
+#undef HAVE_SYS_TIME_H
+
+/* Define if you have the <sys/unistd.h> header file.  */
+#undef HAVE_SYS_UNISTD_H
+
+/* Define if you have the <sys/wait.h> header file.  */
+#undef HAVE_SYS_WAIT_H
+
+/* Define if you have the <unistd.h> header file.  */
+#undef HAVE_UNISTD_H
+
+/* Define if you have the <utime.h> header file.  */
+#undef HAVE_UTIME_H
+
+/* Define if you have the inet library (-linet).  */
+#undef HAVE_LIBINET
+
+/* Define if you have the nsl library (-lnsl).  */
+#undef HAVE_LIBNSL
 
-/* Define if on AIX 3.
-   System headers sometimes define this.
-   We just want to avoid a redefinition error message.  */
-#ifndef _ALL_SOURCE
-#undef _ALL_SOURCE
-#endif
+/* Define if you have the nsl_s library (-lnsl_s).  */
+#undef HAVE_LIBNSL_S
 
+/* Define if you have the socket library (-lsocket).  */
+#undef HAVE_LIBSOCKET
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/configure	1998-04-05 14:10:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/configure	1998-05-14 15:07:51.000000000 +0800
@@ -2204,13 +2204,13 @@
  
 else
   echo "$ac_t""no" 1>&6
 fi
 done
 
-for ac_func in memmove getopt_long lchown setlinebuf
+for ac_func in memmove getopt_long lchown setlinebuf vsnprintf setsid glob
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
 echo "configure:2214: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -2286,21 +2286,21 @@
   echo no
 fi
 rm -fr conftest*
 fi
 
 
-echo $ac_n "checking for long long... $ac_c"
+echo $ac_n "checking for long long ... $ac_c"
 if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
 #line 2298 "configure"
 #include "confdefs.h"
 #include <stdio.h>
-main() { long long x = 1000000000000; char b[20]; sprintf(b,"%lld", x); exit(strcmp("1000000000000", b) == 0? 0: 1); }
+main() { long long x = 1000000; x *= x; exit(((x/1000000) == 1000000)? 0: 1); }
 EOF
 if { (eval echo configure:2303: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   echo yes;cat >> confdefs.h <<\EOF
 #define HAVE_LONGLONG 1
 EOF
@@ -2312,23 +2312,105 @@
   echo no
 fi
 rm -fr conftest*
 fi
 
 
+echo $ac_n "checking for off64_t ... $ac_c"
+if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2324 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+#include <sys/stat.h>
+main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) return 1; exit((lstat64("/dev/null", &st)==0)?0:1); }
+EOF
+if { (eval echo configure:2330: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  echo yes;cat >> confdefs.h <<\EOF
+#define HAVE_OFF64_T 1
+EOF
+
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  echo no
+fi
+rm -fr conftest*
+fi
+
+
+echo $ac_n "checking for unsigned char ... $ac_c"
+if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2351 "configure"
+#include "confdefs.h"
+#include <stdio.h>
+main() { char c; c=250; exit((c > 0)?0:1); }
+EOF
+if { (eval echo configure:2356: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  echo yes;cat >> confdefs.h <<\EOF
+#define HAVE_UNSIGNED_CHAR 1
+EOF
+
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  echo no
+fi
+rm -fr conftest*
+fi
+
+
+echo $ac_n "checking for broken readdir ... $ac_c"
+if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2377 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <dirent.h>
+main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
+if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
+di->d_name[0] == 0) return 0; return 1;} 
+EOF
+if { (eval echo configure:2385: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+then
+  echo yes - you are using the broken /usr/ucb/cc;cat >> confdefs.h <<\EOF
+#define HAVE_BROKEN_READDIR 1
+EOF
+
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  echo no
+fi
+rm -fr conftest*
+fi
+
+
 echo $ac_n "checking for utimbuf ... $ac_c"
 cat > conftest.$ac_ext <<EOF
-#line 2321 "configure"
+#line 2403 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <utime.h>
 int main() {
 struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; return utime("foo.c",&tbuf);
 ; return 0; }
 EOF
-if { (eval echo configure:2329: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2411: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   echo yes;cat >> confdefs.h <<\EOF
 #define HAVE_UTIMBUF 1
 EOF
 
 else
@@ -2336,12 +2418,276 @@
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   echo no
 fi
 rm -f conftest*
 
+# The following test taken from the cvs sources
+# If we can't find connect, try looking in -lsocket, -lnsl, and -linet.
+# The Irix 5 libc.so has connect and gethostbyname, but Irix 5 also has
+# libsocket.so which has a bad implementation of gethostbyname (it
+# only looks in /etc/hosts), so we only look for -lsocket if we need
+# it.
+echo $ac_n "checking for connect""... $ac_c" 1>&6
+echo "configure:2432: checking for connect" >&5
+if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2437 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char connect(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char connect();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_connect) || defined (__stub___connect)
+choke me
+#else
+connect();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2460: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_connect=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_connect=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'connect`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+case "$LIBS" in
+*-lnsl*) ;;
+*) echo $ac_n "checking for printf in -lnsl_s""... $ac_c" 1>&6
+echo "configure:2480: checking for printf in -lnsl_s" >&5
+ac_lib_var=`echo nsl_s'_'printf | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lnsl_s  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2488 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char printf();
+
+int main() {
+printf()
+; return 0; }
+EOF
+if { (eval echo configure:2499: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo nsl_s | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lnsl_s $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+ ;;
+esac
+case "$LIBS" in
+*-lnsl*) ;;
+*) echo $ac_n "checking for printf in -lnsl""... $ac_c" 1>&6
+echo "configure:2530: checking for printf in -lnsl" >&5
+ac_lib_var=`echo nsl'_'printf | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lnsl  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2538 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char printf();
+
+int main() {
+printf()
+; return 0; }
+EOF
+if { (eval echo configure:2549: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo nsl | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lnsl $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+ ;;
+esac
+case "$LIBS" in
+*-lsocket*) ;;
+*) echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
+echo "configure:2580: checking for connect in -lsocket" >&5
+ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lsocket  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2588 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char connect();
+
+int main() {
+connect()
+; return 0; }
+EOF
+if { (eval echo configure:2599: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo socket | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lsocket $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+ ;;
+esac
+case "$LIBS" in
+*-linet*) ;;
+*) echo $ac_n "checking for connect in -linet""... $ac_c" 1>&6
+echo "configure:2630: checking for connect in -linet" >&5
+ac_lib_var=`echo inet'_'connect | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-linet  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2638 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char connect();
+
+int main() {
+connect()
+; return 0; }
+EOF
+if { (eval echo configure:2649: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo inet | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-linet $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+ ;;
+esac
+if test "$ac_cv_lib_socket_connect" = "yes" || 
+   test "$ac_cv_lib_inet_connect" = "yes"; then
+  ac_cv_func_connect=yes
+  cat >> confdefs.h <<\EOF
+#define HAVE_CONNECT 1
+EOF
+
+fi
+fi
+
+
+
 trap '' 1 2 15
 cat > confcache <<\EOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
 # scripts and configure runs.  It is not useful on other systems.
 # If it contains results you don't want to keep, you may remove or edit it.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/configure.in	1998-04-05 14:10:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/configure.in	1998-05-14 15:07:51.000000000 +0800
@@ -39,28 +39,82 @@
 
 AC_FUNC_MEMCMP
 AC_FUNC_MMAP
 AC_FUNC_UTIME_NULL
 AC_CHECK_FUNCS(waitpid strtok pipe getcwd mkdir strdup strerror chown chmod mknod)
 AC_CHECK_FUNCS(fchmod fstat strchr bcopy bzero readlink link utime utimes)
-AC_CHECK_FUNCS(memmove getopt_long lchown setlinebuf)
+AC_CHECK_FUNCS(memmove getopt_long lchown setlinebuf vsnprintf setsid glob)
 
 echo $ac_n "checking for working fnmatch... $ac_c"
 AC_TRY_RUN([#include <fnmatch.h>
 main() { exit(fnmatch("*.o", "x.o", 0) == 0? 0: 1); }],
 echo yes;AC_DEFINE(HAVE_FNMATCH), 
 echo no)
 
-echo $ac_n "checking for long long... $ac_c"
+echo $ac_n "checking for long long ... $ac_c"
 AC_TRY_RUN([#include <stdio.h>
-main() { long long x = 1000000000000; char b[20]; sprintf(b,"%lld", x); exit(strcmp("1000000000000", b) == 0? 0: 1); }],
+main() { long long x = 1000000; x *= x; exit(((x/1000000) == 1000000)? 0: 1); }],
 echo yes;AC_DEFINE(HAVE_LONGLONG), 
 echo no)
 
+echo $ac_n "checking for off64_t ... $ac_c"
+AC_TRY_RUN([#include <stdio.h>
+#include <sys/stat.h>
+main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) return 1; exit((lstat64("/dev/null", &st)==0)?0:1); }],
+echo yes;AC_DEFINE(HAVE_OFF64_T), 
+echo no)
+
+echo $ac_n "checking for unsigned char ... $ac_c"
+AC_TRY_RUN([#include <stdio.h>
+main() { char c; c=250; exit((c > 0)?0:1); }],
+echo yes;AC_DEFINE(HAVE_UNSIGNED_CHAR), 
+echo no)
+
+echo $ac_n "checking for broken readdir ... $ac_c"
+AC_TRY_RUN([#include <sys/types.h>
+#include <dirent.h>
+main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
+if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
+di->d_name[0] == 0) return 0; return 1;} ],
+echo yes - you are using the broken /usr/ucb/cc;AC_DEFINE(HAVE_BROKEN_READDIR), 
+echo no)
+
 echo $ac_n "checking for utimbuf ... $ac_c"
 AC_TRY_COMPILE([#include <sys/types.h>
 #include <utime.h>],
 [struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; return utime("foo.c",&tbuf);],
 echo yes;AC_DEFINE(HAVE_UTIMBUF), 
 echo no)
 
+# The following test taken from the cvs sources
+# If we can't find connect, try looking in -lsocket, -lnsl, and -linet.
+# The Irix 5 libc.so has connect and gethostbyname, but Irix 5 also has
+# libsocket.so which has a bad implementation of gethostbyname (it
+# only looks in /etc/hosts), so we only look for -lsocket if we need
+# it.
+AC_CHECK_FUNC(connect, :, 
+[case "$LIBS" in
+*-lnsl*) ;;
+*) AC_CHECK_LIB(nsl_s, printf) ;;
+esac
+case "$LIBS" in
+*-lnsl*) ;;
+*) AC_CHECK_LIB(nsl, printf) ;;
+esac
+case "$LIBS" in
+*-lsocket*) ;;
+*) AC_CHECK_LIB(socket, connect) ;;
+esac
+case "$LIBS" in
+*-linet*) ;;
+*) AC_CHECK_LIB(inet, connect) ;;
+esac
+dnl We can't just call AC_CHECK_FUNCS(connect) here, because the value
+dnl has been cached.
+if test "$ac_cv_lib_socket_connect" = "yes" || 
+   test "$ac_cv_lib_inet_connect" = "yes"; then
+  ac_cv_func_connect=yes
+  AC_DEFINE(HAVE_CONNECT)
+fi])
+
+
 AC_OUTPUT(Makefile lib/dummy)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: connection.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/cvs.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/cvs.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/cvs.log	1998-04-17 14:49:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/cvs.log	1998-05-14 15:24:58.000000000 +0800
@@ -2452,6 +2452,1261 @@
 
 Modified Files:
 	version.h 
 Log Message:
 preparing for release of 1.7.4
 
+
+****************************************
+Date:	Saturday April 18, 1998 @ 1:48
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv12003
+
+Modified Files:
+	test.sh 
+Log Message:
+
+a much improved test script from Phil. 
+
+
+
+****************************************
+Date:	Tuesday April 28, 1998 @ 15:10
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21477
+
+Modified Files:
+	rsync.1 
+Log Message:
+added missing comma in CVS exclude description
+
+
+
+****************************************
+Date:	Tuesday April 28, 1998 @ 15:53
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16779
+
+Modified Files:
+	rsync.h 
+Log Message:
+
+added support for sockets and fifos
+
+
+
+
+****************************************
+Date:	Tuesday May 5, 1998 @ 21:23
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv7723
+
+Modified Files:
+	exclude.c 
+Log Message:
+
+a leading / in a pattern now means "use a absolute path match". This
+allows you to exclude root directories without excluding
+subdirectories of the same name.
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 15:05
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv19934
+
+Modified Files:
+	configure configure.in io.c rsync.h 
+Log Message:
+fix up the int64 handling a little. It should work on a few more
+systems now (tested on OSF1)
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 15:43
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv17821
+
+Modified Files:
+	checksum.c configure configure.in flist.c hlink.c main.c 
+	match.c proto.h rsync.c rsync.h syscall.c util.c 
+Log Message:
+
+added support for 64 bit file offsets under Solaris 2.6. Not tested
+yet.
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 16:07
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv1895
+
+Modified Files:
+	configure configure.in main.c syscall.c 
+Log Message:
+
+use floating point for printout of stats - this wrks on machines
+without long long but with a 64 bit off_t
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 16:21
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv10608
+
+Modified Files:
+	README checksum.c configure configure.in match.c rsync.h 
+Log Message:
+
+Solaris 2.6 doesn't support "signed char". What a broken system!
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 16:26
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16216
+
+Modified Files:
+	config.h.in 
+Log Message:
+
+need a couple more #undefs in here for solaris
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 16:34
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv26595
+
+Modified Files:
+	io.c mkproto.awk proto.h syscall.c util.c 
+Log Message:
+
+add support for lseek64() under solaris 2.6
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 17:00
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv2818
+
+Modified Files:
+	configure.in flist.c proto.h rsync.c rsync.h syscall.c 
+Log Message:
+
+handle broken readdir() on Solaris 2.6 (it returns the name offset by
+2 characters!)
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 17:18
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16845
+
+Modified Files:
+	configure configure.in syscall.c 
+Log Message:
+
+better test for solaris broken readdir
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 17:21
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21253
+
+Modified Files:
+	config.h.in 
+Log Message:
+need an #undef for HAVE_BROKEN_READDIR
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 17:28
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv1181
+
+Modified Files:
+	util.c 
+Log Message:
+
+handle mmap() failures
+
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 17:35
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv17068
+
+Modified Files:
+	syscall.c 
+Log Message:
+
+damn solaris doesn't prototype it's functions correctly. grrr.
+
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 18:01
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv26955
+
+Modified Files:
+	configure.in 
+Log Message:
+
+don't need off64_t code on systems where off_t is already 64 bits
+
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 6, 1998 @ 18:02
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv3742
+
+Modified Files:
+	configure 
+Log Message:
+
+don't need off64_t code on systems where off_t is already 64 bits
+
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 7, 1998 @ 0:13
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv17319
+
+Modified Files:
+	io.c proto.h 
+Log Message:
+hopefully better support for systems where sizeof(int)==8
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 7, 1998 @ 13:57
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv19621
+
+Modified Files:
+	config.h.in 
+Added Files:
+	acconfig.h 
+Log Message:
+
+now using autoheader as well as autoconf
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 7, 1998 @ 14:18
+Author:	paulus
+
+Update of /data/cvs/rsync/zlib
+In directory samba:/tmp/cvs-serv27161/zlib
+
+Log Message:
+Directory /data/cvs/rsync/zlib added to the repository
+
+
+
+****************************************
+Date:	Thursday May 7, 1998 @ 16:19
+Author:	paulus
+
+Update of /data/cvs/rsync/zlib
+In directory samba:/tmp/cvs-serv23191
+
+Added Files:
+	ChangeLog Makefile README adler32.c crc32.c deflate.c 
+	deflate.h dummy.in infblock.c infblock.h infcodes.c infcodes.h 
+	inffast.c inffast.h inffixed.h inflate.c inftrees.c inftrees.h 
+	infutil.c infutil.h trees.c trees.h zconf.h zlib.h zutil.c 
+	zutil.h 
+Log Message:
+Add pristine zlib-1.1.2 code, ready for hacking.
+
+
+
+****************************************
+Date:	Thursday May 7, 1998 @ 22:29
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21819
+
+Modified Files:
+	configure.in 
+Log Message:
+
+improve the autoconf warning for broken readdir
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 7, 1998 @ 22:30
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv13677
+
+Modified Files:
+	main.c 
+Log Message:
+
+some code cleanup in preparation for a cleaner client/server split
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Friday May 8, 1998 @ 0:50
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv6099
+
+Modified Files:
+	Makefile.in compat.c config.h.in configure configure.in 
+	exclude.c flist.c hlink.c io.c main.c match.c md4.c proto.h 
+	rsync.c rsync.h token.c util.c 
+Log Message:
+
+some large systematic changes to make socket conversion easier. The
+biggest one is the use of rprintf() instead of fprintf()
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Friday May 8, 1998 @ 0:52
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv14586
+
+Modified Files:
+	test.sh 
+Log Message:
+
+removed some quoted printable stuff from this so it works again 
+
+
+
+****************************************
+Date:	Friday May 8, 1998 @ 0:53
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv13913
+
+Added Files:
+	socket.c 
+Log Message:
+
+just a stub for now
+
+
+
+****************************************
+Date:	Saturday May 9, 1998 @ 23:59
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv9478
+
+Modified Files:
+	Makefile.in config.h.in configure configure.in io.c main.c 
+	mkproto.awk proto.h rsync.h socket.c syscall.c util.c 
+Log Message:
+
+first vesrion of working socket based rsync. It still needs a lot of
+work, but at least it works :-)
+
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 0:00
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv13688
+
+Added Files:
+	loadparm.c log.c params.c 
+Log Message:
+
+configuration parsing and loading code for rsyncd. This is based
+on the Samba config code, so you'll find that the config files will
+be eerily familiar if you have ever worked with Samba.
+
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 11:46
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv27431
+
+Modified Files:
+	Makefile.in main.c proto.h rsync.h 
+Log Message:
+
+cleanup code a bit
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 11:46
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20307
+
+Added Files:
+	clientserver.c 
+Log Message:
+
+cleanup code a bit
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 13:08
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv17848
+
+Modified Files:
+	clientserver.c 
+Log Message:
+better negotiation of protocol versions
+
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 17:25
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv966
+
+Modified Files:
+	Makefile.in clientserver.c flist.c main.c proto.h rsync.c 
+	util.c 
+Added Files:
+	options.c 
+Log Message:
+split the options parsing code into options.c
+
+added the --port and --config options
+
+use strlcpy() instead of strncpy()
+
+some cleanups and formatting changes
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 17:40
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv12477
+
+Modified Files:
+	acconfig.h config.h.in configure configure.in 
+Log Message:
+look for -lsocket by checking for connect()
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 17:45
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv9839
+
+Modified Files:
+	configure configure.in 
+Log Message:
+
+fixed typo in socket test
+
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 18:06
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv25390
+
+Modified Files:
+	clientserver.c configure.in loadparm.c proto.h socket.c 
+	uidlist.c util.c 
+Log Message:
+
+change to allow names or numbers to be used for uid and gid. 
+
+
+
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 18:24
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv3756
+
+Modified Files:
+	clientserver.c log.c main.c proto.h rsync.h socket.c util.c 
+Log Message:
+
+use syslog instead of /var/adm/rsyncd.log
+
+
+
+
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 18:31
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8889
+
+Modified Files:
+	loadparm.c log.c 
+Log Message:
+
+only call openlog once
+
+fix a segv in loadparm.c
+
+
+
+
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 22:37
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20759
+
+Modified Files:
+	flist.c loadparm.c 
+Log Message:
+
+changed a couple of places to use strlcpy()
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 23:02
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv10424
+
+Modified Files:
+	main.c 
+Log Message:
+
+the statistics reporting was the wrong way around for client receipt
+mode! It reported the read/written backwards.
+
+
+
+
+
+****************************************
+Date:	Sunday May 10, 1998 @ 23:45
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv1183
+
+Modified Files:
+	rsync.c 
+Log Message:
+
+changed the name of the temporary filename to include a leading . so
+that it appears hidden while being transferred. This should be useful
+when using rsync for mirroring so users accessing via ftp don't get
+confused by the temporary files.
+
+
+
+****************************************
+Date:	Monday May 11, 1998 @ 22:29
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv9147
+
+Modified Files:
+	rsync.c 
+Log Message:
+fixed a bug in the new . filename code
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 10:08
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv13537
+
+Modified Files:
+	clientserver.c 
+Log Message:
+load the config file on each connect rather than at startup
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 17:04
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv1786
+
+Modified Files:
+	main.c 
+Log Message:
+check argc and show usage if no args
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 18:03
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv23991
+
+Modified Files:
+	Makefile.in clientserver.c loadparm.c proto.h 
+Added Files:
+	access.c 
+Log Message:
+added hosts allow and hosts deny support. I ended up writing my own as
+the tcpd code is not quite what I wanted.
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 18:12
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21509
+
+Modified Files:
+	loadparm.c log.c proto.h 
+Log Message:
+
+added "syslog facility" option. It is an integer and defaults to the
+value of LOG_DAEMON.
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 18:52
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv6234
+
+Modified Files:
+	Makefile.in clientserver.c loadparm.c proto.h util.c 
+Added Files:
+	connection.c 
+Log Message:
+
+added two new options "max connections" and "lock file"
+
+
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 18:58
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv1810
+
+Modified Files:
+	clientserver.c compat.c 
+Log Message:
+save one round trip (version swapping) for daemon.
+
+This is an imcompatible change in the socket protocol. You get "is
+your shell clean" if using an older rsync client
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 19:01
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv17244
+
+Modified Files:
+	rsync.h 
+Log Message:
+need sys/file.h for flock()
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 19:08
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv2893
+
+Modified Files:
+	clientserver.c 
+Log Message:
+save another couple of round trip latencies. This set of changes is
+backwards compatible.
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 19:39
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv27759
+
+Modified Files:
+	clientserver.c connection.c loadparm.c proto.h util.c 
+Added Files:
+	authenticate.c 
+Log Message:
+
+improved max connections code. Now use fcntl instead of flock. 
+
+also started on authentication code (I'm doing a challenge response
+system initially)
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 21:49
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8687
+
+Modified Files:
+	Makefile.in authenticate.c clientserver.c 
+Log Message:
+first working version of challenge response authentication. needs
+testing.
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 22:21
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv1652
+
+Modified Files:
+	authenticate.c clientserver.c 
+Log Message:
+improved the authentication and in particular the error reporting
+
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 23:22
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4897
+
+Modified Files:
+	rsync.h 
+Log Message:
+define INADDR_NONE if necessary
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 23:27
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv5156
+
+Modified Files:
+	compat.c 
+Log Message:
+added replacement memmove
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 23:48
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv6188
+
+Modified Files:
+	log.c proto.h 
+Log Message:
+vsprintf returns char* on sunos4
+
+
+
+
+
+
+
+
+****************************************
+Date:	Wednesday May 13, 1998 @ 23:52
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv6405
+
+Modified Files:
+	io.c 
+Log Message:
+vsprintf returns char* on sunos4
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 0:07
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8225
+
+Modified Files:
+	configure 
+Log Message:
+minor update
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 1:44
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv24193
+
+Modified Files:
+	clientserver.c config.h.in configure configure.in main.c 
+	proto.h rsync.h util.c 
+Log Message:
+added globbing support in the rsync daemon. This will allow you to 
+specify wildcards when grabbing files from a anon rsync daemon. 
+
+
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 1:56
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv26322
+
+Modified Files:
+	util.c 
+Log Message:
+removed a debug line
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 14:31
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv17340
+
+Modified Files:
+	access.c proto.h util.c 
+Log Message:
+make host access controls case insensitive
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 14:38
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21670
+
+Modified Files:
+	loadparm.c 
+Log Message:
+changed "syslog facility" to an enumerated type so the string name is
+used in rsyncd.conf
+
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 14:40
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20603
+
+Modified Files:
+	loadparm.c 
+Log Message:
+now support integers or strings for syslog facility
+
+
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 14:49
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv12029
+
+Modified Files:
+	main.c 
+Log Message:
+syslog some stats
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 16:51
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv25520
+
+Modified Files:
+	Makefile.in loadparm.c rsync.1 
+Added Files:
+	rsync.yo rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+
+documentation!
+
+I've written a rsyncd.conf man page (in yodl) and updated the rsync
+man page.
+
+
+
+
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 16:57
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21797
+
+Modified Files:
+	rsync.yo rsyncd.conf.yo 
+Log Message:
+fixed spelling mistakes
+
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 17:22
+Author:	rsync-bu
+
+Update of /data/cvs/rsync
+In directory samba:/data/people/rsync-bugs/rsync
+
+Modified Files:
+	version.h 
+Log Message:
+preparing for release of 2.0.0
+
+
+****************************************
+Date:	Thursday May 14, 1998 @ 17:24
+Author:	rsync-bu
+
+Update of /data/cvs/rsync
+In directory samba:/data/people/rsync-bugs/rsync
+
+Modified Files:
+	rsyncd.conf.5 
+Log Message:
+preparing for release of 2.0.0
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/exclude.c	1998-04-05 14:10:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/exclude.c	1998-05-14 15:07:51.000000000 +0800
@@ -21,13 +21,12 @@
   a lot of this stuff was derived from GNU tar
   */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int am_server;
 
 static char **exclude_list;
 
 static int is_regex(char *str)
 {
   return strchr(str, '*') || strchr(str, '[') || strchr(str, '?');
@@ -40,12 +39,14 @@
 
   if (!strchr(pattern,'/') && (p=strrchr(name,'/')))
     name = p+1;
 
   if (!name[0]) return 0;
 
+  if (*pattern == '/' && *name != '/') pattern++;
+
   if (is_regex(pattern)) {
     if (fnmatch(pattern, name, 0) == 0)
       return 1;
   } else {
     int l1 = strlen(name);
     int l2 = strlen(pattern);
@@ -84,13 +85,13 @@
   int len=0;
   if (list && *list)
     for (; (*list)[len]; len++) ;
 
   if (strcmp(pattern,"!") == 0) {
     if (verbose > 2)
-      fprintf(FINFO,"clearing exclude list\n");
+      rprintf(FINFO,"clearing exclude list\n");
     while ((len)--) 
       free((*list)[len]);
     free((*list));
     *list = NULL;
     return;
   }
@@ -102,13 +103,13 @@
   }
 
   if (!*list || !((*list)[len] = strdup(pattern)))
     out_of_memory("add_exclude");
 
   if (verbose > 2)
-    fprintf(FINFO,"add_exclude(%s)\n",pattern);
+    rprintf(FINFO,"add_exclude(%s)\n",pattern);
   
   (*list)[len+1] = NULL;
 }
 
 void add_exclude(char *pattern)
 {
@@ -119,13 +120,13 @@
 {
   char **list=list1;
   FILE *f = fopen(fname,"r");
   char line[MAXPATHLEN];
   if (!f) {
     if (fatal) {
-      fprintf(FERROR,"%s : %s\n",fname,strerror(errno));
+      rprintf(FERROR,"%s : %s\n",fname,strerror(errno));
       exit_cleanup(1);
     }
     return list;
   }
 
   while (fgets(line,MAXPATHLEN,f)) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/flist.c	1998-04-17 14:48:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/flist.c	1998-05-14 15:07:51.000000000 +0800
@@ -45,45 +45,45 @@
 extern int copy_links;
 extern int remote_version;
 extern int io_error;
 
 static char **local_exclude_list;
 
-int link_stat(const char *Path, struct stat *Buffer) 
+int link_stat(const char *Path, STRUCT_STAT *Buffer) 
 {
 #if SUPPORT_LINKS
     if (copy_links) {
-	return stat(Path, Buffer);
+	return do_stat(Path, Buffer);
     } else {
-	return lstat(Path, Buffer);
+	return do_lstat(Path, Buffer);
     }
 #else
-    return stat(Path, Buffer);
+    return do_stat(Path, Buffer);
 #endif
 }
 
 /*
   This function is used to check if a file should be included/excluded
   from the list of files based on its name and type etc
  */
-static int match_file_name(char *fname,struct stat *st)
+static int match_file_name(char *fname,STRUCT_STAT *st)
 {
   if (check_exclude(fname,local_exclude_list)) {
     if (verbose > 2)
-      fprintf(FINFO,"excluding file %s\n",fname);
+      rprintf(FINFO,"excluding file %s\n",fname);
     return 0;
   }
   return 1;
 }
 
 /* used by the one_file_system code */
 static dev_t filesystem_dev;
 
 static void set_filesystem(char *fname)
 {
-  struct stat st;
+  STRUCT_STAT st;
   if (link_stat(fname,&st) != 0) return;
   filesystem_dev = st.st_dev;
 }
 
 
 static void send_directory(int f,struct file_list *flist,char *dir);
@@ -215,13 +215,13 @@
   last_mode = file->mode;
   last_rdev = file->rdev;
   last_uid = file->uid;
   last_gid = file->gid;
   last_time = file->modtime;
 
-  strncpy(lastname,fname,MAXPATHLEN-1);
+  strlcpy(lastname,fname,MAXPATHLEN-1);
   lastname[MAXPATHLEN-1] = 0;
 }
 
 
 
 static void receive_file_entry(struct file_struct **fptr,
@@ -250,17 +250,17 @@
   if (!file) out_of_memory("receive_file_entry");
   bzero((char *)file,sizeof(*file));
   (*fptr) = file;
 
   if (l2 >= MAXPATHLEN-l1) overflow("receive_file_entry");
 
-  strncpy(thisname,lastname,l1);
+  strlcpy(thisname,lastname,l1);
   read_sbuf(f,&thisname[l1],l2);
   thisname[l1+l2] = 0;
 
-  strncpy(lastname,thisname,MAXPATHLEN-1);
+  strlcpy(lastname,thisname,MAXPATHLEN-1);
   lastname[MAXPATHLEN-1] = 0;
 
   clean_fname(thisname);
 
   if ((p = strrchr(thisname,'/'))) {
 	  static char *lastdir;
@@ -319,15 +319,15 @@
 }
 
 
 /* determine if a file in a different filesstem should be skipped
    when one_file_system is set. We bascally only want to include
    the mount points - but they can be hard to find! */
-static int skip_filesystem(char *fname, struct stat *st)
+static int skip_filesystem(char *fname, STRUCT_STAT *st)
 {
-	struct stat st2;
+	STRUCT_STAT st2;
 	char *p = strrchr(fname, '/');
 
 	/* skip all but directories */
 	if (!S_ISDIR(st->st_mode)) return 1;
 
 	/* if its not a subdirectory then allow */
@@ -343,46 +343,46 @@
 	return (st2.st_dev != filesystem_dev);
 }
 
 static struct file_struct *make_file(char *fname)
 {
 	struct file_struct *file;
-	struct stat st;
+	STRUCT_STAT st;
 	char sum[SUM_LENGTH];
 	char *p;
 	char cleaned_name[MAXPATHLEN];
 
-	strncpy(cleaned_name, fname, MAXPATHLEN-1);
+	strlcpy(cleaned_name, fname, MAXPATHLEN-1);
 	cleaned_name[MAXPATHLEN-1] = 0;
 	clean_fname(cleaned_name);
 	fname = cleaned_name;
 
 	bzero(sum,SUM_LENGTH);
 
 	if (link_stat(fname,&st) != 0) {
 		io_error = 1;
-		fprintf(FERROR,"%s: %s\n",
+		rprintf(FERROR,"%s: %s\n",
 			fname,strerror(errno));
 		return NULL;
 	}
 
 	if (S_ISDIR(st.st_mode) && !recurse) {
-		fprintf(FINFO,"skipping directory %s\n",fname);
+		rprintf(FINFO,"skipping directory %s\n",fname);
 		return NULL;
 	}
 	
 	if (one_file_system && st.st_dev != filesystem_dev) {
 		if (skip_filesystem(fname, &st))
 			return NULL;
 	}
 	
 	if (!match_file_name(fname,&st))
 		return NULL;
 	
 	if (verbose > 2)
-		fprintf(FINFO,"make_file(%s)\n",fname);
+		rprintf(FINFO,"make_file(%s)\n",fname);
 	
 	file = (struct file_struct *)malloc(sizeof(*file));
 	if (!file) out_of_memory("make_file");
 	bzero((char *)file,sizeof(*file));
 
 	if ((p = strrchr(fname,'/'))) {
@@ -415,13 +415,13 @@
 #if SUPPORT_LINKS
 	if (S_ISLNK(st.st_mode)) {
 		int l;
 		char lnk[MAXPATHLEN];
 		if ((l=readlink(fname,lnk,MAXPATHLEN-1)) == -1) {
 			io_error=1;
-			fprintf(FERROR,"readlink %s : %s\n",
+			rprintf(FERROR,"readlink %s : %s\n",
 				fname,strerror(errno));
 			return NULL;
 		}
 		lnk[l] = 0;
 		file->link = strdup(lnk);
 	}
@@ -504,24 +504,23 @@
 	int l;
 	char *p;
 
 	d = opendir(dir);
 	if (!d) {
 		io_error = 1;
-		fprintf(FERROR,"%s: %s\n",
+		rprintf(FERROR,"%s: %s\n",
 			dir,strerror(errno));
 		return;
 	}
 
-	strncpy(fname,dir,MAXPATHLEN-1);
-	fname[MAXPATHLEN-1]=0;
+	strlcpy(fname,dir,MAXPATHLEN-1);
 	l = strlen(fname);
 	if (fname[l-1] != '/') {
 		if (l == MAXPATHLEN-1) {
 			io_error = 1;
-			fprintf(FERROR,"skipping long-named directory %s\n",fname);
+			rprintf(FERROR,"skipping long-named directory %s\n",fname);
 			closedir(d);
 			return;
 		}
 		strcat(fname,"/");
 		l++;
 	}
@@ -530,41 +529,42 @@
 	if (cvs_exclude) {
 		if (strlen(fname) + strlen(".cvsignore") <= MAXPATHLEN-1) {
 			strcpy(p,".cvsignore");
 			local_exclude_list = make_exclude_list(fname,NULL,0);
 		} else {
 			io_error = 1;
-			fprintf(FINFO,"cannot cvs-exclude in long-named directory %s\n",fname);
+			rprintf(FINFO,"cannot cvs-exclude in long-named directory %s\n",fname);
 		}
 	}  
 	
 	for (di=readdir(d); di; di=readdir(d)) {
-		if (strcmp(di->d_name,".")==0 ||
-		    strcmp(di->d_name,"..")==0)
+		char *dname = d_name(di);
+		if (strcmp(dname,".")==0 ||
+		    strcmp(dname,"..")==0)
 			continue;
-		strncpy(p,di->d_name,MAXPATHLEN-(l+1));
+		strlcpy(p,dname,MAXPATHLEN-(l+1));
 		send_file_name(f,flist,fname,recurse,FLAG_DELETE);
 	}
 
 	closedir(d);
 }
 
 
 
 struct file_list *send_file_list(int f,int argc,char *argv[])
 {
 	int i,l;
-	struct stat st;
+	STRUCT_STAT st;
 	char *p,*dir;
 	char dbuf[MAXPATHLEN];
 	char lastpath[MAXPATHLEN]="";
 	struct file_list *flist;
 
 	if (verbose && recurse && !am_server && f != -1) {
-		fprintf(FINFO,"building file list ... ");
-		fflush(FINFO);
+		rprintf(FINFO,"building file list ... ");
+		rflush(FINFO);
 	}
 
 	flist = (struct file_list *)malloc(sizeof(flist[0]));
 	if (!flist) out_of_memory("send_file_list");
 
 	flist->count=0;
@@ -574,28 +574,27 @@
 	if (!flist->files) out_of_memory("send_file_list");
 
 	for (i=0;i<argc;i++) {
 		char fname2[MAXPATHLEN];
 		char *fname = fname2;
 
-		strncpy(fname,argv[i],MAXPATHLEN-1);
-		fname[MAXPATHLEN-1] = 0;
+		strlcpy(fname,argv[i],MAXPATHLEN-1);
 
 		l = strlen(fname);
 		if (l != 1 && fname[l-1] == '/') {
 			strcat(fname,".");
 		}
 
 		if (link_stat(fname,&st) != 0) {
 			io_error=1;
-			fprintf(FERROR,"%s : %s\n",fname,strerror(errno));
+			rprintf(FERROR,"%s : %s\n",fname,strerror(errno));
 			continue;
 		}
 
 		if (S_ISDIR(st.st_mode) && !recurse) {
-			fprintf(FINFO,"skipping directory %s\n",fname);
+			rprintf(FINFO,"skipping directory %s\n",fname);
 			continue;
 		}
 
 		dir = NULL;
 
 		if (!relative_paths) {
@@ -627,28 +626,28 @@
 		
 		if (!*fname)
 			fname = ".";
 		
 		if (dir && *dir) {
 			if (getcwd(dbuf,MAXPATHLEN-1) == NULL) {
-				fprintf(FERROR,"getwd : %s\n",strerror(errno));
+				rprintf(FERROR,"getwd : %s\n",strerror(errno));
 				exit_cleanup(1);
 			}
 			if (chdir(dir) != 0) {
 				io_error=1;
-				fprintf(FERROR,"chdir %s : %s\n",
+				rprintf(FERROR,"chdir %s : %s\n",
 					dir,strerror(errno));
 				continue;
 			}
 			flist_dir = dir;
 			if (one_file_system)
 				set_filesystem(fname);
 			send_file_name(f,flist,fname,recurse,FLAG_DELETE);
 			flist_dir = NULL;
 			if (chdir(dbuf) != 0) {
-				fprintf(FERROR,"chdir %s : %s\n",
+				rprintf(FERROR,"chdir %s : %s\n",
 					dbuf,strerror(errno));
 				exit_cleanup(1);
 			}
 			continue;
 		}
 		
@@ -660,13 +659,13 @@
 	if (f != -1) {
 		send_file_entry(NULL,f,0);
 		write_flush(f);
 	}
 
 	if (verbose && recurse && !am_server && f != -1)
-		fprintf(FINFO,"done\n");
+		rprintf(FINFO,"done\n");
 	
 	clean_flist(flist);
 	
 	/* now send the uid/gid list. This was introduced in protocol
            version 15 */
 	if (f != -1 && remote_version >= 15) {
@@ -676,26 +675,26 @@
 	/* if protocol version is >= 17 then send the io_error flag */
 	if (f != -1 && remote_version >= 17) {
 		write_int(f, io_error);
 	}
 
 	if (verbose > 2)
-		fprintf(FINFO,"send_file_list done\n");
+		rprintf(FINFO,"send_file_list done\n");
 
 	return flist;
 }
 
 
 struct file_list *recv_file_list(int f)
 {
   struct file_list *flist;
   unsigned char flags;
 
   if (verbose && recurse && !am_server) {
-    fprintf(FINFO,"receiving file list ... ");
-    fflush(FINFO);
+    rprintf(FINFO,"receiving file list ... ");
+    rflush(FINFO);
   }
 
   flist = (struct file_list *)malloc(sizeof(flist[0]));
   if (!flist)
     goto oom;
 
@@ -727,23 +726,23 @@
     if (S_ISREG(flist->files[i]->mode))
       total_size += flist->files[i]->length;
 
     flist->count++;
 
     if (verbose > 2)
-      fprintf(FINFO,"recv_file_name(%s)\n",f_name(flist->files[i]));
+      rprintf(FINFO,"recv_file_name(%s)\n",f_name(flist->files[i]));
   }
 
 
   if (verbose > 2)
-    fprintf(FINFO,"received %d names\n",flist->count);
+    rprintf(FINFO,"received %d names\n",flist->count);
 
   clean_flist(flist);
 
   if (verbose && recurse && !am_server) {
-    fprintf(FINFO,"done\n");
+    rprintf(FINFO,"done\n");
   }
 
   /* now recv the uid/gid list. This was introduced in protocol version 15 */
   if (f != -1 && remote_version >= 15) {
 	  recv_uid_list(f, flist);
   }
@@ -751,13 +750,13 @@
   /* if protocol version is >= 17 then recv the io_error flag */
   if (f != -1 && remote_version >= 17) {
 	  io_error |= read_int(f);
   }
 
   if (verbose > 2)
-    fprintf(FINFO,"recv_file_list done\n");
+    rprintf(FINFO,"recv_file_list done\n");
 
   return flist;
 
 oom:
     out_of_memory("recv_file_list");
     return NULL; /* not reached */
@@ -846,13 +845,13 @@
 	for (i=1;i<flist->count;i++) {
 		if (flist->files[i]->basename &&
 		    flist->files[i-1]->basename &&
 		    strcmp(f_name(flist->files[i]),
 			   f_name(flist->files[i-1])) == 0) {
 			if (verbose > 1 && !am_server)
-				fprintf(FINFO,"removing duplicate name %s from file list %d\n",
+				rprintf(FINFO,"removing duplicate name %s from file list %d\n",
 					f_name(flist->files[i-1]),i-1);
 			free_file(flist->files[i]);
 		} 
 	}
 }
 
@@ -870,12 +869,12 @@
 
 	n = (n+1)%10;
 
 	if (f->dirname) {
 		sprintf(p, "%s/%s", f->dirname, f->basename);
 	} else {
-		strcpy(p, f->basename);
+		strlcpy(p, f->basename, MAXPATHLEN-1);
 	}
 
 	return p;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/hlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/hlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/hlink.c	1998-04-17 14:48:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/hlink.c	1998-05-14 15:07:51.000000000 +0800
@@ -16,13 +16,12 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
-extern int am_server;
 extern int dry_run;
 extern int verbose;
 
 #if SUPPORT_HARD_LINKS
 static int hlink_compare(struct file_struct *f1,struct file_struct *f2)
 {
@@ -103,38 +102,38 @@
 }
 
 
 #if SUPPORT_HARD_LINKS
 static void hard_link_one(int i)
 {
-	struct stat st1,st2;
+	STRUCT_STAT st1,st2;
 
 	if (link_stat(f_name(&hlink_list[i-1]),&st1) != 0) return;
 
 	if (link_stat(f_name(&hlink_list[i]),&st2) != 0) {
 		if (do_link(f_name(&hlink_list[i-1]),f_name(&hlink_list[i])) != 0) {
 			if (verbose > 0)
-				fprintf(FINFO,"link %s => %s : %s\n",
+				rprintf(FINFO,"link %s => %s : %s\n",
 					f_name(&hlink_list[i]),
 					f_name(&hlink_list[i-1]),strerror(errno));
 			return;
 		}
 	} else {
 		if (st2.st_dev == st1.st_dev && st2.st_ino == st1.st_ino) return;
 		
 		if (do_unlink(f_name(&hlink_list[i])) != 0 ||
 		    do_link(f_name(&hlink_list[i-1]),f_name(&hlink_list[i])) != 0) {
 			if (verbose > 0)
-				fprintf(FINFO,"link %s => %s : %s\n",
+				rprintf(FINFO,"link %s => %s : %s\n",
 					f_name(&hlink_list[i]),
 					f_name(&hlink_list[i-1]),strerror(errno));
 			return;
 		}
 	}
 	if (verbose > 0)
-		fprintf(FINFO,"%s => %s\n",
+		rprintf(FINFO,"%s => %s\n",
 			f_name(&hlink_list[i]),f_name(&hlink_list[i-1]));
 }
 #endif
 
 /* create any hard links in the flist */
 void do_hard_links(struct file_list *flist)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/io.c	1998-04-05 14:45:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/io.c	1998-05-14 15:07:51.000000000 +0800
@@ -110,13 +110,13 @@
 		return;
 	}
 
 	t = time(NULL);
 
 	if (last_io && io_timeout && (t-last_io)>io_timeout) {
-		fprintf(FERROR,"read timeout after %d second - exiting\n", 
+		rprintf(FERROR,"read timeout after %d second - exiting\n", 
 			(int)(t-last_io));
 		exit_cleanup(1);
 	}
 }
 
 static int readfd(int fd,char *buffer,int N)
@@ -161,19 +161,19 @@
 	if (io_timeout)
 		last_io = time(NULL);
 	return total;
 }
 
 
-int read_int(int f)
+int32 read_int(int f)
 {
   int ret;
   char b[4];
   if ((ret=readfd(f,b,4)) != 4) {
     if (verbose > 1) 
-      fprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
+      rprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
 	      getpid(),4,ret==-1?strerror(errno):"EOF");
     exit_cleanup(1);
   }
   total_read += 4;
   return IVAL(b,0);
 }
@@ -182,22 +182,22 @@
 {
 	extern int remote_version;
 	int64 ret;
 	char b[8];
 	ret = read_int(f);
 
-	if (ret != -1) return ret;
+	if ((int32)ret != (int32)0xffffffff) return ret;
 
-#ifndef HAVE_LONGLONG
-	fprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
+#ifdef NO_INT64
+	rprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
 	exit_cleanup(1);
 #else
 	if (remote_version >= 16) {
 		if ((ret=readfd(f,b,8)) != 8) {
 			if (verbose > 1) 
-				fprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
+				rprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
 					getpid(),8,ret==-1?strerror(errno):"EOF");
 			exit_cleanup(1);
 		}
 		total_read += 8;
 		ret = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
 	}
@@ -208,13 +208,13 @@
 
 void read_buf(int f,char *buf,int len)
 {
   int ret;
   if ((ret=readfd(f,buf,len)) != len) {
     if (verbose > 1) 
-      fprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
+      rprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
 	      getpid(),len,ret==-1?strerror(errno):"EOF");
     exit_cleanup(1);
   }
   total_read += len;
 }
 
@@ -235,13 +235,13 @@
 static char last_byte;
 static int last_sparse;
 
 int sparse_end(int f)
 {
 	if (last_sparse) {
-		lseek(f,-1,SEEK_CUR);
+		do_lseek(f,-1,SEEK_CUR);
 		return (write(f,&last_byte,1) == 1 ? 0 : -1);
 	}
 	last_sparse = 0;
 	return 0;
 }
 
@@ -257,24 +257,24 @@
 	last_byte = buf[len-1];
 
 	if (l1 == len || l2 > 0)
 		last_sparse=1;
 
 	if (l1 > 0)
-		lseek(f,l1,SEEK_CUR);  
+		do_lseek(f,l1,SEEK_CUR);  
 
 	if (l1 == len) 
 		return len;
 
 	if ((ret=write(f,buf+l1,len-(l1+l2))) != len-(l1+l2)) {
 		if (ret == -1 || ret == 0) return ret;
 		return (l1+ret);
 	}
 
 	if (l2 > 0)
-		lseek(f,l2,SEEK_CUR);
+		do_lseek(f,l2,SEEK_CUR);
 	
 	return len;
 }
 
 
 
@@ -321,13 +321,13 @@
     if (ret == -1 && got_select) {
 	    /* hmmm, we got a write select on the fd and then failed to write.
 	       Why doesn't that mean that the fd is dead? It doesn't on some
 	       systems it seems (eg. IRIX) */
 	    u_sleep(1000);
 #if 0
-	    fprintf(FERROR,"write exception\n");
+	    rprintf(FERROR,"write exception\n");
 	    exit_cleanup(1);
 #endif
     }
 
     got_select = 0;
 
@@ -348,13 +348,13 @@
       tv.tv_sec = BLOCKING_TIMEOUT;
       tv.tv_usec = 0;
       count = select(fd_count,buffer_f_in == -1? NULL: &r_fds,
 		     &w_fds,NULL,&tv);
       if (count == -1 && errno != EINTR) {
 	      if (verbose > 1) 
-		      fprintf(FERROR,"select error: %s\n", strerror(errno));
+		      rprintf(FERROR,"select error: %s\n", strerror(errno));
 	      exit_cleanup(1);
       }
 
       if (count == 0) {
 	      check_timeout();
 	      continue;
@@ -373,19 +373,19 @@
 
   return total;
 }
 
 
 
-void write_int(int f,int x)
+void write_int(int f,int32 x)
 {
   int ret;
   char b[4];
   SIVAL(b,0,x);
   if ((ret=writefd(f,b,4)) != 4) {
-    fprintf(FERROR,"write_int failed : %s\n",
+    rprintf(FERROR,"write_int failed : %s\n",
 	    ret==-1?strerror(errno):"EOF");
     exit_cleanup(1);
   }
   total_written += 4;
 }
 
@@ -402,35 +402,82 @@
 
 	write_int(f, -1);
 	SIVAL(b,0,(x&0xFFFFFFFF));
 	SIVAL(b,4,((x>>32)&0xFFFFFFFF));
 
 	if ((ret=writefd(f,b,8)) != 8) {
-		fprintf(FERROR,"write_longint failed : %s\n",
+		rprintf(FERROR,"write_longint failed : %s\n",
 			ret==-1?strerror(errno):"EOF");
 		exit_cleanup(1);
 	}
 	total_written += 8;
 }
 
 void write_buf(int f,char *buf,int len)
 {
   int ret;
   if ((ret=writefd(f,buf,len)) != len) {
-    fprintf(FERROR,"write_buf failed : %s\n",
+    rprintf(FERROR,"write_buf failed : %s\n",
 	    ret==-1?strerror(errno):"EOF");
     exit_cleanup(1);
   }
   total_written += len;
 }
 
+/* write a string to the connection */
+void write_sbuf(int f,char *buf)
+{
+	write_buf(f, buf, strlen(buf));
+}
+
 
 void write_byte(int f,unsigned char c)
 {
-  write_buf(f,(char *)&c,1);
+	write_buf(f,(char *)&c,1);
 }
 
 void write_flush(int f)
 {
 }
 
 
+int read_line(int f, char *buf, int maxlen)
+{
+	while (maxlen) {
+		read_buf(f, buf, 1);
+		if (buf[0] == '\n') {
+			buf[0] = 0;
+			break;
+		}
+		if (buf[0] != '\r') {
+			buf++;
+			maxlen--;
+		}
+	}
+	if (maxlen == 0) {
+		*buf = 0;
+		return 0;
+	}
+	return 1;
+}
+
+
+void io_printf(int fd, const char *format, ...)
+{
+	va_list ap;  
+	char buf[1024];
+	int len;
+	
+	va_start(ap, format);
+
+#if HAVE_VSNPRINTF
+	len = vsnprintf(buf, sizeof(buf)-1, format, ap);
+#else
+	vsprintf(buf, format, ap);
+	len = strlen(buf);
+#endif
+	va_end(ap);
+
+	if (len < 0) exit_cleanup(1);
+
+	write_sbuf(fd, buf);
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/lib/compat.c	1998-02-24 19:54:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/lib/compat.c	1998-05-14 15:07:52.000000000 +0800
@@ -47,6 +47,14 @@
 pid_t waitpid(pid_t pid, int *statptr, int options)
 {
 	return wait4(pid, statptr, options, NULL);
 }
 #endif
 
+
+#ifndef HAVE_MEMMOVE
+void *memmove(void *dest, const void *src, size_t n)
+{
+	bcopy(src, dest, n);
+	return dest;
+}
+#endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: loadparm.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: log.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/main.c	1998-04-13 14:42:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/main.c	1998-05-14 15:07:51.000000000 +0800
@@ -16,198 +16,67 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
-int verbose = 0;
-int always_checksum = 0;
-time_t starttime;
+time_t starttime = 0;
 int64 total_size = 0;
-int block_size=BLOCK_SIZE;
-
-char *backup_suffix = BACKUP_SUFFIX;
-char *tmpdir = NULL;
-
-static char *rsync_path = RSYNC_NAME;
-
-int make_backups = 0;
-int whole_file = 0;
-int copy_links = 0;
-int preserve_links = 0;
-int preserve_hard_links = 0;
-int preserve_perms = 0;
-int preserve_devices = 0;
-int preserve_uid = 0;
-int preserve_gid = 0;
-int preserve_times = 0;
-int update_only = 0;
-int cvs_exclude = 0;
-int dry_run=0;
-int local_server=0;
-int ignore_times=0;
-int delete_mode=0;
-int one_file_system=0;
-int remote_version=0;
-int sparse_files=0;
-int do_compression=0;
-int am_root=0;
-int orig_umask=0;
-int relative_paths=0;
-int numeric_ids = 0;
-int force_delete = 0;
-int io_timeout = 0;
-int io_error = 0;
 
 extern int csum_length;
 
-int am_server = 0;
-int am_sender;
-int recurse = 0;
-
-static void usage(FILE *f);
+extern int verbose;
 
 static void report(int f)
 {
-  int64 in,out,tsize;
-  time_t t = time(NULL);
-  
-  if (!verbose) return;
+	int64 in,out,tsize;
+	time_t t = time(NULL);
+	extern int am_server;
+	extern int am_sender;
+	extern int am_daemon;
+
+	if (!verbose) return;
+
+	if (am_daemon) {
+		rprintf(FINFO, "wrote %.0f bytes  read %.0f bytes  total size %.0f\n",
+			(double)write_total(),(double)read_total(),
+			(double)total_size);
+	}
 
-  if (am_server && am_sender) {
-    write_longint(f,read_total());
-    write_longint(f,write_total());
-    write_longint(f,total_size);
-    write_flush(f);
-    return;
-  }
+	if (am_server && am_sender) {
+		write_longint(f,read_total());
+		write_longint(f,write_total());
+		write_longint(f,total_size);
+		write_flush(f);
+		return;
+	}
     
-  if (am_sender) {
-    in = read_total();
-    out = write_total();
-    tsize = total_size;
-  } else {
-    in = read_longint(f);
-    out = read_longint(f);
-    tsize = read_longint(f);
-  }
-
-#if HAVE_LONGLONG
-  printf("wrote %lld bytes  read %lld bytes  %.2f bytes/sec\n",
-	 (long long)out,(long long)in,(in+out)/(0.5 + (t-starttime)));
-  printf("total size is %lld  speedup is %.2f\n",
-	 (long long)tsize,(1.0*tsize)/(in+out));
-#else
-  printf("wrote %ld bytes  read %ld bytes  %.2f bytes/sec\n",
-	 (long)out,(long)in,(in+out)/(0.5 + (t-starttime)));
-  printf("total size is %ld  speedup is %.2f\n",
-	 (long)tsize,(1.0*tsize)/(in+out));
-#endif
-}
-
-
-static void server_options(char **args,int *argc)
-{
-  int ac = *argc;
-  static char argstr[50];
-  static char bsize[30];
-  static char iotime[30];
-  int i, x;
-
-  args[ac++] = "--server";
-
-  if (!am_sender)
-    args[ac++] = "--sender";
-
-  x = 1;
-  argstr[0] = '-';
-  for (i=0;i<verbose;i++)
-    argstr[x++] = 'v';
-  if (make_backups)
-    argstr[x++] = 'b';
-  if (update_only)
-    argstr[x++] = 'u';
-  if (dry_run)
-    argstr[x++] = 'n';
-  if (preserve_links)
-    argstr[x++] = 'l';
-  if (copy_links)
-    argstr[x++] = 'L';
-  if (whole_file)
-    argstr[x++] = 'W';
-  if (preserve_hard_links)
-    argstr[x++] = 'H';
-  if (preserve_uid)
-    argstr[x++] = 'o';
-  if (preserve_gid)
-    argstr[x++] = 'g';
-  if (preserve_devices)
-    argstr[x++] = 'D';
-  if (preserve_times)
-    argstr[x++] = 't';
-  if (preserve_perms)
-    argstr[x++] = 'p';
-  if (recurse)
-    argstr[x++] = 'r';
-  if (always_checksum)
-    argstr[x++] = 'c';
-  if (cvs_exclude)
-    argstr[x++] = 'C';
-  if (ignore_times)
-    argstr[x++] = 'I';
-  if (relative_paths)
-    argstr[x++] = 'R';
-  if (one_file_system)
-    argstr[x++] = 'x';
-  if (sparse_files)
-    argstr[x++] = 'S';
-  if (do_compression)
-    argstr[x++] = 'z';
-  argstr[x] = 0;
-
-  if (x != 1) args[ac++] = argstr;
-
-  if (block_size != BLOCK_SIZE) {
-    sprintf(bsize,"-B%d",block_size);
-    args[ac++] = bsize;
-  }    
-
-  if (io_timeout) {
-    sprintf(iotime,"--timeout=%d",io_timeout);
-    args[ac++] = iotime;
-  }    
-
-  if (strcmp(backup_suffix, BACKUP_SUFFIX)) {
-	  args[ac++] = "--suffix";
-	  args[ac++] = backup_suffix;
-  }
-
-  if (delete_mode)
-    args[ac++] = "--delete";
-
-  if (force_delete)
-    args[ac++] = "--force";
-
-  if (numeric_ids)
-    args[ac++] = "--numeric-ids";
-
-  if (tmpdir) {
-	  args[ac++] = "--temp-dir";
-	  args[ac++] = tmpdir;
-  }
-
-  *argc = ac;
+	if (am_sender) {
+		in = read_total();
+		out = write_total();
+		tsize = total_size;
+	} else {
+		out = read_longint(f);
+		in = read_longint(f);
+		tsize = read_longint(f);
+	}
+	
+	printf("wrote %.0f bytes  read %.0f bytes  %.2f bytes/sec\n",
+	       (double)out,(double)in,(in+out)/(0.5 + (t-starttime)));
+	printf("total size is %.0f  speedup is %.2f\n",
+	       (double)tsize,(1.0*tsize)/(in+out));
 }
 
 
-
 static int do_cmd(char *cmd,char *machine,char *user,char *path,int *f_in,int *f_out)
 {
 	char *args[100];
 	int i,argc=0, ret;
 	char *tok,*dir=NULL;
+	extern int local_server;
+	extern char *rsync_path;
 
 	if (!local_server) {
 		if (!cmd)
 			cmd = getenv(RSYNC_RSH_ENV);
 		if (!cmd)
 			cmd = RSYNC_RSH;
@@ -244,16 +113,16 @@
 	if (path && *path) 
 		args[argc++] = path;
 
 	args[argc] = NULL;
 
 	if (verbose > 3) {
-		fprintf(FINFO,"cmd=");
+		rprintf(FINFO,"cmd=");
 		for (i=0;i<argc;i++)
-			fprintf(FINFO,"%s ",args[i]);
-		fprintf(FINFO,"\n");
+			rprintf(FINFO,"%s ",args[i]);
+		rprintf(FINFO,"\n");
 	}
 
 	if (local_server) {
 		ret = local_child(argc, args, f_in, f_out);
 	} else {
 		ret = piped_child(args,f_in,f_out);
@@ -270,600 +139,382 @@
 
 
 
 
 static char *get_local_name(struct file_list *flist,char *name)
 {
-  struct stat st;
+	STRUCT_STAT st;
+	extern int orig_umask;
 
-  if (stat(name,&st) == 0) {
+  if (do_stat(name,&st) == 0) {
     if (S_ISDIR(st.st_mode)) {
       if (chdir(name) != 0) {
-	fprintf(FERROR,"chdir %s : %s (1)\n",name,strerror(errno));
+	rprintf(FERROR,"chdir %s : %s (1)\n",name,strerror(errno));
 	exit_cleanup(1);
       }
       return NULL;
     }
     if (flist->count > 1) {
-      fprintf(FERROR,"ERROR: destination must be a directory when copying more than 1 file\n");
+      rprintf(FERROR,"ERROR: destination must be a directory when copying more than 1 file\n");
       exit_cleanup(1);
     }
     return name;
   }
 
   if (flist->count == 1)
     return name;
 
   if (!name) 
     return NULL;
 
   if (do_mkdir(name,0777 & ~orig_umask) != 0) {
-    fprintf(FERROR,"mkdir %s : %s (1)\n",name,strerror(errno));
+    rprintf(FERROR,"mkdir %s : %s (1)\n",name,strerror(errno));
     exit_cleanup(1);
   } else {
-    fprintf(FINFO,"created directory %s\n",name);
+    rprintf(FINFO,"created directory %s\n",name);
   }
 
   if (chdir(name) != 0) {
-    fprintf(FERROR,"chdir %s : %s (2)\n",name,strerror(errno));
+    rprintf(FERROR,"chdir %s : %s (2)\n",name,strerror(errno));
     exit_cleanup(1);
   }
 
   return NULL;
 }
 
 
 
 
-void do_server_sender(int argc,char *argv[])
+static void do_server_sender(int f_in, int f_out, int argc,char *argv[])
 {
-  int i;
-  struct file_list *flist;
-  char *dir = argv[0];
+	int i;
+	struct file_list *flist;
+	char *dir = argv[0];
+	extern int relative_paths;
+	extern int am_daemon;
+	extern int recurse;
 
-  if (verbose > 2)
-    fprintf(FINFO,"server_sender starting pid=%d\n",(int)getpid());
+	if (verbose > 2)
+		rprintf(FINFO,"server_sender starting pid=%d\n",(int)getpid());
   
-  if (!relative_paths && chdir(dir) != 0) {
-	  fprintf(FERROR,"chdir %s: %s (3)\n",dir,strerror(errno));
-	  exit_cleanup(1);
-  }
-  argc--;
-  argv++;
+	if (!relative_paths && chdir(dir) != 0) {
+		rprintf(FERROR,"chdir %s: %s (3)\n",dir,strerror(errno));
+		exit_cleanup(1);
+	}
+	argc--;
+	argv++;
   
-  if (strcmp(dir,".")) {
-	  int l = strlen(dir);
-	  if (strcmp(dir,"/") == 0) 
-		  l = 0;
-	  for (i=0;i<argc;i++)
-		  argv[i] += l+1;
-  }
-
-  if (argc == 0 && recurse) {
-	  argc=1;
-	  argv--;
-	  argv[0] = ".";
-  }
-    
+	if (strcmp(dir,".")) {
+		int l = strlen(dir);
+		if (strcmp(dir,"/") == 0) 
+			l = 0;
+		for (i=0;i<argc;i++)
+			argv[i] += l+1;
+	}
 
-  flist = send_file_list(STDOUT_FILENO,argc,argv);
-  send_files(flist,STDOUT_FILENO,STDIN_FILENO);
-  report(STDOUT_FILENO);
-  exit_cleanup(0);
+	if (argc == 0 && recurse) {
+		argc=1;
+		argv--;
+		argv[0] = ".";
+	}
+	
+	flist = send_file_list(f_out,argc,argv);
+	send_files(flist,f_out,f_in);
+	report(f_out);
+	exit_cleanup(0);
 }
 
 
 static int do_recv(int f_in,int f_out,struct file_list *flist,char *local_name)
 {
   int pid;
   int status=0;
   int recv_pipe[2];
+  extern int preserve_hard_links;
 
   if (preserve_hard_links)
     init_hard_links(flist);
 
   if (pipe(recv_pipe) < 0) {
-    fprintf(FERROR,"pipe failed in do_recv\n");
+    rprintf(FERROR,"pipe failed in do_recv\n");
     exit(1);
   }
   
 
   if ((pid=do_fork()) == 0) {
     recv_files(f_in,flist,local_name,recv_pipe[1]);
     if (verbose > 2)
-      fprintf(FINFO,"receiver read %ld\n",(long)read_total());
+      rprintf(FINFO,"receiver read %ld\n",(long)read_total());
     exit_cleanup(0);
   }
 
   generate_files(f_out,flist,local_name,recv_pipe[0]);
 
   waitpid(pid, &status, 0);
 
   return status;
 }
 
 
-void do_server_recv(int argc,char *argv[])
+static void do_server_recv(int f_in, int f_out, int argc,char *argv[])
 {
-  int status;
-  struct file_list *flist;
-  char *local_name=NULL;
-  char *dir = NULL;
-  
-  if (verbose > 2)
-    fprintf(FINFO,"server_recv(%d) starting pid=%d\n",argc,(int)getpid());
-
-  if (argc > 0) {
-	  dir = argv[0];
-	  argc--;
-	  argv++;
-	  if (chdir(dir) != 0) {
-		  fprintf(FERROR,"chdir %s : %s (4)\n",
-			  dir,strerror(errno));
-		  exit_cleanup(1);
-	  }    
-  }
+	int status;
+	struct file_list *flist;
+	char *local_name=NULL;
+	char *dir = NULL;
+	extern int delete_mode;
+	extern int am_daemon;
 
-  if (delete_mode)
-    recv_exclude_list(STDIN_FILENO);
+	if (verbose > 2)
+		rprintf(FINFO,"server_recv(%d) starting pid=%d\n",argc,(int)getpid());
+	
+	if (argc > 0) {
+		dir = argv[0];
+		argc--;
+		argv++;
+		if (!am_daemon && chdir(dir) != 0) {
+			rprintf(FERROR,"chdir %s : %s (4)\n",
+				dir,strerror(errno));
+			exit_cleanup(1);
+		}    
+	}
 
-  flist = recv_file_list(STDIN_FILENO);
-  if (!flist || flist->count == 0) {
-    fprintf(FERROR,"nothing to do\n");
-    exit_cleanup(1);
-  }
+	if (delete_mode)
+		recv_exclude_list(f_in);
 
-  if (argc > 0) {    
-	  if (strcmp(dir,".")) {
-		  argv[0] += strlen(dir);
-		  if (argv[0][0] == '/') argv[0]++;
-	  }
-	  local_name = get_local_name(flist,argv[0]);
-  }
+	flist = recv_file_list(f_in);
+	if (!flist || flist->count == 0) {
+		rprintf(FERROR,"nothing to do\n");
+		exit_cleanup(1);
+	}
+	
+	if (argc > 0) {    
+		if (strcmp(dir,".")) {
+			argv[0] += strlen(dir);
+			if (argv[0][0] == '/') argv[0]++;
+		}
+		local_name = get_local_name(flist,argv[0]);
+	}
 
-  status = do_recv(STDIN_FILENO,STDOUT_FILENO,flist,local_name);
-  exit_cleanup(status);
+	status = do_recv(f_in,f_out,flist,local_name);
+	exit_cleanup(status);
 }
 
 
-void start_server(int argc, char *argv[])
+void start_server(int f_in, int f_out, int argc, char *argv[])
 {
-      setup_protocol(STDOUT_FILENO,STDIN_FILENO);
+	extern int cvs_exclude;
+	extern int am_sender;
+
+	setup_protocol(f_out, f_in);
 	
-      if (am_sender) {
-	      recv_exclude_list(STDIN_FILENO);
-	      if (cvs_exclude)
-		      add_cvs_excludes();
-	      do_server_sender(argc,argv);
-      } else {
-	      do_server_recv(argc,argv);
-      }
-      exit_cleanup(0);
+	if (am_sender) {
+		recv_exclude_list(f_in);
+		if (cvs_exclude)
+			add_cvs_excludes();
+		do_server_sender(f_in, f_out, argc, argv);
+	} else {
+		do_server_recv(f_in, f_out, argc, argv);
+	}
+	exit_cleanup(0);
 }
 
-
-static void usage(FILE *f)
+int client_run(int f_in, int f_out, int pid, int argc, char *argv[])
 {
-  fprintf(f,"rsync version %s Copyright Andrew Tridgell and Paul Mackerras\n\n",
-	  VERSION);
-  fprintf(f,"Usage:\t%s [options] src user@host:dest\nOR",RSYNC_NAME);
-  fprintf(f,"\t%s [options] user@host:src dest\n\n",RSYNC_NAME);
-  fprintf(f,"Options:\n");
-  fprintf(f,"-v, --verbose            increase verbosity\n");
-  fprintf(f,"-c, --checksum           always checksum\n");
-  fprintf(f,"-a, --archive            archive mode (same as -rlptDog)\n");
-  fprintf(f,"-r, --recursive          recurse into directories\n");
-  fprintf(f,"-R, --relative           use relative path names\n");
-  fprintf(f,"-b, --backup             make backups (default ~ extension)\n");
-  fprintf(f,"-u, --update             update only (don't overwrite newer files)\n");
-  fprintf(f,"-l, --links              preserve soft links\n");
-  fprintf(f,"-L, --copy-links         treat soft links like regular files\n");
-  fprintf(f,"-H, --hard-links         preserve hard links\n");
-  fprintf(f,"-p, --perms              preserve permissions\n");
-  fprintf(f,"-o, --owner              preserve owner (root only)\n");
-  fprintf(f,"-g, --group              preserve group\n");
-  fprintf(f,"-D, --devices            preserve devices (root only)\n");
-  fprintf(f,"-t, --times              preserve times\n");  
-  fprintf(f,"-S, --sparse             handle sparse files efficiently\n");
-  fprintf(f,"-n, --dry-run            show what would have been transferred\n");
-  fprintf(f,"-W, --whole-file         copy whole files, no incremental checks\n");
-  fprintf(f,"-x, --one-file-system    don't cross filesystem boundaries\n");
-  fprintf(f,"-B, --block-size SIZE    checksum blocking size\n");  
-  fprintf(f,"-e, --rsh COMMAND        specify rsh replacement\n");
-  fprintf(f,"    --rsync-path PATH    specify path to rsync on the remote machine\n");
-  fprintf(f,"-C, --cvs-exclude        auto ignore files in the same way CVS does\n");
-  fprintf(f,"    --delete             delete files that don't exist on the sending side\n");
-  fprintf(f,"    --force              force deletion of directories even if not empty\n");
-  fprintf(f,"    --numeric-ids        don't map uid/gid values by user/group name\n");
-  fprintf(f,"    --timeout TIME       set IO timeout in seconds\n");
-  fprintf(f,"-I, --ignore-times       don't exclude files that match length and time\n");
-  fprintf(f,"-T  --temp-dir DIR       create temporary files in directory DIR\n");
-  fprintf(f,"-z, --compress           compress file data\n");
-  fprintf(f,"    --exclude FILE       exclude file FILE\n");
-  fprintf(f,"    --exclude-from FILE  exclude files listed in FILE\n");
-  fprintf(f,"    --suffix SUFFIX      override backup suffix\n");  
-  fprintf(f,"    --version            print version number\n");  
-
-  fprintf(f,"\n");
-  fprintf(f,"the backup suffix defaults to %s\n",BACKUP_SUFFIX);
-  fprintf(f,"the block size defaults to %d\n",BLOCK_SIZE);  
-}
-
-enum {OPT_VERSION,OPT_SUFFIX,OPT_SENDER,OPT_SERVER,OPT_EXCLUDE,
-      OPT_EXCLUDE_FROM,OPT_DELETE,OPT_NUMERIC_IDS,OPT_RSYNC_PATH,
-      OPT_FORCE,OPT_TIMEOUT};
-
-static char *short_options = "oblLWHpguDCtcahvrRIxnSe:B:T:z";
-
-static struct option long_options[] = {
-  {"version",     0,     0,    OPT_VERSION},
-  {"server",      0,     0,    OPT_SERVER},
-  {"sender",      0,     0,    OPT_SENDER},
-  {"delete",      0,     0,    OPT_DELETE},
-  {"force",       0,     0,    OPT_FORCE},
-  {"numeric-ids", 0,     0,    OPT_NUMERIC_IDS},
-  {"exclude",     1,     0,    OPT_EXCLUDE},
-  {"exclude-from",1,     0,    OPT_EXCLUDE_FROM},
-  {"rsync-path",  1,     0,    OPT_RSYNC_PATH},
-  {"one-file-system",0,  0,    'x'},
-  {"ignore-times",0,     0,    'I'},
-  {"help",        0,     0,    'h'},
-  {"dry-run",     0,     0,    'n'},
-  {"sparse",      0,     0,    'S'},
-  {"cvs-exclude", 0,     0,    'C'},
-  {"archive",     0,     0,    'a'},
-  {"checksum",    0,     0,    'c'},
-  {"backup",      0,     0,    'b'},
-  {"update",      0,     0,    'u'},
-  {"verbose",     0,     0,    'v'},
-  {"recursive",   0,     0,    'r'},
-  {"relative",    0,     0,    'R'},
-  {"devices",     0,     0,    'D'},
-  {"perms",       0,     0,    'p'},
-  {"links",       0,     0,    'l'},
-  {"copy-links",  0,     0,    'L'},
-  {"whole-file",  0,     0,    'W'},
-  {"hard-links",  0,     0,    'H'},
-  {"owner",       0,     0,    'o'},
-  {"group",       0,     0,    'g'},
-  {"times",       0,     0,    't'},
-  {"rsh",         1,     0,    'e'},
-  {"suffix",      1,     0,    OPT_SUFFIX},
-  {"block-size",  1,     0,    'B'},
-  {"timeout",     1,     0,    OPT_TIMEOUT},
-  {"temp-dir",    1,     0,    'T'},
-  {"compress",	  0,	 0,    'z'},
-  {0,0,0,0}};
+	struct file_list *flist;
+	int status = 0, status2 = 0;
+	char *local_name = NULL;
+	extern int am_sender;
 
-RETSIGTYPE sigusr1_handler(int val) {
-	exit_cleanup(1);
+	setup_protocol(f_out,f_in);
+	
+	if (am_sender) {
+		extern int cvs_exclude;
+		extern int delete_mode;
+		if (cvs_exclude)
+			add_cvs_excludes();
+		if (delete_mode) 
+			send_exclude_list(f_out);
+		flist = send_file_list(f_out,argc,argv);
+		if (verbose > 3) 
+			rprintf(FINFO,"file list sent\n");
+		send_files(flist,f_out,f_in);
+		if (pid != -1) {
+			if (verbose > 3)
+				rprintf(FINFO,"waiting on %d\n",pid);
+			waitpid(pid, &status, 0);
+		}
+		report(-1);
+		exit_cleanup(status);
+	}
+	
+	send_exclude_list(f_out);
+	
+	flist = recv_file_list(f_in);
+	if (!flist || flist->count == 0) {
+		rprintf(FINFO,"nothing to do\n");
+		exit_cleanup(0);
+	}
+	
+	local_name = get_local_name(flist,argv[0]);
+	
+	status2 = do_recv(f_in,f_out,flist,local_name);
+	
+	report(f_in);
+	
+	if (pid != -1) {
+		waitpid(pid, &status, 0);
+	}
+	
+	return status | status2;
 }
 
-int main(int argc,char *argv[])
+
+int start_client(int argc, char *argv[])
 {
-    int pid, status = 0, status2 = 0;
-    int opt;
-    int option_index;
-    char *shell_cmd = NULL;
-    char *shell_machine = NULL;
-    char *shell_path = NULL;
-    char *shell_user = NULL;
-    char *p;
-    int f_in,f_out;
-    struct file_list *flist;
-    char *local_name = NULL;
-
-    signal(SIGUSR1, sigusr1_handler);
-
-    starttime = time(NULL);
-    am_root = (getuid() == 0);
-
-    /* we set a 0 umask so that correct file permissions can be
-       carried across */
-    orig_umask = (int)umask(0);
-
-    while ((opt = getopt_long(argc, argv, 
-			      short_options, long_options, &option_index)) 
-	   != -1) {
-      switch (opt) 
-	{
-	case OPT_VERSION:
-	  printf("rsync version %s  protocol version %d\n",
-		 VERSION,PROTOCOL_VERSION);
-	  exit_cleanup(0);
-
-	case OPT_SUFFIX:
-	  backup_suffix = optarg;
-	  break;
-
-	case OPT_RSYNC_PATH:
-	  rsync_path = optarg;
-	  break;
-
-	case 'I':
-	  ignore_times = 1;
-	  break;
-
-	case 'x':
-	  one_file_system=1;
-	  break;
-
-	case OPT_DELETE:
-	  delete_mode = 1;
-	  break;
-
-	case OPT_FORCE:
-	  force_delete = 1;
-	  break;
-
-	case OPT_NUMERIC_IDS:
-	  numeric_ids = 1;
-	  break;
-
-	case OPT_EXCLUDE:
-	  add_exclude(optarg);
-	  break;
-
-	case OPT_EXCLUDE_FROM:
-	  add_exclude_file(optarg,1);
-	  break;
-
-	case 'h':
-	  usage(FINFO);
-	  exit_cleanup(0);
-
-	case 'b':
-	  make_backups=1;
-	  break;
-
-	case 'n':
-	  dry_run=1;
-	  break;
-
-	case 'S':
-	  sparse_files=1;
-	  break;
-
-	case 'C':
-	  cvs_exclude=1;
-	  break;
-
-	case 'u':
-	  update_only=1;
-	  break;
-
-	case 'l':
-	  preserve_links=1;
-	  break;
-
-	case 'L':
-	  copy_links=1;
-	  break;
-
-	case 'W':
-	  whole_file=1;
-	  break;
-
-	case 'H':
-#if SUPPORT_HARD_LINKS
-	  preserve_hard_links=1;
-#else 
-	  fprintf(FERROR,"ERROR: hard links not supported on this platform\n");
-	  exit_cleanup(1);
-#endif
-	  break;
+	char *p;
+	char *shell_machine = NULL;
+	char *shell_path = NULL;
+	char *shell_user = NULL;
+	int pid;
+	int f_in,f_out;
+	extern int local_server;
+	extern int am_sender;
+	extern char *shell_cmd;
+
+	p = strchr(argv[0],':');
+
+	if (p) {
+		if (p[1] == ':') {
+			*p = 0;
+			return start_socket_client(argv[0], p+2, argc-1, argv+1);
+		}
 
-	case 'p':
-	  preserve_perms=1;
-	  break;
-
-	case 'o':
-	  preserve_uid=1;
-	  break;
-
-	case 'g':
-	  preserve_gid=1;
-	  break;
-
-	case 'D':
-	  preserve_devices=1;
-	  break;
-
-	case 't':
-	  preserve_times=1;
-	  break;
-
-	case 'c':
-	  always_checksum=1;
-	  break;
-
-	case 'v':
-	  verbose++;
-	  break;
-
-	case 'a':
-	  recurse=1;
-#if SUPPORT_LINKS
-	  preserve_links=1;
-#endif
-	  preserve_perms=1;
-	  preserve_times=1;
-	  preserve_gid=1;
-	  if (am_root) {
-	    preserve_devices=1;
-	    preserve_uid=1;
-	  }
-	  break;
-
-	case OPT_SERVER:
-	  am_server = 1;
-	  break;
-
-	case OPT_SENDER:
-	  if (!am_server) {
-	    usage(FERROR);
-	    exit_cleanup(1);
-	  }
-	  am_sender = 1;
-	  break;
-
-	case 'r':
-	  recurse = 1;
-	  break;
-
-	case 'R':
-	  relative_paths = 1;
-	  break;
-
-	case 'e':
-	  shell_cmd = optarg;
-	  break;
-
-	case 'B':
-	  block_size = atoi(optarg);
-	  break;
-
-	case OPT_TIMEOUT:
-	  io_timeout = atoi(optarg);
-	  break;
-
-	case 'T':
-		tmpdir = optarg;
-		break;
-
-        case 'z':
-	  do_compression = 1;
-	  break;
-
-	default:
-	  /* fprintf(FERROR,"bad option -%c\n",opt); */
-	  exit_cleanup(1);
-	}
-    }
+		if (argc < 2) {
+			usage(FERROR);
+			exit_cleanup(1);
+		}
 
-    while (optind--) {
-      argc--;
-      argv++;
-    }
+		am_sender = 0;
+		*p = 0;
+		shell_machine = argv[0];
+		shell_path = p+1;
+		argc--;
+		argv++;
+	} else {
+		am_sender = 1;
 
-    signal(SIGCHLD,SIG_IGN);
-    signal(SIGINT,SIGNAL_CAST sig_int);
-    signal(SIGPIPE,SIGNAL_CAST sig_int);
-    signal(SIGHUP,SIGNAL_CAST sig_int);
+		p = strchr(argv[argc-1],':');
+		if (!p) {
+			local_server = 1;
+		} else if (p[1] == ':') {
+			*p = 0;
+			return start_socket_client(argv[argc-1], p+2, argc-1, argv);
+		}
 
-    if (dry_run)
-      verbose = MAX(verbose,1);
+		if (argc < 2) {
+			usage(FERROR);
+			exit_cleanup(1);
+		}
+		
+		if (local_server) {
+			shell_machine = NULL;
+			shell_path = argv[argc-1];
+		} else {
+			*p = 0;
+			shell_machine = argv[argc-1];
+			shell_path = p+1;
+		}
+		argc--;
+	}
+	
+	if (shell_machine) {
+		p = strchr(shell_machine,'@');
+		if (p) {
+			*p = 0;
+			shell_user = shell_machine;
+			shell_machine = p+1;
+		}
+	}
 
-#ifndef SUPPORT_LINKS
-    if (!am_server && preserve_links) {
-	    fprintf(FERROR,"ERROR: symbolic links not supported\n");
-	    exit_cleanup(1);
-    }
+	if (verbose > 3) {
+		rprintf(FINFO,"cmd=%s machine=%s user=%s path=%s\n",
+			shell_cmd?shell_cmd:"",
+			shell_machine?shell_machine:"",
+			shell_user?shell_user:"",
+			shell_path?shell_path:"");
+	}
+	
+	if (!am_sender && argc != 1) {
+		usage(FERROR);
+		exit_cleanup(1);
+	}
+	
+	pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,&f_in,&f_out);
+	
+#if HAVE_SETLINEBUF
+	setlinebuf(stdout);
+	setlinebuf(stderr);
 #endif
 
-    if (am_server) {
-	    start_server(argc, argv);
-    }
-
-    if (argc < 2) {
-      usage(FERROR);
-      exit_cleanup(1);
-    }
-
-    p = strchr(argv[0],':');
+	return client_run(f_in, f_out, pid, argc, argv);
+}
 
-    if (p) {
-      am_sender = 0;
-      *p = 0;
-      shell_machine = argv[0];
-      shell_path = p+1;
-      argc--;
-      argv++;
-    } else {
-      am_sender = 1;
-
-      p = strchr(argv[argc-1],':');
-      if (!p) {
-	local_server = 1;
-      }
 
-      if (local_server) {
-	shell_machine = NULL;
-	shell_path = argv[argc-1];
-      } else {
-	*p = 0;
-	shell_machine = argv[argc-1];
-	shell_path = p+1;
-      }
-      argc--;
-    }
+RETSIGTYPE sigusr1_handler(int val) {
+	exit_cleanup(1);
+}
 
-    if (shell_machine) {
-      p = strchr(shell_machine,'@');
-      if (p) {
-	*p = 0;
-	shell_user = shell_machine;
-	shell_machine = p+1;
-      }
-    }
+int main(int argc,char *argv[])
+{       
+	extern int am_root;
+	extern int orig_umask;
+	extern int dry_run;
+	extern int am_daemon;
+	extern int am_server;
+
+	signal(SIGUSR1, sigusr1_handler);
+
+	starttime = time(NULL);
+	am_root = (getuid() == 0);
+
+	if (argc < 2) {
+		usage(FERROR);
+		exit(1);
+	}
 
-    if (verbose > 3) {
-      fprintf(FINFO,"cmd=%s machine=%s user=%s path=%s\n",
-	      shell_cmd?shell_cmd:"",
-	      shell_machine?shell_machine:"",
-	      shell_user?shell_user:"",
-	      shell_path?shell_path:"");
-    }
-    
-    if (!am_sender && argc != 1) {
-      usage(FERROR);
-      exit_cleanup(1);
-    }
+	/* we set a 0 umask so that correct file permissions can be
+	   carried across */
+	orig_umask = (int)umask(0);
+
+	parse_arguments(argc, argv);
+
+	argc -= optind;
+	argv += optind;
+	optind = 0;
+
+	signal(SIGCHLD,SIG_IGN);
+	signal(SIGINT,SIGNAL_CAST sig_int);
+	signal(SIGPIPE,SIGNAL_CAST sig_int);
+	signal(SIGHUP,SIGNAL_CAST sig_int);
 
-    pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,&f_in,&f_out);
+	if (am_daemon) {
+		return daemon_main();
+	}
 
-    setup_protocol(f_out,f_in);
+	if (dry_run)
+		verbose = MAX(verbose,1);
 
-#if HAVE_SETLINEBUF
-    setlinebuf(FINFO);
-    setlinebuf(FERROR);
+#ifndef SUPPORT_LINKS
+	if (!am_server && preserve_links) {
+		rprintf(FERROR,"ERROR: symbolic links not supported\n");
+		exit_cleanup(1);
+	}
 #endif
 
-    if (verbose > 3) 
-      fprintf(FINFO,"parent=%d child=%d sender=%d recurse=%d\n",
-	      (int)getpid(),pid,am_sender,recurse);
-
-    if (am_sender) {
-      if (cvs_exclude)
-	add_cvs_excludes();
-      if (delete_mode) 
-	send_exclude_list(f_out);
-      flist = send_file_list(f_out,argc,argv);
-      if (verbose > 3) 
-	fprintf(FINFO,"file list sent\n");
-      send_files(flist,f_out,f_in);
-      if (verbose > 3)
-	fprintf(FINFO,"waiting on %d\n",pid);
-      waitpid(pid, &status, 0);
-      report(-1);
-      exit_cleanup(status);
-    }
-
-    send_exclude_list(f_out);
-
-    flist = recv_file_list(f_in);
-    if (!flist || flist->count == 0) {
-      fprintf(FINFO,"nothing to do\n");
-      exit_cleanup(0);
-    }
-
-    local_name = get_local_name(flist,argv[0]);
-
-    status2 = do_recv(f_in,f_out,flist,local_name);
-
-    report(f_in);
-
-    waitpid(pid, &status, 0);
+	if (am_server) {
+		start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
+	}
 
-    return status | status2;
+	return start_client(argc, argv);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/Makefile.in	1998-03-26 12:51:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/Makefile.in	1998-05-14 15:07:50.000000000 +0800
@@ -18,30 +18,42 @@
 
 
 .SUFFIXES:
 .SUFFIXES: .c .o
 
 LIBOBJ=lib/getopt.o lib/fnmatch.o lib/zlib.o lib/compat.o
-OBJS1=rsync.o exclude.o util.o md4.o main.o checksum.o match.o syscall.o
-OBJS=$(OBJS1) flist.o io.o compat.o hlink.o token.o uidlist.o $(LIBOBJ)
+OBJS1=rsync.o exclude.o util.o md4.o main.o checksum.o match.o syscall.o log.o
+OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o 
+DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
+OBJS=$(OBJS1) $(OBJS2) $(DAEMON_OBJ) $(LIBOBJ)
 
 # note that the -I. is needed to handle config.h when using VPATH
 .c.o:
 	$(CC) -I. -I$(srcdir) $(CFLAGS) -c $< -o $@
 
-all: rsync
+all: rsync rsync.1 rsyncd.conf.5
 
 install: all
 	-mkdir -p ${INSTALL_BIN}
 	${INSTALLCMD} -m 755 rsync ${INSTALL_BIN}
 	-mkdir -p ${INSTALL_MAN}/man1
+	-mkdir -p ${INSTALL_MAN}/man5
 	${INSTALLCMD} -m 644 $(srcdir)/rsync.1 ${INSTALL_MAN}/man1
+	${INSTALLCMD} -m 644 $(srcdir)/rsyncd.conf.5 ${INSTALL_MAN}/man5
 
 rsync: $(OBJS)
 	$(CC) $(CFLAGS) -o rsync $(OBJS) $(LIBS)
 
+rsync.1: rsync.yo
+	yodl2man rsync.yo
+	mv rsync.man rsync.1
+
+rsyncd.conf.5: rsyncd.conf.yo
+	yodl2man rsyncd.conf.yo
+	mv rsyncd.conf.man rsyncd.conf.5
+
 proto:
 	cat *.c | awk -f mkproto.awk > proto.h
 
 clean:
 	rm -f *~ $(OBJS) rsync config.cache config.log config.status
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/match.c	1998-04-17 14:48:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/match.c	1998-05-14 15:07:51.000000000 +0800
@@ -84,23 +84,23 @@
   for (i=s->count-1;i>=0;i--) {    
     tag_table[targets[i].t] = i;
   }
 }
 
 
-static off_t last_match;
+static OFF_T last_match;
 
 
 static void matched(int f,struct sum_struct *s,struct map_struct *buf,
-		    off_t offset,int i)
+		    OFF_T offset,int i)
 {
-	off_t n = offset - last_match;
+	OFF_T n = offset - last_match;
 	int j;
 
 	if (verbose > 2 && i >= 0)
-		fprintf(FINFO,"match at %d last_match=%d j=%d len=%d n=%d\n",
+		rprintf(FINFO,"match at %d last_match=%d j=%d len=%d n=%d\n",
 			(int)offset,(int)last_match,i,(int)s->sums[i].len,(int)n);
 
 	send_token(f,i,buf,last_match,n,i==-1?0:s->sums[i].len);
 	data_transfer += n;
 
 	if (n > 0)
@@ -120,49 +120,49 @@
 	else
 		last_match = offset;
 }
 
 
 static void hash_search(int f,struct sum_struct *s,
-			struct map_struct *buf,off_t len)
+			struct map_struct *buf,OFF_T len)
 {
-	off_t offset;
+	OFF_T offset;
 	int j,k;
 	int end;
 	char sum2[SUM_LENGTH];
 	uint32 s1, s2, sum; 
-	signed char *map;
+	schar *map;
 
 	if (verbose > 2)
-		fprintf(FINFO,"hash search b=%d len=%d\n",s->n,(int)len);
+		rprintf(FINFO,"hash search b=%d len=%d\n",s->n,(int)len);
 
 	k = MIN(len, s->n);
 	
-	map = (signed char *)map_ptr(buf,0,k);
+	map = (schar *)map_ptr(buf,0,k);
 	
 	sum = get_checksum1((char *)map, k);
 	s1 = sum & 0xFFFF;
 	s2 = sum >> 16;
 	if (verbose > 3)
-		fprintf(FINFO, "sum=%.8x k=%d\n", sum, k);
+		rprintf(FINFO, "sum=%.8x k=%d\n", sum, k);
 	
 	offset = 0;
 	
 	end = len + 1 - s->sums[s->count-1].len;
 	
 	if (verbose > 3)
-		fprintf(FINFO,"hash search s->n=%d len=%d count=%d\n",
+		rprintf(FINFO,"hash search s->n=%d len=%d count=%d\n",
 			s->n,(int)len,s->count);
 	
 	do {
 		tag t = gettag2(s1,s2);
 		int done_csum2 = 0;
 			
 		j = tag_table[t];
 		if (verbose > 4)
-			fprintf(FINFO,"offset=%d sum=%08x\n",(int)offset,sum);
+			rprintf(FINFO,"offset=%d sum=%08x\n",(int)offset,sum);
 		
 		if (j == NULL_TAG) {
 			goto null_tag;
 		}
 
 		sum = (s1 & 0xffff) | (s2 << 16);
@@ -170,41 +170,41 @@
 		for (; j<s->count && targets[j].t == t; j++) {
 			int i = targets[j].i;
 			
 			if (sum != s->sums[i].sum1) continue;
 			
 			if (verbose > 3)
-				fprintf(FINFO,"potential match at %d target=%d %d sum=%08x\n",
+				rprintf(FINFO,"potential match at %d target=%d %d sum=%08x\n",
 					(int)offset,j,i,sum);
 			
 			if (!done_csum2) {
 				int l = MIN(s->n,len-offset);
-				map = (signed char *)map_ptr(buf,offset,l);
+				map = (schar *)map_ptr(buf,offset,l);
 				get_checksum2((char *)map,l,sum2);
 				done_csum2 = 1;
 			}
 			
 			if (memcmp(sum2,s->sums[i].sum2,csum_length) != 0) {
 				false_alarms++;
 				continue;
 			}
 			
 			matched(f,s,buf,offset,i);
 			offset += s->sums[i].len - 1;
 			k = MIN((len-offset), s->n);
-			map = (signed char *)map_ptr(buf,offset,k);
+			map = (schar *)map_ptr(buf,offset,k);
 			sum = get_checksum1((char *)map, k);
 			s1 = sum & 0xFFFF;
 			s2 = sum >> 16;
 			matches++;
 			break;
 		}
 		
 	null_tag:
 		/* Trim off the first byte from the checksum */
-		map = (signed char *)map_ptr(buf,offset,k+1);
+		map = (schar *)map_ptr(buf,offset,k+1);
 		s1 -= map[0] + CHAR_OFFSET;
 		s2 -= k * (map[0]+CHAR_OFFSET);
 		
 		/* Add on the next byte (if there is one) to the checksum */
 		if (k < (len-offset)) {
 			s1 += (map[k]+CHAR_OFFSET);
@@ -217,13 +217,13 @@
 	
 	matched(f,s,buf,len,-1);
 	map_ptr(buf,len-1,1);
 }
 
 
-void match_sums(int f,struct sum_struct *s,struct map_struct *buf,off_t len)
+void match_sums(int f,struct sum_struct *s,struct map_struct *buf,OFF_T len)
 {
 	char file_sum[MD4_SUM_LENGTH];
 
 	last_match = 0;
 	false_alarms = 0;
 	tag_hits = 0;
@@ -233,37 +233,37 @@
 	sum_init();
 
 	if (len > 0 && s->count>0) {
 		build_hash_table(s);
 		
 		if (verbose > 2) 
-			fprintf(FINFO,"built hash table\n");
+			rprintf(FINFO,"built hash table\n");
 		
 		hash_search(f,s,buf,len);
 		
 		if (verbose > 2) 
-			fprintf(FINFO,"done hash search\n");
+			rprintf(FINFO,"done hash search\n");
 	} else {
 		matched(f,s,buf,len,-1);
 	}
 
 	sum_end(file_sum);
 
 	if (remote_version >= 14) {
 		if (verbose > 2)
-			fprintf(FINFO,"sending file_sum\n");
+			rprintf(FINFO,"sending file_sum\n");
 		write_buf(f,file_sum,MD4_SUM_LENGTH);
 	}
 
 	if (targets) {
 		free(targets);
 		targets=NULL;
 	}
 	
 	if (verbose > 2)
-		fprintf(FINFO, "false_alarms=%d tag_hits=%d matches=%d\n",
+		rprintf(FINFO, "false_alarms=%d tag_hits=%d matches=%d\n",
 			false_alarms, tag_hits, matches);
 	
 	total_tag_hits += tag_hits;
 	total_false_alarms += false_alarms;
 	total_matches += matches;
 	total_data_transfer += data_transfer;
@@ -271,11 +271,11 @@
 
 void match_report(void)
 {
 	if (verbose <= 1)
 		return;
 
-	fprintf(FINFO,
+	rprintf(FINFO,
 		"total: matches=%d  tag_hits=%d  false_alarms=%d  data=%ld\n",
 		total_matches,total_tag_hits,
 		total_false_alarms,(long)total_data_transfer);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/md4.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/md4.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/md4.c	1996-07-03 16:12:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/md4.c	1998-05-14 15:07:51.000000000 +0800
@@ -210,13 +210,13 @@
    /* return with no error if this is a courtesy close with count
    ** zero and MDp->done is true.
    */
    if (count == 0 && MDp->done) return;
    /* check to see if MD is already done and report error */
    if (MDp->done)
-          { fprintf(FERROR,"\nError: MDupdate MD already done."); return; }
+          { rprintf(FERROR,"\nError: MDupdate MD already done."); return; }
    /* Add count to MDp->count */
    tmp = count;
    p = MDp->count;
    while (tmp)
      { tmp += *p;
        *p++ = tmp;
@@ -225,13 +225,13 @@
    /* Process data */
    if (count == 512)
      { /* Full block of data to handle */
        MDblock(MDp,(unsigned int *)X);
      }
    else if (count > 512) /* Check for count too large */
-     { fprintf(FERROR,"\nError: MDupdate called with illegal count value %d."
+     { rprintf(FERROR,"\nError: MDupdate called with illegal count value %d."
               ,count);
        return;
      }
    else /* partial block -- must be last block so finish up */
      { /* Find out how many bytes and residual bits there are */
        byte = count >> 3;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/mkproto.awk /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/mkproto.awk
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/mkproto.awk	1998-03-26 12:51:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/mkproto.awk	1998-05-14 15:07:51.000000000 +0800
@@ -16,17 +16,52 @@
       printf "%s\n",$0;
     }
     next;
   }
 }
 
+/^FN_LOCAL_BOOL/ {
+  split($0,a,"[,()]")
+  printf "BOOL %s(int );\n", a[2]
+}
+
+/^FN_LOCAL_STRING/ {
+  split($0,a,"[,()]")
+  printf "char *%s(int );\n", a[2]
+}
+
+/^FN_LOCAL_INT/ {
+  split($0,a,"[,()]")
+  printf "int %s(int );\n", a[2]
+}
+
+/^FN_LOCAL_CHAR/ {
+  split($0,a,"[,()]")
+  printf "char %s(int );\n", a[2]
+}
+
+/^FN_GLOBAL_BOOL/ {
+  split($0,a,"[,()]")
+  printf "BOOL %s(void);\n", a[2]
+}
+
+/^FN_GLOBAL_STRING/ {
+  split($0,a,"[,()]")
+  printf "char *%s(void);\n", a[2]
+}
+
+/^FN_GLOBAL_INT/ {
+  split($0,a,"[,()]")
+  printf "int %s(void);\n", a[2]
+}
+
 /^static|^extern/ || !/^[a-zA-Z]/ || /[;]/ {
   next;
 }
 
-!/^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^struct|^BOOL|^void|^time/ {
+!/^OFF_T|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^struct|^BOOL|^void|^time/ {
   next;
 }
 
 
 /[(].*[)][ \t]*$/ {
     printf "%s;\n",$0;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: options.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: params.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/proto.h	1998-04-17 14:48:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/proto.h	1998-05-14 15:07:51.000000000 +0800
@@ -1,25 +1,32 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
+int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
+void generate_hash(char *in, char *challenge, char *out);
+int auth_server(int fd, int module, char *addr, char *leader);
+void auth_client(int fd, char *user, char *challenge);
 uint32 get_checksum1(char *buf1,int len);
 void get_checksum2(char *buf,int len,char *sum);
-void file_checksum(char *fname,char *sum,off_t size);
+void file_checksum(char *fname,char *sum,OFF_T size);
 void checksum_init(void);
 void sum_init(void);
 void sum_update(char *p,int len);
 void sum_end(char *sum);
+int start_socket_client(char *host, char *path, int argc, char *argv[]);
+int daemon_main(void);
 void setup_protocol(int f_out,int f_in);
+int claim_connection(char *fname,int max_connections);
 int check_exclude(char *name,char **local_exclude_list);
 void add_exclude_list(char *pattern,char ***list);
 void add_exclude(char *pattern);
 char **make_exclude_list(char *fname,char **list1,int fatal);
 void add_exclude_file(char *fname,int fatal);
 void send_exclude_list(int f);
 void recv_exclude_list(int f);
 void add_cvs_excludes(void);
-int link_stat(const char *Path, struct stat *Buffer) ;
+int link_stat(const char *Path, STRUCT_STAT *Buffer) ;
 void send_file_entry(struct file_struct *file,int f,unsigned base_flags);
 struct file_list *send_file_list(int f,int argc,char *argv[]);
 struct file_list *recv_file_list(int f);
 int file_compare(struct file_struct **f1,struct file_struct **f2);
 int flist_find(struct file_list *flist,struct file_struct *f);
 void flist_free(struct file_list *flist);
@@ -28,59 +35,112 @@
 void init_hard_links(struct file_list *flist);
 int check_hard_link(struct file_struct *file);
 void do_hard_links(struct file_list *flist);
 int64 write_total(void);
 int64 read_total(void);
 void setup_nonblocking(int f_in,int f_out);
-int read_int(int f);
+int32 read_int(int f);
 int64 read_longint(int f);
 void read_buf(int f,char *buf,int len);
 void read_sbuf(int f,char *buf,int len);
 unsigned char read_byte(int f);
 int sparse_end(int f);
 int write_file(int f,char *buf,int len);
-void write_int(int f,int x);
+void write_int(int f,int32 x);
 void write_longint(int f, int64 x);
 void write_buf(int f,char *buf,int len);
+void write_sbuf(int f,char *buf);
 void write_byte(int f,unsigned char c);
 void write_flush(int f);
-void do_server_sender(int argc,char *argv[]);
-void do_server_recv(int argc,char *argv[]);
-void start_server(int argc, char *argv[]);
+int read_line(int f, char *buf, int maxlen);
+void io_printf(int fd, const char *format, ...);
+char *lp_motd_file(void);
+char *lp_lock_file(void);
+int lp_max_connections(void);
+int lp_syslog_facility(void);
+char *lp_name(int );
+char *lp_comment(int );
+char *lp_path(int );
+BOOL lp_read_only(int );
+BOOL lp_list(int );
+char *lp_uid(int );
+char *lp_gid(int );
+char *lp_hosts_allow(int );
+char *lp_hosts_deny(int );
+char *lp_auth_users(int );
+char *lp_secrets_file(int );
+BOOL lp_load(char *pszFname);
+int lp_numservices(void);
+int lp_number(char *name);
+void rprintf(int fd, const char *format, ...);
+void rflush(int fd);
+void start_server(int f_in, int f_out, int argc, char *argv[]);
+int client_run(int f_in, int f_out, int pid, int argc, char *argv[]);
+int start_client(int argc, char *argv[]);
 int main(int argc,char *argv[]);
-void match_sums(int f,struct sum_struct *s,struct map_struct *buf,off_t len);
+void match_sums(int f,struct sum_struct *s,struct map_struct *buf,OFF_T len);
 void match_report(void);
+void *smb_mem_malloc(size_t size,char *file,int line);
+char *smb_mem_strdup(char *s, char *file, int line);
+int smb_mem_free(void *ptr,char *file,int line);
+void smb_mem_write_info(void *ptr,FILE *outfile);
+char *smb_mem_query_file(void *ptr);
+int smb_mem_query_line(void *ptr);
+int smb_mem_test(void *ptr);
+void smb_mem_write_status(FILE *outfile);
+void smb_mem_write_verbose(FILE *outfile);
+void smb_mem_write_errors(FILE *outfile);
+void smb_mem_set_multiplier(int multiplier);
+void *smb_mem_resize(void *ptr,size_t newsize);
+void usage(int F);
+void parse_arguments(int argc, char *argv[]);
+void server_options(char **args,int *argc);
+BOOL pm_process( char *FileName,
+                 BOOL (*sfunc)(char *),
+                 BOOL (*pfunc)(char *, char *) );
 int adapt_block_size(struct file_struct *file, int bsize);
 void recv_generator(char *fname,struct file_list *flist,int i,int f_out);
 void exit_cleanup(int code);
 void sig_int(void);
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen);
 void send_files(struct file_list *flist,int f_out,int f_in);
 void generate_files(int f,struct file_list *flist,char *local_name,int f_recv);
+int open_socket_out(char *host, int port);
+int is_a_socket(int fd);
+void start_accept_loop(int port, int (*fn)(int ));
+void set_socket_options(int fd, char *options);
+void become_daemon(void);
+char *client_addr(int fd);
+char *client_name(int fd);
 int do_unlink(char *fname);
 int do_symlink(char *fname1, char *fname2);
 int do_link(char *fname1, char *fname2);
 int do_lchown(const char *path, uid_t owner, gid_t group);
 int do_mknod(char *pathname, mode_t mode, dev_t dev);
 int do_rmdir(char *pathname);
 int do_open(char *pathname, int flags, mode_t mode);
 int do_chmod(const char *path, mode_t mode);
 int do_rename(char *fname1, char *fname2);
 int do_mkdir(char *fname, mode_t mode);
 char *do_mktemp(char *template);
+int do_stat(const char *fname, STRUCT_STAT *st);
+int do_lstat(const char *fname, STRUCT_STAT *st);
+int do_fstat(int fd, STRUCT_STAT *st);
+OFF_T do_lseek(int fd, OFF_T offset, int whence);
+char *d_name(struct dirent *di);
 void send_token(int f,int token,struct map_struct *buf,int offset,
 		int n,int toklen);
 int recv_token(int f,char **data);
 void see_token(char *data, int toklen);
 void add_uid(uid_t uid);
 void add_gid(gid_t gid);
 void send_uid_list(int f);
 void recv_uid_list(int f, struct file_list *flist);
 int num_waiting(int fd);
-struct map_struct *map_file(int fd,off_t len);
-char *map_ptr(struct map_struct *map,off_t offset,int len);
+struct map_struct *map_file(int fd,OFF_T len);
+char *map_ptr(struct map_struct *map,OFF_T offset,int len);
 void unmap_file(struct map_struct *map);
 int piped_child(char **command,int *f_in,int *f_out);
 int local_child(int argc, char **argv,int *f_in,int *f_out);
 void out_of_memory(char *str);
 void overflow(char *str);
 int set_modtime(char *fname,time_t modtime);
@@ -89,6 +149,13 @@
 int full_write(int desc, char *ptr, int len);
 int safe_read(int desc, char *ptr, int len);
 int copy_file(char *source, char *dest, mode_t mode);
 void u_sleep(int usec);
 pid_t do_fork(void);
 void kill_all(int sig);
+void strlcpy(char *d, char *s, int maxlen);
+int name_to_uid(char *name, uid_t *uid);
+int name_to_gid(char *name, gid_t *gid);
+int process_exists(int pid);
+int lock_range(int fd, int offset, int len);
+void glob_expand(char **argv, int *argc, int maxargs);
+void strlower(char *s);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/README	1998-03-26 12:51:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/README	1998-05-14 15:07:50.000000000 +0800
@@ -69,12 +69,18 @@
 features. 
 
 To install rsync, first run the "configure" script. This will create a
 Makefile and config.h appropriate for your system. Then type
 "make". 
 
+Note that on some systems you will have to force configure not to use
+gcc because gcc may not support some features (such as 64 bit file
+offsets) that your system may support. Set the environment variable CC
+to the name of your native compiler before running configure in this
+case. 
+
 Once built put a copy of rsync in your search path on the local and
 remote systems (or use "make install"). That's it!
 
 
 MAILING LIST
 ------------
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/rsync.1	1998-03-26 12:51:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/rsync.1	1998-05-14 15:07:51.000000000 +0800
@@ -1,500 +1,556 @@
-.TH RSYNC 1 26/3/1998 rsync rsync
-.SH NAME
+.TH "rsync" "1" "13 May 1998" "" "" 
+.SH "NAME" 
 rsync \- faster, flexible replacement for rcp
-.SH SYNOPSIS
-   rsync [options] [user@]host:path path
-
-OR
-
-   rsync [options] path [user@]host:path 
-
-OR
-
-   rsync [options] path path
-
-.SH DESCRIPTION
+.SH "SYNOPSIS" 
+.PP 
+rsync [options] [user@]host:path path
+.PP 
+rsync [options] path [user@]host:path
+.PP 
+rsync [options] path path
+.PP 
+rsync [options] [user@]host::path path
+.PP 
+rsync [options] path [user@]host::path
+.PP 
+.SH "DESCRIPTION" 
+.PP 
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speedup file transfers when the destination file already
-exists.
-
+exists\&.
+.PP 
 The rsync remote-update protocol allows rsync to transfer just the
-differences between two sets of files across the network link, using an
-efficient checksum-search algorithm described in the technical report
-that accompanies this package.
-
+differences between two sets of files across the network link, using
+an efficient checksum-search algorithm described in the technical
+report that accompanies this package\&.
+.PP 
 Some of the additional features of rsync are:
-
-- support for copying links, devices, owners, groups and permissions
-
-- exclude and exclude-from options similar to GNU tar
-
-- a CVS exclude mode for ignoring the same files that CVS would ignore
-
-- can use any transparent remote shell, including rsh or ssh
-
-- does not require root privileges
-
-- pipelining of file transfers to minimise latency costs
-
-.SH SETUP
-
-See the file README for installation instructions. 
-
+.PP 
+.IP o 
+support for copying links, devices, owners, groups and permissions
+.IP o 
+exclude and exclude-from options similar to GNU tar
+.IP o 
+a CVS exclude mode for ignoring the same files that CVS would ignore
+.IP o 
+can use any transparent remote shell, including rsh or ssh
+.IP o 
+does not require root privileges
+.IP o 
+pipelining of file transfers to minimize latency costs
+.IP o 
+support for anonymous or authenticated rsync servers (ideal for
+mirroring)
+.PP 
+.SH "GENERAL" 
+.PP 
+There are five different ways of using rsync\&. They are:
+.PP 
+.IP o 
+for copying local files\&. This is invoked when neither
+source nor destination path contains a : separator
+.IP 
+.IP o 
+for copying from the local machine to a remote machine using
+a remote shell program as the transport (such as rsh or
+ssh)\&. This is invoked when the destination path contains a
+single : separator\&.
+.IP 
+.IP o 
+for copying from a remote machine to the local machine
+using a remote shell program\&. This is invoked when the local path
+contains a : separator\&.
+.IP 
+.IP o 
+for copying from a remote rsync server to the local
+machine\&. This is invoked when the source path contains a ::
+separator\&. 
+.IP 
+.IP o 
+for copying from the local machine to a remote rsync
+server\&. This is invoked when the destination path contains a ::
+separator\&. 
+.PP 
+Note that in all cases at least one of the source and destination
+paths must be local\&.
+.PP 
+.SH "SETUP" 
+.PP 
+See the file README for installation instructions\&.
+.PP 
 Once installed you can use rsync to any machine that you can use rsh
-to. rsync uses rsh for its communications, unless both the source and
-destination are local.
-
+to\&.  rsync uses rsh for its communications, unless both the source and
+destination are local\&.
+.PP 
 You can also specify a alternative to rsh, by either using the -e
-command line option, or by setting the RSYNC_RSH environment
-variable. 
-
+command line option, or by setting the RSYNC_RSH environment variable\&.
+.PP 
 One common substitute is to use ssh, which offers a high degree of
-security.
-
-.SH USAGE
-
-You use rsync in the same way you use rcp. You must specify a source
-and a destination, one of which may be remote. 
-
+security\&.
+.PP 
+.SH "USAGE" 
+.PP 
+You use rsync in the same way you use rcp\&. You must specify a source
+and a destination, one of which may be remote\&.
+.PP 
 Perhaps the best way to explain the syntax is some examples:
-
-	rsync *.c foo:src/
-
-this would transfer all files matching the pattern *.c from the
-current directory to the directory src on the machine foo. If any of
+.PP 
+.RS 
+rsync *\&.c foo:src/
+.RE 
+.PP 
+this would transfer all files matching the pattern *\&.c from the
+current directory to the directory src on the machine foo\&. If any of
 the files already exist on the remote system then the rsync
 remote-update protocol is used to update the file by sending only the
-differences. See the tech report for details.
-
-	rsync -avz foo:src/bar /data/tmp
-
+differences\&. See the tech report for details\&.
+.PP 
+.RS 
+rsync -avz foo:src/bar /data/tmp
+.RE 
+.PP 
 recursively transfer all files from the directory src/bar on the
-machine foo into the /data/tmp/bar directory on the local machine. The
+machine foo into the /data/tmp/bar directory on the local machine\&. The
 files are transferred in "archive" mode, which ensures that symbolic
 links, devices, attributes, permissions, ownerships etc are preserved
-in the transfer. Additionally compression will be used to reduce the
-size of data portions of the transfer.
-
-	rsync -avz foo:src/bar/ /data/tmp
- 
-With a trailing slash on the source this behaviour changes to transfer
+in the transfer\&.  Additionally compression will be used to reduce the
+size of data portions of the transfer\&.
+.PP 
+.RS 
+rsync -avz foo:src/bar/ /data/tmp
+.RE 
+.PP 
+With a trailing slash on the source this behavior changes to transfer
 all files from the directory src/bar on the machine foo into the
-/data/tmp/. With a traling / on a source name it means "copy the
-contents of this directory". Without a trailing slash it means "copy
-the directory". This difference becomes particularly important when
-using the --delete option.
-
+/data/tmp/\&.  With a trailing / on a source name it means "copy the
+contents of this directory"\&.  Without a trailing slash it means "copy
+the directory"\&. This difference becomes particularly important when
+using the --delete option\&.
+.PP 
 You can also use rsync in local-only mode, where both the source and
-destination don't have a ':' in the name. In this case it behaves like
-an improved copy command.
-
-.SH EXAMPLES
-
-Here are some examples of how I use rsync.
-
-To backup my wife's home directory, which consists of large MS
-word files and mail folders I use a cron job that runs 
-
-        rsync -Cavz . arvidsjaur:backup
-
+destination don\'t have a \':\' in the name\&. In this case it behaves like
+an improved copy command\&.
+.PP 
+.SH "CONNECTING TO AN RSYNC SERVER" 
+.PP 
+It is also possible to use rsync without using rsh or ssh as the
+transport\&. In this case you will connect to a remote rsync server
+running on TCP port 873\&. 
+.PP 
+Using rsync in this was is the same as using it with rsh or ssh except
+that:
+.PP 
+.IP o 
+you use a double colon :: instead of a single colon to
+separate the hostname from the path\&. 
+.IP 
+.IP o 
+the remote server may print a message of the day when you
+connect
+.IP 
+.IP o 
+if you specify no path name on the remote server then the
+list of accessible paths on the server will be shown\&.
+.PP 
+.SH "RUNNING AN RSYNC SERVER" 
+.PP 
+An rsync server is configured using a config file which by default is
+called /etc/rsyncd\&.conf\&. Please see the rsyncd\&.conf(5) man page for more
+information\&. 
+.PP 
+.SH "EXAMPLES" 
+.PP 
+Here are some examples of how I use rsync\&.
+.PP 
+To backup my wife\'s home directory, which consists of large MS word
+files and mail folders I use a cron job that runs
+.PP 
+.RS 
+rsync -Cavz \&. arvidsjaur:backup
+.RE 
+.PP 
 each night over a PPP link to a duplicate directory on my machine
-"arvidsjaur". 
-
-To synchronise my samba source trees I use the following Makefile
+"arvidsjaur"\&.
+.PP 
+To synchronize my samba source trees I use the following Makefile
 targets:
-
-      get:
-       rsync -avuzb --exclude '*~' samba:samba/ .
-
-      put:
-       rsync -Cavuzb . samba:samba/
-
-      sync: get put
-
+.PP 
+.RS 
+get:
+.br 
+rsync -avuzb --exclude \'*~\' samba:samba/ \&.
+.PP 
+put:
+.br 
+rsync -Cavuzb \&. samba:samba/
+.PP 
+sync: get put
+.RE 
+.PP 
 this allows me to sync with a CVS directory at the other end of the
-link. I then do cvs operations on the remote machine, which saves a
-lot of time as the remote cvs protocol isn't very efficient.
-
-I mirror a directory between my "old" and "new" ftp sites with the command
-
-      rsync -az -e ssh --delete ~ftp/pub/samba/ nimbus:"~ftp/pub/tridge/samba" 
-
-this is launched from cron every few hours.
-
-.SH OPTIONS
-
-rsync uses the GNU long options package. Many of the command line
-options have two variants, one short and one long. These are shown
-below separated by commas. Some options only have a long variant.
-
-.B -h, --help
-.RS 3
-Print a short help page describing the options available in rsync
-.RE
-
-.B --version
-.RS 3
+link\&. I then do cvs operations on the remote machine, which saves a
+lot of time as the remote cvs protocol isn\'t very efficient\&.
+.PP 
+I mirror a directory between my "old" and "new" ftp sites with the
+command
+.PP 
+.RS 
+rsync -az -e ssh --delete ~ftp/pub/samba/ nimbus:"~ftp/pub/tridge/samba"
+.RE 
+.PP 
+this is launched from cron every few hours\&.
+.PP 
+.SH "OPTIONS" 
+.PP 
+rsync uses the GNU long options package\&. Many of the command line
+options have two variants, one short and one long\&.  These are shown
+below separated by commas\&. Some options only have a long variant\&.
+.PP 
+.IP "\fB-h, --help\fP" 
+Print a short help page describing the options
+available in rsync
+.IP 
+.IP "\fB--version\fP" 
 print the rsync version number and exit
-.RE
-
-.B -v, --verbose
-.RS 3
-This option increases the amount of information you are given during
-the transfer. By default rsync works silently. A single -v will give
-you information about what files are being transferred and a brief
-summary at the end. Two -v flags will give you information on what
-files are being skipped and slightly more information at the end. More
-than two -v flags should only be used if you are debugging rsync
-.RE
-
-.B -I, --ignore-times
-.RS 3
-Normally rsync will skip any files that are already the same length
-and have the same timestamp. This option turns off this behaviour.
-.RE
-
-.B -c, --checksum
-.RS 3
-This forces the sender to checksum all files using a 128-bit MD4
-checksum before transfer. The checksum is then explicitly checked on
-the receiver and any files of the same name which already exist and
-have the same checksum and size on the receiver are skipped. This
-option can be quite slow.
-.RE
-
-.B -a, --archive
-.RS 3
-This is equivalent to -rlptDog. It is a quick way of saying I want
-recursion and want to preserve everything. 
-.RE
-
-.B -r, --recursive
-.RS 3
+.IP 
+.IP "\fB-v, --verbose\fP" 
+This option increases the amount of information you
+are given during the transfer\&.  By default rsync works silently\&. A
+single -v will give you information about what files are being
+transferred and a brief summary at the end\&. Two -v flags will give you
+information on what files are being skipped and slightly more
+information at the end\&. More than two -v flags should only be used if
+you are debugging rsync
+.IP 
+.IP "\fB-I, --ignore-times\fP" 
+Normally rsync will skip any files that are
+already the same length and have the same time-stamp\&. This option turns
+off this behavior\&.
+.IP 
+.IP "\fB-c, --checksum\fP" 
+This forces the sender to checksum all files using
+a 128-bit MD4 checksum before transfer\&. The checksum is then
+explicitly checked on the receiver and any files of the same name
+which already exist and have the same checksum and size on the
+receiver are skipped\&.  This option can be quite slow\&.
+.IP 
+.IP "\fB-a, --archive\fP" 
+This is equivalent to -rlptDog\&. It is a quick way
+of saying I want recursion and want to preserve everything\&.
+.IP 
+.IP "\fB-r, --recursive\fP" 
 This tells rsync to copy directories recursively
-.RE
-
-.B -R, --relative
-.RS 3
-Use relative paths. This means that the full path names specified on
-the command line are sent to the server rather than just the last
-parts of the filenames. This is particularly useful when you want to
-sent several different directories at the same time. For example if
-you used the command
-
-	rsync foo/bar/foo.c remote:/tmp/
-
-then this would create a file called foo.c in /tmp/ on the remote
-machine. If instead you used
-
-	rsync -R foo/bar/foo.c remote:/tmp/
-
-then a file called /tmp/foo/bar/foo.c would be created on the remote
-machine. The full path name is preserved.
+.IP 
+.IP "\fB-R, --relative\fP" 
+Use relative paths\&. This means that the full path
+names specified on the command line are sent to the server rather than
+just the last parts of the filenames\&. This is particularly useful when
+you want to sent several different directories at the same time\&. For
+example if you used the command
+.IP 
 
-.RE
-
-.B -b, --backup
-.RS 3
-With this option pre-existing destination files are renamed with a ~
-extension as each file is transferred. You can control the backup
-suffix using the --suffix option.
-.RE
-
-.B -u, --update
-.RS 3
-This forces rsync to skip any files for which the destination file
-already exists and has a date later than the source file.
-.RE
-
-.B -l, --links
-.RS 3
-This tells rsync to recreate symbolic links on the remote system to be
-the same as the local system. Without this option all symbolic links
-are skipped.
-.RE
+.DS 
+ 
+rsync foo/bar/foo\&.c remote:/tmp/
+.DE 
+ 
 
-.B -L, --copy-links
-.RS 3
-This tells rsync to treat symbolic links just like ordinary
-files. 
-.RE
+.IP 
+then this would create a file called foo\&.c in /tmp/ on the remote
+machine\&. If instead you used
+.IP 
 
-.B -H, --hard-links
-.RS 3
-This tells rsync to recreate hard links on the remote system to be
-the same as the local system. Without this option hard links are
-treated like regular files.
+.DS 
+ 
+rsync -R foo/bar/foo\&.c remote:/tmp/
+.DE 
+ 
 
+.IP 
+then a file called /tmp/foo/bar/foo\&.c would be created on the remote
+machine\&. The full path name is preserved\&.
+.IP 
+.IP "\fB-b, --backup\fP" 
+With this option preexisting destination files are
+renamed with a ~ extension as each file is transferred\&.  You can
+control the backup suffix using the --suffix option\&.
+.IP 
+.IP "\fB-u, --update\fP" 
+This forces rsync to skip any files for which the
+destination file already exists and has a date later than the source
+file\&.
+.IP 
+.IP "\fB-l, --links\fP" 
+This tells rsync to recreate symbolic links on the
+remote system  to  be the same as the local system\&. Without this
+option all symbolic links are skipped\&.
+.IP 
+.IP "\fB-L, --copy-links\fP" 
+This tells rsync to treat symbolic links just
+like  ordinary files\&.
+.IP 
+.IP "\fB-H, --hard-links\fP" 
+This tells rsync to recreate hard  links  on
+the  remote system  to  be the same as the local system\&. Without this
+option hard links are treated like regular files\&.
+.IP 
 Note that rsync can only detect hard links if both parts of the link
-are in the list of files being sent.
-
-This option can be quite slow, so only use it if you need it.
-.RE
-
-.B -W, --whole-file
-.RS 3
-With this option the incremental rsync algorithm is not used and the 
-whole file is sent as-is instead. This may be useful when using rsync
-with a local machine.
-.RE
-
-.B -p, --perms
-.RS 3
-This option causes rsync to update the remote permissions to be the
-same as the local permissions.
-.RE
-
-.B -o, --owner
-.RS 3
-This option causes rsync to update the remote owner of the file to be
-the same as the local owner. This is only available to the super-user.
-.RE
-
-.B -g, --group
-.RS 3
-This option causes rsync to update the remote group of the file to be
-the same as the local group.
-.RE
-
-.B -D, --devices
-.RS 3
-This option causes rsync to transfer character and block device
-information to the remote system to recreate these devices. This
-option is only available to the super-user.
-.RE
-
-.B -t, --times
-.RS 3
-This tells rsync to transfer modification times along with the files
-and update them on the remote system
-.RE
-
-.B -n, --dry-run
-.RS 3
-This tells rsync to not do any file transfers, instead it will just
-report the actions it would have taken.
-.RE
-
-.B -S, --sparse
-.RS 3
-Try to handle sparse files efficiently so they take up less space on
-the destination.
-.RE
-
-.B -x, --one-file-system
-.RS 3
-This tells rsync not to cross filesystem boundaries when
-recursing. This is useful for transferring the contents of only one
-filesystem.
-.RE
-
-.B --delete
-.RS 3
-This tells rsync to delete any files on the receiving side that aren't
-on the sending side. This option can be dangerous if used incorrectly!
-
+are in the list of files being sent\&.
+.IP 
+This option can be quite slow, so only use it if you need it\&.
+.IP 
+.IP "\fB-W, --whole-file\fP" 
+With this option the incremental rsync algorithm
+is  not used  and  the whole file is sent as-is instead\&. This may be
+useful when using rsync with a local machine\&.
+.IP 
+.IP "\fB-p, --perms\fP" 
+This option causes rsync to update the remote
+permissions to be the same as the local permissions\&.
+.IP 
+.IP "\fB-o, --owner\fP" 
+This option causes rsync to update the  remote  owner
+of the  file to be the same as the local owner\&. This is only available
+to the super-user\&.
+.IP 
+.IP "\fB-g, --group\fP" 
+This option causes rsync to update the  remote  group
+of the file to be the same as the local group\&.
+.IP 
+.IP "\fB-D, --devices\fP" 
+This option causes rsync to transfer character and
+block device information to the remote system to recreate these
+devices\&. This option is only available to the super-user\&.
+.IP 
+.IP "\fB-t, --times\fP" 
+This tells rsync to transfer modification times along
+with the files and update them on the remote system
+.IP 
+.IP "\fB-n, --dry-run\fP" 
+This tells rsync to not do any file transfers,
+instead it will just report the actions it would have taken\&.
+.IP 
+.IP "\fB-S, --sparse\fP" 
+Try to handle sparse files efficiently so they take
+up less space on the destination\&.
+.IP 
+.IP "\fB-x, --one-file-system\fP" 
+This tells rsync not to cross filesystem
+boundaries  when recursing\&.  This  is useful for transferring the
+contents of only one filesystem\&.
+.IP 
+.IP "\fB--delete\fP" 
+This tells rsync to delete any files on the receiving
+side that aren\'t on the sending side\&. This option can be dangerous if
+used incorrectly!
+.IP 
 It is a very good idea to run first using the dry run option (-n) to
-see what files would be deleted to make sure important files aren't
-listed.
-
-rsync 1.6.4 changed the behaviour of --delete to make it less
-dangerous. rsync now only scans directories on the receiving side that
-are explicitly transferred from the sending side. Only files in these
-directories are deleted.
-
-Still, it is probably easy to get burnt with this option. The moral of
-the story is to use the -n option until you get used to the behaviour
-of --delete.
-
+see what files would be deleted to make sure important files aren\'t
+listed\&.
+.IP 
+rsync 1\&.6\&.4 changed the behavior of --delete to make it less
+dangerous\&.  rsync now only scans directories on the receiving side
+that are explicitly transferred from the sending side\&.  Only files in
+these directories are deleted\&.
+.IP 
+Still, it is probably easy to get burnt with this option\&.  The moral
+of the story is to use the -n option until you get used to the
+behavior of --delete\&.
+.IP 
 NOTE: It also may delete files on the destination if the sending side
-can't open them or stat them. This is a bug that hopefully will be
-fixed in a future release.
-.RE
-
-.B --force
-.RS 3
-This options tells rsync to delete directories even if they are not
-empty. This applies to both the --delete option and to cases where
-rsync tries to copy a normal file but the destination contains a
-directory of the same name. Normally rsync will refuse to do a
-recursive directory deletion in such cases, by using --force the
-recursive deletion will be done.
-
+can\'t open them or stat them\&. This is a bug that hopefully will be
+fixed in a future release\&.
+.IP 
+.IP "\fB--force\fP" 
+This options tells rsync to delete directories even if
+they are not empty\&.  This applies to both the --delete option and to
+cases where rsync tries to copy a normal file but the destination
+contains a directory of the same name\&. Normally rsync will refuse to
+do a recursive directory deletion in such cases, by using --force
+the recursive deletion will be done\&.
+.IP 
 Use this option with caution!
-.RE
-
-.B -B , --block_size BLOCKSIZE
-.RS 3
-This controls the block size used in the rsync algorithm. See the
-technical report for details.
-.RE
-
-.B -e, --rsh COMMAND
-.RS 3
-This option allows you to choose an alternative remote shell program
-to use for communication between the local and remote copies of
-rsync. By default rsync will use rsh, but you may like to instead use
-ssh because of its high security.
-
+.IP 
+.IP "\fB-B , --block_size BLOCKSIZE\fP" 
+This controls the block size used in
+the rsync algorithm\&. See the technical report for details\&.
+.IP 
+.IP "\fB-e, --rsh COMMAND\fP" 
+This option allows you to choose an alternative
+remote shell program to use for communication between the local and
+remote copies of rsync\&. By default rsync will use rsh, but you may
+like to instead use ssh because of its high security\&.
+.IP 
 You can also choose the remote shell program using the RSYNC_RSH
-environment variable.
-.RE
-
-.B --rsync-path PATH
-.RS 3
-Use this to specify the path to the copy of rsync on the remote
-machine. Useful when its not in your path.
-.RE
-
-.B --exclude FILE
-.RS 3
-This option allows you to selectively exclude certain files from the
-list of files to be transferred. This is most useful in combination
-with a recursive transfer.
-
+environment variable\&.
+.IP 
+.IP "\fB--rsync-path PATH\fP" 
+Use this to specify the path to the copy of
+rsync on the remote machine\&. Useful when its not in your path\&.
+.IP 
+.IP "\fB--exclude FILE\fP" 
+This option allows you to selectively exclude
+certain files from the list of files to be transferred\&. This is most
+useful in combination with a recursive transfer\&.
+.IP 
 The option FILE can either be a file name or a shell wildcard
-expression. If it is a directory name then rsync will not recurse into
-directories of that name. 
-
+expression\&. If it is a directory name then rsync will not recurse into
+directories of that name\&.
+.IP 
 You may use as many --exclude options on the command line as you like
-to build up the list of files to exclude.
-
-If the filename is a single ! then the exclude list is reset.
-.RE
-
-.B --exclude-from FILE
-.RS 3
-This option is similar to the --exclude option, but instead it adds
-all filenames listed in the file FILE to the exclude list.
-.RE
-
-.B -C, --cvs-exclude
-.RS 3
-This is a useful shorthand for excluding a broad range of files that
-you often don't want to transfer between systems. It uses the same
-algorithm that CVS uses to determine if a file should be ignored. 
-
-The exclude list is initialised to:
-
-.RS 5
-RCS SCCS CVS CVS.adm RCSLOG cvslog.* 
-tags TAGS .make.state .nse_depinfo 
-*~ #* .#*  * *.old *.bak *.BAK *.orig 
-*.rej .del-* *.a *.o *.obj *.so *.Z *.elc *.ln 
-core
-.RE
-
-then files listed in a $HOME/.cvsignore are added to the list and any
-files listed in the CVSIGNORE environment variable (space delimited).
-
-Finally in each directory any files listed in the .cvsignore file in
-that directory are added to the list.
-.RE
-
-.B --suffix SUFFIX
-.RS 3
-This option allows you to override the default backup suffix used with
-the -b option. The default is a ~.
-.RE
-
-.B --csum-length LENGTH
-.RS 3
-By default the primary checksum used in rsync is a very strong 16 byte
-MD4 checksum. In most cases you will find that a truncated version of
-this checksum is quite efficient, and this will decrease the size of
-the checksum data sent over the link, making things faster.
-
+to build up the list of files to exclude\&.
+.IP 
+If the filename is a single ! then the exclude list is reset\&.
+.IP 
+.IP "\fB--exclude-from FILE\fP" 
+This option is similar to the --exclude
+option, but instead it adds all filenames listed in the file FILE to
+the exclude list\&.
+.IP 
+.IP "\fB-C, --cvs-exclude\fP" 
+This is a useful shorthand for excluding a
+broad range of files that you often don\'t want to transfer between
+systems\&. It uses the same algorithm that CVS uses to determine if
+a file should be ignored\&.
+.IP 
+The exclude list is initialized to:
+.IP 
+.RS 
+RCS SCCS CVS CVS\&.adm RCSLOG cvslog\&.* tags TAGS \&.make\&.state
+\&.nse_depinfo *~ #* \&.#* ,* *\&.old *\&.bak *\&.BAK *\&.orig *\&.rej \&.del-*
+*\&.a *\&.o *\&.obj *\&.so *\&.Z *\&.elc *\&.ln core
+.RE 
+.IP 
+then files listed in a $HOME/\&.cvsignore are added to the list and any
+files listed in the CVSIGNORE environment variable (space delimited)\&.
+.IP 
+Finally in each directory any files listed in the \&.cvsignore file in
+that directory are added to the list\&.
+.IP 
+.IP "\fB--suffix SUFFIX\fP" 
+This option allows you to override the default
+backup suffix used with the -b option\&. The default is a ~\&.
+.IP 
+.IP "\fB--csum-length LENGTH\fP" 
+By default the primary checksum used in
+rsync is a very strong 16 byte MD4 checksum\&. In most cases you will
+find that a truncated version of this checksum is quite efficient, and
+this will decrease the size of the checksum data sent over the link,
+making things faster\&.
+.IP 
 You can choose the number of bytes in the truncated checksum using the
---csum-length option. Any value less than or equal to 16 is valid.
-
+--csum-length option\&. Any value less than or equal to 16 is valid\&.
+.IP 
 Note that if you use this option then you run the risk of ending up
-with an incorrect target file. The risk with a value of 16 is
+with an incorrect target file\&. The risk with a value of 16 is
 microscopic and can be safely ignored (the universe will probably end
-before it fails) but with smaller values the risk is higher.
-.RE
-
-.B -T, --temp-dir DIR
-.RS 3
-This options instructs rsync to use DIR as a scratch directory when
-creating a temporary copies of the files transferred on the
-receiving side.  The default behaviour is to create the temporary
-files in the receiving directory.
-.RE
-
-.B -z, --compress
-.RS 3
-With this option, rsync compresses any data from the source file(s)
-which it sends to the destination machine.  This option is useful on
-slow links.  The compression method used is the same method that gzip
-uses.
-
+before it fails) but with smaller values the risk is higher\&.
+.IP 
+.IP "\fB-T, --temp-dir DIR\fP" 
+This options instructs rsync to use DIR as a
+scratch directory when creating a temporary copies of the files
+transferred on the receiving side\&.  The default behavior is to create
+the temporary files in the receiving directory\&.
+.IP 
+.IP "\fB-z, --compress\fP" 
+With this option, rsync compresses any data from
+the source file(s) which it sends to the destination machine\&.  This
+option is useful on slow links\&.  The compression method used is the
+same method that gzip uses\&.
+.IP 
 Note this this option typically achieves better compression ratios
 that can be achieved by using a compressing remote shell, or a
 compressing transport, as it takes advantage of the implicit
-information sent for matching data blocks.
-.RE
-
-.B --numeric-ids
-.RS 3
-With this option rsync will transfer numeric group and user ids rather
-than using user and group names and mapping them at both ends.
-
+information sent for matching data blocks\&.
+.IP 
+.IP "\fB--numeric-ids\fP" 
+With this option rsync will transfer numeric group
+and user ids rather than using user and group names and mapping them
+at both ends\&.
+.IP 
 By default rsync will use the user name and group name to determine
-what ownership to give files. The special uid 0 and the special group
+what ownership to give files\&. The special uid 0 and the special group
 0 and never mapped via user/group names even if the --numeric-ids
-option is not specified.
-
+option is not specified\&.
+.IP 
 If a user or group name does not exist on the destination system then
-the numeric id from the source system is used instead.
-
-.RE
-
-.B --timeout
-.RS 3
-This option allows you to set a maximum IO timeout in seconds. If no
-data is transferred for the specified time then rsync will exit. The
-default is 0, which means no timeout.
-
-.RE
-
-.SH BUGS
-
+the numeric id from the source system is used instead\&.
+.IP 
+.IP "\fB--timeout\fP" 
+This option allows you to set a maximum IO timeout in
+seconds\&. If no data is transferred for the specified time then rsync
+will exit\&. The default is 0, which means no timeout\&.
+.IP 
+.IP "\fB--daemon\fP" 
+This tells rsync that it is to run as a rsync
+daemon\&. If standard input is a socket then rsync will assume that it
+is being run via inetd, otherwise it will detach from the current
+terminal and become a background daemon\&. The dameon will read the
+config file (/etc/rsyncd\&.conf) on each connect made by a client and
+respond to requests accordingly\&. See the rsyncd\&.conf(5) man page for more
+details\&. 
+.IP 
+.IP "\fB--config FILE\fP" 
+This specifies an alternate config file than
+the default /etc/rsyncd\&.conf\&. This is only relevent when --daemon is
+specified\&. 
+.IP 
+.IP "\fB--port PORT\fP" 
+This specifies an alternate TCP port number to use
+rather than the default port 873\&. 
+.IP 
+.PP 
+.SH "FILES" 
+.PP 
+/etc/rsyncd\&.conf
+.PP 
+.SH "SEE ALSO" 
+.PP 
+rsyncd\&.conf(5)
+.PP 
+.SH "DIAGNOSTICS" 
+.PP 
+.SH "BUGS" 
+.PP 
 times are transferred as unix time_t values
-
+.PP 
 file permissions, devices etc are transferred as native numerical
 values
-
-see also the comments on the -delete option 
-
+.PP 
+see also the comments on the -delete option
+.PP 
 Please report bugs! The rsync bug tracking system is online at
-http://samba.anu.edu.au/rsync/
-
-
-.SH VERSION
-
-This man page is current for version 1.5 of rsync
-
-.SH CREDITS
-
-rsync was written by Andrew Tridgell and Paul Mackerras. They may be
-contacted via email at tridge@samba.anu.edu.au and
-Paul.Mackerras@cs.anu.edu.au
-
-rsync is distributed under the GNU public license. See the file
-COPYING for details.
-
-The primary ftp site for rsync is ftp://samba.anu.edu.au/pub/rsync.
-
-A WEB site is available at http://samba.anu.edu.au/rsync/
-
-We would be delighted to hear from you if you like this program.
-
+http://samba\&.anu\&.edu\&.au/rsync/
+.PP 
+.SH "VERSION" 
+This man page is current for version 2\&.0 of rsync
+.PP 
+.SH "CREDITS" 
+.PP 
+rsync is distributed under the GNU public license\&.  See the file
+COPYING for details\&.
+.PP 
+The primary ftp site for rsync is
+ftp://samba\&.anu\&.edu\&.au/pub/rsync\&.
+.PP 
+A WEB site is available at
+http://samba\&.anu\&.edu\&.au/rsync/
+.PP 
+We would be delighted to hear from you if you like this program\&.
+.PP 
 This program uses the zlib compression library written by Jean-loup
-Gailly and Mark Adler.
-
-.SH THANKS
-
+Gailly and Mark Adler\&.
+.PP 
+.SH "THANKS" 
+.PP 
 Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
-and David Bell for helpful suggestions and testing of rsync. I've
-probably missed some people, my apologies if I have.
+and David Bell for helpful suggestions and testing of rsync\&. I\'ve
+probably missed some people, my apologies if I have\&.
+.PP 
+.SH "AUTHOR" 
+.PP 
+rsync was written by Andrew Tridgell and Paul Mackerras\&.  They may be
+contacted via email at tridge@samba\&.anu\&.edu\&.au and
+Paul\&.Mackerras@cs\&.anu\&.edu\&.au
+.PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/rsync.c	1998-04-17 14:48:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/rsync.c	1998-05-14 15:07:51.000000000 +0800
@@ -69,66 +69,67 @@
 static int delete_file(char *fname)
 {
 	DIR *d;
 	struct dirent *di;
 	char buf[MAXPATHLEN];
 	extern int force_delete;
-	struct stat st;
+	STRUCT_STAT st;
 	int ret;
 
 	if (do_unlink(fname) == 0 || errno == ENOENT) return 0;
 
 #if SUPPORT_LINKS
-	ret = lstat(fname, &st);
+	ret = do_lstat(fname, &st);
 #else
-	ret = stat(fname, &st);
+	ret = do_stat(fname, &st);
 #endif
 	if (ret) {
-		fprintf(FERROR,"stat(%s) : %s\n", fname, strerror(errno));
+		rprintf(FERROR,"stat(%s) : %s\n", fname, strerror(errno));
 		return -1;
 	}
 
 	if (!S_ISDIR(st.st_mode)) {
-		fprintf(FERROR,"unlink(%s) : %s\n", fname, strerror(errno));
+		rprintf(FERROR,"unlink(%s) : %s\n", fname, strerror(errno));
 		return -1;
 	}
 
 	if (do_rmdir(fname) == 0 || errno == ENOENT) return 0;
 	if (!force_delete || (errno != ENOTEMPTY && errno != EEXIST)) {
-		fprintf(FERROR,"rmdir(%s) : %s\n", fname, strerror(errno));
+		rprintf(FERROR,"rmdir(%s) : %s\n", fname, strerror(errno));
 		return -1;
 	}
 
 	/* now we do a recsursive delete on the directory ... */
 	d = opendir(fname);
 	if (!d) {
-		fprintf(FERROR,"opendir(%s): %s\n",
+		rprintf(FERROR,"opendir(%s): %s\n",
 			fname,strerror(errno));
 		return -1;
 	}
 
 	for (di=readdir(d); di; di=readdir(d)) {
-		if (strcmp(di->d_name,".")==0 ||
-		    strcmp(di->d_name,"..")==0)
+		char *dname = d_name(di);
+		if (strcmp(dname,".")==0 ||
+		    strcmp(dname,"..")==0)
 			continue;
-		strncpy(buf, fname, (MAXPATHLEN-strlen(di->d_name))-2);
+		strlcpy(buf, fname, (MAXPATHLEN-strlen(dname))-2);
 		strcat(buf, "/");
-		strcat(buf, di->d_name);
+		strcat(buf, dname);
 		buf[MAXPATHLEN-1] = 0;
 		if (verbose > 0)
-			fprintf(FINFO,"deleting %s\n", buf);
+			rprintf(FINFO,"deleting %s\n", buf);
 		if (delete_file(buf) != 0) {
 			closedir(d);
 			return -1;
 		}
 	}	
 
 	closedir(d);
 	
 	if (do_rmdir(fname) != 0) {
-		fprintf(FERROR,"rmdir(%s) : %s\n", fname, strerror(errno));
+		rprintf(FERROR,"rmdir(%s) : %s\n", fname, strerror(errno));
 		return -1;
 	}
 
 	return 0;
 }
 
@@ -155,20 +156,20 @@
 
 /*
   generate a stream of signatures/checksums that describe a buffer
 
   generate approximately one checksum every n bytes
   */
-static struct sum_struct *generate_sums(struct map_struct *buf,off_t len,int n)
+static struct sum_struct *generate_sums(struct map_struct *buf,OFF_T len,int n)
 {
   int i;
   struct sum_struct *s;
   int count;
   int block_len = n;
   int remainder = (len%block_len);
-  off_t offset = 0;
+  OFF_T offset = 0;
 
   count = (len+(block_len-1))/block_len;
 
   s = (struct sum_struct *)malloc(sizeof(*s));
   if (!s) out_of_memory("generate_sums");
 
@@ -180,13 +181,13 @@
   if (count==0) {
     s->sums = NULL;
     return s;
   }
 
   if (verbose > 3)
-    fprintf(FINFO,"count=%d rem=%d n=%d flength=%d\n",
+    rprintf(FINFO,"count=%d rem=%d n=%d flength=%d\n",
 	    s->count,s->remainder,s->n,(int)s->flength);
 
   s->sums = (struct sum_buf *)malloc(sizeof(s->sums[0])*s->count);
   if (!s->sums) out_of_memory("generate_sums");
   
   for (i=0;i<count;i++) {
@@ -198,13 +199,13 @@
 
     s->sums[i].offset = offset;
     s->sums[i].len = n1;
     s->sums[i].i = i;
 
     if (verbose > 3)
-      fprintf(FINFO,"chunk[%d] offset=%d len=%d sum1=%08x\n",
+      rprintf(FINFO,"chunk[%d] offset=%d len=%d sum1=%08x\n",
 	      i,(int)s->sums[i].offset,s->sums[i].len,s->sums[i].sum1);
 
     len -= n1;
     offset += n1;
   }
 
@@ -216,24 +217,24 @@
   receive the checksums for a buffer
   */
 static struct sum_struct *receive_sums(int f)
 {
   struct sum_struct *s;
   int i;
-  off_t offset = 0;
+  OFF_T offset = 0;
 
   s = (struct sum_struct *)malloc(sizeof(*s));
   if (!s) out_of_memory("receive_sums");
 
   s->count = read_int(f);
   s->n = read_int(f);
   s->remainder = read_int(f);  
   s->sums = NULL;
 
   if (verbose > 3)
-    fprintf(FINFO,"count=%d n=%d rem=%d\n",
+    rprintf(FINFO,"count=%d n=%d rem=%d\n",
 	    s->count,s->n,s->remainder);
 
   if (s->count == 0) 
     return(s);
 
   s->sums = (struct sum_buf *)malloc(sizeof(s->sums[0])*s->count);
@@ -251,54 +252,54 @@
     } else {
       s->sums[i].len = s->n;
     }
     offset += s->sums[i].len;
 
     if (verbose > 3)
-      fprintf(FINFO,"chunk[%d] len=%d offset=%d sum1=%08x\n",
+      rprintf(FINFO,"chunk[%d] len=%d offset=%d sum1=%08x\n",
 	      i,s->sums[i].len,(int)s->sums[i].offset,s->sums[i].sum1);
   }
 
   s->flength = offset;
 
   return s;
 }
 
 
-static int set_perms(char *fname,struct file_struct *file,struct stat *st,
+static int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
 		     int report)
 {
   int updated = 0;
-  struct stat st2;
+  STRUCT_STAT st2;
 
   if (dry_run) return 0;
 
   if (!st) {
     if (link_stat(fname,&st2) != 0) {
-      fprintf(FERROR,"stat %s : %s\n",fname,strerror(errno));
+      rprintf(FERROR,"stat %s : %s\n",fname,strerror(errno));
       return 0;
     }
     st = &st2;
   }
 
   if (preserve_times && !S_ISLNK(st->st_mode) &&
       st->st_mtime != file->modtime) {
     updated = 1;
     if (set_modtime(fname,file->modtime) != 0) {
-      fprintf(FERROR,"failed to set times on %s : %s\n",
+      rprintf(FERROR,"failed to set times on %s : %s\n",
 	      fname,strerror(errno));
       return 0;
     }
   }
 
 #ifdef HAVE_CHMOD
   if (preserve_perms && !S_ISLNK(st->st_mode) &&
       st->st_mode != file->mode) {
     updated = 1;
     if (do_chmod(fname,file->mode) != 0) {
-      fprintf(FERROR,"failed to set permissions on %s : %s\n",
+      rprintf(FERROR,"failed to set permissions on %s : %s\n",
 	      fname,strerror(errno));
       return 0;
     }
   }
 #endif
 
@@ -307,32 +308,32 @@
 	  if (do_lchown(fname,
 			(am_root&&preserve_uid)?file->uid:-1,
 			preserve_gid?file->gid:-1) != 0) {
 		  if (preserve_uid && st->st_uid != file->uid)
 			  updated = 1;
 		  if (verbose>1 || preserve_uid)
-			  fprintf(FERROR,"chown %s : %s\n",
+			  rprintf(FERROR,"chown %s : %s\n",
 				  fname,strerror(errno));
 		  return updated;
 	  }
 	  updated = 1;
   }
     
   if (verbose > 1 && report) {
 	  if (updated)
-		  fprintf(FINFO,"%s\n",fname);
+		  rprintf(FINFO,"%s\n",fname);
 	  else
-		  fprintf(FINFO,"%s is uptodate\n",fname);
+		  rprintf(FINFO,"%s is uptodate\n",fname);
   }
   return updated;
 }
 
 
 /* choose whether to skip a particular file */
 static int skip_file(char *fname,
-		     struct file_struct *file, struct stat *st)
+		     struct file_struct *file, STRUCT_STAT *st)
 {
 	if (st->st_size != file->length) {
 		return 0;
 	}
 	
 	/* if always checksum is set then we use the checksum instead 
@@ -361,42 +362,42 @@
 	return ret;
 }
 
 void recv_generator(char *fname,struct file_list *flist,int i,int f_out)
 {  
   int fd;
-  struct stat st;
+  STRUCT_STAT st;
   struct map_struct *buf;
   struct sum_struct *s;
   int statret;
   struct file_struct *file = flist->files[i];
 
   if (verbose > 2)
-    fprintf(FINFO,"recv_generator(%s,%d)\n",fname,i);
+    rprintf(FINFO,"recv_generator(%s,%d)\n",fname,i);
 
   statret = link_stat(fname,&st);
 
   if (S_ISDIR(file->mode)) {
     if (dry_run) return;
     if (statret == 0 && !S_ISDIR(st.st_mode)) {
       if (do_unlink(fname) != 0) {
-	fprintf(FERROR,"unlink %s : %s\n",fname,strerror(errno));
+	rprintf(FERROR,"unlink %s : %s\n",fname,strerror(errno));
 	return;
       }
       statret = -1;
     }
     if (statret != 0 && do_mkdir(fname,file->mode) != 0 && errno != EEXIST) {
 	    if (!(relative_paths && errno==ENOENT && 
 		  create_directory_path(fname)==0 && 
 		  do_mkdir(fname,file->mode)==0)) {
-		    fprintf(FERROR,"mkdir %s : %s (2)\n",
+		    rprintf(FERROR,"mkdir %s : %s (2)\n",
 			    fname,strerror(errno));
 	    }
     }
     if (set_perms(fname,file,NULL,0) && verbose) 
-      fprintf(FINFO,"%s/\n",fname);
+      rprintf(FINFO,"%s/\n",fname);
     return;
   }
 
   if (preserve_links && S_ISLNK(file->mode)) {
 #if SUPPORT_LINKS
     char lnk[MAXPATHLEN];
@@ -410,18 +411,18 @@
 	  return;
 	}
       }
     }
     delete_file(fname);
     if (do_symlink(file->link,fname) != 0) {
-      fprintf(FERROR,"link %s -> %s : %s\n",
+      rprintf(FERROR,"link %s -> %s : %s\n",
 	      fname,file->link,strerror(errno));
     } else {
       set_perms(fname,file,NULL,0);
       if (verbose) 
-	fprintf(FINFO,"%s -> %s\n",
+	rprintf(FINFO,"%s -> %s\n",
 		fname,file->link);
     }
 #endif
     return;
   }
 
@@ -429,46 +430,46 @@
   if (am_root && preserve_devices && IS_DEVICE(file->mode)) {
     if (statret != 0 || 
 	st.st_mode != file->mode ||
 	st.st_rdev != file->rdev) {	
       delete_file(fname);
       if (verbose > 2)
-	fprintf(FINFO,"mknod(%s,0%o,0x%x)\n",
+	rprintf(FINFO,"mknod(%s,0%o,0x%x)\n",
 		fname,(int)file->mode,(int)file->rdev);
       if (do_mknod(fname,file->mode,file->rdev) != 0) {
-	fprintf(FERROR,"mknod %s : %s\n",fname,strerror(errno));
+	rprintf(FERROR,"mknod %s : %s\n",fname,strerror(errno));
       } else {
 	set_perms(fname,file,NULL,0);
 	if (verbose)
-	  fprintf(FINFO,"%s\n",fname);
+	  rprintf(FINFO,"%s\n",fname);
       }
     } else {
       set_perms(fname,file,&st,1);
     }
     return;
   }
 #endif
 
   if (preserve_hard_links && check_hard_link(file)) {
     if (verbose > 1)
-      fprintf(FINFO,"%s is a hard link\n",f_name(file));
+      rprintf(FINFO,"%s is a hard link\n",f_name(file));
     return;
   }
 
   if (!S_ISREG(file->mode)) {
-    fprintf(FINFO,"skipping non-regular file %s\n",fname);
+    rprintf(FINFO,"skipping non-regular file %s\n",fname);
     return;
   }
 
   if (statret == -1) {
     if (errno == ENOENT) {
       write_int(f_out,i);
       if (!dry_run) send_sums(NULL,f_out);
     } else {
       if (verbose > 1)
-	fprintf(FERROR,"recv_generator failed to open %s\n",fname);
+	rprintf(FERROR,"recv_generator failed to open %s\n",fname);
     }
     return;
   }
 
   if (!S_ISREG(st.st_mode)) {
     if (delete_file(fname) != 0) {
@@ -480,13 +481,13 @@
     if (!dry_run) send_sums(NULL,f_out);    
     return;
   }
 
   if (update_only && st.st_mtime > file->modtime) {
     if (verbose > 1)
-      fprintf(FINFO,"%s is newer\n",fname);
+      rprintf(FINFO,"%s is newer\n",fname);
     return;
   }
 
   if (skip_file(fname, file, &st)) {
     set_perms(fname,file,&st,1);
     return;
@@ -504,30 +505,30 @@
   }
 
   /* open the file */  
   fd = open(fname,O_RDONLY);
 
   if (fd == -1) {
-    fprintf(FERROR,"failed to open %s : %s\n",fname,strerror(errno));
-    fprintf(FERROR,"skipping %s\n",fname);
+    rprintf(FERROR,"failed to open %s : %s\n",fname,strerror(errno));
+    rprintf(FERROR,"skipping %s\n",fname);
     return;
   }
 
   if (st.st_size > 0) {
     buf = map_file(fd,st.st_size);
   } else {
     buf = NULL;
   }
 
   if (verbose > 3)
-    fprintf(FINFO,"gen mapped %s of size %d\n",fname,(int)st.st_size);
+    rprintf(FINFO,"gen mapped %s of size %d\n",fname,(int)st.st_size);
 
   s = generate_sums(buf,st.st_size,adapt_block_size(file, block_size));
 
   if (verbose > 2)
-    fprintf(FINFO,"sending sums for %d\n",i);
+    rprintf(FINFO,"sending sums for %d\n",i);
 
   write_int(f_out,i);
   send_sums(s,f_out);
   write_flush(f_out);
 
   close(fd);
@@ -538,14 +539,14 @@
 
 
 
 static int receive_data(int f_in,struct map_struct *buf,int fd,char *fname)
 {
   int i,n,remainder,len,count;
-  off_t offset = 0;
-  off_t offset2;
+  OFF_T offset = 0;
+  OFF_T offset2;
   char *data;
   static char file_sum1[MD4_SUM_LENGTH];
   static char file_sum2[MD4_SUM_LENGTH];
   char *map=NULL;
 
   count = read_int(f_in);
@@ -554,77 +555,77 @@
 
   sum_init();
 
   for (i=recv_token(f_in,&data); i != 0; i=recv_token(f_in,&data)) {
     if (i > 0) {
       if (verbose > 3)
-	fprintf(FINFO,"data recv %d at %d\n",i,(int)offset);
+	rprintf(FINFO,"data recv %d at %d\n",i,(int)offset);
 
       sum_update(data,i);
 
       if (fd != -1 && write_file(fd,data,i) != i) {
-	fprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
+	rprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
 	exit_cleanup(1);
       }
       offset += i;
     } else {
       i = -(i+1);
       offset2 = i*n;
       len = n;
       if (i == count-1 && remainder != 0)
 	len = remainder;
 
       if (verbose > 3)
-	fprintf(FINFO,"chunk[%d] of size %d at %d offset=%d\n",
+	rprintf(FINFO,"chunk[%d] of size %d at %d offset=%d\n",
 		i,len,(int)offset2,(int)offset);
 
       map = map_ptr(buf,offset2,len);
 
       see_token(map, len);
       sum_update(map,len);
 
       if (fd != -1 && write_file(fd,map,len) != len) {
-	fprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
+	rprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
 	exit_cleanup(1);
       }
       offset += len;
     }
   }
 
   if (fd != -1 && offset > 0 && sparse_end(fd) != 0) {
-    fprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
+    rprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
     exit_cleanup(1);
   }
 
   sum_end(file_sum1);
 
   if (remote_version >= 14) {
     read_buf(f_in,file_sum2,MD4_SUM_LENGTH);
     if (verbose > 2)
-      fprintf(FINFO,"got file_sum\n");
+      rprintf(FINFO,"got file_sum\n");
     if (fd != -1 && memcmp(file_sum1,file_sum2,MD4_SUM_LENGTH) != 0)
       return 0;
   }
   return 1;
 }
 
 
 static void delete_one(struct file_struct *f)
 {
   if (!S_ISDIR(f->mode)) {
     if (do_unlink(f_name(f)) != 0) {
-      fprintf(FERROR,"unlink %s : %s\n",f_name(f),strerror(errno));
+      rprintf(FERROR,"unlink %s : %s\n",f_name(f),strerror(errno));
     } else if (verbose) {
-      fprintf(FINFO,"deleting %s\n",f_name(f));
+      rprintf(FINFO,"deleting %s\n",f_name(f));
     }
   } else {    
     if (do_rmdir(f_name(f)) != 0) {
       if (errno != ENOTEMPTY && errno != EEXIST)
-	fprintf(FERROR,"rmdir %s : %s\n",f_name(f),strerror(errno));
+	rprintf(FERROR,"rmdir %s : %s\n",f_name(f),strerror(errno));
     } else if (verbose) {
-      fprintf(FINFO,"deleting directory %s\n",f_name(f));      
+      rprintf(FINFO,"deleting directory %s\n",f_name(f));      
     }
   }
 }
 
 
 
@@ -648,23 +649,23 @@
 
 	delete_list[dlist_len].dev = file->dev;
 	delete_list[dlist_len].inode = file->inode;
 	dlist_len++;
 
 	if (verbose > 3)
-		fprintf(FINFO,"added %s to delete list\n", f_name(file));
+		rprintf(FINFO,"added %s to delete list\n", f_name(file));
 }
 
 /* yuck! This function wouldn't have been necessary if I had the sorting
    algorithm right. Unfortunately fixing the sorting algorithm would introduce
    a backward incompatibility as file list indexes are sent over the link.
 */
 static int delete_already_done(struct file_list *flist,int j)
 {
 	int i;
-	struct stat st;
+	STRUCT_STAT st;
 
 	if (link_stat(f_name(flist->files[j]), &st)) return 1;
 
 	for (i=0;i<dlist_len;i++) {
 		if (st.st_ino == delete_list[i].inode &&
 		    st.st_dev == delete_list[i].dev)
@@ -685,13 +686,13 @@
 	char *name;
 
 	if (cvs_exclude)
 		add_cvs_excludes();
 
 	if (io_error) {
-		fprintf(FINFO,"IO error encountered - skipping file deletion\n");
+		rprintf(FINFO,"IO error encountered - skipping file deletion\n");
 		return;
 	}
 
 	for (j=0;j<flist->count;j++) {
 		if (!S_ISDIR(flist->files[j]->mode) || 
 		    !(flist->files[j]->flags & FLAG_DELETE)) continue;
@@ -703,13 +704,13 @@
 		if (!(local_file_list = send_file_list(-1,1,&name))) {
 			free(name);
 			continue;
 		}
 
 		if (verbose > 1)
-			fprintf(FINFO,"deleting in %s\n", name);
+			rprintf(FINFO,"deleting in %s\n", name);
 
 		for (i=local_file_list->count-1;i>=0;i--) {
 			if (!local_file_list->files[i]->basename) continue;
 			if (S_ISDIR(local_file_list->files[i]->mode))
 				add_delete_entry(local_file_list->files[i]);
 			if (-1 == flist_find(flist,local_file_list->files[i])) {
@@ -740,23 +741,23 @@
 }
 
 
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen)
 {  
   int fd1,fd2;
-  struct stat st;
+  STRUCT_STAT st;
   char *fname;
   char fnametmp[MAXPATHLEN];
   struct map_struct *buf;
   int i;
   struct file_struct *file;
   int phase=0;
   int recv_ok;
 
   if (verbose > 2) {
-    fprintf(FINFO,"recv_files(%d) starting\n",flist->count);
+    rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
   }
 
   if (recurse && delete_mode && !local_name && flist->count>0) {
     delete_files(flist);
   }
 
@@ -765,13 +766,13 @@
       i = read_int(f_in);
       if (i == -1) {
 	if (phase==0 && remote_version >= 13) {
 	  phase++;
 	  csum_length = SUM_LENGTH;
 	  if (verbose > 2)
-	    fprintf(FINFO,"recv_files phase=%d\n",phase);
+	    rprintf(FINFO,"recv_files phase=%d\n",phase);
 	  write_int(f_gen,-1);
 	  write_flush(f_gen);
 	  continue;
 	}
 	break;
       }
@@ -786,71 +787,86 @@
 	if (!am_server && verbose)
 	  printf("%s\n",fname);
 	continue;
       }
 
       if (verbose > 2)
-	fprintf(FINFO,"recv_files(%s)\n",fname);
+	rprintf(FINFO,"recv_files(%s)\n",fname);
 
       /* open the file */  
       fd1 = open(fname,O_RDONLY);
 
-      if (fd1 != -1 && fstat(fd1,&st) != 0) {
-	fprintf(FERROR,"fstat %s : %s\n",fname,strerror(errno));
+      if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
+	rprintf(FERROR,"fstat %s : %s\n",fname,strerror(errno));
 	receive_data(f_in,NULL,-1,NULL);
 	close(fd1);
 	continue;
       }
 
       if (fd1 != -1 && !S_ISREG(st.st_mode)) {
-	fprintf(FERROR,"%s : not a regular file (recv_files)\n",fname);
+	rprintf(FERROR,"%s : not a regular file (recv_files)\n",fname);
 	receive_data(f_in,NULL,-1,NULL);
 	close(fd1);
 	continue;
       }
 
       if (fd1 != -1 && st.st_size > 0) {
 	buf = map_file(fd1,st.st_size);
 	if (verbose > 2)
-	  fprintf(FINFO,"recv mapped %s of size %d\n",fname,(int)st.st_size);
+	  rprintf(FINFO,"recv mapped %s of size %d\n",fname,(int)st.st_size);
       } else {
 	buf = NULL;
       }
 
       /* open tmp file */
-      if (strlen(fname) > (MAXPATHLEN-8)) {
-	fprintf(FERROR,"filename too long\n");
-	if (buf) unmap_file(buf);
-	close(fd1);
-	continue;
-      }
       if (tmpdir) {
 	      char *f;
 	      f = strrchr(fname,'/');
 	      if (f == NULL) 
 		      f = fname;
 	      else 
 		      f++;
-	      sprintf(fnametmp,"%s/%s.XXXXXX",tmpdir,f);
+	      if (strlen(tmpdir)+strlen(f)+10 > MAXPATHLEN) {
+		      rprintf(FERROR,"filename too long\n");
+		      if (buf) unmap_file(buf);
+		      close(fd1);
+		      continue;
+	      }
+	      sprintf(fnametmp,"%s/.%s.XXXXXX",tmpdir,f);
       } else {
-	      sprintf(fnametmp,"%s.XXXXXX",fname);
+	      char *f = strrchr(fname,'/');
+
+	      if (strlen(fname)+9 > MAXPATHLEN) {
+		      rprintf(FERROR,"filename too long\n");
+		      if (buf) unmap_file(buf);
+		      close(fd1);
+		      continue;
+	      }
+
+	      if (f) {
+		      *f = 0;
+		      sprintf(fnametmp,"%s/.%s.XXXXXX",fname,f+1);
+		      *f = '/';
+	      } else {
+		      sprintf(fnametmp,".%s.XXXXXX",fname);
+	      }
       }
       if (NULL == do_mktemp(fnametmp)) {
-	fprintf(FERROR,"mktemp %s failed\n",fnametmp);
+	rprintf(FERROR,"mktemp %s failed\n",fnametmp);
 	receive_data(f_in,buf,-1,NULL);
 	if (buf) unmap_file(buf);
 	close(fd1);
 	continue;
       }
       fd2 = do_open(fnametmp,O_WRONLY|O_CREAT|O_EXCL,file->mode);
       if (fd2 == -1 && relative_paths && errno == ENOENT && 
 	  create_directory_path(fnametmp) == 0) {
 	      fd2 = do_open(fnametmp,O_WRONLY|O_CREAT|O_EXCL,file->mode);
       }
       if (fd2 == -1) {
-	fprintf(FERROR,"open %s : %s\n",fnametmp,strerror(errno));
+	rprintf(FERROR,"open %s : %s\n",fnametmp,strerror(errno));
 	receive_data(f_in,buf,-1,NULL);
 	if (buf) unmap_file(buf);
 	close(fd1);
 	continue;
       }
       
@@ -866,58 +882,58 @@
       if (fd1 != -1) {
 	close(fd1);
       }
       close(fd2);
 
       if (verbose > 2)
-	fprintf(FINFO,"renaming %s to %s\n",fnametmp,fname);
+	rprintf(FINFO,"renaming %s to %s\n",fnametmp,fname);
 
       if (make_backups) {
 	char fnamebak[MAXPATHLEN];
 	if (strlen(fname) + strlen(backup_suffix) > (MAXPATHLEN-1)) {
-		fprintf(FERROR,"backup filename too long\n");
+		rprintf(FERROR,"backup filename too long\n");
 		continue;
 	}
 	sprintf(fnamebak,"%s%s",fname,backup_suffix);
 	if (do_rename(fname,fnamebak) != 0 && errno != ENOENT) {
-	  fprintf(FERROR,"rename %s %s : %s\n",fname,fnamebak,strerror(errno));
+	  rprintf(FERROR,"rename %s %s : %s\n",fname,fnamebak,strerror(errno));
 	  continue;
 	}
       }
 
       /* move tmp file over real file */
       if (do_rename(fnametmp,fname) != 0) {
 	      if (errno == EXDEV) {
 		      /* rename failed on cross-filesystem link.  
 			 Copy the file instead. */
 		      if (copy_file(fnametmp,fname, file->mode)) {
-			      fprintf(FERROR,"copy %s -> %s : %s\n",
+			      rprintf(FERROR,"copy %s -> %s : %s\n",
 				      fnametmp,fname,strerror(errno));
 		      } else {
 			      set_perms(fname,file,NULL,0);
 		      }
 		      do_unlink(fnametmp);
 	      } else {
-		      fprintf(FERROR,"rename %s -> %s : %s\n",
+		      rprintf(FERROR,"rename %s -> %s : %s\n",
 			      fnametmp,fname,strerror(errno));
 		      do_unlink(fnametmp);
 	      }
       } else {
 	      set_perms(fname,file,NULL,0);
       }
 
       cleanup_fname = NULL;
 
 
       if (!recv_ok) {
 	      if (csum_length == SUM_LENGTH) {
-		      fprintf(FERROR,"ERROR: file corruption in %s. File changed during transfer?\n",
+		      rprintf(FERROR,"ERROR: file corruption in %s. File changed during transfer?\n",
 			      fname);
 	      } else {
 		      if (verbose > 1)
-			      fprintf(FINFO,"redoing %s(%d)\n",fname,i);
+			      rprintf(FINFO,"redoing %s(%d)\n",fname,i);
 		      write_int(f_gen,i);
 	      }
       }
     }
 
   if (preserve_hard_links)
@@ -929,121 +945,120 @@
 	  struct file_struct *file = flist->files[i];
 	  if (!file->basename || !S_ISDIR(file->mode)) continue;
 	  recv_generator(f_name(file),flist,i,-1);
   }
 
   if (verbose > 2)
-    fprintf(FINFO,"recv_files finished\n");
+    rprintf(FINFO,"recv_files finished\n");
   
   return 0;
 }
 
 
 
 void send_files(struct file_list *flist,int f_out,int f_in)
 { 
   int fd;
   struct sum_struct *s;
   struct map_struct *buf;
-  struct stat st;
+  STRUCT_STAT st;
   char fname[MAXPATHLEN];  
   int i;
   struct file_struct *file;
   int phase = 0;
   int offset=0;
 
   if (verbose > 2)
-    fprintf(FINFO,"send_files starting\n");
+    rprintf(FINFO,"send_files starting\n");
 
   setup_nonblocking(f_in,f_out);
 
   while (1) {
 	  i = read_int(f_in);
 	  if (i == -1) {
 		  if (phase==0 && remote_version >= 13) {
 			  phase++;
 			  csum_length = SUM_LENGTH;
 			  write_int(f_out,-1);
 			  write_flush(f_out);
 			  if (verbose > 2)
-				  fprintf(FINFO,"send_files phase=%d\n",phase);
+				  rprintf(FINFO,"send_files phase=%d\n",phase);
 			  continue;
 		  }
 		  break;
 	  }
 
 	  file = flist->files[i];
 
 	  fname[0] = 0;
 	  if (file->basedir) {
-		  strncpy(fname,file->basedir,MAXPATHLEN-1);
-		  fname[MAXPATHLEN-1] = 0;
+		  strlcpy(fname,file->basedir,MAXPATHLEN-1);
 		  if (strlen(fname) == MAXPATHLEN-1) {
 			  io_error = 1;
-			  fprintf(FERROR, "send_files failed on long-named directory %s\n",
+			  rprintf(FERROR, "send_files failed on long-named directory %s\n",
 				  fname);
 			  return;
 		  }
 		  strcat(fname,"/");
 		  offset = strlen(file->basedir)+1;
 	  }
 	  strncat(fname,f_name(file),MAXPATHLEN-strlen(fname));
 	  
 	  if (verbose > 2) 
-		  fprintf(FINFO,"send_files(%d,%s)\n",i,fname);
+		  rprintf(FINFO,"send_files(%d,%s)\n",i,fname);
 	  
 	  if (dry_run) {	
 		  if (!am_server && verbose)
 			  printf("%s\n",fname);
 		  write_int(f_out,i);
 		  continue;
 	  }
 
 	  s = receive_sums(f_in);
 	  if (!s) {
 		  io_error = 1;
-		  fprintf(FERROR,"receive_sums failed\n");
+		  rprintf(FERROR,"receive_sums failed\n");
 		  return;
 	  }
 	  
 	  fd = open(fname,O_RDONLY);
 	  if (fd == -1) {
 		  io_error = 1;
-		  fprintf(FERROR,"send_files failed to open %s: %s\n",
+		  rprintf(FERROR,"send_files failed to open %s: %s\n",
 			  fname,strerror(errno));
 		  free_sums(s);
 		  continue;
 	  }
 	  
 	  /* map the local file */
-	  if (fstat(fd,&st) != 0) {
+	  if (do_fstat(fd,&st) != 0) {
 		  io_error = 1;
-		  fprintf(FERROR,"fstat failed : %s\n",strerror(errno));
+		  rprintf(FERROR,"fstat failed : %s\n",strerror(errno));
 		  free_sums(s);
 		  close(fd);
 		  return;
 	  }
 	  
 	  if (st.st_size > 0) {
 		  buf = map_file(fd,st.st_size);
 	  } else {
 		  buf = NULL;
 	  }
 	  
 	  if (verbose > 2)
-		  fprintf(FINFO,"send_files mapped %s of size %d\n",
+		  rprintf(FINFO,"send_files mapped %s of size %d\n",
 			  fname,(int)st.st_size);
 	  
 	  write_int(f_out,i);
 	  
 	  write_int(f_out,s->count);
 	  write_int(f_out,s->n);
 	  write_int(f_out,s->remainder);
 	  
 	  if (verbose > 2)
-		  fprintf(FINFO,"calling match_sums %s\n",fname);
+		  rprintf(FINFO,"calling match_sums %s\n",fname);
 	  
 	  if (!am_server && verbose)
 		  printf("%s\n",fname+offset);
 	  
 	  match_sums(f_out,s,buf,st.st_size);
 	  write_flush(f_out);
@@ -1051,17 +1066,17 @@
 	  if (buf) unmap_file(buf);
 	  close(fd);
 	  
 	  free_sums(s);
 	  
 	  if (verbose > 2)
-		  fprintf(FINFO,"sender finished %s\n",fname);
+		  rprintf(FINFO,"sender finished %s\n",fname);
   }
 
   if (verbose > 2)
-	  fprintf(FINFO,"send files finished\n");
+	  rprintf(FINFO,"send files finished\n");
 
   match_report();
 
   write_int(f_out,-1);
   write_flush(f_out);
 }
@@ -1071,13 +1086,13 @@
 void generate_files(int f,struct file_list *flist,char *local_name,int f_recv)
 {
   int i;
   int phase=0;
 
   if (verbose > 2)
-    fprintf(FINFO,"generator starting pid=%d count=%d\n",
+    rprintf(FINFO,"generator starting pid=%d count=%d\n",
 	    (int)getpid(),flist->count);
 
   for (i = 0; i < flist->count; i++) {
     struct file_struct *file = flist->files[i];
     mode_t saved_mode = file->mode;
     if (!file->basename) continue;
@@ -1097,13 +1112,13 @@
 
   phase++;
   csum_length = SUM_LENGTH;
   ignore_times=1;
 
   if (verbose > 2)
-    fprintf(FINFO,"generate_files phase=%d\n",phase);
+    rprintf(FINFO,"generate_files phase=%d\n",phase);
 
   write_int(f,-1);
   write_flush(f);
 
   /* we expect to just sit around now, so don't exit on a timeout. If we
      really get a timeout then the other process should exit */
@@ -1117,18 +1132,18 @@
       recv_generator(local_name?local_name:f_name(file),
 		     flist,i,f);    
     }
 
     phase++;
     if (verbose > 2)
-      fprintf(FINFO,"generate_files phase=%d\n",phase);
+      rprintf(FINFO,"generate_files phase=%d\n",phase);
 
     write_int(f,-1);
     write_flush(f);
   }
 
 
   if (verbose > 2)
-    fprintf(FINFO,"generator wrote %ld\n",(long)write_total());
+    rprintf(FINFO,"generator wrote %ld\n",(long)write_total());
 }
 
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: rsyncd.conf.5
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: rsyncd.conf.yo
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/rsync.h	1998-04-17 14:48:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/rsync.h	1998-05-14 15:07:51.000000000 +0800
@@ -18,12 +18,14 @@
 */
 
 #define BLOCK_SIZE 700
 #define RSYNC_RSH_ENV "RSYNC_RSH"
 
 #define RSYNC_NAME "rsync"
+#define RSYNCD_CONF "/etc/rsyncd.conf"
+
 #define BACKUP_SUFFIX "~"
 
 /* a non-zero CHAR_OFFSET makes the rolling sum stronger, but is
    imcompatible with older versions :-( */
 #define CHAR_OFFSET 0
 
@@ -40,21 +42,25 @@
 
 /* update this if you make incompatible changes */
 #define PROTOCOL_VERSION 17
 #define MIN_PROTOCOL_VERSION 11
 #define MAX_PROTOCOL_VERSION 30
 
+#define RSYNC_PORT 873
+
 #define SPARSE_WRITE_SIZE (1024)
 #define WRITE_SIZE (32*1024)
 #define CHUNK_SIZE (32*1024)
 #define MAX_MAP_SIZE (4*1024*1024)
 
+#define MAX_ARGS 1000
+
 #define BLOCKING_TIMEOUT 10
 
-#define FERROR stderr
-#define FINFO (am_server?stderr:stdout)
+#define FERROR 1
+#define FINFO 2
 
 #include "config.h"
 
 #if HAVE_REMSH
 #define RSYNC_RSH "remsh"
 #else
@@ -63,12 +69,13 @@
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <stdio.h>
+#include <stddef.h>
 
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
 
 #ifdef HAVE_STDLIB_H
@@ -160,28 +167,47 @@
 #ifdef HAVE_GETOPT_LONG
 #include <getopt.h>
 #else
 #include "lib/getopt.h"
 #endif
 
+#ifdef HAVE_GLOB
+#include <glob.h>
+#endif
+
 /* these are needed for the uid/gid mapping code */
 #include <pwd.h>
 #include <grp.h>
 
+#include <stdarg.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <syslog.h>
+#include <sys/file.h>
+
 #ifndef S_IFLNK
 #define S_IFLNK  0120000
 #endif
 
 #ifndef S_ISLNK
 #define S_ISLNK(mode) (((mode) & S_IFLNK) == S_IFLNK)
 #endif
 
+#define BOOL int
+
 #ifndef uchar
 #define uchar unsigned char
 #endif
 
+#if HAVE_UNSIGNED_CHAR
+#define schar signed char
+#else
+#define schar char
+#endif
+
 #ifndef int32
 #if (SIZEOF_INT == 4)
 #define int32 int
 #elif (SIZEOF_LONG == 4)
 #define int32 long
 #elif (SIZEOF_SHORT == 4)
@@ -190,16 +216,31 @@
 #endif
 
 #ifndef uint32
 #define uint32 unsigned int32
 #endif
 
-#ifdef HAVE_LONGLONG
+#if HAVE_OFF64_T
+#define OFF_T off64_t
+#define STRUCT_STAT struct stat64
+#else
+#define OFF_T off_t
+#define STRUCT_STAT struct stat
+#endif
+
+#if HAVE_OFF64_T
+#define int64 off64_t
+#elif (SIZEOF_LONG == 8) 
+#define int64 long
+#elif (SIZEOF_INT == 8) 
+#define int64 int
+#elif HAVE_LONGLONG
 #define int64 long long
 #else
 #define int64 off_t
+#define NO_INT64
 #endif
 
 #ifndef MIN
 #define MIN(a,b) ((a)<(b)?(a):(b))
 #endif
 
@@ -212,16 +253,20 @@
 #define SUM_LENGTH 16
 
 #ifndef MAXPATHLEN
 #define MAXPATHLEN 1024
 #endif
 
+#ifndef INADDR_NONE
+#define INADDR_NONE 0xffffffff
+#endif
+
 struct file_struct {
 	unsigned flags;
 	time_t modtime;
-	off_t length;
+	OFF_T length;
 	mode_t mode;
 	ino_t inode;
 	dev_t dev;
 	dev_t rdev;
 	uid_t uid;
 	gid_t gid;
@@ -236,42 +281,56 @@
   int count;
   int malloced;
   struct file_struct **files;
 };
 
 struct sum_buf {
-  off_t offset;			/* offset in file of this chunk */
+  OFF_T offset;			/* offset in file of this chunk */
   int len;			/* length of chunk of file */
   int i;			/* index of this chunk */
   uint32 sum1;	                /* simple checksum */
   char sum2[SUM_LENGTH];	/* checksum  */
 };
 
 struct sum_struct {
-  off_t flength;		/* total file length */
+  OFF_T flength;		/* total file length */
   int count;			/* how many chunks */
   int remainder;		/* flength % block_length */
   int n;			/* block_length */
   struct sum_buf *sums;		/* points to info for each chunk */
 };
 
 struct map_struct {
 	char *map,*p;
 	int fd,p_size,p_len;
-	off_t size, p_offset;
+	OFF_T size, p_offset;
 };
 
 /* we need this function because of the silly way in which duplicate
    entries are handled in the file lists - we can't change this
    without breaking existing versions */
 static inline int flist_up(struct file_list *flist, int i)
 {
 	while (!flist->files[i]->basename) i++;
 	return i;
 }
 
+#if HAVE_DIRENT_H
+# include <dirent.h>
+#else
+# define dirent direct
+# if HAVE_SYS_NDIR_H
+#  include <sys/ndir.h>
+# endif
+# if HAVE_SYS_DIR_H
+#  include <sys/dir.h>
+# endif
+# if HAVE_NDIR_H
+#  include <ndir.h>
+# endif
+#endif
 
 #include "byteorder.h"
 #include "version.h"
 #include "proto.h"
 #include "md4.h"
 
@@ -282,27 +341,12 @@
 
 #ifndef HAVE_STRCHR
 # define strchr                 index
 # define strrchr                rindex
 #endif
 
-#if HAVE_DIRENT_H
-# include <dirent.h>
-#else
-# define dirent direct
-# if HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif
-# if HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif
-# if HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-#endif
-
 #ifndef HAVE_ERRNO_DECL
 extern int errno;
 #endif
 
 #ifndef HAVE_BCOPY
 #define bcopy(src,dest,n) memcpy(dest,src,n)
@@ -346,16 +390,33 @@
 #endif
 
 #ifndef S_ISCHR
 #define S_ISCHR(mode) (((mode) & (_S_IFMT)) == (_S_IFCHR))
 #endif
 
+#ifndef S_ISSOCK
+#ifdef _S_IFSOCK
+#define S_ISSOCK(mode) (((mode) & (_S_IFMT)) == (_S_IFSOCK))
+#else
+#define S_ISSOCK(mode) (0)
+#endif
+#endif
+
+#ifndef S_ISFIFO
+#ifdef _S_IFIFO
+#define S_ISFIFO(mode) (((mode) & (_S_IFMT)) == (_S_IFIFO))
+#else
+#define S_ISFIFO(mode) (0)
+#endif
+#endif
+
 #ifndef S_ISDIR
 #define S_ISDIR(mode) (((mode) & (_S_IFMT)) == (_S_IFDIR))
 #endif
 
 #ifndef S_ISREG
 #define S_ISREG(mode) (((mode) & (_S_IFMT)) == (_S_IFREG))
 #endif
 
-#define IS_DEVICE(mode) (S_ISCHR(mode) || S_ISBLK(mode))
+
+#define IS_DEVICE(mode) (S_ISCHR(mode) || S_ISBLK(mode) || S_ISSOCK(mode) || S_ISFIFO(mode))
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: rsync.yo
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0: socket.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/syscall.c	1998-04-05 14:45:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/syscall.c	1998-05-14 15:07:51.000000000 +0800
@@ -20,78 +20,140 @@
   syscall wrappers to ensure that nothing gets done in dry_run mode
   */
 
 #include "rsync.h"
 
 extern int dry_run;
+extern int read_only;
+
+#define CHECK_RO if (read_only) {errno = EROFS; return -1;}
 
 int do_unlink(char *fname)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return unlink(fname);
 }
 
 int do_symlink(char *fname1, char *fname2)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return symlink(fname1, fname2);
 }
 
 #if HAVE_LINK
 int do_link(char *fname1, char *fname2)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return link(fname1, fname2);
 }
 #endif
 
 int do_lchown(const char *path, uid_t owner, gid_t group)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return lchown(path, owner, group);
 }
 
 #if HAVE_MKNOD
 int do_mknod(char *pathname, mode_t mode, dev_t dev)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return mknod(pathname, mode, dev);
 }
 #endif
 
 int do_rmdir(char *pathname)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return rmdir(pathname);
 }
 
 int do_open(char *pathname, int flags, mode_t mode)
 {
 	if (dry_run) return -1;
+	CHECK_RO
 	return open(pathname, flags, mode);
 }
 
 #if HAVE_CHMOD
 int do_chmod(const char *path, mode_t mode)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return chmod(path, mode);
 }
 #endif
 
 int do_rename(char *fname1, char *fname2)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return rename(fname1, fname2);
 }
 
 int do_mkdir(char *fname, mode_t mode)
 {
 	if (dry_run) return 0;
+	CHECK_RO
 	return mkdir(fname, mode);
 }
 
 char *do_mktemp(char *template)
 {
 	if (dry_run) return NULL;
+	if (read_only) {errno = EROFS; return NULL;}
 	return mktemp(template);
 }
+
+int do_stat(const char *fname, STRUCT_STAT *st)
+{
+#if HAVE_OFF64_T
+	return stat64(fname, st);
+#else
+	return stat(fname, st);
+#endif
+}
+
+#if SUPPORT_LINKS
+int do_lstat(const char *fname, STRUCT_STAT *st)
+{
+#if HAVE_OFF64_T
+	return lstat64(fname, st);
+#else
+	return lstat(fname, st);
+#endif
+}
+#endif
+
+int do_fstat(int fd, STRUCT_STAT *st)
+{
+#if HAVE_OFF64_T
+	return fstat64(fd, st);
+#else
+	return fstat(fd, st);
+#endif
+}
+
+OFF_T do_lseek(int fd, OFF_T offset, int whence)
+{
+#if HAVE_OFF64_T
+	off64_t lseek64();
+	return lseek64(fd, offset, whence);
+#else
+	return lseek(fd, offset, whence);
+#endif
+}
+
+char *d_name(struct dirent *di)
+{
+#if HAVE_BROKEN_READDIR
+	return (di->d_name - 2);
+#else
+	return di->d_name;
+#endif
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/test.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/test.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/test.sh	1998-04-17 14:08:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/test.sh	1998-05-14 15:07:52.000000000 +0800
@@ -1,54 +1,116 @@
-#!/bin/sh -e 
+#!/bin/sh
+
+#
+# Copyright (C) 1998 Philip Hands <http://www.hands.com/~phil/>
+#
+# This program is distributable under the terms of the GNU GPL (see COPYING)
+#
 # This is a simple test script that tests a few rsync
-# features to make sure I haven't broken them before a release. Thanks
-# to Phil Hands for writing this
+# features to make sure I haven't broken them before a release.
+#
+#
 
 export PATH=.:$PATH
 TMP=/tmp/rsync-test.$$
-F1=README
+FROM=${TMP}/from
+TO=${TMP}/to
+F1=text1
+LOG=${TMP}/log
 
 mkdir $TMP
+mkdir $FROM
+mkdir $TO
+
+# set up test data
+touch ${FROM}/empty
+mkdir ${FROM}/emptydir
+ps ax > ${FROM}/pslist
+echo -n "This file has no trailing lf" > ${FROM}/nolf
+ln -s nolf ${FROM}/nolf-symlink
+cat /etc/inittab /etc/services /etc/resolv.conf > ${FROM}/${F1}
+mkdir ${FROM}/dir
+cp ${FROM}/${F1} ${FROM}/dir
+
+checkit() {
+  echo -n "Test $4: $5:"
+  log=${LOG}.$4
+  failed=
+  echo "Running: \"$1\""  >${log}
+  echo "">>${log}
+  eval "$1 || failed=YES"  >>${log} 2>&1
+
+  echo "-------------">>${log}
+  echo "check how the files compare with diff:">>${log}
+  echo "">>${log}
+  diff -ur $2 $3 >>${log} || failed=YES
+  echo "-------------">>${log}
+  echo "check how the directory listings compare with diff:">>${log}
+  echo "">>${log}
+  ls -la $2 > ${TMP}/ls-from
+  ls -la $3 > ${TMP}/ls-to
+  diff -u ${TMP}/ls-from ${TMP}/ls-to >>${log} || failed=YES
+  if [ -z "${failed}" ] ; then
+    echo "	done."
+    rm $log
+  else
+    echo "	FAILED."
+  fi
+}
 
-pause() {
-    echo ... press enter to continue
-    read
+checkforlogs() {
+  if [ -f $1 ] ; then
+    cat <<EOF
+
+Failures have occured.
+
+You can find the output of the tests in these files:
+  $@
+
+Please hit <RETURN>
+EOF
+  read input
+  else
+
+    rm -rf ${TMP}
+    echo ""
+    echo "Tests Completed Successfully :-)"
+  fi
 }
 
-echo "Test 1 basic operation"
-rsync -av testin/ ${TMP}/rsync
-diff -ur testin/ ${TMP}/rsync
-pause
-
-echo "Test 2 - one file"
-rm ${TMP}/rsync/${F1}
-rsync -av testin/ ${TMP}/rsync
-diff -ur testin/ ${TMP}/rsync
-pause
-
-echo "Test 3 - extra data"
-echo "extra line" >> ${TMP}/rsync/${F1}
-rsync -av testin/ ${TMP}/rsync
-diff -ur testin/ ${TMP}/rsync
-pause
-
-echo "Test 4 - --delete"
-cp testin/${F1} ${TMP}/rsync/f1
-rsync --delete -av testin/ ${TMP}/rsync
-diff -ur testin/ ${TMP}/rsync
-pause
-
-echo "Test 5 (uses ssh, so will fail if you don't have it) "
-rm -rf ${TMP}/rsync
-rsync -av -e ssh testin/ localhost:${TMP}/rsync
-diff -ur testin/ ${TMP}/rsync
-pause
-
-echo "Test 6 (uses ssh, so will fail if you don't have it) "
-mv ${TMP}/rsync/${F1} ${TMP}/rsync/f1
-rsync --delete -av -e ssh testin/ localhost:${TMP}/rsync
-diff -ur testin/ ${TMP}/rsync
-pause
+# Main script starts here
+
+checkit "rsync -av ${FROM}/ ${TO}" ${FROM}/ ${TO} \
+  1 "basic operation"
+
+ln ${FROM}/pslist ${FROM}/dir
+checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
+  2 "hard links"
+
+rm ${TO}/${F1}
+checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
+  3 "one file"
+
+echo "extra line" >> ${TO}/${F1}
+checkit "rsync -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
+  4 "extra data"
+
+cp ${FROM}/${F1} ${TO}/ThisShouldGo
+checkit "rsync --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO} \
+  5 " --delete"
+
+if type ssh >/dev/null ; then
+rm -rf ${TO}
+  checkit "rsync -avH -e ssh ${FROM}/ localhost:${TO}" ${FROM}/ ${TO} \
+    6 "ssh: basic test"
+
+  mv ${TO}/${F1} ${TO}/ThisShouldGo
+  checkit "rsync --delete -avH -e ssh ${FROM}/ localhost:${TO}" ${FROM}/ ${TO}\
+    7 "ssh: renamed file"
+else
+  echo ""
+  echo "**** Skipping SSH tests because ssh is not in the path ****"
+  echo ""
+fi
 
-rm -rf ${TMP}
+checkforlogs ${LOG}.?
 
-echo Tests Completed
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/token.c	1998-03-26 12:51:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/token.c	1998-05-14 15:07:52.000000000 +0800
@@ -114,13 +114,13 @@
 	if (!init_done) {
 	    tx_strm.next_in = NULL;
 	    tx_strm.zalloc = z_alloc;
 	    tx_strm.zfree = z_free;
 	    if (deflateInit2(&tx_strm, Z_DEFAULT_COMPRESSION, 8,
 			     -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
-		fprintf(FERROR, "compression init failed\n");
+		rprintf(FERROR, "compression init failed\n");
 		exit_cleanup(1);
 	    }
 	    if ((obuf = malloc(MAX_DATA_COUNT+2)) == NULL)
 		out_of_memory("send_deflated_token");
 	    init_done = 1;
 	} else
@@ -165,13 +165,13 @@
 	    if (tx_strm.avail_out == 0) {
 		tx_strm.next_out = (Bytef *)(obuf + 2);
 		tx_strm.avail_out = MAX_DATA_COUNT;
 	    }
 	    r = deflate(&tx_strm, nb? Z_NO_FLUSH: Z_PACKET_FLUSH);
 	    if (r != Z_OK) {
-		fprintf(FERROR, "deflate returned %d\n", r);
+		rprintf(FERROR, "deflate returned %d\n", r);
 		exit_cleanup(1);
 	    }
 	    if (nb == 0 || tx_strm.avail_out == 0) {
 		n = MAX_DATA_COUNT - tx_strm.avail_out;
 		if (n > 0) {
 		    obuf[0] = DEFLATED_DATA + (n >> 8);
@@ -188,13 +188,13 @@
 	tx_strm.next_in = (Bytef *)map_ptr(buf, offset, toklen);
 	tx_strm.avail_in = toklen;
 	tx_strm.next_out = NULL;
 	tx_strm.avail_out = 2 * toklen;
 	r = deflate(&tx_strm, Z_INSERT_ONLY);
 	if (r != Z_OK || tx_strm.avail_in != 0) {
-	    fprintf(FERROR, "deflate on token returned %d (%d bytes left)\n",
+	    rprintf(FERROR, "deflate on token returned %d (%d bytes left)\n",
 		    r, tx_strm.avail_in);
 	    exit_cleanup(1);
 	}
 
     } else {
 	/* end of file - clean up */
@@ -228,13 +228,13 @@
 	case r_init:
 	    if (!init_done) {
 		rx_strm.next_out = NULL;
 		rx_strm.zalloc = z_alloc;
 		rx_strm.zfree = z_free;
 		if (inflateInit2(&rx_strm, -15) != Z_OK) {
-		    fprintf(FERROR, "inflate init failed\n");
+		    rprintf(FERROR, "inflate init failed\n");
 		    exit_cleanup(1);
 		}
 		if ((cbuf = malloc(MAX_DATA_COUNT)) == NULL
 		    || (dbuf = malloc(CHUNK_SIZE)) == NULL)
 		    out_of_memory("recv_deflated_token");
 		init_done = 1;
@@ -265,13 +265,13 @@
 		rx_strm.avail_in = 0;
 		rx_strm.next_out = (Bytef *)dbuf;
 		rx_strm.avail_out = CHUNK_SIZE;
 		r = inflate(&rx_strm, Z_PACKET_FLUSH);
 		n = CHUNK_SIZE - rx_strm.avail_out;
 		if (r != Z_OK) {
-		    fprintf(FERROR, "inflate flush returned %d (%d bytes)\n",
+		    rprintf(FERROR, "inflate flush returned %d (%d bytes)\n",
 			    r, n);
 		    exit_cleanup(1);
 		}
 		if (n != 0) {
 		    /* have to return some more data and
 		       save the flag for later. */
@@ -305,13 +305,13 @@
 	case r_inflating:
 	    rx_strm.next_out = (Bytef *)dbuf;
 	    rx_strm.avail_out = CHUNK_SIZE;
 	    r = inflate(&rx_strm, Z_NO_FLUSH);
 	    n = CHUNK_SIZE - rx_strm.avail_out;
 	    if (r != Z_OK) {
-		fprintf(FERROR, "inflate returned %d (%d bytes)\n", r, n);
+		rprintf(FERROR, "inflate returned %d (%d bytes)\n", r, n);
 		exit_cleanup(1);
 	    }
 	    if (rx_strm.avail_in == 0)
 		recv_state = r_inflated;
 	    if (n != 0) {
 		*data = dbuf;
@@ -338,13 +338,13 @@
     int r;
 
     rx_strm.next_in = (Bytef *)buf;
     rx_strm.avail_in = len;
     r = inflateIncomp(&rx_strm);
     if (r != Z_OK) {
-	fprintf(FERROR, "inflateIncomp returned %d\n", r);
+	rprintf(FERROR, "inflateIncomp returned %d\n", r);
 	exit_cleanup(1);
     }
 }
 
 /*
  * transmit a verbatim buffer of length n followed by a token 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/uidlist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/uidlist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/uidlist.c	1998-04-05 14:10:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/uidlist.c	1998-05-14 15:07:52.000000000 +0800
@@ -64,44 +64,25 @@
 {
 	struct group *grp = getgrgid(gid);
 	if (grp) return(grp->gr_name);
 	return NULL;
 }
 
-
-/* turn a user name into a uid */
-static uid_t name_to_uid(char *name)
-{
-	struct passwd *pass;
-	if (!name || !*name) return 0;
-	pass = getpwnam(name);
-	if (pass) return(pass->pw_uid);
-	return 0;
-}
-
-/* turn a group name into a gid */
-static gid_t name_to_gid(char *name)
-{
-	struct group *grp;
-	if (!name || !*name) return 0;
-	grp = getgrnam(name);
-	if (grp) return(grp->gr_gid);
-	return 0;
-}
-
 static int map_uid(int id, char *name)
 {
-	uid_t uid = name_to_uid(name);
-	if (uid != 0) return uid;
+	uid_t uid;
+	if (name_to_uid(name, &uid) && uid != 0)
+		return uid;
 	return id;
 }
 
 static int map_gid(int id, char *name)
 {
-	gid_t gid = name_to_gid(name);
-	if (gid != 0) return gid;
+	gid_t gid;
+	if (name_to_gid(name, &gid) && gid != 0)
+		return gid;
 	return id;
 }
 
 /* this function is a definate candidate for a faster algorithm */
 static uid_t match_uid(uid_t uid)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/util.c	1998-04-05 14:45:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/util.c	1998-05-14 15:07:52.000000000 +0800
@@ -29,13 +29,13 @@
   int len=0;
   ioctl(fd,FIONREAD,&len);
   return(len);
 }
 
 
-struct map_struct *map_file(int fd,off_t len)
+struct map_struct *map_file(int fd,OFF_T len)
 {
   struct map_struct *ret;
   ret = (struct map_struct *)malloc(sizeof(*ret));
   if (!ret) out_of_memory("map_file");
 
   ret->map = NULL;
@@ -44,20 +44,24 @@
   ret->p = NULL;
   ret->p_size = 0;
   ret->p_offset = 0;
   ret->p_len = 0;
 
 #ifdef HAVE_MMAP
-  if (len < MAX_MAP_SIZE)
-    ret->map = (char *)mmap(NULL,len,PROT_READ,MAP_SHARED,fd,0);
+  if (len < MAX_MAP_SIZE) {
+	  ret->map = (char *)mmap(NULL,len,PROT_READ,MAP_SHARED,fd,0);
+	  if (ret->map == (char *)-1) {
+		  ret->map = NULL;
+	  }
+  }
 #endif
   return ret;
 }
 
 
-char *map_ptr(struct map_struct *map,off_t offset,int len)
+char *map_ptr(struct map_struct *map,OFF_T offset,int len)
 {
   int nread = -2;
 
   if (map->map)
     return map->map+offset;
 
@@ -80,15 +84,15 @@
     if (map->p) free(map->p);
     map->p = (char *)malloc(len);
     if (!map->p) out_of_memory("map_ptr");
     map->p_size = len;
   }
 
-  if (lseek(map->fd,offset,SEEK_SET) != offset ||
+  if (do_lseek(map->fd,offset,SEEK_SET) != offset ||
       (nread=read(map->fd,map->p,len)) != len) {
-	  fprintf(FERROR,"EOF in map_ptr! (offset=%d len=%d nread=%d errno=%d)\n",
+	  rprintf(FERROR,"EOF in map_ptr! (offset=%d len=%d nread=%d errno=%d)\n",
 		  (int)offset, len, nread, errno);
 	  exit_cleanup(1);
   }
 
   map->p_offset = offset;
   map->p_len = len;
@@ -114,45 +118,45 @@
   int pid;
   int to_child_pipe[2];
   int from_child_pipe[2];
 
   if (pipe(to_child_pipe) < 0 ||
       pipe(from_child_pipe) < 0) {
-    fprintf(FERROR,"pipe: %s\n",strerror(errno));
+    rprintf(FERROR,"pipe: %s\n",strerror(errno));
     exit_cleanup(1);
   }
 
 
   pid = do_fork();
   if (pid < 0) {
-    fprintf(FERROR,"fork: %s\n",strerror(errno));
+    rprintf(FERROR,"fork: %s\n",strerror(errno));
     exit_cleanup(1);
   }
 
   if (pid == 0)
     {
       extern int orig_umask;
       if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 	  close(to_child_pipe[1]) < 0 ||
 	  close(from_child_pipe[0]) < 0 ||
 	  dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
-	fprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
+	rprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
 	exit_cleanup(1);
       }
       if (to_child_pipe[0] != STDIN_FILENO) close(to_child_pipe[0]);
       if (from_child_pipe[1] != STDOUT_FILENO) close(from_child_pipe[1]);
       umask(orig_umask);
       execvp(command[0], command);
-      fprintf(FERROR,"Failed to exec %s : %s\n",
+      rprintf(FERROR,"Failed to exec %s : %s\n",
 	      command[0],strerror(errno));
       exit_cleanup(1);
     }
 
   if (close(from_child_pipe[1]) < 0 ||
       close(to_child_pipe[0]) < 0) {
-    fprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
+    rprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
     exit_cleanup(1);
   }
 
   *f_in = from_child_pipe[0];
   *f_out = to_child_pipe[1];
   
@@ -164,20 +168,20 @@
 	int pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
 
 	if (pipe(to_child_pipe) < 0 ||
 	    pipe(from_child_pipe) < 0) {
-		fprintf(FERROR,"pipe: %s\n",strerror(errno));
+		rprintf(FERROR,"pipe: %s\n",strerror(errno));
 		exit_cleanup(1);
 	}
 
 
 	pid = do_fork();
 	if (pid < 0) {
-		fprintf(FERROR,"fork: %s\n",strerror(errno));
+		rprintf(FERROR,"fork: %s\n",strerror(errno));
 		exit_cleanup(1);
 	}
 
 	if (pid == 0) {
 		extern int am_sender;
 		extern int am_server;
@@ -186,23 +190,23 @@
 		am_server = 1;		
 
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
-			fprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
+			rprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
 			exit_cleanup(1);
 		}
 		if (to_child_pipe[0] != STDIN_FILENO) close(to_child_pipe[0]);
 		if (from_child_pipe[1] != STDOUT_FILENO) close(from_child_pipe[1]);
-		start_server(argc, argv);
+		start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
 	}
 
 	if (close(from_child_pipe[1]) < 0 ||
 	    close(to_child_pipe[0]) < 0) {
-		fprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
+		rprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
 		exit_cleanup(1);
 	}
 
 	*f_in = from_child_pipe[0];
 	*f_out = to_child_pipe[1];
   
@@ -210,19 +214,19 @@
 }
 
 
 
 void out_of_memory(char *str)
 {
-  fprintf(FERROR,"ERROR: out of memory in %s\n",str);
+  rprintf(FERROR,"ERROR: out of memory in %s\n",str);
   exit_cleanup(1);
 }
 
 void overflow(char *str)
 {
-  fprintf(FERROR,"ERROR: buffer overflow in %s\n",str);
+  rprintf(FERROR,"ERROR: buffer overflow in %s\n",str);
   exit_cleanup(1);
 }
 
 
 
 int set_modtime(char *fname,time_t modtime)
@@ -363,46 +367,46 @@
 	int ofd;
 	char buf[1024 * 8];
 	int len;   /* Number of bytes read into `buf'. */
 
 	ifd = open(source, O_RDONLY);
 	if (ifd == -1) {
-		fprintf(FERROR,"open %s: %s\n",
+		rprintf(FERROR,"open %s: %s\n",
 			source,strerror(errno));
 		return -1;
 	}
 
 	if (do_unlink(dest) && errno != ENOENT) {
-		fprintf(FERROR,"unlink %s: %s\n",
+		rprintf(FERROR,"unlink %s: %s\n",
 			dest,strerror(errno));
 		return -1;
 	}
 
 	ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode);
 	if (ofd < 0) {
-		fprintf(FERROR,"open %s: %s\n",
+		rprintf(FERROR,"open %s: %s\n",
 			dest,strerror(errno));
 		close(ifd);
 		return -1;
 	}
 
 	while ((len = safe_read(ifd, buf, sizeof(buf))) > 0) {
 		if (full_write(ofd, buf, len) < 0) {
-			fprintf(FERROR,"write %s: %s\n",
+			rprintf(FERROR,"write %s: %s\n",
 				dest,strerror(errno));
 			close(ifd);
 			close(ofd);
 			return -1;
 		}
 	}
 
 	close(ifd);
 	close(ofd);
 
 	if (len < 0) {
-		fprintf(FERROR,"read %s: %s\n",
+		rprintf(FERROR,"read %s: %s\n",
 			source,strerror(errno));
 		return -1;
 	}
 
 	return 0;
 }
@@ -438,6 +442,104 @@
 	int i;
 	for (i=0;i<num_pids;i++) {
 		if (all_pids[i] != getpid())
 			kill(all_pids[i], sig);
 	}
 }
+
+/* like strncpy but does not 0 fill the buffer and always null 
+   terminates (thus it can use maxlen+1 space in d) */
+void strlcpy(char *d, char *s, int maxlen)
+{
+	int len = strlen(s);
+	if (len > maxlen) len = maxlen;
+	memcpy(d, s, len);
+	d[len] = 0;
+}
+
+/* turn a user name into a uid */
+int name_to_uid(char *name, uid_t *uid)
+{
+	struct passwd *pass;
+	if (!name || !*name) return 0;
+	pass = getpwnam(name);
+	if (pass) {
+		*uid = pass->pw_uid;
+		return 1;
+	}
+	return 0;
+}
+
+/* turn a group name into a gid */
+int name_to_gid(char *name, gid_t *gid)
+{
+	struct group *grp;
+	if (!name || !*name) return 0;
+	grp = getgrnam(name);
+	if (grp) {
+		*gid = grp->gr_gid;
+		return 1;
+	}
+	return 0;
+}
+
+
+/****************************************************************************
+check if a process exists. 
+****************************************************************************/
+int process_exists(int pid)
+{
+	return(kill(pid,0) == 0 || errno != ESRCH);
+}
+
+/* lock a byte range in a open file */
+int lock_range(int fd, int offset, int len)
+{
+	struct flock lock;
+
+	lock.l_type = F_WRLCK;
+	lock.l_whence = SEEK_SET;
+	lock.l_start = offset;
+	lock.l_len = len;
+	lock.l_pid = 0;
+	
+	return fcntl(fd,F_SETLK,&lock) == 0;
+}
+
+
+void glob_expand(char **argv, int *argc, int maxargs)
+{
+#ifndef HAVE_GLOB
+	(*argc)++;
+	return;
+#else
+	glob_t globbuf;
+	int i;
+
+	memset(&globbuf, 0, sizeof(globbuf));
+	glob(argv[*argc], 0, NULL, &globbuf);
+	if (globbuf.gl_pathc == 0) {
+		(*argc)++;
+		globfree(&globbuf);
+		return;
+	}
+	for (i=0; i<(maxargs - (*argc)) && i<globbuf.gl_pathc;i++) {
+		if (i == 0) free(argv[*argc]);
+		argv[(*argc) + i] = strdup(globbuf.gl_pathv[i]);
+		if (!argv[(*argc) + i]) out_of_memory("glob_expand");
+	}
+	globfree(&globbuf);
+	(*argc) += i;
+#endif
+}
+
+
+/*******************************************************************
+  convert a string to lower case
+********************************************************************/
+void strlower(char *s)
+{
+	while (*s) {
+		if (isupper(*s)) *s = tolower(*s);
+		s++;
+	}
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-1.7.4/version.h	1998-04-17 14:49:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.0/version.h	1998-05-14 15:24:52.000000000 +0800
@@ -1 +1 @@
-#define VERSION "1.7.4"
+#define VERSION "2.0.0"
