diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/authenticate.c	1998-09-09 15:06:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/authenticate.c	1998-11-26 00:24:39.000000000 +0800
@@ -52,13 +52,13 @@
 {
 	char input[32];
 	struct timeval tv;
 
 	memset(input, 0, sizeof(input));
 
-	strlcpy((char *)input, addr, 16);
+	strlcpy((char *)input, addr, 17);
 	gettimeofday(&tv, NULL);
 	SIVAL(input, 16, tv.tv_sec);
 	SIVAL(input, 20, tv.tv_usec);
 	SIVAL(input, 24, getpid());
 
 	sum_init();
@@ -72,18 +72,37 @@
 static int get_secret(int module, char *user, char *secret, int len)
 {
 	char *fname = lp_secrets_file(module);
 	int fd, found=0;
 	char line[MAXPATHLEN];
 	char *p, *pass=NULL;
+	STRUCT_STAT st;
+	int ok = 1;
+	extern int am_root;
 
 	if (!fname || !*fname) return 0;
 
 	fd = open(fname,O_RDONLY);
 	if (fd == -1) return 0;
 
+	if (do_stat(fname, &st) == -1) {
+		rprintf(FERROR,"stat(%s) : %s\n", fname, strerror(errno));
+		ok = 0;
+	} else if ((st.st_mode & 06) != 0) {
+		rprintf(FERROR,"secrets file must not be other-accessible\n");
+		ok = 0;
+	} else if (am_root && (st.st_uid != 0)) {
+		rprintf(FERROR,"secrets file must be owned by root when running as root\n");
+		ok = 0;
+	}
+	if (!ok) {
+		rprintf(FERROR,"continuing without secrets file\n");
+		close(fd);
+		return 0;
+	}
+
 	while (!found) {
 		int i = 0;
 		memset(line, 0, sizeof(line));
 		while (i<(sizeof(line)-1)) {
 			if (read(fd, &line[i], 1) != 1) {
 				memset(line, 0, sizeof(line));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/cleanup.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/cleanup.c	1998-11-26 00:24:39.000000000 +0800
@@ -28,13 +28,13 @@
 static char *cleanup_new_fname;
 static struct file_struct *cleanup_file;
 static int cleanup_fd1, cleanup_fd2;
 static struct map_struct *cleanup_buf;
 static int cleanup_pid = 0;
 
-void exit_cleanup(int code)
+void _exit_cleanup(int code, const char *file, int line)
 {
 	extern int keep_partial;
 
 	signal(SIGUSR1, SIG_IGN);
 
 	if (cleanup_got_literal && cleanup_fname && keep_partial) {
@@ -55,13 +55,13 @@
 		char *pidf = lp_pid_file();
 		if (pidf && *pidf) {
 			unlink(lp_pid_file());
 		}
 	}
 
-	if (code) log_exit(code);
+	if (code) log_exit(code, file, line);
 
 	exit(code);
 }
 
 void cleanup_disable(void)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/clientserver.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/clientserver.c	1998-11-26 00:24:39.000000000 +0800
@@ -184,12 +184,18 @@
 			io_printf(fd,"@ERROR: invalid gid\n");
 			return -1;
 		} 
 		gid = atoi(p);
 	}
 
+	p = lp_include_from(i);
+	add_exclude_file(p, 1, 1);
+
+	p = lp_include(i);
+	add_include_line(p);
+
 	p = lp_exclude_from(i);
 	add_exclude_file(p, 1, 0);
 
 	p = lp_exclude(i);
 	add_exclude_line(p);
 
@@ -250,13 +256,13 @@
 
 		if (start_glob) {
 			if (start_glob == 1) {
 				request = strdup(p);
 				start_glob++;
 			}
-			glob_expand(name, argv, &argc, MAX_ARGS);
+			glob_expand(name, argv, &argc, MAX_ARGS, !use_chroot);
 		} else {
 			argc++;
 		}
 
 		if (strcmp(line,".") == 0) {
 			start_glob = 1;
@@ -273,15 +279,13 @@
 		 *    they are filenames, but no other legal parameters contain
 		 *    the forms that need to be sanitized so it doesn't hurt;
 		 *    it is not known at this point which parameters are files
 		 *    and which aren't.
 		 */
 		for (i = 1; i < argc; i++) {
-			char *copy = sanitize_path(argv[i]);
-			free((void *)argv[i]);
-			argv[i] = copy;
+			sanitize_path(argv[i]);
 		}
 	}
 
 	ret = parse_arguments(argc, argv);
 
 	if (request) {
@@ -307,14 +311,18 @@
 	optind = 0;
 
 	if (remote_version > 17 && am_sender)
 		io_start_multiplex_out(fd);
 
 	if (!ret) {
-		rprintf(FERROR,"Error parsing options (unsupported option?) - aborting\n");
-		exit_cleanup(RERR_SYNTAX);
+		option_error();
+	}
+
+	if (lp_timeout(i)) {
+		extern int io_timeout;
+		io_timeout = lp_timeout(i);
 	}
 
 	start_server(fd, fd, argc, argp);
 
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/config.h.in	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/config.h.in	1998-11-26 00:24:39.000000000 +0800
@@ -127,12 +127,18 @@
 /* Define if you have the strerror function.  */
 #undef HAVE_STRERROR
 
 /* Define if you have the strftime function.  */
 #undef HAVE_STRFTIME
 
+/* Define if you have the strlcat function.  */
+#undef HAVE_STRLCAT
+
+/* Define if you have the strlcpy function.  */
+#undef HAVE_STRLCPY
+
 /* Define if you have the strpbrk function.  */
 #undef HAVE_STRPBRK
 
 /* Define if you have the utime function.  */
 #undef HAVE_UTIME
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/configure	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/configure	1998-11-26 00:24:39.000000000 +0800
@@ -517,12 +517,15 @@
   ac_n= ac_c='\c' ac_t=
 fi
 
 
 
 
+# compile with optimisation and without debugging by default
+CFLAGS=${CFLAGS-"-O"}
+
 ac_aux_dir=
 for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
   if test -f $ac_dir/install-sh; then
     ac_aux_dir=$ac_dir
     ac_install_sh="$ac_aux_dir/install-sh -c"
     break
@@ -564,13 +567,13 @@
 # Make sure we can run config.sub.
 if $ac_config_sub sun4 >/dev/null 2>&1; then :
 else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:571: checking host system type" >&5
+echo "configure:574: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
 NONE)
   case $nonopt in
   NONE)
@@ -585,13 +588,13 @@
 host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
 host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
 host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking target system type""... $ac_c" 1>&6
-echo "configure:592: checking target system type" >&5
+echo "configure:595: checking target system type" >&5
 
 target_alias=$target
 case "$target_alias" in
 NONE)
   case $nonopt in
   NONE) target_alias=$host_alias ;;
@@ -603,13 +606,13 @@
 target_cpu=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
 target_vendor=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
 target_os=`echo $target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 echo "$ac_t""$target" 1>&6
 
 echo $ac_n "checking build system type""... $ac_c" 1>&6
-echo "configure:610: checking build system type" >&5
+echo "configure:613: checking build system type" >&5
 
 build_alias=$build
 case "$build_alias" in
 NONE)
   case $nonopt in
   NONE) build_alias=$host_alias ;;
@@ -628,13 +631,13 @@
     NONENONEs,x,x, &&
   program_prefix=${target_alias}-
 
 
     
     echo $ac_n "checking config.cache system type""... $ac_c" 1>&6
-echo "configure:635: checking config.cache system type" >&5
+echo "configure:638: checking config.cache system type" >&5
     if { test x"${ac_cv_host_system_type+set}" = x"set" &&
          test x"$ac_cv_host_system_type" != x"$host"; } ||
        { test x"${ac_cv_build_system_type+set}" = x"set" &&
          test x"$ac_cv_build_system_type" != x"$build"; } ||
        { test x"${ac_cv_target_system_type+set}" = x"set" &&
          test x"$ac_cv_target_system_type" != x"$target"; }; then
@@ -648,13 +651,13 @@
     ac_cv_target_system_type="$target"
 
 
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:655: checking for $ac_word" >&5
+echo "configure:658: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -677,13 +680,13 @@
 fi
 
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:684: checking for $ac_word" >&5
+echo "configure:687: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -725,27 +728,27 @@
 fi
 
   test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:732: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:735: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
 ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext <<EOF
-#line 742 "configure"
+#line 745 "configure"
 #include "confdefs.h"
 main(){return(0);}
 EOF
-if { (eval echo configure:746: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:749: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
     ac_cv_prog_cc_cross=no
   else
     ac_cv_prog_cc_cross=yes
@@ -759,27 +762,27 @@
 
 echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
 if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:766: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:769: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:771: checking whether we are using GNU C" >&5
+echo "configure:774: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.c <<EOF
 #ifdef __GNUC__
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:780: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:783: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
 fi
 fi
 
@@ -788,13 +791,13 @@
 if test $ac_cv_prog_gcc = yes; then
   GCC=yes
   ac_test_CFLAGS="${CFLAGS+set}"
   ac_save_CFLAGS="$CFLAGS"
   CFLAGS=
   echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:795: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:798: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo 'void f(){}' > conftest.c
 if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
   ac_cv_prog_cc_g=yes
@@ -826,13 +829,13 @@
 # IRIX /sbin/install
 # AIX /bin/install
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:833: checking for a BSD compatible install" >&5
+echo "configure:836: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS="${IFS}:"
   for ac_dir in $PATH; do
@@ -880,13 +883,13 @@
 
 
 
 # Extract the first word of "remsh", so it can be a program name with args.
 set dummy remsh; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:887: checking for $ac_word" >&5
+echo "configure:890: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_HAVE_REMSH'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$HAVE_REMSH"; then
   ac_cv_prog_HAVE_REMSH="$HAVE_REMSH" # Let the user override the test.
 else
@@ -912,46 +915,46 @@
 cat >> confdefs.h <<EOF
 #define HAVE_REMSH $HAVE_REMSH
 EOF
 
 
 echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:919: checking whether byte ordering is bigendian" >&5
+echo "configure:922: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_bigendian=unknown
 # See if sys/param.h defines the BYTE_ORDER macro.
 cat > conftest.$ac_ext <<EOF
-#line 926 "configure"
+#line 929 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
 int main() {
 
 #if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
  bogus endian macros
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:937: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:940: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat > conftest.$ac_ext <<EOF
-#line 941 "configure"
+#line 944 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
 int main() {
 
 #if BYTE_ORDER != BIG_ENDIAN
  not big endian
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:952: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:955: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_bigendian=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -965,26 +968,26 @@
 rm -f conftest*
 if test $ac_cv_c_bigendian = unknown; then
 if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 972 "configure"
+#line 975 "configure"
 #include "confdefs.h"
 main () {
   /* Are we little or big endian?  From Harbison&Steele.  */
   union
   {
     long l;
     char c[sizeof (long)];
   } u;
   u.l = 1;
   exit (u.c[sizeof (long) - 1] == 1);
 }
 EOF
-if { (eval echo configure:985: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:988: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian=no
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1006,26 +1009,26 @@
 
 ac_header_dirent=no
 for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:1013: checking for $ac_hdr that defines DIR" >&5
+echo "configure:1016: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1018 "configure"
+#line 1021 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
 int main() {
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:1026: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1029: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1044,32 +1047,32 @@
   echo "$ac_t""no" 1>&6
 fi
 done
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:1051: checking for opendir in -ldir" >&5
+echo "configure:1054: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1059 "configure"
+#line 1062 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char opendir();
 
 int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:1070: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:1073: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1085,32 +1088,32 @@
 else
   echo "$ac_t""no" 1>&6
 fi
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:1092: checking for opendir in -lx" >&5
+echo "configure:1095: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1100 "configure"
+#line 1103 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char opendir();
 
 int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:1111: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:1114: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1127,27 +1130,27 @@
   echo "$ac_t""no" 1>&6
 fi
 
 fi
 
 echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:1134: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:1137: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1139 "configure"
+#line 1142 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
 #include <time.h>
 int main() {
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:1148: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1151: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1162,18 +1165,18 @@
 #define TIME_WITH_SYS_TIME 1
 EOF
 
 fi
 
 echo $ac_n "checking for sys/wait.h that is POSIX.1 compatible""... $ac_c" 1>&6
-echo "configure:1169: checking for sys/wait.h that is POSIX.1 compatible" >&5
+echo "configure:1172: checking for sys/wait.h that is POSIX.1 compatible" >&5
 if eval "test \"`echo '$''{'ac_cv_header_sys_wait_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1174 "configure"
+#line 1177 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/wait.h>
 #ifndef WEXITSTATUS
 #define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
 #endif
@@ -1183,13 +1186,13 @@
 int main() {
 int s;
 wait (&s);
 s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
 ; return 0; }
 EOF
-if { (eval echo configure:1190: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1193: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_sys_wait_h=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1204,13 +1207,13 @@
 #define HAVE_SYS_WAIT_H 1
 EOF
 
 fi
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:1211: checking how to run the C preprocessor" >&5
+echo "configure:1214: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
 fi
 if test -z "$CPP"; then
 if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
@@ -1219,36 +1222,36 @@
     # This must be in double quotes, not single quotes, because CPP may get
   # substituted into the Makefile and "${CC-cc}" will confuse make.
   CPP="${CC-cc} -E"
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 1226 "configure"
+#line 1229 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1232: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1235: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 1243 "configure"
+#line 1246 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1249: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1252: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
@@ -1268,23 +1271,23 @@
 echo "$ac_t""$CPP" 1>&6
 
 for ac_hdr in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h unistd.h utime.h grp.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1275: checking for $ac_hdr" >&5
+echo "configure:1278: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1280 "configure"
+#line 1283 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1285: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1288: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -1308,23 +1311,23 @@
 done
 
 for ac_hdr in compat.h sys/param.h ctype.h sys/wait.h sys/ioctl.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1315: checking for $ac_hdr" >&5
+echo "configure:1318: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1320 "configure"
+#line 1323 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1325: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1328: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -1348,23 +1351,23 @@
 done
 
 for ac_hdr in sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1355: checking for $ac_hdr" >&5
+echo "configure:1358: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1360 "configure"
+#line 1363 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1365: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1368: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -1388,23 +1391,23 @@
 done
 
 for ac_hdr in glob.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1395: checking for $ac_hdr" >&5
+echo "configure:1398: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1400 "configure"
+#line 1403 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1405: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1408: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -1426,32 +1429,32 @@
   echo "$ac_t""no" 1>&6
 fi
 done
 
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:1433: checking size of int" >&5
+echo "configure:1436: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 1441 "configure"
+#line 1444 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(int));
   exit(0);
 }
 EOF
-if { (eval echo configure:1452: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1455: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1465,32 +1468,32 @@
 cat >> confdefs.h <<EOF
 #define SIZEOF_INT $ac_cv_sizeof_int
 EOF
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:1472: checking size of long" >&5
+echo "configure:1475: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 1480 "configure"
+#line 1483 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long));
   exit(0);
 }
 EOF
-if { (eval echo configure:1491: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1494: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1504,32 +1507,32 @@
 cat >> confdefs.h <<EOF
 #define SIZEOF_LONG $ac_cv_sizeof_long
 EOF
 
 
 echo $ac_n "checking size of short""... $ac_c" 1>&6
-echo "configure:1511: checking size of short" >&5
+echo "configure:1514: checking size of short" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_short'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 1519 "configure"
+#line 1522 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(short));
   exit(0);
 }
 EOF
-if { (eval echo configure:1530: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1533: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_short=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1544,27 +1547,27 @@
 #define SIZEOF_SHORT $ac_cv_sizeof_short
 EOF
 
 
 
 echo $ac_n "checking for inline""... $ac_c" 1>&6
-echo "configure:1551: checking for inline" >&5
+echo "configure:1554: checking for inline" >&5
 if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat > conftest.$ac_ext <<EOF
-#line 1558 "configure"
+#line 1561 "configure"
 #include "confdefs.h"
 
 int main() {
 } $ac_kw foo() {
 ; return 0; }
 EOF
-if { (eval echo configure:1565: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1568: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_inline=$ac_kw; break
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -1585,18 +1588,18 @@
 EOF
  ;;
 esac
 
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:1592: checking return type of signal handlers" >&5
+echo "configure:1595: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1597 "configure"
+#line 1600 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
 #ifdef signal
 #undef signal
 #endif
@@ -1607,13 +1610,13 @@
 #endif
 
 int main() {
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:1614: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1617: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1626,18 +1629,18 @@
 cat >> confdefs.h <<EOF
 #define RETSIGTYPE $ac_cv_type_signal
 EOF
 
 
 echo $ac_n "checking for uid_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:1633: checking for uid_t in sys/types.h" >&5
+echo "configure:1636: checking for uid_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'ac_cv_type_uid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1638 "configure"
+#line 1641 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "uid_t" >/dev/null 2>&1; then
   rm -rf conftest*
@@ -1660,26 +1663,26 @@
 #define gid_t int
 EOF
 
 fi
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:1667: checking for ANSI C header files" >&5
+echo "configure:1670: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1672 "configure"
+#line 1675 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1680: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1683: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
   ac_cv_header_stdc=yes
 else
   echo "$ac_err" >&5
@@ -1690,13 +1693,13 @@
 fi
 rm -f conftest*
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 1697 "configure"
+#line 1700 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "memchr" >/dev/null 2>&1; then
   :
@@ -1708,13 +1711,13 @@
 
 fi
 
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 1715 "configure"
+#line 1718 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "free" >/dev/null 2>&1; then
   :
@@ -1729,24 +1732,24 @@
 if test $ac_cv_header_stdc = yes; then
   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
 if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 1736 "configure"
+#line 1739 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
 #define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
 #define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int main () { int i; for (i = 0; i < 256; i++)
 if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
 exit (0); }
 
 EOF
-if { (eval echo configure:1747: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1750: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -1764,18 +1767,18 @@
 #define STDC_HEADERS 1
 EOF
 
 fi
 
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:1771: checking for mode_t" >&5
+echo "configure:1774: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1776 "configure"
+#line 1779 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1797,18 +1800,18 @@
 #define mode_t int
 EOF
 
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:1804: checking for off_t" >&5
+echo "configure:1807: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1809 "configure"
+#line 1812 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1830,18 +1833,18 @@
 #define off_t long
 EOF
 
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:1837: checking for size_t" >&5
+echo "configure:1840: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1842 "configure"
+#line 1845 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1863,18 +1866,18 @@
 #define size_t unsigned
 EOF
 
 fi
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:1870: checking for pid_t" >&5
+echo "configure:1873: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1875 "configure"
+#line 1878 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1896,26 +1899,26 @@
 #define pid_t int
 EOF
 
 fi
 
 echo $ac_n "checking for st_rdev in struct stat""... $ac_c" 1>&6
-echo "configure:1903: checking for st_rdev in struct stat" >&5
+echo "configure:1906: checking for st_rdev in struct stat" >&5
 if eval "test \"`echo '$''{'ac_cv_struct_st_rdev'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1908 "configure"
+#line 1911 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
 int main() {
 struct stat s; s.st_rdev;
 ; return 0; }
 EOF
-if { (eval echo configure:1916: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1919: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_struct_st_rdev=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1930,18 +1933,18 @@
 #define HAVE_ST_RDEV 1
 EOF
 
 fi
 
 echo $ac_n "checking for ino_t""... $ac_c" 1>&6
-echo "configure:1937: checking for ino_t" >&5
+echo "configure:1940: checking for ino_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ino_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1942 "configure"
+#line 1945 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -1964,26 +1967,26 @@
 EOF
 
 fi
 
 
 echo $ac_n "checking for errno in errno.h""... $ac_c" 1>&6
-echo "configure:1971: checking for errno in errno.h" >&5
+echo "configure:1974: checking for errno in errno.h" >&5
 if eval "test \"`echo '$''{'rsync_cv_errno'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
     cat > conftest.$ac_ext <<EOF
-#line 1977 "configure"
+#line 1980 "configure"
 #include "confdefs.h"
 #include <errno.h>
 int main() {
 int i = errno
 ; return 0; }
 EOF
-if { (eval echo configure:1984: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1987: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   rsync_cv_errno=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1998,31 +2001,31 @@
 #define HAVE_ERRNO_DECL 1
 EOF
 
 fi
 
 echo $ac_n "checking for 8-bit clean memcmp""... $ac_c" 1>&6
-echo "configure:2005: checking for 8-bit clean memcmp" >&5
+echo "configure:2008: checking for 8-bit clean memcmp" >&5
 if eval "test \"`echo '$''{'ac_cv_func_memcmp_clean'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_func_memcmp_clean=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 2013 "configure"
+#line 2016 "configure"
 #include "confdefs.h"
 
 main()
 {
   char c0 = 0x40, c1 = 0x80, c2 = 0x81;
   exit(memcmp(&c0, &c2, 1) < 0 && memcmp(&c1, &c2, 1) < 0 ? 0 : 1);
 }
 
 EOF
-if { (eval echo configure:2023: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2026: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_memcmp_clean=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2034,34 +2037,34 @@
 fi
 
 echo "$ac_t""$ac_cv_func_memcmp_clean" 1>&6
 test $ac_cv_func_memcmp_clean = no && LIBOBJS="$LIBOBJS memcmp.o"
 
 echo $ac_n "checking whether utime accepts a null argument""... $ac_c" 1>&6
-echo "configure:2041: checking whether utime accepts a null argument" >&5
+echo "configure:2044: checking whether utime accepts a null argument" >&5
 if eval "test \"`echo '$''{'ac_cv_func_utime_null'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   rm -f conftestdata; > conftestdata
 # Sequent interprets utime(file, 0) to mean use start of epoch.  Wrong.
 if test "$cross_compiling" = yes; then
   ac_cv_func_utime_null=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 2051 "configure"
+#line 2054 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
 main() {
 struct stat s, t;
 exit(!(stat ("conftestdata", &s) == 0 && utime("conftestdata", (long *)0) == 0
 && stat("conftestdata", &t) == 0 && t.st_mtime >= s.st_mtime
 && t.st_mtime - s.st_mtime < 120));
 }
 EOF
-if { (eval echo configure:2062: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2065: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_utime_null=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2081,18 +2084,18 @@
 
 fi
 
 for ac_func in mmap munmap waitpid getcwd strdup strerror chown chmod mknod
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:2088: checking for $ac_func" >&5
+echo "configure:2091: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2093 "configure"
+#line 2096 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2109,13 +2112,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2116: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2119: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2136,18 +2139,18 @@
 fi
 done
 
 for ac_func in fchmod fstat strchr readlink link utime utimes strftime
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:2143: checking for $ac_func" >&5
+echo "configure:2146: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2148 "configure"
+#line 2151 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2164,13 +2167,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2171: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2174: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2191,18 +2194,73 @@
 fi
 done
 
 for ac_func in memmove getopt_long lchown vsnprintf snprintf setsid glob strpbrk
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:2198: checking for $ac_func" >&5
+echo "configure:2201: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2206 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2229: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+for ac_func in strlcat strlcpy
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2256: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2203 "configure"
+#line 2261 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2219,13 +2277,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2226: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2284: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2249,18 +2307,18 @@
 
 echo $ac_n "checking for working fnmatch... $ac_c"
 if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2256 "configure"
+#line 2314 "configure"
 #include "confdefs.h"
 #include <fnmatch.h>
 main() { exit(fnmatch("*.o", "x.o", 0) == 0? 0: 1); }
 EOF
-if { (eval echo configure:2261: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2319: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   echo yes;cat >> confdefs.h <<\EOF
 #define HAVE_FNMATCH 1
 EOF
 
 else
@@ -2271,27 +2329,27 @@
 fi
 rm -fr conftest*
 fi
 
 
 echo $ac_n "checking for long long""... $ac_c" 1>&6
-echo "configure:2278: checking for long long" >&5
+echo "configure:2336: checking for long long" >&5
 if eval "test \"`echo '$''{'rsync_cv_have_longlong'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_have_longlong=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2287 "configure"
+#line 2345 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main() { long long x = 1000000; x *= x; exit(((x/1000000) == 1000000)? 0: 1); }
 EOF
-if { (eval echo configure:2292: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2350: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_have_longlong=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2308,28 +2366,28 @@
 #define HAVE_LONGLONG 1
 EOF
 
 fi
 
 echo $ac_n "checking for off64_t""... $ac_c" 1>&6
-echo "configure:2315: checking for off64_t" >&5
+echo "configure:2373: checking for off64_t" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_OFF64_T'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_OFF64_T=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2324 "configure"
+#line 2382 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #include <sys/stat.h>
 main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) exit(1); exit((lstat64("/dev/null", &st)==0)?0:1); }
 EOF
-if { (eval echo configure:2330: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2388: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_OFF64_T=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2350,20 +2408,20 @@
 
 echo $ac_n "checking for short ino_t ... $ac_c"
 if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2357 "configure"
+#line 2415 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 main() { if (sizeof(ino_t) < sizeof(unsigned int)) return 0; return 1; }
 EOF
-if { (eval echo configure:2364: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   echo yes;cat >> confdefs.h <<\EOF
 #define HAVE_SHORT_INO_T 1
 EOF
 
 else
@@ -2374,27 +2432,27 @@
 fi
 rm -fr conftest*
 fi
 
 
 echo $ac_n "checking for unsigned char""... $ac_c" 1>&6
-echo "configure:2381: checking for unsigned char" >&5
+echo "configure:2439: checking for unsigned char" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_UNSIGNED_CHAR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_UNSIGNED_CHAR=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2390 "configure"
+#line 2448 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main() { char c; c=250; exit((c > 0)?0:1); }
 EOF
-if { (eval echo configure:2395: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2453: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_UNSIGNED_CHAR=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2411,30 +2469,30 @@
 #define HAVE_UNSIGNED_CHAR 1
 EOF
 
 fi
 
 echo $ac_n "checking for broken readdir""... $ac_c" 1>&6
-echo "configure:2418: checking for broken readdir" >&5
+echo "configure:2476: checking for broken readdir" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_BROKEN_READDIR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_BROKEN_READDIR=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2427 "configure"
+#line 2485 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <dirent.h>
 main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
 if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
 di->d_name[0] == 0) exit(0); exit(1);} 
 EOF
-if { (eval echo configure:2435: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2493: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_HAVE_BROKEN_READDIR=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2451,27 +2509,27 @@
 #define HAVE_BROKEN_READDIR 1
 EOF
 
 fi
 
 echo $ac_n "checking for utimbuf""... $ac_c" 1>&6
-echo "configure:2458: checking for utimbuf" >&5
+echo "configure:2516: checking for utimbuf" >&5
 if eval "test \"`echo '$''{'rsync_cv_HAVE_UTIMBUF'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 cat > conftest.$ac_ext <<EOF
-#line 2464 "configure"
+#line 2522 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <utime.h>
 int main() {
 struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));
 ; return 0; }
 EOF
-if { (eval echo configure:2472: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2530: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   rsync_cv_HAVE_UTIMBUF=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2486,34 +2544,34 @@
 #define HAVE_UTIMBUF 1
 EOF
 
 fi
 
 echo $ac_n "checking for broken inet_ntoa""... $ac_c" 1>&6
-echo "configure:2493: checking for broken inet_ntoa" >&5
+echo "configure:2551: checking for broken inet_ntoa" >&5
 if eval "test \"`echo '$''{'rsync_cv_REPLACE_INET_NTOA'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
 if test "$cross_compiling" = yes; then
   rsync_cv_REPLACE_INET_NTOA=cross
 else
   cat > conftest.$ac_ext <<EOF
-#line 2502 "configure"
+#line 2560 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 main() { struct in_addr ip; ip.s_addr = 0x12345678;
 if (strcmp(inet_ntoa(ip),"18.52.86.120") &&
     strcmp(inet_ntoa(ip),"120.86.52.18")) { exit(0); } 
 exit(1);}
 EOF
-if { (eval echo configure:2514: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2572: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   rsync_cv_REPLACE_INET_NTOA=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -2538,18 +2596,18 @@
 # libsocket.so which has a bad implementation of gethostbyname (it
 # only looks in /etc/hosts), so we only look for -lsocket if we need
 # it.
 for ac_func in connect
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:2545: checking for $ac_func" >&5
+echo "configure:2603: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2550 "configure"
+#line 2608 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2566,13 +2624,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2573: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2631: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2594,32 +2652,32 @@
 done
 
 if test x"$ac_cv_func_connect" = x"no"; then
     case "$LIBS" in
     *-lnsl*) ;;
     *) echo $ac_n "checking for printf in -lnsl_s""... $ac_c" 1>&6
-echo "configure:2601: checking for printf in -lnsl_s" >&5
+echo "configure:2659: checking for printf in -lnsl_s" >&5
 ac_lib_var=`echo nsl_s'_'printf | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl_s  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2609 "configure"
+#line 2667 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char printf();
 
 int main() {
 printf()
 ; return 0; }
 EOF
-if { (eval echo configure:2620: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2678: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2644,32 +2702,32 @@
 fi
  ;;
     esac
     case "$LIBS" in
     *-lnsl*) ;;
     *) echo $ac_n "checking for printf in -lnsl""... $ac_c" 1>&6
-echo "configure:2651: checking for printf in -lnsl" >&5
+echo "configure:2709: checking for printf in -lnsl" >&5
 ac_lib_var=`echo nsl'_'printf | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2659 "configure"
+#line 2717 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char printf();
 
 int main() {
 printf()
 ; return 0; }
 EOF
-if { (eval echo configure:2670: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2728: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2694,32 +2752,32 @@
 fi
  ;;
     esac
     case "$LIBS" in
     *-lsocket*) ;;
     *) echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
-echo "configure:2701: checking for connect in -lsocket" >&5
+echo "configure:2759: checking for connect in -lsocket" >&5
 ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2709 "configure"
+#line 2767 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char connect();
 
 int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:2720: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2778: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2744,32 +2802,32 @@
 fi
  ;;
     esac
     case "$LIBS" in
     *-linet*) ;;
     *) echo $ac_n "checking for connect in -linet""... $ac_c" 1>&6
-echo "configure:2751: checking for connect in -linet" >&5
+echo "configure:2809: checking for connect in -linet" >&5
 ac_lib_var=`echo inet'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-linet  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2759 "configure"
+#line 2817 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char connect();
 
 int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:2770: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2828: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2802,12 +2860,120 @@
 #define HAVE_CONNECT 1
 EOF
 
     fi
 fi
 
+# 
+# if we can't find strcasecmp, look in -lresolv (for Unixware at least)
+#
+for ac_func in strcasecmp
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:2873: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2878 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:2901: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+if test x"$ac_cv_func_strcasecmp" = x"no"; then
+    echo $ac_n "checking for strcasecmp in -lresolv""... $ac_c" 1>&6
+echo "configure:2927: checking for strcasecmp in -lresolv" >&5
+ac_lib_var=`echo resolv'_'strcasecmp | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_save_LIBS="$LIBS"
+LIBS="-lresolv  $LIBS"
+cat > conftest.$ac_ext <<EOF
+#line 2935 "configure"
+#include "confdefs.h"
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char strcasecmp();
+
+int main() {
+strcasecmp()
+; return 0; }
+EOF
+if { (eval echo configure:2946: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_lib_$ac_lib_var=no"
+fi
+rm -f conftest*
+LIBS="$ac_save_LIBS"
+
+fi
+if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_lib=HAVE_LIB`echo resolv | sed -e 's/[^a-zA-Z0-9_]/_/g' \
+    -e 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_lib 1
+EOF
+
+  LIBS="-lresolv $LIBS"
+
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+fi
+
 #
 # The following test was mostly taken from the tcl/tk plus patches
 #
 echo $ac_n "checking whether -c -o works ... $ac_c"
 rm -rf conftest*
 cat > conftest.$ac_ext <<EOF
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/configure.in	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/configure.in	1998-11-26 00:24:39.000000000 +0800
@@ -1,10 +1,13 @@
 dnl Process this file with autoconf to produce a configure script.
 AC_INIT(byteorder.h)
 AC_CONFIG_HEADER(config.h)
 
+# compile with optimisation and without debugging by default
+CFLAGS=${CFLAGS-"-O"}
+
 AC_CANONICAL_SYSTEM
 AC_VALIDATE_CACHE_SYSTEM_TYPE
 
 dnl Checks for programs.
 AC_PROG_CC
 AC_PROG_INSTALL
@@ -46,12 +49,13 @@
 
 AC_FUNC_MEMCMP
 AC_FUNC_UTIME_NULL
 AC_CHECK_FUNCS(mmap munmap waitpid getcwd strdup strerror chown chmod mknod)
 AC_CHECK_FUNCS(fchmod fstat strchr readlink link utime utimes strftime)
 AC_CHECK_FUNCS(memmove getopt_long lchown vsnprintf snprintf setsid glob strpbrk)
+AC_CHECK_FUNCS(strlcat strlcpy)
 
 echo $ac_n "checking for working fnmatch... $ac_c"
 AC_TRY_RUN([#include <fnmatch.h>
 main() { exit(fnmatch("*.o", "x.o", 0) == 0? 0: 1); }],
 echo yes;AC_DEFINE(HAVE_FNMATCH), 
 echo no)
@@ -155,12 +159,20 @@
         # ac_cv_func_connect=yes
         # don't!  it would cause AC_CHECK_FUNC to succeed next time configure is run
         AC_DEFINE(HAVE_CONNECT)
     fi
 fi
 
+# 
+# if we can't find strcasecmp, look in -lresolv (for Unixware at least)
+#
+AC_CHECK_FUNCS(strcasecmp)
+if test x"$ac_cv_func_strcasecmp" = x"no"; then
+    AC_CHECK_LIB(resolv, strcasecmp)
+fi
+
 #
 # The following test was mostly taken from the tcl/tk plus patches
 #
 echo $ac_n "checking whether -c -o works ... $ac_c"
 rm -rf conftest*
 cat > conftest.$ac_ext <<EOF
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/cvs.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/cvs.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/cvs.log	1998-11-04 06:01:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/cvs.log	1998-11-26 00:25:06.000000000 +0800
@@ -7562,6 +7562,622 @@
 
 Modified Files:
 	rsync.spec 
 Log Message:
 preparing for release of 2.2.0
 
+
+****************************************
+Date:	Wednesday November 4, 1998 @ 9:30
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv23668
+
+Modified Files:
+	rsync.1 rsync.yo 
+Log Message:
+Remove statement in rsync.1 that a rsync:// URL can only be used if 
+a username is not needed.
+
+
+
+****************************************
+Date:	Wednesday November 4, 1998 @ 13:35
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv173
+
+Modified Files:
+	mdfour.c 
+Log Message:
+use macros to make mdfour faster on systems that don't do inlining
+well. Also helps when optimisation level is low.
+
+
+
+****************************************
+Date:	Wednesday November 4, 1998 @ 14:14
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv17473
+
+Modified Files:
+	clientserver.c loadparm.c proto.h rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+added timeout option in rsyncd.conf
+
+
+
+
+****************************************
+Date:	Thursday November 5, 1998 @ 3:47
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16357
+
+Modified Files:
+	errcode.h exclude.c 
+Log Message:
+Fix confusion between RERR_NOSUPPORT and RERR_UNSUPPORTED for exit codes
+that indicate a feature is not supported.  Two places that are normally
+ifdefed out used RERR_UNSUPPORTED whereas one other place and errcode.h
+used RERR_NOSUPPORT.  Changed them all to consistently use RERR_UNSUPPORTED.
+The two things that had the bad values were #ifndef SUPPORT_LINKS and
+#ifdef NO_INT64.  The former is probably for non-Unix operating systems
+and the latter was at least on the default Unixware compiler.
+
+
+
+****************************************
+Date:	Friday November 6, 1998 @ 1:33
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv10789
+
+Modified Files:
+	receiver.c 
+Log Message:
+Add comment before call to mktemp saying it is deliberately chosen over
+mkstemp.
+
+
+
+****************************************
+Date:	Friday November 6, 1998 @ 21:37
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv11127
+
+Modified Files:
+	README 
+Log Message:
+fixed typo
+
+
+
+****************************************
+Date:	Saturday November 7, 1998 @ 4:07
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv22035
+
+Modified Files:
+	util.c 
+Log Message:
+Change sanitize_path() to not use clean_fname() because it removes the
+trailing slash.  This caused a problem when using "use chroot" and sources
+that contained a trailing slash (which prevents the last filename component
+of the source from being included in the destination).  Instead, have
+sanitize_path() remove "." components and duplicated slashes ("//") itself.
+
+
+
+****************************************
+Date:	Sunday November 15, 1998 @ 10:31
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv22497
+
+Modified Files:
+	authenticate.c exclude.c flist.c generator.c io.c loadparm.c 
+	log.c mkproto.awk proto.h receiver.c rsync.c sender.c socket.c 
+	util.c 
+Log Message:
+changed strlcat() and strlcpy() to have the same semantics as the
+OpenBSD functions of the same name.
+
+changed slprintf() to take buffer length rather than buffer length -1
+
+
+
+****************************************
+Date:	Sunday November 15, 1998 @ 10:32
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv24316
+
+Modified Files:
+	compat.c 
+Log Message:
+changed strlcat() and strlcpy() to have the same semantics as the
+OpenBSD functions of the same name.
+
+changed slprintf() to take buffer length rather than buffer length -1
+
+
+
+****************************************
+Date:	Sunday November 15, 1998 @ 10:49
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8967
+
+Modified Files:
+	configure configure.in 
+Log Message:
+compile with optimisation by default on all compilers
+(the mdfour code really needs it)
+
+
+
+****************************************
+Date:	Sunday November 15, 1998 @ 12:04
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv23497
+
+Modified Files:
+	config.h.in configure configure.in proto.h rsync.h util.c 
+Log Message:
+use native strlcat() and strlcpy() if available
+
+
+
+****************************************
+Date:	Sunday November 15, 1998 @ 12:04
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv65
+
+Modified Files:
+	compat.c 
+Log Message:
+use native strlcat() and strlcpy() if available
+
+
+
+****************************************
+Date:	Sunday November 15, 1998 @ 12:21
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv25906
+
+Modified Files:
+	cleanup.c log.c main.c proto.h rsync.h 
+Log Message:
+log filename(line) in exit_cleanup() to make tracking down problems
+easier in rsync daemons.
+
+
+
+
+
+****************************************
+Date:	Monday November 16, 1998 @ 14:53
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv4320
+
+Modified Files:
+	match.c 
+Log Message:
+fixed a bug handling files larger than 2GB 
+
+
+
+
+****************************************
+Date:	Tuesday November 17, 1998 @ 10:50
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv540
+
+Modified Files:
+	log.c 
+Log Message:
+don't interpret %h and %a when using --log-format locally
+
+
+
+****************************************
+Date:	Wednesday November 18, 1998 @ 8:56
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv12268
+
+Modified Files:
+	clientserver.c proto.h util.c 
+Log Message:
+Apply sanitize_paths() to glob expansions when use chroot = no.
+
+
+
+****************************************
+Date:	Thursday November 19, 1998 @ 2:54
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv19230
+
+Modified Files:
+	rsync.1 rsync.c rsync.yo 
+Log Message:
+Change documentation to explain that a lack of -t in effect causes -I to be
+assumed on the next transfer.
+
+
+
+****************************************
+Date:	Thursday November 19, 1998 @ 3:02
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv14060
+
+Modified Files:
+	rsync.c 
+Log Message:
+Remove a debugging statement I accidentally included in the last commit.
+
+
+
+****************************************
+Date:	Thursday November 19, 1998 @ 3:20
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv7193
+
+Modified Files:
+	rsync.1 rsync.yo rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+Change --log-format documentation to make it clear that it is for the client
+logging to stdout.
+
+
+
+****************************************
+Date:	Thursday November 19, 1998 @ 4:36
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv1740
+
+Modified Files:
+	README options.c rsync.1 rsync.yo rsyncd.conf.yo 
+	tech_report.tex 
+Log Message:
+Minor documentation patches, due mostly to
+    Jason Henry Parker <henry@freezer.humbug.org.au>
+
+
+
+****************************************
+Date:	Thursday November 19, 1998 @ 4:53
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv5456
+
+Modified Files:
+	configure configure.in 
+Log Message:
+Look for strcasecmp in -lresolv for Unixware.
+
+
+
+****************************************
+Date:	Thursday November 19, 1998 @ 17:35
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20651
+
+Modified Files:
+	clientserver.c loadparm.c options.c proto.h rsyncd.conf.5 
+	rsyncd.conf.yo 
+Log Message:
+added "refuse options" option
+
+
+
+
+
+
+****************************************
+Date:	Thursday November 19, 1998 @ 17:45
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv12782
+
+Modified Files:
+	options.c 
+Log Message:
+improved the "refuse options" code a bit
+
+
+
+
+
+
+
+****************************************
+Date:	Saturday November 21, 1998 @ 9:26
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv25505
+
+Modified Files:
+	loadparm.c proto.h rsyncd.conf.5 rsyncd.conf.yo sender.c 
+	token.c 
+Log Message:
+added "dont compress" option with the default setting of
+	*.gz *.tgz *.zip *.z *.rpm *.deb
+
+
+
+****************************************
+Date:	Saturday November 21, 1998 @ 9:46
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv24322
+
+Modified Files:
+	rsyncd.conf.yo 
+Log Message:
+changed an example slightly
+
+
+
+****************************************
+Date:	Monday November 23, 1998 @ 11:30
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8200
+
+Modified Files:
+	README options.c rsync.yo rsyncd.conf.yo rsyncstats 
+	tech_report.tex 
+Log Message:
+updates to reflect new samba.org domain
+the main web site is now http://rsync.samba.org/
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Monday November 23, 1998 @ 11:30
+Author:	tridge
+
+Update of /data/cvs/rsync/lib
+In directory samba:/tmp/cvs-serv16340
+
+Modified Files:
+	snprintf.c 
+Log Message:
+updates to reflect new samba.org domain
+the main web site is now http://rsync.samba.org/
+
+
+
+
+
+
+
+
+
+****************************************
+Date:	Tuesday November 24, 1998 @ 8:54
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv14273
+
+Modified Files:
+	clientserver.c exclude.c loadparm.c proto.h rsyncd.conf.5 
+	rsyncd.conf.yo 
+Log Message:
+Add "include" and "include from" rsyncd.conf options.  Contributed
+by Dennis Gilbert <dennis@oit.pdx.edu>.
+
+
+
+****************************************
+Date:	Wednesday November 25, 1998 @ 6:01
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv9326
+
+Modified Files:
+	proto.h receiver.c rsync.c 
+Log Message:
+Backup deleted files when using --delete and --backup.  Based on a 
+suggested patch from Kanai Makoto (kanai@hallab.co.jp).
+
+
+
+****************************************
+Date:	Wednesday November 25, 1998 @ 6:10
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv21637
+
+Modified Files:
+	syscall.c 
+Log Message:
+Always add the O_BINARY flag in do_open if it is defined, for Windows.
+Suggestion from Mart.Laak@hansa.ee
+
+
+
+****************************************
+Date:	Wednesday November 25, 1998 @ 6:52
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv27835
+
+Modified Files:
+	authenticate.c 
+Log Message:
+Make sure secrets file is not other-accessible, and owned by root if the
+daemon is running as root.  Suggested by
+    Mike Richardson <mike@quaking.demon.co.uk>
+
+
+
+****************************************
+Date:	Wednesday November 25, 1998 @ 7:18
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv26017
+
+Modified Files:
+	clientserver.c proto.h util.c 
+Log Message:
+Change sanitize_path() function to not malloc a copy since it only shrinks
+paths and it is only used in places that have already just done a copy.
+
+
+
+****************************************
+Date:	Wednesday November 25, 1998 @ 7:51
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv20568
+
+Modified Files:
+	flist.c 
+Log Message:
+Don't list cleaned-out duplicate file names as "<NULL>" when doing
+list_only mode; skip them instead.
+
+
+
+****************************************
+Date:	Wednesday November 25, 1998 @ 7:54
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv873
+
+Modified Files:
+	README 
+Log Message:
+Update the README file to reflect current usage options.
+
+
+
+****************************************
+Date:	Wednesday November 25, 1998 @ 8:26
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv16018
+
+Modified Files:
+	exclude.c rsync.1 rsync.yo rsyncd.conf.5 rsyncd.conf.yo 
+Log Message:
+Always include "." when processing exclude lists.  This avoids confusion
+when people do --exclude "*".  Also, add an example to the man page that
+shows explicitly including parent directories when itemizing specific
+paths to include followed by --exclude "*".
+
+
+
+****************************************
+Date:	Wednesday November 25, 1998 @ 9:03
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv3828
+
+Modified Files:
+	options.c rsyncd.conf.5 rsyncd.conf.yo token.c 
+Log Message:
+When "refuse options = compress" is set in rsyncd.conf, silently send files
+at compression level 0 instead of printing an error and exitting.  This is
+the same effect as "dont compress = *".
+
+
+
+****************************************
+Date:	Thursday November 26, 1998 @ 2:37
+Author:	dwd
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv8544
+
+Modified Files:
+	options.c rsyncd.conf.5 rsyncd.conf.yo token.c 
+Log Message:
+Back out change that treated "refuse options = compress" the same as
+"dont compress = *", by request of Tridge.  Instead, mention the difference
+in the man page.  Also, put in a shortcut in set_compression() to recognize
+"*" earlier instead of going through malloc/strtok/fnmatch/free cycle.
+
+
+
+****************************************
+Date:	Thursday November 26, 1998 @ 3:24
+Author:	rsync-bu
+
+Update of /data/cvs/rsync
+In directory samba:/data/people/rsync-bugs/rsync
+
+Modified Files:
+	version.h 
+Log Message:
+preparing for release of 2.2.1
+
+
+****************************************
+Date:	Thursday November 26, 1998 @ 3:24
+Author:	rsync-bu
+
+Update of /data/cvs/rsync/packaging/redhat/5.0
+In directory samba:/data/people/rsync-bugs/rsync/packaging/redhat/5.0
+
+Modified Files:
+	rsync.spec 
+Log Message:
+preparing for release of 2.2.1
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/errcode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/errcode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/errcode.h	1998-11-03 15:08:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/errcode.h	1998-11-26 00:24:39.000000000 +0800
@@ -1,12 +1,12 @@
 /* error codes returned by rsync */
 
 #define RERR_SYNTAX     1       /* syntax or usage error */
 #define RERR_PROTOCOL   2       /* protocol incompatibility */
 #define RERR_FILESELECT 3       /* errors selecting input/output files, dirs */
-#define RERR_NOSUPPORT  4       /* requested action not supported */
+#define RERR_UNSUPPORTED 4       /* requested action not supported */
 
 #define RERR_SOCKETIO   10      /* error in socket IO */
 #define RERR_FILEIO     11      /* error in file IO */
 #define RERR_STREAMIO   12      /* error in rsync protocol data stream */
 #define RERR_MESSAGEIO  13      /* errors with program diagnostics */
 #define RERR_IPC        14      /* error in IPC code */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/exclude.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/exclude.c	1998-11-26 00:24:39.000000000 +0800
@@ -157,12 +157,16 @@
 
 int check_exclude(char *name,struct exclude_struct **local_exclude_list,
 		  STRUCT_STAT *st)
 {
 	int n;
 
+	if (name && (name[0] == '.') && !name[1])
+		/* never exclude '.', even if somebody does --exclude '*' */
+		return 0;
+
 	if (exclude_list) {
 		for (n=0; exclude_list[n]; n++)
 			if (check_one_exclude(name,exclude_list[n],st))
 				return !exclude_list[n]->include;
 	}
 
@@ -261,13 +265,13 @@
 
 		l = strlen(pattern);
 		if (l == 0) continue;
 		if (exclude_list[i]->include) {
 			if (remote_version < 19) {
 				rprintf(FERROR,"remote rsync does not support include syntax - aborting\n");
-				exit_cleanup(RERR_NOSUPPORT);
+				exit_cleanup(RERR_UNSUPPORTED);
 			}
 			write_int(f,l+2);
 			write_buf(f,"+ ",2);
 		} else {
 			write_int(f,l);
 		}
@@ -298,12 +302,23 @@
 	if (!p) out_of_memory("add_exclude_line");
 	for (tok=strtok(p," "); tok; tok=strtok(NULL," "))
 		add_exclude(tok, 0);
 	free(p);
 }
 
+void add_include_line(char *p)
+{
+	char *tok;
+	if (!p || !*p) return;
+	p = strdup(p);
+	if (!p) out_of_memory("add_include_line");
+	for (tok=strtok(p," "); tok; tok=strtok(NULL," "))
+		add_exclude(tok, 1);
+	free(p);
+}
+
 
 static char *cvs_ignore_list[] = {
   "RCS","SCCS","CVS","CVS.adm","RCSLOG","cvslog.*",
   "tags","TAGS",".make.state",".nse_depinfo",
   "*~", "#*", ".#*", ",*", "*.old", "*.bak", "*.BAK", "*.orig",
   "*.rej", ".del-*", "*.a", "*.o", "*.obj", "*.so", "*.Z", "*.elc", "*.ln",
@@ -318,12 +333,12 @@
 	int i;
   
 	for (i=0; cvs_ignore_list[i]; i++)
 		add_exclude(cvs_ignore_list[i], 0);
 
 	if ((p=getenv("HOME")) && strlen(p) < (MAXPATHLEN-12)) {
-		slprintf(fname,sizeof(fname)-1, "%s/.cvsignore",p);
+		slprintf(fname,sizeof(fname), "%s/.cvsignore",p);
 		add_exclude_file(fname,0,0);
 	}
 
 	add_exclude_line(getenv("CVSIGNORE"));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/flist.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/flist.c	1998-11-26 00:24:39.000000000 +0800
@@ -55,12 +55,16 @@
 static void list_file_entry(struct file_struct *f)
 {
 	char perms[11] = "----------";
 	char *perm_map = "rwxrwxrwx";
 	int i;
 
+	if (!f->basename)
+		/* this can happen if duplicate names were removed */
+		return;
+
 	for (i=0;i<9;i++) {
 		if (f->mode & (1<<i)) perms[9-i] = perm_map[8-i];
 	}
 	if (S_ISLNK(f->mode)) perms[0] = 'l';
 	if (S_ISDIR(f->mode)) perms[0] = 'd';
 	if (S_ISBLK(f->mode)) perms[0] = 'b';
@@ -227,13 +231,13 @@
 	last_mode = file->mode;
 	last_rdev = file->rdev;
 	last_uid = file->uid;
 	last_gid = file->gid;
 	last_time = file->modtime;
 
-	strlcpy(lastname,fname,MAXPATHLEN-1);
+	strlcpy(lastname,fname,MAXPATHLEN);
 	lastname[MAXPATHLEN-1] = 0;
 }
 
 
 
 static void receive_file_entry(struct file_struct **fptr,
@@ -262,17 +266,17 @@
 	if (!file) out_of_memory("receive_file_entry");
 	memset((char *)file, 0, sizeof(*file));
 	(*fptr) = file;
 
 	if (l2 >= MAXPATHLEN-l1) overflow("receive_file_entry");
 
-	strlcpy(thisname,lastname,l1);
+	strlcpy(thisname,lastname,l1+1);
 	read_sbuf(f,&thisname[l1],l2);
 	thisname[l1+l2] = 0;
 
-	strlcpy(lastname,thisname,MAXPATHLEN-1);
+	strlcpy(lastname,thisname,MAXPATHLEN);
 	lastname[MAXPATHLEN-1] = 0;
 
 	clean_fname(thisname);
 
 	if ((p = strrchr(thisname,'/'))) {
 		static char *lastdir;
@@ -367,13 +371,13 @@
 	struct file_struct *file;
 	STRUCT_STAT st;
 	char sum[SUM_LENGTH];
 	char *p;
 	char cleaned_name[MAXPATHLEN];
 
-	strlcpy(cleaned_name, fname, MAXPATHLEN-1);
+	strlcpy(cleaned_name, fname, MAXPATHLEN);
 	cleaned_name[MAXPATHLEN-1] = 0;
 	clean_fname(cleaned_name);
 	fname = cleaned_name;
 
 	memset(sum,0,SUM_LENGTH);
 
@@ -528,22 +532,22 @@
 		io_error = 1;
 		rprintf(FERROR,"opendir(%s): %s\n",
 			dir,strerror(errno));
 		return;
 	}
 
-	strlcpy(fname,dir,MAXPATHLEN-1);
+	strlcpy(fname,dir,MAXPATHLEN);
 	l = strlen(fname);
 	if (fname[l-1] != '/') {
 		if (l == MAXPATHLEN-1) {
 			io_error = 1;
 			rprintf(FERROR,"skipping long-named directory %s\n",fname);
 			closedir(d);
 			return;
 		}
-		strlcat(fname,"/", MAXPATHLEN-1);
+		strlcat(fname,"/", MAXPATHLEN);
 		l++;
 	}
 	p = fname + strlen(fname);
 
 	local_exclude_list = NULL;
 
@@ -559,13 +563,13 @@
 	
 	for (di=readdir(d); di; di=readdir(d)) {
 		char *dname = d_name(di);
 		if (strcmp(dname,".")==0 ||
 		    strcmp(dname,"..")==0)
 			continue;
-		strlcpy(p,dname,MAXPATHLEN-(l+1));
+		strlcpy(p,dname,MAXPATHLEN-l);
 		send_file_name(f,flist,fname,recurse,0);
 	}
 
 	if (local_exclude_list) {
 		add_exclude_list("!", &local_exclude_list, 0);
 	}
@@ -605,17 +609,17 @@
 	}
 
 	for (i=0;i<argc;i++) {
 		char fname2[MAXPATHLEN];
 		char *fname = fname2;
 
-		strlcpy(fname,argv[i],MAXPATHLEN-1);
+		strlcpy(fname,argv[i],MAXPATHLEN);
 
 		l = strlen(fname);
 		if (l != 1 && fname[l-1] == '/') {
-			strlcat(fname,".",MAXPATHLEN-1);
+			strlcat(fname,".",MAXPATHLEN);
 		}
 
 		if (link_stat(fname,&st) != 0) {
 			io_error=1;
 			rprintf(FERROR,"%s : %s\n",fname,strerror(errno));
 			continue;
@@ -641,13 +645,13 @@
 			}
 		} else if (f != -1 && (p=strrchr(fname,'/'))) {
 			/* this ensures we send the intermediate directories,
 			   thus getting their permissions right */
 			*p = 0;
 			if (strcmp(lastpath,fname)) {
-				strlcpy(lastpath, fname, sizeof(lastpath)-1);
+				strlcpy(lastpath, fname, sizeof(lastpath));
 				*p = '/';
 				for (p=fname+1; (p=strchr(p,'/')); p++) {
 					int copy_links_saved = copy_links;
 					*p = 0;
 					copy_links = 0;
 					send_file_name(f, flist, fname, 0, 0);
@@ -953,16 +957,16 @@
 
 	if (!f || !f->basename) return NULL;
 
 	n = (n+1)%10;
 
 	if (f->dirname) {
-		strlcpy(p, f->dirname, MAXPATHLEN-1);
-		strlcat(p, "/", MAXPATHLEN-1);
-		strlcat(p, f->basename, MAXPATHLEN-1);
+		strlcpy(p, f->dirname, MAXPATHLEN);
+		strlcat(p, "/", MAXPATHLEN);
+		strlcat(p, f->basename, MAXPATHLEN);
 	} else {
-		strlcpy(p, f->basename, MAXPATHLEN-1);
+		strlcpy(p, f->basename, MAXPATHLEN);
 	}
 
 	return p;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/generator.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/generator.c	1998-11-26 00:24:40.000000000 +0800
@@ -270,13 +270,13 @@
 
 	fnamecmp = fname;
 
 	if ((statret == -1) && (compare_dest != NULL)) {
 		/* try the file at compare_dest instead */
 		int saveerrno = errno;
-		slprintf(fnamecmpbuf,MAXPATHLEN-1,"%s/%s",compare_dest,fname);
+		slprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",compare_dest,fname);
 		statret = link_stat(fnamecmpbuf,&st);
 		if (!S_ISREG(st.st_mode))
 			statret = -1;
 		if (statret == -1)
 			errno = saveerrno;
 		else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/io.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/io.c	1998-11-26 00:24:40.000000000 +0800
@@ -535,13 +535,13 @@
 {
 	va_list ap;  
 	char buf[1024];
 	int len;
 	
 	va_start(ap, format);
-	len = vslprintf(buf, sizeof(buf)-1, format, ap);
+	len = vslprintf(buf, sizeof(buf), format, ap);
 	va_end(ap);
 
 	if (len < 0) exit_cleanup(RERR_STREAMIO);
 
 	write_sbuf(fd, buf);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib/compat.c	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/lib/compat.c	1998-11-26 00:24:41.000000000 +0800
@@ -33,40 +33,40 @@
     strcpy(ret,s);
   return ret;
 }
 #endif
 
 #ifndef HAVE_GETCWD
-char *getcwd(char *buf, int size)
+ char *getcwd(char *buf, int size)
 {
 	return getwd(buf);
 }
 #endif
 
 
 #ifndef HAVE_WAITPID
-pid_t waitpid(pid_t pid, int *statptr, int options)
+ pid_t waitpid(pid_t pid, int *statptr, int options)
 {
 	return wait4(pid, statptr, options, NULL);
 }
 #endif
 
 
 #ifndef HAVE_MEMMOVE
-void *memmove(void *dest, const void *src, size_t n)
+ void *memmove(void *dest, const void *src, size_t n)
 {
 	memcpy(dest, src, n);
 	return dest;
 }
 #endif
 
 #ifndef HAVE_STRPBRK
 /* Find the first ocurrence in S of any character in ACCEPT.  
    derived from glibc 
 */
-char *strpbrk(const char *s, const char *accept)
+ char *strpbrk(const char *s, const char *accept)
 {
 	while (*s != '\0')  {
 		const char *a = accept;
 		while (*a != '\0') {
 			if (*a++ == *s)	return (char *)s;
 		}
@@ -75,20 +75,55 @@
 
 	return NULL;
 }
 #endif
 
 #ifdef REPLACE_INET_NTOA
-char *rep_inet_ntoa(struct in_addr ip)
+ char *rep_inet_ntoa(struct in_addr ip)
 {
 	unsigned char *p = (unsigned char *)&ip.s_addr;
 	static char buf[18];
 #if WORDS_BIGENDIAN
-	slprintf(buf, 17, "%d.%d.%d.%d", 
+	slprintf(buf, 18, "%d.%d.%d.%d", 
 		 (int)p[0], (int)p[1], (int)p[2], (int)p[3]);
 #else
-	slprintf(buf, 17, "%d.%d.%d.%d", 
+	slprintf(buf, 18, "%d.%d.%d.%d", 
 		 (int)p[3], (int)p[2], (int)p[1], (int)p[0]);
 #endif
 	return buf;
 }
 #endif
+
+#ifndef HAVE_STRLCPY
+/* like strncpy but does not 0 fill the buffer and always null 
+   terminates. bufsize is the size of the destination buffer */
+ size_t strlcpy(char *d, const char *s, size_t bufsize)
+{
+	size_t len = strlen(s);
+	size_t ret = len;
+	if (len >= bufsize) len = bufsize-1;
+	memcpy(d, s, len);
+	d[len] = 0;
+	return ret;
+}
+#endif
+
+#ifndef HAVE_STRLCAT
+/* like strncat but does not 0 fill the buffer and always null 
+   terminates. bufsize is the length of the buffer, which should
+   be one more than the maximum resulting string length */
+ size_t strlcat(char *d, const char *s, size_t bufsize)
+{
+	size_t len1 = strlen(d);
+	size_t len2 = strlen(s);
+	size_t ret = len1 + len2;
+
+	if (len1+len2 >= bufsize) {
+		len2 = bufsize - (len1+1);
+	}
+	if (len2 > 0) {
+		memcpy(d+len1, s, len2);
+		d[len1+len2] = 0;
+	}
+	return ret;
+}
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib/mdfour.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/lib/mdfour.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib/mdfour.c	1998-10-29 14:39:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/lib/mdfour.c	1998-11-26 00:24:41.000000000 +0800
@@ -25,36 +25,20 @@
 
    It assumes that a int is at least 32 bits long
 */
 
 static struct mdfour *m;
 
-static inline uint32 F(uint32 X, uint32 Y, uint32 Z)
-{
-	return (X&Y) | ((~X)&Z);
-}
-
-static inline uint32 G(uint32 X, uint32 Y, uint32 Z)
-{
-	return (X&Y) | (X&Z) | (Y&Z); 
-}
-
-static inline uint32 H(uint32 X, uint32 Y, uint32 Z)
-{
-	return X^Y^Z;
-}
-
-static inline uint32 lshift(uint32 x, int s)
-{
+#define F(X,Y,Z) (((X)&(Y)) | ((~(X))&(Z)))
+#define G(X,Y,Z) (((X)&(Y)) | ((X)&(Z)) | ((Y)&(Z)))
+#define H(X,Y,Z) ((X)^(Y)^(Z))
 #ifdef LARGE_INT32
-	x &= 0xFFFFFFFF;
-	return ((x<<s)&0xFFFFFFFF) | (x>>(32-s));
+#define lshift(x,s) ((((x)<<(s))&0xFFFFFFFF) | (((x)>>(32-(s)))&0xFFFFFFFF))
 #else
-	return ((x<<s) | (x>>(32-s)));
+#define lshift(x,s) (((x)<<(s)) | ((x)>>(32-(s))))
 #endif
-}
 
 #define ROUND1(a,b,c,d,k,s) a = lshift(a + F(b,c,d) + X[k], s)
 #define ROUND2(a,b,c,d,k,s) a = lshift(a + G(b,c,d) + X[k] + 0x5A827999,s)
 #define ROUND3(a,b,c,d,k,s) a = lshift(a + H(b,c,d) + X[k] + 0x6ED9EBA1,s)
 
 /* this applies md4 to 64 byte chunks */
@@ -206,14 +190,14 @@
 
 #ifdef TEST_MDFOUR
 static void file_checksum1(char *fname)
 {
 	int fd, i;
 	struct mdfour md;
-	unsigned char buf[64], sum[16];
-
+	unsigned char buf[64*1024], sum[16];
+	
 	fd = open(fname,O_RDONLY);
 	if (fd == -1) {
 		perror("fname");
 		exit(1);
 	}
 	
@@ -231,12 +215,13 @@
 
 	for (i=0;i<16;i++)
 		printf("%02X", sum[i]);
 	printf("\n");
 }
 
+#if 0
 #include "../md4.h"
 
 static void file_checksum2(char *fname)
 {
 	int fd, i;
 	MDstruct md;
@@ -265,14 +250,17 @@
 	memcpy(sum, md.buffer, 16);
 
 	for (i=0;i<16;i++)
 		printf("%02X", sum[i]);
 	printf("\n");
 }
+#endif
 
  int main(int argc, char *argv[])
 {
 	file_checksum1(argv[1]);
+#if 0
 	file_checksum2(argv[1]);
+#endif
 	return 0;
 }
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib/snprintf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/lib/snprintf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/lib/snprintf.c	1998-10-31 12:35:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/lib/snprintf.c	1998-11-26 00:24:41.000000000 +0800
@@ -42,13 +42,13 @@
  *
  *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
  *    The original code assumed that both snprintf() and vsnprintf() were
  *    missing.  Some systems only have snprintf() but not vsnprintf(), so
  *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
  *
- *  Andrew Tridgell (tridge@samba.anu.edu.au) Oct 1998
+ *  Andrew Tridgell (tridge@samba.org) Oct 1998
  *    fixed handling of %.0f
  *    added test for HAVE_LONG_DOUBLE
  *
  **************************************************************/
 
 #include "config.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/loadparm.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/loadparm.c	1998-11-26 00:24:40.000000000 +0800
@@ -48,13 +48,13 @@
 #define False 0
 #define True 1
 #define PTR_DIFF(p1,p2) ((ptrdiff_t)(((char *)(p1)) - (char *)(p2)))
 #define strequal(a,b) (strcasecmp(a,b)==0)
 #define BOOLSTR(b) ((b) ? "Yes" : "No")
 typedef char pstring[1024];
-#define pstrcpy(a,b) strlcpy(a,b,sizeof(pstring)-1)
+#define pstrcpy(a,b) strlcpy(a,b,sizeof(pstring))
 
 /* the following are used by loadparm for option lists */
 typedef enum
 {
 	P_BOOL,P_BOOLREV,P_CHAR,P_INTEGER,P_OCTAL,
 	P_STRING,P_GSTRING,P_ENUM,P_SEP
@@ -126,13 +126,18 @@
 	char *hosts_allow;
 	char *hosts_deny;
 	char *auth_users;
 	char *secrets_file;
 	char *exclude;
 	char *exclude_from;
+	char *include;
+	char *include_from;
 	char *log_format;
+	char *refuse_options;
+	char *dont_compress;
+	int timeout;
 } service;
 
 
 /* This is a default service used to prime a services structure */
 static service sDefault = 
 {
@@ -148,13 +153,18 @@
 	NULL,    /* hosts allow */
 	NULL,    /* hosts deny */
 	NULL,    /* auth users */
 	NULL,    /* secrets file */
 	NULL,    /* exclude */
 	NULL,    /* exclude from */
+	NULL,    /* include */
+	NULL,    /* include from */
 	"%o %h [%a] %m (%u) %f %l",    /* log format */
+	NULL,    /* refuse options */
+	"*.gz *.tgz *.zip *.z *.rpm *.deb",    /* dont compress */
+	0        /* timeout */
 };
 
 
 
 /* local variables */
 static service **ServicePtrs = NULL;
@@ -239,12 +249,13 @@
   {"lock file",        P_STRING,  P_GLOBAL, &Globals.lock_file,    NULL,   0},
   {"syslog facility",  P_ENUM,    P_GLOBAL, &Globals.syslog_facility, enum_facilities,0},
   {"socket options",   P_STRING,  P_GLOBAL, &Globals.socket_options,NULL,  0},
   {"log file",         P_STRING,  P_GLOBAL, &Globals.log_file,      NULL,  0},
   {"pid file",         P_STRING,  P_GLOBAL, &Globals.pid_file,      NULL,  0},
 
+  {"timeout",          P_INTEGER, P_LOCAL,  &sDefault.timeout,     NULL,  0},
   {"name",             P_STRING,  P_LOCAL,  &sDefault.name,        NULL,   0},
   {"comment",          P_STRING,  P_LOCAL,  &sDefault.comment,     NULL,   0},
   {"path",             P_STRING,  P_LOCAL,  &sDefault.path,        NULL,   0},
   {"read only",        P_BOOL,    P_LOCAL,  &sDefault.read_only,   NULL,   0},
   {"list",             P_BOOL,    P_LOCAL,  &sDefault.list,        NULL,   0},
   {"use chroot",       P_BOOL,    P_LOCAL,  &sDefault.use_chroot,  NULL,   0},
@@ -253,14 +264,18 @@
   {"hosts allow",      P_STRING,  P_LOCAL,  &sDefault.hosts_allow, NULL,   0},
   {"hosts deny",       P_STRING,  P_LOCAL,  &sDefault.hosts_deny,  NULL,   0},
   {"auth users",       P_STRING,  P_LOCAL,  &sDefault.auth_users,  NULL,   0},
   {"secrets file",     P_STRING,  P_LOCAL,  &sDefault.secrets_file,NULL,   0},
   {"exclude",          P_STRING,  P_LOCAL,  &sDefault.exclude,     NULL,   0},
   {"exclude from",     P_STRING,  P_LOCAL,  &sDefault.exclude_from,NULL,   0},
+  {"include",          P_STRING,  P_LOCAL,  &sDefault.include,     NULL,   0},
+  {"include from",     P_STRING,  P_LOCAL,  &sDefault.include_from,NULL,   0},
   {"transfer logging", P_BOOL,    P_LOCAL,  &sDefault.transfer_logging,NULL,0},
   {"log format",       P_STRING,  P_LOCAL,  &sDefault.log_format,  NULL,   0},
+  {"refuse options",   P_STRING,  P_LOCAL,  &sDefault.refuse_options,NULL, 0},
+  {"dont compress",    P_STRING,  P_LOCAL,  &sDefault.dont_compress,NULL,  0},
   {NULL,               P_BOOL,    P_NONE,   NULL,                  NULL,   0}
 };
 
 
 /***************************************************************************
 Initialise the global parameter structure.
@@ -326,13 +341,18 @@
 FN_LOCAL_STRING(lp_hosts_allow, hosts_allow)
 FN_LOCAL_STRING(lp_hosts_deny, hosts_deny)
 FN_LOCAL_STRING(lp_auth_users, auth_users)
 FN_LOCAL_STRING(lp_secrets_file, secrets_file)
 FN_LOCAL_STRING(lp_exclude, exclude)
 FN_LOCAL_STRING(lp_exclude_from, exclude_from)
+FN_LOCAL_STRING(lp_include, include)
+FN_LOCAL_STRING(lp_include_from, include_from)
 FN_LOCAL_STRING(lp_log_format, log_format)
+FN_LOCAL_STRING(lp_refuse_options, refuse_options)
+FN_LOCAL_STRING(lp_dont_compress, dont_compress)
+FN_LOCAL_INTEGER(lp_timeout, timeout)
 
 /* local prototypes */
 static int    strwicmp( char *psz1, char *psz2 );
 static int    map_parameter( char *parmname);
 static BOOL   set_boolean( BOOL *pb, char *parmvalue );
 static int    getservicebyname(char *name, service *pserviceDest);
@@ -445,13 +465,13 @@
      return(-1);
 
    for (iIndex = 0; parm_table[iIndex].label; iIndex++) 
       if (strwicmp(parm_table[iIndex].label, parmname) == 0)
          return(iIndex);
 
-   rprintf(FERROR, "Unknown parameter encountered: \"%s\"\n", parmname);
+   rprintf(FERROR, "Unknown Parameter encountered: \"%s\"\n", parmname);
    return(-1);
 }
 
 
 /***************************************************************************
 Set a boolean variable from the text value stored in the passed string.
@@ -557,13 +577,13 @@
    void *def_ptr=NULL;
 
    parmnum = map_parameter(parmname);
 
    if (parmnum < 0)
      {
-       rprintf(FERROR, "Ignoring unknown parameter \"%s\"\n", parmname);
+       rprintf(FERROR, "IGNORING unknown parameter \"%s\"\n", parmname);
        return(True);
      }
 
    def_ptr = parm_table[parmnum].ptr;
 
    /* we might point at a service, the default service or a global */
@@ -603,13 +623,13 @@
 
      case P_STRING:
        string_set(parm_ptr,parmvalue);
        break;
 
      case P_GSTRING:
-       strlcpy((char *)parm_ptr,parmvalue,sizeof(pstring)-1);
+       strlcpy((char *)parm_ptr,parmvalue,sizeof(pstring));
        break;
 
      case P_ENUM:
 	     for (i=0;parm_table[parmnum].enum_list[i].name;i++) {
 		     if (strequal(parmvalue, parm_table[parmnum].enum_list[i].name)) {
 			     *(int *)parm_ptr = parm_table[parmnum].enum_list[i].value;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/log.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/log.c	1998-11-26 00:24:40.000000000 +0800
@@ -87,13 +87,13 @@
 	int len;
 	FILE *f=NULL;
 	extern int am_daemon;
 	/* recursion can happen with certain fatal conditions */
 
 	va_start(ap, format);
-	len = vslprintf(buf, sizeof(buf)-1, format, ap);
+	len = vslprintf(buf, sizeof(buf), format, ap);
 	va_end(ap);
 
 	if (len < 0) exit_cleanup(RERR_MESSAGEIO);
 
 	if (len > sizeof(buf)-1) exit_cleanup(RERR_MESSAGEIO);
 
@@ -183,37 +183,38 @@
 	char buf[1024];
 	char buf2[1024];
 	char *p, *s, *n;
 	int l;
 	extern struct stats stats;		
 	extern int am_sender;
+	extern int am_daemon;
 	int64 b;
 
-	strlcpy(buf, format, sizeof(buf)-1);
+	strlcpy(buf, format, sizeof(buf));
 	
 	for (s=&buf[0]; 
 	     s && (p=strchr(s,'%')); ) {
 		n = NULL;
 		s = p + 1;
 
 		switch (p[1]) {
-		case 'h': n = client_name(0); break;
-		case 'a': n = client_addr(0); break;
+		case 'h': if (am_daemon) n = client_name(0); break;
+		case 'a': if (am_daemon) n = client_addr(0); break;
 		case 'l': 
-			slprintf(buf2,sizeof(buf2)-1,"%.0f", 
+			slprintf(buf2,sizeof(buf2),"%.0f", 
 				 (double)file->length); 
 			n = buf2;
 			break;
 		case 'p': 
-			slprintf(buf2,sizeof(buf2)-1,"%d", 
+			slprintf(buf2,sizeof(buf2),"%d", 
 				 (int)getpid()); 
 			n = buf2;
 			break;
 		case 'o': n = op; break;
 		case 'f': 
-			slprintf(buf2, sizeof(buf2)-1, "%s/%s", 
+			slprintf(buf2, sizeof(buf2), "%s/%s", 
 				 file->basedir?file->basedir:"", 
 				 f_name(file));
 			clean_fname(buf2);
 			n = buf2; 
 			if (*n == '/') n++;
 			break;
@@ -226,24 +227,24 @@
 				b = stats.total_written - 
 					initial_stats->total_written;
 			} else {
 				b = stats.total_read - 
 					initial_stats->total_read;
 			}
-			slprintf(buf2,sizeof(buf2)-1,"%.0f", (double)b); 
+			slprintf(buf2,sizeof(buf2),"%.0f", (double)b); 
 			n = buf2;
 			break;
 		case 'c': 
 			if (!am_sender) {
 				b = stats.total_written - 
 					initial_stats->total_written;
 			} else {
 				b = stats.total_read - 
 					initial_stats->total_read;
 			}
-			slprintf(buf2,sizeof(buf2)-1,"%.0f", (double)b); 
+			slprintf(buf2,sizeof(buf2),"%.0f", (double)b); 
 			n = buf2;
 			break;
 		}
 
 		if (!n) continue;
 
@@ -292,31 +293,32 @@
 	} else if (log_format && !am_server) {
 		log_formatted(FINFO, log_format, "send", file, initial_stats);
 	}
 }
 
 /* called when the transfer is interrupted for some reason */
-void log_exit(int code)
+void log_exit(int code, const char *file, int line)
 {
 	if (code == 0) {
 		extern struct stats stats;		
 		rprintf(FLOG,"wrote %.0f bytes  read %.0f bytes  total size %.0f\n",
 			(double)stats.total_written,
 			(double)stats.total_read,
 			(double)stats.total_size);
 	} else {
-		rprintf(FLOG,"transfer interrupted (code %d)\n", code);
+		rprintf(FLOG,"transfer interrupted (code %d) at %s(%d)\n", 
+			code, file, line);
 	}
 }
 
 /* log the incoming transfer of a file for interactive use, this
    will be called at the end where the client was run 
    
    it i called when a file starts to be transferred
 */
-void log_transfer(struct file_struct *file, char *fname)
+void log_transfer(struct file_struct *file, const char *fname)
 {
 	extern int verbose;
 
 	if (!verbose) return;
 
 	rprintf(FINFO,"%s\n", fname);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/main.c	1998-11-04 06:00:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/main.c	1998-11-26 00:24:40.000000000 +0800
@@ -33,13 +33,13 @@
 	extern int am_server;
 	extern int am_sender;
 	extern int am_daemon;
 	extern int do_stats;
 
 	if (am_daemon) {
-		log_exit(0);
+		log_exit(0, __FILE__, __LINE__);
 		if (f == -1 || !am_sender) return;
 	}
 
 	if (!verbose) return;
 
 	if (am_server && !am_sender) return;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/match.c	1998-07-17 22:46:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/match.c	1998-11-26 00:24:40.000000000 +0800
@@ -91,13 +91,13 @@
 
 
 static void matched(int f,struct sum_struct *s,struct map_struct *buf,
 		    OFF_T offset,int i)
 {
 	OFF_T n = offset - last_match;
-	int j;
+	OFF_T j;
 
 	if (verbose > 2 && i >= 0)
 		rprintf(FINFO,"match at %d last_match=%d j=%d len=%d n=%d\n",
 			(int)offset,(int)last_match,i,(int)s->sums[i].len,(int)n);
 
 	send_token(f,i,buf,last_match,n,i<0?0:s->sums[i].len);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/mkproto.awk /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/mkproto.awk
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/mkproto.awk	1998-05-14 15:07:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/mkproto.awk	1998-11-26 00:24:40.000000000 +0800
@@ -55,13 +55,13 @@
 }
 
 /^static|^extern/ || !/^[a-zA-Z]/ || /[;]/ {
   next;
 }
 
-!/^OFF_T|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^struct|^BOOL|^void|^time/ {
+!/^OFF_T|^size_t|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^struct|^BOOL|^void|^time/ {
   next;
 }
 
 
 /[(].*[)][ \t]*$/ {
     printf "%s;\n",$0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/options.c	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/options.c	1998-11-26 00:24:40.000000000 +0800
@@ -83,15 +83,15 @@
 
   rprintf(F,"rsync is a file transfer program capable of efficient remote update\nvia a fast differencing algorithm.\n\n");
 
   rprintf(F,"Usage: rsync [OPTION]... SRC [USER@]HOST:DEST\n");
   rprintf(F,"  or   rsync [OPTION]... [USER@]HOST:SRC DEST\n");
   rprintf(F,"  or   rsync [OPTION]... SRC DEST\n");
-  rprintf(F,"  or   rsync [OPTION]... [USER@]HOST::SRC DEST\n");
+  rprintf(F,"  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]\n");
   rprintf(F,"  or   rsync [OPTION]... SRC [USER@]HOST::DEST\n");
-  rprintf(F,"  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC DEST\n");
+  rprintf(F,"  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]\n");
   rprintf(F,"\nOptions\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
   rprintf(F," -c, --checksum              always checksum\n");
   rprintf(F," -a, --archive               archive mode\n");
   rprintf(F," -r, --recursive             recurse into directories\n");
   rprintf(F," -R, --relative              use relative path names\n");
@@ -139,13 +139,13 @@
 
   rprintf(F,"\n");
   rprintf(F,"the backup suffix defaults to %s\n",BACKUP_SUFFIX);
   rprintf(F,"the block size defaults to %d\n",BLOCK_SIZE);  
 
   rprintf(F,"\nPlease see the rsync(1) and rsyncd.conf(5) man pages for full documentation\n");
-  rprintf(F,"See http://samba.anu.edu.au/rsync/ for updates and bug reports\n");
+  rprintf(F,"See http://rsync.samba.org/ for updates and bug reports\n");
 }
 
 enum {OPT_VERSION,OPT_SUFFIX,OPT_SENDER,OPT_SERVER,OPT_EXCLUDE,
       OPT_EXCLUDE_FROM,OPT_DELETE,OPT_NUMERIC_IDS,OPT_RSYNC_PATH,
       OPT_FORCE,OPT_TIMEOUT,OPT_DAEMON,OPT_CONFIG,OPT_PORT,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_STATS, OPT_PARTIAL, OPT_PROGRESS,
@@ -202,20 +202,69 @@
   {"config",      1,     0,    OPT_CONFIG},
   {"port",        1,     0,    OPT_PORT},
   {"log-format",  1,     0,    OPT_LOG_FORMAT},
   {0,0,0,0}};
 
 
+static char err_buf[100];
+
+void option_error(void)
+{
+	if (err_buf[0]) {
+		rprintf(FLOG,"%s", err_buf);
+		rprintf(FERROR,"%s", err_buf);
+	} else {
+		rprintf(FLOG,"Error parsing options - unsupported option?\n");
+		rprintf(FERROR,"Error parsing options - unsupported option?\n");
+	}
+	exit_cleanup(RERR_UNSUPPORTED);
+}
+
+/* check to see if we should refuse this option */
+static int check_refuse_options(char *ref, int opt)
+{
+	int i, len;
+	char *p;
+	const char *name;
+
+	for (i=0; long_options[i].name; i++) {
+		if (long_options[i].val == opt) break;
+	}
+	
+	if (!long_options[i].name) return 0;
+
+	name = long_options[i].name;
+	len = strlen(name);
+
+	while ((p = strstr(ref,name))) {
+		if ((p==ref || p[-1]==' ') &&
+		    (p[len] == ' ' || p[len] == 0)) {
+			slprintf(err_buf,sizeof(err_buf),
+				 "The '%s' option is not supported by this server\n", name);
+			return 1;
+		}
+		ref += len;
+	}
+	return 0;
+}
+
+
 int parse_arguments(int argc, char *argv[])
 {
 	int opt;
 	int option_index;
+	char *ref = lp_refuse_options(module_id);
 
 	while ((opt = getopt_long(argc, argv, 
 				  short_options, long_options, &option_index)) 
 	       != -1) {
+
+		if (ref) {
+			if (check_refuse_options(ref, opt)) return 0;
+		}
+
 		switch (opt) {
 		case OPT_VERSION:
 			rprintf(FINFO,"rsync version %s  protocol version %d\n\n",
 				VERSION,PROTOCOL_VERSION);
 			rprintf(FINFO,"Written by Andrew Tridgell and Paul Mackerras\n");
 			exit_cleanup(0);
@@ -305,12 +354,13 @@
 			break;
 
 		case 'H':
 #if SUPPORT_HARD_LINKS
 			preserve_hard_links=1;
 #else 
+			slprintf(err_buf,sizeof(err_buf),"hard links are not supported on this server\n");
 			rprintf(FERROR,"ERROR: hard links not supported on this platform\n");
 			return 0;
 #endif
 			break;
 
 		case 'p':
@@ -425,12 +475,13 @@
 
 		case OPT_LOG_FORMAT:
 			log_format = optarg;
 			break;
 
 		default:
+			slprintf(err_buf,sizeof(err_buf),"unrecognised option\n");
 			return 0;
 		}
 	}
 	return 1;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/packaging/redhat/5.0/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/packaging/redhat/5.0/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/packaging/redhat/5.0/rsync.spec	1998-11-04 06:00:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/packaging/redhat/5.0/rsync.spec	1998-11-26 00:24:51.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.2.0
+Version: 2.2.1
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.2.0.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.2.1.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/proto.h	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/proto.h	1998-11-26 00:24:40.000000000 +0800
@@ -7,13 +7,13 @@
 void get_checksum2(char *buf,int len,char *sum);
 void file_checksum(char *fname,char *sum,OFF_T size);
 void checksum_init(void);
 void sum_init(void);
 void sum_update(char *p,int len);
 void sum_end(char *sum);
-void exit_cleanup(int code);
+void _exit_cleanup(int code, const char *file, int line);
 void cleanup_disable(void);
 void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
 		 struct map_struct *buf, int fd1, int fd2);
 void cleanup_set_pid(int pid);
 int start_socket_client(char *host, char *path, int argc, char *argv[]);
 int daemon_main(void);
@@ -28,12 +28,13 @@
 					  struct exclude_struct **list1,
 					  int fatal, int include);
 void add_exclude_file(char *fname,int fatal,int include);
 void send_exclude_list(int f);
 void recv_exclude_list(int f);
 void add_exclude_line(char *p);
+void add_include_line(char *p);
 void add_cvs_excludes(void);
 int sparse_end(int f);
 int write_file(int f,char *buf,int len);
 struct map_struct *map_file(int fd,OFF_T len);
 char *map_ptr(struct map_struct *map,OFF_T offset,int len);
 void unmap_file(struct map_struct *map);
@@ -89,39 +90,46 @@
 char *lp_hosts_allow(int );
 char *lp_hosts_deny(int );
 char *lp_auth_users(int );
 char *lp_secrets_file(int );
 char *lp_exclude(int );
 char *lp_exclude_from(int );
+char *lp_include(int );
+char *lp_include_from(int );
 char *lp_log_format(int );
+char *lp_refuse_options(int );
+char *lp_dont_compress(int );
+int lp_timeout(int );
 BOOL lp_load(char *pszFname, int globals_only);
 int lp_numservices(void);
 int lp_number(char *name);
 void log_open(void);
 void rflush(int fd);
 void log_send(struct file_struct *file, struct stats *initial_stats);
 void log_recv(struct file_struct *file, struct stats *initial_stats);
-void log_exit(int code);
-void log_transfer(struct file_struct *file, char *fname);
+void log_exit(int code, const char *file, int line);
+void log_transfer(struct file_struct *file, const char *fname);
 void start_server(int f_in, int f_out, int argc, char *argv[]);
 int client_run(int f_in, int f_out, int pid, int argc, char *argv[]);
 int main(int argc,char *argv[]);
 void match_sums(int f,struct sum_struct *s,struct map_struct *buf,OFF_T len);
 void match_report(void);
 void usage(int F);
+void option_error(void);
 int parse_arguments(int argc, char *argv[]);
 void server_options(char **args,int *argc);
 BOOL pm_process( char *FileName,
                  BOOL (*sfunc)(char *),
                  BOOL (*pfunc)(char *, char *) );
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen);
 void free_sums(struct sum_struct *s);
 int delete_file(char *fname);
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
 	      int report);
 void sig_int(void);
+int make_backup(char *fname);
 void finish_transfer(char *fname, char *fnametmp, struct file_struct *file);
 void send_files(struct file_list *flist,int f_out,int f_in);
 int open_socket_out(char *host, int port);
 int is_a_socket(int fd);
 void start_accept_loop(int port, int (*fn)(int ));
 void set_socket_options(int fd, char *options);
@@ -142,12 +150,13 @@
 int do_stat(const char *fname, STRUCT_STAT *st);
 int do_lstat(const char *fname, STRUCT_STAT *st);
 int do_fstat(int fd, STRUCT_STAT *st);
 OFF_T do_lseek(int fd, OFF_T offset, int whence);
 void *do_mmap(void *start, int len, int prot, int flags, int fd, OFF_T offset);
 char *d_name(struct dirent *di);
+void set_compression(char *fname);
 void send_token(int f,int token,struct map_struct *buf,OFF_T offset,
 		int n,int toklen);
 int recv_token(int f,char **data);
 void see_token(char *data, int toklen);
 void add_uid(uid_t uid);
 void add_gid(gid_t gid);
@@ -161,25 +170,23 @@
 int set_modtime(char *fname,time_t modtime);
 int create_directory_path(char *fname);
 int copy_file(char *source, char *dest, mode_t mode);
 void u_sleep(int usec);
 pid_t do_fork(void);
 void kill_all(int sig);
-void strlcpy(char *d, char *s, int maxlen);
-void strlcat(char *d, char *s, int maxlen);
 int name_to_uid(char *name, uid_t *uid);
 int name_to_gid(char *name, gid_t *gid);
 int lock_range(int fd, int offset, int len);
-void glob_expand(char *base1, char **argv, int *argc, int maxargs);
+void glob_expand(char *base1, char **argv, int *argc, int maxargs, int sanitize_paths);
 void strlower(char *s);
 int vslprintf(char *str, int n, const char *format, va_list ap);
 int slprintf(char *str, int n, char *format, ...);
 void *Realloc(void *p, int size);
 void clean_fname(char *name);
+void sanitize_path(char *p);
 char *push_dir(char *dir, int save);
 int pop_dir(char *dir);
 int u_strcmp(const char *cs1, const char *cs2);
 void end_progress(void);
 void show_progress(OFF_T ofs, OFF_T size);
 int unsafe_symlink(char *dest, char *src);
-char *sanitize_path(char *p);
 char *timestring(time_t t);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/README	1998-05-15 13:43:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/README	1998-11-26 00:24:39.000000000 +0800
@@ -17,59 +17,75 @@
 
 USAGE
 -----
 
 Basically you use rsync just like rcp, but rsync has many additional options.
 
-Here is a brief description of available options:
+Here is a brief description of rsync usage:
 
-Options:
--v, --verbose            increase verbosity
--c, --checksum           always checksum
--a, --archive            archive mode (same as -rlptDog)
--r, --recursive          recurse into directories
--R, --relative           use relative path names
--b, --backup             make backups (default ~ extension)
--u, --update             update only (don't overwrite newer files)
--l, --links              preserve soft links
--L, --copy-links         treat soft links like regular files
--H, --hard-links         preserve hard links
--p, --perms              preserve permissions
--o, --owner              preserve owner (root only)
--g, --group              preserve group
--D, --devices            preserve devices (root only)
--t, --times              preserve times
--S, --sparse             handle sparse files efficiently
--n, --dry-run            show what would have been transferred
--W, --whole-file         copy whole files, no incremental checks
--x, --one-file-system    don't cross filesystem boundaries
--B, --block-size SIZE    checksum blocking size
--e, --rsh COMMAND        specify rsh replacement
-    --rsync-path PATH    specify path to rsync on the remote machine
--C, --cvs-exclude        auto ignore files in the same way CVS does
-    --delete             delete files that don't exist on the sending side
-    --force              force deletion of directories even if not empty
-    --numeric-ids        don't map uid/gid values by user/group name
-    --timeout TIME       set IO timeout in seconds
--I, --ignore-times       don't exclude files that match length and time
--T  --temp-dir DIR       create temporary files in directory DIR
--z, --compress           compress file data
-    --exclude FILE       exclude file FILE
-    --exclude-from FILE  exclude files listed in FILE
-    --suffix SUFFIX      override backup suffix
-    --version            print version number
-    --daemon             run as a rsync daemon
-    --config FILE        specify alternate rsyncd.conf file
-    --port PORT          specify alternate rsyncd port number
+Usage: rsync [OPTION]... SRC [USER@]HOST:DEST
+  or   rsync [OPTION]... [USER@]HOST:SRC DEST
+  or   rsync [OPTION]... SRC DEST
+  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]
+  or   rsync [OPTION]... SRC [USER@]HOST::DEST
+  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
+
+Options
+ -v, --verbose               increase verbosity
+ -c, --checksum              always checksum
+ -a, --archive               archive mode
+ -r, --recursive             recurse into directories
+ -R, --relative              use relative path names
+ -b, --backup                make backups (default ~ extension)
+ -u, --update                update only (don't overwrite newer files)
+ -l, --links                 preserve soft links
+ -L, --copy-links            treat soft links like regular files
+     --safe-links            ignore links outside the destination tree
+ -H, --hard-links            preserve hard links
+ -p, --perms                 preserve permissions
+ -o, --owner                 preserve owner (root only)
+ -g, --group                 preserve group
+ -D, --devices               preserve devices (root only)
+ -t, --times                 preserve times
+ -S, --sparse                handle sparse files efficiently
+ -n, --dry-run               show what would have been transferred
+ -W, --whole-file            copy whole files, no incremental checks
+ -x, --one-file-system       don't cross filesystem boundaries
+ -B, --block-size=SIZE       checksum blocking size
+ -e, --rsh=COMMAND           specify rsh replacement
+     --rsync-path=PATH       specify path to rsync on the remote machine
+ -C, --cvs-exclude           auto ignore files in the same way CVS does
+     --delete                delete files that don't exist on the sending side
+     --partial               keep partially transferred files
+     --force                 force deletion of directories even if not empty
+     --numeric-ids           don't map uid/gid values by user/group name
+     --timeout=TIME          set IO timeout in seconds
+ -I, --ignore-times          don't exclude files that match length and time
+ -T  --temp-dir=DIR          create temporary files in directory DIR
+     --compare-dest=DIR      also compare destination files relative to DIR
+ -z, --compress              compress file data
+     --exclude=PATTERN       exclude files matching PATTERN
+     --exclude-from=FILE     exclude patterns listed in FILE
+     --include=PATTERN       don't exclude files matching PATTERN
+     --include-from=FILE     don't exclude patterns listed in FILE
+     --suffix=SUFFIX         override backup suffix
+     --version               print version number
+     --daemon                run as a rsync daemon
+     --config=FILE           specify alternate rsyncd.conf file
+     --port=PORT             specify alternate rsyncd port number
+     --stats                 give some file transfer stats
+     --progress              show progress during transfer
+     --log-format=FORMAT     log file transfers using specified format
+ -h, --help                  show this help screen
 
 
 SETUP
 -----
 
 Rsync uses rsh or ssh for communication. It does not need to be setuid
-and requires no special privilages for installation. It does not
+and requires no special privileges for installation. It does not
 require a inetd entry or a daemon. You must, however, have a working
 rsh or ssh system. Using ssh is recommended for its security
 features. 
 
 To install rsync, first run the "configure" script. This will create a
 Makefile and config.h appropriate for your system. Then type
@@ -85,75 +101,70 @@
 remote systems (or use "make install"). That's it!
 
 RSYNC SERVERS
 -------------
 
 rsync can also talk to "rsync servers" which can provide anonymous or
-authenticated rsync. See the rsync.conf(5) man page for details on how
+authenticated rsync. See the rsyncd.conf(5) man page for details on how
 to setup a rsync server. See the rsync(1) man page for info on how to
 connect to a rsync server.
 
 
 MAILING LIST
 ------------
 
 There is a mailing list for the discussion of rsync and its
 applications. It is open to anyone to join. I will announce new
 versions on this list. 
 
-To join the mailing list send mail to listproc@samba.anu.edu.au with
+To join the mailing list send mail to listproc@samba.org with
 no subject and a body of "subscribe rsync Your Name".
 
-To send mail to everyone on the list send it to rsync@samba.anu.edu.au
+To send mail to everyone on the list send it to rsync@samba.org
 
 
 BUG REPORTS
 -----------
 
 If you have web access then please look at
-http://samba.anu.edu.au/rsync/ 
+http://rsync.samba.org/rsync/ 
 
 This will give you access to the bug tracking system used by the
 developers of rsync and will allow you to look at other bug reports or
 submit a new bug report.
 
 If you don't have web access then mail bug reports to
-rsync-bugs@samba.anu.edu.au or (if you think it will be of interest to
-lots of people) send it to rsync@samba.anu.edu.au
+rsync-bugs@samba.org or (if you think it will be of interest to lots
+of people) send it to rsync@samba.org
 
 
 CVS TREE
 --------
 
 If you want to get the very latest version of rsync direct from the
 source code repository then you can use anonymous cvs. You will need a
 recent version of cvs then use the following commands:
 
-	cvs -d :pserver:cvs@samba.anu.edu.au:/cvsroot login
+	cvs -d :pserver:cvs@cvs.samba.org:/cvsroot login
 	Password: cvs
 
-	cvs -d :pserver:cvs@samba.anu.edu.au:/cvsroot co rsync
+	cvs -d :pserver:cvs@cvs.samba.org:/cvsroot co rsync
 
 Look at the cvs documentation for more details.
 
 
 COPYRIGHT
 ---------
 
 Rsync was written by Andrew Tridgell and Paul Mackerras, and is
 available under the Gnu Public License.
 
-tridge@samba.anu.edu.au
+tridge@samba.org
 paulus@cs.anu.edu.au
 
 
 AVAILABILITY
 ------------
 
-The main ftp site for rsync is ftp://samba.anu.edu.au/pub/rsync 
-This is also available as rsync://samba.anu.edu.au/rsyncftp/
-
-Mirrors are available at:
-
-ftp://sunsite.auc.dk/pub/unix/rsync
-ftp://ftp.sunet.se/pub/unix/admin/rsync
-ftp://ftp.fu-berlin.de/pub/unix/network/rsync/
+The main web site for rsync is http://rsync.samba.org/
+The main ftp site is ftp://rsync.samba.org/pub/rsync/
+This is also available as rsync://rsync.samba.org/rsyncftp/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/receiver.c	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/receiver.c	1998-11-26 00:24:40.000000000 +0800
@@ -30,12 +30,14 @@
 extern int relative_paths;
 extern int preserve_hard_links;
 extern int cvs_exclude;
 extern int io_error;
 extern char *tmpdir;
 extern char *compare_dest;
+extern int make_backups;
+extern char *backup_suffix;
 
 
 static struct delete_list {
 	dev_t dev;
 	INO_T inode;
 } *delete_list;
@@ -136,14 +138,21 @@
 		for (i=local_file_list->count-1;i>=0;i--) {
 			if (!local_file_list->files[i]->basename) continue;
 			if (remote_version < 19 &&
 			    S_ISDIR(local_file_list->files[i]->mode))
 				add_delete_entry(local_file_list->files[i]);
 			if (-1 == flist_find(flist,local_file_list->files[i])) {
-				delete_one(local_file_list->files[i]);
-			}    
+				char *f = f_name(local_file_list->files[i]);
+				int k = strlen(f) - strlen(backup_suffix);
+				if (make_backups && ((k <= 0) ||
+					    (strcmp(f+k,backup_suffix) != 0))) {
+					(void) make_backup(f);
+				} else {
+					delete_one(local_file_list->files[i]);
+				}
+			}
 		}
 		flist_free(local_file_list);
 		free(name);
 	}
 }
 
@@ -160,30 +169,30 @@
 		else 
 			f++;
 		if (strlen(tmpdir)+strlen(f)+10 > MAXPATHLEN) {
 			rprintf(FERROR,"filename too long\n");
 			return 0;
 		}
-		slprintf(fnametmp,MAXPATHLEN-1, "%s/.%s.XXXXXX",tmpdir,f);
+		slprintf(fnametmp,MAXPATHLEN, "%s/.%s.XXXXXX",tmpdir,f);
 		return 1;
 	} 
 
 	f = strrchr(fname,'/');
 
 	if (strlen(fname)+9 > MAXPATHLEN) {
 		rprintf(FERROR,"filename too long\n");
 		return 0;
 	}
 
 	if (f) {
 		*f = 0;
-		slprintf(fnametmp,MAXPATHLEN-1,"%s/.%s.XXXXXX",
+		slprintf(fnametmp,MAXPATHLEN,"%s/.%s.XXXXXX",
 			 fname,f+1);
 		*f = '/';
 	} else {
-		slprintf(fnametmp,MAXPATHLEN-1,".%s.XXXXXX",fname);
+		slprintf(fnametmp,MAXPATHLEN,".%s.XXXXXX",fname);
 	}
 
 	return 1;
 }
 
 
@@ -350,13 +359,13 @@
 
 		/* open the file */  
 		fd1 = open(fnamecmp,O_RDONLY);
 
 		if ((fd1 == -1) && (compare_dest != NULL)) {
 			/* try the file at compare_dest instead */
-			slprintf(fnamecmpbuf,MAXPATHLEN-1,"%s/%s",
+			slprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",
 						compare_dest,fname);
 			fnamecmp = fnamecmpbuf;
 			fd1 = open(fnamecmp,O_RDONLY);
 		}
 
 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
@@ -384,12 +393,16 @@
 		if (!get_tmpname(fnametmp,fname)) {
 			if (buf) unmap_file(buf);
 			if (fd1 != -1) close(fd1);
 			continue;
 		}
 
+		/* mktemp is deliberately used here instead of mkstemp.
+		   because O_EXCL is used on the open, the race condition
+		   is not a problem or a security hole, and we want to
+		   control the access permissions on the created file. */
 		if (NULL == do_mktemp(fnametmp)) {
 			rprintf(FERROR,"mktemp %s failed\n",fnametmp);
 			receive_data(f_in,buf,-1,NULL,file->length);
 			if (buf) unmap_file(buf);
 			if (fd1 != -1) close(fd1);
 			continue;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.1	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsync.1	1998-11-26 00:24:40.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsync" "1" "13 May 1998" "" "" 
+.TH "rsync" "1" "24 Nov 1998" "" "" 
 .SH "NAME" 
 rsync \- faster, flexible replacement for rcp
 .SH "SYNOPSIS" 
 .PP 
 rsync [options] [user@]host:path path
 .PP 
@@ -64,14 +64,13 @@
 using a remote shell program\&. This is invoked when the local path
 contains a : separator\&.
 .IP 
 .IP o 
 for copying from a remote rsync server to the local
 machine\&. This is invoked when the source path contains a ::
-separator\&. You can also use a rsync:// URL if no username
-is required\&.
+separator or a rsync:// URL.
 .IP 
 .IP o 
 for copying from the local machine to a remote rsync
 server\&. This is invoked when the destination path contains a ::
 separator\&. 
 .IP 
@@ -129,15 +128,15 @@
 size of data portions of the transfer\&.
 .PP 
 .RS 
 rsync -avz foo:src/bar/ /data/tmp
 .RE 
 .PP 
-With a trailing slash on the source this behavior changes to transfer
+a trailing slash on the source changes this behavior to transfer
 all files from the directory src/bar on the machine foo into the
-/data/tmp/\&.  With a trailing / on a source name it means "copy the
+/data/tmp/\&.  A trailing / on a source name means "copy the
 contents of this directory"\&.  Without a trailing slash it means "copy
 the directory"\&. This difference becomes particularly important when
 using the --delete option\&.
 .PP 
 You can also use rsync in local-only mode, where both the source and
 destination don\'t have a \':\' in the name\&. In this case it behaves like
@@ -322,26 +321,26 @@
 explicitly checked on the receiver and any files of the same name
 which already exist and have the same checksum and size on the
 receiver are skipped\&.  This option can be quite slow\&.
 .IP 
 .IP "\fB-a, --archive\fP" 
 This is equivalent to -rlptDg\&. It is a quick way
-of saying I want recursion and want to preserve everything\&.
+of saying you want recursion and want to preserve everything\&.
 .IP 
 Note: if the user launching rsync is root then the -o option (preserve
 uid) is also implied\&.
 .IP 
 .IP "\fB-r, --recursive\fP" 
 This tells rsync to copy directories recursively
 .IP 
 .IP "\fB-R, --relative\fP" 
 Use relative paths\&. This means that the full path
 names specified on the command line are sent to the server rather than
 just the last parts of the filenames\&. This is particularly useful when
 you want to sent several different directories at the same time\&. For
-example if you used the command
+example, if you used the command
 .IP 
 
 .DS 
  
 rsync foo/bar/foo\&.c remote:/tmp/
 .DE 
@@ -430,13 +429,18 @@
 This option causes rsync to transfer character and
 block device information to the remote system to recreate these
 devices\&. This option is only available to the super-user\&.
 .IP 
 .IP "\fB-t, --times\fP" 
 This tells rsync to transfer modification times along
-with the files and update them on the remote system
+with the files and update them on the remote system\&.  Note that if this
+option is not used, the optimization that excludes files that have not been
+modified cannot be effective; in other words, a missing -t or -a will
+cause the next transfer to behave as if it used -I, and all files will have
+their checksums compared and show up in log messages even if they haven't
+changed\&.
 .IP 
 .IP "\fB-n, --dry-run\fP" 
 This tells rsync to not do any file transfers,
 instead it will just report the actions it would have taken\&.
 .IP 
 .IP "\fB-S, --sparse\fP" 
@@ -584,16 +588,18 @@
 .IP "\fB--compare-dest DIR\fP" 
 This option instructs rsync to use DIR as an
 additional directory to compare destination files against when doing
 transfers\&.  This is useful for doing transfers to a new destination while
 leaving existing files intact, and then doing a flash-cutover when all
 files have been successfully transfered (for example by moving directories
-around and removing the old directory)\&.  This option increases the
-usefulness of --partial because partially transferred files will remain in
-the new temporary destination until they have a chance to be completed\&.
-If DIR is a relative path, it is relative to the destination directory\&.
+around and removing the old directory, although this requires also doing
+the transfer with -I to avoid skipping files that haven't changed)\&.  This
+option increases the usefulness of --partial because partially transferred
+files will remain in the new temporary destination until they have a chance
+to be completed\&.  If DIR is a relative path, it is relative to the
+destination directory\&.
 .IP 
 .IP "\fB-z, --compress\fP" 
 With this option, rsync compresses any data from
 the source file(s) which it sends to the destination machine\&.  This
 option is useful on slow links\&.  The compression method used is the
 same method that gzip uses\&.
@@ -638,16 +644,16 @@
 .IP 
 .IP "\fB--port PORT\fP" 
 This specifies an alternate TCP port number to use
 rather than the default port 873\&. 
 .IP 
 .IP "\fB--log-format=FORMAT\fP" 
-Normally rsync just logs filenames as
-they are transferred\&. This allows you to specify exactly what gets
-logged on a per file basis\&. The log format is specified using the same
-format conventions as the log format option in rsyncd\&.conf\&.
+This allows you to specify exactly what the
+rsync client logs to stdout on a per file basis\&. The log format is
+specified using the same format conventions as the log format option in
+rsyncd\&.conf\&.
 .IP 
 .IP "\fB--stats\fP" 
 This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data\&. This option only works in conjunction with
 the -v (verbose) option\&.
@@ -721,12 +727,16 @@
 --exclude "/foo" would exclude a file in the base directory called foo
 .IP o 
 --exclude "foo/" would exclude any directory called foo
 .IP o 
 --include "*/" --include "*\&.c" --exclude "*" would include all 
 directories and C source files\&.
+.IP o
+--include "foo/" --include "foo/bar\&.c" --exclude "*" would include
+only foo/bar\&.c (the foo/ directory must be explicitly included or
+it would be excluded by the "*")
 .PP 
 .SH "DIAGNOSTICS" 
 .PP 
 rsync occasinally produces error messages that may seem a little
 cryptic\&. The one that seems to cause the most confusion is "protocol
 version mismatch - is your shell clean?"\&.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.c	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsync.c	1998-11-26 00:24:40.000000000 +0800
@@ -91,13 +91,13 @@
 
 	for (di=readdir(d); di; di=readdir(d)) {
 		char *dname = d_name(di);
 		if (strcmp(dname,".")==0 ||
 		    strcmp(dname,"..")==0)
 			continue;
-		slprintf(buf, sizeof(buf)-1, "%s/%s", fname, dname);
+		slprintf(buf, sizeof(buf), "%s/%s", fname, dname);
 		if (verbose > 0)
 			rprintf(FINFO,"deleting %s\n", buf);
 		if (delete_file(buf) != 0) {
 			closedir(d);
 			return -1;
 		}
@@ -188,29 +188,39 @@
 
 void sig_int(void)
 {
 	exit_cleanup(RERR_SIGNAL);
 }
 
+int make_backup(char *fname)
+{
+	char fnamebak[MAXPATHLEN];
+	if (strlen(fname) + strlen(backup_suffix) > (MAXPATHLEN-1)) {
+		rprintf(FERROR,"backup filename too long\n");
+		return 0;
+	}
+
+	slprintf(fnamebak,sizeof(fnamebak)-1,"%s%s",fname,backup_suffix);
+	if (do_rename(fname,fnamebak) != 0) {
+		if (errno != ENOENT) {
+			rprintf(FERROR,"rename %s %s : s\n",fname,fnamebak,strerror(errno));
+			return 0;
+		}
+	} else if (verbose > 1) {
+		rprintf(FINFO,"backed up %s to %s\n",fname,fnamebak);
+	}
+	return 1;
+}
+
 
 /* finish off a file transfer, renaming the file and setting the permissions
    and ownership */
 void finish_transfer(char *fname, char *fnametmp, struct file_struct *file)
 {
-	if (make_backups) {
-		char fnamebak[MAXPATHLEN];
-		if (strlen(fname) + strlen(backup_suffix) > (MAXPATHLEN-1)) {
-			rprintf(FERROR,"backup filename too long\n");
-			return;
-		}
-		slprintf(fnamebak,sizeof(fnamebak)-1,"%s%s",fname,backup_suffix);
-		if (do_rename(fname,fnamebak) != 0 && errno != ENOENT) {
-			rprintf(FERROR,"rename %s %s : %s\n",fname,fnamebak,strerror(errno));
-			return;
-		}
-	}
+	if (make_backups && !make_backup(fname))
+		return;
 
 	/* move tmp file over real file */
 	if (do_rename(fnametmp,fname) != 0) {
 		if (errno == EXDEV) {
 			/* rename failed on cross-filesystem link.  
 			   Copy the file instead. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncd.conf.5	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsyncd.conf.5	1998-11-26 00:24:40.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsyncd\&.conf" "5" "13 May 1998" "" "" 
+.TH "rsyncd\&.conf" "5" "25 Nov 1998" "" "" 
 .SH "NAME" 
 rsyncd\&.conf \- configuration file for rsync server
 .SH "SYNOPSIS" 
 .PP 
 rsyncd\&.conf
 .PP 
@@ -43,13 +43,13 @@
 .PP 
 .SH "LAUNCHING THE RSYNC DAEMON" 
 .PP 
 The rsync daemon is launched by specifying the --daemon option to
 rsync\&. The daemon must run with root privileges\&.
 .PP 
-You can launch it either via inetd or as a standalone daemon\&. If run
+You can launch it either via inetd or as a stand-alone daemon\&. If run
 as a daemon then just run the command "rsync --daemon" from a suitable
 startup script\&.
 .PP 
 When run via inetd you should add a line like this to /etc/services:
 .PP 
 .RS 
@@ -113,57 +113,12 @@
 rsync server\&. You may use any standard syslog facility name which is
 defined on your system\&. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
 local1, local2, local3, local4, local5, local6 and local7\&. The default
 is daemon\&. 
 .IP 
-.IP "\fBtransfer logging\fP" 
-The "transfer logging" option enables per-file 
-logging of downloads and uploads in a format somewhat similar to that
-used by ftp daemons\&. If you want to customise the log formats look at
-log_send, log_recv and log_transfer in log\&.c
-.IP 
-.IP "\fBlog format\fP" 
-The "log format" option allows you to specify the
-format used for logging file transfers when transfer logging is
-enabled\&. The format is a text string containing embedded single
-character escape sequences prefixed with a percent (%) character\&.
-.IP 
-The prefixes that are understood are:
-.IP 
-.IP o 
-%h for the remote host name
-.IP o 
-%a for the remote IP address
-.IP o 
-%l for the length of the file in bytes
-.IP o 
-%p for the process id of this rsync session
-.IP o 
-%o for the operation, which is either "send" or "recv"
-.IP o 
-%f for the filename
-.IP o 
-%P for the module path
-.IP o 
-%m for the module name
-.IP o 
-%t for the current time
-.IP o 
-%u for the authenticated username (or the null string)
-.IP o 
-%b for the number of bytes actually transferred 
-.IP o 
-%c when sending files this gives the number of checksum bytes
-received for this file
-.IP 
-The default log format is "%o %h [%a] %m (%u) %f %l"
-.IP 
-A perl script called rsyncstats to summarise this format is included
-in the rsync source code distribution\&.
-.IP 
 .IP "\fBsocket options\fP" 
 This option can provide endless fun for people
 who like to tune their systems to the utmost degree\&. You can set all
 sorts of socket options which may make transfers faster (or
 slower!)\&. Read the man page for the setsockopt() system call for
 details on some of the options you may be able to set\&. By default no
@@ -234,12 +189,28 @@
 The "exclude from" option specifies a filename
 on the server that contains exclude patterns, one per line\&. This is
 equivalent to the client specifying the --exclude-from option with a
 equivalent file\&. See also the note about security for the exclude
 option above\&.
 .IP 
+.IP "\fBinclude\fP" 
+The "include" option allows you to specify a space
+separated list of patterns which rsync should not exclude\&. This is
+equivalent to the client specifying these patterns with the --include
+option\&. This is useful as it allows you to build up quite complex
+exclude/include rules\&.
+.IP
+See the section of exclude patterns for information  on the syntax of
+this option\&.
+.IP 
+.IP "\fBinclude from\fP" 
+The "include from" option specifies a filename
+on the server that contains include patterns, one per line\&. This is
+equivalent to the client specifying the --include-from option with a
+equivalent file\&.
+.IP 
 .IP "\fBauth users\fP" 
 The "auth users" option specifies a comma
 and space separated list of usernames that will be allowed to connect
 to this module\&. The usernames do not need to exist on the local
 system\&. If "auth users" is set then the client will be challenged to
 supply a username and password to connect to the module\&. A challenge
@@ -311,19 +282,101 @@
 list of patterns that are matched against a connecting clients
 hostname and IP address\&. If the pattern matches then the connection is
 rejected\&. See the "hosts allow" option for more information\&.
 .IP 
 The default is no "hosts deny" option, which means all hosts can connect\&.
 .IP 
+.IP "\fBtransfer logging\fP" 
+The "transfer logging" option enables per-file 
+logging of downloads and uploads in a format somewhat similar to that
+used by ftp daemons\&. If you want to customize the log formats look at
+the log format option\&.
+.IP 
+.IP "\fBlog format\fP" 
+The "log format" option allows you to specify the
+format used for logging file transfers when transfer logging is
+enabled\&. The format is a text string containing embedded single
+character escape sequences prefixed with a percent (%) character\&.
+.IP 
+The prefixes that are understood are:
+.IP 
+.IP o 
+%h for the remote host name
+.IP o 
+%a for the remote IP address
+.IP o 
+%l for the length of the file in bytes
+.IP o 
+%p for the process id of this rsync session
+.IP o 
+%o for the operation, which is either "send" or "recv"
+.IP o 
+%f for the filename
+.IP o 
+%P for the module path
+.IP o 
+%m for the module name
+.IP o 
+%t for the current time
+.IP o 
+%u for the authenticated username (or the null string)
+.IP o 
+%b for the number of bytes actually transferred 
+.IP o 
+%c when sending files this gives the number of checksum bytes
+received for this file
+.IP 
+The default log format is "%o %h [%a] %m (%u) %f %l"
+.IP 
+A perl script called rsyncstats to summarize this format is included
+in the rsync source code distribution\&.
+.IP 
+.IP "\fBtimeout\fP" 
+The "timeout" option allows you to override the
+clients choice for IO timeout for this module\&. Using this option you
+can ensure that rsync won\'t wait on a dead client forever\&. The timeout
+is specified in seconds\&. A value of zero means no timeout and is the
+default\&. A good choice for anonymous rsync servers may be 600 (giving
+a 10 minute timeout)\&.
+.IP 
+.IP "\fBrefuse options\fP" 
+The "refuse options" option allows you to
+specify a space separated list of rsync command line options that will
+be refused by your rsync server\&.  The full names of the options must be
+used (i\&.e\&., you must use "checksum" not "c" to disable checksumming)\&.  
+When an option is refused, the server prints an error message and exits\&.
+To prevent all compression, you can use "dont compress = *" (see below)
+instead of "refuse options = compress" to avoid returning an error to a
+client that requests compression\&.
+.IP 
+.IP "\fBdont compress\fP" 
+The "dont compress" option allows you to select
+filenames based on wildcard patterns that should not be compressed
+during transfer\&. Compression is expensive in terms of CPU usage so it
+is usually good to not try to compress files that won\'t compress well,
+such as already compressed files\&. 
+.IP 
+The "dont compress" option takes a space separated list of
+case-insensitive wildcard patterns\&. Any source filename matching one
+of the patterns will not be compressed during transfer\&.
+.IP 
+The default setting is 
+.DS 
+ 
+*\&.gz *\&.tgz *\&.zip *\&.z *\&.rpm *\&.deb
+.DE 
+ 
+
+.IP 
 .PP 
 .SH "AUTHENTICATION STRENGTH" 
 .PP 
 The authentication protocol used in rsync is a 128 bit MD4 based
 challenge response system\&. Although I believe that no one has ever
 demonstrated a brute-force break of this sort of system you should
-realise that this is not a "military strength" authentication system\&.
+realize that this is not a "military strength" authentication system\&.
 It should be good enough for most purposes but if you want really top
 quality security then I recommend that you run rsync over ssh\&.
 .PP 
 Also note that the rsync server protocol does not currently provide any
 encryption of the data that is transferred over the link\&. Only
 authentication is provided\&. Use ssh as the transport if you want
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncd.conf.yo	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsyncd.conf.yo	1998-11-26 00:24:40.000000000 +0800
@@ -1,8 +1,8 @@
-mailto(rsync-bugs@samba.anu.edu.au)
-manpage(rsyncd.conf)(5)(13 May 1998)()()
+mailto(rsync-bugs@samba.org)
+manpage(rsyncd.conf)(5)(25 Nov 1998)()()
 manpagename(rsyncd.conf)(configuration file for rsync server)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -43,13 +43,13 @@
 
 manpagesection(LAUNCHING THE RSYNC DAEMON)
 
 The rsync daemon is launched by specifying the --daemon option to
 rsync. The daemon must run with root privileges.
 
-You can launch it either via inetd or as a standalone daemon. If run
+You can launch it either via inetd or as a stand-alone daemon. If run
 as a daemon then just run the command "rsync --daemon" from a suitable
 startup script.
 
 When run via inetd you should add a line like this to /etc/services:
 
 quote(rsync           873/tcp)
@@ -104,45 +104,12 @@
 rsync server. You may use any standard syslog facility name which is
 defined on your system. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
 local1, local2, local3, local4, local5, local6 and local7. The default
 is daemon. 
 
-dit(bf(transfer logging)) The "transfer logging" option enables per-file 
-logging of downloads and uploads in a format somewhat similar to that
-used by ftp daemons. If you want to customise the log formats look at
-log_send, log_recv and log_transfer in log.c
-
-dit(bf(log format)) The "log format" option allows you to specify the
-format used for logging file transfers when transfer logging is
-enabled. The format is a text string containing embedded single
-character escape sequences prefixed with a percent (%) character.
-
-The prefixes that are understood are:
-
-itemize(
-  it() %h for the remote host name
-  it() %a for the remote IP address
-  it() %l for the length of the file in bytes
-  it() %p for the process id of this rsync session
-  it() %o for the operation, which is either "send" or "recv"
-  it() %f for the filename
-  it() %P for the module path
-  it() %m for the module name
-  it() %t for the current time
-  it() %u for the authenticated username (or the null string)
-  it() %b for the number of bytes actually transferred 
-  it() %c when sending files this gives the number of checksum bytes
-    received for this file
-)
-
-The default log format is "%o %h [%a] %m (%u) %f %l"
-
-A perl script called rsyncstats to summarise this format is included
-in the rsync source code distribution.
-
 dit(bf(socket options)) This option can provide endless fun for people
 who like to tune their systems to the utmost degree. You can set all
 sorts of socket options which may make transfers faster (or
 slower!). Read the man page for the setsockopt() system call for
 details on some of the options you may be able to set. By default no
 special socket options are set.
@@ -206,12 +173,26 @@
 dit(bf(exclude from)) The "exclude from" option specifies a filename
 on the server that contains exclude patterns, one per line. This is
 equivalent to the client specifying the --exclude-from option with a
 equivalent file. See also the note about security for the exclude
 option above.
 
+dit(bf(include)) The "include" option allows you to specify a space
+separated list of patterns which rsync should not exclude. This is
+equivalent to the client specifying these patterns with the --include
+option. This is useful as it allows you to build up quite complex
+exclude/include rules.
+
+See the section of exclude patterns for information  on the syntax of
+this option.
+
+dit(bf(include from)) The "include from" option specifies a filename
+on the server that contains include patterns, one per line. This is
+equivalent to the client specifying the --include-from option with a
+equivalent file.
+
 dit(bf(auth users)) The "auth users" option specifies a comma
 and space separated list of usernames that will be allowed to connect
 to this module. The usernames do not need to exist on the local
 system. If "auth users" is set then the client will be challenged to
 supply a username and password to connect to the module. A challenge
 response authentication protocol is used for this exchange. The plain
@@ -276,20 +257,81 @@
 list of patterns that are matched against a connecting clients
 hostname and IP address. If the pattern matches then the connection is
 rejected. See the "hosts allow" option for more information.
 
 The default is no "hosts deny" option, which means all hosts can connect.
 
+dit(bf(transfer logging)) The "transfer logging" option enables per-file 
+logging of downloads and uploads in a format somewhat similar to that
+used by ftp daemons. If you want to customize the log formats look at
+the log format option.
+
+dit(bf(log format)) The "log format" option allows you to specify the
+format used for logging file transfers when transfer logging is
+enabled. The format is a text string containing embedded single
+character escape sequences prefixed with a percent (%) character.
+
+The prefixes that are understood are:
+
+itemize(
+  it() %h for the remote host name
+  it() %a for the remote IP address
+  it() %l for the length of the file in bytes
+  it() %p for the process id of this rsync session
+  it() %o for the operation, which is either "send" or "recv"
+  it() %f for the filename
+  it() %P for the module path
+  it() %m for the module name
+  it() %t for the current time
+  it() %u for the authenticated username (or the null string)
+  it() %b for the number of bytes actually transferred 
+  it() %c when sending files this gives the number of checksum bytes
+    received for this file
+)
+
+The default log format is "%o %h [%a] %m (%u) %f %l"
+
+A perl script called rsyncstats to summarize this format is included
+in the rsync source code distribution.
+
+dit(bf(timeout)) The "timeout" option allows you to override the
+clients choice for IO timeout for this module. Using this option you
+can ensure that rsync won't wait on a dead client forever. The timeout
+is specified in seconds. A value of zero means no timeout and is the
+default. A good choice for anonymous rsync servers may be 600 (giving
+a 10 minute timeout).
+
+dit(bf(refuse options)) The "refuse options" option allows you to
+specify a space separated list of rsync command line options that will
+be refused by your rsync server.  The full names of the options must be
+used (i.e., you must use "checksum" not "c" to disable checksumming).  
+When an option is refused, the server prints an error message and exits.
+To prevent all compression, you can use "dont compress = *" (see below)
+instead of "refuse options = compress" to avoid returning an error to a
+client that requests compression.
+
+dit(bf(dont compress)) The "dont compress" option allows you to select
+filenames based on wildcard patterns that should not be compressed
+during transfer. Compression is expensive in terms of CPU usage so it
+is usually good to not try to compress files that won't compress well,
+such as already compressed files. 
+
+The "dont compress" option takes a space separated list of
+case-insensitive wildcard patterns. Any source filename matching one
+of the patterns will not be compressed during transfer.
+
+The default setting is verb(*.gz *.tgz *.zip *.z *.rpm *.deb)
+
 enddit()
 
 manpagesection(AUTHENTICATION STRENGTH)
 
 The authentication protocol used in rsync is a 128 bit MD4 based
 challenge response system. Although I believe that no one has ever
 demonstrated a brute-force break of this sort of system you should
-realise that this is not a "military strength" authentication system.
+realize that this is not a "military strength" authentication system.
 It should be good enough for most purposes but if you want really top
 quality security then I recommend that you run rsync over ssh.
 
 Also note that the rsync server protocol does not currently provide any
 encryption of the data that is transferred over the link. Only
 authentication is provided. Use ssh as the transport if you want
@@ -361,27 +403,27 @@
 
 The rsync server does not send all types of error messages to the
 client. this means a client may be mystified as to why a transfer
 failed. The error will have been logged by syslog on the server.
 
 Please report bugs! The rsync bug tracking system is online at
-url(http://samba.anu.edu.au/rsync/)(http://samba.anu.edu.au/rsync/)
+url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 This man page is current for version 2.0 of rsync
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
 The primary ftp site for rsync is
-url(ftp://samba.anu.edu.au/pub/rsync)(ftp://samba.anu.edu.au/pub/rsync).
+url(ftp://rsync.samba.org/pub/rsync)(ftp://rsync.samba.org/pub/rsync).
 
 A WEB site is available at
-url(http://samba.anu.edu.au/rsync/)(http://samba.anu.edu.au/rsync/)
+url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 We would be delighted to hear from you if you like this program.
 
 This program uses the zlib compression library written by Jean-loup
 Gailly and Mark Adler.
 
@@ -391,9 +433,9 @@
 server. Thanks to Karsten Thygesen for his many suggestions and
 documentation! 
 
 manpageauthor()
 
 rsync was written by Andrew Tridgell and Paul Mackerras.  They may be
-contacted via email at tridge@samba.anu.edu.au and
+contacted via email at tridge@samba.org and
 Paul.Mackerras@cs.anu.edu.au
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.h	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsync.h	1998-11-26 00:24:40.000000000 +0800
@@ -471,6 +471,17 @@
 #endif
 ;
 
 #ifdef REPLACE_INET_NTOA
 #define inet_ntoa rep_inet_ntoa
 #endif
+
+
+#ifndef HAVE_STRLCPY
+size_t strlcpy(char *d, const char *s, size_t bufsize);
+#endif
+
+#ifndef HAVE_STRLCAT
+size_t strlcat(char *d, const char *s, size_t bufsize);
+#endif
+
+#define exit_cleanup(code) _exit_cleanup(code, __FILE__, __LINE__)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncstats /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsyncstats
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsyncstats	1998-11-02 15:26:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsyncstats	1998-11-26 00:24:40.000000000 +0800
@@ -15,13 +15,13 @@
 #
 # This script parses the default logfile format produced by rsync when running
 # as a daemon with transfer logging enabled. It is derived from the xferstats
 # script that comes with wuftpd
 #
 # Andrew Tridgell, October 1998
-# rsync-bugs@samba.anu.edu.au
+# rsync-bugs@samba.org
 #
 # ---------------------------------------------------------------------------
 
 # edit the next line to customize for your default log file
 $usage_file = "/var/adm/rsyncd.log";
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/rsync.yo	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/rsync.yo	1998-11-26 00:24:40.000000000 +0800
@@ -1,8 +1,8 @@
-mailto(rsync-bugs@samba.anu.edu.au)
-manpage(rsync)(1)(13 May 1998)()()
+mailto(rsync-bugs@samba.org)
+manpage(rsync)(1)(24 Nov 1998)()()
 manpagename(rsync)(faster, flexible replacement for rcp)
 manpagesynopsis()
 
 rsync [options] [user@]host:path path
 
 rsync [options] path [user@]host:path
@@ -56,36 +56,35 @@
 	it() for copying from a remote machine to the local machine
 	using a remote shell program. This is invoked when the local path
 	contains a : separator.
 
 	it() for copying from a remote rsync server to the local
 	machine. This is invoked when the source path contains a ::
-	separator. You can also use a rsync:// URL if no username
-	is required.
+	separator or a rsync:// URL.
 
 	it() for copying from the local machine to a remote rsync
 	server. This is invoked when the destination path contains a ::
 	separator. 
 
 	it() for listing files on a remote machine. This is done the
 	same way as rsync transfers except that you leave off the
 	local destination.  
 )
 
-Note that in all cases at least one of the source and destination
-paths must be local.
+Note that in all cases (other than listing) at least one of the source
+and destination paths must be local.
 
 manpagesection(SETUP)
 
 See the file README for installation instructions.
 
 Once installed you can use rsync to any machine that you can use rsh
 to.  rsync uses rsh for its communications, unless both the source and
 destination are local.
 
-You can also specify a alternative to rsh, by either using the -e
+You can also specify an alternative to rsh, by either using the -e
 command line option, or by setting the RSYNC_RSH environment variable.
 
 One common substitute is to use ssh, which offers a high degree of
 security.
 
 Note that rsync must be installed on both the source and destination
@@ -105,54 +104,59 @@
 the files already exist on the remote system then the rsync
 remote-update protocol is used to update the file by sending only the
 differences. See the tech report for details.
 
 quote(rsync -avz foo:src/bar /data/tmp)
 
-recursively transfer all files from the directory src/bar on the
+this would recursively transfer all files from the directory src/bar on the
 machine foo into the /data/tmp/bar directory on the local machine. The
 files are transferred in "archive" mode, which ensures that symbolic
 links, devices, attributes, permissions, ownerships etc are preserved
-in the transfer.  Additionally compression will be used to reduce the
+in the transfer.  Additionally, compression will be used to reduce the
 size of data portions of the transfer.
 
 quote(rsync -avz foo:src/bar/ /data/tmp)
 
-With a trailing slash on the source this behavior changes to transfer
+a trailing slash on the source changes this behavior to transfer
 all files from the directory src/bar on the machine foo into the
-/data/tmp/.  With a trailing / on a source name it means "copy the
+/data/tmp/.  A trailing / on a source name means "copy the
 contents of this directory".  Without a trailing slash it means "copy
 the directory". This difference becomes particularly important when
 using the --delete option.
 
 You can also use rsync in local-only mode, where both the source and
 destination don't have a ':' in the name. In this case it behaves like
 an improved copy command.
 
+quote(rsync somehost.mydomain.com::)
+
+this would list all the anonymous rsync modules available on the host
+somehost.mydomain.com.  (See the following section for more details.)
+
 
 manpagesection(CONNECTING TO AN RSYNC SERVER)
 
 It is also possible to use rsync without using rsh or ssh as the
 transport. In this case you will connect to a remote rsync server
 running on TCP port 873. 
 
-Using rsync in this was is the same as using it with rsh or ssh except
+Using rsync in this way is the same as using it with rsh or ssh except
 that:
 
 itemize(
 	it() you use a double colon :: instead of a single colon to
 	separate the hostname from the path. 
 
 	it() the remote server may print a message of the day when you
-	connect
+	connect.
 
 	it() if you specify no path name on the remote server then the
 	list of accessible paths on the server will be shown.
-	
+
 	it() if you specify no local destination then a listing of the
-	specified files on the remote server is provided
+	specified files on the remote server is provided.
 )
 
 Some paths on the remote server may require authentication. If so then
 you will receive a password prompt when you connect. You can avoid the
 password prompt by setting the environment variable RSYNC_PASSWORD to
 the password you want to use. This may be useful when scripting rsync.
@@ -164,14 +168,14 @@
 information. 
 
 manpagesection(EXAMPLES)
 
 Here are some examples of how I use rsync.
 
-To backup my wife's home directory, which consists of large MS word
-files and mail folders I use a cron job that runs
+To backup my wife's home directory, which consists of large MS Word
+files and mail folders, I use a cron job that runs
 
 quote(rsync -Cavz . arvidsjaur:backup)
 
 each night over a PPP link to a duplicate directory on my machine
 "arvidsjaur".
 
@@ -196,22 +200,22 @@
 quote(rsync -az -e ssh --delete ~ftp/pub/samba/ nimbus:"~ftp/pub/tridge/samba")
 
 this is launched from cron every few hours.
 
 manpagesection(OPTIONS SUMMARY)
 
-Here is a short summary of the options avalable in rsync. Please refer
+Here is a short summary of the options available in rsync. Please refer
 to the detailed description below for a complete description.
 
 verb(
 Usage: rsync [OPTION]... SRC [USER@]HOST:DEST
   or   rsync [OPTION]... [USER@]HOST:SRC DEST
   or   rsync [OPTION]... SRC DEST
-  or   rsync [OPTION]... [USER@]HOST::SRC DEST
+  or   rsync [OPTION]... [USER@]HOST::SRC [DEST]
   or   rsync [OPTION]... SRC [USER@]HOST::DEST
-  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC DEST
+  or   rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
 
 Options
  -v, --verbose               increase verbosity
  -c, --checksum              always checksum
  -a, --archive               archive mode
  -r, --recursive             recurse into directories
@@ -260,51 +264,51 @@
 )
 
 manpageoptions()
 
 rsync uses the GNU long options package. Many of the command line
 options have two variants, one short and one long.  These are shown
-below separated by commas. Some options only have a long variant.
+below, separated by commas. Some options only have a long variant.
 
 startdit()
 dit(bf(-h, --help)) Print a short help page describing the options
 available in rsync
 
 dit(bf(--version)) print the rsync version number and exit
 
 dit(bf(-v, --verbose)) This option increases the amount of information you
-are given during the transfer.  By default rsync works silently. A
+are given during the transfer.  By default, rsync works silently. A
 single -v will give you information about what files are being
 transferred and a brief summary at the end. Two -v flags will give you
 information on what files are being skipped and slightly more
 information at the end. More than two -v flags should only be used if
-you are debugging rsync
+you are debugging rsync.
 
 dit(bf(-I, --ignore-times)) Normally rsync will skip any files that are
 already the same length and have the same time-stamp. This option turns
 off this behavior.
 
 dit(bf(-c, --checksum)) This forces the sender to checksum all files using
 a 128-bit MD4 checksum before transfer. The checksum is then
 explicitly checked on the receiver and any files of the same name
 which already exist and have the same checksum and size on the
 receiver are skipped.  This option can be quite slow.
 
 dit(bf(-a, --archive)) This is equivalent to -rlptDg. It is a quick way
-of saying I want recursion and want to preserve everything.
+of saying you want recursion and want to preserve everything.
 
 Note: if the user launching rsync is root then the -o option (preserve
 uid) is also implied.
 
-dit(bf(-r, --recursive)) This tells rsync to copy directories recursively
+dit(bf(-r, --recursive)) This tells rsync to copy directories recursively.
 
 dit(bf(-R, --relative)) Use relative paths. This means that the full path
 names specified on the command line are sent to the server rather than
 just the last parts of the filenames. This is particularly useful when
-you want to sent several different directories at the same time. For
-example if you used the command
+you want to send several different directories at the same time. For
+example, if you used the command
 
 verb(rsync foo/bar/foo.c remote:/tmp/)
 
 then this would create a file called foo.c in /tmp/ on the remote
 machine. If instead you used
 
@@ -320,21 +324,21 @@
 dit(bf(-u, --update)) This forces rsync to skip any files for which the
 destination file already exists and has a date later than the source
 file.
 
 dit(bf(-l, --links)) This tells rsync to recreate symbolic links on the
 remote system  to  be the same as the local system. Without this
-option all symbolic links are skipped.
+option, all symbolic links are skipped.
 
 dit(bf(-L, --copy-links)) This tells rsync to treat symbolic links just
 like  ordinary files.
 
 dit(bf(--safe-links)) This tells rsync to ignore any symbolic links
 which point outside the destination tree. All absolute symlinks are
 also ignored. Using this option in conjunction with --relative may
-give unexpecetd results. 
+give unexpected results. 
 
 dit(bf(-H, --hard-links)) This tells rsync to recreate hard  links  on
 the  remote system  to  be the same as the local system. Without this
 option hard links are treated like regular files.
 
 Note that rsync can only detect hard links if both parts of the link
@@ -343,38 +347,43 @@
 This option can be quite slow, so only use it if you need it.
 
 dit(bf(-W, --whole-file)) With this option the incremental rsync algorithm
 is  not used  and  the whole file is sent as-is instead. This may be
 useful when using rsync with a local machine.
 
-dit(bf(--partial)) By default rsync will delete any partially
+dit(bf(--partial)) By default, rsync will delete any partially
 transferred file if the transfer is interrupted. In some circumstances
 it is more desirable to keep partially transferred files. Using the
 --partial option tells rsync to keep the partial file which should
 make a subsequent transfer of the rest of the file much faster.
 
 dit(bf(-p, --perms)) This option causes rsync to update the remote
 permissions to be the same as the local permissions.
 
 dit(bf(-o, --owner)) This option causes rsync to update the  remote  owner
 of the  file to be the same as the local owner. This is only available
 to the super-user.  Note that if the source system is a daemon using chroot,
 the --numeric-ids option is implied because the source system cannot get
-access to the user names.
+access to the usernames.
 
 dit(bf(-g, --group)) This option causes rsync to update the  remote  group
 of the file to be the same as the local group.  Note that if the source
 system is a daemon using chroot, the --numeric-ids option is implied because
 the source system cannot get access to the group names.
 
 dit(bf(-D, --devices)) This option causes rsync to transfer character and
 block device information to the remote system to recreate these
 devices. This option is only available to the super-user.
 
 dit(bf(-t, --times)) This tells rsync to transfer modification times along
-with the files and update them on the remote system
+with the files and update them on the remote system.  Note that if this
+option is not used, the optimization that excludes files that have not been
+modified cannot be effective; in other words, a missing -t or -a will
+cause the next transfer to behave as if it used -I, and all files will have
+their checksums compared and show up in log messages even if they haven't
+changed.
 
 dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
 instead it will just report the actions it would have taken.
 
 dit(bf(-S, --sparse)) Try to handle sparse files efficiently so they take
 up less space on the destination.
@@ -421,29 +430,29 @@
 
 dit(bf(-B , --block_size BLOCKSIZE)) This controls the block size used in
 the rsync algorithm. See the technical report for details.
 
 dit(bf(-e, --rsh COMMAND)) This option allows you to choose an alternative
 remote shell program to use for communication between the local and
-remote copies of rsync. By default rsync will use rsh, but you may
+remote copies of rsync. By default, rsync will use rsh, but you may
 like to instead use ssh because of its high security.
 
 You can also choose the remote shell program using the RSYNC_RSH
 environment variable.
 
 dit(bf(--rsync-path PATH)) Use this to specify the path to the copy of
-rsync on the remote machine. Useful when its not in your path.
+rsync on the remote machine. Useful when it's not in your path.
 
 dit(bf(--exclude pattern)) This option allows you to selectively exclude
 certain files from the list of files to be transferred. This is most
 useful in combination with a recursive transfer.
 
 You may use as many --exclude options on the command line as you like
 to build up the list of files to exclude.
 
-See the section of exclude patterns for information on the syntax of 
+See the section on exclude patterns for information on the syntax of 
 this option.
 
 dit(bf(--exclude-from FILE)) This option is similar to the --exclude
 option, but instead it adds all filenames listed in the file FILE to
 the exclude list.
 
@@ -502,17 +511,19 @@
 the temporary files in the receiving directory.
 
 dit(bf(--compare-dest DIR)) This option instructs rsync to use DIR as an
 additional directory to compare destination files against when doing
 transfers.  This is useful for doing transfers to a new destination while
 leaving existing files intact, and then doing a flash-cutover when all
-files have been successfully transfered (for example by moving directories
-around and removing the old directory).  This option increases the
-usefulness of --partial because partially transferred files will remain in
-the new temporary destination until they have a chance to be completed.
-If DIR is a relative path, it is relative to the destination directory.
+files have been successfully transferred (for example by moving directories
+around and removing the old directory, although this requires also doing
+the transfer with -I to avoid skipping files that haven't changed).  This
+option increases the usefulness of --partial because partially transferred
+files will remain in the new temporary destination until they have a chance
+to be completed.  If DIR is a relative path, it is relative to the
+destination directory.
 
 dit(bf(-z, --compress)) With this option, rsync compresses any data from
 the source file(s) which it sends to the destination machine.  This
 option is useful on slow links.  The compression method used is the
 same method that gzip uses.
 
@@ -524,13 +535,13 @@
 dit(bf(--numeric-ids)) With this option rsync will transfer numeric group
 and user ids rather than using user and group names and mapping them
 at both ends.
 
 By default rsync will use the user name and group name to determine
 what ownership to give files. The special uid 0 and the special group
-0 and never mapped via user/group names even if the --numeric-ids
+0 are never mapped via user/group names even if the --numeric-ids
 option is not specified.
 
 If the source system is a daemon using chroot, or if a user or group name
 does not exist on the destination system, then the numeric id from the
 source system is used instead.
 
@@ -548,18 +559,18 @@
 
 dit(bf(--config FILE)) This specifies an alternate config file than
 the default /etc/rsyncd.conf. This is only relevant when --daemon is
 specified. 
 
 dit(bf(--port PORT)) This specifies an alternate TCP port number to use
-rather than the default port 873. 
+rather than the default port 873.
 
-dit(bf(--log-format=FORMAT)) Normally rsync just logs filenames as
-they are transferred. This allows you to specify exactly what gets
-logged on a per file basis. The log format is specified using the same
-format conventions as the log format option in rsyncd.conf.
+dit(bf(--log-format=FORMAT)) This allows you to specify exactly what the
+rsync client logs to stdout on a per-file basis. The log format is
+specified using the same format conventions as the log format option in
+rsyncd.conf.
 
 dit(bf(--stats)) This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
 algorithm is for your data. This option only works in conjunction with
 the -v (verbose) option.
 
@@ -569,23 +580,23 @@
 
 enddit()
 
 manpagesection(EXCLUDE PATTERNS)
 
 The exclude and include patterns specified to rsync allow for flexible
-selection of what files to transfer and what files to skip.
+selection of which files to transfer and which files to skip.
 
-rsync build a ordered list of include/exclude options as specified on
-the command line. When a filename is encountered rsync then checks the
+rsync builds a ordered list of include/exclude options as specified on
+the command line. When a filename is encountered, rsync checks the
 name against each exclude/include pattern in turn. The first matching
 pattern is acted on. If it is an exclude pattern than that file is
 skipped. If it is an include pattern then that filename is not
 skipped. If no matching include/exclude pattern is found then the
 filename is not skipped.
 
-The patterns themselves can take several forms. The rules are:
+The patterns can take several forms. The rules are:
 
 itemize(
   it() if the pattern starts with a / then it is matched against the
   start of the filename, otherwise it is matched against the end of
   the filename. Thus /foo would match a file called foo
   at the base of the tree whereas foo would match any file
@@ -623,35 +634,38 @@
 
 itemize(
   it() --exclude "*.o" would exclude all filenames matching *.o
   it() --exclude "/foo" would exclude a file in the base directory called foo
   it() --exclude "foo/" would exclude any directory called foo
   it() --include "*/" --include "*.c" --exclude "*" would include all 
-  directories and C source files.
+  directories and C source files
+  it() --include "foo/" --include "foo/bar.c" --exclude "*" would include
+  only foo/bar.c (the foo/ directory must be explicitly included or
+  it would be excluded by the "*")
 )
 
 manpagesection(DIAGNOSTICS)
 
-rsync occasinally produces error messages that may seem a little
+rsync occasionally produces error messages that may seem a little
 cryptic. The one that seems to cause the most confusion is "protocol
 version mismatch - is your shell clean?".
 
 This message is usually caused by your startup scripts or remote shell
 facility producing unwanted garbage on the stream that rsync is using
-for its transport. The way ot diagnose this problem is to run your
+for its transport. The way to diagnose this problem is to run your
 remote shell like this:
 
 verb(
    rsh remotehost /bin/true > out.dat
 )
        
 then look at out.dat. If everything is working correctly then out.dat
 should be a zero length file. You you are getting the above error from
 rsync then you will probably find that out.dat contains some text or
 data. Look at the contents and try to work out what is producing
-it. The most common cause is incorrectly configued shell startup
+it. The most common cause is incorrectly configured shell startup
 scripts (such as .cshrc or .profile) that contain output statements
 for non-interactive logins.
 
 manpagesection(ENVIRONMENT VARIABLES)
 
 startdit()
@@ -669,13 +683,13 @@
 daemon without user intervention. Note that this does not supply a
 password to a shell transport such as ssh.
 
 dit(bf(USER) or bf(LOGNAME)) The USER or LOGNAME environment variables
 are used to determine the default username sent to a rsync server.
 
-dit(bf(HOME)) The HOME environment variable is used to find the users
+dit(bf(HOME)) The HOME environment variable is used to find the user's
 default .cvsignore file.
 
 enddit()
 
 manpagefiles()
 
@@ -694,40 +708,40 @@
 file permissions, devices etc are transferred as native numerical
 values
 
 see also the comments on the --delete option
 
 Please report bugs! The rsync bug tracking system is online at
-url(http://samba.anu.edu.au/rsync/)(http://samba.anu.edu.au/rsync/)
+url(http://rsync.samba.org/rsync/)(http://rsync.samba.org/rsync/)
 
 manpagesection(VERSION)
 This man page is current for version 2.0 of rsync
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
-The primary ftp site for rsync is
-url(ftp://samba.anu.edu.au/pub/rsync)(ftp://samba.anu.edu.au/pub/rsync).
-
 A WEB site is available at
-url(http://samba.anu.edu.au/rsync/)(http://samba.anu.edu.au/rsync/)
+url(http://rsync.samba.org/)(http://rsync.samba.org/)
+
+The primary ftp site for rsync is
+url(ftp://rsync.samba.org/pub/rsync)(ftp://rsync.samba.org/pub/rsync).
 
 We would be delighted to hear from you if you like this program.
 
-This program uses the zlib compression library written by Jean-loup
-Gailly and Mark Adler.
+This program uses the excellent zlib compression library written by
+Jean-loup Gailly and Mark Adler.
 
 manpagesection(THANKS)
 
 Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
 and David Bell for helpful suggestions and testing of rsync. I've
 probably missed some people, my apologies if I have.
 
 
 manpageauthor()
 
 rsync was written by Andrew Tridgell and Paul Mackerras.  They may be
-contacted via email at tridge@samba.anu.edu.au and
+contacted via email at tridge@samba.org and
 Paul.Mackerras@cs.anu.edu.au
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/sender.c	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/sender.c	1998-11-26 00:24:40.000000000 +0800
@@ -125,23 +125,23 @@
 
 		stats.num_transferred_files++;
 		stats.total_transferred_size += file->length;
 
 		fname[0] = 0;
 		if (file->basedir) {
-			strlcpy(fname,file->basedir,MAXPATHLEN-1);
+			strlcpy(fname,file->basedir,MAXPATHLEN);
 			if (strlen(fname) == MAXPATHLEN-1) {
 				io_error = 1;
 				rprintf(FERROR, "send_files failed on long-named directory %s\n",
 					fname);
 				return;
 			}
-			strlcat(fname,"/",MAXPATHLEN-1);
+			strlcat(fname,"/",MAXPATHLEN);
 			offset = strlen(file->basedir)+1;
 		}
-		strlcat(fname,f_name(file),MAXPATHLEN-strlen(fname));
+		strlcat(fname,f_name(file),MAXPATHLEN);
 	  
 		if (verbose > 2) 
 			rprintf(FINFO,"send_files(%d,%s)\n",i,fname);
 	  
 		if (dry_run) {	
 			if (!am_server) {
@@ -197,12 +197,14 @@
 		if (verbose > 2)
 			rprintf(FINFO,"calling match_sums %s\n",fname);
 	  
 		if (!am_server) {
 			log_transfer(file, fname+offset);
 		}
+
+		set_compression(fname);
 	  
 		match_sums(f_out,s,buf,st.st_size);
 
 		log_send(file, &initial_stats);
 	  	  
 		if (buf) unmap_file(buf);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/socket.c	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/socket.c	1998-11-26 00:24:41.000000000 +0800
@@ -327,13 +327,13 @@
 	initialised = 1;
 
 	if (getpeername(fd, &sa, &length)) {
 		exit_cleanup(RERR_SOCKETIO);
 	}
 	
-	strlcpy(addr_buf,(char *)inet_ntoa(sockin->sin_addr), sizeof(addr_buf)-1);
+	strlcpy(addr_buf,(char *)inet_ntoa(sockin->sin_addr), sizeof(addr_buf));
 	return addr_buf;
 }
 
 
 /*******************************************************************
  return the DNS name of the client 
@@ -360,13 +360,13 @@
 	}
 
 	/* Look up the remote host name. */
 	if ((hp = gethostbyaddr((char *) &sockin->sin_addr,
 				sizeof(sockin->sin_addr),
 				AF_INET))) {
-		strlcpy(name_buf,(char *)hp->h_name,sizeof(name_buf) - 1);
+		strlcpy(name_buf,(char *)hp->h_name,sizeof(name_buf));
 	}
 
 
 	/* do a forward lookup as well to prevent spoofing */
 	hp = gethostbyname(name_buf);
 	if (!hp) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/syscall.c	1998-05-26 22:43:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/syscall.c	1998-11-26 00:24:41.000000000 +0800
@@ -73,12 +73,16 @@
 	return rmdir(pathname);
 }
 
 int do_open(char *pathname, int flags, mode_t mode)
 {
 	if (dry_run) return -1;
+#ifdef O_BINARY
+	/* for Windows */
+	flags |= O_BINARY;
+#endif
 	CHECK_RO
 	return open(pathname, flags, mode);
 }
 
 #if HAVE_CHMOD
 int do_chmod(const char *path, mode_t mode)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/tech_report.tex /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/tech_report.tex
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/tech_report.tex	1996-06-22 13:04:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/tech_report.tex	1998-11-26 00:24:41.000000000 +0800
@@ -28,13 +28,13 @@
 \section{The problem}
 
 Imagine you have two files, $A$ and $B$, and you wish to update $B$ to be
 the same as $A$. The obvious method is to copy $A$ onto $B$.
 
 Now imagine that the two files are on machines connected by a slow
-communications link, for example a dial up IP link.  If $A$ is large,
+communications link, for example a dialup IP link.  If $A$ is large,
 copying $A$ onto $B$ will be slow.  To make it faster you could
 compress $A$ before sending it, but that will usually only gain a
 factor of 2 to 4.
 
 Now assume that $A$ and $B$ are quite similar, perhaps both derived
 from the same original file. To really speed things up you would need
@@ -130,13 +130,13 @@
 
 Thus the checksum can be calculated for blocks of length S at all
 possible offsets within a file in a ``rolling'' fashion, with very
 little computation at each point.
 
 Despite its simplicity, this checksum was found to be quite adequate as
-a first level check for a match of two file blocks.  We have found in
+a first-level check for a match of two file blocks.  We have found in
 practice that the probability of this checksum matching when the
 blocks are not equal is quite low.  This is important because the much
 more expensive strong checksum must be calculated for each block where
 the weak checksum matches.
 
 \section{Checksum searching}
@@ -155,22 +155,22 @@
 hash of the 32-bit rolling checksum.  Each entry in the hash table
 points to the first element of the list for that hash value, or
 contains a null value if no element of the list has that hash value.
 
 At each offset in the file the 32-bit rolling checksum and its 16-bit
 hash are calculated.  If the hash table entry for that hash value is
-not a null value, the second level check is invoked.
+not a null value, the second-level check is invoked.
 
-The second level check involves scanning the sorted checksum list
+The second-level check involves scanning the sorted checksum list
 starting with the entry pointed to by the hash table entry, looking
 for an entry whose 32-bit rolling checksum matches the current value.
 The scan terminates when it reaches an entry whose 16-bit hash
-differs.  If this search finds a match, the third level check is
+differs.  If this search finds a match, the third-level check is
 invoked.
 
-The third level check involves calculating the strong checksum for the
+The third-level check involves calculating the strong checksum for the
 current offset in the file and comparing it with the strong checksum
 value in the current list entry.  If the two strong checksums match,
 we assume that we have found a block of $A$ which matches a block of
 $B$.  In fact the blocks could be different, but the probability of
 this is microscopic, and in practice this is a reasonable assumption.
 
@@ -243,20 +243,20 @@
 
 The columns in the table are as follows:
 
 \begin{description}
 \item [block size] The size in bytes of the checksummed blocks.
 \item [matches] The number of times a block of $B$ was found in $A$.
-\item [tag hits] The number of times the 16 bit hash of the rolling
+\item [tag hits] The number of times the 16-bit hash of the rolling
   checksum matched a hash of one of the checksums from $B$.
-\item [false alarms] The number of times the 32 bit rolling checksum
+\item [false alarms] The number of times the 32-bit rolling checksum
   matched but the strong checksum didn't.
 \item [data] The amount of file data transferred verbatim, in bytes.
-\item [written] The total number of bytes written by $\alpha$
+\item [written] The total number of bytes written by $\alpha$,
   including protocol overheads. This is almost all file data.
-\item [read] The total number of bytes read by $\alpha$ including
+\item [read] The total number of bytes read by $\alpha$, including
   protocol overheads. This is almost all checksum information.
 \end{description}
 
 The results demonstrate that for block sizes above 300 bytes, only a
 small fraction (around 5\%) of the file was transferred. The amount
 transferred was also considerably less than the size of the diff file
@@ -266,13 +266,13 @@
 The checksums themselves took up a considerable amount of space,
 although much less than the size of the data transferred in each
 case. Each pair of checksums consumes 20 bytes: 4 bytes for the
 rolling checksum plus 16 bytes for the 128-bit MD4 checksum.
 
 The number of false alarms was less than $1/1000$ of the number of
-true matches, indicating that the 32 bit rolling checksum is quite
+true matches, indicating that the 32-bit rolling checksum is quite
 good at screening out false matches. 
 
 The number of tag hits indicates that the second level of the
 checksum search algorithm was invoked about once every 50
 characters.  This is quite high because the total number of blocks in
 the file is a large fraction of the size of the tag hash table. For
@@ -302,9 +302,9 @@
 
 
 \section{Availability}
 
 An implementation of rsync which provides a convenient interface
 similar to the common UNIX command rcp has been written and is
-available for download from ftp://samba.anu.edu.au/pub/rsync.
+available for download from http://rsync.samba.org/
 
 \end{document}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/token.c	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/token.c	1998-11-26 00:24:41.000000000 +0800
@@ -18,13 +18,50 @@
 */
 
 #include "rsync.h"
 #include "zlib/zlib.h"
 
 extern int do_compression;
+static int compression_level = Z_DEFAULT_COMPRESSION;
 
+/* determine the compression level based on a wildcard filename list */
+void set_compression(char *fname)
+{
+	extern int module_id;
+	char *dont;
+	char *tok;
+
+	if (!do_compression) return;
+
+	compression_level = Z_DEFAULT_COMPRESSION;
+	dont = lp_dont_compress(module_id);
+
+	if (!dont || !*dont) return;
+
+	if ((dont[0] == '*') && (!dont[1])) {
+		/* an optimization to skip the rest of this routine */
+		compression_level = 0;
+		return;
+	}
+
+	dont = strdup(dont);
+	fname = strdup(fname);
+	if (!dont || !fname) return;
+
+	strlower(dont);
+	strlower(fname);
+
+	for (tok=strtok(dont," ");tok;tok=strtok(NULL," ")) {
+		if (fnmatch(tok, fname, 0) == 0) {
+			compression_level = 0;
+			break;
+		}
+	}
+	free(dont);
+	free(fname);
+}
 
 /* non-compressing recv token */
 static int simple_recv_token(int f,char **data)
 {
 	static int residue;
 	static char *buf;
@@ -101,13 +138,13 @@
 	if (last_token == -1) {
 		/* initialization */
 		if (!init_done) {
 			tx_strm.next_in = NULL;
 			tx_strm.zalloc = NULL;
 			tx_strm.zfree = NULL;
-			if (deflateInit2(&tx_strm, Z_DEFAULT_COMPRESSION,
+			if (deflateInit2(&tx_strm, compression_level,
 					 Z_DEFLATED, -15, 8,
 					 Z_DEFAULT_STRATEGY) != Z_OK) {
 				rprintf(FERROR, "compression init failed\n");
 				exit_cleanup(RERR_STREAMIO);
 			}
 			if ((obuf = malloc(MAX_DATA_COUNT+2)) == NULL)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/util.c	1998-11-04 06:00:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/util.c	1998-11-26 00:24:41.000000000 +0800
@@ -355,37 +355,12 @@
 	for (i=0;i<num_pids;i++) {
 		if (all_pids[i] != getpid())
 			kill(all_pids[i], sig);
 	}
 }
 
-/* like strncpy but does not 0 fill the buffer and always null 
-   terminates (thus it can use maxlen+1 space in d) */
-void strlcpy(char *d, char *s, int maxlen)
-{
-	int len = strlen(s);
-	if (len > maxlen) len = maxlen;
-	memcpy(d, s, len);
-	d[len] = 0;
-}
-
-/* like strncat but does not 0 fill the buffer and always null 
-   terminates (thus it can use maxlen+1 space in d) */
-void strlcat(char *d, char *s, int maxlen)
-{
-	int len1 = strlen(d);
-	int len2 = strlen(s);
-	if (len1+len2 > maxlen) {
-		len2 = maxlen-len1;
-	}
-	if (len2 > 0) {
-		memcpy(d+len1, s, len2);
-		d[len1+len2] = 0;
-	}
-}
-
 /* turn a user name into a uid */
 int name_to_uid(char *name, uid_t *uid)
 {
 	struct passwd *pass;
 	if (!name || !*name) return 0;
 	pass = getpwnam(name);
@@ -422,26 +397,28 @@
 	lock.l_pid = 0;
 	
 	return fcntl(fd,F_SETLK,&lock) == 0;
 }
 
 
-static void glob_expand_one(char *s, char **argv, int *argc, int maxargs)
+static void glob_expand_one(char *s, char **argv, int *argc, int maxargs, int sanitize_paths)
 {
 #if !(defined(HAVE_GLOB) && defined(HAVE_GLOB_H))
 	if (!*s) s = ".";
 	argv[*argc] = strdup(s);
 	(*argc)++;
 	return;
 #else
 	glob_t globbuf;
 	int i;
 
 	if (!*s) s = ".";
 
-	argv[*argc] = strdup(s);
+	s = strdup(s);
+	sanitize_path(s);
+	argv[*argc] = s;
 
 	memset(&globbuf, 0, sizeof(globbuf));
 	glob(argv[*argc], 0, NULL, &globbuf);
 	if (globbuf.gl_pathc == 0) {
 		(*argc)++;
 		globfree(&globbuf);
@@ -454,13 +431,13 @@
 	}
 	globfree(&globbuf);
 	(*argc) += i;
 #endif
 }
 
-void glob_expand(char *base1, char **argv, int *argc, int maxargs)
+void glob_expand(char *base1, char **argv, int *argc, int maxargs, int sanitize_paths)
 {
 	char *s = argv[*argc];
 	char *p, *q;
 	char *base = base1;
 
 	if (!s || !*s) return;
@@ -478,17 +455,17 @@
 	sprintf(base," %s/", base1);
 
 	q = s;
 	while ((p = strstr(q,base)) && ((*argc) < maxargs)) {
 		/* split it at this point */
 		*p = 0;
-		glob_expand_one(q, argv, argc, maxargs);
+		glob_expand_one(q, argv, argc, maxargs, sanitize_paths);
 		q = p+strlen(base);
 	}
 
-	if (*q && (*argc < maxargs)) glob_expand_one(q, argv, argc, maxargs);
+	if (*q && (*argc < maxargs)) glob_expand_one(q, argv, argc, maxargs, sanitize_paths);
 
 	free(s);
 	free(base);
 }
 
 /*******************************************************************
@@ -499,20 +476,19 @@
 	while (*s) {
 		if (isupper(*s)) *s = tolower(*s);
 		s++;
 	}
 }
 
-/* this is like vsnprintf but the 'n' limit does not include
-   the terminating null. So if you have a 1024 byte buffer then
-   pass 1023 for n */
+/* this is like vsnprintf but it always null terminates, so you
+   can fit at most n-1 chars in */
 int vslprintf(char *str, int n, const char *format, va_list ap)
 {
 	int ret = vsnprintf(str, n, format, ap);
-	if (ret > n || ret < 0) {
-		str[n] = 0;
+	if (ret >= n || ret < 0) {
+		str[n-1] = 0;
 		return -1;
 	}
 	str[ret] = 0;
 	return ret;
 }
 
@@ -578,57 +554,76 @@
 		}
 	}
 }
 
 /*
  * Make path appear as if a chroot had occurred:
- *    0. call clean_fname on it.
  *    1. remove leading "/" (or replace with "." if at end)
  *    2. remove leading ".." components
  *    3. delete any other "<dir>/.." (recursively)
- * Return a malloc'ed copy.
+ * While we're at it, remove double slashes and "." components like
+ *   clean_fname does(), but DON'T remove a trailing slash because that
+ *   is sometimes significant on command line arguments.
+ * Can only shrink paths, so sanitizes in place.
  * Contributed by Dave Dykstra <dwd@bell-labs.com>
  */
 
-char *sanitize_path(char *p)
+void sanitize_path(char *p)
 {
-	char *copy, *copyp;
-
-	clean_fname(p);
+	char *start, *sanp;
 
-	copy = (char *) malloc(strlen(p)+1);
-	copyp = copy;
+	start = p;
+	sanp = p;
+	while (*p == '/') {
+		/* remove leading slashes */
+		p++;
+	}
 	while (*p != '\0') {
-		if ((*p == '/') && (copyp == copy)) {
-			/* remove leading slash */
-			p++;
-		}
-		else if ((*p == '.') && (*(p+1) == '.') &&
+		/* this loop iterates once per filename component in p.
+		 * both p (and sanp if the original had a slash) should
+		 * always be left pointing after a slash
+		 */
+		if ((*p == '.') && ((*(p+1) == '/') || (*(p+1) == '\0'))) {
+			/* skip "." component */
+			while (*++p == '/') {
+				/* skip following slashes */
+				;
+			}
+		} else if ((*p == '.') && (*(p+1) == '.') &&
 			    ((*(p+2) == '/') || (*(p+2) == '\0'))) {
-			/* remove .. followed by slash or end */
+			/* skip ".." component followed by slash or end */
 			p += 2;
-			if (copyp != copy) {
-				/* backup the copy one level */
-				while ((--copyp != copy) && (*copyp == '/'))
-					/* skip trailing slashes */
-					;
-				while ((copyp != copy) && (*copyp != '/'))
-					/* skip back through slash */
-					copyp--;
+			if (*p == '/')
+				p++;
+			if (sanp != start) {
+				/* back up sanp one level */
+				--sanp; /* now pointing at slash */
+				while ((sanp > start) && (*(sanp - 1) != '/')) {
+					/* skip back up to slash */
+					sanp--;
+				}
 			}
 		} else {
-			/* copy one component */
 			while (1) {
-				*copyp++ = *p++;
-				if ((*p == '\0') || (*(p-1) == '/'))
+				/* copy one component through next slash */
+				*sanp++ = *p++;
+				if ((*p == '\0') || (*(p-1) == '/')) {
+					while (*p == '/') {
+						/* skip multiple slashes */
+						p++;
+					}
 					break;
+				}
 			}
 		}
 	}
-	*copyp = '\0';
-	return(copy);
+	if (sanp == start) {
+		/* ended up with nothing, so put in "." component */
+		*sanp++ = '.';
+	}
+	*sanp = '\0';
 }
 
 
 static char curr_dir[MAXPATHLEN];
 
 /* like chdir() but can be reversed with pop_dir() if save is set. It
@@ -647,16 +642,16 @@
 
 	if (save) {
 		ret = strdup(curr_dir);
 	}
 
 	if (*dir == '/') {
-		strlcpy(curr_dir, dir, sizeof(curr_dir)-1);
+		strlcpy(curr_dir, dir, sizeof(curr_dir));
 	} else {
-		strlcat(curr_dir,"/", sizeof(curr_dir)-1);
-		strlcat(curr_dir,dir, sizeof(curr_dir)-1);
+		strlcat(curr_dir,"/", sizeof(curr_dir));
+		strlcat(curr_dir,dir, sizeof(curr_dir));
 	}
 
 	clean_fname(curr_dir);
 
 	return ret;
 }
@@ -669,25 +664,25 @@
 	ret = chdir(dir);
 	if (ret) {
 		free(dir);
 		return ret;
 	}
 
-	strlcpy(curr_dir, dir, sizeof(curr_dir)-1);
+	strlcpy(curr_dir, dir, sizeof(curr_dir));
 
 	free(dir);
 
 	return 0;
 }
 
 /* we need to supply our own strcmp function for file list comparisons
    to ensure that signed/unsigned usage is consistent between machines. */
 int u_strcmp(const char *cs1, const char *cs2)
 {
-	const uchar *s1 = (uchar *)cs1;
-	const uchar *s2 = (uchar *)cs2;
+	const uchar *s1 = (const uchar *)cs1;
+	const uchar *s2 = (const uchar *)cs2;
 
 	while (*s1 && *s2 && (*s1 == *s2)) {
 		s1++; s2++;
 	}
 	
 	return (int)*s1 - (int)*s2;
@@ -774,13 +769,13 @@
 	static char TimeBuf[200];
 	struct tm *tm = localtime(&t);
 
 #ifdef HAVE_STRFTIME
 	strftime(TimeBuf,sizeof(TimeBuf)-1,"%Y/%m/%d %T",tm);
 #else
-	strlcpy(TimeBuf, asctime(tm), sizeof(TimeBuf)-1);
+	strlcpy(TimeBuf, asctime(tm), sizeof(TimeBuf));
 #endif
 
 	if (TimeBuf[strlen(TimeBuf)-1] == '\n') {
 		TimeBuf[strlen(TimeBuf)-1] = 0;
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.0/version.h	1998-11-04 06:00:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.2.1/version.h	1998-11-26 00:24:48.000000000 +0800
@@ -1 +1 @@
-#define VERSION "2.2.0"
+#define VERSION "2.2.1"
