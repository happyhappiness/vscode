diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/access.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/access.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/access.c	2003-01-20 21:46:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/access.c	2003-07-30 14:12:27.000000000 +0800
@@ -24,13 +24,13 @@
 #include "rsync.h"
 
 
 static int match_hostname(char *host, char *tok)
 {
 	if (!host || !*host) return 0;
-	return (fnmatch(tok, host, 0) == 0);
+	return wildmatch(tok, host);
 }
 
 static int match_binary(char *b1, char *b2, char *mask, int addrlen)
 {
 	int i;
 
@@ -70,17 +70,30 @@
 	long int bits;
 #else
 	int bits;
 #endif
 	char mask[16];
 	char *a = NULL, *t = NULL;
+	unsigned int len;
 
 	if (!addr || !*addr) return 0;
 
 	p = strchr(tok,'/');
-	if (p) *p = 0;
+	if (p) {
+		*p = '\0';
+		len = p - tok;
+	}
+	else
+		len = strlen(tok);
+
+	/* Fail quietly if tok is a hostname (not an address) */
+	if (strspn(tok, ".0123456789") != len
+#ifdef INET6
+	 && !strchr(tok, ':')
+#endif
+		) return 0;
 
 	memset(&hints, 0, sizeof(hints));
 	hints.ai_family = PF_UNSPEC;
 	hints.ai_socktype = SOCK_STREAM;
 #ifdef AI_NUMERICHOST
 	hints.ai_flags = AI_NUMERICHOST;
@@ -90,13 +103,16 @@
 	if (gai) return 0;
 
 	gai = getaddrinfo(tok, NULL, &hints, &rest);
 	if (p)
 		*p++ = '/';
 	if (gai) {
-		rprintf(FERROR,"malformed address %s\n", tok);
+		rprintf(FERROR,
+			"error matching address %s: %s\n",
+			tok,
+			gai_strerror(gai));
 		freeaddrinfo(resa);
 		return 0;
 	}
 
 	if (rest->ai_family != resa->ai_family) {
 		ret = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/authenticate.c	2003-01-27 03:37:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/authenticate.c	2003-07-30 14:12:27.000000000 +0800
@@ -236,13 +236,13 @@
 	}
 	
 	users = strdup(users);
 	if (!users) return NULL;
 
 	for (tok=strtok(users," ,\t"); tok; tok = strtok(NULL," ,\t")) {
-		if (fnmatch(tok, user, 0) == 0) break;
+		if (wildmatch(tok, user)) break;
 	}
 	free(users);
 
 	if (!tok) {
 		return NULL;
 	}
@@ -270,14 +270,20 @@
 	extern char *password_file;
 
 	if (!user || !*user) return;
 
 	if (!(pass=getpassf(password_file)) && !(pass=getenv("RSYNC_PASSWORD"))) {
 		/* XXX: cyeoh says that getpass is deprecated, because
-		   it may return a truncated password on some systems,
-		   and it is not in the LSB. */
+		 * it may return a truncated password on some systems,
+		 * and it is not in the LSB.
+                 *
+                 * Andrew Klein says that getpassphrase() is present
+                 * on Solaris and reads up to 256 characters.
+                 *
+                 * OpenBSD has a readpassphrase() that might be more suitable.
+                 */
 		pass = getpass("Password: ");
 	}
 
 	if (!pass || !*pass) {
 		pass = "";
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/backup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/backup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/backup.c	2002-05-10 05:44:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/backup.c	2003-09-11 12:53:05.000000000 +0800
@@ -18,17 +18,17 @@
 
 /* backup handling code */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int suffix_specified;
+extern int backup_suffix_len;
+extern int backup_dir_len;
 extern char *backup_suffix;
 extern char *backup_dir;
 
-
 extern int am_root;
 extern int preserve_devices;
 extern int preserve_links;
 extern int preserve_hard_links;
 
 /* simple backup creates a backup with a suffix in the same directory */
@@ -32,26 +32,26 @@
 extern int preserve_hard_links;
 
 /* simple backup creates a backup with a suffix in the same directory */
 static int make_simple_backup(char *fname)
 {
 	char fnamebak[MAXPATHLEN];
-	if (strlen(fname) + strlen(backup_suffix) > (MAXPATHLEN-1)) {
-		rprintf(FERROR,"backup filename too long\n");
+	if (strlen(fname) + backup_suffix_len > MAXPATHLEN-1) {
+		rprintf(FERROR, "backup filename too long\n");
 		return 0;
 	}
 
-	snprintf(fnamebak,sizeof(fnamebak),"%s%s",fname,backup_suffix);
-	if (do_rename(fname,fnamebak) != 0) {
+	snprintf(fnamebak, sizeof(fnamebak), "%s%s", fname, backup_suffix);
+	if (do_rename(fname, fnamebak) != 0) {
 		/* cygwin (at least version b19) reports EINVAL */
 		if (errno != ENOENT && errno != EINVAL) {
 			rsyserr(FERROR, errno, "rename %s to backup %s", fname, fnamebak);
 			return 0;
 		}
 	} else if (verbose > 1) {
-		rprintf(FINFO,"backed up %s to %s\n",fname,fnamebak);
+		rprintf(FINFO, "backed up %s to %s\n", fname, fnamebak);
 	}
 	return 1;
 }
 
 
 /* recursively make a directory path */
@@ -78,52 +78,55 @@
 
 
 /****************************************************************************
 Create a directory given an absolute path, perms based upon another directory
 path
 ****************************************************************************/
-static int make_bak_dir(char *fname,char *bak_path)
+static int make_bak_dir(char *fname, char *bak_path)
 {
         STRUCT_STAT st;
         STRUCT_STAT *st2;
         char fullpath[MAXPATHLEN];
         extern int orig_umask;
         char *p;
         char *q;
 
-        while(strncmp(bak_path,"./",2)==0) bak_path += 2;
+	while(strncmp(bak_path, "./", 2) == 0) bak_path += 2;
 
-        if(bak_path[strlen(bak_path)-1]!='/') {
-                snprintf(fullpath,sizeof(fullpath),"%s/",bak_path);
+	if(bak_path[strlen(bak_path)-1] != '/') {
+		snprintf(fullpath, sizeof(fullpath), "%s/", bak_path);
         } else {
-                snprintf(fullpath,sizeof(fullpath),"%s",bak_path);
+		snprintf(fullpath, sizeof(fullpath), "%s", bak_path);
         }
-        p=fullpath;
-        q=&fullpath[strlen(fullpath)];  /* End of bak_path string */
-        strcat(fullpath,fname);
+	p = fullpath;
+	q = &fullpath[strlen(fullpath)];  /* End of bak_path string */
+	strcat(fullpath, fname);
 
         /* Make the directories */
-        while ((p=strchr(p,'/'))) {
+	while ((p = strchr(p, '/'))) {
                 *p = 0;
-                if(do_lstat(fullpath,&st)!=0) {
-                        do_mkdir(fullpath,0777 & ~orig_umask);
+		if(do_lstat(fullpath, &st) != 0) {
+			do_mkdir(fullpath, 0777 & ~orig_umask);
                         if(p>q) {
-                                if(do_lstat(q,&st)!=0) {
-                                        rprintf(FERROR,"make_bak_dir stat %s : %s\n",fullpath,strerror(errno));
+				if(do_lstat(q, &st) != 0) {
+					rprintf(FERROR, "make_bak_dir stat %s failed: %s\n",
+						full_fname(fullpath), strerror(errno));
                                 } else {
-                                        st2=&st;
-                                        set_modtime(fullpath,st2->st_mtime);
-                                        if(do_lchown(fullpath,st2->st_uid,st2->st_gid)!=0) {
-                                                rprintf(FERROR,"make_bak_dir chown %s : %s\n",fullpath,strerror(errno));
-                                        };
-                                        if(do_chmod(fullpath,st2->st_mode)!=0) {
-                                                rprintf(FERROR,"make_bak_dir failed to set permissions on %s : %s\n",fullpath,strerror(errno));
-                                        };
-                                };
+					st2 = &st;
+					set_modtime(fullpath, st2->st_mtime);
+					if(do_lchown(fullpath, st2->st_uid, st2->st_gid) != 0) {
+						rprintf(FERROR, "make_bak_dir chown %s failed: %s\n",
+							full_fname(fullpath), strerror(errno));
+					}
+					if(do_chmod(fullpath, st2->st_mode) != 0) {
+						rprintf(FERROR, "make_bak_dir failed to set permissions on %s: %s\n",
+							full_fname(fullpath), strerror(errno));
+					}
+				}
                         }
-                };
+		}
                 *p = '/';
                 p++;
         }
         return 0;
 }
 
@@ -144,22 +147,22 @@
 			failed = robust_rename (src, dst);
 		}
 
 		if (failed) {
 			if (verbose > 2)
 				rprintf (FERROR, "robust_move failed: %s(%d)\n",
-					strerror (errno), errno);
+				    strerror (errno), errno);
 			switch (errno) {
 				/* external filesystem */
 				case EXDEV:
 					keep_path_extfs = 1;
 					keep_trying--;
 					break;
 				/* no directory to write to */
 				case ENOENT:
-					make_dir (dst, 0755);
+					make_dir(dst, 0700);
 					keep_trying--;
 					break;
 				default:
 					keep_trying = 0;
 			} /* switch */
 		} else
@@ -177,108 +180,110 @@
 	static int initialised;
 
 	char keep_name [MAXPATHLEN];
 	STRUCT_STAT st;
 	struct file_struct *file;
 
-	int kept=0;
+	int kept = 0;
 	int ret_code;
 
 	if (!initialised) {
-		if (backup_dir[strlen(backup_dir) - 1] == '/')
-			backup_dir[strlen(backup_dir) - 1] = 0;
+		if (backup_dir_len && backup_dir[backup_dir_len - 1] == '/')
+			backup_dir[--backup_dir_len] = '\0';
 		if (verbose > 0)
 			rprintf (FINFO, "backup_dir is %s\n", backup_dir);
 		initialised = 1;
 	}
 
 	/* return if no file to keep */
 #if SUPPORT_LINKS
 	if (do_lstat (fname, &st)) return 1;
 #else
 	if (do_stat (fname, &st)) return 1;
 #endif
 
-	file = make_file(-1, fname, NULL, 1);
+	file = make_file(fname, NULL, NO_EXCLUDES);
 
 	/* the file could have disappeared */
 	if (!file) return 1;
 
         /* make a complete pathname for backup file */
-        if (strlen(backup_dir) + strlen(fname) + 
-		(suffix_specified ? strlen(backup_suffix) : 0) > (MAXPATHLEN - 1)) {
+	if (backup_dir_len+strlen(fname)+backup_suffix_len > MAXPATHLEN-1) {
                 rprintf (FERROR, "keep_backup filename too long\n");
                 return 0;
         }
 
-	if (suffix_specified) {
-        	snprintf(keep_name, sizeof (keep_name), "%s/%s%s", backup_dir, fname, backup_suffix);
-		} else {
-        	snprintf(keep_name, sizeof (keep_name), "%s/%s", backup_dir, fname);
-		}
-
+	snprintf(keep_name, sizeof (keep_name), "%s/%s%s",
+	    backup_dir, fname, backup_suffix);
 
 #ifdef HAVE_MKNOD
 	/* Check to see if this is a device file, or link */
         if(IS_DEVICE(file->mode)) {
                 if(am_root && preserve_devices) {
-                        make_bak_dir(fname,backup_dir);
-                        if(do_mknod(keep_name,file->mode,file->rdev)!=0) {
-                                rprintf(FERROR,"mknod %s : %s\n",keep_name,strerror(errno));
-                        } else {
-                                if(verbose>2)
-                                        rprintf(FINFO,"make_backup : DEVICE %s successful.\n",fname);
-                        };
-                };
-		kept=1;
+			make_bak_dir(fname, backup_dir);
+			if(do_mknod(keep_name, file->mode, file->rdev) != 0) {
+				rprintf(FERROR, "mknod %s failed: %s\n",
+					full_fname(keep_name), strerror(errno));
+			} else if(verbose>2) {
+				rprintf(FINFO, "make_backup: DEVICE %s successful.\n", fname);
+			}
+		}
+		kept = 1;
                 do_unlink(fname);
-        };
+	}
 #endif
 
 	if(!kept && S_ISDIR(file->mode)) {
 		/* make an empty directory */
-                make_bak_dir(fname,backup_dir);
-                do_mkdir(keep_name,file->mode);
-                ret_code=do_rmdir(fname);
-                if(verbose>2)
-                        rprintf(FINFO,"make_backup : RMDIR %s returns %i\n",fname,ret_code);
-		kept=1;
-        };
+		make_bak_dir(fname, backup_dir);
+		do_mkdir(keep_name, file->mode);
+		ret_code = do_rmdir(fname);
+
+		if(verbose>2) {
+			rprintf(FINFO, "make_backup: RMDIR %s returns %i\n",
+				full_fname(fname), ret_code);
+		}
+		kept = 1;
+	}
 
 #if SUPPORT_LINKS
         if(!kept && preserve_links && S_ISLNK(file->mode)) {
                 extern int safe_symlinks;
                 if (safe_symlinks && unsafe_symlink(file->link, keep_name)) {
                         if (verbose) {
-                                rprintf(FINFO,"ignoring unsafe symlink %s -> %s\n",
-                                        keep_name,file->link);
+				rprintf(FINFO, "ignoring unsafe symlink %s -> %s\n",
+					full_fname(keep_name), file->link);
                         }
-			kept=1;
+			kept = 1;
+		}
+		make_bak_dir(fname, backup_dir);
+		if(do_symlink(file->link, keep_name) != 0) {
+			rprintf(FERROR, "link %s -> %s : %s\n",
+				full_fname(keep_name), file->link, strerror(errno));
                 }
-                make_bak_dir(fname,backup_dir);
-                if(do_symlink(file->link,keep_name) != 0) {
-                        rprintf(FERROR,"link %s -> %s : %s\n",keep_name,file->link,strerror(errno));
-                };
                 do_unlink(fname);
-		kept=1;
-        };
+		kept = 1;
+	}
 #endif
         if(!kept && preserve_hard_links && check_hard_link(file)) {
-                if(verbose > 1) rprintf(FINFO,"%s is a hard link\n",f_name(file));
-        };
+		if(verbose > 1)
+			rprintf(FINFO, "%s is a hard link\n", f_name(file));
+	}
 
         if(!kept && !S_ISREG(file->mode)) {
-                rprintf(FINFO,"make_bak: skipping non-regular file %s\n",fname);
+		rprintf(FINFO, "make_bak: skipping non-regular file %s\n",
+		    fname);
         }
 
 	/* move to keep tree if a file */
 	if(!kept) {
-		if (!robust_move (fname, keep_name))
-			rprintf(FERROR, "keep_backup failed %s -> %s : %s\n",
-				fname, keep_name, strerror(errno));
-	};
+		if (!robust_move (fname, keep_name)) {
+			rprintf(FERROR, "keep_backup failed: %s -> \"%s\": %s\n",
+				full_fname(fname), keep_name, strerror(errno));
+		}
+	}
 	set_perms (keep_name, file, NULL, 0);
 	free_file (file);
 	free (file);
 
 	if (verbose > 1)
 		rprintf (FINFO, "keep_backup %s -> %s\n", fname, keep_name);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/checksum.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/checksum.c	2003-12-07 05:07:27.000000000 +0800
@@ -21,13 +21,13 @@
 
 int csum_length=2; /* initial value */
 
 #define CSUM_CHUNK 64
 
 int checksum_seed = 0;
-extern int remote_version;
+extern int protocol_version;
 
 /*
   a simple 32 bit checksum that can be upadted from either end
   (inspired by Mark Adler's Adler-32 checksum)
   */
 uint32 get_checksum1(char *buf1,int len)
@@ -71,13 +71,19 @@
 		len += 4;
 	}
 	
 	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
 		mdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);
 	}
-	if (len - i > 0) {
+	/*
+	 * Prior to version 27 an incorrect MD4 checksum was computed
+	 * by failing to call mdfour_tail() for block sizes that
+	 * are multiples of 64.  This is fixed by calling mdfour_update()
+	 * even when there are no more bytes.
+	 */
+	if (len - i > 0 || protocol_version >= 27) {
 		mdfour_update(&m, (uchar *)(buf1+i), (len-i));
 	}
 	
 	mdfour_result(&m, (uchar *)sum);
 }
 
@@ -102,34 +108,32 @@
 
 	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
 		memcpy(tmpchunk, map_ptr(buf,i,CSUM_CHUNK), CSUM_CHUNK);
 		mdfour_update(&m, (uchar *)tmpchunk, CSUM_CHUNK);
 	}
 
+	/*
+	 * Prior to version 27 an incorrect MD4 checksum was computed
+	 * by failing to call mdfour_tail() for block sizes that
+	 * are multiples of 64.  This is fixed by calling mdfour_update()
+	 * even when there are no more bytes.
+	 */
 	if (len - i > 0) {
 		memcpy(tmpchunk, map_ptr(buf,i,len-i), len-i);
+	}
+	if (len - i > 0 || protocol_version >= 27) {
 		mdfour_update(&m, (uchar *)tmpchunk, (len-i));
 	}
 
 	mdfour_result(&m, (uchar *)sum);
 
 	close(fd);
 	unmap_file(buf);
 }
 
 
-void checksum_init(void)
-{
-  if (remote_version >= 14)
-    csum_length = 2; /* adaptive */
-  else
-    csum_length = SUM_LENGTH;
-}
-
-
-
 static int sumresidue;
 static char sumrbuf[CSUM_CHUNK];
 static struct mdfour md;
 
 void sum_init(void)
 {
@@ -177,12 +181,12 @@
 		sumresidue = 0;    
 	}
 }
 
 void sum_end(char *sum)
 {
-	if (sumresidue) {
+	if (sumresidue || protocol_version >= 27) {
 		mdfour_update(&md, (uchar *)sumrbuf, sumresidue);
 	}
 
 	mdfour_result(&md, (uchar *)sum);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/cleanup.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/cleanup.c	2003-12-15 16:08:44.000000000 +0800
@@ -128,14 +128,17 @@
 		char *pidf = lp_pid_file();
 		if (pidf && *pidf) {
 			unlink(lp_pid_file());
 		}
 	}
 
-	if (code == 0 && (io_error || log_got_error)) {
-		code = RERR_PARTIAL;
+	if (code == 0) {
+		if ((io_error & ~IOERR_VANISHED) || log_got_error)
+			code = RERR_PARTIAL;
+		else if (io_error)
+			code = RERR_VANISHED;
 	}
 
 	if (code) log_exit(code, file, line);
 
 	if (verbose > 2)
 		rprintf(FINFO,"_exit_cleanup(code=%d, file=%s, line=%d): about to call exit(%d)\n", 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/clientserver.c	2003-01-27 04:08:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/clientserver.c	2003-09-11 12:00:19.000000000 +0800
@@ -1,21 +1,21 @@
 /* -*- c-file-style: "linux"; -*-
- * 
+ *
  * Copyright (C) 1998-2001 by Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2001-2002 by Martin Pool <mbp@samba.org>
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /**
@@ -30,12 +30,17 @@
 extern int module_id;
 extern int read_only;
 extern int verbose;
 extern int rsync_port;
 char *auth_user;
 extern int sanitize_paths;
+extern int filesfrom_fd;
+extern int remote_protocol;
+extern int protocol_version;
+extern struct exclude_struct **server_exclude_list;
+extern char *exclude_path_prefix;
 
 /**
  * Run a client connected to an rsyncd.  The alternative to this
  * function for remote-shell connections is do_cmd().
  *
  * After negotiating which module to use and reading the server's
@@ -51,16 +56,16 @@
 int start_socket_client(char *host, char *path, int argc, char *argv[])
 {
 	int fd, ret;
 	char *p, *user=NULL;
 	extern char *bind_address;
 	extern int default_af_hint;
-       
+
 	/* this is redundant with code in start_inband_exchange(), but
-	   this short-circuits a problem before we open a socket, and 
-	   the extra check won't hurt */
+	 * this short-circuits a problem before we open a socket, and
+	 * the extra check won't hurt */
 	if (*path == '/') {
 		rprintf(FERROR,"ERROR: The remote path must start with a module name not a /\n");
 		return -1;
 	}
 
 	p = strchr(host, '@');
@@ -74,14 +79,14 @@
 		/* FIXME: If we're going to use a socket program for
 		 * testing, then this message is wrong.  We need to
 		 * say something like "(except really using %s)" */
 		rprintf(FINFO, "opening tcp connection to %s port %d\n",
 			host, rsync_port);
 	}
-	fd = open_socket_out_wrapped (host, rsync_port, bind_address,
-				      default_af_hint);
+	fd = open_socket_out_wrapped(host, rsync_port, bind_address,
+				     default_af_hint);
 	if (fd == -1) {
 		exit_cleanup(RERR_SOCKETIO);
 	}
 
 	ret = start_inband_exchange(user, path, fd, fd, argc);
 
@@ -92,13 +97,12 @@
 {
 	int i;
 	char *sargs[MAX_ARGS];
 	int sargc = 0;
 	char line[MAXPATHLEN];
 	char *p;
-	extern int remote_version;
 	extern int kludge_around_eof;
 	extern int am_sender;
 	extern int daemon_over_rsh;
 	extern int list_only;
 
 	if (argc == 0 && !am_sender)
@@ -109,47 +113,49 @@
 		return -1;
 	}
 
 	if (!user) user = getenv("USER");
 	if (!user) user = getenv("LOGNAME");
 
-	/* set daemon_over_rsh to false since we need to build the 
-	   true set of args passed through the rsh/ssh connection; 
-	   this is a no-op for direct-socket-connection mode */
+	/* set daemon_over_rsh to false since we need to build the
+	 * true set of args passed through the rsh/ssh connection;
+	 * this is a no-op for direct-socket-connection mode */
 	daemon_over_rsh = 0;
 	server_options(sargs, &sargc);
 
 	sargs[sargc++] = ".";
 
-	if (path && *path) 
+	if (path && *path)
 		sargs[sargc++] = path;
 
 	sargs[sargc] = NULL;
 
 	io_printf(f_out, "@RSYNCD: %d\n", PROTOCOL_VERSION);
 
 	if (!read_line(f_in, line, sizeof(line)-1)) {
 		rprintf(FERROR, "rsync: did not see server greeting\n");
 		return -1;
 	}
 
-	if (sscanf(line,"@RSYNCD: %d", &remote_version) != 1) {
+	if (sscanf(line,"@RSYNCD: %d", &remote_protocol) != 1) {
 		/* note that read_line strips of \n or \r */
 		rprintf(FERROR, "rsync: server sent \"%s\" rather than greeting\n",
 			line);
 		return -1;
 	}
+	if (protocol_version > remote_protocol)
+		protocol_version = remote_protocol;
 
 	p = strchr(path,'/');
 	if (p) *p = 0;
 	io_printf(f_out, "%s\n", path);
 	if (p) *p = '/';
 
 	/* Old servers may just drop the connection here,
 	 rather than sending a proper EXIT command.  Yuck. */
-	kludge_around_eof = list_only && (remote_version < 25);
+	kludge_around_eof = list_only && (protocol_version < 25);
 
 	while (1) {
 		if (!read_line(f_in, line, sizeof(line)-1)) {
 			rprintf(FERROR, "rsync: didn't get server startup line\n");
 			return -1;
 		}
@@ -182,14 +188,14 @@
 
 	for (i = 0; i < sargc; i++) {
 		io_printf(f_out, "%s\n", sargs[i]);
 	}
 	io_printf(f_out, "\n");
 
-	if (remote_version < 23) {
-		if (remote_version == 22 || (remote_version > 17 && !am_sender))
+	if (protocol_version < 23) {
+		if (protocol_version == 22 || (protocol_version > 17 && !am_sender))
 			io_start_multiplex_in(f_in);
 	}
 
 	return 0;
 }
 
@@ -211,13 +217,12 @@
 	int start_glob=0;
 	int ret;
 	char *request=NULL;
 	extern int am_sender;
 	extern int am_server;
 	extern int am_daemon;
-	extern int remote_version;
 	extern int am_root;
 
 	if (!allow_access(addr, host, lp_hosts_allow(i), lp_hosts_deny(i))) {
 		rprintf(FERROR,"rsync denied on module %s from %s (%s)\n",
 			name, host, addr);
 		io_printf(f_out, "@ERROR: access denied to %s from %s (%s)\n",
@@ -236,25 +241,26 @@
 				lp_lock_file(i), strerror(errno));
 			io_printf(f_out, "@ERROR: failed to open lock file %s : %s\n",
 				  lp_lock_file(i), strerror(errno));
 		} else {
 			rprintf(FERROR,"max connections (%d) reached\n",
 				lp_max_connections(i));
-			io_printf(f_out, "@ERROR: max connections (%d) reached - try again later\n", lp_max_connections(i));
+			io_printf(f_out, "@ERROR: max connections (%d) reached - try again later\n",
+				lp_max_connections(i));
 		}
 		return -1;
 	}
 
-	
+
 	auth_user = auth_server(f_in, f_out, i, addr, "@RSYNCD: AUTHREQD ");
 
 	if (!auth_user) {
 		rprintf(FERROR,"auth failed on module %s from %s (%s)\n",
 			name, host, addr);
 		io_printf(f_out, "@ERROR: auth failed on module %s\n", name);
-		return -1;		
+		return -1;
 	}
 
 	module_id = i;
 
 	am_root = (getuid() == 0);
 
@@ -262,45 +268,51 @@
 		p = lp_uid(i);
 		if (!name_to_uid(p, &uid)) {
 			if (!isdigit(* (unsigned char *) p)) {
 				rprintf(FERROR,"Invalid uid %s\n", p);
 				io_printf(f_out, "@ERROR: invalid uid %s\n", p);
 				return -1;
-			} 
+			}
 			uid = atoi(p);
 		}
 
 		p = lp_gid(i);
 		if (!name_to_gid(p, &gid)) {
 			if (!isdigit(* (unsigned char *) p)) {
 				rprintf(FERROR,"Invalid gid %s\n", p);
 				io_printf(f_out, "@ERROR: invalid gid %s\n", p);
 				return -1;
-			} 
+			}
 			gid = atoi(p);
 		}
 	}
-        
+
         /* TODO: If we're not root, but the configuration requests
          * that we change to some uid other than the current one, then
          * log a warning. */
 
         /* TODO: Perhaps take a list of gids, and make them into the
          * supplementary groups. */
 
+	exclude_path_prefix = use_chroot? "" : lp_path(i);
+	if (*exclude_path_prefix == '/' && !exclude_path_prefix[1])
+		exclude_path_prefix = "";
+
 	p = lp_include_from(i);
-	add_exclude_file(p, 1, 1);
+	add_exclude_file(&server_exclude_list, p, MISSING_FATAL, ADD_INCLUDE);
 
 	p = lp_include(i);
-	add_include_line(p);
+	add_exclude_line(&server_exclude_list, p, ADD_INCLUDE);
 
 	p = lp_exclude_from(i);
-	add_exclude_file(p, 1, 0);
+	add_exclude_file(&server_exclude_list, p, MISSING_FATAL, ADD_EXCLUDE);
 
 	p = lp_exclude(i);
-	add_exclude_line(p);
+	add_exclude_line(&server_exclude_list, p, ADD_EXCLUDE);
+
+	exclude_path_prefix = NULL;
 
 	log_init();
 
 	if (use_chroot) {
 		/*
 		 * XXX: The 'use chroot' flag is a fairly reliable
@@ -333,22 +345,12 @@
 			return -1;
 		}
 		sanitize_paths = 1;
 	}
 
 	if (am_root) {
-#ifdef HAVE_SETGROUPS
-		/* Get rid of any supplementary groups this process
-		 * might have inheristed. */
-		if (setgroups(0, NULL)) {
-			rsyserr(FERROR, errno, "setgroups failed");
-			io_printf(f_out, "@ERROR: setgroups failed\n");
-			return -1;
-		}
-#endif
-
 		/* XXXX: You could argue that if the daemon is started
 		 * by a non-root user and they explicitly specify a
 		 * gid, then we should try to change to that gid --
 		 * this could be possible if it's already in their
 		 * supplementary groups. */
 
@@ -358,12 +360,21 @@
 
 		if (setgid(gid)) {
 			rsyserr(FERROR, errno, "setgid %d failed", (int) gid);
 			io_printf(f_out, "@ERROR: setgid failed\n");
 			return -1;
 		}
+#ifdef HAVE_SETGROUPS
+		/* Get rid of any supplementary groups this process
+		 * might have inheristed. */
+		if (setgroups(1, &gid)) {
+			rsyserr(FERROR, errno, "setgroups failed");
+			io_printf(f_out, "@ERROR: setgroups failed\n");
+			return -1;
+		}
+#endif
 
 		if (setuid(uid)) {
 			rsyserr(FERROR, errno, "setuid %d failed", (int) uid);
 			io_printf(f_out, "@ERROR: setuid failed\n");
 			return -1;
 		}
@@ -421,12 +432,15 @@
 		}
 	}
 
         argp = argv;
 	ret = parse_arguments(&argc, (const char ***) &argp, 0);
 
+	if (filesfrom_fd == 0)
+		filesfrom_fd = f_in;
+
 	if (request) {
 		if (*auth_user) {
 			rprintf(FINFO,"rsync %s %s from %s@%s (%s)\n",
 				am_sender?"on":"to",
 				request, auth_user, host, addr);
 		} else {
@@ -439,17 +453,17 @@
 
 #ifndef DEBUG
 	/* don't allow the logs to be flooded too fast */
 	if (verbose > 1) verbose = 1;
 #endif
 
-	if (remote_version < 23) {
-		if (remote_version == 22 || (remote_version > 17 && am_sender))
+	if (protocol_version < 23) {
+		if (protocol_version == 22 || (protocol_version > 17 && am_sender))
 			io_start_multiplex_out(f_out);
 	}
-        
+
         /* For later protocol versions, we don't start multiplexing
          * until we've configured nonblocking in start_server.  That
          * means we're in a sticky situation now: there's no way to
          * convey errors to the client. */
 
         /* FIXME: Hold off on reporting option processing errors until
@@ -473,32 +487,30 @@
 /* send a list of available modules to the client. Don't list those
    with "list = False". */
 static void send_listing(int fd)
 {
 	int n = lp_numservices();
 	int i;
-	extern int remote_version;
 
 	for (i=0;i<n;i++)
 		if (lp_list(i))
-		    io_printf(fd, "%-15s\t%s\n", lp_name(i), lp_comment(i));
+			io_printf(fd, "%-15s\t%s\n", lp_name(i), lp_comment(i));
 
-	if (remote_version >= 25)
+	if (protocol_version >= 25)
 		io_printf(fd,"@RSYNCD: EXIT\n");
 }
 
 /* this is called when a connection is established to a client
    and we want to start talking. The setup of the system is done from
    here */
 int start_daemon(int f_in, int f_out)
 {
 	char line[200];
 	char *motd;
 	int i = -1;
 	extern char *config_file;
-	extern int remote_version;
 	extern int am_server;
 
 	if (!lp_load(config_file, 0)) {
 		exit_cleanup(RERR_SYNTAX);
 	}
 
@@ -527,27 +539,29 @@
 	}
 
 	if (!read_line(f_in, line, sizeof(line)-1)) {
 		return -1;
 	}
 
-	if (sscanf(line,"@RSYNCD: %d", &remote_version) != 1) {
+	if (sscanf(line,"@RSYNCD: %d", &remote_protocol) != 1) {
 		io_printf(f_out, "@ERROR: protocol startup error\n");
 		return -1;
-	}	
+	}
+	if (protocol_version > remote_protocol)
+		protocol_version = remote_protocol;
 
 	while (i == -1) {
 		line[0] = 0;
 		if (!read_line(f_in, line, sizeof(line)-1)) {
 			return -1;
 		}
 
 		if (!*line || strcmp(line,"#list")==0) {
 			send_listing(f_out);
 			return -1;
-		} 
+		}
 
 		if (*line == '#') {
 			/* it's some sort of command that I don't understand */
 			io_printf(f_out, "@ERROR: Unknown command '%s'\n", line);
 			return -1;
 		}
@@ -571,48 +585,47 @@
 	extern int no_detach;
 
 	if (is_a_socket(STDIN_FILENO)) {
 		int i;
 
 		/* we are running via inetd - close off stdout and
-		   stderr so that library functions (and getopt) don't
-		   try to use them. Redirect them to /dev/null */
+		 * stderr so that library functions (and getopt) don't
+		 * try to use them. Redirect them to /dev/null */
 		for (i=1;i<3;i++) {
-			close(i); 
+			close(i);
 			open("/dev/null", O_RDWR);
 		}
 
 		return start_daemon(STDIN_FILENO, STDIN_FILENO);
 	}
 
 	if (!no_detach)
-	    become_daemon();
+		become_daemon();
 
 	if (!lp_load(config_file, 1)) {
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	log_init();
 
 	rprintf(FINFO, "rsyncd version %s starting, listening on port %d\n",
-		RSYNC_VERSION,
-                rsync_port);
+		RSYNC_VERSION, rsync_port);
         /* TODO: If listening on a particular address, then show that
          * address too.  In fact, why not just do inet_ntop on the
          * local address??? */
 
 	if (((pid_file = lp_pid_file()) != NULL) && (*pid_file != '\0')) {
 		char pidbuf[16];
 		int fd;
 		int pid = (int) getpid();
 		cleanup_set_pid(pid);
 		if ((fd = do_open(lp_pid_file(), O_WRONLY|O_CREAT|O_TRUNC,
 					0666 & ~orig_umask)) == -1) {
-		    cleanup_set_pid(0);
-		    rsyserr(FLOG, errno, "failed to create pid file %s", pid_file);
-		    exit_cleanup(RERR_FILEIO);
+			cleanup_set_pid(0);
+			rsyserr(FLOG, errno, "failed to create pid file %s", pid_file);
+			exit_cleanup(RERR_FILEIO);
 		}
 		snprintf(pidbuf, sizeof(pidbuf), "%d\n", pid);
 		write(fd, pidbuf, strlen(pidbuf));
 		close(fd);
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/compat.c	2002-04-08 11:43:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/compat.c	2003-09-11 12:48:07.000000000 +0800
@@ -22,58 +22,75 @@
  *
  * Compatibility routines for older rsync protocol versions.
  **/
 
 #include "rsync.h"
 
+int remote_protocol = 0;
+
 extern int am_server;
 
 extern int preserve_links;
 extern int preserve_perms;
 extern int preserve_devices;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_times;
 extern int always_checksum;
 extern int checksum_seed;
 
 
-extern int remote_version;
+extern int protocol_version;
 extern int verbose;
 
-extern int read_batch;  /* dw */
-extern int write_batch;  /* dw */
+extern int read_batch;
+extern int write_batch;
 
 void setup_protocol(int f_out,int f_in)
 {
-	if (remote_version == 0) {
+	if (remote_protocol == 0) {
 		if (am_server) {
-			remote_version = read_int(f_in);
-			write_int(f_out,PROTOCOL_VERSION);
+			remote_protocol = read_int(f_in);
+			write_int(f_out, protocol_version);
 		} else {
-			write_int(f_out,PROTOCOL_VERSION);
-			remote_version = read_int(f_in);
+			write_int(f_out, protocol_version);
+			remote_protocol = read_int(f_in);
 		}
+		if (protocol_version > remote_protocol)
+			protocol_version = remote_protocol;
 	}
 
-	if (remote_version < MIN_PROTOCOL_VERSION ||
-	    remote_version > MAX_PROTOCOL_VERSION) {
+	if (verbose > 3) {
+		rprintf(FINFO, "(%s) Protocol versions: remote=%d, negotiated=%d\n",
+			am_server? "Server" : "Client", remote_protocol, protocol_version);
+	}
+	if (remote_protocol < MIN_PROTOCOL_VERSION
+	 || remote_protocol > MAX_PROTOCOL_VERSION) {
 		rprintf(FERROR,"protocol version mismatch - is your shell clean?\n");
 		rprintf(FERROR,"(see the rsync man page for an explanation)\n");
 		exit_cleanup(RERR_PROTOCOL);
-	}	
-	
-	if (remote_version >= 12) {
-		if (am_server) {
-		    if (read_batch || write_batch) /* dw */
+	}
+	if (remote_protocol < OLD_PROTOCOL_VERSION) {
+		rprintf(FINFO,"%s is very old version of rsync, upgrade recommended.\n",
+			am_server? "Client" : "Server");
+	}
+	if (protocol_version < MIN_PROTOCOL_VERSION) {
+		rprintf(FERROR, "--protocol must be at least %d on the %s.\n",
+			MIN_PROTOCOL_VERSION, am_server? "Server" : "Client");
+		exit_cleanup(RERR_PROTOCOL);
+	}
+	if (protocol_version > PROTOCOL_VERSION) {
+		rprintf(FERROR, "--protocol must be no more than %d on the %s.\n",
+			PROTOCOL_VERSION, am_server? "Server" : "Client");
+		exit_cleanup(RERR_PROTOCOL);
+	}
+
+	if (am_server) {
+		if (read_batch || write_batch)
 			checksum_seed = 32761;
-		    else
+		else
 			checksum_seed = time(NULL);
-			write_int(f_out,checksum_seed);
-		} else {
-			checksum_seed = read_int(f_in);
-		}
+		write_int(f_out,checksum_seed);
+	} else {
+		checksum_seed = read_int(f_in);
 	}
-	
-	checksum_init();
 }
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/config.h.in	2003-01-28 13:05:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/config.h.in	2003-07-30 14:12:38.000000000 +0800
@@ -73,15 +73,12 @@
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
 /* Define to 1 if you have the <float.h> header file. */
 #undef HAVE_FLOAT_H
 
-/* */
-#undef HAVE_FNMATCH
-
 /* Define to 1 if you have the `fstat' function. */
 #undef HAVE_FSTAT
 
 /* Define if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/configure	2003-12-04 12:27:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/configure	2004-01-02 03:09:16.000000000 +0800
@@ -1,70 +1,72 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.53.
+# Generated by GNU Autoconf 2.57.
 #
 # Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
 # Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
-
-if expr a : '\(a\)' >/dev/null 2>&1; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-
 ## --------------------- ##
 ## M4sh Initialization.  ##
 ## --------------------- ##
 
 # Be Bourne compatible
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
 elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
   set -o posix
 fi
 
-# NLS nuisances.
 # Support unset when possible.
 if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
 fi
 
-(set +x; test -n "`(LANG=C; export LANG) 2>&1`") &&
-    { $as_unset LANG || test "${LANG+set}" != set; } ||
-      { LANG=C; export LANG; }
-(set +x; test -n "`(LC_ALL=C; export LC_ALL) 2>&1`") &&
-    { $as_unset LC_ALL || test "${LC_ALL+set}" != set; } ||
-      { LC_ALL=C; export LC_ALL; }
-(set +x; test -n "`(LC_TIME=C; export LC_TIME) 2>&1`") &&
-    { $as_unset LC_TIME || test "${LC_TIME+set}" != set; } ||
-      { LC_TIME=C; export LC_TIME; }
-(set +x; test -n "`(LC_CTYPE=C; export LC_CTYPE) 2>&1`") &&
-    { $as_unset LC_CTYPE || test "${LC_CTYPE+set}" != set; } ||
-      { LC_CTYPE=C; export LC_CTYPE; }
-(set +x; test -n "`(LANGUAGE=C; export LANGUAGE) 2>&1`") &&
-    { $as_unset LANGUAGE || test "${LANGUAGE+set}" != set; } ||
-      { LANGUAGE=C; export LANGUAGE; }
-(set +x; test -n "`(LC_COLLATE=C; export LC_COLLATE) 2>&1`") &&
-    { $as_unset LC_COLLATE || test "${LC_COLLATE+set}" != set; } ||
-      { LC_COLLATE=C; export LC_COLLATE; }
-(set +x; test -n "`(LC_NUMERIC=C; export LC_NUMERIC) 2>&1`") &&
-    { $as_unset LC_NUMERIC || test "${LC_NUMERIC+set}" != set; } ||
-      { LC_NUMERIC=C; export LC_NUMERIC; }
-(set +x; test -n "`(LC_MESSAGES=C; export LC_MESSAGES) 2>&1`") &&
-    { $as_unset LC_MESSAGES || test "${LC_MESSAGES+set}" != set; } ||
-      { LC_MESSAGES=C; export LC_MESSAGES; }
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
 
 
 # Name of the executable.
-as_me=`(basename "$0") 2>/dev/null ||
+as_me=`$as_basename "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)$' \| \
 	 .     : '\(.\)' 2>/dev/null ||
 echo X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
@@ -79,21 +82,21 @@
 as_cr_Letters=$as_cr_letters$as_cr_LETTERS
 as_cr_digits='0123456789'
 as_cr_alnum=$as_cr_Letters$as_cr_digits
 
 # The user is always right.
 if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conftest.sh
-  echo  "exit 0"   >>conftest.sh
-  chmod +x conftest.sh
-  if (PATH=".;."; conftest.sh) >/dev/null 2>&1; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
     PATH_SEPARATOR=';'
   else
     PATH_SEPARATOR=:
   fi
-  rm -f conftest.sh
+  rm -f conf$$.sh
 fi
 
 
   as_lineno_1=$LINENO
   as_lineno_2=$LINENO
   as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
@@ -135,12 +138,14 @@
 	   if ("$as_dir/$as_base" -c '
   as_lineno_1=$LINENO
   as_lineno_2=$LINENO
   as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
   test "x$as_lineno_1" != "x$as_lineno_2" &&
   test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
 	     CONFIG_SHELL=$as_dir/$as_base
 	     export CONFIG_SHELL
 	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
 	   fi;;
 	 esac
        done
@@ -207,12 +212,18 @@
   as_ln_s=ln
 else
   as_ln_s='cp -p'
 fi
 rm -f conf$$ conf$$.exe conf$$.file
 
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  as_mkdir_p=false
+fi
+
 as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
 
 # Sed expression to map a string onto a valid variable name.
@@ -223,13 +234,13 @@
 # We need space, tab and new line, in precisely that order.
 as_nl='
 '
 IFS=" 	$as_nl"
 
 # CDPATH.
-$as_unset CDPATH || test "${CDPATH+set}" != set || { CDPATH=$PATH_SEPARATOR; export CDPATH; }
+$as_unset CDPATH
 
 
 # Name of the host.
 # hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
 # so uname gets run too.
 ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
@@ -237,12 +248,13 @@
 exec 6>&1
 
 #
 # Initializations.
 #
 ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
 cross_compiling=no
 subdirs=
 MFLAGS=
 MAKEFLAGS=
 SHELL=${CONFIG_SHELL-/bin/sh}
 
@@ -293,12 +305,14 @@
 # endif
 #endif
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif"
 
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS RSYNC_VERSION build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA HAVE_REMSH EGREP LIBOBJS ALLOCA OBJ_SAVE OBJ_RESTORE CC_SHOBJ_FLAG BUILD_POPT LTLIBOBJS'
+ac_subst_files=''
 
 # Initialize some variables set by options.
 ac_init_help=
 ac_init_version=false
 # The variables have the same names as the options, with
 # dashes changed to underlines.
@@ -716,12 +730,15 @@
    { (exit 1); exit 1; }; }
   else
     { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
    { (exit 1); exit 1; }; }
   fi
 fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
 srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
 ac_env_build_alias_set=${build_alias+set}
 ac_env_build_alias_value=$build_alias
 ac_cv_env_build_alias_set=${build_alias+set}
 ac_cv_env_build_alias_value=$build_alias
 ac_env_host_alias_set=${host_alias+set}
@@ -836,15 +853,14 @@
   --disable-ipv6          don't even try to use IPv6
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-included-popt    use bundled popt library, not from system
-  --with-rsync-path=PATH  set default --rsync-path to PATH (default: \"rsync\")
-  --with-rsh=CMD          set rsh command to CMD (default: \"remsh\" or
-                          \"rsh\")
+  --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)
+  --with-rsh=CMD          set remote shell command to CMD (default: ssh)
 
 Some influential environment variables:
   CC          C compiler command
   CFLAGS      C compiler flags
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
               nonstandard directory <lib dir>
@@ -888,13 +904,13 @@
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
 # Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
 # absolute.
 ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd $ac_top_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
 ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
 ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
 
     cd $ac_dir
     # Check for guested configure; otherwise get Cygnus style configure.
     if test -f $ac_srcdir/configure.gnu; then
@@ -928,13 +944,13 @@
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.53.  Invocation command line was
+generated by GNU Autoconf 2.57.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
 cat <<_ASUNAME
@@ -980,33 +996,60 @@
 
 _ACEOF
 
 
 # Keep a trace of the command line.
 # Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
 # Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
 ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
 ac_sep=
-for ac_arg
+ac_must_keep_next=false
+for ac_pass in 1 2
 do
-  case $ac_arg in
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c | -n ) continue ;;
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    continue ;;
-  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
-    ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
-  esac
-  case " $ac_configure_args " in
-    *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-    *) ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
-       ac_sep=" " ;;
-  esac
-  # Get rid of the leading space.
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+        ac_must_keep_next=false # Got value, back to normal.
+      else
+        case $ac_arg in
+          *=* | --config-cache | -C | -disable-* | --disable-* \
+          | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+          | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+          | -with-* | --with-* | -without-* | --without-* | --x)
+            case "$ac_configure_args0 " in
+              "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+            esac
+            ;;
+          -* ) ac_must_keep_next=true ;;
+        esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
 done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
 
 # When interrupted or exit'd, cleanup temporary files, and complete
 # config.log.  We remove comments because anyway the quotes in there
 # would cause problems or look ugly.
 # WARNING: Be sure not to use single quotes in there, as some shells,
 # such as our DU 5.0 friend, will then `close' the trap.
@@ -1033,20 +1077,49 @@
       sed -n \
         "s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
       ;;
     esac;
 }
     echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+        echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
     if test -s confdefs.h; then
       cat <<\_ASBOX
 ## ----------- ##
 ## confdefs.h. ##
 ## ----------- ##
 _ASBOX
       echo
-      sed "/^$/d" confdefs.h
+      sed "/^$/d" confdefs.h | sort
       echo
     fi
     test "$ac_signal" != 0 &&
       echo "$as_me: caught signal $ac_signal"
     echo "$as_me: exit $exit_status"
   } >&5
@@ -1198,17 +1271,18 @@
 
 
 
 
 
 
-ac_config_headers="$ac_config_headers config.h"
+
+          ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=2.5.7
+RSYNC_VERSION=2.6.0
 
 { echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
 echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -1527,15 +1601,13 @@
   shift
   if test $# != 0; then
     # We chose a different compiler from the bogus one.
     # However, it has the same basename, so the bogon will be chosen
     # first if we set CC to just the basename; use the full file name.
     shift
-    set dummy "$as_dir/$ac_word" ${1+"$@"}
-    shift
-    ac_cv_prog_CC="$@"
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
   fi
 fi
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
@@ -1634,14 +1706,16 @@
   CC=$ac_ct_CC
 fi
 
 fi
 
 
-test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH" >&5
-echo "$as_me: error: no acceptable C compiler found in \$PATH" >&2;}
+test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&5
+echo "$as_me: error: no acceptable C compiler found in \$PATH
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 
 # Provide some information about the compiler.
 echo "$as_me:$LINENO:" \
      "checking for C compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
@@ -1660,30 +1734,28 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
 
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   ;
   return 0;
 }
 _ACEOF
 ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.exe"
+ac_clean_files="$ac_clean_files a.out a.exe b.out"
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
 echo "$as_me:$LINENO: checking for C compiler default output" >&5
 echo $ECHO_N "checking for C compiler default output... $ECHO_C" >&6
 ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
@@ -1696,32 +1768,45 @@
 # not robust to junk in `.', hence go to wildcards (a.*) only as a last
 # resort.
 
 # Be careful to initialize this variable, since it used to be cached.
 # Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
 ac_cv_exeext=
-for ac_file in `ls a_out.exe a.exe conftest.exe 2>/dev/null;
-                ls a.out conftest 2>/dev/null;
-                ls a.* conftest.* 2>/dev/null`; do
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
+do
+  test -f "$ac_file" || continue
   case $ac_file in
-    *.$ac_ext | *.o | *.obj | *.xcoff | *.tds | *.d | *.pdb | *.xSYM ) ;;
-    a.out ) # We found the default executable, but exeext='' is most
-            # certainly right.
-            break;;
-    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-          # FIXME: I believe we export ac_cv_exeext for Libtool --akim.
-          export ac_cv_exeext
-          break;;
-    * ) break;;
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+        ;;
+    conftest.$ac_ext )
+        # This is the source file.
+        ;;
+    [ab].out )
+        # We found the default executable, but exeext='' is most
+        # certainly right.
+        break;;
+    *.* )
+        ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+        # FIXME: I believe we export ac_cv_exeext for Libtool,
+        # but it would be cool to find out if it's true.  Does anybody
+        # maintain Libtool? --akim.
+        export ac_cv_exeext
+        break;;
+    * )
+        break;;
   esac
 done
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-{ { echo "$as_me:$LINENO: error: C compiler cannot create executables" >&5
-echo "$as_me: error: C compiler cannot create executables" >&2;}
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
+See \`config.log' for more details." >&5
+echo "$as_me: error: C compiler cannot create executables
+See \`config.log' for more details." >&2;}
    { (exit 77); exit 77; }; }
 fi
 
 ac_exeext=$ac_cv_exeext
 echo "$as_me:$LINENO: result: $ac_file" >&5
 echo "${ECHO_T}$ac_file" >&6
@@ -1742,23 +1827,25 @@
     cross_compiling=no
   else
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
 	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'." >&5
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'." >&2;}
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
     fi
   fi
 fi
 echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6
 
-rm -f a.out a.exe conftest$ac_cv_exeext
+rm -f a.out a.exe conftest$ac_cv_exeext b.out
 ac_clean_files=$ac_clean_files_save
 # Check the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
 echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
 echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
 echo "$as_me:$LINENO: result: $cross_compiling" >&5
@@ -1772,24 +1859,27 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   # If both `conftest.exe' and `conftest' are `present' (well, observable)
 # catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
 # work properly (i.e., refer to `conftest.exe'), while it won't with
 # `rm'.
-for ac_file in `(ls conftest.exe; ls conftest; ls conftest.*) 2>/dev/null`; do
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
   case $ac_file in
-    *.$ac_ext | *.o | *.obj | *.xcoff | *.tds | *.d | *.pdb ) ;;
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
           export ac_cv_exeext
           break;;
     * ) break;;
   esac
 done
 else
-  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link" >&5
-echo "$as_me: error: cannot compute suffix of executables: cannot compile and link" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 rm -f conftest$ac_cv_exeext
 echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
 echo "${ECHO_T}$ac_cv_exeext" >&6
@@ -1801,20 +1891,18 @@
 echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
 if test "${ac_cv_objext+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   ;
   return 0;
@@ -1825,22 +1913,25 @@
   (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
   case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb ) ;;
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
     *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
        break;;
   esac
 done
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile" >&5
-echo "$as_me: error: cannot compute suffix of object files: cannot compile" >&2;}
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
@@ -1851,20 +1942,18 @@
 echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
 if test "${ac_cv_c_compiler_gnu+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 #ifndef __GNUC__
        choke me
 #endif
@@ -1885,13 +1974,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_compiler_gnu=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_compiler_gnu=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
@@ -1905,20 +1995,18 @@
 echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
 if test "${ac_cv_prog_cc_g+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   ;
   return 0;
@@ -1936,13 +2024,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_prog_cc_g=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_prog_cc_g=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
 echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
@@ -1958,12 +2047,108 @@
   if test "$GCC" = yes; then
     CFLAGS="-O2"
   else
     CFLAGS=
   fi
 fi
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
 # Some people use a C++ compiler to compile C.  Since we use `exit',
 # in C++ we need to declare it.  In case someone uses the same compiler
 # for both compiling C and C++ we need to have the C++ compiler decide
 # the declaration of exit, since it's the most demanding environment.
 cat >conftest.$ac_ext <<_ACEOF
 #ifndef __cplusplus
@@ -1990,21 +2175,19 @@
    'extern "C" void exit (int) throw ();' \
    'extern "C" void exit (int);' \
    'void exit (int);'
 do
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <stdlib.h>
 $ac_declaration
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 exit (42);
   ;
   return 0;
@@ -2022,26 +2205,25 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   :
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 continue
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_declaration
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 exit (42);
   ;
   return 0;
@@ -2059,26 +2241,28 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 done
 rm -f conftest*
 if test -n "$ac_declaration"; then
   echo '#ifdef __cplusplus' >>confdefs.h
   echo $ac_declaration      >>confdefs.h
   echo '#endif'             >>confdefs.h
 fi
 
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
@@ -2104,24 +2288,34 @@
     do
       ac_preproc_ok=false
 for ac_c_preproc_warn_flag in '' yes
 do
   # Use a header file that comes with gcc, so configuring glibc
   # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
-#include <assert.h>
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
                      Syntax error
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -2132,29 +2326,34 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   :
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   # Broken: fails on valid input.
 continue
 fi
 rm -f conftest.err conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <ac_nonexistent.h>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -2166,13 +2365,14 @@
 fi
 if test -z "$ac_cpp_err"; then
   # Broken: success on invalid input.
 continue
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   # Passes both tests.
 ac_preproc_ok=:
 break
 fi
 rm -f conftest.err conftest.$ac_ext
 
@@ -2195,24 +2395,34 @@
 echo "${ECHO_T}$CPP" >&6
 ac_preproc_ok=false
 for ac_c_preproc_warn_flag in '' yes
 do
   # Use a header file that comes with gcc, so configuring glibc
   # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
-#include <assert.h>
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
                      Syntax error
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -2223,29 +2433,34 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   :
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   # Broken: fails on valid input.
 continue
 fi
 rm -f conftest.err conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <ac_nonexistent.h>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -2257,27 +2472,30 @@
 fi
 if test -z "$ac_cpp_err"; then
   # Broken: success on invalid input.
 continue
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   # Passes both tests.
 ac_preproc_ok=:
 break
 fi
 rm -f conftest.err conftest.$ac_ext
 
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
 rm -f conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then
   :
 else
-  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check" >&5
-echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check" >&2;}
+  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -2359,114 +2577,17 @@
 
 test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
 
-echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
-echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
-if test "${ac_cv_prog_cc_stdc+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_prog_cc_stdc=no
-ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-#include "confdefs.h"
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-# Don't try gcc -ansi; that turns off useful extensions and
-# breaks some systems' header files.
-# AIX			-qlanglvl=ansi
-# Ultrix and OSF/1	-std1
-# HP-UX 10.20 and later	-Ae
-# HP-UX older versions	-Aa -D_HPUX_SOURCE
-# SVR4			-Xc -D__EXTENSIONS__
-for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_prog_cc_stdc=$ac_arg
-break
-else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-fi
-rm -f conftest.$ac_objext
-done
-rm -f conftest.$ac_ext conftest.$ac_objext
-CC=$ac_save_CC
-
-fi
-
-case "x$ac_cv_prog_cc_stdc" in
-  x|xno)
-    echo "$as_me:$LINENO: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6 ;;
-  *)
-    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
-    CC="$CC $ac_cv_prog_cc_stdc" ;;
-esac
-
-
-
-
-cat >>confdefs.h <<\_ACEOF
-#define _GNU_SOURCE 1
+
+
+
+cat >>confdefs.h <<\_ACEOF
+#define _GNU_SOURCE 1
 _ACEOF
 
 
 if test "x$ac_cv_prog_cc_stdc" = xno
 then
 	{ echo "$as_me:$LINENO: WARNING: rsync requires an ANSI C compiler and you don't seem to have one" >&5
@@ -2604,17 +2725,14 @@
 _ACEOF
 
 
 if test x"$with_rsh" != x
 then
 	RSYNC_RSH="$with_rsh"
-elif test x"$HAVE_REMSH" = x1
-then
-	RSYNC_RSH="remsh"
 else
-	RSYNC_RSH="rsh"
+	RSYNC_RSH="ssh"
 fi
 
 
 cat >>confdefs.h <<_ACEOF
 #define RSYNC_RSH "$RSYNC_RSH"
 _ACEOF
@@ -2630,13 +2749,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_BROKEN_LARGEFILE=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #define _FILE_OFFSET_BITS 64
 #include <stdio.h>
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/wait.h>
@@ -2675,17 +2798,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_BROKEN_LARGEFILE=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_BROKEN_LARGEFILE=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_BROKEN_LARGEFILE" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_BROKEN_LARGEFILE" >&6
 if test x"$rsync_cv_HAVE_BROKEN_LARGEFILE" != x"yes"; then
    # Check whether --enable-largefile or --disable-largefile was given.
@@ -2705,28 +2829,26 @@
        ac_save_CC=$CC
        while :; do
      	 # IRIX 6.2 and later do not support large files by default,
      	 # so use the C compiler's -n32 option if that helps.
          cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
 #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   ;
   return 0;
@@ -2744,13 +2866,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext
      	 CC="$CC -n32"
      	 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -2763,13 +2886,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_largefile_CC=' -n32'; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext
          break
        done
        CC=$ac_save_CC
        rm -f conftest.$ac_ext
@@ -2787,28 +2911,26 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   while :; do
   ac_cv_sys_file_offset_bits=no
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
 #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   ;
   return 0;
@@ -2826,34 +2948,33 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #define _FILE_OFFSET_BITS 64
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
 #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   ;
   return 0;
@@ -2871,13 +2992,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_file_offset_bits=64; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   break
 done
 fi
 echo "$as_me:$LINENO: result: $ac_cv_sys_file_offset_bits" >&5
@@ -2896,28 +3018,26 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   while :; do
   ac_cv_sys_large_files=no
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
 #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   ;
   return 0;
@@ -2935,34 +3055,33 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #define _LARGE_FILES 1
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
 #define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   ;
   return 0;
@@ -2980,13 +3099,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_large_files=1; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   break
 done
 fi
 echo "$as_me:$LINENO: result: $ac_cv_sys_large_files" >&5
@@ -3019,23 +3139,42 @@
 echo $ECHO_N "checking ipv6 stack type... $ECHO_C" >&6
 	for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
 		case $i in
 		inria)
 			# http://www.kame.net/
 
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <netinet/in.h>
 #ifdef IPV6_INRIA_VERSION
 yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
+  $EGREP "yes" >/dev/null 2>&1; then
   ipv6type=$i;
 
 cat >>confdefs.h <<\_ACEOF
 #define INET6 1
 _ACEOF
 
@@ -3045,21 +3184,25 @@
 
 			;;
 		kame)
 			# http://www.kame.net/
 			cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <netinet/in.h>
 #ifdef __KAME__
 yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
+  $EGREP "yes" >/dev/null 2>&1; then
   ipv6type=$i;
 
 cat >>confdefs.h <<\_ACEOF
 #define INET6 1
 _ACEOF
 
@@ -3068,21 +3211,25 @@
 
 			;;
 		linux-glibc)
 			# http://www.v6.linux.or.jp/
 			cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <features.h>
 #if defined(__GLIBC__) && __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 1
 yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
+  $EGREP "yes" >/dev/null 2>&1; then
   ipv6type=$i;
 
 cat >>confdefs.h <<\_ACEOF
 #define INET6 1
 _ACEOF
 
@@ -3105,21 +3252,25 @@
 				CFLAGS="-I/usr/inet6/include $CFLAGS"
 			fi
 			;;
 		toshiba)
 			cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <sys/param.h>
 #ifdef _TOSHIBA_INET6
 yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
+  $EGREP "yes" >/dev/null 2>&1; then
   ipv6type=$i;
 				ipv6lib=inet6;
 				ipv6libdir=/usr/local/v6/lib;
 
 cat >>confdefs.h <<\_ACEOF
 #define INET6 1
@@ -3129,21 +3280,25 @@
 rm -f conftest*
 
 			;;
 		v6d)
 			cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include </usr/local/v6/include/sys/v6config.h>
 #ifdef __V6D__
 yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
+  $EGREP "yes" >/dev/null 2>&1; then
   ipv6type=$i;
 				ipv6lib=v6;
 				ipv6libdir=/usr/local/v6/lib;
 
 cat >>confdefs.h <<\_ACEOF
 #define INET6 1
@@ -3153,21 +3308,25 @@
 rm -f conftest*
 
 			;;
 		zeta)
 			cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <sys/param.h>
 #ifdef _ZETA_MINAMI_INET6
 yes
 #endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
+  $EGREP "yes" >/dev/null 2>&1; then
   ipv6type=$i;
 				ipv6lib=inet6;
 				ipv6libdir=/usr/local/v6/lib;
 
 cat >>confdefs.h <<\_ACEOF
 #define INET6 1
@@ -3191,27 +3350,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_func_search_save_LIBS=$LIBS
 ac_cv_search_getaddrinfo=no
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char getaddrinfo ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 getaddrinfo ();
   ;
   return 0;
@@ -3229,35 +3386,34 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_getaddrinfo="none required"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 if test "$ac_cv_search_getaddrinfo" = no; then
   for ac_lib in inet6; do
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char getaddrinfo ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 getaddrinfo ();
   ;
   return 0;
@@ -3276,13 +3432,14 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_getaddrinfo="-l$ac_lib"
 break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
   done
 fi
 LIBS=$ac_func_search_save_LIBS
 fi
@@ -3315,22 +3472,20 @@
 if test "${ac_cv_c_bigendian+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   # See if sys/param.h defines the BYTE_ORDER macro.
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <sys/param.h>
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 #if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
  bogus endian macros
 #endif
@@ -3351,22 +3506,20 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <sys/param.h>
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 #if BYTE_ORDER != BIG_ENDIAN
  not big endian
 #endif
@@ -3387,38 +3540,38 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_c_bigendian=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_c_bigendian=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 # It does not; compile a test program.
 if test "$cross_compiling" = yes; then
-  # try to guess the endianess by grep'ing values into an object file
+  # try to guess the endianness by grepping values into an object file
   ac_cv_c_bigendian=unknown
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
 short ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
 void _ascii () { char *s = (char *) ascii_mm; s = (char *) ascii_ii; }
 short ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
 short ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
 void _ebcdic () { char *s = (char *) ebcdic_mm; s = (char *) ebcdic_ii; }
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
  _ascii (); _ebcdic ();
   ;
   return 0;
@@ -3433,32 +3586,37 @@
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  if fgrep BIGenDianSyS conftest.$ac_objext >/dev/null ; then
+  if grep BIGenDianSyS conftest.$ac_objext >/dev/null ; then
   ac_cv_c_bigendian=yes
 fi
-if fgrep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
+if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
   if test "$ac_cv_c_bigendian" = unknown; then
     ac_cv_c_bigendian=no
   else
     # finding both strings is unlikely to happen, but who knows?
     ac_cv_c_bigendian=unknown
   fi
 fi
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 int
 main ()
 {
   /* Are we little or big endian?  From Harbison&Steele.  */
   union
   {
@@ -3481,17 +3639,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_c_bigendian=no
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 ac_cv_c_bigendian=yes
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
 echo "${ECHO_T}$ac_cv_c_bigendian" >&6
@@ -3502,15 +3661,15 @@
 #define WORDS_BIGENDIAN 1
 _ACEOF
  ;;
   no)
      ;;
   *)
-    { { echo "$as_me:$LINENO: error: unknown endianess
+    { { echo "$as_me:$LINENO: error: unknown endianness
 presetting ac_cv_c_bigendian=no (or yes) will help" >&5
-echo "$as_me: error: unknown endianess
+echo "$as_me: error: unknown endianness
 presetting ac_cv_c_bigendian=no (or yes) will help" >&2;}
    { (exit 1); exit 1; }; } ;;
 esac
 
 
 
@@ -3524,22 +3683,20 @@
 echo $ECHO_N "checking for $ac_hdr that defines DIR... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <$ac_hdr>
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((DIR *) 0)
 return 0;
   ;
@@ -3558,13 +3715,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_Header=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_Header=no"
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
@@ -3585,27 +3743,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_func_search_save_LIBS=$LIBS
 ac_cv_search_opendir=no
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char opendir ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 opendir ();
   ;
   return 0;
@@ -3623,35 +3779,34 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_opendir="none required"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 if test "$ac_cv_search_opendir" = no; then
   for ac_lib in dir; do
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char opendir ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 opendir ();
   ;
   return 0;
@@ -3670,13 +3825,14 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_opendir="-l$ac_lib"
 break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
   done
 fi
 LIBS=$ac_func_search_save_LIBS
 fi
@@ -3694,27 +3850,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_func_search_save_LIBS=$LIBS
 ac_cv_search_opendir=no
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char opendir ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 opendir ();
   ;
   return 0;
@@ -3732,35 +3886,34 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_opendir="none required"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 if test "$ac_cv_search_opendir" = no; then
   for ac_lib in x; do
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char opendir ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 opendir ();
   ;
   return 0;
@@ -3779,13 +3932,14 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_opendir="-l$ac_lib"
 break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
   done
 fi
 LIBS=$ac_func_search_save_LIBS
 fi
@@ -3802,23 +3956,21 @@
 echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6
 if test "${ac_cv_header_time+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <sys/time.h>
 #include <time.h>
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((struct tm *) 0)
 return 0;
   ;
@@ -3837,13 +3989,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_header_time=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_header_time=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_header_time" >&5
 echo "${ECHO_T}$ac_cv_header_time" >&6
@@ -3859,28 +4012,26 @@
 echo $ECHO_N "checking for sys/wait.h that is POSIX.1 compatible... $ECHO_C" >&6
 if test "${ac_cv_header_sys_wait_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <sys/wait.h>
 #ifndef WEXITSTATUS
 # define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
 #endif
 #ifndef WIFEXITED
 # define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
 #endif
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
   int s;
   wait (&s);
   s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
@@ -3900,13 +4051,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_header_sys_wait_h=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_header_sys_wait_h=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_header_sys_wait_h" >&5
 echo "${ECHO_T}$ac_cv_header_sys_wait_h" >&6
@@ -3922,72 +4074,87 @@
 echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
 if test "${ac_cv_header_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 
+int
+main ()
+{
+
+  ;
+  return 0;
+}
 _ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_header_stdc=yes
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  ac_cv_header_stdc=no
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_header_stdc=no
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.$ac_objext conftest.$ac_ext
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <string.h>
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "memchr" >/dev/null 2>&1; then
+  $EGREP "memchr" >/dev/null 2>&1; then
   :
 else
   ac_cv_header_stdc=no
 fi
 rm -f conftest*
 
 fi
 
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <stdlib.h>
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "free" >/dev/null 2>&1; then
+  $EGREP "free" >/dev/null 2>&1; then
   :
 else
   ac_cv_header_stdc=no
 fi
 rm -f conftest*
 
@@ -3997,19 +4164,24 @@
   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
   if test "$cross_compiling" = yes; then
   :
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <ctype.h>
 #if ((' ' & 0x0FF) == 0x020)
 # define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
 # define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
 #else
-# define ISLOWER(c) (('a' <= (c) && (c) <= 'i') \
+# define ISLOWER(c) \
+                   (('a' <= (c) && (c) <= 'i') \
                      || ('j' <= (c) && (c) <= 'r') \
                      || ('s' <= (c) && (c) <= 'z'))
 # define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
 #endif
 
 #define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
@@ -4036,17 +4208,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   :
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 ac_cv_header_stdc=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 fi
 echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
 echo "${ECHO_T}$ac_cv_header_stdc" >&6
 if test $ac_cv_header_stdc = yes; then
@@ -4075,13 +4248,17 @@
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
@@ -4095,13 +4272,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_Header=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_Header=no"
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
@@ -4137,13 +4315,17 @@
 else
   # Is the header compilable?
 echo "$as_me:$LINENO: checking $ac_header usability" >&5
 echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -4156,31 +4338,36 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_header_compiler=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
 echo "$as_me:$LINENO: checking $ac_header presence" >&5
 echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -4191,33 +4378,52 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   ac_header_preproc=no
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
   no:yes )
     { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
 echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
 echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
 esac
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4255,13 +4461,17 @@
 else
   # Is the header compilable?
 echo "$as_me:$LINENO: checking $ac_header usability" >&5
 echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -4274,31 +4484,36 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_header_compiler=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
 echo "$as_me:$LINENO: checking $ac_header presence" >&5
 echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -4309,33 +4524,52 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   ac_header_preproc=no
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
   no:yes )
     { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
 echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
 echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
 esac
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4374,13 +4608,17 @@
 else
   # Is the header compilable?
 echo "$as_me:$LINENO: checking $ac_header usability" >&5
 echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -4393,31 +4631,36 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_header_compiler=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
 echo "$as_me:$LINENO: checking $ac_header presence" >&5
 echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -4428,33 +4671,52 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   ac_header_preproc=no
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
   no:yes )
     { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
 echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
 echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
 esac
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4492,13 +4754,17 @@
 else
   # Is the header compilable?
 echo "$as_me:$LINENO: checking $ac_header usability" >&5
 echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -4511,31 +4777,36 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_header_compiler=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
 echo "$as_me:$LINENO: checking $ac_header presence" >&5
 echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -4546,33 +4817,52 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   ac_header_preproc=no
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
   no:yes )
     { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
 echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
 echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
 esac
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4606,13 +4896,17 @@
 else
   # Is the header compilable?
 echo "$as_me:$LINENO: checking $ac_header usability" >&5
 echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -4625,31 +4919,36 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_header_compiler=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
 echo "$as_me:$LINENO: checking $ac_header presence" >&5
 echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -4660,33 +4959,52 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   ac_header_preproc=no
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
   no:yes )
     { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
 echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
 echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
 esac
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4720,13 +5038,17 @@
 else
   # Is the header compilable?
 echo "$as_me:$LINENO: checking $ac_header usability" >&5
 echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -4739,31 +5061,36 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_header_compiler=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
 echo "$as_me:$LINENO: checking $ac_header presence" >&5
 echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -4774,33 +5101,52 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   ac_header_preproc=no
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
   no:yes )
     { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
 echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
 echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
 esac
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4834,13 +5180,17 @@
 else
   # Is the header compilable?
 echo "$as_me:$LINENO: checking $ac_header usability" >&5
 echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -4853,31 +5203,36 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_header_compiler=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
 echo "$as_me:$LINENO: checking $ac_header presence" >&5
 echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
+  grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
@@ -4888,33 +5243,52 @@
   ac_cpp_err=yes
 fi
 if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
   ac_header_preproc=no
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
   no:yes )
     { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
 echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
 echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;};;
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
 esac
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4938,20 +5312,18 @@
 echo $ECHO_N "checking for int... $ECHO_C" >&6
 if test "${ac_cv_type_int+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((int *) 0)
   return 0;
 if (sizeof (int))
@@ -4972,13 +5344,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_int=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_int=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_int" >&5
 echo "${ECHO_T}$ac_cv_type_int" >&6
@@ -4994,20 +5367,18 @@
   # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
   # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (int))) >= 0)];
 test_array [0] = 0
 
@@ -5028,20 +5399,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (int))) <= $ac_mid)];
 test_array [0] = 0
 
@@ -5061,35 +5430,35 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo=`expr $ac_mid + 1`
                     if test $ac_lo -le $ac_mid; then
                       ac_lo= ac_hi=
                       break
                     fi
                     ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (int))) < 0)];
 test_array [0] = 0
 
@@ -5110,20 +5479,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (int))) >= $ac_mid)];
 test_array [0] = 0
 
@@ -5143,43 +5510,43 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_hi=`expr '(' $ac_mid ')' - 1`
                        if test $ac_mid -le $ac_hi; then
                          ac_lo= ac_hi=
                          break
                        fi
                        ac_mid=`expr 2 '*' $ac_mid`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo= ac_hi=
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (int))) <= $ac_mid)];
 test_array [0] = 0
 
@@ -5199,43 +5566,46 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_int=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77" >&5
-echo "$as_me: error: cannot compute sizeof (int), 77" >&2;}
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (int), 77
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling" >&5
-echo "$as_me: error: cannot run test program while cross compiling" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 long longval () { return (long) (sizeof (int)); }
 unsigned long ulongval () { return (long) (sizeof (int)); }
 #include <stdio.h>
 #include <stdlib.h>
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
@@ -5272,19 +5642,22 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sizeof_int=`cat conftest.val`
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
-{ { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77" >&5
-echo "$as_me: error: cannot compute sizeof (int), 77" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (int), 77
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 rm -f conftest.val
 else
   ac_cv_sizeof_int=0
 fi
@@ -5300,20 +5673,18 @@
 echo $ECHO_N "checking for long... $ECHO_C" >&6
 if test "${ac_cv_type_long+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((long *) 0)
   return 0;
 if (sizeof (long))
@@ -5334,13 +5705,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_long=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_long=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_long" >&5
 echo "${ECHO_T}$ac_cv_type_long" >&6
@@ -5356,20 +5728,18 @@
   # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
   # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (long))) >= 0)];
 test_array [0] = 0
 
@@ -5390,20 +5760,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (long))) <= $ac_mid)];
 test_array [0] = 0
 
@@ -5423,35 +5791,35 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo=`expr $ac_mid + 1`
                     if test $ac_lo -le $ac_mid; then
                       ac_lo= ac_hi=
                       break
                     fi
                     ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (long))) < 0)];
 test_array [0] = 0
 
@@ -5472,20 +5840,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (long))) >= $ac_mid)];
 test_array [0] = 0
 
@@ -5505,43 +5871,43 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_hi=`expr '(' $ac_mid ')' - 1`
                        if test $ac_mid -le $ac_hi; then
                          ac_lo= ac_hi=
                          break
                        fi
                        ac_mid=`expr 2 '*' $ac_mid`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo= ac_hi=
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (long))) <= $ac_mid)];
 test_array [0] = 0
 
@@ -5561,43 +5927,46 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_long=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77" >&5
-echo "$as_me: error: cannot compute sizeof (long), 77" >&2;}
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (long), 77
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling" >&5
-echo "$as_me: error: cannot run test program while cross compiling" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 long longval () { return (long) (sizeof (long)); }
 unsigned long ulongval () { return (long) (sizeof (long)); }
 #include <stdio.h>
 #include <stdlib.h>
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
@@ -5634,19 +6003,22 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sizeof_long=`cat conftest.val`
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
-{ { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77" >&5
-echo "$as_me: error: cannot compute sizeof (long), 77" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (long), 77
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 rm -f conftest.val
 else
   ac_cv_sizeof_long=0
 fi
@@ -5662,20 +6034,18 @@
 echo $ECHO_N "checking for short... $ECHO_C" >&6
 if test "${ac_cv_type_short+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((short *) 0)
   return 0;
 if (sizeof (short))
@@ -5696,13 +6066,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_short=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_short=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_short" >&5
 echo "${ECHO_T}$ac_cv_type_short" >&6
@@ -5718,20 +6089,18 @@
   # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
   # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (short))) >= 0)];
 test_array [0] = 0
 
@@ -5752,20 +6121,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (short))) <= $ac_mid)];
 test_array [0] = 0
 
@@ -5785,35 +6152,35 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo=`expr $ac_mid + 1`
                     if test $ac_lo -le $ac_mid; then
                       ac_lo= ac_hi=
                       break
                     fi
                     ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (short))) < 0)];
 test_array [0] = 0
 
@@ -5834,20 +6201,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (short))) >= $ac_mid)];
 test_array [0] = 0
 
@@ -5867,43 +6232,43 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_hi=`expr '(' $ac_mid ')' - 1`
                        if test $ac_mid -le $ac_hi; then
                          ac_lo= ac_hi=
                          break
                        fi
                        ac_mid=`expr 2 '*' $ac_mid`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo= ac_hi=
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static int test_array [1 - 2 * !(((long) (sizeof (short))) <= $ac_mid)];
 test_array [0] = 0
 
@@ -5923,43 +6288,46 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_short=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77" >&5
-echo "$as_me: error: cannot compute sizeof (short), 77" >&2;}
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (short), 77
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling" >&5
-echo "$as_me: error: cannot run test program while cross compiling" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
 long longval () { return (long) (sizeof (short)); }
 unsigned long ulongval () { return (long) (sizeof (short)); }
 #include <stdio.h>
 #include <stdlib.h>
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
@@ -5996,19 +6364,22 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sizeof_short=`cat conftest.val`
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
-{ { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77" >&5
-echo "$as_me: error: cannot compute sizeof (short), 77" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (short), 77
+See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 rm -f conftest.val
 else
   ac_cv_sizeof_short=0
 fi
@@ -6027,16 +6398,21 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #ifndef __cplusplus
-static $ac_kw int static_foo () {return 0; }
-$ac_kw int foo () {return 0; }
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
 #endif
 
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
@@ -6049,13 +6425,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_c_inline=$ac_kw; break
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 done
 
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
@@ -6078,30 +6455,28 @@
 echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
 if test "${ac_cv_type_signal+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <signal.h>
 #ifdef signal
 # undef signal
 #endif
 #ifdef __cplusplus
 extern "C" void (*signal (int, void (*)(int)))(int);
 #else
 void (*signal ()) ();
 #endif
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 int i;
   ;
   return 0;
@@ -6119,13 +6494,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_signal=void
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_signal=int
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
 echo "${ECHO_T}$ac_cv_type_signal" >&6
@@ -6139,18 +6515,22 @@
 echo $ECHO_N "checking for uid_t in sys/types.h... $ECHO_C" >&6
 if test "${ac_cv_type_uid_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "uid_t" >/dev/null 2>&1; then
+  $EGREP "uid_t" >/dev/null 2>&1; then
   ac_cv_type_uid_t=yes
 else
   ac_cv_type_uid_t=no
 fi
 rm -f conftest*
 
@@ -6174,20 +6554,18 @@
 echo $ECHO_N "checking for mode_t... $ECHO_C" >&6
 if test "${ac_cv_type_mode_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((mode_t *) 0)
   return 0;
 if (sizeof (mode_t))
@@ -6208,13 +6586,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_mode_t=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_mode_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_mode_t" >&5
 echo "${ECHO_T}$ac_cv_type_mode_t" >&6
@@ -6232,20 +6611,18 @@
 echo $ECHO_N "checking for off_t... $ECHO_C" >&6
 if test "${ac_cv_type_off_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((off_t *) 0)
   return 0;
 if (sizeof (off_t))
@@ -6266,13 +6643,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_off_t=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_off_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
 echo "${ECHO_T}$ac_cv_type_off_t" >&6
@@ -6290,20 +6668,18 @@
 echo $ECHO_N "checking for size_t... $ECHO_C" >&6
 if test "${ac_cv_type_size_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((size_t *) 0)
   return 0;
 if (sizeof (size_t))
@@ -6324,13 +6700,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_size_t=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_size_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
 echo "${ECHO_T}$ac_cv_type_size_t" >&6
@@ -6348,20 +6725,18 @@
 echo $ECHO_N "checking for pid_t... $ECHO_C" >&6
 if test "${ac_cv_type_pid_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((pid_t *) 0)
   return 0;
 if (sizeof (pid_t))
@@ -6382,13 +6757,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_pid_t=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_pid_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
 echo "${ECHO_T}$ac_cv_type_pid_t" >&6
@@ -6409,13 +6785,17 @@
 else
   if test "$cross_compiling" = yes; then
   ac_cv_type_getgroups=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* Thanks to Mike Rendell for this test.  */
 #include <sys/types.h>
 #define NGID 256
 #undef MAX
 #define MAX(x, y) ((x) > (y) ? (x) : (y))
 
@@ -6448,27 +6828,32 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_getgroups=gid_t
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 ac_cv_type_getgroups=int
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 if test $ac_cv_type_getgroups = cross; then
         cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <unistd.h>
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "getgroups.*int.*gid_t" >/dev/null 2>&1; then
+  $EGREP "getgroups.*int.*gid_t" >/dev/null 2>&1; then
   ac_cv_type_getgroups=gid_t
 else
   ac_cv_type_getgroups=int
 fi
 rm -f conftest*
 
@@ -6486,20 +6871,18 @@
 echo $ECHO_N "checking for struct stat.st_rdev... $ECHO_C" >&6
 if test "${ac_cv_member_struct_stat_st_rdev+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static struct stat ac_aggr;
 if (ac_aggr.st_rdev)
 return 0;
@@ -6519,17 +6902,55 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_member_struct_stat_st_rdev=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+static struct stat ac_aggr;
+if (sizeof ac_aggr.st_rdev)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_struct_stat_st_rdev=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_member_struct_stat_st_rdev=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
 echo "$as_me:$LINENO: result: $ac_cv_member_struct_stat_st_rdev" >&5
 echo "${ECHO_T}$ac_cv_member_struct_stat_st_rdev" >&6
 if test $ac_cv_member_struct_stat_st_rdev = yes; then
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_STRUCT_STAT_ST_RDEV 1
@@ -6543,20 +6964,18 @@
 echo $ECHO_N "checking for ino_t... $ECHO_C" >&6
 if test "${ac_cv_type_ino_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((ino_t *) 0)
   return 0;
 if (sizeof (ino_t))
@@ -6577,13 +6996,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_ino_t=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_ino_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_ino_t" >&5
 echo "${ECHO_T}$ac_cv_type_ino_t" >&6
@@ -6602,22 +7022,20 @@
 echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6
 if test "${ac_cv_type_socklen_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <sys/socket.h>
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 if ((socklen_t *) 0)
   return 0;
 if (sizeof (socklen_t))
@@ -6638,13 +7056,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_socklen_t=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_type_socklen_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
 echo "${ECHO_T}$ac_cv_type_socklen_t" >&6
@@ -6662,25 +7081,23 @@
          # "void *" as the second argument to getpeername
          rsync_cv_socklen_t_equiv=
          for arg2 in "struct sockaddr" void; do
             for t in int size_t unsigned long "unsigned long"; do
                cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <sys/types.h>
 #include <sys/socket.h>
 
                   int getpeername (int, $arg2 *, $t *);
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 
                   $t len;
                   getpeername(0,0,&len);
@@ -6704,13 +7121,14 @@
 
                   rsync_cv_socklen_t_equiv="$t"
                   break
 
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
             done
          done
 
          if test "x$rsync_cv_socklen_t_equiv" = x; then
@@ -6737,20 +7155,18 @@
 if test "${rsync_cv_errno+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
     cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <errno.h>
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 int i = errno
   ;
   return 0;
@@ -6768,13 +7184,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_errno=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 rsync_cv_have_errno_decl=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_errno" >&5
 echo "${ECHO_T}$rsync_cv_errno" >&6
@@ -6802,43 +7219,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -6852,13 +7276,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -6880,27 +7305,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lnsl_s  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char printf ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 printf ();
   ;
   return 0;
@@ -6918,13 +7341,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_nsl_s_printf=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_lib_nsl_s_printf=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_s_printf" >&5
@@ -6948,27 +7372,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lnsl  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char printf ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 printf ();
   ;
   return 0;
@@ -6986,13 +7408,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_nsl_printf=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_lib_nsl_printf=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_printf" >&5
@@ -7016,27 +7439,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lsocket  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char connect ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 connect ();
   ;
   return 0;
@@ -7054,13 +7475,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_socket_connect=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_lib_socket_connect=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_socket_connect" >&5
@@ -7084,27 +7506,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-linet  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char connect ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 connect ();
   ;
   return 0;
@@ -7122,13 +7542,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_inet_connect=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_lib_inet_connect=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_inet_connect" >&5
@@ -7162,27 +7583,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lresolv  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char inet_ntop ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 inet_ntop ();
   ;
   return 0;
@@ -7200,13 +7619,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_resolv_inet_ntop=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_lib_resolv_inet_ntop=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_resolv_inet_ntop" >&5
@@ -7230,43 +7650,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -7280,13 +7707,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -7308,43 +7736,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -7358,13 +7793,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -7386,23 +7822,27 @@
 if test "${rsync_cv_HAVE_GETADDR_DEFINES+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
 			cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 			#include <sys/types.h>
 			#include <sys/socket.h>
 			#include <netdb.h>
 			#ifdef AI_PASSIVE
 			yes
 			#endif
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "yes" >/dev/null 2>&1; then
+  $EGREP "yes" >/dev/null 2>&1; then
   rsync_cv_HAVE_GETADDR_DEFINES=yes
 else
   rsync_cv_HAVE_GETADDR_DEFINES=no
 fi
 rm -f conftest*
 
@@ -7421,43 +7861,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -7471,13 +7918,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -7488,22 +7936,20 @@
 
 else
   echo "$as_me:$LINENO: checking for getaddrinfo by including <netdb.h>" >&5
 echo $ECHO_N "checking for getaddrinfo by including <netdb.h>... $ECHO_C" >&6
 		cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 		#include <sys/socket.h>
 		#include <netdb.h>
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 getaddrinfo(NULL, NULL, NULL, NULL);
   ;
   return 0;
@@ -7527,13 +7973,14 @@
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_GETADDRINFO 1
 _ACEOF
 
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
 			LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
@@ -7547,43 +7994,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -7597,13 +8051,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -7627,24 +8082,22 @@
 echo $ECHO_N "checking for struct sockaddr.sa_len... $ECHO_C" >&6
 if test "${ac_cv_member_struct_sockaddr_sa_len+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <sys/types.h>
 #include <sys/socket.h>
 
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static struct sockaddr ac_aggr;
 if (ac_aggr.sa_len)
 return 0;
@@ -7664,17 +8117,59 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_member_struct_sockaddr_sa_len=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+
+int
+main ()
+{
+static struct sockaddr ac_aggr;
+if (sizeof ac_aggr.sa_len)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_struct_sockaddr_sa_len=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_member_struct_sockaddr_sa_len=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
 echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_sa_len" >&5
 echo "${ECHO_T}$ac_cv_member_struct_sockaddr_sa_len" >&6
 if test $ac_cv_member_struct_sockaddr_sa_len = yes; then
    cat >>confdefs.h <<\_ACEOF
 #define HAVE_SOCKADDR_LEN 1
 _ACEOF
@@ -7683,21 +8178,19 @@
 
 
 echo "$as_me:$LINENO: checking struct sockaddr_storage" >&5
 echo $ECHO_N "checking struct sockaddr_storage... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <sys/socket.h>
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 struct sockaddr_storage x;
   ;
   return 0;
@@ -7721,38 +8214,37 @@
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_SOCKADDR_STORAGE 1
 _ACEOF
 
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 
 echo "$as_me:$LINENO: checking for struct sockaddr_in6.sin6_scope_id" >&5
 echo $ECHO_N "checking for struct sockaddr_in6.sin6_scope_id... $ECHO_C" >&6
 if test "${ac_cv_member_struct_sockaddr_in6_sin6_scope_id+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 static struct sockaddr_in6 ac_aggr;
 if (ac_aggr.sin6_scope_id)
 return 0;
@@ -7772,17 +8264,60 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+
+int
+main ()
+{
+static struct sockaddr_in6 ac_aggr;
+if (sizeof ac_aggr.sin6_scope_id)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_member_struct_sockaddr_in6_sin6_scope_id=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
 echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&5
 echo "${ECHO_T}$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&6
 if test $ac_cv_member_struct_sockaddr_in6_sin6_scope_id = yes; then
    cat >>confdefs.h <<\_ACEOF
 #define HAVE_SOCKADDR_IN6_SCOPE_ID 1
 _ACEOF
@@ -7800,43 +8335,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -7850,13 +8392,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -7876,27 +8419,25 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lresolv  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char strcasecmp ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 strcasecmp ();
   ;
   return 0;
@@ -7914,13 +8455,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_resolv_strcasecmp=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_lib_resolv_strcasecmp=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_resolv_strcasecmp" >&5
@@ -7946,20 +8488,18 @@
 # Sequent interprets utime(file, 0) to mean use start of epoch.  Wrong.
 if test "$cross_compiling" = yes; then
   ac_cv_func_utime_null=no
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 $ac_includes_default
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 struct stat s, t;
   exit (!(stat ("conftest.data", &s) == 0
           && utime ("conftest.data", (long *)0) == 0
@@ -7982,17 +8522,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_utime_null=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 ac_cv_func_utime_null=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f core core.* *.core
 fi
 echo "$as_me:$LINENO: result: $ac_cv_func_utime_null" >&5
 echo "${ECHO_T}$ac_cv_func_utime_null" >&6
 if test $ac_cv_func_utime_null = yes; then
@@ -8010,20 +8551,18 @@
 echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
 if test "${ac_cv_working_alloca_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <alloca.h>
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 char *p = (char *) alloca (2 * sizeof (int));
   ;
   return 0;
@@ -8041,13 +8580,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_working_alloca_h=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_working_alloca_h=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
 echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
@@ -8063,13 +8603,17 @@
 echo $ECHO_N "checking for alloca... $ECHO_C" >&6
 if test "${ac_cv_func_alloca_works+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #ifdef __GNUC__
 # define alloca __builtin_alloca
 #else
 # ifdef _MSC_VER
 #  include <malloc.h>
 #  define alloca _alloca
@@ -8085,18 +8629,12 @@
 #    endif
 #   endif
 #  endif
 # endif
 #endif
 
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 char *p = (char *) alloca (1);
   ;
   return 0;
@@ -8114,13 +8652,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_alloca_works=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_func_alloca_works=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
 echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
@@ -8148,22 +8687,26 @@
 echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
 if test "${ac_cv_os_cray+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
 #else
 wenotbecray
 #endif
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "webecray" >/dev/null 2>&1; then
+  $EGREP "webecray" >/dev/null 2>&1; then
   ac_cv_os_cray=yes
 else
   ac_cv_os_cray=no
 fi
 rm -f conftest*
 
@@ -8177,43 +8720,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -8227,13 +8777,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -8256,13 +8807,17 @@
 else
   if test "$cross_compiling" = yes; then
   ac_cv_c_stack_direction=0
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 int
 find_stack_direction ()
 {
   static char *addr = 0;
   auto char dummy;
   if (addr == 0)
@@ -8292,17 +8847,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_c_stack_direction=1
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 ac_cv_c_stack_direction=-1
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
 echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
 
 cat >>confdefs.h <<_ACEOF
@@ -8328,43 +8884,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -8378,13 +8941,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -8411,43 +8975,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -8461,13 +9032,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -8494,43 +9066,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -8544,13 +9123,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -8575,43 +9155,50 @@
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char $ac_func ();
-char (*f) ();
-
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
-int
-main ()
-{
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined (__stub_$ac_func) || defined (__stub___$ac_func)
 choke me
 #else
-f = $ac_func;
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
+int
+main ()
+{
+return f != $ac_func;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -8625,13 +9212,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
@@ -8652,13 +9240,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_SOCKETPAIR=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <sys/types.h>
 #include <sys/socket.h>
 
 main() {
        int fd[2];
@@ -8677,104 +9269,55 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_SOCKETPAIR=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_SOCKETPAIR=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SOCKETPAIR" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_SOCKETPAIR" >&6
 if test x"$rsync_cv_HAVE_SOCKETPAIR" = x"yes"; then
 
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_SOCKETPAIR 1
 _ACEOF
 
 fi
 
-echo "$as_me:$LINENO: checking for working fnmatch" >&5
-echo $ECHO_N "checking for working fnmatch... $ECHO_C" >&6
-if test "${rsync_cv_HAVE_FNMATCH+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_HAVE_FNMATCH=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-#include "confdefs.h"
-#include <fnmatch.h>
-main() { exit((fnmatch("*.o", "x.o", FNM_PATHNAME) == 0 &&
-               fnmatch("a/b/*", "a/b/c/d", FNM_PATHNAME) != 0) ? 0: 1); }
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_HAVE_FNMATCH=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-( exit $ac_status )
-rsync_cv_HAVE_FNMATCH=no
-fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
-echo "$as_me:$LINENO: result: $rsync_cv_HAVE_FNMATCH" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_FNMATCH" >&6
-if test x"$rsync_cv_HAVE_FNMATCH" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_FNMATCH 1
-_ACEOF
-
-fi
-
 if test x"$with_included_popt" != x"yes"
 then
 
 echo "$as_me:$LINENO: checking for poptGetContext in -lpopt" >&5
 echo $ECHO_N "checking for poptGetContext in -lpopt... $ECHO_C" >&6
 if test "${ac_cv_lib_popt_poptGetContext+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lpopt  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
 char poptGetContext ();
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 poptGetContext ();
   ;
   return 0;
@@ -8792,13 +9335,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_popt_poptGetContext=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ac_cv_lib_popt_poptGetContext=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_popt_poptGetContext" >&5
@@ -8844,13 +9388,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_LONGLONG=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <stdio.h>
 main() { long long x = 1000000; x *= x; exit(((x/1000000) == 1000000)? 0: 1); }
 _ACEOF
 rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
@@ -8863,17 +9411,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_LONGLONG=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_LONGLONG=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_LONGLONG" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_LONGLONG" >&6
 if test x"$rsync_cv_HAVE_LONGLONG" = x"yes"; then
 
@@ -8891,13 +9440,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_OFF64_T=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <stdio.h>
 #include <sys/stat.h>
 main() { struct stat64 st; off64_t s; if (sizeof(off_t) == sizeof(off64_t)) exit(1); exit((lstat64("/dev/null", &st)==0)?0:1); }
 _ACEOF
 rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
@@ -8911,17 +9464,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_OFF64_T=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_OFF64_T=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_OFF64_T" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_OFF64_T" >&6
 if test x"$rsync_cv_HAVE_OFF64_T" = x"yes"; then
 
@@ -8939,13 +9493,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_SHORT_INO_T=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 main() { if (sizeof(ino_t) < sizeof(unsigned int)) return 0; return 1; }
 _ACEOF
 rm -f conftest$ac_exeext
@@ -8960,17 +9518,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_SHORT_INO_T=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_SHORT_INO_T=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SHORT_INO_T" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_SHORT_INO_T" >&6
 if test x"$rsync_cv_HAVE_SHORT_INO_T" = x"yes"; then
 
@@ -8988,13 +9547,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_UNSIGNED_CHAR=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <stdio.h>
 main() { char c; c=250; exit((c > 0)?0:1); }
 _ACEOF
 rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
@@ -9007,17 +9570,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_UNSIGNED_CHAR=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_UNSIGNED_CHAR=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_UNSIGNED_CHAR" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_UNSIGNED_CHAR" >&6
 if test x"$rsync_cv_HAVE_UNSIGNED_CHAR" = x"yes"; then
 
@@ -9035,13 +9599,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_BROKEN_READDIR=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <dirent.h>
 main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
 if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
 di->d_name[0] == 0) exit(0); exit(1);}
 _ACEOF
@@ -9057,17 +9625,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_BROKEN_READDIR=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_BROKEN_READDIR=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_BROKEN_READDIR" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_BROKEN_READDIR" >&6
 if test x"$rsync_cv_HAVE_BROKEN_READDIR" = x"yes"; then
 
@@ -9082,21 +9651,19 @@
 if test "${rsync_cv_HAVE_UTIMBUF+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <sys/types.h>
 #include <utime.h>
-#ifdef F77_DUMMY_MAIN
-#  ifdef __cplusplus
-     extern "C"
-#  endif
-   int F77_DUMMY_MAIN() { return 1; }
-#endif
 int
 main ()
 {
 struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));
   ;
   return 0;
@@ -9114,13 +9681,14 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_UTIMBUF=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 rsync_cv_HAVE_UTIMBUF=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_UTIMBUF" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_UTIMBUF" >&6
@@ -9140,13 +9708,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_GETTIMEOFDAY_TZ=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <sys/time.h>
 #include <unistd.h>
 main() { struct timeval tv; exit(gettimeofday(&tv, NULL));}
 _ACEOF
 rm -f conftest$ac_exeext
@@ -9161,17 +9733,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_GETTIMEOFDAY_TZ=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_GETTIMEOFDAY_TZ=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_GETTIMEOFDAY_TZ" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_GETTIMEOFDAY_TZ" >&6
 if test x"$rsync_cv_HAVE_GETTIMEOFDAY_TZ" = x"yes"; then
 
@@ -9189,13 +9762,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_C99_VSNPRINTF=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <sys/types.h>
 #include <stdarg.h>
 void foo(const char *format, ...) {
        va_list ap;
        int len;
@@ -9225,17 +9802,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_C99_VSNPRINTF=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_C99_VSNPRINTF=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_C99_VSNPRINTF" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_C99_VSNPRINTF" >&6
 if test x"$rsync_cv_HAVE_C99_VSNPRINTF" = x"yes"; then
 
@@ -9254,13 +9832,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_SECURE_MKSTEMP=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 main() {
   struct stat st;
@@ -9285,17 +9867,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_HAVE_SECURE_MKSTEMP=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_HAVE_SECURE_MKSTEMP=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SECURE_MKSTEMP" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_SECURE_MKSTEMP" >&6
 if test x"$rsync_cv_HAVE_SECURE_MKSTEMP" = x"yes"; then
 
@@ -9314,13 +9897,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_REPLACE_INET_NTOA=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 main() { struct in_addr ip; ip.s_addr = 0x12345678;
@@ -9340,17 +9927,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_REPLACE_INET_NTOA=no
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_REPLACE_INET_NTOA=yes
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_REPLACE_INET_NTOA" >&5
 echo "${ECHO_T}$rsync_cv_REPLACE_INET_NTOA" >&6
 if test x"$rsync_cv_REPLACE_INET_NTOA" = x"yes"; then
 
@@ -9369,13 +9957,17 @@
 
 if test "$cross_compiling" = yes; then
   rsync_cv_REPLACE_INET_ATON=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
-#include "confdefs.h"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 #include <stdio.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 main() { struct in_addr ip;
@@ -9393,17 +9985,18 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   rsync_cv_REPLACE_INET_ATON=no
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 ( exit $ac_status )
 rsync_cv_REPLACE_INET_ATON=yes
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_REPLACE_INET_ATON" >&5
 echo "${ECHO_T}$rsync_cv_REPLACE_INET_ATON" >&6
 if test x"$rsync_cv_REPLACE_INET_ATON" = x"yes"; then
 
@@ -9449,25 +10042,25 @@
 
 
 
 
 
 
-ac_config_files="$ac_config_files Makefile lib/dummy zlib/dummy popt/dummy shconfig"
+                                                  ac_config_files="$ac_config_files Makefile lib/dummy zlib/dummy popt/dummy shconfig"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
 # scripts and configure runs, see configure's option --config-cache.
 # It is not useful on other systems.  If it contains results you don't
 # want to keep, you may remove or edit it.
 #
 # config.status only pays attention to the cache file if you give it
 # the --recheck option to rerun configure.
 #
-# `ac_cv_env_foo' variables (set or unset) will be overriden when
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
 # loading this file, other *unset* `ac_cv_foo' will be assigned the
 # following values.
 
 _ACEOF
 
 # The following way of writing the cache mishandles newlines in values,
@@ -9496,13 +10089,13 @@
      t clear
      : clear
      s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
      t end
      /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
      : end' >>confcache
-if cmp -s $cache_file confcache; then :; else
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
   if test -w $cache_file; then
     test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
     cat confcache >$cache_file
   else
     echo "not updating unwritable cache $cache_file"
   fi
@@ -9527,12 +10120,27 @@
 s/^[^=]*=[ 	]*$//;
 }'
 fi
 
 DEFS=-DHAVE_CONFIG_H
 
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+         sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
 
 : ${CONFIG_STATUS=./config.status}
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
 { echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
 echo "$as_me: creating $CONFIG_STATUS" >&6;}
@@ -9541,17 +10149,18 @@
 # Generated by $as_me.
 # Run this file to recreate the current configuration.
 # Compiler output produced by configure, useful for debugging
 # configure, is in config.log if it exists.
 
 debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
 SHELL=\${CONFIG_SHELL-$SHELL}
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF
-
 ## --------------------- ##
 ## M4sh Initialization.  ##
 ## --------------------- ##
 
 # Be Bourne compatible
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
@@ -9554,52 +10163,62 @@
 ## --------------------- ##
 
 # Be Bourne compatible
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
 elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
   set -o posix
 fi
 
-# NLS nuisances.
 # Support unset when possible.
 if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
 fi
 
-(set +x; test -n "`(LANG=C; export LANG) 2>&1`") &&
-    { $as_unset LANG || test "${LANG+set}" != set; } ||
-      { LANG=C; export LANG; }
-(set +x; test -n "`(LC_ALL=C; export LC_ALL) 2>&1`") &&
-    { $as_unset LC_ALL || test "${LC_ALL+set}" != set; } ||
-      { LC_ALL=C; export LC_ALL; }
-(set +x; test -n "`(LC_TIME=C; export LC_TIME) 2>&1`") &&
-    { $as_unset LC_TIME || test "${LC_TIME+set}" != set; } ||
-      { LC_TIME=C; export LC_TIME; }
-(set +x; test -n "`(LC_CTYPE=C; export LC_CTYPE) 2>&1`") &&
-    { $as_unset LC_CTYPE || test "${LC_CTYPE+set}" != set; } ||
-      { LC_CTYPE=C; export LC_CTYPE; }
-(set +x; test -n "`(LANGUAGE=C; export LANGUAGE) 2>&1`") &&
-    { $as_unset LANGUAGE || test "${LANGUAGE+set}" != set; } ||
-      { LANGUAGE=C; export LANGUAGE; }
-(set +x; test -n "`(LC_COLLATE=C; export LC_COLLATE) 2>&1`") &&
-    { $as_unset LC_COLLATE || test "${LC_COLLATE+set}" != set; } ||
-      { LC_COLLATE=C; export LC_COLLATE; }
-(set +x; test -n "`(LC_NUMERIC=C; export LC_NUMERIC) 2>&1`") &&
-    { $as_unset LC_NUMERIC || test "${LC_NUMERIC+set}" != set; } ||
-      { LC_NUMERIC=C; export LC_NUMERIC; }
-(set +x; test -n "`(LC_MESSAGES=C; export LC_MESSAGES) 2>&1`") &&
-    { $as_unset LC_MESSAGES || test "${LC_MESSAGES+set}" != set; } ||
-      { LC_MESSAGES=C; export LC_MESSAGES; }
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
 
 
 # Name of the executable.
-as_me=`(basename "$0") 2>/dev/null ||
+as_me=`$as_basename "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)$' \| \
 	 .     : '\(.\)' 2>/dev/null ||
 echo X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
@@ -9614,21 +10234,21 @@
 as_cr_Letters=$as_cr_letters$as_cr_LETTERS
 as_cr_digits='0123456789'
 as_cr_alnum=$as_cr_Letters$as_cr_digits
 
 # The user is always right.
 if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conftest.sh
-  echo  "exit 0"   >>conftest.sh
-  chmod +x conftest.sh
-  if (PATH=".;."; conftest.sh) >/dev/null 2>&1; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
     PATH_SEPARATOR=';'
   else
     PATH_SEPARATOR=:
   fi
-  rm -f conftest.sh
+  rm -f conf$$.sh
 fi
 
 
   as_lineno_1=$LINENO
   as_lineno_2=$LINENO
   as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
@@ -9671,12 +10291,14 @@
 	   if ("$as_dir/$as_base" -c '
   as_lineno_1=$LINENO
   as_lineno_2=$LINENO
   as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
   test "x$as_lineno_1" != "x$as_lineno_2" &&
   test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
 	     CONFIG_SHELL=$as_dir/$as_base
 	     export CONFIG_SHELL
 	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
 	   fi;;
 	 esac
        done
@@ -9744,12 +10366,18 @@
   as_ln_s=ln
 else
   as_ln_s='cp -p'
 fi
 rm -f conf$$ conf$$.exe conf$$.file
 
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  as_mkdir_p=false
+fi
+
 as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
 
 # Sed expression to map a string onto a valid variable name.
@@ -9760,13 +10388,13 @@
 # We need space, tab and new line, in precisely that order.
 as_nl='
 '
 IFS=" 	$as_nl"
 
 # CDPATH.
-$as_unset CDPATH || test "${CDPATH+set}" != set || { CDPATH=$PATH_SEPARATOR; export CDPATH; }
+$as_unset CDPATH
 
 exec 6>&1
 
 # Open the log real soon, to keep \$[0] and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.  Logging --version etc. is OK.
@@ -9777,13 +10405,13 @@
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.53.  Invocation command line was
+generated by GNU Autoconf 2.57.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
   $ $0 $@
@@ -9817,12 +10445,13 @@
 current configuration.
 
 Usage: $0 [OPTIONS] [FILE]...
 
   -h, --help       print this help, then exit
   -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
   -d, --debug      don't remove temporary files
       --recheck    update $as_me by reconfiguring in the same conditions
   --file=FILE[:TEMPLATE]
                    instantiate the configuration file FILE
   --header=FILE[:TEMPLATE]
                    instantiate the configuration header FILE
@@ -9836,13 +10465,13 @@
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.53,
+configured by $0, generated by GNU Autoconf 2.57,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
@@ -9857,31 +10486,31 @@
 while test $# != 0
 do
   case $1 in
   --*=*)
     ac_option=`expr "x$1" : 'x\([^=]*\)='`
     ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
-    shift
-    set dummy "$ac_option" "$ac_optarg" ${1+"$@"}
-    shift
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
     ;;
-  -*);;
   *) # This is not an option, so the user has probably given explicit
      # arguments.
+     ac_option=$1
      ac_need_defaults=false;;
   esac
 
-  case $1 in
+  case $ac_option in
   # Handling of the options.
 _ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    echo "running $SHELL $0 " $ac_configure_args " --no-create --no-recursion"
-    exec $SHELL $0 $ac_configure_args --no-create --no-recursion ;;
-_ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
   --version | --vers* | -V )
     echo "$ac_cs_version"; exit 0 ;;
   --he | --h)
     # Conflict between --help and --header
     { { echo "$as_me:$LINENO: error: ambiguous option: $1
 Try \`$0 --help' for more information." >&5
@@ -9890,19 +10519,22 @@
    { (exit 1); exit 1; }; };;
   --help | --hel | -h )
     echo "$ac_cs_usage"; exit 0 ;;
   --debug | --d* | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
-    shift
-    CONFIG_FILES="$CONFIG_FILES $1"
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
     ac_need_defaults=false;;
   --header | --heade | --head | --hea )
-    shift
-    CONFIG_HEADERS="$CONFIG_HEADERS $1"
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
     ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
 
   # This is an error.
   -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
 Try \`$0 --help' for more information." >&5
 echo "$as_me: error: unrecognized option: $1
 Try \`$0 --help' for more information." >&2;}
@@ -9911,12 +10543,26 @@
   *) ac_config_targets="$ac_config_targets $1" ;;
 
   esac
   shift
 done
 
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
 _ACEOF
 
 
 
 
 
@@ -9943,31 +10589,34 @@
 # bizarre bug on SunOS 4.1.3.
 if $ac_need_defaults; then
   test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
   test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
 fi
 
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
 # Create a temporary directory, and hook for its removal unless debugging.
 $debug ||
 {
   trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
   trap '{ (exit 1); exit 1; }' 1 2 13 15
 }
 
 # Create a (secure) tmp directory for tmp files.
-: ${TMPDIR=/tmp}
+
 {
-  tmp=`(umask 077 && mktemp -d -q "$TMPDIR/csXXXXXX") 2>/dev/null` &&
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
   test -n "$tmp" && test -d "$tmp"
 }  ||
 {
-  tmp=$TMPDIR/cs$$-$RANDOM
+  tmp=./confstat$$-$RANDOM
   (umask 077 && mkdir $tmp)
 } ||
 {
-   echo "$me: cannot create a temporary directory in $TMPDIR" >&2
+   echo "$me: cannot create a temporary directory in ." >&2
    { (exit 1); exit 1; }
 }
 
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
@@ -10034,18 +10683,20 @@
 s,@OBJEXT@,$OBJEXT,;t t
 s,@CPP@,$CPP,;t t
 s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
 s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
 s,@INSTALL_DATA@,$INSTALL_DATA,;t t
 s,@HAVE_REMSH@,$HAVE_REMSH,;t t
+s,@EGREP@,$EGREP,;t t
 s,@LIBOBJS@,$LIBOBJS,;t t
 s,@ALLOCA@,$ALLOCA,;t t
 s,@OBJ_SAVE@,$OBJ_SAVE,;t t
 s,@OBJ_RESTORE@,$OBJ_RESTORE,;t t
 s,@CC_SHOBJ_FLAG@,$CC_SHOBJ_FLAG,;t t
 s,@BUILD_POPT@,$BUILD_POPT,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
 CEOF
 
 _ACEOF
 
   cat >>$CONFIG_STATUS <<\_ACEOF
   # Split the substitutions into bite-sized pieces for seds with
@@ -10110,31 +10761,36 @@
 echo X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
   	  /^X\(\/\/\)$/{ s//\1/; q; }
   	  /^X\(\/\).*/{ s//\1/; q; }
   	  s/.*/./; q'`
-  { case "$ac_dir" in
-  [\\/]* | ?:[\\/]* ) as_incr_dir=;;
-  *)                      as_incr_dir=.;;
-esac
-as_dummy="$ac_dir"
-for as_mkdir_dir in `IFS='/\\'; set X $as_dummy; shift; echo "$@"`; do
-  case $as_mkdir_dir in
-    # Skip DOS drivespec
-    ?:) as_incr_dir=$as_mkdir_dir ;;
-    *)
-      as_incr_dir=$as_incr_dir/$as_mkdir_dir
-      test -d "$as_incr_dir" ||
-        mkdir "$as_incr_dir" ||
-	{ { echo "$as_me:$LINENO: error: cannot create \"$ac_dir\"" >&5
-echo "$as_me: error: cannot create \"$ac_dir\"" >&2;}
-   { (exit 1); exit 1; }; }
-    ;;
-  esac
-done; }
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$as_dir" : 'X\(//\)[^/]' \| \
+         X"$as_dir" : 'X\(//\)$' \| \
+         X"$as_dir" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
 
   ac_builddir=.
 
 if test "$ac_dir" != .; then
   ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
   # A "../" for each directory in $ac_dir_suffix.
@@ -10158,13 +10814,13 @@
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
 # Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
 # absolute.
 ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd $ac_top_builddir && pwd`
+ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
 ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
 ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
 
 
   case $INSTALL in
   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
@@ -10348,13 +11004,13 @@
 s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
 _ACEOF
 
 # Break up conftest.defines because some shells have a limit on the size
 # of here documents, and old seds have small limits too (100 cmds).
 echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
-echo '  if egrep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  if grep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
 echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
 echo '  :' >>$CONFIG_STATUS
 rm -f conftest.tail
 while grep . conftest.defines >/dev/null
 do
   # Write a limited-size here document to $tmp/defines.sed.
@@ -10372,13 +11028,13 @@
 ' >>$CONFIG_STATUS
   sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
   rm -f conftest.defines
   mv conftest.tail conftest.defines
 done
 rm -f conftest.defines
-echo '  fi # egrep' >>$CONFIG_STATUS
+echo '  fi # grep' >>$CONFIG_STATUS
 echo >>$CONFIG_STATUS
 
 # Break up conftest.undefs because some shells have a limit on the size
 # of here documents, and old seds have small limits too (100 cmds).
 echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
 rm -f conftest.tail
@@ -10412,13 +11068,13 @@
   else
     echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
   fi
   cat $tmp/in >>$tmp/config.h
   rm -f $tmp/in
   if test x"$ac_file" != x-; then
-    if cmp -s $ac_file $tmp/config.h 2>/dev/null; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
       { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
 echo "$as_me: $ac_file is unchanged" >&6;}
     else
       ac_dir=`(dirname "$ac_file") 2>/dev/null ||
 $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
          X"$ac_file" : 'X\(//\)[^/]' \| \
@@ -10428,31 +11084,36 @@
 echo X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
   	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
   	  /^X\(\/\/\)$/{ s//\1/; q; }
   	  /^X\(\/\).*/{ s//\1/; q; }
   	  s/.*/./; q'`
-      { case "$ac_dir" in
-  [\\/]* | ?:[\\/]* ) as_incr_dir=;;
-  *)                      as_incr_dir=.;;
-esac
-as_dummy="$ac_dir"
-for as_mkdir_dir in `IFS='/\\'; set X $as_dummy; shift; echo "$@"`; do
-  case $as_mkdir_dir in
-    # Skip DOS drivespec
-    ?:) as_incr_dir=$as_mkdir_dir ;;
-    *)
-      as_incr_dir=$as_incr_dir/$as_mkdir_dir
-      test -d "$as_incr_dir" ||
-        mkdir "$as_incr_dir" ||
-	{ { echo "$as_me:$LINENO: error: cannot create \"$ac_dir\"" >&5
-echo "$as_me: error: cannot create \"$ac_dir\"" >&2;}
-   { (exit 1); exit 1; }; }
-    ;;
-  esac
-done; }
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+         X"$as_dir" : 'X\(//\)[^/]' \| \
+         X"$as_dir" : 'X\(//\)$' \| \
+         X"$as_dir" : 'X\(/\)' \| \
+         .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
 
       rm -f $ac_file
       mv $tmp/config.h $ac_file
     fi
   else
     cat $tmp/config.h
@@ -10476,21 +11137,44 @@
 # output is simply discarded.  So we exec the FD to /dev/null,
 # effectively closing config.log, so it can be properly (re)opened and
 # appended to by config.status.  When coming back to configure, we
 # need to make the FD available again.
 if test "$no_create" != yes; then
   ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
   exec 5>/dev/null
-  $SHELL $CONFIG_STATUS || ac_cs_success=false
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
   $ac_cs_success || { (exit 1); exit 1; }
 fi
 
 
+if test x"$with_rsh" = x; then
+	if test x"$HAVE_REMSH" = x1; then
+		rmsh1='remsh:'
+		rmsh2='=remsh'
+	else
+		rmsh1='rsh:  '
+		rmsh2='=rsh  '
+	fi
+	echo "$as_me:$LINENO: result: " >&5
+echo "${ECHO_T}" >&6
+	echo "$as_me:$LINENO: result:     **********************************************************************" >&5
+echo "${ECHO_T}    **********************************************************************" >&6
+	echo "$as_me:$LINENO: result:     *   As of v2.6.0, the default remote shell is ssh instead of rsh!!   *" >&5
+echo "${ECHO_T}    *   As of v2.6.0, the default remote shell is ssh instead of rsh!!   *" >&6
+	echo "$as_me:$LINENO: result:     *   To use previous default of $rmsh1 ./configure --with-rsh$rmsh2   *" >&5
+echo "${ECHO_T}    *   To use previous default of $rmsh1 ./configure --with-rsh$rmsh2   *" >&6
+	echo "$as_me:$LINENO: result:     **********************************************************************" >&5
+echo "${ECHO_T}    **********************************************************************" >&6
+fi
+
 echo "$as_me:$LINENO: result: " >&5
 echo "${ECHO_T}" >&6
 echo "$as_me:$LINENO: result:     rsync ${RSYNC_VERSION} configuration successful" >&5
 echo "${ECHO_T}    rsync ${RSYNC_VERSION} configuration successful" >&6
 echo "$as_me:$LINENO: result: " >&5
 echo "${ECHO_T}" >&6
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/configure.in	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/configure.in	2004-01-02 03:09:16.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.52)
 
-RSYNC_VERSION=2.5.7
+RSYNC_VERSION=2.6.0
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -87,32 +87,29 @@
 fi
 
 AC_ARG_WITH(included-popt,
         [  --with-included-popt    use bundled popt library, not from system])
 
 AC_ARG_WITH(rsync-path,
-	[  --with-rsync-path=PATH  set default --rsync-path to PATH (default: \"rsync\")],
+	[  --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)],
 	[ RSYNC_PATH="$with_rsync_path" ],
 	[ RSYNC_PATH="rsync" ])
 
 AC_DEFINE_UNQUOTED(RSYNC_PATH, "$RSYNC_PATH", [location of rsync on remote machine])
 
 AC_ARG_WITH(rsh,
-	AC_HELP_STRING([--with-rsh=CMD], [set rsh command to CMD (default: \"remsh\" or \"rsh\")]))
+	AC_HELP_STRING([--with-rsh=CMD], [set remote shell command to CMD (default: ssh)]))
 
 AC_CHECK_PROG(HAVE_REMSH, remsh, 1, 0)
 AC_DEFINE_UNQUOTED(HAVE_REMSH, $HAVE_REMSH, [remote shell is remsh not rsh])
 
 if test x"$with_rsh" != x
 then
 	RSYNC_RSH="$with_rsh"
-elif test x"$HAVE_REMSH" = x1
-then 
-	RSYNC_RSH="remsh"
 else
-	RSYNC_RSH="rsh"
+	RSYNC_RSH="ssh"
 fi
 
 AC_DEFINE_UNQUOTED(RSYNC_RSH, "$RSYNC_RSH", [default -e command])
 
 # arrgh. libc in the current debian stable screws up the largefile
 # stuff, getting byte range locking wrong
@@ -426,21 +423,12 @@
 }],
 rsync_cv_HAVE_SOCKETPAIR=yes,rsync_cv_HAVE_SOCKETPAIR=no,rsync_cv_HAVE_SOCKETPAIR=cross)])
 if test x"$rsync_cv_HAVE_SOCKETPAIR" = x"yes"; then
     AC_DEFINE(HAVE_SOCKETPAIR, 1, [ ])
 fi
 
-AC_CACHE_CHECK([for working fnmatch],rsync_cv_HAVE_FNMATCH,[
-AC_TRY_RUN([#include <fnmatch.h>
-main() { exit((fnmatch("*.o", "x.o", FNM_PATHNAME) == 0 &&
-               fnmatch("a/b/*", "a/b/c/d", FNM_PATHNAME) != 0) ? 0: 1); }],
-rsync_cv_HAVE_FNMATCH=yes,rsync_cv_HAVE_FNMATCH=no,rsync_cv_HAVE_FNMATCH=cross)])
-if test x"$rsync_cv_HAVE_FNMATCH" = x"yes"; then
-    AC_DEFINE(HAVE_FNMATCH, 1, [ ])
-fi
-
 if test x"$with_included_popt" != x"yes"
 then
     AC_CHECK_LIB(popt, poptGetContext, , [with_included_popt=yes])
 fi
 
 AC_MSG_CHECKING([whether to use included libpopt])
@@ -633,9 +621,24 @@
 AC_SUBST(CC_SHOBJ_FLAG)
 AC_SUBST(BUILD_POPT)
 
 AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
 AC_OUTPUT
 
+if test x"$with_rsh" = x; then
+	if test x"$HAVE_REMSH" = x1; then
+		rmsh1='remsh:'
+		rmsh2='=remsh'
+	else
+		rmsh1='rsh:  '
+		rmsh2='=rsh  '
+	fi
+	AC_MSG_RESULT()
+	AC_MSG_RESULT([    **********************************************************************])
+	AC_MSG_RESULT([    *   As of v2.6.0, the default remote shell is ssh instead of rsh!!   *])
+	AC_MSG_RESULT([    *   To use previous default of $rmsh1 ./configure --with-rsh$rmsh2   *])
+	AC_MSG_RESULT([    **********************************************************************])
+fi
+
 AC_MSG_RESULT()
 AC_MSG_RESULT([    rsync ${RSYNC_VERSION} configuration successful])
 AC_MSG_RESULT()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/errcode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/errcode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/errcode.h	2002-04-09 13:29:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/errcode.h	2003-12-15 16:04:14.000000000 +0800
@@ -16,32 +16,33 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /*
  * error codes returned by rsync.  If you change these, please also update the
- * string mappings in log.c
+ * string mappings in log.c and the EXIT VALUES in rsync.yo
  */
 
 #define RERR_OK         0
 #define RERR_SYNTAX     1       /* syntax or usage error */
 #define RERR_PROTOCOL   2       /* protocol incompatibility */
 #define RERR_FILESELECT 3       /* errors selecting input/output files, dirs */
-#define RERR_UNSUPPORTED 4       /* requested action not supported */
+#define RERR_UNSUPPORTED 4      /* requested action not supported */
 #define RERR_STARTCLIENT 5      /* error starting client-server protocol */
 
 #define RERR_SOCKETIO   10      /* error in socket IO */
 #define RERR_FILEIO     11      /* error in file IO */
 #define RERR_STREAMIO   12      /* error in rsync protocol data stream */
 #define RERR_MESSAGEIO  13      /* errors with program diagnostics */
 #define RERR_IPC        14      /* error in IPC code */
 
 #define RERR_SIGNAL     20      /* status returned when sent SIGUSR1, SIGINT */
 #define RERR_WAITCHILD  21      /* some error returned by waitpid() */
 #define RERR_MALLOC     22      /* error allocating core memory buffers */
 #define RERR_PARTIAL    23      /* partial transfer */
+#define RERR_VANISHED   24      /* file(s) vanished on sender side */
 
 #define RERR_TIMEOUT    30      /* timeout in data send/receive */
 
 /* Although it doesn't seem to be specified anywhere,
  * ssh and the shell seem to return these values:
  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/exclude.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/exclude.c	2003-12-07 05:07:27.000000000 +0800
@@ -1,22 +1,22 @@
 /* -*- c-file-style: "linux" -*-
- * 
+ *
  * Copyright (C) 1996-2001 by Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 1996 by Paul Mackerras
  * Copyright (C) 2002 by Martin Pool
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /* a lot of this stuff was originally derived from GNU tar, although
@@ -24,20 +24,24 @@
 
 /* include/exclude cluestick added by Martin Pool <mbp@samba.org> */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int delete_mode;
 
-static struct exclude_struct **exclude_list;
+struct exclude_struct **exclude_list;
+struct exclude_struct **local_exclude_list;
+struct exclude_struct **server_exclude_list;
+char *exclude_path_prefix = NULL;
 
 /** Build an exclude structure given a exclude pattern */
 static struct exclude_struct *make_exclude(const char *pattern, int include)
 {
 	struct exclude_struct *ret;
+	char *cp;
+	int pat_len;
 
 	ret = new(struct exclude_struct);
 	if (!ret) out_of_memory("make_exclude");
 
 	memset(ret, 0, sizeof(*ret));
 
@@ -47,265 +51,310 @@
 		ret->include = 1;
 		pattern += 2;
 	} else {
 		ret->include = include;
 	}
 
-	ret->pattern = strdup(pattern);
-
-	if (!ret->pattern) out_of_memory("make_exclude");
+	if (exclude_path_prefix)
+		ret->match_flags |= MATCHFLG_ABS_PATH;
+	if (exclude_path_prefix && *pattern == '/') {
+		ret->pattern = new_array(char,
+			strlen(exclude_path_prefix) + strlen(pattern) + 1);
+		if (!ret->pattern) out_of_memory("make_exclude");
+		sprintf(ret->pattern, "%s%s", exclude_path_prefix, pattern);
+	}
+	else {
+		ret->pattern = strdup(pattern);
+		if (!ret->pattern) out_of_memory("make_exclude");
+	}
 
 	if (strpbrk(pattern, "*[?")) {
-	    ret->regular_exp = 1;
-	    ret->fnmatch_flags = FNM_PATHNAME;
-	    if (strstr(pattern, "**")) {
-		    static int tested;
-		    if (!tested) {
-			    tested = 1;
-			    if (fnmatch("a/b/*", "a/b/c/d", FNM_PATHNAME)==0) {
-				    rprintf(FERROR,"WARNING: fnmatch FNM_PATHNAME is broken on your system\n");
-			    }
-		    }
-		    ret->fnmatch_flags = 0;
-	    }
+		ret->match_flags |= MATCHFLG_WILD;
+		if (strstr(pattern, "**")) {
+			ret->match_flags |= MATCHFLG_WILD2;
+			/* If the pattern starts with **, note that. */
+			if (*pattern == '*' && pattern[1] == '*')
+				ret->match_flags |= MATCHFLG_WILD2_PREFIX;
+		}
 	}
 
-	if (strlen(pattern) > 1 && pattern[strlen(pattern)-1] == '/') {
-		ret->pattern[strlen(pattern)-1] = 0;
+	pat_len = strlen(ret->pattern);
+	if (pat_len > 1 && ret->pattern[pat_len-1] == '/') {
+		ret->pattern[pat_len-1] = 0;
 		ret->directory = 1;
 	}
 
-	if (!strchr(ret->pattern,'/')) {
-		ret->local = 1;
-	}
+	for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
+		ret->slash_cnt++;
 
 	return ret;
 }
 
 static void free_exclude(struct exclude_struct *ex)
 {
 	free(ex->pattern);
 	memset(ex,0,sizeof(*ex));
 	free(ex);
 }
 
+
+void free_exclude_list(struct exclude_struct ***listp)
+{
+	struct exclude_struct **list = *listp;
+
+	if (verbose > 2)
+		rprintf(FINFO,"clearing exclude list\n");
+
+	if (!list)
+		return;
+
+	while (*list)
+		free_exclude(*list++);
+
+	free(*listp);
+	*listp = NULL;
+}
+
 static int check_one_exclude(char *name, struct exclude_struct *ex,
-                             STRUCT_STAT *st)
+                             int name_is_dir)
 {
 	char *p;
-	int match_start=0;
+	int match_start = 0;
 	char *pattern = ex->pattern;
 
-	if (ex->local && (p=strrchr(name,'/')))
-		name = p+1;
+	/* If the pattern does not have any slashes AND it does not have
+	 * a "**" (which could match a slash), then we just match the
+	 * name portion of the path. */
+	if (!ex->slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
+		if ((p = strrchr(name,'/')) != NULL)
+			name = p+1;
+	}
+	else if ((ex->match_flags & MATCHFLG_ABS_PATH) && *name != '/') {
+		static char full_name[MAXPATHLEN];
+		extern char curr_dir[];
+		int plus = curr_dir[1] == '\0'? 1 : 0;
+		snprintf(full_name, sizeof full_name,
+			 "%s/%s", curr_dir+plus, name);
+		name = full_name;
+	}
 
 	if (!name[0]) return 0;
 
-	if (ex->directory && !S_ISDIR(st->st_mode)) return 0;
+	if (ex->directory && !name_is_dir) return 0;
 
-	if (*pattern == '/' && *name != '/') {
+	if (*pattern == '/') {
 		match_start = 1;
 		pattern++;
+		if (*name == '/')
+			name++;
 	}
 
-	if (ex->regular_exp) {
-		if (fnmatch(pattern, name, ex->fnmatch_flags) == 0) {
+	if (ex->match_flags & MATCHFLG_WILD) {
+		/* A non-anchored match with an infix slash and no "**"
+		 * needs to match the last slash_cnt+1 name elements. */
+		if (!match_start && ex->slash_cnt &&
+		    !(ex->match_flags & MATCHFLG_WILD2)) {
+			int cnt = ex->slash_cnt + 1;
+			for (p = name + strlen(name) - 1; p >= name; p--) {
+				if (*p == '/' && !--cnt)
+					break;
+			}
+			name = p+1;
+		}
+		if (wildmatch(pattern, name))
 			return 1;
+		if (ex->match_flags & MATCHFLG_WILD2_PREFIX) {
+			/* If the **-prefixed pattern has a '/' as the next
+			 * character, then try to match the rest of the
+			 * pattern at the root. */
+			if (pattern[2] == '/' && wildmatch(pattern+3, name))
+				return 1;
+		}
+		else if (!match_start && ex->match_flags & MATCHFLG_WILD2) {
+			/* A non-anchored match with an infix or trailing "**"
+			 * (but not a prefixed "**") needs to try matching
+			 * after every slash. */
+			while ((name = strchr(name, '/')) != NULL) {
+				name++;
+				if (wildmatch(pattern, name))
+					return 1;
+			}
 		}
+	} else if (match_start) {
+		if (strcmp(name,pattern) == 0)
+			return 1;
 	} else {
 		int l1 = strlen(name);
 		int l2 = strlen(pattern);
-		if (l2 <= l1 && 
+		if (l2 <= l1 &&
 		    strcmp(name+(l1-l2),pattern) == 0 &&
-		    (l1==l2 || (!match_start && name[l1-(l2+1)] == '/'))) {
+		    (l1==l2 || name[l1-(l2+1)] == '/')) {
 			return 1;
 		}
 	}
 
 	return 0;
 }
 
 
 static void report_exclude_result(char const *name,
                                   struct exclude_struct const *ent,
-                                  STRUCT_STAT const *st)
+                                  int name_is_dir)
 {
         /* If a trailing slash is present to match only directories,
          * then it is stripped out by make_exclude.  So as a special
          * case we add it back in here. */
-        
+
         if (verbose >= 2)
                 rprintf(FINFO, "%s %s %s because of pattern %s%s\n",
                         ent->include ? "including" : "excluding",
-                        S_ISDIR(st->st_mode) ? "directory" : "file",
+			name_is_dir ? "directory" : "file",
                         name, ent->pattern,
                         ent->directory ? "/" : "");
 }
 
 
 /*
  * Return true if file NAME is defined to be excluded by either
  * LOCAL_EXCLUDE_LIST or the globals EXCLUDE_LIST.
  */
-int check_exclude(char *name, struct exclude_struct **local_exclude_list,
-		  STRUCT_STAT *st)
+int check_exclude(struct exclude_struct **list, char *name, int name_is_dir)
 {
-	int n;
         struct exclude_struct *ent;
 
-	if (name && (name[0] == '.') && !name[1])
-		/* never exclude '.', even if somebody does --exclude '*' */
-		return 0;
-
-	if (exclude_list) {
-		for (n=0; exclude_list[n]; n++) {
-                        ent = exclude_list[n];
-			if (check_one_exclude(name, ent, st)) {
-                                report_exclude_result(name, ent, st);
-				return !ent->include;
-                        }
-                }
-	}
-
-	if (local_exclude_list) {
-		for (n=0; local_exclude_list[n]; n++) {
-                        ent = local_exclude_list[n];
-			if (check_one_exclude(name, ent, st)) {
-                                report_exclude_result(name, ent, st);
-				return !ent->include;
-                        }
+	while ((ent = *list++) != NULL) {
+		if (check_one_exclude(name, ent, name_is_dir)) {
+			report_exclude_result(name, ent, name_is_dir);
+			return !ent->include;
                 }
 	}
 
 	return 0;
 }
 
 
-void add_exclude_list(const char *pattern, struct exclude_struct ***list, int include)
+void add_exclude(struct exclude_struct ***listp, const char *pattern, int include)
 {
-	int len=0;
-	if (list && *list)
-		for (; (*list)[len]; len++) ;
-
-	if (strcmp(pattern,"!") == 0) {
-		if (verbose > 2)
-			rprintf(FINFO,"clearing exclude list\n");
-		while ((len)--) {
-			free_exclude((*list)[len]);
-		}
-		free((*list));
-		*list = NULL;
-		return;
+	struct exclude_struct **list = *listp;
+	int len = 0;
+
+	if (*pattern == '!' && !pattern[1]) {
+	    free_exclude_list(listp);
+	    return;
 	}
 
-	*list = realloc_array(*list, struct exclude_struct *, len+2);
-	
-	if (!*list || !((*list)[len] = make_exclude(pattern, include)))
+	if (list)
+		for (; list[len]; len++) {}
+
+ 	list = *listp = realloc_array(list, struct exclude_struct *, len+2);
+
+	if (!list || !(list[len] = make_exclude(pattern, include)))
 		out_of_memory("add_exclude");
-	
+
 	if (verbose > 2) {
 		rprintf(FINFO,"add_exclude(%s,%s)\n",pattern,
-			      include ? "include" : "exclude");
+			include ? "include" : "exclude");
 	}
 
-	(*list)[len+1] = NULL;
+	list[len+1] = NULL;
 }
 
-void add_exclude(const char *pattern, int include)
-{
-	add_exclude_list(pattern,&exclude_list, include);
-}
 
-struct exclude_struct **make_exclude_list(const char *fname,
-					  struct exclude_struct **list1,
-					  int fatal, int include)
+void add_exclude_file(struct exclude_struct ***listp, const char *fname,
+		      int fatal, int include)
 {
-	struct exclude_struct **list=list1;
-	FILE *f;
+	int fd;
 	char line[MAXPATHLEN];
+	char *eob = line + MAXPATHLEN - 1;
+	extern int eol_nulls;
 
-	if (strcmp(fname, "-")) {
-		f = fopen(fname,"r");
-	} else {
-		f = fdopen(0, "r");
-	}
-	if (!f) {
+	if (!fname || !*fname)
+		return;
+
+	if (*fname != '-' || fname[1])
+		fd = open(fname, O_RDONLY|O_BINARY);
+	else
+		fd = 0;
+	if (fd < 0) {
 		if (fatal) {
 			rsyserr(FERROR, errno,
                                 "failed to open %s file %s",
                                 include ? "include" : "exclude",
                                 fname);
 			exit_cleanup(RERR_FILEIO);
 		}
-		return list;
+		return;
 	}
 
-	while (fgets(line,MAXPATHLEN,f)) {
-		int l = strlen(line);
-		while (l && (line[l-1] == '\n' || line[l-1] == '\r')) l--;
-		line[l] = 0;
-		if (line[0] && (line[0] != ';') && (line[0] != '#')) {
+	while (1) {
+		char ch, *s = line;
+		int cnt;
+		while (1) {
+			if ((cnt = read(fd, &ch, 1)) <= 0) {
+				if (cnt < 0 && errno == EINTR)
+					continue;
+				break;
+			}
+			if (eol_nulls? !ch : (ch == '\n' || ch == '\r'))
+				break;
+			if (s < eob)
+				*s++ = ch;
+		}
+		*s = '\0';
+		if (*line && *line != ';' && *line != '#') {
 			/* Skip lines starting with semicolon or pound.
-			   It probably wouldn't cause any harm to not skip
-			     them but there's no need to save them. */
-			add_exclude_list(line,&list,include);
+			 * It probably wouldn't cause any harm to not skip
+			 * them but there's no need to save them. */
+			add_exclude(listp, line, include);
 		}
+		if (cnt <= 0)
+			break;
 	}
-	fclose(f);
-	return list;
-}
-
-
-void add_exclude_file(const char *fname, int fatal, int include)
-{
-	if (!fname || !*fname) return;
-
-	exclude_list = make_exclude_list(fname,exclude_list,fatal,include);
+	close(fd);
 }
 
 
 void send_exclude_list(int f)
 {
 	int i;
-	extern int remote_version;
+	extern int protocol_version;
 	extern int list_only, recurse;
 
 	/* This is a complete hack - blame Rusty.
 	 *
 	 * FIXME: This pattern shows up in the output of
 	 * report_exclude_result(), which is not ideal. */
-	if (list_only && !recurse) {
-		add_exclude("/*/*", 0);
-	}
+	if (list_only && !recurse)
+		add_exclude(&exclude_list, "/*/*", ADD_EXCLUDE);
 
 	if (!exclude_list) {
 		write_int(f,0);
 		return;
 	}
 
 	for (i=0;exclude_list[i];i++) {
 		int l;
 		char pattern[MAXPATHLEN];
 
-		strlcpy(pattern,exclude_list[i]->pattern,sizeof(pattern)); 
+		strlcpy(pattern,exclude_list[i]->pattern,sizeof(pattern));
 		if (exclude_list[i]->directory) strlcat(pattern,"/", sizeof(pattern));
 
 		l = strlen(pattern);
 		if (l == 0) continue;
 		if (exclude_list[i]->include) {
-			if (remote_version < 19) {
+			if (protocol_version < 19) {
 				rprintf(FERROR,"remote rsync does not support include syntax - aborting\n");
 				exit_cleanup(RERR_UNSUPPORTED);
 			}
 			write_int(f,l+2);
 			write_buf(f,"+ ",2);
 		} else {
 			write_int(f,l);
 		}
 		write_buf(f,pattern,l);
-	}    
+	}
 
 	write_int(f,0);
 }
 
 
 void recv_exclude_list(int f)
@@ -313,13 +362,13 @@
 	char line[MAXPATHLEN];
 	unsigned int l;
 
 	while ((l=read_int(f))) {
 		if (l >= MAXPATHLEN) overflow("recv_exclude_list");
 		read_sbuf(f,line,l);
-		add_exclude(line,0);
+		add_exclude(&exclude_list, line, ADD_EXCLUDE);
 	}
 }
 
 /* Get the next include/exclude arg from the string. It works in a similar way
 ** to strtok - initially an arg is sent over, from then on NULL. This
 ** routine takes into account any +/- in the strings and does not
@@ -349,13 +398,13 @@
 		/* remember the beginning of the token */
 		t=s;
 
 		/* Is this a '+' or '-' followed by a space (not whitespace)? */
 		if ((*s=='+' || *s=='-') && *(s+1)==' ')
 			s+=2;
-	
+
 		/* Skip to the next space or the end of the string */
 		while (!isspace(* (unsigned char *) s) && *s != '\0')
 			s++;
 	} else {
 		t=NULL;
 	}
@@ -365,32 +414,22 @@
 		*s++='\0';
 	else
 		more=0;
 	return(t);
 }
 
-	
-void add_exclude_line(char *p)
-{
-	char *tok;
-	if (!p || !*p) return;
-	p = strdup(p);
-	if (!p) out_of_memory("add_exclude_line");
- 	for (tok=get_exclude_tok(p); tok; tok=get_exclude_tok(NULL))
-		add_exclude(tok, 0);
-	free(p);
-}
 
-void add_include_line(char *p)
+void add_exclude_line(struct exclude_struct ***listp,
+		      const char *line, int include)
 {
-	char *tok;
-	if (!p || !*p) return;
-	p = strdup(p);
-	if (!p) out_of_memory("add_include_line");
+	char *tok, *p;
+	if (!line || !*line) return;
+	p = strdup(line);
+	if (!p) out_of_memory("add_exclude_line");
 	for (tok=get_exclude_tok(p); tok; tok=get_exclude_tok(NULL))
-		add_exclude(tok, 1);
+		add_exclude(listp, tok, include);
 	free(p);
 }
 
 
 static char *cvs_ignore_list[] = {
   "RCS/", "SCCS/", "CVS/", ".svn/", "CVS.adm", "RCSLOG", "cvslog.*",
@@ -402,17 +441,17 @@
 
 void add_cvs_excludes(void)
 {
 	char fname[MAXPATHLEN];
 	char *p;
 	int i;
-  
+
 	for (i=0; cvs_ignore_list[i]; i++)
-		add_exclude(cvs_ignore_list[i], 0);
+		add_exclude(&exclude_list, cvs_ignore_list[i], ADD_EXCLUDE);
 
 	if ((p=getenv("HOME")) && strlen(p) < (MAXPATHLEN-12)) {
 		snprintf(fname,sizeof(fname), "%s/.cvsignore",p);
-		add_exclude_file(fname,0,0);
+		add_exclude_file(&exclude_list,fname,MISSING_OK,ADD_EXCLUDE);
 	}
 
-	add_exclude_line(getenv("CVSIGNORE"));
+	add_exclude_line(&exclude_list, getenv("CVSIGNORE"), ADD_EXCLUDE);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/fileio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/fileio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/fileio.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/fileio.c	2003-12-07 05:07:27.000000000 +0800
@@ -66,25 +66,28 @@
 	if (l2 > 0)
 		do_lseek(f,l2,SEEK_CUR);
 	
 	return len;
 }
 
-
-
+/*
+ * write_file does not allow incomplete writes.  It loops internally
+ * until len bytes are written or errno is set.
+ */
 int write_file(int f,char *buf,size_t len)
 {
 	int ret = 0;
 
-	if (!sparse_files) {
-		return write(f,buf,len);
-	}
-
 	while (len>0) {
-		int len1 = MIN(len, SPARSE_WRITE_SIZE);
-		int r1 = write_sparse(f, buf, len1);
+		int r1;
+		if (sparse_files) {
+			int len1 = MIN(len, SPARSE_WRITE_SIZE);
+			r1 = write_sparse(f, buf, len1);
+		} else {
+			r1 = write(f, buf, len);
+		}
 		if (r1 <= 0) {
 			if (ret > 0) return ret;
 			return r1;
 		}
 		len -= r1;
 		buf += r1;
@@ -109,12 +112,13 @@
 	map->file_size = len;
 	map->p = NULL;
 	map->p_size = 0;
 	map->p_offset = 0;
 	map->p_fd_offset = 0;
 	map->p_len = 0;
+	map->status = 0;
 
 	return map;
 }
 
 /* slide the read window in the file */
 char *map_ptr(struct map_struct *map,OFF_T offset,int len)
@@ -185,13 +189,17 @@
 				exit_cleanup(RERR_FILEIO);
 			}
 			map->p_fd_offset = read_start;
 		}
 
 		if ((nread=read(map->fd,map->p + read_offset,read_size)) != read_size) {
-			if (nread < 0) nread = 0;
+			if (nread < 0) {
+				nread = 0;
+				if (!map->status)
+					map->status = errno;
+			}
 			/* the best we can do is zero the buffer - the file
 			   has changed mid transfer! */
 			memset(map->p+read_offset+nread, 0, read_size - nread);
 		}
 		map->p_fd_offset += nread;
 	}
@@ -200,16 +208,21 @@
 	map->p_len = window_size;
   
 	return map->p + (offset - map->p_offset); 
 }
 
 
-void unmap_file(struct map_struct *map)
+int unmap_file(struct map_struct *map)
 {
+	int	ret;
+
 	if (map->p) {
 		free(map->p);
 		map->p = NULL;
 	}
+	ret = map->status;
 	memset(map, 0, sizeof(*map));
 	free(map);
+
+	return ret;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/flist.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/flist.c	2003-12-15 16:10:31.000000000 +0800
@@ -1,21 +1,21 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1996
    Copyright (C) Paul Mackerras 1996
    Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /** @file flist.c
@@ -38,42 +38,48 @@
 extern int am_server;
 extern int always_checksum;
 
 extern int cvs_exclude;
 
 extern int recurse;
+extern char *files_from;
+extern int filesfrom_fd;
 
 extern int one_file_system;
 extern int make_backups;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_perms;
 extern int preserve_devices;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_times;
 extern int relative_paths;
+extern int implied_dirs;
 extern int copy_links;
 extern int copy_unsafe_links;
-extern int remote_version;
-extern int io_error;
+extern int protocol_version;
 extern int sanitize_paths;
 
 extern int read_batch;
 extern int write_batch;
 
-static struct exclude_struct **local_exclude_list;
+extern struct exclude_struct **exclude_list;
+extern struct exclude_struct **server_exclude_list;
+extern struct exclude_struct **local_exclude_list;
+
+int io_error;
 
 static struct file_struct null_file;
 
-static void clean_flist(struct file_list *flist, int strip_root);
+static void clean_flist(struct file_list *flist, int strip_root, int no_dups);
 
 
 static int show_filelist_p(void)
 {
-	return verbose && recurse && !am_server;
+	return verbose && (recurse || files_from) && !am_server;
 }
 
 static void start_filelist_progress(char *kind)
 {
 	rprintf(FINFO, "%s ... ", kind);
 	if ((verbose > 1) || do_progress)
@@ -213,18 +219,18 @@
 	if (do_lstat(path, buffer) == -1) {
 		return -1;
 	}
 	if (S_ISLNK(buffer->st_mode)) {
 		int l;
 		l = readlink((char *) path, linkbuf, MAXPATHLEN - 1);
-		if (l == -1) 
+		if (l == -1)
 			return -1;
 		linkbuf[l] = 0;
 		if (copy_unsafe_links && unsafe_symlink(linkbuf, path)) {
 			if (verbose > 1) {
-				rprintf(FINFO,"copying unsafe symlink \"%s\" -> \"%s\"\n", 
+				rprintf(FINFO,"copying unsafe symlink \"%s\" -> \"%s\"\n",
 					path, linkbuf);
 			}
 			return do_stat(path, buffer);
 		}
 	}
 	return 0;
@@ -244,26 +250,43 @@
 #else
 	return do_stat(path, buffer);
 #endif
 }
 
 /*
-  This function is used to check if a file should be included/excluded
-  from the list of files based on its name and type etc
+ * This function is used to check if a file should be included/excluded
+ * from the list of files based on its name and type etc.  The value of
+ * exclude_level is set to either SERVER_EXCLUDES or ALL_EXCLUDES.
  */
-static int check_exclude_file(int f, char *fname, STRUCT_STAT * st)
+static int check_exclude_file(char *fname, int is_dir, int exclude_level)
 {
-	extern int delete_excluded;
-
-	/* f is set to -1 when calculating deletion file list */
-	if ((f == -1) && delete_excluded) {
+#if 0 /* This currently never happens, so avoid a useless compare. */
+	if (exclude_level == NO_EXCLUDES)
 		return 0;
+#endif
+	if (fname) {
+		/* never exclude '.', even if somebody does --exclude '*' */
+		if (fname[0] == '.' && !fname[1])
+			return 0;
+		/* Handle the -R version of the '.' dir. */
+		if (fname[0] == '/') {
+			int len = strlen(fname);
+			if (fname[len-1] == '.' && fname[len-2] == '/')
+				return 0;
+		}
 	}
-	if (check_exclude(fname, local_exclude_list, st)) {
+	if (server_exclude_list
+	 && check_exclude(server_exclude_list, fname, is_dir))
+		return 1;
+	if (exclude_level != ALL_EXCLUDES)
+		return 0;
+	if (exclude_list && check_exclude(exclude_list, fname, is_dir))
+		return 1;
+	if (local_exclude_list
+	 && check_exclude(local_exclude_list, fname, is_dir))
 		return 1;
-	}
 	return 0;
 }
 
 /* used by the one_file_system code */
 static dev_t filesystem_dev;
 
@@ -303,33 +326,34 @@
  * entries.
  **/
 static void flist_expand(struct file_list *flist)
 {
 	if (flist->count >= flist->malloced) {
 		void *new_ptr;
-		
+
 		if (flist->malloced < 1000)
 			flist->malloced += 1000;
 		else
 			flist->malloced *= 2;
 
-		if (flist->files)
+		if (flist->files) {
 			new_ptr = realloc_array(flist->files,
 						struct file_struct *,
 						flist->malloced);
-		else
+		} else {
 			new_ptr = new_array(struct file_struct *,
 					    flist->malloced);
+		}
 
 		if (verbose >= 2) {
 			rprintf(FINFO, "expand file_list to %.0f bytes, did%s move\n",
 				(double)sizeof(flist->files[0])
 				* flist->malloced,
 				(new_ptr == flist->files) ? " not" : "");
 		}
-		
+
 		flist->files = (struct file_struct **) new_ptr;
 
 		if (!flist->files)
 			out_of_memory("flist_expand");
 	}
 }
@@ -372,13 +396,13 @@
 		flags |= SAME_GID;
 	if (file->modtime == last_time)
 		flags |= SAME_TIME;
 
 	for (l1 = 0;
 	     lastname[l1] && (fname[l1] == lastname[l1]) && (l1 < 255);
-	     l1++);
+	     l1++) {}
 	l2 = strlen(fname) - l1;
 
 	if (l1 > 0)
 		flags |= SAME_NAME;
 	if (l2 > 255)
 		flags |= LONG_NAME;
@@ -422,26 +446,26 @@
 		write_buf(f, file->link, strlen(file->link));
 	}
 #endif
 
 #if SUPPORT_HARD_LINKS
 	if (preserve_hard_links && S_ISREG(file->mode)) {
-		if (remote_version < 26) {
+		if (protocol_version < 26) {
 			/* 32-bit dev_t and ino_t */
 			write_int(f, (int) file->dev);
 			write_int(f, (int) file->inode);
 		} else {
 			/* 64-bit dev_t and ino_t */
 			write_longint(f, file->dev);
 			write_longint(f, file->inode);
 		}
 	}
 #endif
 
 	if (always_checksum) {
-		if (remote_version < 21) {
+		if (protocol_version < 21) {
 			write_buf(f, file->sum, 2);
 		} else {
 			write_buf(f, file->sum, MD4_SUM_LENGTH);
 		}
 	}
 
@@ -555,13 +579,13 @@
 		if (sanitize_paths) {
 			sanitize_path(file->link, file->dirname);
 		}
 	}
 #if SUPPORT_HARD_LINKS
 	if (preserve_hard_links && S_ISREG(file->mode)) {
-		if (remote_version < 26) {
+		if (protocol_version < 26) {
 			file->dev = read_int(f);
 			file->inode = read_int(f);
 		} else {
 			file->dev = read_longint(f);
 			file->inode = read_longint(f);
 		}
@@ -569,13 +593,13 @@
 #endif
 
 	if (always_checksum) {
 		file->sum = new_array(char, MD4_SUM_LENGTH);
 		if (!file->sum)
 			out_of_memory("md4 sum");
-		if (remote_version < 21) {
+		if (protocol_version < 21) {
 			read_buf(f, file->sum, 2);
 		} else {
 			read_buf(f, file->sum, MD4_SUM_LENGTH);
 		}
 	}
 
@@ -636,14 +660,14 @@
  * stat()ing the file in some circumstances, which has a certain cost.
  * We are called immediately after doing readdir(), and so we may
  * already know the d_type of the file.  We could for example avoid
  * statting directories if we're not recursing, but this is not a very
  * important case.  Some systems may not have d_type.
  **/
-struct file_struct *make_file(int f, char *fname, struct string_area **ap,
-			      int noexcludes)
+struct file_struct *make_file(char *fname, struct string_area **ap,
+			      int exclude_level)
 {
 	struct file_struct *file;
 	STRUCT_STAT st;
 	char sum[SUM_LENGTH];
 	char *p;
 	char cleaned_name[MAXPATHLEN];
@@ -659,46 +683,44 @@
 	fname = cleaned_name;
 
 	memset(sum, 0, SUM_LENGTH);
 
 	if (readlink_stat(fname, &st, linkbuf) != 0) {
 		int save_errno = errno;
-		if ((errno == ENOENT) && !noexcludes) {
-			/* either symlink pointing nowhere or file that 
+		if (errno == ENOENT && exclude_level != NO_EXCLUDES) {
+			/* either symlink pointing nowhere or file that
 			 * was removed during rsync run; see if excluded
 			 * before reporting an error */
-			memset((char *) &st, 0, sizeof(st));
-			if (check_exclude_file(f, fname, &st)) {
+			if (check_exclude_file(fname, 0, exclude_level)) {
 				/* file is excluded anyway, ignore silently */
 				return NULL;
 			}
 		}
-		io_error = 1;
-		rprintf(FERROR, "readlink %s: %s\n",
-			fname, strerror(save_errno));
+		io_error |= IOERR_GENERAL;
+		rprintf(FERROR, "readlink %s failed: %s\n",
+			full_fname(fname), strerror(save_errno));
 		return NULL;
 	}
 
-	/* we use noexcludes from backup.c */
-	if (noexcludes)
+	/* backup.c calls us with exclude_level set to NO_EXCLUDES. */
+	if (exclude_level == NO_EXCLUDES)
 		goto skip_excludes;
 
-	if (S_ISDIR(st.st_mode) && !recurse) {
+	if (S_ISDIR(st.st_mode) && !recurse && !files_from) {
 		rprintf(FINFO, "skipping directory %s\n", fname);
 		return NULL;
 	}
 
 	if (one_file_system && st.st_dev != filesystem_dev) {
 		if (skip_filesystem(fname, &st))
 			return NULL;
 	}
 
-	if (check_exclude_file(f, fname, &st))
+	if (check_exclude_file(fname, S_ISDIR(st.st_mode) != 0, exclude_level))
 		return NULL;
 
-
 	if (lp_ignore_nonreadable(module_id) && access(fname, R_OK) != 0)
 		return NULL;
 
       skip_excludes:
 
 	if (verbose > 2)
@@ -699,13 +721,13 @@
 	if (lp_ignore_nonreadable(module_id) && access(fname, R_OK) != 0)
 		return NULL;
 
       skip_excludes:
 
 	if (verbose > 2)
-		rprintf(FINFO, "make_file(%d,%s)\n", f, fname);
+		rprintf(FINFO, "make_file(%s,*,%d)\n", fname, exclude_level);
 
 	file = new(struct file_struct);
 	if (!file)
 		out_of_memory("make_file");
 	memset((char *) file, 0, sizeof(*file));
 
@@ -777,26 +799,30 @@
 
 
 void send_file_name(int f, struct file_list *flist, char *fname,
 		    int recursive, unsigned base_flags)
 {
 	struct file_struct *file;
+	extern int delete_excluded;
 
-	file = make_file(f, fname, &flist->string_area, 0);
+	/* f is set to -1 when calculating deletion file list */
+	file = make_file(fname, &flist->string_area,
+			 f == -1 && delete_excluded? SERVER_EXCLUDES
+						   : ALL_EXCLUDES);
 
 	if (!file)
 		return;
 
 	maybe_emit_filelist_progress(flist);
 
 	flist_expand(flist);
 
 	if (write_batch)	/*  dw  */
 		file->flags = FLAG_DELETE;
 
-	if (strcmp(file->basename, "")) {
+	if (file->basename[0]) {
 		flist->files[flist->count++] = file;
 		send_file_entry(file, f, base_flags);
 	}
 
 	if (S_ISDIR(file->mode) && recursive) {
 		struct exclude_struct **last_exclude_list =
@@ -816,25 +842,25 @@
 	char fname[MAXPATHLEN];
 	int l;
 	char *p;
 
 	d = opendir(dir);
 	if (!d) {
-		io_error = 1;
-		rprintf(FERROR, "opendir(%s): %s\n", dir, strerror(errno));
+		io_error |= IOERR_GENERAL;
+		rprintf(FERROR, "opendir %s failed: %s\n",
+			full_fname(dir), strerror(errno));
 		return;
 	}
 
 	strlcpy(fname, dir, MAXPATHLEN);
 	l = strlen(fname);
 	if (fname[l - 1] != '/') {
 		if (l == MAXPATHLEN - 1) {
-			io_error = 1;
-			rprintf(FERROR,
-				"skipping long-named directory %s\n",
-				fname);
+			io_error |= IOERR_GENERAL;
+			rprintf(FERROR, "skipping long-named directory: %s\n",
+				full_fname(fname));
 			closedir(d);
 			return;
 		}
 		strlcat(fname, "/", MAXPATHLEN);
 		l++;
 	}
@@ -842,93 +868,113 @@
 
 	local_exclude_list = NULL;
 
 	if (cvs_exclude) {
 		if (strlen(fname) + strlen(".cvsignore") <= MAXPATHLEN - 1) {
 			strcpy(p, ".cvsignore");
-			local_exclude_list =
-			    make_exclude_list(fname, NULL, 0, 0);
+			add_exclude_file(&exclude_list,fname,MISSING_OK,ADD_EXCLUDE);
 		} else {
-			io_error = 1;
+			io_error |= IOERR_GENERAL;
 			rprintf(FINFO,
 				"cannot cvs-exclude in long-named directory %s\n",
-				fname);
+				full_fname(fname));
 		}
 	}
 
-	for (di = readdir(d); di; di = readdir(d)) {
+	for (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {
 		char *dname = d_name(di);
-		if (strcmp(dname, ".") == 0 || strcmp(dname, "..") == 0)
+		if (dname[0] == '.' && (dname[1] == '\0'
+		    || (dname[1] == '.' && dname[2] == '\0')))
 			continue;
 		strlcpy(p, dname, MAXPATHLEN - l);
 		send_file_name(f, flist, fname, recurse, 0);
 	}
-
-	if (local_exclude_list) {
-		add_exclude_list("!", &local_exclude_list, 0);
+	if (errno) {
+		io_error |= IOERR_GENERAL;
+		rprintf(FERROR, "readdir(%s): (%d) %s\n",
+		    dir, errno, strerror(errno));
 	}
 
+	if (local_exclude_list)
+		free_exclude_list(&local_exclude_list); /* Zeros pointer too */
+
 	closedir(d);
 }
 
 
 /**
- *
- * I <b>think</b> f==-1 means that the list should just be built in
- * memory and not transmitted.  But who can tell? -- mbp
+ * The delete_files() function in receiver.c sets f to -1 so that we just
+ * construct the file list in memory without sending it over the wire.  It
+ * also has the side-effect of ignoring user-excludes if delete_excluded
+ * is set (so that the delete list includes user-excluded files).
  **/
 struct file_list *send_file_list(int f, int argc, char *argv[])
 {
-	int i, l;
+	int l;
 	STRUCT_STAT st;
 	char *p, *dir, *olddir;
 	char lastpath[MAXPATHLEN] = "";
 	struct file_list *flist;
 	int64 start_write;
+	int use_ff_fd = 0;
 
 	if (show_filelist_p() && f != -1)
 		start_filelist_progress("building file list");
 
 	start_write = stats.total_written;
 
 	flist = flist_new();
 
 	if (f != -1) {
 		io_start_buffering(f);
+		if (filesfrom_fd >= 0) {
+			if (argv[0] && !push_dir(argv[0], 0)) {
+				rprintf(FERROR, "push_dir %s failed: %s\n",
+					full_fname(argv[0]), strerror(errno));
+				exit_cleanup(RERR_FILESELECT);
+			}
+			use_ff_fd = 1;
+		}
 	}
 
-	for (i = 0; i < argc; i++) {
+	while (1) {
 		char fname2[MAXPATHLEN];
 		char *fname = fname2;
 
-		strlcpy(fname, argv[i], MAXPATHLEN);
+		if (use_ff_fd) {
+			if (read_filesfrom_line(filesfrom_fd, fname) == 0)
+				break;
+			sanitize_path(fname, NULL);
+		} else {
+			if (argc-- == 0)
+				break;
+			strlcpy(fname, *argv++, MAXPATHLEN);
+			if (sanitize_paths)
+				sanitize_path(fname, NULL);
+		}
 
 		l = strlen(fname);
-		if (l != 1 && fname[l - 1] == '/') {
-			if ((l == 2) && (fname[0] == '.')) {
-				/*  Turn ./ into just . rather than ./.
-				   This was put in to avoid a problem with
-				   rsync -aR --delete from ./
-				   The send_file_name() below of ./ was
-				   mysteriously preventing deletes */
-				fname[1] = 0;
+		if (fname[l - 1] == '/') {
+			if (l == 2 && fname[0] == '.') {
+				/* Turn "./" into just "." rather than "./." */
+				fname[1] = '\0';
 			} else {
 				strlcat(fname, ".", MAXPATHLEN);
 			}
 		}
 
 		if (link_stat(fname, &st) != 0) {
 			if (f != -1) {
-				io_error = 1;
-				rprintf(FERROR, "link_stat %s : %s\n",
-					fname, strerror(errno));
+				io_error |= IOERR_GENERAL;
+				rprintf(FERROR, "link_stat %s failed: %s\n",
+					full_fname(fname), strerror(errno));
 			}
 			continue;
 		}
 
-		if (S_ISDIR(st.st_mode) && !recurse) {
+		if (S_ISDIR(st.st_mode) && !recurse && !files_from) {
 			rprintf(FINFO, "skipping directory %s\n", fname);
 			continue;
 		}
 
 		dir = NULL;
 		olddir = NULL;
@@ -940,51 +986,57 @@
 				if (p == fname)
 					dir = "/";
 				else
 					dir = fname;
 				fname = p + 1;
 			}
-		} else if (f != -1 && (p = strrchr(fname, '/'))) {
+		} else if (f != -1 && implied_dirs && (p=strrchr(fname,'/')) && p != fname) {
 			/* this ensures we send the intermediate directories,
 			   thus getting their permissions right */
+			char *lp = lastpath, *fn = fname, *slash = fname;
 			*p = 0;
-			if (strcmp(lastpath, fname)) {
-				strlcpy(lastpath, fname, sizeof(lastpath));
-				*p = '/';
-				for (p = fname + 1; (p = strchr(p, '/'));
-				     p++) {
-					int copy_links_saved = copy_links;
-					int recurse_saved = recurse;
-					*p = 0;
-					copy_links = copy_unsafe_links;
-					/* set recurse to 1 to prevent make_file
-					   from ignoring directory, but still
-					   turn off the recursive parameter to
-					   send_file_name */
-					recurse = 1;
-					send_file_name(f, flist, fname, 0,
-						       0);
-					copy_links = copy_links_saved;
-					recurse = recurse_saved;
-					*p = '/';
+			/* Skip any initial directories in our path that we
+			 * have in common with lastpath. */
+			while (*fn && *lp == *fn) {
+				if (*fn == '/')
+					slash = fn;
+				lp++, fn++;
+			}
+			*p = '/';
+			if (fn != p || (*lp && *lp != '/')) {
+				int copy_links_saved = copy_links;
+				int recurse_saved = recurse;
+				copy_links = copy_unsafe_links;
+				/* set recurse to 1 to prevent make_file
+				 * from ignoring directory, but still
+				 * turn off the recursive parameter to
+				 * send_file_name */
+				recurse = 1;
+				while ((slash = strchr(slash+1, '/')) != 0) {
+					*slash = 0;
+					send_file_name(f, flist, fname, 0, 0);
+					*slash = '/';
 				}
-			} else {
+				copy_links = copy_links_saved;
+				recurse = recurse_saved;
+				*p = 0;
+				strlcpy(lastpath, fname, sizeof lastpath);
 				*p = '/';
 			}
 		}
 
 		if (!*fname)
 			fname = ".";
 
 		if (dir && *dir) {
 			olddir = push_dir(dir, 1);
 
 			if (!olddir) {
-				io_error = 1;
-				rprintf(FERROR, "push_dir %s : %s\n",
-					dir, strerror(errno));
+				io_error |= IOERR_GENERAL;
+				rprintf(FERROR, "push_dir %s failed: %s\n",
+					full_fname(dir), strerror(errno));
 				continue;
 			}
 
 			flist_dir = dir;
 		}
 
@@ -993,14 +1045,14 @@
 
 		send_file_name(f, flist, fname, recurse, FLAG_DELETE);
 
 		if (olddir != NULL) {
 			flist_dir = NULL;
 			if (pop_dir(olddir) != 0) {
-				rprintf(FERROR, "pop_dir %s : %s\n",
-					dir, strerror(errno));
+				rprintf(FERROR, "pop_dir %s failed: %s\n",
+					full_fname(dir), strerror(errno));
 				exit_cleanup(RERR_FILESELECT);
 			}
 		}
 	}
 
 	if (f != -1) {
@@ -1008,22 +1060,22 @@
 	}
 
 	if (show_filelist_p() && f != -1) {
 		finish_filelist_progress(flist);
 	}
 
-	clean_flist(flist, 0);
+	clean_flist(flist, 0, 0);
 
 	/* now send the uid/gid list. This was introduced in protocol
 	   version 15 */
-	if (f != -1 && remote_version >= 15) {
+	if (f != -1) {
 		send_uid_list(f);
 	}
 
-	/* if protocol version is >= 17 then send the io_error flag */
-	if (f != -1 && remote_version >= 17) {
+	/* send the io_error flag */
+	if (f != -1) {
 		extern int module_id;
 		write_int(f, lp_ignore_errors(module_id) ? 0 : io_error);
 	}
 
 	if (f != -1) {
 		io_end_buffering();
@@ -1062,13 +1114,13 @@
 	if (!flist->files)
 		goto oom;
 
 
 	for (flags = read_byte(f); flags; flags = read_byte(f)) {
 		int i = flist->count;
-		
+
 		flist_expand(flist);
 
 		receive_file_entry(&flist->files[i], flags, f);
 
 		if (S_ISREG(flist->files[i]->mode))
 			stats.total_size += flist->files[i]->length;
@@ -1083,25 +1135,25 @@
 	}
 
 
 	if (verbose > 2)
 		rprintf(FINFO, "received %d names\n", flist->count);
 
-	clean_flist(flist, relative_paths);
+	clean_flist(flist, relative_paths, 1);
 
 	if (show_filelist_p()) {
 		finish_filelist_progress(flist);
 	}
 
 	/* now recv the uid/gid list. This was introduced in protocol version 15 */
-	if (f != -1 && remote_version >= 15) {
+	if (f != -1) {
 		recv_uid_list(f, flist);
 	}
 
-	/* if protocol version is >= 17 then recv the io_error flag */
-	if (f != -1 && remote_version >= 17 && !read_batch) {	/* dw-added readbatch */
+	/* recv the io_error flag */
+	if (f != -1 && !read_batch) {	/* dw-added readbatch */
 		extern int module_id;
 		extern int ignore_errors;
 		if (lp_ignore_errors(module_id) || ignore_errors) {
 			read_int(f);
 		} else {
 			io_error |= read_int(f);
@@ -1240,27 +1292,28 @@
 	free(flist);
 }
 
 
 /*
  * This routine ensures we don't have any duplicate names in our file list.
- * duplicate names can cause corruption because of the pipelining 
+ * duplicate names can cause corruption because of the pipelining
  */
-static void clean_flist(struct file_list *flist, int strip_root)
+static void clean_flist(struct file_list *flist, int strip_root, int no_dups)
 {
-	int i;
+	int i, prev_i = 0;
 	char *name, *prev_name = NULL;
 
 	if (!flist || flist->count == 0)
 		return;
 
 	qsort(flist->files, flist->count,
 	      sizeof(flist->files[0]), (int (*)()) file_compare);
 
-	for (i = 0; i < flist->count; i++) {
+	for (i = no_dups? 0 : flist->count; i < flist->count; i++) {
 		if (flist->files[i]->basename) {
+			prev_i = i;
 			prev_name = f_name(flist->files[i]);
 			break;
 		}
 	}
 	while (++i < flist->count) {
 		if (!flist->files[i]->basename)
@@ -1269,21 +1322,30 @@
 		if (strcmp(name, prev_name) == 0) {
 			if (verbose > 1 && !am_server) {
 				rprintf(FINFO,
 					"removing duplicate name %s from file list %d\n",
 					name, i);
 			}
+			/* Make sure that if we unduplicate '.', that we don't
+			 * lose track of a user-specified starting point (or
+			 * else deletions will mysteriously fail with -R). */
+			if (flist->files[i]->flags & FLAG_DELETE)
+				flist->files[prev_i]->flags |= FLAG_DELETE;
 			/* it's not great that the flist knows the semantics of
 			 * the file memory usage, but i'd rather not add a flag
 			 * byte to that struct.
 			 * XXX can i use a bit in the flags field? */
 			if (flist->string_area)
 				flist->files[i][0] = null_file;
 			else
 				free_file(flist->files[i]);
 		}
+		else
+			prev_i = i;
+		/* We set prev_name every iteration to avoid it becoming
+		 * invalid when names[][] in f_name() wraps around. */
 		prev_name = name;
 	}
 
 	if (strip_root) {
 		/* we need to strip off the root directory in the case
 		   of relative paths, but this must be done _after_
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/generator.c	2002-08-29 22:44:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/generator.c	2003-12-24 09:14:16.000000000 +0800
@@ -1,24 +1,24 @@
 /* -*- c-file-style: "linux" -*-
 
    rsync -- fast file replication program
-   
-   Copyright (C) 1996-2000 by Andrew Tridgell 
+
+   Copyright (C) 1996-2000 by Andrew Tridgell
    Copyright (C) Paul Mackerras 1996
    Copyright (C) 2002 by Martin Pool <mbp@samba.org>
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
@@ -29,18 +29,17 @@
 extern int preserve_links;
 extern int am_root;
 extern int preserve_devices;
 extern int preserve_hard_links;
 extern int update_only;
 extern int opt_ignore_existing;
-extern int block_size;
 extern int csum_length;
 extern int ignore_times;
 extern int size_only;
 extern int io_timeout;
-extern int remote_version;
+extern int protocol_version;
 extern int always_checksum;
 extern int modify_window;
 extern char *compare_dest;
 extern int link_dest;
 
 
@@ -49,36 +48,42 @@
 		     struct file_struct *file, STRUCT_STAT *st)
 {
 	if (st->st_size != file->length) {
 		return 0;
 	}
 	if (link_dest) {
-		if((st->st_mode & ~_S_IFMT) !=  (file->mode & ~_S_IFMT)) {
+		extern int preserve_perms;
+		extern int preserve_uid;
+		extern int preserve_gid;
+
+		if(preserve_perms
+		    && (st->st_mode & ~_S_IFMT) !=  (file->mode & ~_S_IFMT))
 			return 0;
-		}
-		if (st->st_uid != file->uid || st->st_gid != file->gid) {
+
+		if (preserve_uid && st->st_uid != file->uid)
+			return 0;
+
+		if (preserve_gid && st->st_gid != file->gid)
 			return 0;
-		}
 	}
 
-	
-	/* if always checksum is set then we use the checksum instead 
+	/* if always checksum is set then we use the checksum instead
 	   of the file time to determine whether to sync */
 	if (always_checksum && S_ISREG(st->st_mode)) {
 		char sum[MD4_SUM_LENGTH];
 		char fnamecmpdest[MAXPATHLEN];
 
 		if (compare_dest != NULL) {
 			if (access(fname, 0) != 0) {
 				snprintf(fnamecmpdest,MAXPATHLEN,"%s/%s",
-						    compare_dest,fname);
+					 compare_dest,fname);
 				fname = fnamecmpdest;
 			}
 		}
 		file_checksum(fname,sum,st->st_size);
-		if (remote_version < 21) {
+		if (protocol_version < 21) {
 			return (memcmp(sum,file->sum,2) == 0);
 		} else {
 			return (memcmp(sum,file->sum,MD4_SUM_LENGTH) == 0);
 		}
 	}
 
@@ -91,39 +96,112 @@
 	}
 
 	return (cmp_modtime(st->st_mtime,file->modtime) == 0);
 }
 
 
-/* use a larger block size for really big files */
-static int adapt_block_size(struct file_struct *file, int bsize)
+/*
+ * 	NULL sum_struct means we have no checksums
+ */
+
+void write_sum_head(int f, struct sum_struct *sum)
 {
-	int ret;
+	static struct sum_struct null_sum;
 
-	if (bsize != BLOCK_SIZE) return bsize;
+	if (sum == (struct sum_struct *)NULL)
+		sum = &null_sum;
 
-	ret = file->length / (10000); /* rough heuristic */
-	ret = ret & ~15; /* multiple of 16 */
-	if (ret < bsize) ret = bsize;
-	if (ret > CHUNK_SIZE/2) ret = CHUNK_SIZE/2;
-	return ret;
+	write_int(f, sum->count);
+	write_int(f, sum->blength);
+	if (protocol_version >= 27)
+		write_int(f, sum->s2length);
+	write_int(f, sum->remainder);
 }
 
+/* 
+ * set (initialize) the size entries in the per-file sum_struct
+ * calulating dynamic block ans checksum sizes.
+ *
+ * This is only called from generate_and_send_sums() but is a seperate
+ * function to encapsulate the logic.
+ *
+ * The block size is a rounded square root of file length.
+ *
+ * The checksum size is determined according to:
+ *     blocksum_bits = BLOCKSUM_EXP + 2*log2(file_len) - log2(block_len)
+ * provided by Donovan Baarda which gives a probability of rsync
+ * algorithm corrupting data and falling back using the whole md4
+ * checksums.
+ *
+ * This might be made one of several selectable heuristics.
+ */
 
-/*
-  send a header that says "we have no checksums" down the f_out fd
-  */
-static void send_null_sums(int f_out)
+static void sum_sizes_sqroot(struct sum_struct *sum, uint64 len)
 {
-	write_int(f_out, 0);
-	write_int(f_out, block_size);
-	write_int(f_out, 0);
+	extern int block_size;
+	int blength, s2length, b;
+	uint32 c;
+	uint64 l;
+
+	if (block_size) {
+		blength = block_size;
+	} else if (len <= BLOCK_SIZE * BLOCK_SIZE) {
+		blength = BLOCK_SIZE;
+	} else {
+		l = len;
+		c = 1;
+		while (l >>= 2) {
+			c <<= 1;
+		}
+		blength = 0;
+		do {
+			blength |= c;
+			if (len < (uint64)blength * blength)
+				blength &= ~c;
+			c >>= 1;
+		} while (c >= 8);	/* round to multiple of 8 */
+		blength = MAX(blength, BLOCK_SIZE);
+	}
+
+	if (protocol_version < 27) {
+		s2length = csum_length;
+	} else if (csum_length == SUM_LENGTH) {
+		s2length = SUM_LENGTH;
+	} else {
+		b = BLOCKSUM_BIAS;
+		l = len;
+		while (l >>= 1) {
+			b += 2;
+		}
+		c = blength;
+		while (c >>= 1 && b) {
+			b--;
+		}
+		s2length = (b + 1 - 32 + 7) / 8; /* add a bit,
+						  * subtract rollsum,
+						  * round up
+						  *    --optimize in compiler--
+						  */
+		s2length = MAX(s2length, csum_length);
+		s2length = MIN(s2length, SUM_LENGTH);
+	}
+
+	sum->flength	= len;
+	sum->blength	= blength;
+	sum->s2length	= s2length;
+	sum->count	= (len + (blength - 1)) / blength;
+	sum->remainder	= (len % blength);
+
+	if (sum->count && verbose > 2) {
+		rprintf(FINFO, "count=%ld rem=%ld blength=%ld s2length=%ld flength=%.0f\n",
+			(long) sum->count, (long) sum->remainder,
+			(long) sum->blength, (long) sum->s2length,
+			(double) sum->flength);
+	}
 }
 
-
-
 /**
  * Perhaps we want to just send an empty checksum set for this file,
  * which will force the whole thing to be literally transferred.
  *
  * When do we do this?  If the user's explicitly said they
  * want the whole thing, or if { they haven't explicitly
@@ -129,74 +207,54 @@
  * want the whole thing, or if { they haven't explicitly
  * requested a delta, and it's local but not batch mode.}
  *
  * Whew. */
 static BOOL disable_deltas_p(void)
 {
-	extern int whole_file, no_whole_file;
+	extern int whole_file;
 	extern int local_server;
 	extern int write_batch;
 
-	assert(whole_file == 0 || whole_file == 1);
-
-	/* whole_file and no_whole_file are never both on at the same time */
-
-	if (whole_file)
+	if (whole_file > 0)
 		return True;
-	else if (no_whole_file)
-		return False;
-	else if (write_batch)
+	if (whole_file == 0 || write_batch)
 		return False;
-	else
-		return local_server;
+	return local_server;
 }
 
 
 /*
  * Generate and send a stream of signatures/checksums that describe a buffer
  *
  * Generate approximately one checksum every block_len bytes.
  */
-static void generate_and_send_sums(struct map_struct *buf, OFF_T len,
-				   int block_len, int f_out)
+static void generate_and_send_sums(struct map_struct *buf, OFF_T len, int f_out)
 {
 	size_t i;
 	struct sum_struct sum;
 	OFF_T offset = 0;
 
-	sum.count = (len + (block_len - 1)) / block_len;
-	sum.remainder = (len % block_len);
-	sum.n = block_len;
-	sum.flength = len;
-	/* not needed here  sum.sums = NULL; */
-
-	if (sum.count && verbose > 3) {
-		rprintf(FINFO, "count=%ld rem=%ld n=%ld flength=%.0f\n",
-			(long) sum.count, (long) sum.remainder,
-			(long) sum.n, (double) sum.flength);
-	}
+	sum_sizes_sqroot(&sum, len);
 
-	write_int(f_out, sum.count);
-	write_int(f_out, sum.n);
-	write_int(f_out, sum.remainder);
+	write_sum_head(f_out, &sum);
 
 	for (i = 0; i < sum.count; i++) {
-		int n1 = MIN(len, block_len);
+		int n1 = MIN(len, sum.blength);
 		char *map = map_ptr(buf, offset, n1);
 		uint32 sum1 = get_checksum1(map, n1);
 		char sum2[SUM_LENGTH];
 
 		get_checksum2(map, n1, sum2);
 
 		if (verbose > 3) {
 			rprintf(FINFO,
-				"chunk[%d] offset=%.0f len=%d sum1=%08lx\n",
-				i, (double) offset, n1, (unsigned long) sum1);
+				"chunk[%ld] offset=%.0f len=%d sum1=%08lx\n",
+				(long)i,(double)offset,n1,(unsigned long)sum1);
 		}
 		write_int(f_out, sum1);
-		write_buf(f_out, sum2, csum_length);
+		write_buf(f_out, sum2, sum.s2length);
 		len -= n1;
 		offset += n1;
 	}
 }
 
 
@@ -205,15 +263,15 @@
  * Acts on file number @p i from @p flist, whose name is @p fname.
  *
  * First fixes up permissions, then generates checksums for the file.
  *
  * @note This comment was added later by mbp who was trying to work it
  * out.  It might be wrong.
- **/ 
+ **/
 void recv_generator(char *fname, struct file_list *flist, int i, int f_out)
-{  
+{
 	int fd;
 	STRUCT_STAT st;
 	struct map_struct *buf;
 	int statret;
 	struct file_struct *file = flist->files[i];
 	char *fnamecmp;
@@ -234,63 +292,63 @@
 	if (only_existing && statret == -1 && errno == ENOENT) {
 		/* we only want to update existing files */
 		if (verbose > 1) rprintf(FINFO, "not creating new file \"%s\"\n",fname);
 		return;
 	}
 
-	if (statret == 0 && 
-	    !preserve_perms && 
+	if (statret == 0 &&
+	    !preserve_perms &&
 	    (S_ISDIR(st.st_mode) == S_ISDIR(file->mode))) {
 		/* if the file exists already and we aren't perserving
-                   presmissions then act as though the remote end sent
-                   us the file permissions we already have */
+		 * permissions then act as though the remote end sent
+		 * us the file permissions we already have */
 		file->mode = (file->mode & _S_IFMT) | (st.st_mode & ~_S_IFMT);
 	}
 
 	if (S_ISDIR(file->mode)) {
                 /* The file to be received is a directory, so we need
                  * to prepare appropriately.  If there is already a
                  * file of that name and it is *not* a directory, then
                  * we need to delete it.  If it doesn't exist, then
                  * recursively create it. */
-          
+
 		if (dry_run) return; /* XXXX -- might cause inaccuracies?? -- mbp */
 		if (statret == 0 && !S_ISDIR(st.st_mode)) {
 			if (robust_unlink(fname) != 0) {
-				rprintf(FERROR, RSYNC_NAME
-					": recv_generator: unlink \"%s\" to make room for directory: %s\n",
-                                        fname,strerror(errno));
+				rprintf(FERROR,
+					"recv_generator: unlink %s to make room for directory: %s\n",
+					full_fname(fname), strerror(errno));
 				return;
 			}
 			statret = -1;
 		}
 		if (statret != 0 && do_mkdir(fname,file->mode) != 0 && errno != EEXIST) {
-			if (!(relative_paths && errno==ENOENT && 
-			      create_directory_path(fname, orig_umask)==0 && 
+			if (!(relative_paths && errno==ENOENT &&
+			      create_directory_path(fname, orig_umask)==0 &&
 			      do_mkdir(fname,file->mode)==0)) {
-				rprintf(FERROR, RSYNC_NAME ": recv_generator: mkdir \"%s\": %s (2)\n",
-					fname,strerror(errno));
+				rprintf(FERROR, "recv_generator: mkdir %s failed: %s\n",
+					full_fname(fname), strerror(errno));
 			}
 		}
-		/* f_out is set to -1 when doing final directory 
+		/* f_out is set to -1 when doing final directory
 		   permission and modification time repair */
-		if (set_perms(fname,file,NULL,0) && verbose && (f_out != -1)) 
+		if (set_perms(fname,file,NULL,0) && verbose && (f_out != -1))
 			rprintf(FINFO,"%s/\n",fname);
 		return;
 	}
 
 	if (preserve_links && S_ISLNK(file->mode)) {
 #if SUPPORT_LINKS
 		char lnk[MAXPATHLEN];
 		int l;
 		extern int safe_symlinks;
 
 		if (safe_symlinks && unsafe_symlink(file->link, fname)) {
 			if (verbose) {
-				rprintf(FINFO,"ignoring unsafe symlink \"%s\" -> \"%s\"\n",
-					fname,file->link);
+				rprintf(FINFO, "ignoring unsafe symlink %s -> \"%s\"\n",
+					full_fname(fname), file->link);
 			}
 			return;
 		}
 		if (statret == 0) {
 			l = readlink(fname,lnk,MAXPATHLEN-1);
 			if (l > 0) {
@@ -299,42 +357,43 @@
 				 * right place -- no further action
 				 * required. */
 				if (strcmp(lnk,file->link) == 0) {
 					set_perms(fname,file,&st,1);
 					return;
 				}
-			}  
+			}
 			/* Not a symlink, so delete whatever's
 			 * already there and put a new symlink
-			 * in place. */			   
+			 * in place. */
 			delete_file(fname);
 		}
 		if (do_symlink(file->link,fname) != 0) {
-			rprintf(FERROR,RSYNC_NAME": symlink \"%s\" -> \"%s\": %s\n",
-				fname,file->link,strerror(errno));
+			rprintf(FERROR, "symlink %s -> \"%s\" failed: %s\n",
+				full_fname(fname), file->link, strerror(errno));
 		} else {
 			set_perms(fname,file,NULL,0);
 			if (verbose) {
 				rprintf(FINFO,"%s -> %s\n", fname,file->link);
 			}
 		}
 #endif
 		return;
 	}
 
 #ifdef HAVE_MKNOD
 	if (am_root && preserve_devices && IS_DEVICE(file->mode)) {
-		if (statret != 0 || 
+		if (statret != 0 ||
 		    st.st_mode != file->mode ||
-		    st.st_rdev != file->rdev) {	
+		    (DEV64_T)st.st_rdev != file->rdev) {
 			delete_file(fname);
 			if (verbose > 2)
 				rprintf(FINFO,"mknod(%s,0%o,0x%x)\n",
 					fname,(int)file->mode,(int)file->rdev);
 			if (do_mknod(fname,file->mode,file->rdev) != 0) {
-				rprintf(FERROR,"mknod %s : %s\n",fname,strerror(errno));
+				rprintf(FERROR, "mknod %s failed: %s\n",
+					full_fname(fname), strerror(errno));
 			} else {
 				set_perms(fname,file,NULL,0);
 				if (verbose)
 					rprintf(FINFO,"%s\n",fname);
 			}
 		} else {
@@ -382,38 +441,37 @@
 			fnamecmp = fnamecmpbuf;
 	}
 
 	if (statret == -1) {
 		if (errno == ENOENT) {
 			write_int(f_out,i);
-			if (!dry_run) send_null_sums(f_out);
-		} else {
-			if (verbose > 1)
-				rprintf(FERROR, RSYNC_NAME
-					": recv_generator failed to open \"%s\": %s\n",
-					fname, strerror(errno));
+			if (!dry_run) write_sum_head(f_out, NULL);
+		} else if (verbose > 1) {
+			rprintf(FERROR,
+				"recv_generator: failed to open %s: %s\n",
+				full_fname(fname), strerror(errno));
 		}
 		return;
 	}
 
 	if (!S_ISREG(st.st_mode)) {
 		if (delete_file(fname) != 0) {
 			return;
 		}
 
 		/* now pretend the file didn't exist */
 		write_int(f_out,i);
-		if (!dry_run) send_null_sums(f_out);
+		if (!dry_run) write_sum_head(f_out, NULL);
 		return;
 	}
 
-	if (opt_ignore_existing && fnamecmp == fname) { 
+	if (opt_ignore_existing && fnamecmp == fname) {
 		if (verbose > 1)
 			rprintf(FINFO,"%s exists\n",fname);
 		return;
-	} 
+	}
 
 	if (update_only && cmp_modtime(st.st_mtime,file->modtime)>0 && fnamecmp == fname) {
 		if (verbose > 1)
 			rprintf(FINFO,"%s is newer\n",fname);
 		return;
 	}
@@ -428,24 +486,25 @@
 		write_int(f_out,i);
 		return;
 	}
 
 	if (disable_deltas_p()) {
 		write_int(f_out,i);
-		send_null_sums(f_out);
+		write_sum_head(f_out, NULL);
 		return;
 	}
 
-	/* open the file */  
+	/* open the file */
 	fd = do_open(fnamecmp, O_RDONLY, 0);
 
 	if (fd == -1) {
-		rprintf(FERROR,RSYNC_NAME": failed to open \"%s\", continuing : %s\n",fnamecmp,strerror(errno));
+		rprintf(FERROR, "failed to open %s, continuing: %s\n",
+			full_fname(fnamecmp), strerror(errno));
 		/* pretend the file didn't exist */
 		write_int(f_out,i);
-		send_null_sums(f_out);
+		write_sum_head(f_out, NULL);
 		return;
 	}
 
 	if (st.st_size > 0) {
 		buf = map_file(fd,st.st_size);
 	} else {
@@ -456,14 +515,13 @@
 		rprintf(FINFO,"gen mapped %s of size %.0f\n",fnamecmp,(double)st.st_size);
 
 	if (verbose > 2)
 		rprintf(FINFO, "generating and sending sums for %d\n", i);
 
 	write_int(f_out,i);
-	generate_and_send_sums(buf, st.st_size,
-			       adapt_block_size(file, block_size), f_out);
+	generate_and_send_sums(buf, st.st_size, f_out);
 
 	close(fd);
 	if (buf) unmap_file(buf);
 }
 
 
@@ -476,17 +534,17 @@
 	if (verbose > 2)
 		rprintf(FINFO,"generator starting pid=%d count=%d\n",
 			(int)getpid(),flist->count);
 
 	if (verbose >= 2) {
 		rprintf(FINFO,
-			disable_deltas_p() 
+			disable_deltas_p()
 			? "delta-transmission disabled for local transfer or --whole-file\n"
 			: "delta transmission enabled\n");
 	}
-	
+
 	/* we expect to just sit around now, so don't exit on a
 	   timeout. If we really get a timeout then the other process should
 	   exit */
 	io_timeout = 0;
 
 	for (i = 0; i < flist->count; i++) {
@@ -500,14 +558,13 @@
 		if (!am_root && S_ISDIR(file->mode)) {
 			file->mode |= S_IWUSR; /* user write */
                         /* XXX: Could this be causing a problem on SCO?  Perhaps their
                          * handling of permissions is strange? */
 		}
 
-		recv_generator(local_name?local_name:f_name(file),
-			       flist,i,f);
+		recv_generator(local_name?local_name:f_name(file), flist,i,f);
 
 		file->mode = saved_mode;
 	}
 
 	phase++;
 	csum_length = SUM_LENGTH;
@@ -515,22 +572,19 @@
 
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
 	write_int(f,-1);
 
-	if (remote_version >= 13) {
-		/* in newer versions of the protocol the files can cycle through
-		   the system more than once to catch initial checksum errors */
-		for (i=read_int(f_recv); i != -1; i=read_int(f_recv)) {
-			struct file_struct *file = flist->files[i];
-			recv_generator(local_name?local_name:f_name(file),
-				       flist,i,f);    
-		}
+	/* files can cycle through the system more than once
+	 * to catch initial checksum errors */
+	for (i=read_int(f_recv); i != -1; i=read_int(f_recv)) {
+		struct file_struct *file = flist->files[i];
+		recv_generator(local_name?local_name:f_name(file), flist,i,f);
+	}
 
-		phase++;
-		if (verbose > 2)
-			rprintf(FINFO,"generate_files phase=%d\n",phase);
+	phase++;
+	if (verbose > 2)
+		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
-		write_int(f,-1);
-	}
+	write_int(f,-1);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/getgroups.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/getgroups.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/getgroups.c	2002-03-25 11:18:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/getgroups.c	2003-09-10 16:27:34.000000000 +0800
@@ -28,13 +28,14 @@
 
 #ifndef NGROUPS
 /* It ought to be defined, but just in case. */
 #  define NGROUPS 32
 #endif
 
-int main(int argc, char *argv[])
+int
+main(UNUSED(int argc), UNUSED(char *argv[]))
 {
 	int n, i;
 	gid_t list[NGROUPS];
 
 	if ((n = getgroups(NGROUPS, list)) == -1) {
 		perror("getgroups");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/INSTALL	2002-03-27 13:10:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/INSTALL	2003-12-16 02:20:06.000000000 +0800
@@ -8,20 +8,27 @@
 to ./configure.  To see them, use:
 
   $ ./configure --help
 
 As of 2.4.7, rsync uses Eric Troan's popt option-parsing library.  A
 cut-down copy of release 1.5 is included in the rsync distribution,
-and will be used it there is no popt library on your build host, or if
+and will be used if there is no popt library on your build host, or if
 the --with-included-popt option is passed to ./configure.
 
 If you configure using --enable-maintainer-mode, then rsync will try
 to pop up an xterm on DISPLAY=:0 if it crashes.  You might find this
 useful, but it should be turned off for production builds.
 
 
+RPM NOTES
+---------
+
+Under packaging you will find .spec files for several distributions.
+The .spec file in packaging/lsb can be used for Linux systems that
+adhere to the Linux Standards Base (e.g., RedHat and others).
+
 HP-UX NOTES
 -----------
 
 The HP-UX 10.10 "bundled" C compiler seems not to be able to cope with
 ANSI C.  You may see this error message in config.log if ./configure
 fails:
@@ -38,8 +45,14 @@
 Mac OS X (Darwin) seems to have an IPv6 stack, but it does not
 completely implement the "New Sockets" API.  
 
 <http://www.ipv6.org/impl/mac.html> says that Apple do not support
 IPv6 yet.  If your build fails, try again with --disable-ipv6.
 
+IBM AIX NOTES
+-------------
 
-
+IBM AIX has a largefile problem with mkstemp.  See IBM PR-51921.
+The workaround is to append the below to config.h
+	#ifdef _LARGE_FILES
+	#undef HAVE_SECURE_MKSTEMP
+	#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/io.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/io.c	2003-12-27 07:04:01.000000000 +0800
@@ -73,22 +73,28 @@
 /** Ignore EOF errors while reading a module listing if the remote
     version is 24 or less. */
 int kludge_around_eof = False;
 
 
 static int io_error_fd = -1;
+static int io_filesfrom_f_in = -1;
+static int io_filesfrom_f_out = -1;
+static char io_filesfrom_buf[2048];
+static char *io_filesfrom_bp;
+static char io_filesfrom_lastchar;
+static int io_filesfrom_buflen;
 
 static void read_loop(int fd, char *buf, size_t len);
 
 static void check_timeout(void)
 {
 	extern int am_server, am_daemon;
 	time_t t;
 
 	err_list_push();
-	
+
 	if (!io_timeout) return;
 
 	if (!last_io) {
 		last_io = time(NULL);
 		return;
 	}
@@ -128,55 +134,73 @@
 	len = tag & 0xFFFFFF;
 	tag = tag >> 24;
 	tag -= MPLEX_BASE;
 
 	while (len) {
 		n = len;
-		if (n > (sizeof(buf)-1))
-			n = sizeof(buf)-1;
+		if (n > (sizeof buf - 1))
+			n = sizeof buf - 1;
 		read_loop(fd, buf, n);
 		rwrite((enum logcode)tag, buf, n);
 		len -= n;
 	}
 
 	io_error_fd = fd;
 }
 
+/**
+ * When we're the receiver and we have a local --files-from list of names
+ * that needs to be sent over the socket to the sender, we have to do two
+ * things at the same time: send the sender a list of what files we're
+ * processing and read the incoming file+info list from the sender.  We do
+ * this by augmenting the read_timeout() function to copy this data.  It
+ * uses the io_filesfrom_buf to read a block of data from f_in (when it is
+ * ready, since it might be a pipe) and then blast it out f_out (when it
+ * is ready to receive more data).
+ */
+void io_set_filesfrom_fds(int f_in, int f_out)
+{
+	io_filesfrom_f_in = f_in;
+	io_filesfrom_f_out = f_out;
+	io_filesfrom_bp = io_filesfrom_buf;
+	io_filesfrom_lastchar = '\0';
+	io_filesfrom_buflen = 0;
+}
 
 /**
  * It's almost always an error to get an EOF when we're trying to read
  * from the network, because the protocol is self-terminating.
  *
  * However, there is one unfortunate cases where it is not, which is
  * rsync <2.4.6 sending a list of modules on a server, since the list
  * is terminated by closing the socket. So, for the section of the
  * program where that is a problem (start_socket_client),
  * kludge_around_eof is True and we just exit.
  */
-static void whine_about_eof (void)
+static void whine_about_eof(void)
 {
 	if (kludge_around_eof)
-		exit_cleanup (0);
+		exit_cleanup(0);
 	else {
-		rprintf (FERROR,
-			 "%s: connection unexpectedly closed "
-			 "(%.0f bytes read so far)\n",
-			 RSYNC_NAME, (double)stats.total_read);
-	
-		exit_cleanup (RERR_STREAMIO);
+		rprintf(FERROR,
+			"%s: connection unexpectedly closed "
+			"(%.0f bytes read so far)\n",
+			RSYNC_NAME, (double)stats.total_read);
+
+		exit_cleanup(RERR_STREAMIO);
 	}
 }
 
 
-static void die_from_readerr (int err)
+static void die_from_readerr(int err)
 {
 	/* this prevents us trying to write errors on a dead socket */
 	io_multiplexing_close();
-				
+
 	rprintf(FERROR, "%s: read error: %s\n",
-		RSYNC_NAME, strerror (err));
+		RSYNC_NAME, strerror(err));
 	exit_cleanup(RERR_STREAMIO);
 }
 
 
 /**
  * Read from a socket with IO timeout. return the number of bytes
@@ -186,88 +210,218 @@
  * actually report an "unexpected EOF" error here.  Since it's a
  * fairly common mistake to try to use rsh when ssh is required, we
  * should trap that: if we fail to read any data at all, we should
  * give a better explanation.  We can tell whether the connection has
  * started by looking e.g. at whether the remote version is known yet.
  */
-static int read_timeout (int fd, char *buf, size_t len)
+static int read_timeout(int fd, char *buf, size_t len)
 {
 	int n, ret=0;
 
 	io_flush();
 
 	while (ret == 0) {
 		/* until we manage to read *something* */
-		fd_set fds;
+		fd_set r_fds, w_fds;
 		struct timeval tv;
 		int fd_count = fd+1;
 		int count;
 
-		FD_ZERO(&fds);
-		FD_SET(fd, &fds);
+		FD_ZERO(&r_fds);
+		FD_SET(fd, &r_fds);
 		if (io_error_fd != -1) {
-			FD_SET(io_error_fd, &fds);
-			if (io_error_fd > fd) fd_count = io_error_fd+1;
+			FD_SET(io_error_fd, &r_fds);
+			if (io_error_fd >= fd_count) fd_count = io_error_fd+1;
+		}
+		if (io_filesfrom_f_out != -1) {
+			int new_fd;
+			if (io_filesfrom_buflen == 0) {
+				if (io_filesfrom_f_in != -1) {
+					FD_SET(io_filesfrom_f_in, &r_fds);
+					new_fd = io_filesfrom_f_in;
+				} else {
+					io_filesfrom_f_out = -1;
+					new_fd = -1;
+				}
+			} else {
+				FD_ZERO(&w_fds);
+				FD_SET(io_filesfrom_f_out, &w_fds);
+				new_fd = io_filesfrom_f_out;
+			}
+			if (new_fd >= fd_count) fd_count = new_fd+1;
 		}
 
 		tv.tv_sec = io_timeout?io_timeout:SELECT_TIMEOUT;
 		tv.tv_usec = 0;
 
 		errno = 0;
 
-		count = select(fd_count, &fds, NULL, NULL, &tv);
+		count = select(fd_count, &r_fds,
+			       io_filesfrom_buflen? &w_fds : NULL,
+			       NULL, &tv);
 
 		if (count == 0) {
 			check_timeout();
 		}
 
 		if (count <= 0) {
 			if (errno == EBADF) {
 				exit_cleanup(RERR_SOCKETIO);
 			}
 			continue;
 		}
 
-		if (io_error_fd != -1 && FD_ISSET(io_error_fd, &fds)) {
+		if (io_error_fd != -1 && FD_ISSET(io_error_fd, &r_fds)) {
 			read_error_fd();
 		}
 
-		if (!FD_ISSET(fd, &fds)) continue;
+		if (io_filesfrom_f_out != -1) {
+			if (io_filesfrom_buflen) {
+				if (FD_ISSET(io_filesfrom_f_out, &w_fds)) {
+					int l = write(io_filesfrom_f_out,
+						      io_filesfrom_bp,
+						      io_filesfrom_buflen);
+					if (l > 0) {
+						if (!(io_filesfrom_buflen -= l))
+							io_filesfrom_bp = io_filesfrom_buf;
+						else
+							io_filesfrom_bp += l;
+					} else {
+						/* XXX should we complain? */
+						io_filesfrom_f_out = -1;
+					}
+				}
+			} else if (io_filesfrom_f_in != -1) {
+				if (FD_ISSET(io_filesfrom_f_in, &r_fds)) {
+					int l = read(io_filesfrom_f_in,
+						     io_filesfrom_buf,
+						     sizeof io_filesfrom_buf);
+					if (l <= 0) {
+						/* Send end-of-file marker */
+						io_filesfrom_buf[0] = '\0';
+						io_filesfrom_buf[1] = '\0';
+						io_filesfrom_buflen = io_filesfrom_lastchar? 2 : 1;
+						io_filesfrom_f_in = -1;
+					} else {
+						extern int eol_nulls;
+						if (!eol_nulls) {
+							char *s = io_filesfrom_buf + l;
+							/* Transform CR and/or LF into '\0' */
+							while (s-- > io_filesfrom_buf) {
+								if (*s == '\n' || *s == '\r')
+									*s = '\0';
+							}
+						}
+						if (!io_filesfrom_lastchar) {
+							/* Last buf ended with a '\0', so don't
+							 * let this buf start with one. */
+							while (l && !*io_filesfrom_bp)
+								io_filesfrom_bp++, l--;
+						}
+						if (!l)
+							io_filesfrom_bp = io_filesfrom_buf;
+						else {
+							char *f = io_filesfrom_bp;
+							char *t = f;
+							char *eob = f + l;
+							/* Eliminate any multi-'\0' runs. */
+							while (f != eob) {
+								if (!(*t++ = *f++)) {
+									while (f != eob && !*f)
+										f++, l--;
+								}
+							}
+							io_filesfrom_lastchar = f[-1];
+						}
+						io_filesfrom_buflen = l;
+					}
+				}
+			}
+		}
+
+		if (!FD_ISSET(fd, &r_fds)) continue;
 
 		n = read(fd, buf, len);
 
 		if (n > 0) {
 			buf += n;
 			len -= n;
 			ret += n;
 			if (io_timeout)
 				last_io = time(NULL);
 			continue;
 		} else if (n == 0) {
-			whine_about_eof ();
+			whine_about_eof();
 			return -1; /* doesn't return */
 		} else if (n == -1) {
 			if (errno == EINTR || errno == EWOULDBLOCK ||
 			    errno == EAGAIN) 
 				continue;
-			else
-				die_from_readerr (errno);
+			die_from_readerr(errno);
 		}
 	}
 
 	return ret;
 }
 
+/**
+ * Read a line into the "fname" buffer (which must be at least MAXPATHLEN
+ * characters long).
+ */
+int read_filesfrom_line(int fd, char *fname)
+{
+	char ch, *s, *eob = fname + MAXPATHLEN - 1;
+	int cnt;
+	extern int io_timeout;
+	extern int eol_nulls;
+	extern char *remote_filesfrom_file;
+	int reading_remotely = remote_filesfrom_file != NULL;
+	int nulls = eol_nulls || reading_remotely;
+
+  start:
+	s = fname;
+	while (1) {
+		cnt = read(fd, &ch, 1);
+		if (cnt < 0 && (errno == EWOULDBLOCK
+		  || errno == EINTR || errno == EAGAIN)) {
+			struct timeval tv;
+			fd_set fds;
+			FD_ZERO(&fds);
+			FD_SET(fd, &fds);
+			tv.tv_sec = io_timeout? io_timeout : SELECT_TIMEOUT;
+			tv.tv_usec = 0;
+			if (!select(fd+1, &fds, NULL, NULL, &tv))
+				check_timeout();
+			continue;
+		}
+		if (cnt != 1)
+			break;
+		if (nulls? !ch : (ch == '\r' || ch == '\n')) {
+			/* Skip empty lines if reading locally. */
+			if (!reading_remotely && s == fname)
+				continue;
+			break;
+		}
+		if (s < eob)
+			*s++ = ch;
+	}
+	*s = '\0';
 
+	/* Dump comments. */
+	if (*fname == '#' || *fname == ';')
+		goto start;
+
+	return s - fname;
+}
 
 
 /**
  * Continue trying to read len bytes - don't return until len has been
  * read.
  **/
-static void read_loop (int fd, char *buf, size_t len)
+static void read_loop(int fd, char *buf, size_t len)
 {
 	while (len) {
 		int n = read_timeout(fd, buf, len);
 
 		buf += n;
 		len -= n;
@@ -312,15 +466,15 @@
 
 		if (tag != FERROR && tag != FINFO) {
 			rprintf(FERROR, "unexpected tag %d\n", tag);
 			exit_cleanup(RERR_STREAMIO);
 		}
 
-		if (remaining > sizeof(line) - 1) {
-			rprintf(FERROR, "multiplexing overflow %d\n\n",
-				remaining);
+		if (remaining > sizeof line - 1) {
+			rprintf(FERROR, "multiplexing overflow %ld\n\n",
+				(long)remaining);
 			exit_cleanup(RERR_STREAMIO);
 		}
 
 		read_loop(fd, line, remaining);
 		line[remaining] = 0;
 
@@ -335,21 +489,21 @@
 
 /**
  * Do a buffered read from @p fd.  Don't return until all @p n bytes
  * have been read.  If all @p n can't be read then exit with an
  * error.
  **/
-static void readfd (int fd, char *buffer, size_t N)
+static void readfd(int fd, char *buffer, size_t N)
 {
 	int  ret;
 	size_t total=0;  
-	
+
 	while (total < N) {
 		io_flush();
 
-		ret = read_unbuffered (fd, buffer + total, N-total);
+		ret = read_unbuffered(fd, buffer + total, N-total);
 		total += ret;
 	}
 
 	stats.total_read += total;
 }
 
@@ -364,49 +518,46 @@
 	if (ret == (int32)0xffffffff) return -1;
 	return ret;
 }
 
 int64 read_longint(int f)
 {
-	extern int remote_version;
 	int64 ret;
 	char b[8];
 	ret = read_int(f);
 
 	if ((int32)ret != (int32)0xffffffff) {
 		return ret;
 	}
 
 #ifdef NO_INT64
 	rprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
 	exit_cleanup(RERR_UNSUPPORTED);
 #else
-	if (remote_version >= 16) {
-		readfd(f,b,8);
-		ret = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
-	}
+	readfd(f,b,8);
+	ret = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
 #endif
 
 	return ret;
 }
 
 void read_buf(int f,char *buf,size_t len)
 {
 	readfd(f,buf,len);
 }
 
 void read_sbuf(int f,char *buf,size_t len)
 {
-	read_buf (f,buf,len);
+	read_buf(f,buf,len);
 	buf[len] = 0;
 }
 
 unsigned char read_byte(int f)
 {
 	unsigned char c;
-	read_buf (f, (char *)&c, 1);
+	read_buf(f, (char *)&c, 1);
 	return c;
 }
 
 
 /**
  * Sleep after writing to limit I/O bandwidth usage.
@@ -423,13 +574,13 @@
 
 	if (!bwlimit)
 		return;
 
 	assert(bytes_written > 0);
 	assert(bwlimit > 0);
-	
+
 	tv.tv_usec = bytes_written * 1000 / bwlimit;
 	tv.tv_sec  = tv.tv_usec / 1000000;
 	tv.tv_usec = tv.tv_usec % 1000000;
 
 	select(0, NULL, NULL, NULL, &tv);
 }
@@ -451,17 +602,17 @@
 	err_list_push();
 
 	no_flush++;
 
 	while (total < len) {
 		FD_ZERO(&w_fds);
-		FD_ZERO(&r_fds);
 		FD_SET(fd,&w_fds);
 		fd_count = fd;
 
 		if (io_error_fd != -1) {
+			FD_ZERO(&r_fds);
 			FD_SET(io_error_fd,&r_fds);
 			if (io_error_fd > fd_count) 
 				fd_count = io_error_fd;
 		}
 
 		tv.tv_sec = io_timeout?io_timeout:SELECT_TIMEOUT;
@@ -548,14 +699,14 @@
 {
 	char buffer[4096];
 	size_t n = len;
 
 	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
 
-	if (n > (sizeof(buffer)-4)) {
-		n = sizeof(buffer)-4;
+	if (n > (sizeof buffer - 4)) {
+		n = sizeof buffer - 4;
 	}
 
 	memcpy(&buffer[4], buf, n);
 	writefd_unbuffered(fd, buffer, n+4);
 
 	len -= n;
@@ -609,13 +760,13 @@
 		if (n > 0) {
 			memcpy(io_buffer+io_buffer_count, buf, n);
 			buf += n;
 			len -= n;
 			io_buffer_count += n;
 		}
-		
+
 		if (io_buffer_count == IO_BUFFER_SIZE) io_flush();
 	}
 }
 
 
 void write_int(int f,int32 x)
@@ -637,25 +788,29 @@
 /*
  * Note: int64 may actually be a 32-bit type if ./configure couldn't find any
  * 64-bit types on this platform.
  */
 void write_longint(int f, int64 x)
 {
-	extern int remote_version;
 	char b[8];
 
-	if (remote_version < 16 || x <= 0x7FFFFFFF) {
+	if (x <= 0x7FFFFFFF) {
 		write_int(f, (int)x);
 		return;
 	}
 
+#ifdef NO_INT64
+	rprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
+	exit_cleanup(RERR_UNSUPPORTED);
+#else
 	write_int(f, (int32)0xFFFFFFFF);
 	SIVAL(b,0,(x&0xFFFFFFFF));
 	SIVAL(b,4,((x>>32)&0xFFFFFFFF));
 
 	writefd(f,b,8);
+#endif
 }
 
 void write_buf(int f,char *buf,size_t len)
 {
 	writefd(f,buf,len);
 }
@@ -707,15 +862,15 @@
 
 void io_printf(int fd, const char *format, ...)
 {
 	va_list ap;  
 	char buf[1024];
 	int len;
-	
+
 	va_start(ap, format);
-	len = vsnprintf(buf, sizeof(buf), format, ap);
+	len = vsnprintf(buf, sizeof buf, format, ap);
 	va_end(ap);
 
 	if (len < 0) exit_cleanup(RERR_STREAMIO);
 
 	write_sbuf(fd, buf);
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/lib: fnmatch.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/lib: fnmatch.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/lib/mdfour.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/mdfour.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/lib/mdfour.c	2001-06-28 13:07:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/mdfour.c	2003-09-09 23:58:48.000000000 +0800
@@ -106,56 +106,83 @@
 {
 	md->A = 0x67452301;
 	md->B = 0xefcdab89;
 	md->C = 0x98badcfe;
 	md->D = 0x10325476;
 	md->totalN = 0;
+	md->totalN2 = 0;
 }
 
 
-static void mdfour_tail(unsigned char *in, int n)
+static void mdfour_tail(unsigned char *in, uint32 n)
 {
 	unsigned char buf[128];
 	uint32 M[16];
-	uint32 b;
+	extern int protocol_version;
 
-	m->totalN += n;
-
-	b = m->totalN * 8;
+	/*
+	 * Count total number of bits, modulo 2^64
+	 */
+	m->totalN += n << 3;
+	if (m->totalN < (n << 3)) {
+		m->totalN2++;
+	}
+	m->totalN2 += n >> 29;
 
 	memset(buf, 0, 128);
 	if (n) memcpy(buf, in, n);
 	buf[n] = 0x80;
 
 	if (n <= 55) {
-		copy4(buf+56, b);
+		copy4(buf+56, m->totalN);
+		/*
+		 * Prior to protocol version 27 only the number of bits
+		 * modulo 2^32 was included.  MD4 requires the number
+		 * of bits modulo 2^64, which was fixed starting with
+		 * protocol version 27.
+		 */
+		if (protocol_version >= 27) {
+			copy4(buf+60, m->totalN2);
+		}
 		copy64(M, buf);
 		mdfour64(M);
 	} else {
-		copy4(buf+120, b); 
+		copy4(buf+120, m->totalN); 
+		/*
+		 * Prior to protocol version 27 only the number of bits
+		 * modulo 2^32 was included.  MD4 requires the number
+		 * of bits modulo 2^64, which was fixed starting with
+		 * protocol version 27.
+		 */
+		if (protocol_version >= 27) {
+			copy4(buf+124, m->totalN2); 
+		}
 		copy64(M, buf);
 		mdfour64(M);
 		copy64(M, buf+64);
 		mdfour64(M);
 	}
 }
 
-void mdfour_update(struct mdfour *md, unsigned char *in, int n)
+void mdfour_update(struct mdfour *md, unsigned char *in, uint32 n)
 {
 	uint32 M[16];
 
-	if (n == 0) mdfour_tail(in, n);
-
 	m = md;
 
+	if (n == 0) mdfour_tail(in, n);
+
 	while (n >= 64) {
 		copy64(M, in);
 		mdfour64(M);
 		in += 64;
 		n -= 64;
-		m->totalN += 64;
+		m->totalN += 64 << 3;
+		if (m->totalN < 64 << 3) {
+			m->totalN2++;
+		}
 	}
 
 	if (n) mdfour_tail(in, n);
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/lib/mdfour.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/mdfour.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/lib/mdfour.h	1998-10-29 13:01:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/mdfour.h	2003-04-10 09:50:12.000000000 +0800
@@ -18,17 +18,18 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 struct mdfour {
 	uint32 A, B, C, D;
-	uint32 totalN;
+	uint32 totalN;          /* bit count, lower 32 bits */
+	uint32 totalN2;         /* bit count, upper 32 bits */
 };
 
 void mdfour_begin(struct mdfour *md);
-void mdfour_update(struct mdfour *md, unsigned char *in, int n);
+void mdfour_update(struct mdfour *md, unsigned char *in, uint32 n);
 void mdfour_result(struct mdfour *md, unsigned char *out);
 void mdfour(unsigned char *out, unsigned char *in, int n);
 
 
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/lib/snprintf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/snprintf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/lib/snprintf.c	2001-05-07 14:59:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/snprintf.c	2003-07-04 23:36:39.000000000 +0800
@@ -50,12 +50,15 @@
  *    added test for HAVE_LONG_DOUBLE
  *
  * tridge@samba.org, idra@samba.org, April 2001
  *    got rid of fcvt code (twas buggy and made testing harder)
  *    added C99 semantics
  *
+ *  Paul Green (paulg@samba.org) April 9, 2003
+ *    fixed handling of %f when converting fractions with leading zeros.
+ *    (e.g., 0.025).
  **************************************************************/
 
 #ifndef NO_CONFIG_H /* for some tests */
 #include "config.h"
 #endif
 
@@ -722,21 +725,21 @@
 	 * Decimal point.  This should probably use locale to find the correct
 	 * char to print out.
 	 */
 	if (max > 0) {
 		dopr_outch (buffer, currlen, maxlen, '.');
 		
+		while (zpadlen > 0) {
+		  dopr_outch (buffer, currlen, maxlen, '0');
+		  --zpadlen;
+		}
+
 		while (fplace > 0) 
 			dopr_outch (buffer, currlen, maxlen, fconvert[--fplace]);
 	}
 	
-	while (zpadlen > 0) {
-		dopr_outch (buffer, currlen, maxlen, '0');
-		--zpadlen;
-	}
-
 	while (padlen < 0) {
 		dopr_outch (buffer, currlen, maxlen, ' ');
 		++padlen;
 	}
 }
 
@@ -746,19 +749,21 @@
 		buffer[(*currlen)] = c;
 	}
 	(*currlen)++;
 }
 
 #if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
- int vsnprintf (char *str, size_t count, const char *fmt, va_list args)
+#define vsnprintf rsync_vsnprintf
+ int vsnprintf(char *str, size_t count, const char *fmt, va_list args)
 {
 	return dopr(str, count, fmt, args);
 }
 #endif
 
 #if !defined(HAVE_SNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
+#define snprintf rsync_snprintf
  int snprintf(char *str,size_t count,const char *fmt,...)
 {
 	size_t ret;
 	va_list ap;
     
 	va_start(ap, fmt);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib: wildmatch.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib: wildmatch.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/loadparm.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/loadparm.c	2003-12-07 05:07:27.000000000 +0800
@@ -3,23 +3,23 @@
 
 /* some fixes
  *
  * Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
  */
 
-/* 
+/*
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /*
@@ -33,13 +33,13 @@
  *
  * 1) add it to the global or service structure definition
  * 2) add it to the parm_table
  * 3) add it to the list of available functions (eg: using FN_GLOBAL_STRING())
  * 4) If it's a global then initialise it in init_globals. If a local
  *    (ie. service) parameter then initialise it in the sDefault structure
- *  
+ *
  *
  * Notes:
  *   The configuration file is processed sequentially for speed. It is NOT
  *   accessed randomly as happens in 'real' Windows. For this reason, there
  *   is a fair bit of sequence-dependent code here - ie., code which assumes
  *   that certain things happen before others. In particular, the code which
@@ -58,13 +58,13 @@
 #define pstrcpy(a,b) strlcpy(a,b,sizeof(pstring))
 
 /* the following are used by loadparm for option lists */
 typedef enum
 {
 	P_BOOL,P_BOOLREV,P_CHAR,P_INTEGER,P_OCTAL,
-	P_STRING,P_GSTRING,P_ENUM,P_SEP
+	P_PATH,P_STRING,P_GSTRING,P_ENUM,P_SEP
 } parm_type;
 
 typedef enum
 {
 	P_LOCAL,P_GLOBAL,P_SEPARATOR,P_NONE
 } parm_class;
@@ -90,13 +90,13 @@
 
 /* some helpful bits */
 #define pSERVICE(i) ServicePtrs[i]
 #define iSERVICE(i) (*pSERVICE(i))
 #define LP_SNUM_OK(iService) (((iService) >= 0) && ((iService) < iNumServices))
 
-/* 
+/*
  * This structure describes global (ie., server-wide) parameters.
  */
 typedef struct
 {
 	char *motd_file;
 	char *log_file;
@@ -106,14 +106,14 @@
 } global;
 
 static global Globals;
 
 
 
-/* 
- * This structure describes a single service. 
+/*
+ * This structure describes a single service.
  */
 typedef struct
 {
 	char *name;
 	char *path;
 	char *comment;
@@ -141,34 +141,34 @@
 	int max_connections;
 	BOOL ignore_nonreadable;
 } service;
 
 
 /* This is a default service used to prime a services structure */
-static service sDefault = 
+static service sDefault =
 {
 	NULL,    /* name */
 	NULL,    /* path */
 	NULL,    /* comment */
 	DEFAULT_LOCK_FILE,    /* lock file */
 	True,    /* read only */
 	True,    /* list */
 	True,    /* use chroot */
 	False,   /* transfer logging */
 	False,   /* ignore errors */
 	"nobody",/* uid */
-	
+
 	/* TODO: This causes problems on Debian, where it is called
 	 * "nogroup".  Debian patch this in their version of the
 	 * package, but it would be nice to be consistent.  Possibly
 	 * other systems are different again.
 	 *
 	 * What is the best behaviour?  Perhaps always using (gid_t)
 	 * -2? */
 	"nobody",/* gid */
-	
+
 	NULL,    /* hosts allow */
 	NULL,    /* hosts deny */
 	NULL,    /* auth users */
 	NULL,    /* secrets file */
 	True,   /* strict modes */
 	NULL,    /* exclude */
@@ -219,13 +219,13 @@
 	{ LOG_MAIL, "mail" },
 #endif
 #ifdef LOG_NEWS
 	{ LOG_NEWS, "news" },
 #endif
 #ifdef LOG_AUTH
-	{ LOG_AUTH, "security" },		
+	{ LOG_AUTH, "security" },
 #endif
 #ifdef LOG_SYSLOG
 	{ LOG_SYSLOG, "syslog" },
 #endif
 #ifdef LOG_USER
 	{ LOG_USER, "user" },
@@ -271,13 +271,13 @@
 
   {"timeout",          P_INTEGER, P_LOCAL,  &sDefault.timeout,     NULL,  0},
   {"max connections",  P_INTEGER, P_LOCAL,  &sDefault.max_connections,NULL, 0},
   {"name",             P_STRING,  P_LOCAL,  &sDefault.name,        NULL,   0},
   {"comment",          P_STRING,  P_LOCAL,  &sDefault.comment,     NULL,   0},
   {"lock file",        P_STRING,  P_LOCAL,  &sDefault.lock_file,   NULL,   0},
-  {"path",             P_STRING,  P_LOCAL,  &sDefault.path,        NULL,   0},
+  {"path",             P_PATH,    P_LOCAL,  &sDefault.path,        NULL,   0},
   {"read only",        P_BOOL,    P_LOCAL,  &sDefault.read_only,   NULL,   0},
   {"list",             P_BOOL,    P_LOCAL,  &sDefault.list,        NULL,   0},
   {"use chroot",       P_BOOL,    P_LOCAL,  &sDefault.use_chroot,  NULL,   0},
   {"ignore nonreadable",P_BOOL,   P_LOCAL,  &sDefault.ignore_nonreadable,  NULL,   0},
   {"uid",              P_STRING,  P_LOCAL,  &sDefault.uid,         NULL,   0},
   {"gid",              P_STRING,  P_LOCAL,  &sDefault.gid,         NULL,   0},
@@ -316,14 +316,14 @@
 static void init_locals(void)
 {
 }
 
 
 /*
-   In this section all the functions that are used to access the 
-   parameters from the rest of the program are defined 
+   In this section all the functions that are used to access the
+   parameters from the rest of the program are defined
 */
 
 #define FN_GLOBAL_STRING(fn_name,ptr) \
  char *fn_name(void) {return(*(char **)(ptr) ? *(char **)(ptr) : "");}
 #define FN_GLOBAL_BOOL(fn_name,ptr) \
  BOOL fn_name(void) {return(*(BOOL *)(ptr));}
@@ -373,18 +373,17 @@
 FN_LOCAL_STRING(lp_refuse_options, refuse_options)
 FN_LOCAL_STRING(lp_dont_compress, dont_compress)
 FN_LOCAL_INTEGER(lp_timeout, timeout)
 FN_LOCAL_INTEGER(lp_max_connections, max_connections)
 
 /* local prototypes */
-static int    strwicmp( char *psz1, char *psz2 );
-static int    map_parameter( char *parmname);
-static BOOL   set_boolean( BOOL *pb, char *parmvalue );
+static int    strwicmp(char *psz1, char *psz2);
+static int    map_parameter(char *parmname);
+static BOOL   set_boolean(BOOL *pb, char *parmvalue);
 static int    getservicebyname(char *name, service *pserviceDest);
-static void   copy_service( service *pserviceDest, 
-                            service *pserviceSource);
+static void   copy_service(service *pserviceDest, service *pserviceSource);
 static BOOL   do_parameter(char *parmname, char *parmvalue);
 static BOOL   do_section(char *sectionname);
 
 
 /***************************************************************************
 initialise a service to the defaults
@@ -418,25 +417,25 @@
 	if (!*s)
 		exit_cleanup(RERR_MALLOC);
 }
 
 
 /***************************************************************************
-add a new service to the services array initialising it with the given 
+add a new service to the services array initialising it with the given
 service
 ***************************************************************************/
 static int add_a_service(service *pservice, char *name)
 {
   int i;
   service tservice;
   int num_to_alloc = iNumServices+1;
 
   tservice = *pservice;
 
   /* it might already exist */
-  if (name) 
+  if (name)
     {
       i = getservicebyname(name,NULL);
       if (i >= 0)
 	return(i);
     }
 
@@ -452,13 +451,13 @@
 
   iNumServices++;
 
   init_service(pSERVICE(i));
   copy_service(pSERVICE(i),&tservice);
   if (name)
-    string_set(&iSERVICE(i).name,name);  
+    string_set(&iSERVICE(i).name,name);
 
   return(i);
 }
 
 /***************************************************************************
 Do a case-insensitive, whitespace-ignoring string compare.
@@ -490,34 +489,34 @@
       psz2++;
    }
    return (*psz1 - *psz2);
 }
 
 /***************************************************************************
-Map a parameter's string representation to something we can use. 
+Map a parameter's string representation to something we can use.
 Returns False if the parameter string is not recognised, else TRUE.
 ***************************************************************************/
 static int map_parameter(char *parmname)
 {
    int iIndex;
 
    if (*parmname == '-')
      return(-1);
 
-   for (iIndex = 0; parm_table[iIndex].label; iIndex++) 
+   for (iIndex = 0; parm_table[iIndex].label; iIndex++)
       if (strwicmp(parm_table[iIndex].label, parmname) == 0)
          return(iIndex);
 
    rprintf(FERROR, "Unknown Parameter encountered: \"%s\"\n", parmname);
    return(-1);
 }
 
 
 /***************************************************************************
 Set a boolean variable from the text value stored in the passed string.
-Returns True in success, False if the passed string does not correctly 
+Returns True in success, False if the passed string does not correctly
 represent a boolean.
 ***************************************************************************/
 static BOOL set_boolean(BOOL *pb, char *parmvalue)
 {
    BOOL bRetval;
 
@@ -545,13 +544,13 @@
 ***************************************************************************/
 static int getservicebyname(char *name, service *pserviceDest)
 {
    int iService;
 
    for (iService = iNumServices - 1; iService >= 0; iService--)
-      if (strwicmp(iSERVICE(iService).name, name) == 0) 
+      if (strwicmp(iSERVICE(iService).name, name) == 0)
       {
          if (pserviceDest != NULL)
 	   copy_service(pserviceDest, pSERVICE(iService));
          break;
       }
 
@@ -561,23 +560,23 @@
 
 
 /***************************************************************************
 Copy a service structure to another
 
 ***************************************************************************/
-static void copy_service(service *pserviceDest, 
+static void copy_service(service *pserviceDest,
                          service *pserviceSource)
 {
   int i;
 
   for (i=0;parm_table[i].label;i++)
     if (parm_table[i].ptr && parm_table[i].class == P_LOCAL) {
 	void *def_ptr = parm_table[i].ptr;
-	void *src_ptr = 
+	void *src_ptr =
 	  ((char *)pserviceSource) + PTR_DIFF(def_ptr,&sDefault);
-	void *dest_ptr = 
+	void *dest_ptr =
 	  ((char *)pserviceDest) + PTR_DIFF(def_ptr,&sDefault);
 
 	switch (parm_table[i].type)
 	  {
 	  case P_BOOL:
 	  case P_BOOLREV:
@@ -591,12 +590,13 @@
 	    break;
 
 	  case P_CHAR:
 	    *(char *)dest_ptr = *(char *)src_ptr;
 	    break;
 
+	  case P_PATH:
 	  case P_STRING:
 	    string_set(dest_ptr,*(char **)src_ptr);
 	    break;
 
 	  default:
 	    break;
@@ -611,12 +611,13 @@
 ***************************************************************************/
 static BOOL lp_do_parameter(int snum, char *parmname, char *parmvalue)
 {
    int parmnum, i;
    void *parm_ptr=NULL; /* where we are going to store the result */
    void *def_ptr=NULL;
+   char *cp;
 
    parmnum = map_parameter(parmname);
 
    if (parmnum < 0)
      {
        rprintf(FERROR, "IGNORING unknown parameter \"%s\"\n", parmname);
@@ -657,12 +658,21 @@
        break;
 
      case P_OCTAL:
        sscanf(parmvalue,"%o",(int *)parm_ptr);
        break;
 
+     case P_PATH:
+       string_set(parm_ptr,parmvalue);
+       if ((cp = *(char**)parm_ptr) != NULL) {
+	   int len = strlen(cp);
+	   while (len > 1 && cp[len-1] == '/') len--;
+	   cp[len] = '\0';
+       }
+       break;
+
      case P_STRING:
        string_set(parm_ptr,parmvalue);
        break;
 
      case P_GSTRING:
        strlcpy((char *)parm_ptr,parmvalue,sizeof(pstring));
@@ -708,13 +718,13 @@
 
    /* if we were in a global section then do the local inits */
    if (bInGlobalSection && !isglobal)
      init_locals();
 
    /* if we've just struck a global section, note the fact. */
-   bInGlobalSection = isglobal;   
+   bInGlobalSection = isglobal;
 
    /* check for multiple global sections */
    if (bInGlobalSection)
    {
      return(True);
    }
@@ -740,40 +750,40 @@
 
    return (bRetval);
 }
 
 
 /***************************************************************************
-Load the services array from the services file. Return True on success, 
+Load the services array from the services file. Return True on success,
 False on failure.
 ***************************************************************************/
 BOOL lp_load(char *pszFname, int globals_only)
 {
 	extern int am_server;
 	extern int am_daemon;
 	extern int am_root;
 	pstring n2;
 	BOOL bRetval;
- 
+
 	bRetval = False;
 
 	bInGlobalSection = True;
-  
+
 	init_globals();
 
 	if (pszFname)
 	    pstrcpy(n2,pszFname);
 	else if (am_server && am_daemon && !am_root)
 	    pstrcpy(n2,RSYNCD_USERCONF);
 	else
 	    pstrcpy(n2,RSYNCD_SYSCONF);
 
 	/* We get sections first, so have to start 'behind' to make up */
 	iServiceIndex = -1;
 	bRetval = pm_process(n2, globals_only?NULL:do_section, do_parameter);
-  
+
 	return (bRetval);
 }
 
 
 /***************************************************************************
 return the max number of services
@@ -791,12 +801,12 @@
 ***************************************************************************/
 int lp_number(char *name)
 {
    int iService;
 
    for (iService = iNumServices - 1; iService >= 0; iService--)
-      if (strequal(lp_name(iService), name)) 
+      if (strequal(lp_name(iService), name))
          break;
 
    return (iService);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/log.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/log.c	2003-12-15 16:06:52.000000000 +0800
@@ -1,21 +1,21 @@
 /* -*- c-file-style: "linux"; -*-
-   
+
    Copyright (C) 1998-2001 by Andrew Tridgell <tridge@samba.org>
    Copyright (C) 2000-2001 by Martin Pool <mbp@samba.org>
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /*
@@ -36,27 +36,28 @@
 int log_got_error=0;
 
 struct {
         int code;
         char const *name;
 } const rerr_names[] = {
-	{ RERR_SYNTAX     , "syntax or usage error" }, 
-	{ RERR_PROTOCOL   , "protocol incompatibility" }, 
-	{ RERR_FILESELECT , "errors selecting input/output files, dirs" }, 
-	{ RERR_UNSUPPORTED, "requested action not supported" }, 
-	{ RERR_STARTCLIENT, "error starting client-server protocol" }, 
-	{ RERR_SOCKETIO   , "error in socket IO" }, 
-	{ RERR_FILEIO     , "error in file IO" }, 
-	{ RERR_STREAMIO   , "error in rsync protocol data stream" }, 
-	{ RERR_MESSAGEIO  , "errors with program diagnostics" }, 
-	{ RERR_IPC        , "error in IPC code" }, 
-	{ RERR_SIGNAL     , "received SIGUSR1 or SIGINT" }, 
-	{ RERR_WAITCHILD  , "some error returned by waitpid()" }, 
-	{ RERR_MALLOC     , "error allocating core memory buffers" }, 
-	{ RERR_PARTIAL    , "some files could not be transferred" }, 
-	{ RERR_TIMEOUT    , "timeout in data send/receive" }, 
+	{ RERR_SYNTAX     , "syntax or usage error" },
+	{ RERR_PROTOCOL   , "protocol incompatibility" },
+	{ RERR_FILESELECT , "errors selecting input/output files, dirs" },
+	{ RERR_UNSUPPORTED, "requested action not supported" },
+	{ RERR_STARTCLIENT, "error starting client-server protocol" },
+	{ RERR_SOCKETIO   , "error in socket IO" },
+	{ RERR_FILEIO     , "error in file IO" },
+	{ RERR_STREAMIO   , "error in rsync protocol data stream" },
+	{ RERR_MESSAGEIO  , "errors with program diagnostics" },
+	{ RERR_IPC        , "error in IPC code" },
+	{ RERR_SIGNAL     , "received SIGUSR1 or SIGINT" },
+	{ RERR_WAITCHILD  , "some error returned by waitpid()" },
+	{ RERR_MALLOC     , "error allocating core memory buffers" },
+	{ RERR_PARTIAL    , "some files could not be transferred" },
+	{ RERR_VANISHED   , "some files vanished before they could be transfered" },
+	{ RERR_TIMEOUT    , "timeout in data send/receive" },
 	{ RERR_CMD_FAILED , "remote shell failed" },
 	{ RERR_CMD_KILLED , "remote shell killed" },
 	{ RERR_CMD_RUN,     "remote command could not be run" },
         { RERR_CMD_NOTFOUND, "remote command not found" },
         { 0, NULL }
 };
@@ -114,13 +115,13 @@
 	if (log_error_fd == -1) return;
 
 	while (err_list_head) {
 		struct err_list *el = err_list_head;
 		int n = write(log_error_fd, el->buf+el->written, el->len - el->written);
 		/* don't check for an error if the best way of handling the error is
-		   to ignore it */
+		 * to ignore it */
 		if (n == -1) break;
 		if (n > 0) {
 			el->written += n;
 		}
 		if (el->written == el->len) {
 			free(el->buf);
@@ -134,13 +135,13 @@
 
 static void logit(int priority, char *buf)
 {
 	if (logfname) {
 		if (!logfile)
 			log_open();
-		fprintf(logfile,"%s [%d] %s", 
+		fprintf(logfile,"%s [%d] %s",
 			timestring(time(NULL)), (int)getpid(), buf);
 		fflush(logfile);
 	} else {
 		syslog(priority, "%s", buf);
 	}
 }
@@ -151,14 +152,14 @@
 	time_t t;
 
 	if (log_initialised) return;
 	log_initialised = 1;
 
 	/* this looks pointless, but it is needed in order for the
-	   C library on some systems to fetch the timezone info
-	   before the chroot */
+	 * C library on some systems to fetch the timezone info
+	 * before the chroot */
 	t = time(NULL);
 	localtime(&t);
 
 	/* optionally use a log file instead of syslog */
 	logfname = lp_log_file();
 	if (logfname) {
@@ -200,21 +201,21 @@
 		fclose(logfile);
 		logfile = NULL;
 	}
 }
 
 /* setup the error file descriptor - used when we are a server
-   that is receiving files */
+ * that is receiving files */
 void set_error_fd(int fd)
 {
 	log_error_fd = fd;
 	set_nonblocking(log_error_fd);
 }
 
 /* this is the underlying (unformatted) rsync debugging function. Call
-   it with FINFO, FERROR or FLOG */
+ * it with FINFO, FERROR or FLOG */
 void rwrite(enum logcode code, char *buf, int len)
 {
 	FILE *f=NULL;
 	extern int am_daemon;
 	extern int am_server;
 	extern int quiet;
@@ -235,25 +236,27 @@
 	if (am_server && log_error_fd != -1) {
 		err_list_add(code, buf, len);
 		err_list_push();
 		return;
 	}
 
-	/* next, if we are a server but not in daemon mode, and multiplexing
-	 *  is enabled, pass it to the other side.  */
-	if (am_server && !am_daemon && io_multiplex_write(code, buf, len)) {
+	/* next, if we are a server and multiplexing is enabled,
+	 * pass it to the other side.  */
+	if (am_server && io_multiplex_write(code, buf, len)) {
 		return;
 	}
 
 	/* otherwise, if in daemon mode and either we are not a server
 	 *  (that is, we are not running --daemon over a remote shell) or
 	 *  the log has already been initialised, log the message on this
 	 *  side because we don't want the client to see most errors for
 	 *  security reasons.  We do want early messages when running daemon
 	 *  mode over a remote shell to go to the remote side; those will
-	 *  fall through to the next case. */
+	 *  fall through to the next case.
+	 * Note that this is only for the time before multiplexing is enabled.
+	 */
 	if (am_daemon && (!am_server || log_initialised)) {
 		static int depth;
 		int priority = LOG_INFO;
 		if (code == FERROR) priority = LOG_WARNING;
 
 		if (depth) return;
@@ -267,20 +270,20 @@
 		return;
 	}
 
 	if (code == FERROR) {
 		log_got_error = 1;
 		f = stderr;
-	} 
+	}
 
 	if (code == FINFO) {
-		if (am_server) 
+		if (am_server)
 			f = stderr;
 		else
 			f = stdout;
-	} 
+	}
 
 	if (!f) exit_cleanup(RERR_MESSAGEIO);
 
 	if (fwrite(buf, len, 1, f) != 1) exit_cleanup(RERR_MESSAGEIO);
 
 	if (buf[len-1] == '\r' || buf[len-1] == '\n') fflush(f);
@@ -288,13 +291,13 @@
 		
 
 /* This is the rsync debugging function. Call it with FINFO, FERROR or
  * FLOG. */
 void rprintf(enum logcode code, const char *format, ...)
 {
-	va_list ap;  
+	va_list ap;
 	char buf[1024];
 	int len;
 
 	va_start(ap, format);
 	/* Note: might return -1 */
 	len = vsnprintf(buf, sizeof(buf), format, ap);
@@ -337,13 +340,13 @@
  * one in the format string.
  *
  * Note that since strerror might involve dynamically loading a
  * message catalog we need to call it once before chroot-ing. */
 void rsyserr(enum logcode code, int errcode, const char *format, ...)
 {
-	va_list ap;  
+	va_list ap;
 	char buf[1024];
 	int len;
 	size_t sys_len;
         char *sysmsg;
 
 	va_start(ap, format);
@@ -381,34 +384,34 @@
 	if (am_daemon) {
 		return;
 	}
 
 	if (code == FLOG) {
 		return;
-	} 
+	}
 
 	if (code == FERROR) {
 		f = stderr;
-	} 
+	}
 
 	if (code == FINFO) {
 		extern int am_server;
-		if (am_server) 
+		if (am_server)
 			f = stderr;
 		else
 			f = stdout;
-	} 
+	}
 
 	if (!f) exit_cleanup(RERR_MESSAGEIO);
 	fflush(f);
 }
 
 
 
 /* a generic logging routine for send/recv, with parameter
-   substitiution */
+ * substitiution */
 static void log_formatted(enum logcode code,
 			  char *format, char *op, struct file_struct *file,
 			  struct stats *initial_stats)
 {
 	extern int module_id;
 	extern char *auth_user;
@@ -426,63 +429,62 @@
 	 * rather keep going until we reach the nul of the format.
 	 * Just to make sure we don't clobber that nul and therefore
 	 * accidentally keep going, we zero the buffer now. */
 	memset(buf, 0, sizeof buf);
 	strlcpy(buf, format, sizeof(buf));
 	
-	for (s=&buf[0]; 
-	     s && (p=strchr(s,'%')); ) {
+	for (s = &buf[0]; s && (p = strchr(s,'%')); ) {
 		n = NULL;
 		s = p + 1;
 
 		switch (p[1]) {
 		case 'h': if (am_daemon) n = client_name(0); break;
 		case 'a': if (am_daemon) n = client_addr(0); break;
-		case 'l': 
-			snprintf(buf2,sizeof(buf2),"%.0f", 
-				 (double)file->length); 
+		case 'l':
+			snprintf(buf2,sizeof(buf2),"%.0f",
+				 (double)file->length);
 			n = buf2;
 			break;
-		case 'p': 
-			snprintf(buf2,sizeof(buf2),"%d", 
-				 (int)getpid()); 
+		case 'p':
+			snprintf(buf2,sizeof(buf2),"%d",
+				 (int)getpid());
 			n = buf2;
 			break;
 		case 'o': n = op; break;
-		case 'f': 
-			snprintf(buf2, sizeof(buf2), "%s/%s", 
-				 file->basedir?file->basedir:"", 
+		case 'f':
+			snprintf(buf2, sizeof(buf2), "%s/%s",
+				 file->basedir?file->basedir:"",
 				 f_name(file));
 			clean_fname(buf2);
-			n = buf2; 
+			n = buf2;
 			if (*n == '/') n++;
 			break;
 		case 'm': n = lp_name(module_id); break;
 		case 't': n = timestring(time(NULL)); break;
 		case 'P': n = lp_path(module_id); break;
 		case 'u': n = auth_user; break;
-		case 'b': 
+		case 'b':
 			if (am_sender) {
-				b = stats.total_written - 
+				b = stats.total_written -
 					initial_stats->total_written;
 			} else {
-				b = stats.total_read - 
+				b = stats.total_read -
 					initial_stats->total_read;
 			}
-			snprintf(buf2,sizeof(buf2),"%.0f", (double)b); 
+			snprintf(buf2,sizeof(buf2),"%.0f", (double)b);
 			n = buf2;
 			break;
-		case 'c': 
+		case 'c':
 			if (!am_sender) {
-				b = stats.total_written - 
+				b = stats.total_written -
 					initial_stats->total_written;
 			} else {
-				b = stats.total_read - 
+				b = stats.total_read -
 					initial_stats->total_read;
 			}
-			snprintf(buf2,sizeof(buf2),"%.0f", (double)b); 
+			snprintf(buf2,sizeof(buf2),"%.0f", (double)b);
 			n = buf2;
 			break;
 		}
 
 		/* n is the string to be inserted in place of this %
 		 * code; l is its length not including the trailing
@@ -562,25 +564,17 @@
 	} else {
                 const char *name;
 
                 name = rerr_name(code);
                 if (!name)
                         name = "unexplained error";
-                
-		rprintf(FERROR,"rsync error: %s (code %d) at %s(%d)\n", 
-			name, code, file, line);
-	}
-}
-
-/*
- * Log the incoming transfer of a file for interactive use,
- * this will be called at the end where the client was run.
- * Called when a file starts to be transferred.
- */
-void log_transfer(struct file_struct *file, const char *fname)
-{
-	extern int verbose;
-
-	if (!verbose) return;
 
-	rprintf(FINFO, "%s\n", fname);
+		/* VANISHED is not an error, only a warning */
+		if (code == RERR_VANISHED) {
+			rprintf(FINFO, "rsync warning: %s (code %d) at %s(%d)\n", 
+				name, code, file, line);
+		} else {
+			rprintf(FERROR, "rsync error: %s (code %d) at %s(%d)\n",
+				name, code, file, line);
+		}
+	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/main.c	2003-01-28 13:05:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/main.c	2003-12-21 00:57:24.000000000 +0800
@@ -1,33 +1,40 @@
 /* -*- c-file-style: "linux" -*-
-   
+
    Copyright (C) 1996-2001 by Andrew Tridgell <tridge@samba.org>
    Copyright (C) Paul Mackerras 1996
    Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
 time_t starttime = 0;
 
 extern struct stats stats;
+extern char *files_from;
+extern int filesfrom_fd;
+extern char *remote_filesfrom_file;
+extern int am_server;
+extern int am_sender;
+extern int am_daemon;
 extern int verbose;
+extern int protocol_version;
 
 /* there's probably never more than at most 2 outstanding child processes,
  * but set it higher just in case.
  */
 #define MAXCHILDPROCS 5
 
@@ -47,13 +54,13 @@
 	int cnt;
 
 	while ((waited_pid = waitpid(pid, status, WNOHANG)) == 0) {
 		msleep(20);
 		io_flush();
 	}
-        
+
 	if ((waited_pid == -1) && (errno == ECHILD)) {
 		/* status of requested child no longer available.
 		 * check to see if it was processed by the sigchld_handler.
 		 */
 		for (cnt = 0;  cnt < MAXCHILDPROCS; cnt++) {
 			if (pid == pid_stat_table[cnt].pid) {
@@ -72,88 +79,84 @@
 	*status = WEXITSTATUS(*status);
 }
 
 static void report(int f)
 {
 	time_t t = time(NULL);
-	extern int am_server;
-	extern int am_sender;
-	extern int am_daemon;
 	extern int do_stats;
-	extern int remote_version;
 	int send_stats;
 
-	if (do_stats) {
+	if (do_stats && verbose > 1) {
 		/* These come out from every process */
 		show_malloc_stats();
 		show_flist_stats();
 	}
 
 	if (am_daemon) {
 		log_exit(0, __FILE__, __LINE__);
 		if (f == -1 || !am_sender) return;
 	}
 
-	send_stats = verbose || (remote_version >= 20);
+	send_stats = verbose || protocol_version >= 20;
 	if (am_server) {
 		if (am_sender && send_stats) {
 			int64 w;
 			/* store total_written in a temporary
-			    because write_longint changes it */
+			 * because write_longint changes it */
 			w = stats.total_written;
 			write_longint(f,stats.total_read);
 			write_longint(f,w);
 			write_longint(f,stats.total_size);
 		}
 		return;
 	}
 
 	/* this is the client */
-	    
+
 	if (!am_sender && send_stats) {
 		int64 r;
 		stats.total_written = read_longint(f);
 		/* store total_read in a temporary, read_longint changes it */
 		r = read_longint(f);
 		stats.total_size = read_longint(f);
 		stats.total_read = r;
 	}
 
 	if (do_stats) {
 		if (!am_sender && !send_stats) {
-		    /* missing the bytes written by the generator */
-		    rprintf(FINFO, "\nCannot show stats as receiver because remote protocol version is less than 20\n");
-		    rprintf(FINFO, "Use --stats -v to show stats\n");
-		    return;
+			/* missing the bytes written by the generator */
+			rprintf(FINFO, "\nCannot show stats as receiver because remote protocol version is less than 20\n");
+			rprintf(FINFO, "Use --stats -v to show stats\n");
+			return;
 		}
 		rprintf(FINFO,"\nNumber of files: %d\n", stats.num_files);
-		rprintf(FINFO,"Number of files transferred: %d\n", 
-		       stats.num_transferred_files);
-		rprintf(FINFO,"Total file size: %.0f bytes\n", 
-		       (double)stats.total_size);
-		rprintf(FINFO,"Total transferred file size: %.0f bytes\n", 
-		       (double)stats.total_transferred_size);
-		rprintf(FINFO,"Literal data: %.0f bytes\n", 
-		       (double)stats.literal_data);
-		rprintf(FINFO,"Matched data: %.0f bytes\n", 
-		       (double)stats.matched_data);
+		rprintf(FINFO,"Number of files transferred: %d\n",
+			stats.num_transferred_files);
+		rprintf(FINFO,"Total file size: %.0f bytes\n",
+			(double)stats.total_size);
+		rprintf(FINFO,"Total transferred file size: %.0f bytes\n",
+			(double)stats.total_transferred_size);
+		rprintf(FINFO,"Literal data: %.0f bytes\n",
+			(double)stats.literal_data);
+		rprintf(FINFO,"Matched data: %.0f bytes\n",
+			(double)stats.matched_data);
 		rprintf(FINFO,"File list size: %d\n", stats.flist_size);
-		rprintf(FINFO,"Total bytes written: %.0f\n", 
-		       (double)stats.total_written);
-		rprintf(FINFO,"Total bytes read: %.0f\n\n", 
-		       (double)stats.total_read);
+		rprintf(FINFO,"Total bytes written: %.0f\n",
+			(double)stats.total_written);
+		rprintf(FINFO,"Total bytes read: %.0f\n",
+			(double)stats.total_read);
 	}
-	
+
 	if (verbose || do_stats) {
-		rprintf(FINFO,"wrote %.0f bytes  read %.0f bytes  %.2f bytes/sec\n",
-		       (double)stats.total_written,
-		       (double)stats.total_read,
-		       (stats.total_written+stats.total_read)/(0.5 + (t-starttime)));
+		rprintf(FINFO,"\nwrote %.0f bytes  read %.0f bytes  %.2f bytes/sec\n",
+			(double)stats.total_written,
+			(double)stats.total_read,
+			(stats.total_written+stats.total_read)/(0.5 + (t-starttime)));
 		rprintf(FINFO,"total size is %.0f  speedup is %.2f\n",
-		       (double)stats.total_size,
-		       (1.0*stats.total_size)/(stats.total_written+stats.total_read));
+			(double)stats.total_size,
+			(1.0*stats.total_size)/(stats.total_written+stats.total_read));
 	}
 
 	fflush(stdout);
 	fflush(stderr);
 }
 
@@ -162,19 +165,16 @@
  * If our C library can get malloc statistics, then show them to FINFO
  **/
 static void show_malloc_stats(void)
 {
 #ifdef HAVE_MALLINFO
 	struct mallinfo mi;
-	extern int am_server;
-	extern int am_sender;
-	extern int am_daemon;
 
 	mi = mallinfo();
 
-	rprintf(FINFO, RSYNC_NAME "[%d] (%s%s%s) heap statistics:\n",
+	rprintf(FINFO, "\n" RSYNC_NAME "[%d] (%s%s%s) heap statistics:\n",
 		getpid(),
 		am_server ? "server " : "",
 		am_daemon ? "daemon " : "",
 		am_sender ? "sender" : "receiver");
 	rprintf(FINFO, "  arena:     %10d   (bytes from sbrk)\n", mi.arena);
 	rprintf(FINFO, "  ordblks:   %10d   (chunks not in use)\n", mi.ordblks);
@@ -202,26 +202,27 @@
 	extern char *rsync_path;
 	extern int blocking_io;
 	extern int daemon_over_rsh;
 	extern int read_batch;
 
 	if (!read_batch && !local_server) {
+		char *rsh_env = getenv(RSYNC_RSH_ENV);
 		if (!cmd)
-			cmd = getenv(RSYNC_RSH_ENV);
+			cmd = rsh_env;
 		if (!cmd)
 			cmd = RSYNC_RSH;
 		cmd = strdup(cmd);
-		if (!cmd) 
+		if (!cmd)
 			goto oom;
 
 		for (tok=strtok(cmd," ");tok;tok=strtok(NULL," ")) {
 			args[argc++] = tok;
 		}
 
-		/* check to see if we've already been given '-l user' in 
-		   the remote-shell command */
+		/* check to see if we've already been given '-l user' in
+		 * the remote-shell command */
 		for (i = 0; i < argc-1; i++) {
 			if (!strcmp(args[i], "-l") && args[i+1][0] != '-')
 				dash_l_set = 1;
 		}
 
 #if HAVE_REMSH
@@ -238,22 +239,28 @@
 		}
 		args[argc++] = machine;
 #endif
 
 		args[argc++] = rsync_path;
 
-		if ((blocking_io == -1) && (strcmp(cmd, RSYNC_RSH) == 0))
-			blocking_io = 1;
+		if (blocking_io < 0) {
+			char *cp;
+			if ((cp = strrchr(cmd, '/')) != NULL)
+				cp++;
+			else
+				cp = cmd;
+			if (strcmp(cp, "rsh") == 0 || strcmp(cp, "remsh") == 0)
+				blocking_io = 1;
+		}
 
 		server_options(args,&argc);
-
 	}
 
 	args[argc++] = ".";
 
-	if (!daemon_over_rsh && path && *path) 
+	if (!daemon_over_rsh && path && *path)
 		args[argc++] = path;
 
 	args[argc] = NULL;
 
 	if (verbose > 3) {
 		rprintf(FINFO,"cmd=");
@@ -261,13 +268,13 @@
 			rprintf(FINFO,"%s ",args[i]);
 		rprintf(FINFO,"\n");
 	}
 
 	if (local_server) {
 		if (read_batch)
-		    create_flist_from_batch(); /* sets batch_flist */
+			create_flist_from_batch(); /* sets batch_flist */
 		ret = local_child(argc, args, f_in, f_out, child_main);
 	} else {
 		ret = piped_child(args,f_in,f_out);
 	}
 
 	if (dir) free(dir);
@@ -282,52 +289,53 @@
 
 
 
 static char *get_local_name(struct file_list *flist,char *name)
 {
 	STRUCT_STAT st;
+	int e;
 	extern int orig_umask;
 
 	if (verbose > 2)
-		rprintf(FINFO,"get_local_name count=%d %s\n", 
+		rprintf(FINFO,"get_local_name count=%d %s\n",
 			flist->count, NS(name));
 
-	if (!name) 
+	if (!name)
 		return NULL;
 
 	if (do_stat(name,&st) == 0) {
 		if (S_ISDIR(st.st_mode)) {
 			if (!push_dir(name, 0)) {
-				rprintf(FERROR,"push_dir %s : %s (1)\n",
-					name,strerror(errno));
+				rprintf(FERROR, "push_dir %s failed: %s (1)\n",
+					full_fname(name), strerror(errno));
 				exit_cleanup(RERR_FILESELECT);
 			}
 			return NULL;
 		}
 		if (flist->count > 1) {
 			rprintf(FERROR,"ERROR: destination must be a directory when copying more than 1 file\n");
 			exit_cleanup(RERR_FILESELECT);
 		}
 		return name;
 	}
 
-	if (flist->count <= 1)
+	if (flist->count <= 1 && ((e = strlen(name)) <= 1 || name[e-1] != '/'))
 		return name;
 
 	if (do_mkdir(name,0777 & ~orig_umask) != 0) {
-		rprintf(FERROR, RSYNC_NAME ": mkdir %s: %s\n",
-			name, strerror(errno));
+		rprintf(FERROR, "mkdir %s failed: %s\n",
+			full_fname(name), strerror(errno));
 		exit_cleanup(RERR_FILEIO);
 	} else {
 		if (verbose > 0)
 			rprintf(FINFO,"created directory %s\n",name);
 	}
 
 	if (!push_dir(name, 0)) {
-		rprintf(FERROR, RSYNC_NAME ": push_dir %s: %s\n",
-			name, strerror(errno));
+		rprintf(FERROR, "push_dir %s failed: %s (2)\n",
+			full_fname(name), strerror(errno));
 		exit_cleanup(RERR_FILESELECT);
 	}
 
 	return NULL;
 }
 
@@ -338,48 +346,48 @@
 {
 	int i;
 	struct file_list *flist;
 	char *dir = argv[0];
 	extern int relative_paths;
 	extern int recurse;
-	extern int remote_version;
 
 	if (verbose > 2)
 		rprintf(FINFO,"server_sender starting pid=%d\n",(int)getpid());
-  
+
 	if (!relative_paths && !push_dir(dir, 0)) {
-		rprintf(FERROR,"push_dir %s: %s (3)\n",dir,strerror(errno));
+		rprintf(FERROR, "push_dir %s failed: %s (3)\n",
+			full_fname(dir), strerror(errno));
 		exit_cleanup(RERR_FILESELECT);
 	}
 	argc--;
 	argv++;
-  
+
 	if (strcmp(dir,".")) {
 		int l = strlen(dir);
-		if (strcmp(dir,"/") == 0) 
+		if (strcmp(dir,"/") == 0)
 			l = 0;
 		for (i=0;i<argc;i++)
 			argv[i] += l+1;
 	}
 
 	if (argc == 0 && recurse) {
 		argc=1;
 		argv--;
 		argv[0] = ".";
 	}
-	
+
 	flist = send_file_list(f_out,argc,argv);
 	if (!flist || flist->count == 0) {
 		exit_cleanup(0);
 	}
 
 	send_files(flist,f_out,f_in);
 	io_flush();
 	report(f_out);
-	if (remote_version >= 24) {
-		/* final goodbye message */		
+	if (protocol_version >= 24) {
+		/* final goodbye message */
  		read_int(f_in);
  	}
 	io_flush();
 	exit_cleanup(0);
 }
 
@@ -391,13 +399,12 @@
 	int recv_pipe[2];
 	int error_pipe[2];
 	extern int preserve_hard_links;
 	extern int delete_after;
 	extern int recurse;
 	extern int delete_mode;
-	extern int remote_version;
 
 	if (preserve_hard_links)
 		init_hard_links(flist);
 
 	if (!delete_after) {
 		/* I moved this here from recv_files() to prevent a race condition */
@@ -412,13 +419,13 @@
 	}
 
 	if (fd_pair(error_pipe) < 0) {
 		rprintf(FERROR,"error pipe failed in do_recv\n");
 		exit_cleanup(RERR_SOCKETIO);
 	}
-  
+
 	io_flush();
 
 	if ((pid=do_fork()) == 0) {
 		close(recv_pipe[0]);
 		close(error_pipe[0]);
 		if (f_in != f_out) close(f_out);
@@ -434,14 +441,14 @@
 		report(f_in);
 
 		write_int(recv_pipe[1],1);
 		close(recv_pipe[1]);
 		io_flush();
 		/* finally we go to sleep until our parent kills us
-		   with a USR2 signal. We sleep for a short time as on
-		   some OSes a signal won't interrupt a sleep! */
+		 * with a USR2 signal. We sleep for a short time as on
+		 * some OSes a signal won't interrupt a sleep! */
 		while (msleep(20))
 			;
 	}
 
 	close(recv_pipe[1]);
 	close(error_pipe[1]);
@@ -452,13 +459,13 @@
 	io_set_error_fd(error_pipe[0]);
 
 	generate_files(f_out,flist,local_name,recv_pipe[0]);
 
 	read_int(recv_pipe[0]);
 	close(recv_pipe[0]);
-	if (remote_version >= 24) {
+	if (protocol_version >= 24) {
 		/* send a final goodbye message */
 		write_int(f_out, -1);
 	}
 	io_flush();
 
 	io_set_error_fd(-1);
@@ -473,52 +480,59 @@
 	int status;
 	struct file_list *flist;
 	char *local_name=NULL;
 	char *dir = NULL;
 	extern int delete_mode;
 	extern int delete_excluded;
-	extern int am_daemon;
 	extern int module_id;
-	extern int am_sender;
 	extern int read_batch;
 	extern struct file_list *batch_flist;
 
 	if (verbose > 2)
 		rprintf(FINFO,"server_recv(%d) starting pid=%d\n",argc,(int)getpid());
 
 	if (am_daemon && lp_read_only(module_id) && !am_sender) {
 		rprintf(FERROR,"ERROR: module is read only\n");
 		exit_cleanup(RERR_SYNTAX);
 		return;
 	}
 
-	
+
 	if (argc > 0) {
 		dir = argv[0];
 		argc--;
 		argv++;
 		if (!am_daemon && !push_dir(dir, 0)) {
-			rprintf(FERROR,"push_dir %s : %s (4)\n",
-				dir,strerror(errno));
+			rprintf(FERROR, "push_dir %s failed: %s (4)\n",
+				full_fname(dir), strerror(errno));
 			exit_cleanup(RERR_FILESELECT);
-		}    
+		}
 	}
 
 	if (delete_mode && !delete_excluded)
 		recv_exclude_list(f_in);
 
+	if (filesfrom_fd >= 0) {
+		/* We're receiving the file info from the sender, so we need
+		 * the IO routines to automatically write out the names onto
+		 * our f_out socket as we read the list info from the sender.
+		 * This avoids both deadlock and extra delays/buffers. */
+		io_set_filesfrom_fds(filesfrom_fd, f_out);
+		filesfrom_fd = -1;
+	}
+
 	if (read_batch)
-	    flist = batch_flist;
+		flist = batch_flist;
 	else
-	    flist = recv_file_list(f_in);
+		flist = recv_file_list(f_in);
 	if (!flist) {
 		rprintf(FERROR,"server_recv: recv_file_list error\n");
 		exit_cleanup(RERR_FILESELECT);
 	}
-	
-	if (argc > 0) {    
+
+	if (argc > 0) {
 		if (strcmp(dir,".")) {
 			argv[0] += strlen(dir);
 			if (argv[0][0] == '/') argv[0]++;
 		}
 		local_name = get_local_name(flist,argv[0]);
 	}
@@ -535,29 +549,27 @@
 }
 
 
 void start_server(int f_in, int f_out, int argc, char *argv[])
 {
 	extern int cvs_exclude;
-	extern int am_sender;
-	extern int remote_version;
 	extern int read_batch;
 
 	setup_protocol(f_out, f_in);
 
 	set_nonblocking(f_in);
 	set_nonblocking(f_out);
 
-	if (remote_version >= 23)
+	if (protocol_version >= 23)
 		io_start_multiplex_out(f_out);
 
 	if (am_sender) {
 		if (!read_batch) {
-		    recv_exclude_list(f_in);
-		    if (cvs_exclude)
-			add_cvs_excludes();
+			recv_exclude_list(f_in);
+			if (cvs_exclude)
+				add_cvs_excludes();
 		}
 		do_server_sender(f_in, f_out, argc, argv);
 	} else {
 		do_server_recv(f_in, f_out, argc, argv);
 	}
 	exit_cleanup(0);
@@ -570,47 +582,47 @@
  */
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[])
 {
 	struct file_list *flist = NULL;
 	int status = 0, status2 = 0;
 	char *local_name = NULL;
-	extern int am_sender;
-	extern int remote_version;
 	extern pid_t cleanup_child_pid;
 	extern int write_batch;
 	extern int read_batch;
 	extern struct file_list *batch_flist;
 
 	cleanup_child_pid = pid;
 	if (read_batch)
-	    flist = batch_flist;
+		flist = batch_flist;
 
 	set_nonblocking(f_in);
 	set_nonblocking(f_out);
 
 	setup_protocol(f_out,f_in);
 
-	if (remote_version >= 23)
+	if (protocol_version >= 23)
 		io_start_multiplex_in(f_in);
-	
+
 	if (am_sender) {
 		extern int cvs_exclude;
 		extern int delete_mode;
 		extern int delete_excluded;
 		if (cvs_exclude)
 			add_cvs_excludes();
-		if (delete_mode && !delete_excluded) 
+		if (delete_mode && !delete_excluded)
 			send_exclude_list(f_out);
+		if (remote_filesfrom_file)
+			filesfrom_fd = f_in;
 		if (!read_batch) /*  dw -- don't write to pipe */
-		    flist = send_file_list(f_out,argc,argv);
-		if (verbose > 3) 
+			flist = send_file_list(f_out,argc,argv);
+		if (verbose > 3)
 			rprintf(FINFO,"file list sent\n");
 
 		send_files(flist,f_out,f_in);
-		if (remote_version >= 24) {
-			/* final goodbye message */		
+		if (protocol_version >= 24) {
+			/* final goodbye message */
 			read_int(f_in);
 		}
 		if (pid != -1) {
 			if (verbose > 3)
 				rprintf(FINFO,"client_run waiting on %d\n", (int) pid);
 			io_flush();
@@ -621,54 +633,43 @@
 	}
 
 	if (argc == 0) {
 		extern int list_only;
 		list_only = 1;
 	}
-	
+
 	if (!write_batch)
-	    send_exclude_list(f_out);
-	
+		send_exclude_list(f_out);
+
+	if (filesfrom_fd >= 0) {
+		io_set_filesfrom_fds(filesfrom_fd, f_out);
+		filesfrom_fd = -1;
+	}
+
 	flist = recv_file_list(f_in);
 	if (!flist || flist->count == 0) {
 		rprintf(FINFO, "client: nothing to do: "
                         "perhaps you need to specify some filenames or "
                         "the --recursive option?\n");
 		exit_cleanup(0);
 	}
-	
+
 	local_name = get_local_name(flist,argv[0]);
-	
+
 	status2 = do_recv(f_in,f_out,flist,local_name);
-	
+
 	if (pid != -1) {
 		if (verbose > 3)
 			rprintf(FINFO,"client_run2 waiting on %d\n", (int) pid);
 		io_flush();
 		wait_process(pid, &status);
 	}
-	
-	return MAX(status, status2);
-}
-
-static char *find_colon(char *s)
-{
-	char *p, *p2;
 
-	p = strchr(s,':');
-	if (!p) return NULL;
-	
-	/* now check to see if there is a / in the string before the : - if there is then
-	   discard the colon on the assumption that the : is part of a filename */
-	p2 = strchr(s,'/');
-	if (p2 && p2 < p) return NULL;
-
-	return p;
+	return MAX(status, status2);
 }
 
-
 static int copy_argv (char *argv[])
 {
 	int i;
 
 	for (i = 0; argv[i]; i++) {
 		if (!(argv[i] = strdup(argv[i]))) {
@@ -697,21 +698,20 @@
 	char *shell_path = NULL;
 	char *shell_user = NULL;
 	int ret;
 	pid_t pid;
 	int f_in,f_out;
 	extern int local_server;
-	extern int am_sender;
 	extern char *shell_cmd;
 	extern int rsync_port;
 	extern int daemon_over_rsh;
 	extern int read_batch;
 	int rc;
 
 	/* Don't clobber argv[] so that ps(1) can still show the right
-           command line. */
+	 * command line. */
 	if ((rc = copy_argv(argv)))
 		return rc;
 
 	/* rsync:// always uses rsync server over direct socket connection */
 	if (strncasecmp(URL_PREFIX, argv[0], strlen(URL_PREFIX)) == 0) {
 		char *host, *path;
@@ -731,90 +731,108 @@
 		}
 		return start_socket_client(host, path, argc-1, argv+1);
 	}
 
 	if (!read_batch) {
 		p = find_colon(argv[0]);
+		if (p) {
+			if (remote_filesfrom_file
+			 && remote_filesfrom_file != files_from + 1
+			 && strncmp(files_from, argv[0], p-argv[0]+1) != 0) {
+				rprintf(FERROR,
+					"--files-from hostname is not transfer hostname\n");
+				exit_cleanup(RERR_SYNTAX);
+			}
+			if (p[1] == ':') { /* double colon */
+				*p = 0;
+				if (!shell_cmd) {
+					return start_socket_client(argv[0], p+2,
+								   argc-1, argv+1);
+				}
+				p++;
+				daemon_over_rsh = 1;
+			}
 
-	if (p) {
-		if (p[1] == ':') { /* double colon */
-			*p = 0;
-			if (!shell_cmd) {
-				return start_socket_client(argv[0], p+2,
-							   argc-1, argv+1);
+			if (argc < 1) {
+				usage(FERROR);
+				exit_cleanup(RERR_SYNTAX);
 			}
-			p++;
-			daemon_over_rsh = 1;
-		}
 
-		if (argc < 1) {
-			usage(FERROR);
-			exit_cleanup(RERR_SYNTAX);
-		}
+			am_sender = 0;
+			*p = 0;
+			shell_machine = argv[0];
+			shell_path = p+1;
+			argc--;
+			argv++;
+		} else {
+			am_sender = 1;
 
-		am_sender = 0;
-		*p = 0;
-		shell_machine = argv[0];
-		shell_path = p+1;
-		argc--;
-		argv++;
-	} else {
-		am_sender = 1;
+			/* rsync:// destination uses rsync server over direct socket */
+			if (strncasecmp(URL_PREFIX, argv[argc-1], strlen(URL_PREFIX)) == 0) {
+				char *host, *path;
+
+				host = argv[argc-1] + strlen(URL_PREFIX);
+				p = strchr(host,'/');
+				if (p) {
+					*p = 0;
+					path = p+1;
+				} else {
+					path = "";
+				}
+				p = strchr(host,':');
+				if (p) {
+					rsync_port = atoi(p+1);
+					*p = 0;
+				}
+				return start_socket_client(host, path, argc-1, argv);
+			}
 
-		/* rsync:// destination uses rsync server over direct socket */
-		if (strncasecmp(URL_PREFIX, argv[argc-1], strlen(URL_PREFIX)) == 0) {
-			char *host, *path;
-
-			host = argv[argc-1] + strlen(URL_PREFIX);
-			p = strchr(host,'/');
-			if (p) {
-				*p = 0;
-				path = p+1;
-			} else {
-				path = "";
+			p = find_colon(argv[argc-1]);
+			if (p && remote_filesfrom_file
+			 && remote_filesfrom_file != files_from + 1
+			 && strncmp(files_from, argv[argc-1], p-argv[argc-1]+1) != 0) {
+				rprintf(FERROR,
+					"--files-from hostname is not transfer hostname\n");
+				exit_cleanup(RERR_SYNTAX);
 			}
-			p = strchr(host,':');
-			if (p) {
-				rsync_port = atoi(p+1);
+			if (!p) {
+				local_server = 1;
+				if (remote_filesfrom_file) {
+					rprintf(FERROR,
+						"--files-from is remote but transfer is local\n");
+					exit_cleanup(RERR_SYNTAX);
+				}
+			} else if (p[1] == ':') { /* double colon */
 				*p = 0;
+				if (!shell_cmd) {
+					return start_socket_client(argv[argc-1], p+2,
+								   argc-1, argv);
+				}
+				p++;
+				daemon_over_rsh = 1;
 			}
-			return start_socket_client(host, path, argc-1, argv);
-		}
 
-		p = find_colon(argv[argc-1]);
-		if (!p) {
-			local_server = 1;
-		} else if (p[1] == ':') { /* double colon */
-			*p = 0;
-			if (!shell_cmd) {
-				return start_socket_client(argv[argc-1], p+2,
-							   argc-1, argv);
+			if (argc < 2) {
+				usage(FERROR);
+				exit_cleanup(RERR_SYNTAX);
 			}
-			p++;
-			daemon_over_rsh = 1;
-		}
 
-		if (argc < 2) {
-			usage(FERROR);
-			exit_cleanup(RERR_SYNTAX);
-		}
-		
-		if (local_server) {
-			shell_machine = NULL;
-			shell_path = argv[argc-1];
-		} else {
-			*p = 0;
-			shell_machine = argv[argc-1];
-			shell_path = p+1;
+			if (local_server) {
+				shell_machine = NULL;
+				shell_path = argv[argc-1];
+			} else {
+				*p = 0;
+				shell_machine = argv[argc-1];
+				shell_path = p+1;
+			}
+			argc--;
 		}
-		argc--;
-	}
 	} else {
-	    am_sender = 1;
-	    local_server = 1;
-	    shell_path = argv[argc-1];
+		am_sender = 1;
+		local_server = 1;
+		shell_path = argv[argc-1];
 	}
 
 	if (shell_machine) {
 		p = strchr(shell_machine,'@');
 		if (p) {
 			*p = 0;
@@ -827,28 +845,28 @@
 		rprintf(FINFO,"cmd=%s machine=%s user=%s path=%s\n",
 			shell_cmd?shell_cmd:"",
 			shell_machine?shell_machine:"",
 			shell_user?shell_user:"",
 			shell_path?shell_path:"");
 	}
-	
+
 	if (!am_sender && argc > 1) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (argc == 0 && !am_sender) {
 		extern int list_only;
 		list_only = 1;
 	}
-	
+
 	pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,
 		     &f_in,&f_out);
 
 	/* if we're running an rsync server on the remote host over a
-	   remote shell command, we need to do the RSYNCD protocol first */
+	 * remote shell command, we need to do the RSYNCD protocol first */
 	if (daemon_over_rsh) {
 		int tmpret;
 		tmpret = start_inband_exchange(shell_user, shell_path,
 					       f_in, f_out, argc);
 		if (tmpret < 0)
 			return tmpret;
@@ -860,41 +878,44 @@
 	fflush(stderr);
 
 	return ret;
 }
 
 
-static RETSIGTYPE sigusr1_handler(int UNUSED(val)) {
+static RETSIGTYPE sigusr1_handler(UNUSED(int val))
+{
 	exit_cleanup(RERR_SIGNAL);
 }
 
-static RETSIGTYPE sigusr2_handler(int UNUSED(val)) {
+static RETSIGTYPE sigusr2_handler(UNUSED(int val))
+{
 	extern int log_got_error;
 	if (log_got_error) _exit(RERR_PARTIAL);
 	_exit(0);
 }
 
-static RETSIGTYPE sigchld_handler(int UNUSED(val)) {
+static RETSIGTYPE sigchld_handler(UNUSED(int val))
+{
 #ifdef WNOHANG
 	int cnt, status;
 	pid_t pid;
 	/* An empty waitpid() loop was put here by Tridge and we could never
-	 * get him to explain why he put it in, so rather than taking it 
+	 * get him to explain why he put it in, so rather than taking it
 	 * out we're instead saving the child exit statuses for later use.
 	 * The waitpid() loop presumably eliminates all possibility of leaving
 	 * zombie children, maybe that's why he did it.
 	 */
 	while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
-		 /* save the child's exit status */
-		 for (cnt = 0; cnt < MAXCHILDPROCS; cnt++) {
-			  if (pid_stat_table[cnt].pid == 0) {
-				   pid_stat_table[cnt].pid = pid;
-				   pid_stat_table[cnt].status = status;
-				   break;
-			  }
-		 }
+		/* save the child's exit status */
+		for (cnt = 0; cnt < MAXCHILDPROCS; cnt++) {
+			if (pid_stat_table[cnt].pid == 0) {
+				pid_stat_table[cnt].pid = pid;
+				pid_stat_table[cnt].status = status;
+				break;
+			}
+		}
 	}
 #endif
 }
 
 
 /**
@@ -928,13 +949,13 @@
  *
  * This signal handler is only installed if we were configured with
  * --enable-maintainer-mode.  Perhaps it should always be on and we
  * should just look at the environment variable, but I'm a bit leery
  * of a signal sending us into a busy loop.
  **/
-static RETSIGTYPE rsync_panic_handler(int UNUSED(whatsig))
+static RETSIGTYPE rsync_panic_handler(UNUSED(int whatsig))
 {
 	char cmd_buf[300];
 	int ret;
 
 	sprintf(cmd_buf, get_panic_action(),
 		getpid(), getpid());
@@ -946,18 +967,16 @@
 		_exit(ret);
 }
 #endif
 
 
 int main(int argc,char *argv[])
-{       
+{
 	extern int am_root;
 	extern int orig_umask;
 	extern int dry_run;
-	extern int am_daemon;
-	extern int am_server;
 	int ret;
 	extern int write_batch;
 	int orig_argc;
 	char **orig_argv;
 
 	orig_argc = argc;
@@ -981,13 +1000,13 @@
 	if (argc < 2) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	/* we set a 0 umask so that correct file permissions can be
-	   carried across */
+	 * carried across */
 	orig_umask = (int)umask(0);
 
 	if (!parse_arguments(&argc, (const char ***) &argv, 1)) {
                 /* FIXME: We ought to call the same error-handling
                  * code here, rather than relying on getopt. */
 		option_error();
@@ -1000,19 +1019,19 @@
 
 	/* Ignore SIGPIPE; we consistently check error codes and will
 	 * see the EPIPE. */
 	signal(SIGPIPE, SIG_IGN);
 
 	/* Initialize push_dir here because on some old systems getcwd
-	   (implemented by forking "pwd" and reading its output) doesn't
-	   work when there are other child processes.  Also, on all systems
-	   that implement getcwd that way "pwd" can't be found after chroot. */
+	 * (implemented by forking "pwd" and reading its output) doesn't
+	 * work when there are other child processes.  Also, on all systems
+	 * that implement getcwd that way "pwd" can't be found after chroot. */
 	push_dir(NULL,0);
 
 	if (write_batch && !am_server) {
-	    write_batch_argvs_file(orig_argc, orig_argv);
+		write_batch_argvs_file(orig_argc, orig_argv);
 	}
 
 	if (am_daemon && !am_server)
 		return daemon_main();
 
 	if (argc < 1) {
@@ -1036,14 +1055,13 @@
 		if (am_daemon)
 			return start_daemon(STDIN_FILENO, STDOUT_FILENO);
 		start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
 	}
 
 	ret = start_client(argc, argv);
-	if (ret == -1) 
+	if (ret == -1)
 		exit_cleanup(RERR_STARTCLIENT);
 	else
 		exit_cleanup(ret);
 
-	exit(ret);
-	/* NOTREACHED */
+	return ret;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/Makefile.in	2003-01-21 02:26:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/Makefile.in	2003-07-30 14:12:25.000000000 +0800
@@ -22,13 +22,14 @@
 
 VERSION=@VERSION@
 
 .SUFFIXES:
 .SUFFIXES: .c .o
 
-LIBOBJ=lib/fnmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o \
+HEADERS=byteorder.h config.h errcode.h proto.h rsync.h
+LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o \
 	lib/permstring.o @LIBOBJS@
 ZLIBOBJ=zlib/deflate.o zlib/infblock.o zlib/infcodes.o zlib/inffast.o \
 	zlib/inflate.o zlib/inftrees.o zlib/infutil.o zlib/trees.o \
 	zlib/zutil.o zlib/adler32.o
 OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
 	main.o checksum.o match.o syscall.o log.o backup.o
@@ -41,16 +42,16 @@
 OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
 
 TLS_OBJ = tls.o syscall.o lib/permstring.o
 
 # Programs we must have to run the test cases
 CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) \
-	trimslash$(EXEEXT) t_unsafe$(EXEEXT)
+	trimslash$(EXEEXT) t_unsafe$(EXEEXT) wildtest$(EXEEXT)
 
 # Objects for CHECK_PROGS to clean
-CHECK_OBJS=getgroups.o t_stub.o t_unsafe.o trimslash.o
+CHECK_OBJS=getgroups.o t_stub.o t_unsafe.o trimslash.o wildtest.o
 
 # note that the -I. is needed to handle config.h when using VPATH
 .c.o:
 @OBJ_SAVE@
 	$(CC) -I. -I$(srcdir) $(CFLAGS) $(CPPFLAGS) -c $< @CC_SHOBJ_FLAG@
 @OBJ_RESTORE@
@@ -70,13 +71,13 @@
 install-strip:
 	$(MAKE) STRIP='-s' install
 
 rsync$(EXEEXT): $(OBJS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
 
-$(OBJS): config.h
+$(OBJS): $(HEADERS)
 
 tls$(EXEEXT): $(TLS_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TLS_OBJ) $(LIBS)
 
 getgroups$(EXEEXT): getgroups.o
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getgroups.o $(LIBS)
@@ -155,12 +156,16 @@
 # catch Bash-isms earlier even if we're running on GNU.  Of course, we
 # might lose in the future where POSIX diverges from old sh.
 
 check: all $(CHECK_PROGS)
 	POSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin=`pwd`/rsync$(EXEEXT) srcdir="$(srcdir)" $(srcdir)/runtests.sh
 
+wildtest.o: wildtest.c lib/wildmatch.c rsync.h
+wildtest$(EXEEXT): wildtest.o
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ wildtest.o @BUILD_POPT@ $(LIBS)
+
 # This does *not* depend on building or installing: you can use it to
 # check a version installed from a binary or some other source tree,
 # if you want.
 
 installcheck: $(CHECK_PROGS)
 	POSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin="$(bindir)/rsync$(EXEEXT)" srcdir="$(srcdir)" $(srcdir)/runtests.sh
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/match.c	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/match.c	2003-12-07 05:07:27.000000000 +0800
@@ -1,33 +1,30 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1996
    Copyright (C) Paul Mackerras 1996
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
-extern int csum_length;
-
 extern int verbose;
 extern int am_server;
-
-extern int remote_version;
+extern int do_progress;
 
 typedef unsigned short tag;
 
 #define TABLESIZE (1<<16)
 #define NULL_TAG (-1)
 
@@ -40,53 +37,52 @@
 static int total_tag_hits;
 static int total_matches;
 
 extern struct stats stats;
 
 struct target {
-  tag t;
-  int i;
+	tag t;
+	int i;
 };
 
 static struct target *targets;
 
 static int *tag_table;
 
 #define gettag2(s1,s2) (((s1) + (s2)) & 0xFFFF)
 #define gettag(sum) gettag2((sum)&0xFFFF,(sum)>>16)
 
 static int compare_targets(struct target *t1,struct target *t2)
 {
-  return((int)t1->t - (int)t2->t);
+	return (int)t1->t - (int)t2->t;
 }
 
 
 static void build_hash_table(struct sum_struct *s)
 {
-  int i;
+	int i;
 
-  if (!tag_table)
-    tag_table = new_array(int, TABLESIZE);
+	if (!tag_table)
+		tag_table = new_array(int, TABLESIZE);
 
-  targets = new_array(struct target, s->count);
-  if (!tag_table || !targets) 
-    out_of_memory("build_hash_table");
-
-  for (i=0;i<(int) s->count;i++) {
-    targets[i].i = i;
-    targets[i].t = gettag(s->sums[i].sum1);
-  }
+	targets = new_array(struct target, s->count);
+	if (!tag_table || !targets)
+		out_of_memory("build_hash_table");
+
+	for (i = 0; i < (int)s->count; i++) {
+		targets[i].i = i;
+		targets[i].t = gettag(s->sums[i].sum1);
+	}
 
-  qsort(targets,s->count,sizeof(targets[0]),(int (*)())compare_targets);
+	qsort(targets,s->count,sizeof(targets[0]),(int (*)())compare_targets);
 
-  for (i=0;i<TABLESIZE;i++)
-    tag_table[i] = NULL_TAG;
+	for (i = 0; i < TABLESIZE; i++)
+		tag_table[i] = NULL_TAG;
 
-  for (i=s->count-1;i>=0;i--) {    
-    tag_table[targets[i].t] = i;
-  }
+	for (i = s->count-1; i >= 0; i--)
+		tag_table[targets[i].t] = i;
 }
 
 
 static OFF_T last_match;
 
 
@@ -116,25 +112,25 @@
 	data_transfer += n;
 
 	if (i >= 0) {
 		stats.matched_data += s->sums[i].len;
 		n += s->sums[i].len;
 	}
-  
-	for (j=0;j<n;j+=CHUNK_SIZE) {
+
+	for (j = 0; j < n; j += CHUNK_SIZE) {
 		int n1 = MIN(CHUNK_SIZE,n-j);
 		sum_update(map_ptr(buf,last_match+j,n1),n1);
 	}
 
 
 	if (i >= 0)
 		last_match = offset + s->sums[i].len;
 	else
 		last_match = offset;
 
-	if (buf) {
+	if (buf && do_progress) {
 		show_progress(last_match, buf->file_size);
 
 		if (i == -1) end_progress(buf->file_size);
 	}
 }
 
@@ -142,114 +138,112 @@
 static void hash_search(int f,struct sum_struct *s,
 			struct map_struct *buf,OFF_T len)
 {
 	OFF_T offset, end;
 	int j,k, last_i;
 	char sum2[SUM_LENGTH];
-	uint32 s1, s2, sum; 
+	uint32 s1, s2, sum;
 	schar *map;
 
 	/* last_i is used to encourage adjacent matches, allowing the RLL coding of the
 	   output to work more efficiently */
 	last_i = -1;
 
 	if (verbose > 2)
 		rprintf(FINFO,"hash search b=%ld len=%.0f\n",
-			(long) s->n, (double)len);
+			(long) s->blength, (double)len);
+
+	k = MIN(len, (OFF_T)s->blength);
 
-	/* cast is to make s->n signed; it should always be reasonably
-	 * small */
-	k = MIN(len, (OFF_T) s->n);
-	
 	map = (schar *)map_ptr(buf,0,k);
-	
+
 	sum = get_checksum1((char *)map, k);
 	s1 = sum & 0xFFFF;
 	s2 = sum >> 16;
 	if (verbose > 3)
 		rprintf(FINFO, "sum=%.8x k=%d\n", sum, k);
-	
+
 	offset = 0;
-	
+
 	end = len + 1 - s->sums[s->count-1].len;
-	
+
 	if (verbose > 3)
-		rprintf(FINFO, "hash search s->n=%ld len=%.0f count=%ld\n",
-			(long) s->n, (double) len, (long) s->count);
-	
+		rprintf(FINFO, "hash search s->blength=%ld len=%.0f count=%ld\n",
+			(long) s->blength, (double) len, (long) s->count);
+
 	do {
 		tag t = gettag2(s1,s2);
 		int done_csum2 = 0;
-			
+
 		j = tag_table[t];
 		if (verbose > 4)
 			rprintf(FINFO,"offset=%.0f sum=%08x\n",(double)offset,sum);
-		
+
 		if (j == NULL_TAG) {
 			goto null_tag;
 		}
 
 		sum = (s1 & 0xffff) | (s2 << 16);
 		tag_hits++;
 		for (; j < (int) s->count && targets[j].t == t; j++) {
 			int l, i = targets[j].i;
-			
+
 			if (sum != s->sums[i].sum1) continue;
-			
+
 			/* also make sure the two blocks are the same length */
-			l = MIN(s->n,len-offset);
-			if (l != s->sums[i].len) continue;			
+			l = MIN((OFF_T)s->blength, len-offset);
+			if (l != s->sums[i].len) continue;
 
 			if (verbose > 3)
 				rprintf(FINFO,"potential match at %.0f target=%d %d sum=%08x\n",
 					(double)offset,j,i,sum);
-			
+
 			if (!done_csum2) {
 				map = (schar *)map_ptr(buf,offset,l);
 				get_checksum2((char *)map,l,sum2);
 				done_csum2 = 1;
 			}
-			
-			if (memcmp(sum2,s->sums[i].sum2,csum_length) != 0) {
+
+			if (memcmp(sum2,s->sums[i].sum2,s->s2length) != 0) {
 				false_alarms++;
 				continue;
 			}
 
 			/* we've found a match, but now check to see
-                           if last_i can hint at a better match */
+			 * if last_i can hint at a better match */
 			for (j++; j < (int) s->count && targets[j].t == t; j++) {
 				int i2 = targets[j].i;
 				if (i2 == last_i + 1) {
 					if (sum != s->sums[i2].sum1) break;
-					if (memcmp(sum2,s->sums[i2].sum2,csum_length) != 0) break;
-					/* we've found an adjacent match - the RLL coder 
-					   will be happy */
+					if (memcmp(sum2,s->sums[i2].sum2,s->s2length) != 0) break;
+					/* we've found an adjacent match - the RLL coder
+					 * will be happy */
 					i = i2;
 					break;
 				}
 			}
 
 			last_i = i;
-			
+
 			matched(f,s,buf,offset,i);
 			offset += s->sums[i].len - 1;
-			k = MIN((len-offset), s->n);
+			k = MIN((OFF_T)s->blength, len-offset);
 			map = (schar *)map_ptr(buf,offset,k);
 			sum = get_checksum1((char *)map, k);
 			s1 = sum & 0xFFFF;
 			s2 = sum >> 16;
 			matches++;
 			break;
 		}
-		
+
 	null_tag:
 		/* Trim off the first byte from the checksum */
 		map = (schar *)map_ptr(buf,offset,k+1);
 		s1 -= map[0] + CHAR_OFFSET;
 		s2 -= k * (map[0]+CHAR_OFFSET);
-		
+
 		/* Add on the next byte (if there is one) to the checksum */
 		if (k < (len-offset)) {
 			s1 += (map[k]+CHAR_OFFSET);
 			s2 += s1;
 		} else {
 			--k;
@@ -258,19 +252,19 @@
 		/* By matching early we avoid re-reading the
 		   data 3 times in the case where a token
 		   match comes a long way after last
 		   match. The 3 reads are caused by the
 		   running match, the checksum update and the
 		   literal send. */
-		if (offset > last_match &&
-		    offset-last_match >= CHUNK_SIZE+s->n && 
-		    (end-offset > CHUNK_SIZE)) {
-			matched(f,s,buf,offset - s->n, -2);
+		if (offset > last_match
+		 && offset-last_match >= CHUNK_SIZE+s->blength
+		 && end-offset > CHUNK_SIZE) {
+			matched(f,s,buf,offset - s->blength, -2);
 		}
 	} while (++offset < end);
-	
+
 	matched(f,s,buf,len,-1);
 	map_ptr(buf,len-1,1);
 }
 
 
 /**
@@ -292,56 +286,54 @@
 	char file_sum[MD4_SUM_LENGTH];
 	extern int write_batch;  /*  dw */
 
 	last_match = 0;
 	false_alarms = 0;
 	tag_hits = 0;
-	matches=0;
-	data_transfer=0;
+	matches = 0;
+	data_transfer = 0;
 
 	sum_init();
 
 	if (len > 0 && s->count>0) {
 		build_hash_table(s);
-		
-		if (verbose > 2) 
+
+		if (verbose > 2)
 			rprintf(FINFO,"built hash table\n");
-		
+
 		hash_search(f,s,buf,len);
-		
-		if (verbose > 2) 
+
+		if (verbose > 2)
 			rprintf(FINFO,"done hash search\n");
 	} else {
 		OFF_T j;
 		/* by doing this in pieces we avoid too many seeks */
-		for (j=0;j<(len-CHUNK_SIZE);j+=CHUNK_SIZE) {
+		for (j = 0; j < len-CHUNK_SIZE; j += CHUNK_SIZE) {
 			int n1 = MIN(CHUNK_SIZE,(len-CHUNK_SIZE)-j);
 			matched(f,s,buf,j+n1,-2);
 		}
 		matched(f,s,buf,len,-1);
 	}
 
 	sum_end(file_sum);
 
-	if (remote_version >= 14) {
-		if (verbose > 2)
-			rprintf(FINFO,"sending file_sum\n");
-		write_buf(f,file_sum,MD4_SUM_LENGTH);
-		if (write_batch) /* dw */
-		    write_batch_delta_file(file_sum, MD4_SUM_LENGTH);
-	}
+	if (verbose > 2)
+		rprintf(FINFO,"sending file_sum\n");
+	write_buf(f,file_sum,MD4_SUM_LENGTH);
+	if (write_batch) /* dw */
+		write_batch_delta_file(file_sum, MD4_SUM_LENGTH);
 
 	if (targets) {
 		free(targets);
 		targets=NULL;
 	}
-	
+
 	if (verbose > 2)
 		rprintf(FINFO, "false_alarms=%d tag_hits=%d matches=%d\n",
 			false_alarms, tag_hits, matches);
-	
+
 	total_tag_hits += tag_hits;
 	total_false_alarms += false_alarms;
 	total_matches += matches;
 	stats.literal_data += data_transfer;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/NEWS	2003-12-04 12:23:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/NEWS	2003-12-27 08:14:21.000000000 +0800
@@ -1,99 +1,134 @@
-NEWS for rsync version 2.5.7:
+NEWS for rsync 2.6.0 (1 Jan 2004)
+Protocol: 27 (changed)
+Changes since 2.5.7:
 
-  SECURITY:
+  ENHANCEMENTS:
 
-    * Fix buffer handling bugs.  (Andrew Tridgell, Martin Pool, Paul
-      Russell, Andrea Barisani)
+    * "ssh" is now the default remote shell for rsync.  If you want to
+      change this, configure like this:  "./configure --with-rsh=rsh".
 
+    * Added --files-from, --no-relative, --no-implied-dirs, and --from0.
+      Note that --from0 affects the line-ending character for all the
+      files read by the --*-from options. (Wayne Davison)
+
+    * Length of csum2 is now per-file starting with protocol version
+      27. (J.W. Schultz)
+
+    * Per-file dynamic block size is now sqrt(file length).  The
+      per-file checksum size is determined according to an algorithm
+      provided by Donovan Baarda which reduces the probability of rsync
+      algorithm corrupting data and falling back using the whole md4
+      checksums. (J.W. Schultz, Donovan Baarda)
+
+    * The --stats option no longer includes the (debug) malloc summary
+      unless the verbose option was specified at least twice.
+
+    * Added a new error/warning code for when files vanish from the
+      sending side.  Made vanished source files not interfere with the
+      file-deletion pass when --delete-after was specified.
 
-NEWS for rsync version 2.5.6, aka the dwd-between-jobs release
-Changes since version 2.5.5:
+    * Various trailing-info sections are now preceded by a newline.
 
-  ENHANCEMENTS:
+  BUG FIXES:
 
-    * The --delete-after option now implies --delete.  (Wayne Davison)
+    * Fixed several exclude/include matching bugs when using wild-cards.
+      This has a several user-visible effects, all of which make the
+      matching more consistent and intuitive.  This should hopefully not
+      cause anyone problems since it makes the matching work more like
+      what people are expecting. (Wayne Davison)
 
-    * The --suffix option can now be used with --backup-dir.  (Michael
-      Zimmerman)
+      - A pattern with a "**" no longer causes a "*" to match slashes.
+        For example, with "/*/foo/**", "foo" must be 2 levels deep.
 
-    * Combining "::" syntax with the -rsh/-e option now uses the
-      specified remote-shell as a transport to talk to a (newly-spawned)
-      server-daemon.  This allows someone to use daemon features, such
-      as modules, over a secure protocol, such as ssh.  (JD Paul)
+      - "**/foo" now matches at the base of the transfer (i.e. /foo).
 
-    * The rsync:// syntax for daemon connections is now accepted in the
-      destination field.
+      - An non-anchored wildcard term floats to match beyond the base of
+        the transfer.  E.g. "CVS/R*" matches at the end of the path,
+        just like the non-wildcard term "CVS/Root" does.
 
-    * If the file name given to --include-from or --exclude-from is "-",
-      rsync will read from standard input.  (J.W. Schultz)
+      - Including a "**" in the match term causes it to be matched
+        against the entire path, not just the name portion, even if
+        there aren't any interior slashes in the term.  E.g. "foo**bar"
+        would exclude "/path/foo-bar" (just like before) as well as
+        "/foo-path/baz-bar" (unlike before).
 
-    * New option --link-dest which is like --compare-dest except that
-      unchanged files are hard-linked in to the destination directory.
-      (J.W. Schultz)
+    * The exclude list specified in the daemon's config file is now
+      properly applied to the pulled items no matter how deep the
+      user's file-args are in the source tree.  (Wayne Davison)
 
-    * Don't report an error if an excluded file disappears during an
-      rsync run.  (Eugene Chupriyanov and Bo Kersey)
+    * For protocol version >= 27, mdfour_tail() is called when the
+      block size (including checksum_seed) is a multiple of 64.
+      Previously it was not called, giving the wrong MD4 checksum.
+      (Craig Barratt)
 
-    * Added .svn to --cvs-exclude list to support subversion.  (Jon
-      Middleton)
+    * For protocol version >= 27, a 64 bit bit counter is used in
+      mdfour.c as required by the RFC.  Previously only a 32 bit bit
+      counter was used, causing incorrect MD4 file checksums for
+      file sizes >= 512MB - 4.  (Craig Barratt)
 
-    * Properly support IPv6 addresses in the rsyncd.conf "hosts allow"
-      and "hosts deny" fields.  (Hideaki Yoshifuji)
+    * Fixed a crash bug when interacting with older rsync versions and
+      multiple files of the same name are destined for the same dir.
+      (Wayne Davison)
 
-    * Changed exclude file handling to permit DOS or MAC style line
-      terminations.  (J.W. Schultz)
+    * Keep tmp names from overflowing MAXPATHLEN.
 
-    * Ignore errors from chmod when -p/-a/--preserve-perms is not set.
-      (Dave Dykstra)
+    * Make --link-dest honor the absence of -p, -o, and -g.
 
-  BUG FIXES:
-  
-    * Fix "forward name lookup failed" errors on AIX 4.3.3.  (John
-      L. Allen, Martin Pool)
+    * Made rsync treat a trailing slash in the destination in a more
+      consistent manner.
 
-    * Generate each file's rolling-checksum data as we send it, not
-      in a separate (memory-eating) pass before hand.  This prevents
-      timeout errors on really large files. (Stefan Nehlsen)
+    * Fixed file I/O error detection.  (John Van Essen)
 
-    * Fix compilation on Tru64.  (Albert Chin, Zoong Pham)
+    * Fixed bogus "malformed address {hostname}" message in rsyncd log
+      when checking IP address against hostnames from "hosts allow"
+      and "hosts deny" parameters in config file.
 
-    * Better handling of some client-server errors.  (Martin Pool)
+    * Print heap statistics when verbose >= 2 instead of when >= 1.
 
-    * Fixed a crash that would occur when sending a list of files that
-      contains a duplicate name (if it sorts to the end of the file
-      list) and using --delete.  (Wayne Davison)
+    * Fixed a compression (-z) bug when syncing a mostly-matching file
+      that contains already-compressed data.  (Yasuoka Masahiko and
+      Wayne Davison)
 
-    * Fixed the file-name duplicate-removal code when dealing with multiple
-      dups in a row. (Wayne Davison)
+    * Fixed a bug in the --backup code that could cause deleted files
+      to not get backed up.
 
-    * Fixed a bug that caused rsync to lose the exit status of its child
-      processes and sometimes return an exit code of 0 instead of showing
-      an error.  (David R. Staples, Dave Dykstra)
+    * When the backup code makes new directories, create them with mode
+      0700 instead of 0755 (since the directory permissions in the
+      backup tree are not yet copied from the main tree).
 
-    * Fixed bug in --copy-unsafe-links that caused it to be completely
-      broken.  (Dave Dykstra)
+    * Call setgroups() in a more portable manner.
 
-    * Prevent infinite recursion in cleanup code under certain circumstances.
-      (Sviatoslav Sviridov and Marc Espie)
+    * Improved file-related error messages to better indicate exactly
+      what pathname failed. (Wayne Davison)
 
-    * Fixed a bug that prevented rsync from creating intervening directories
-      when --relative-paths/-R is set.  (Craig Barratt)
+    * Fixed some bugs in the handling of --delete and --exclude when
+      using the --relative (-R) option. (Wayne Davison)
 
-    * Prevent "Connection reset by peer" messages from Cygwin. (Randy O'Meara)
+    * Fixed bug that prevented regular files from replacing
+      special files and caused a directory in --link-dest or
+      --compare-dest to block the creation of a file with the
+      same path.  A directory still cannot be replaced by a
+      regular file unless --delete specified.  (J.W. Schultz)
 
-  INTERNAL:
+    * Detect and report when open or opendir succeed but read and
+      readdir fail caused by network filesystems issues and truncated
+      files.  (David Norwood, Michael Brown, J.W. Schultz)
 
-    * Many code cleanups and improved internal documentation.  (Martin 
-      Pool, Nelson Beebe)
+    * Added a fix that should give ssh time to restore the tty settings
+      if the user presses Ctrl-C at an ssh password prompt.
 
-    * Portability fixes. (Dave Dykstra and Wayne Davison)
+  INTERNAL:
 
-    * More test cases.  (Martin Pool)
+    * Eliminated vestigial support for old versions that we stopped
+      supporting. (J.W. Schultz)
 
-    * Some test-case fixes.  (Brian Poole, Wayne Davison)
+    * Simplified some of the option-parsing code. (Wayne Davison)
 
-    * Updated included popt to the latest vendor drop, version 1.6.4.
-      (Jos Backus)
+    * Some cleanup made to the exclude code, as well as some new
+      defines added to enhance readability. (Wayne Davison)
 
-    * Updated config.guess and config.sub to latest versions; this
-      means rsync should build on more platforms.  (Paul Green)
+    * Changed the protocol-version code so that it can interact at a
+      lower protocol level than the maximum supported by both sides.
+      Added an undocumented option, --protocol=N, to force the value
+      we advertise to the other side (primarily for testing purposes).
+      (Wayne Davison)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/OLDNEWS	2002-04-03 10:13:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/OLDNEWS	2003-12-27 08:14:21.000000000 +0800
@@ -1,7 +1,113 @@
-rsync 2.5.5 "Snowy River" (2 April 2002)
+NEWS for rsync 2.5.7 (4 Dec 2003)
+Protocol: 26 (unchanged)
+Changes since 2.5.6:
+
+  SECURITY FIXES:
+
+    * Fix buffer handling bugs.  (Andrew Tridgell, Martin Pool, Paul
+      Russell, Andrea Barisani)
+
+
+NEWS for rsync 2.5.6, aka "the dwd-between-jobs release" (26 Jan 2003)
+Protocol: 26 (unchanged)
+Changes since 2.5.5:
+
+  ENHANCEMENTS:
+
+    * The --delete-after option now implies --delete.  (Wayne Davison)
+
+    * The --suffix option can now be used with --backup-dir.  (Michael
+      Zimmerman)
+
+    * Combining "::" syntax with the -rsh/-e option now uses the
+      specified remote-shell as a transport to talk to a (newly-spawned)
+      server-daemon.  This allows someone to use daemon features, such
+      as modules, over a secure protocol, such as ssh.  (JD Paul)
+
+    * The rsync:// syntax for daemon connections is now accepted in the
+      destination field.
+
+    * If the file name given to --include-from or --exclude-from is "-",
+      rsync will read from standard input.  (J.W. Schultz)
+
+    * New option --link-dest which is like --compare-dest except that
+      unchanged files are hard-linked in to the destination directory.
+      (J.W. Schultz)
+
+    * Don't report an error if an excluded file disappears during an
+      rsync run.  (Eugene Chupriyanov and Bo Kersey)
+
+    * Added .svn to --cvs-exclude list to support subversion.  (Jon
+      Middleton)
+
+    * Properly support IPv6 addresses in the rsyncd.conf "hosts allow"
+      and "hosts deny" fields.  (Hideaki Yoshifuji)
+
+    * Changed exclude file handling to permit DOS or MAC style line
+      terminations.  (J.W. Schultz)
+
+    * Ignore errors from chmod when -p/-a/--preserve-perms is not set.
+      (Dave Dykstra)
+
+  BUG FIXES:
+
+    * Fix "forward name lookup failed" errors on AIX 4.3.3.  (John
+      L. Allen, Martin Pool)
+
+    * Generate each file's rolling-checksum data as we send it, not
+      in a separate (memory-eating) pass before hand.  This prevents
+      timeout errors on really large files. (Stefan Nehlsen)
+
+    * Fix compilation on Tru64.  (Albert Chin, Zoong Pham)
+
+    * Better handling of some client-server errors.  (Martin Pool)
+
+    * Fixed a crash that would occur when sending a list of files that
+      contains a duplicate name (if it sorts to the end of the file
+      list) and using --delete.  (Wayne Davison)
+
+    * Fixed the file-name duplicate-removal code when dealing with multiple
+      dups in a row. (Wayne Davison)
+
+    * Fixed a bug that caused rsync to lose the exit status of its child
+      processes and sometimes return an exit code of 0 instead of showing
+      an error.  (David R. Staples, Dave Dykstra)
+
+    * Fixed bug in --copy-unsafe-links that caused it to be completely
+      broken.  (Dave Dykstra)
+
+    * Prevent infinite recursion in cleanup code under certain circumstances.
+      (Sviatoslav Sviridov and Marc Espie)
+
+    * Fixed a bug that prevented rsync from creating intervening directories
+      when --relative-paths/-R is set.  (Craig Barratt)
+
+    * Prevent "Connection reset by peer" messages from Cygwin. (Randy O'Meara)
+
+  INTERNAL:
+
+    * Many code cleanups and improved internal documentation.  (Martin
+      Pool, Nelson Beebe)
+
+    * Portability fixes. (Dave Dykstra and Wayne Davison)
+
+    * More test cases.  (Martin Pool)
+
+    * Some test-case fixes.  (Brian Poole, Wayne Davison)
+
+    * Updated included popt to the latest vendor drop, version 1.6.4.
+      (Jos Backus)
+
+    * Updated config.guess and config.sub to latest versions; this
+      means rsync should build on more platforms.  (Paul Green)
+
+
+NEWS for rsync 2.5.5, aka Snowy River (2 Apr 2002)
+Protocol: 26 (unchanged)
+Changes since 2.5.4:
 
   ENHANCEMENTS:
 
     * With --progress, when a transfer is complete show the time taken;
       otherwise show expected time to complete. (Cameron Simpson)
 
@@ -34,46 +140,46 @@
       <http://www.opensource.apple.com/bugs/X/BSD%20Kernel/2734739.html>
       (Martin Pool)
 
     * Improved network error handling.  (Greg A. Woods)
 
 
-rsync 2.5.4 (13 March 2002)
-
-  "Imitation lizard skin"
+NEWS for rsync 2.5.4, aka "Imitation lizard skin" (13 Mar 2002)
+Protocol: 26 (unchanged)
+Changes since 2.5.3:
 
   BUG FIXES:
 
     * Additional fix for zlib double-free bug.  (Martin Pool, Andrew
       Tridgell) (CVE CAN-2002-0059)
- 
+
   ENHANCEMENTS:
 
     * Merge in changes from zlib 1.1.3 to zlib 1.1.4.  (Jos Backus)
       (Note that rsync still uses a custom version of zlib; you can
       not just link against a system library.  See zlib/README.rsync)
 
     * Additional test cases for --compress.  (Martin Pool)
 
 
-rsync 2.5.3 (11 March 2002)
-
-  "Happy 26"
+NEWS for rsync 2.5.3, aka "Happy 26" (11 Mar 2002)
+Protocol: 26 (unchanged)
+Changes since 2.5.2:
 
   SECURITY FIXES:
 
     * Make sure that supplementary groups are removed from a server
       process after changing uid and gid. (Ethan Benson) (Debian bug
       #132272, CVE CAN-2002-0080)
 
   BUG FIXES:
 
     * Fix zlib double-free bug.  (Owen Taylor, Mark J Cox) (CVE
       CAN-2002-0059)
 
-    * Fixed problem that in many cases caused the error message 
+    * Fixed problem that in many cases caused the error message
 	unexpected read size of 0 in map_ptr
       and resulted in the wrong data being copied.
 
     * Fixed compilation errors on some systems caused by the use of
       "unsigned int64" in rsync.h.
 
@@ -88,13 +194,13 @@
 
   ENHANCEMENTS:
 
     * Merge in changes from zlib 1.1.2 to zlib 1.1.3.  (Note that
       rsync still uses a custom version of zlib; you can not just link
       against a system library.  See zlib/README.rsync)
- 
+
     * Command to initiate connections is only shown with -vv, rather
       than -v as in 2.5.2.  Output from plain -v is more similar to
       what was historically used so as not to break scripts that try
       to parse the output.
 
     * Added --no-whole-file and --no-blocking-io options (Dave Dykstra)
@@ -102,13 +208,16 @@
     * Made the --write-batch and --read-batch options actually work
       and added documentation in the man page (Jos Backus)
 
     * If the daemon is unable to fork a child to accept a connection,
       print an error message.  (Colin Walters)
 
-rsync 2.5.2 (26 Jan 2002)
+
+NEWS for rsync 2.5.2 (26 Jan 2002)
+Protocol: 26 (changed)
+Changes since 2.5.1:
 
   SECURITY FIXES:
 
     * Signedness security patch from Sebastian Krahmer
       <krahmer@suse.de> -- in some cases we were not sufficiently
       careful about reading integers from the network.
@@ -129,29 +238,32 @@
   ENHANCEMENTS:
 
     * With -v, rsync now shows the command used to initiate an ssh/rsh
       connection.
 
     * --statistics now shows memory heap usage on platforms that
-        support mallinfo().
+      support mallinfo().
 
     * "The Ted T'so school of program optimization": make progress
       visible and people will think it's faster.  (With --progress,
       rsync will show you how many files it has seen as it builds the
       file_list, giving some indication that it has not hung.)
 
     * Improvements to batch mode support.  This is still experimental
       but testing would be welcome.   (Jos Backus)
- 
+
     * New --ignore-existing option, patch previously distributed with
       Vipul's Razor.  (Debian #124286)
 
-rsync 2.5.1 (2002-01-03)
+
+NEWS for rsync 2.5.1 (3 Jan 2002)
+Protocol: 25 (unchanged)
+Changes since 2.5.0:
+
+  BUG FIXES:
 
-  BUG FIXES: 
-   
     * Fix for segfault in --daemon mode configuration parser.  (Paul
       Mackerras)
 
     * Correct string<->address parsing for both IPv4 and 6.
       (YOSHIFUJI Hideaki, SUMIKAWA Munechika and Jun-ichiro "itojun"
       Hagino)
@@ -167,23 +279,25 @@
 
     * Correction to ./configure tests for inet_ntop.  (Jeff Garzik)
 
   ENHANCEMENTS:
 
     * --progress and -P now show estimated data transfer rate (in a
-        multiple of bytes/s) and estimated time to completion.  (Rik
-        Faith)
-   
+      multiple of bytes/s) and estimated time to completion.  (Rik
+      Faith)
+
     * --no-detach option, required to run as a W32 service and also
-        useful when running on Unix under daemontools, AIX's SRC, or a
-        debugger.  (Max Bowsher, Jos Backus)
+      useful when running on Unix under daemontools, AIX's SRC, or a
+      debugger.  (Max Bowsher, Jos Backus)
 
     * Clearer error messages for some conditions.
 
 
-rsync 2.5.0 (2001-11-30)
+NEWS for rsync 2.5.0 (30 Nov 2001)
+Protocol: 25 (changed)
+Changes since 2.4.6:
 
   ANNOUNCEMENTS
 
     * Martin Pool <mbp@samba.org> is now a co-maintainer.
 
   NEW FEATURES
@@ -239,13 +353,13 @@
 
     * Attempt to fix Large File Summit support on AIX.
 
     * Attempt to fix error handling lockup bug.
 
     * Give a non-0 exit code if *any* of the files we have been asked
-      to transfer fail to transfer 
+      to transfer fail to transfer.
 
     * For log messages containing ridiculously long strings that might
       overflow a buffer rsync no longer aborts, but rather prints an
       ellipsis at the end of the string.  (Patch from Ed Santiago.)
 
   PLATFORMS:
@@ -291,6 +405,51 @@
 
   TESTING:
 
     * The existing test.sh script by Phil Hands has been merged into a
       test framework that works from both "make check" and the Samba
       build farm.
+
+Partial Protocol History
+	RELEASE DATE	VER.	DATE OF COMMIT	PROTOCOL
+	01 Jan 2004	2.6.0	10 Apr 2003	27 (MAX=40)
+	04 Dec 2003	2.5.7			26
+	26 Jan 2003	2.5.6			26
+	02 Apr 2002	2.5.5			26
+	13 Mar 2002	2.5.4			26
+	11 Mar 2002	2.5.3			26
+	26 Jan 2002	2.5.2	11 Jan 2002	26
+	03 Jan 2002	2.5.1			25
+	30 Nov 2001	2.5.0	23 Aug 2001	25
+	06 Sep 2000	2.4.6			24
+	19 Aug 2000	2.4.5			24
+	29 Jul 2000	2.4.4			24
+	09 Apr 2000	2.4.3			24
+	30 Mar 2000	2.4.2			24
+	30 Jan 2000	2.4.1	29 Jan 2000	24
+	29 Jan 2000	2.4.0	28 Jan 2000	23
+	25 Jan 2000	2.3.3	23 Jan 2000	22
+	08 Nov 1999	2.3.2	26 Jun 1999	21
+	06 Apr 1999	2.3.1			20
+	15 Mar 1999	2.3.0	15 Mar 1999	20
+	25 Nov 1998	2.2.1			19
+	03 Nov 1998	2.2.0			19
+	09 Sep 1998	2.1.1			19
+	20 Jul 1998	2.1.0			19
+	17 Jul 1998	2.0.19			19
+	18 Jun 1998	2.0.17			19
+	01 Jun 1998	2.0.16			19
+	27 May 1998	2.0.13	27 May 1998	19
+	26 May 1998	2.0.12			18
+	22 May 1998	2.0.11			18
+	18 May 1998	2.0.9	18 May 1998	18
+	17 May 1998	2.0.8			17
+	15 May 1998	2.0.1			17
+	14 May 1998	2.0.0			17
+	17 Apr 1998	1.7.4			17
+	13 Apr 1998	1.7.3			17
+	05 Apr 1998	1.7.2			17
+	26 Mar 1998	1.7.1			17
+	26 Mar 1998	1.7.0	26 Mar 1998	17 (MAX=30)
+	13 Jan 1998	1.6.9	13 Jan 1998	15 (MAX=20)
+
+* DATE OF COMMIT is the date the protocol change was committed to CVS.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/options.c	2003-01-28 11:11:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/options.c	2003-12-31 02:16:25.000000000 +0800
@@ -1,43 +1,44 @@
 /*  -*- c-file-style: "linux" -*-
- * 
+ *
  * Copyright (C) 1998-2001 by Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2000, 2001, 2002 by Martin Pool <mbp@samba.org>
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "rsync.h"
 #include "popt.h"
 
+extern struct exclude_struct **exclude_list;
+
 int make_backups = 0;
 
 /**
- * If True, send the whole file as literal data rather than trying to
+ * If 1, send the whole file as literal data rather than trying to
  * create an incremental diff.
  *
- * If both are 0, then look at whether we're local or remote and go by
- * that.
+ * If -1, then look at whether we're local or remote and go by that.
  *
  * @sa disable_deltas_p()
  **/
-int whole_file = 0;
-int no_whole_file = 0;
+int whole_file = -1;
 
+int archive_mode = 0;
 int copy_links = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
 int preserve_perms = 0;
 int preserve_devices = 0;
 int preserve_uid = 0;
@@ -48,35 +49,39 @@
 int dry_run=0;
 int local_server=0;
 int ignore_times=0;
 int delete_mode=0;
 int delete_excluded=0;
 int one_file_system=0;
-int remote_version=0;
+int protocol_version = PROTOCOL_VERSION;
 int sparse_files=0;
 int do_compression=0;
 int am_root=0;
 int orig_umask=0;
-int relative_paths=0;
+int relative_paths = -1;
+int implied_dirs = 1;
 int numeric_ids = 0;
 int force_delete = 0;
 int io_timeout = 0;
-int io_error = 0;
 int read_only = 0;
 int module_id = -1;
 int am_server = 0;
 int am_sender = 0;
+char *files_from = NULL;
+int filesfrom_fd = -1;
+char *remote_filesfrom_file = NULL;
+int eol_nulls = 0;
 int recurse = 0;
 int am_daemon = 0;
 int daemon_over_rsh = 0;
 int do_stats=0;
 int do_progress=0;
 int keep_partial=0;
 int safe_symlinks=0;
 int copy_unsafe_links=0;
-int block_size=BLOCK_SIZE;
+int block_size=0;
 int size_only=0;
 int bwlimit=0;
 int delete_after=0;
 int only_existing=0;
 int opt_ignore_existing=0;
 int max_delete=0;
@@ -96,15 +101,16 @@
  * for debugging and required for running as a service on W32,
  * or under Unix process-monitors. **/
 int no_detach = 0;
 
 int write_batch = 0;
 int read_batch = 0;
-int suffix_specified = 0;
+int backup_dir_len = 0;
+int backup_suffix_len;
 
-char *backup_suffix = BACKUP_SUFFIX;
+char *backup_suffix = NULL;
 char *tmpdir = NULL;
 char *compare_dest = NULL;
 char *config_file = NULL;
 char *shell_cmd = NULL;
 char *log_format = NULL;
 char *password_file = NULL;
@@ -147,29 +153,29 @@
 #if SUPPORT_LINKS
         links = "";
 #endif
 
 #if INET6
 	ipv6 = "";
-#endif       
+#endif
 
         rprintf(f, "%s  version %s  protocol version %d\n",
                 RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
         rprintf(f,
-                "Copyright (C) 1996-2002 by Andrew Tridgell and others\n");
+		"Copyright (C) 1996-2004 by Andrew Tridgell and others\n");
 	rprintf(f, "<http://rsync.samba.org/>\n");
         rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
                 "%shard links, %ssymlinks, batchfiles, \n",
                 (int) (sizeof(OFF_T) * 8),
                 got_socketpair, hardlinks, links);
 
 	/* Note that this field may not have type ino_t.  It depends
 	 * on the complicated interaction between largefile feature
 	 * macros. */
 	rprintf(f, "              %sIPv6, %d-bit system inums, %d-bit internal inums\n",
-		ipv6, 
+		ipv6,
 		(int) (sizeof(dumstat->st_ino) * 8),
 		(int) (sizeof(INO64_T) * 8));
 #ifdef MAINTAINER_MODE
 	rprintf(f, "              panic action: \"%s\"\n",
 		get_panic_action());
 #endif
@@ -207,68 +213,73 @@
   rprintf(F," -v, --verbose               increase verbosity\n");
   rprintf(F," -q, --quiet                 decrease verbosity\n");
   rprintf(F," -c, --checksum              always checksum\n");
   rprintf(F," -a, --archive               archive mode, equivalent to -rlptgoD\n");
   rprintf(F," -r, --recursive             recurse into directories\n");
   rprintf(F," -R, --relative              use relative path names\n");
-  rprintf(F," -b, --backup                make backups (default %s suffix)\n",BACKUP_SUFFIX);
+  rprintf(F,"     --no-relative           turn off --relative\n");
+  rprintf(F,"     --no-implied-dirs       don't send implied dirs with -R\n");
+  rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
   rprintf(F,"     --backup-dir            make backups into this directory\n");
-  rprintf(F,"     --suffix=SUFFIX         override backup suffix\n");  
+  rprintf(F,"     --suffix=SUFFIX         backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
   rprintf(F," -u, --update                update only (don't overwrite newer files)\n");
   rprintf(F," -l, --links                 copy symlinks as symlinks\n");
   rprintf(F," -L, --copy-links            copy the referent of symlinks\n");
   rprintf(F,"     --copy-unsafe-links     copy links outside the source tree\n");
   rprintf(F,"     --safe-links            ignore links outside the destination tree\n");
   rprintf(F," -H, --hard-links            preserve hard links\n");
   rprintf(F," -p, --perms                 preserve permissions\n");
   rprintf(F," -o, --owner                 preserve owner (root only)\n");
   rprintf(F," -g, --group                 preserve group\n");
   rprintf(F," -D, --devices               preserve devices (root only)\n");
-  rprintf(F," -t, --times                 preserve times\n");  
+  rprintf(F," -t, --times                 preserve times\n");
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
   rprintf(F," -n, --dry-run               show what would have been transferred\n");
   rprintf(F," -W, --whole-file            copy whole files, no incremental checks\n");
   rprintf(F,"     --no-whole-file         turn off --whole-file\n");
   rprintf(F," -x, --one-file-system       don't cross filesystem boundaries\n");
-  rprintf(F," -B, --block-size=SIZE       checksum blocking size (default %d)\n",BLOCK_SIZE);  
+  rprintf(F," -B, --block-size=SIZE       checksum blocking size (default %d)\n",BLOCK_SIZE);
   rprintf(F," -e, --rsh=COMMAND           specify the remote shell\n");
   rprintf(F,"     --rsync-path=PATH       specify path to rsync on the remote machine\n");
-  rprintf(F," -C, --cvs-exclude           auto ignore files in the same way CVS does\n");
   rprintf(F,"     --existing              only update files that already exist\n");
-  rprintf(F,"     --ignore-existing       ignore files that already exist on the receiving side\n");
+  rprintf(F,"     --ignore-existing       ignore files that already exist on receiving side\n");
   rprintf(F,"     --delete                delete files that don't exist on the sending side\n");
   rprintf(F,"     --delete-excluded       also delete excluded files on the receiving side\n");
   rprintf(F,"     --delete-after          delete after transferring, not before\n");
   rprintf(F,"     --ignore-errors         delete even if there are IO errors\n");
   rprintf(F,"     --max-delete=NUM        don't delete more than NUM files\n");
   rprintf(F,"     --partial               keep partially transferred files\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
   rprintf(F,"     --timeout=TIME          set IO timeout in seconds\n");
-  rprintf(F," -I, --ignore-times          don't exclude files that match length and time\n");
-  rprintf(F,"     --size-only             only use file size when determining if a file should be transferred\n");
-  rprintf(F,"     --modify-window=NUM     Timestamp window (seconds) for file match (default=%d)\n",modify_window);
+  rprintf(F," -I, --ignore-times          turn off mod time & file size quick check\n");
+  rprintf(F,"     --size-only             ignore mod time for quick check (use size)\n");
+  rprintf(F,"     --modify-window=NUM     compare mod times with reduced accuracy\n");
   rprintf(F," -T  --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
+  rprintf(F,"     --link-dest=DIR         create hardlinks to DIR for unchanged files\n");
   rprintf(F," -P                          equivalent to --partial --progress\n");
   rprintf(F," -z, --compress              compress file data\n");
+  rprintf(F," -C, --cvs-exclude           auto ignore files in the same way CVS does\n");
   rprintf(F,"     --exclude=PATTERN       exclude files matching PATTERN\n");
   rprintf(F,"     --exclude-from=FILE     exclude patterns listed in FILE\n");
   rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
   rprintf(F,"     --include-from=FILE     don't exclude patterns listed in FILE\n");
-  rprintf(F,"     --version               print version number\n");  
-  rprintf(F,"     --daemon                run as a rsync daemon\n");  
-  rprintf(F,"     --no-detach             do not detach from the parent\n");  
-  rprintf(F,"     --address=ADDRESS       bind to the specified address\n");  
-  rprintf(F,"     --config=FILE           specify alternate rsyncd.conf file\n");  
+  rprintf(F,"     --files-from=FILE       read FILE for list of source-file names\n");
+  rprintf(F," -0  --from0                 all *-from file lists are delimited by nulls\n");
+  rprintf(F,"     --version               print version number\n");
+  rprintf(F,"     --daemon                run as a rsync daemon\n");
+  rprintf(F,"     --no-detach             do not detach from the parent\n");
+  rprintf(F,"     --address=ADDRESS       bind to the specified address\n");
+  rprintf(F,"     --config=FILE           specify alternate rsyncd.conf file\n");
   rprintf(F,"     --port=PORT             specify alternate rsyncd port number\n");
-  rprintf(F,"     --blocking-io           use blocking IO for the remote shell\n");  
-  rprintf(F,"     --no-blocking-io        turn off --blocking-io\n");  
-  rprintf(F,"     --stats                 give some file transfer stats\n");  
-  rprintf(F,"     --progress              show progress during transfer\n");  
-  rprintf(F,"     --log-format=FORMAT     log file transfers using specified format\n");  
+  rprintf(F,"     --blocking-io           use blocking IO for the remote shell\n");
+  rprintf(F,"     --no-blocking-io        turn off --blocking-io\n");
+  rprintf(F,"     --stats                 give some file transfer stats\n");
+  rprintf(F,"     --progress              show progress during transfer\n");
+  rprintf(F,"     --log-format=FORMAT     log file transfers using specified format\n");
   rprintf(F,"     --password-file=FILE    get password from FILE\n");
   rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth, KBytes per second\n");
   rprintf(F,"     --write-batch=PREFIX    write batch fileset starting with PREFIX\n");
   rprintf(F,"     --read-batch=PREFIX     read batch fileset starting with PREFIX\n");
   rprintf(F," -h, --help                  show this help screen\n");
 #ifdef INET6
@@ -279,99 +290,98 @@
   rprintf(F,"\n");
 
   rprintf(F,"\nPlease see the rsync(1) and rsyncd.conf(5) man pages for full documentation\n");
   rprintf(F,"See http://rsync.samba.org/ for updates, bug reports, and answers\n");
 }
 
-enum {OPT_VERSION = 1000, OPT_SUFFIX, OPT_SENDER, OPT_SERVER, OPT_EXCLUDE,
-      OPT_EXCLUDE_FROM, OPT_DELETE, OPT_DELETE_EXCLUDED, OPT_NUMERIC_IDS,
-      OPT_RSYNC_PATH, OPT_FORCE, OPT_TIMEOUT, OPT_DAEMON, OPT_CONFIG, OPT_PORT,
-      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_STATS, OPT_PARTIAL, OPT_PROGRESS,
-      OPT_COPY_UNSAFE_LINKS, OPT_SAFE_LINKS, OPT_COMPARE_DEST, OPT_LINK_DEST,
-      OPT_LOG_FORMAT, OPT_PASSWORD_FILE, OPT_SIZE_ONLY, OPT_ADDRESS,
-      OPT_DELETE_AFTER, OPT_EXISTING, OPT_MAX_DELETE, OPT_BACKUP_DIR, 
-      OPT_IGNORE_ERRORS, OPT_BWLIMIT, OPT_BLOCKING_IO,
-      OPT_NO_BLOCKING_IO, OPT_WHOLE_FILE, OPT_NO_WHOLE_FILE,
-      OPT_MODIFY_WINDOW, OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_IGNORE_EXISTING};
+enum {OPT_VERSION = 1000, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
+      OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_LINK_DEST,
+      OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
+      OPT_READ_BATCH, OPT_WRITE_BATCH};
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
-  {"version",          0,  POPT_ARG_NONE,   0,             OPT_VERSION, 0, 0},
-  {"suffix",           0,  POPT_ARG_STRING, &backup_suffix,	OPT_SUFFIX, 0, 0 },
+  {"version",          0,  POPT_ARG_NONE,   0,              OPT_VERSION, 0, 0},
+  {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
   {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path,	0, 0, 0 },
   {"password-file",    0,  POPT_ARG_STRING, &password_file,	0, 0, 0 },
-  {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times , 0, 0, 0 },
-  {"size-only",        0,  POPT_ARG_NONE,   &size_only , 0, 0, 0 },
+  {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
+  {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
-  {"one-file-system", 'x', POPT_ARG_NONE,   &one_file_system , 0, 0, 0 },
-  {"delete",           0,  POPT_ARG_NONE,   &delete_mode , 0, 0, 0 },
-  {"existing",         0,  POPT_ARG_NONE,   &only_existing , 0, 0, 0 },
-  {"ignore-existing",  0,  POPT_ARG_NONE,   &opt_ignore_existing , 0, 0, 0 },
+  {"one-file-system", 'x', POPT_ARG_NONE,   &one_file_system, 0, 0, 0 },
+  {"delete",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },
+  {"existing",         0,  POPT_ARG_NONE,   &only_existing, 0, 0, 0 },
+  {"ignore-existing",  0,  POPT_ARG_NONE,   &opt_ignore_existing, 0, 0, 0 },
   {"delete-after",     0,  POPT_ARG_NONE,   0,              OPT_DELETE_AFTER, 0, 0 },
   {"delete-excluded",  0,  POPT_ARG_NONE,   0,              OPT_DELETE_EXCLUDED, 0, 0 },
-  {"force",            0,  POPT_ARG_NONE,   &force_delete , 0, 0, 0 },
-  {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids , 0, 0, 0 },
+  {"force",            0,  POPT_ARG_NONE,   &force_delete, 0, 0, 0 },
+  {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
   {"exclude",          0,  POPT_ARG_STRING, 0,              OPT_EXCLUDE, 0, 0 },
   {"include",          0,  POPT_ARG_STRING, 0,              OPT_INCLUDE, 0, 0 },
   {"exclude-from",     0,  POPT_ARG_STRING, 0,              OPT_EXCLUDE_FROM, 0, 0 },
   {"include-from",     0,  POPT_ARG_STRING, 0,              OPT_INCLUDE_FROM, 0, 0 },
-  {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks , 0, 0, 0 },
+  {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
   {"help",            'h', POPT_ARG_NONE,   0,              'h', 0, 0 },
-  {"backup",          'b', POPT_ARG_NONE,   &make_backups , 0, 0, 0 },
-  {"dry-run",         'n', POPT_ARG_NONE,   &dry_run , 0, 0, 0 },
-  {"sparse",          'S', POPT_ARG_NONE,   &sparse_files , 0, 0, 0 },
-  {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude , 0, 0, 0 },
-  {"update",          'u', POPT_ARG_NONE,   &update_only , 0, 0, 0 },
-  {"links",           'l', POPT_ARG_NONE,   &preserve_links , 0, 0, 0 },
-  {"copy-links",      'L', POPT_ARG_NONE,   &copy_links , 0, 0, 0 },
-  {"whole-file",      'W', POPT_ARG_NONE,   0,              OPT_WHOLE_FILE, 0, 0 },
-  {"no-whole-file",    0,  POPT_ARG_NONE,   0,              OPT_NO_WHOLE_FILE, 0, 0 },
-  {"copy-unsafe-links", 0, POPT_ARG_NONE,   &copy_unsafe_links , 0, 0, 0 },
-  {"perms",           'p', POPT_ARG_NONE,   &preserve_perms , 0, 0, 0 },
-  {"owner",           'o', POPT_ARG_NONE,   &preserve_uid , 0, 0, 0 },
-  {"group",           'g', POPT_ARG_NONE,   &preserve_gid , 0, 0, 0 },
-  {"devices",         'D', POPT_ARG_NONE,   &preserve_devices , 0, 0, 0 },
-  {"times",           't', POPT_ARG_NONE,   &preserve_times , 0, 0, 0 },
-  {"checksum",        'c', POPT_ARG_NONE,   &always_checksum , 0, 0, 0 },
+  {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
+  {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
+  {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
+  {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
+  {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
+  {"links",           'l', POPT_ARG_NONE,   &preserve_links, 0, 0, 0 },
+  {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
+  {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
+  {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
+  {"copy-unsafe-links", 0, POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
+  {"perms",           'p', POPT_ARG_NONE,   &preserve_perms, 0, 0, 0 },
+  {"owner",           'o', POPT_ARG_NONE,   &preserve_uid, 0, 0, 0 },
+  {"group",           'g', POPT_ARG_NONE,   &preserve_gid, 0, 0, 0 },
+  {"devices",         'D', POPT_ARG_NONE,   &preserve_devices, 0, 0, 0 },
+  {"times",           't', POPT_ARG_NONE,   &preserve_times, 0, 0, 0 },
+  {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
   {"verbose",         'v', POPT_ARG_NONE,   0,               'v', 0, 0 },
   {"quiet",           'q', POPT_ARG_NONE,   0,               'q', 0, 0 },
-  {"archive",         'a', POPT_ARG_NONE,   0,               'a', 0, 0 }, 
-  {"server",           0,  POPT_ARG_NONE,   &am_server , 0, 0, 0 },
-  {"sender",           0,  POPT_ARG_NONE,   0,               OPT_SENDER, 0, 0 },
-  {"recursive",       'r', POPT_ARG_NONE,   &recurse , 0, 0, 0 },
-  {"relative",        'R', POPT_ARG_NONE,   &relative_paths , 0, 0, 0 },
-  {"rsh",             'e', POPT_ARG_STRING, &shell_cmd , 0, 0, 0 },
-  {"block-size",      'B', POPT_ARG_INT,    &block_size , 0, 0, 0 },
-  {"max-delete",       0,  POPT_ARG_INT,    &max_delete , 0, 0, 0 },
-  {"timeout",          0,  POPT_ARG_INT,    &io_timeout , 0, 0, 0 },
-  {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir , 0, 0, 0 },
-  {"compare-dest",     0,  POPT_ARG_STRING, &compare_dest , 0, 0, 0 },
-  {"link-dest",        0,  POPT_ARG_STRING, 0,               OPT_LINK_DEST, 0, 0 },
+  {"archive",         'a', POPT_ARG_NONE,   &archive_mode, 0, 0, 0 },
+  {"server",           0,  POPT_ARG_NONE,   &am_server, 0, 0, 0 },
+  {"sender",           0,  POPT_ARG_NONE,   0,              OPT_SENDER, 0, 0 },
+  {"recursive",       'r', POPT_ARG_NONE,   &recurse, 0, 0, 0 },
+  {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
+  {"no-relative",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
+  {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
+  {"block-size",      'B', POPT_ARG_INT,    &block_size, 0, 0, 0 },
+  {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
+  {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
+  {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
+  {"compare-dest",     0,  POPT_ARG_STRING, &compare_dest, 0, 0, 0 },
+  {"link-dest",        0,  POPT_ARG_STRING, 0,              OPT_LINK_DEST, 0, 0 },
   /* TODO: Should this take an optional int giving the compression level? */
-  {"compress",        'z', POPT_ARG_NONE,   &do_compression , 0, 0, 0 },
-  {"daemon",           0,  POPT_ARG_NONE,   &am_daemon , 0, 0, 0 },
-  {"no-detach",        0,  POPT_ARG_NONE,   &no_detach , 0, 0, 0 },
-  {"stats",            0,  POPT_ARG_NONE,   &do_stats , 0, 0, 0 },
-  {"progress",         0,  POPT_ARG_NONE,   &do_progress , 0, 0, 0 },
-  {"partial",          0,  POPT_ARG_NONE,   &keep_partial , 0, 0, 0 },
-  {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors , 0, 0, 0 },
-  {"blocking-io",      0,  POPT_ARG_NONE,   &blocking_io , 0, 0, 0 },
-  {"no-blocking-io",   0,  POPT_ARG_NONE,   0, 		     OPT_NO_BLOCKING_IO, 0, 0 },
-  {0,                 'P', POPT_ARG_NONE,   0,               'P', 0, 0 },
-  {"config",           0,  POPT_ARG_STRING, &config_file , 0, 0, 0 },
-  {"port",             0,  POPT_ARG_INT,    &rsync_port , 0, 0, 0 },
-  {"log-format",       0,  POPT_ARG_STRING, &log_format , 0, 0, 0 },
-  {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit , 0, 0, 0 },
+  {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
+  {"daemon",           0,  POPT_ARG_NONE,   &am_daemon, 0, 0, 0 },
+  {"no-detach",        0,  POPT_ARG_NONE,   &no_detach, 0, 0, 0 },
+  {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
+  {"progress",         0,  POPT_ARG_NONE,   &do_progress, 0, 0, 0 },
+  {"partial",          0,  POPT_ARG_NONE,   &keep_partial, 0, 0, 0 },
+  {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
+  {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
+  {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
+  {0,                 'P', POPT_ARG_NONE,   0,              'P', 0, 0 },
+  {"config",           0,  POPT_ARG_STRING, &config_file, 0, 0, 0 },
+  {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
+  {"log-format",       0,  POPT_ARG_STRING, &log_format, 0, 0, 0 },
+  {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
   {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
-  {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir , 0, 0, 0 },
-  {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links , 0, 0, 0 },
-  {"read-batch",       0,  POPT_ARG_STRING, &batch_prefix, OPT_READ_BATCH, 0, 0 },
-  {"write-batch",      0,  POPT_ARG_STRING, &batch_prefix, OPT_WRITE_BATCH, 0, 0 },
+  {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
+  {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links, 0, 0, 0 },
+  {"read-batch",       0,  POPT_ARG_STRING, &batch_prefix,  OPT_READ_BATCH, 0, 0 },
+  {"write-batch",      0,  POPT_ARG_STRING, &batch_prefix,  OPT_WRITE_BATCH, 0, 0 },
+  {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
+  {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
+  {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
+  {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
 #ifdef INET6
-  {0,		      '4', POPT_ARG_VAL,    &default_af_hint,   AF_INET , 0, 0 },
-  {0,		      '6', POPT_ARG_VAL,    &default_af_hint,   AF_INET6 , 0, 0 },
+  {0,		      '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
+  {0,		      '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
 #endif
   {0,0,0,0, 0, 0, 0}
 };
 
 
 static char err_buf[100];
@@ -383,13 +393,13 @@
  * show the error later on.
  **/
 void option_error(void)
 {
 	if (err_buf[0]) {
 		rprintf(FLOG, "%s", err_buf);
-		rprintf(FERROR, "%s: %s", RSYNC_NAME, err_buf);
+		rprintf(FERROR, RSYNC_NAME ": %s", err_buf);
 	} else {
 		rprintf (FERROR, "Error parsing options: "
 			 "option may be supported on client but not on server?\n");
 		rprintf (FERROR, RSYNC_NAME ": Error parsing options: "
 			 "option may be supported on client but not on server?\n");
 	}
@@ -405,13 +415,13 @@
 	char *p;
 	const char *name;
 
 	for (i=0; long_options[i].longName; i++) {
 		if (long_options[i].val == opt) break;
 	}
-	
+
 	if (!long_options[i].longName) return 0;
 
 	name = long_options[i].longName;
 	len = strlen(name);
 
 	while ((p = strstr(ref,name))) {
@@ -430,13 +440,13 @@
 static int count_args(char const **argv)
 {
         int i = 0;
 
         while (argv[i] != NULL)
                 i++;
-        
+
         return i;
 }
 
 
 /**
  * Process command line arguments.  Called on both local and remote.
@@ -467,20 +477,13 @@
                  * only special cases are returned and listed here. */
 
 		switch (opt) {
 		case OPT_VERSION:
                         print_rsync_version(FINFO);
 			exit_cleanup(0);
-			
-		case OPT_SUFFIX:
-                        /* The value has already been set by popt, but
-                         * we need to remember that a suffix was specified
-                         * in case a backup-directory is used. */
-                        suffix_specified = 1;
-			break;
-			
+
 		case OPT_MODIFY_WINDOW:
                         /* The value has already been set by popt, but
                          * we need to remember that we're using a
                          * non-default setting. */
 			modify_window_set = 1;
 			break;
@@ -493,39 +496,29 @@
 		case OPT_DELETE_EXCLUDED:
 			delete_excluded = 1;
 			delete_mode = 1;
 			break;
 
 		case OPT_EXCLUDE:
-			add_exclude(poptGetOptArg(pc), 0);
+			add_exclude(&exclude_list, poptGetOptArg(pc),
+				    ADD_EXCLUDE);
 			break;
 
 		case OPT_INCLUDE:
-			add_exclude(poptGetOptArg(pc), 1);
+			add_exclude(&exclude_list, poptGetOptArg(pc),
+				    ADD_INCLUDE);
 			break;
 
 		case OPT_EXCLUDE_FROM:
-			add_exclude_file(poptGetOptArg(pc), 1, 0);
+			add_exclude_file(&exclude_list, poptGetOptArg(pc),
+					 MISSING_FATAL, ADD_EXCLUDE);
 			break;
 
 		case OPT_INCLUDE_FROM:
-			add_exclude_file(poptGetOptArg(pc), 1, 1);
-			break;
-
-		case OPT_WHOLE_FILE:
-			whole_file = 1;
-			no_whole_file = 0;
-			break;
-
-		case OPT_NO_WHOLE_FILE:
-			no_whole_file = 1;
-			whole_file = 0;
-			break;
-
-		case OPT_NO_BLOCKING_IO:
-			blocking_io = 0;
+			add_exclude_file(&exclude_list, poptGetOptArg(pc),
+					 MISSING_FATAL, ADD_INCLUDE);
 			break;
 
 		case 'h':
 			usage(FINFO);
 			exit_cleanup(0);
 
@@ -536,40 +529,28 @@
                         /* FIXME: Don't say "server" if this is
                          * happening on the client. */
                         /* FIXME: Why do we have the duplicated
                          * rprintf?  Everybody who gets this message
                          * ought to send it to the client and also to
                          * the logs. */
-			snprintf(err_buf,sizeof(err_buf),
+			snprintf(err_buf, sizeof err_buf,
                                  "hard links are not supported on this %s\n",
 				 am_server ? "server" : "client");
-			rprintf(FERROR,"ERROR: hard links not supported on this platform\n");
+			rprintf(FERROR, "ERROR: %s", err_buf);
 			return 0;
 #endif /* SUPPORT_HARD_LINKS */
 			break;
 
 		case 'v':
 			verbose++;
 			break;
 
 		case 'q':
 			if (frommain) quiet++;
 			break;
 
-		case 'a':
-			recurse=1;
-#if SUPPORT_LINKS
-			preserve_links=1;
-#endif
-			preserve_perms=1;
-			preserve_times=1;
-			preserve_gid=1;
-			preserve_uid=1;
-			preserve_devices=1;
-			break;
-
 		case OPT_SENDER:
 			if (!am_server) {
 				usage(FERROR);
 				exit_cleanup(RERR_SYNTAX);
 			}
 			am_sender = 1;
@@ -592,16 +574,16 @@
 		case OPT_LINK_DEST:
 #if HAVE_LINK
 			compare_dest = (char *)poptGetOptArg(pc);
 			link_dest = 1;
 			break;
 #else
-			snprintf(err_buf,sizeof(err_buf),
+			snprintf(err_buf, sizeof err_buf,
                                  "hard links are not supported on this %s\n",
 				 am_server ? "server" : "client");
-			rprintf(FERROR,"ERROR: hard links not supported on this platform\n");
+			rprintf(FERROR, "ERROR: %s", err_buf);
 			return 0;
 #endif
 
 
 		default:
                         /* FIXME: If --daemon is specified, then errors for later
@@ -613,33 +595,99 @@
                                  poptStrerror(opt));
                         return 0;
 		}
 	}
 
 	if (write_batch && read_batch) {
-	    snprintf(err_buf,sizeof(err_buf),
-		"write-batch and read-batch can not be used together\n");
-	    rprintf(FERROR,"ERROR: write-batch and read-batch"
-		" can not be used together\n");
-	    return 0;
+		rprintf(FERROR,
+			"write-batch and read-batch can not be used together\n");
+		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (do_compression && (write_batch || read_batch)) {
-	    snprintf(err_buf,sizeof(err_buf),
-		"compress can not be used with write-batch or read-batch\n");
-	    rprintf(FERROR,"ERROR: compress can not be used with"
-		"  write-batch or read-batch\n");
-	    return 0;
+		rprintf(FERROR,
+			"compress can not be used with write-batch or read-batch\n");
+		exit_cleanup(RERR_SYNTAX);
+	}
+
+	if (archive_mode) {
+		if (!files_from)
+			recurse = 1;
+#if SUPPORT_LINKS
+		preserve_links = 1;
+#endif
+		preserve_perms = 1;
+		preserve_times = 1;
+		preserve_gid = 1;
+		preserve_uid = 1;
+		preserve_devices = 1;
+	}
+
+	if (relative_paths < 0)
+		relative_paths = files_from? 1 : 0;
+
+	if (!backup_suffix)
+		backup_suffix = backup_dir? "" : BACKUP_SUFFIX;
+	backup_suffix_len = strlen(backup_suffix);
+	if (strchr(backup_suffix, '/') != NULL) {
+		rprintf(FERROR, "--suffix cannot contain slashes: %s\n",
+			backup_suffix);
+		exit_cleanup(RERR_SYNTAX);
+	}
+	if (backup_dir)
+		backup_dir_len = strlen(backup_dir);
+	else if (!backup_suffix_len) {
+		rprintf(FERROR,
+			"--suffix cannot be a null string without --backup-dir\n");
+		exit_cleanup(RERR_SYNTAX);
 	}
 
+	if (do_progress && !verbose)
+		verbose = 1;
+
         *argv = poptGetArgs(pc);
         if (*argv)
                 *argc = count_args(*argv);
         else
                 *argc = 0;
 
+	if (files_from) {
+		char *colon;
+		if (*argc != 2) {
+			usage(FERROR);
+			exit_cleanup(RERR_SYNTAX);
+		}
+		if (strcmp(files_from, "-") == 0) {
+			filesfrom_fd = 0;
+			if (am_server)
+				remote_filesfrom_file = "-";
+		}
+		else if ((colon = find_colon(files_from)) != 0) {
+			if (am_server) {
+				usage(FERROR);
+				exit_cleanup(RERR_SYNTAX);
+			}
+			remote_filesfrom_file = colon+1 + (colon[1] == ':');
+			if (strcmp(remote_filesfrom_file, "-") == 0) {
+				rprintf(FERROR, "Invalid --files-from remote filename\n");
+				exit_cleanup(RERR_SYNTAX);
+			}
+		} else {
+			extern int sanitize_paths;
+			if (sanitize_paths)
+				sanitize_path(strdup(files_from), NULL);
+			filesfrom_fd = open(files_from, O_RDONLY|O_BINARY);
+			if (filesfrom_fd < 0) {
+				rsyserr(FERROR, errno,
+					"failed to open files-from file %s",
+					files_from);
+				exit_cleanup(RERR_FILEIO);
+			}
+		}
+	}
+
 	return 1;
 }
 
 
 /**
  * Construct a filtered list of options to pass through from the
@@ -692,19 +740,18 @@
 		argstr[x++] = 'n';
 	if (preserve_links)
 		argstr[x++] = 'l';
 	if (copy_links)
 		argstr[x++] = 'L';
 
-	assert(whole_file == 0 || whole_file == 1);
-	if (whole_file)
+	if (whole_file > 0)
 		argstr[x++] = 'W';
 	/* We don't need to send --no-whole-file, because it's the
 	 * default for remote transfers, and in any case old versions
 	 * of rsync will not understand it. */
-	
+
 	if (preserve_hard_links)
 		argstr[x++] = 'H';
 	if (preserve_uid)
 		argstr[x++] = 'o';
 	if (preserve_gid)
 		argstr[x++] = 'g';
@@ -728,57 +775,67 @@
 		argstr[x++] = 'x';
 	if (sparse_files)
 		argstr[x++] = 'S';
 	if (do_compression)
 		argstr[x++] = 'z';
 
-	/* this is a complete hack - blame Rusty 
+	/* this is a complete hack - blame Rusty
 
 	   this is a hack to make the list_only (remote file list)
 	   more useful */
-	if (list_only && !recurse) 
+	if (list_only && !recurse)
 		argstr[x++] = 'r';
 
 	argstr[x] = 0;
 
 	if (x != 1) args[ac++] = argstr;
 
-	if (block_size != BLOCK_SIZE) {
+	if (block_size) {
 		snprintf(bsize,sizeof(bsize),"-B%d",block_size);
 		args[ac++] = bsize;
-	}    
+	}
 
 	if (max_delete && am_sender) {
 		snprintf(mdelete,sizeof(mdelete),"--max-delete=%d",max_delete);
 		args[ac++] = mdelete;
-	}    
-	
+	}
+
 	if (batch_prefix != NULL) {
 		char *fmt = "";
 		if (write_batch)
-		    fmt = "--write-batch=%s";
+			fmt = "--write-batch=%s";
 		else
 		if (read_batch)
-		    fmt = "--read-batch=%s";
+			fmt = "--read-batch=%s";
 		snprintf(fext,sizeof(fext),fmt,batch_prefix);
 		args[ac++] = fext;
 	}
 
 	if (io_timeout) {
 		snprintf(iotime,sizeof(iotime),"--timeout=%d",io_timeout);
 		args[ac++] = iotime;
-	}    
+	}
 
 	if (bwlimit) {
 		snprintf(bw,sizeof(bw),"--bwlimit=%d",bwlimit);
 		args[ac++] = bw;
 	}
 
-	if (strcmp(backup_suffix, BACKUP_SUFFIX)) {
-		args[ac++] = "--suffix";
-		args[ac++] = backup_suffix;
+	if (backup_dir) {
+		args[ac++] = "--backup-dir";
+		args[ac++] = backup_dir;
+	}
+
+	/* Only send --suffix if it specifies a non-default value. */
+	if (strcmp(backup_suffix, backup_dir? "" : BACKUP_SUFFIX) != 0) {
+		char *s = new_array(char, 9+backup_suffix_len+1);
+		if (!s)
+			out_of_memory("server_options");
+		/* We use the following syntax to avoid weirdness with '~'. */
+		sprintf(s, "--suffix=%s", backup_suffix);
+		args[ac++] = s;
 	}
 
 	if (delete_mode && !delete_excluded)
 		args[ac++] = "--delete";
 
 	if (delete_excluded)
@@ -814,34 +871,56 @@
 	if (numeric_ids)
 		args[ac++] = "--numeric-ids";
 
 	if (only_existing && am_sender)
 		args[ac++] = "--existing";
 
-	if (opt_ignore_existing && am_sender) 
+	if (opt_ignore_existing && am_sender)
 		args[ac++] = "--ignore-existing";
 
 	if (tmpdir) {
 		args[ac++] = "--temp-dir";
 		args[ac++] = tmpdir;
 	}
 
-	if (backup_dir && am_sender) {
-		/* only the receiver needs this option, if we are the sender
-		 *   then we need to send it to the receiver.
-		 */
-		args[ac++] = "--backup-dir";
-		args[ac++] = backup_dir;
-	}
-
 	if (compare_dest && am_sender) {
 		/* the server only needs this option if it is not the sender,
 		 *   and it may be an older version that doesn't know this
 		 *   option, so don't send it if client is the sender.
 		 */
 		args[ac++] = link_dest ? "--link-dest" : "--compare-dest";
 		args[ac++] = compare_dest;
 	}
 
+	if (files_from && (!am_sender || remote_filesfrom_file)) {
+		if (remote_filesfrom_file) {
+			args[ac++] = "--files-from";
+			args[ac++] = remote_filesfrom_file;
+			if (eol_nulls)
+				args[ac++] = "--from0";
+		} else {
+			args[ac++] = "--files-from=-";
+			args[ac++] = "--from0";
+		}
+	}
+
 	*argc = ac;
 }
 
+/**
+ * Return the position of a ':' IF it is not part of a filename (i.e. as
+ * long as it doesn't occur after a slash.
+ */
+char *find_colon(char *s)
+{
+	char *p, *p2;
+
+	p = strchr(s,':');
+	if (!p) return NULL;
+
+	/* now check to see if there is a / in the string before the : - if there is then
+	   discard the colon on the assumption that the : is part of a filename */
+	p2 = strchr(s,'/');
+	if (p2 && p2 < p) return NULL;
+
+	return p;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/packaging/lsb/rsync.spec	2003-12-04 12:27:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/packaging/lsb/rsync.spec	2004-01-02 03:09:16.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.5.7
+Version: 2.6.0
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.5.7.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-%{version}.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
@@ -18,17 +18,24 @@
 sets of files are present at one of the ends of the link beforehand.
 
 A technical report describing the rsync algorithm is included with
 this package. 
 
 %changelog
-* Mon Sept 11 2000 John H Terpstra <jht@turbolinux.com>
+* Thu Jan 30 2003 Horst von Brand <vonbrand@inf.utfsm.cl>
+  Fixed "Sept" date in %changelog here
+  Use %{_mandir} to point to manpages
+  Support for compressed manpages (* at end catches them in %files)
+  Add doc/README-SGML and doc/rsync.sgml to %doc
+
+* Mon Sep 11 2000 John H Terpstra <jht@turbolinux.com>
   Changed target paths to be Linux Standards Base compliant
 
 * Mon Jan 25 1999 Stefan Hornburg <racke@linuxia.de>
-  quoted RPM_OPT_FLAGS for the sake of robustness  
+  quoted RPM_OPT_FLAGS for the sake of robustness
+
 * Mon May 18 1998 Andrew Tridgell <tridge@samba.anu.edu.au>
   reworked for auto-building when I release rsync (tridge@samba.anu.edu.au)
 
 * Sat May 16 1998 John H Terpstra <jht@aquasoft.com.au>
   Upgraded to Rsync 2.0.6
     -new feature anonymous rsync
@@ -59,26 +66,28 @@
 previous package(s).)
 
 %prep
 %setup
 
 %build
-./configure --prefix=/usr --mandir=/usr/share/man
+./configure --prefix=/usr --mandir=%{_mandir}
 make CFLAGS="$RPM_OPT_FLAGS"
 strip rsync
 
 %install
-mkdir -p $RPM_BUILD_ROOT/usr/{bin,share/man/{man1,man5}}
+mkdir -p $RPM_BUILD_ROOT/usr/bin
+mkdir -p $RPM_BUILD_ROOT/%{_mandir}/man{1,5}
 install -m755 rsync $RPM_BUILD_ROOT/usr/bin
-install -m644 rsync.1 $RPM_BUILD_ROOT/usr/share/man/man1
-install -m644 rsyncd.conf.5 $RPM_BUILD_ROOT/usr/share/man/man5
+install -m644 rsync.1 $RPM_BUILD_ROOT/%{_mandir}/man1
+install -m644 rsyncd.conf.5 $RPM_BUILD_ROOT/%{_mandir}/man5
 
 %clean
 rm -rf $RPM_BUILD_ROOT
 
 %files
 %attr(-,root,root) /usr/bin/rsync
-%attr(-,root,root) /usr/share/man/man1/rsync.1
-%attr(-,root,root) /usr/share/man/man5/rsyncd.conf.5
+%attr(-,root,root) %{_mandir}/man1/rsync.1*
+%attr(-,root,root) %{_mandir}/man5/rsyncd.conf.5*
 %attr(-,root,root) %doc tech_report.tex
 %attr(-,root,root) %doc README
 %attr(-,root,root) %doc COPYING
+%attr(-,root,root) %doc doc/README-SGML doc/rsync.sgml
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/packaging: redhat
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/patches/craigb-perf.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches/craigb-perf.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/patches/craigb-perf.diff	2003-01-15 05:56:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches/craigb-perf.diff	2003-12-24 09:56:24.000000000 +0800
@@ -28,12 +28,14 @@
 
 There are some other unneeded system calls:
 
   - One example is that show_progress() calls gettimeofday() even
     if do_progress is not set.  show_progress() is called on every
     block, so there is an extra system call per (700 byte) block.
+    (NOTE: this was already fixed in 2.6.0, so it is no longer in
+    this patch.)
 
   - Another example is that file_write writes each matching (700 byte)
     block without buffering, so that's another system call per block.
 
 To study this behavior I used rsync-2.5.6cvs and had a benchmark area
 comprising around 7800 files of total size 530MB.
@@ -103,99 +105,107 @@
 a bug caused by a missing io_flush: deadlock is possible, so try
 the patch at your own risk...
 
 Craig
 
 ###########################################################################
-diff -bur rsync/fileio.c rsync-craig/fileio.c
---- rsync/fileio.c	Fri Jan 25 15:07:34 2002
-+++ rsync-craig/fileio.c	Sat Dec  7 22:21:10 2002
-@@ -76,7 +76,35 @@
- 	int ret = 0;
- 
- 	if (!sparse_files) {
--		return write(f,buf,len);
-+		static char *writeBuf;
-+		static size_t writeBufSize;
-+		static size_t writeBufCnt;
+Note: This is an updated patch for 2.6.0, created by Wayne Davison.
+###########################################################################
+--- orig/fileio.c	6 Dec 2003 21:07:27 -0000	1.8
++++ rsync-2.6.0/fileio.c	24 Dec 2003 01:47:40 -0000
+@@ -69,6 +69,21 @@
+ 	return len;
+ }
+ 
 +
-+		if ( !writeBuf ) {
-+		    writeBufSize = MAX_MAP_SIZE;
-+		    writeBufCnt  = 0;
-+		    writeBuf = (char*)malloc(MAX_MAP_SIZE);
-+		    if (!writeBuf) out_of_memory("write_file");
-+		}
-+		ret = len;
-+		do {
-+		    if ( buf && writeBufCnt < writeBufSize ) {
-+			size_t copyLen = len;
-+			if ( copyLen > writeBufSize - writeBufCnt ) {
-+			    copyLen = writeBufSize - writeBufCnt;
-+			}
-+			memcpy(writeBuf + writeBufCnt, buf, copyLen);
-+			writeBufCnt += copyLen;
-+			buf += copyLen;
-+			len -= copyLen;
-+		    }
-+		    if ( !buf || writeBufCnt == writeBufSize ) {
-+			int thisRet = write(f, writeBuf, writeBufCnt);
-+			if ( thisRet < 0 ) return thisRet;
-+			writeBufCnt = 0;
-+		    }
-+		} while ( buf && len > 0 );
++static char *wf_writeBuf;
++static size_t wf_writeBufSize;
++static size_t wf_writeBufCnt;
++
++int flush_write_file(int f)
++{
++	int ret = write(f, wf_writeBuf, wf_writeBufCnt);
++	if (ret < 0)
 +		return ret;
- 	}
- 
- 	while (len>0) {
-diff -bur rsync/flist.c rsync-craig/flist.c
---- rsync/flist.c	Sat Jul 27 11:01:21 2002
-+++ rsync-craig/flist.c	Sun Dec  8 16:28:14 2002
-@@ -889,7 +889,7 @@
++	/* if (ret < wf_writeBufCnt) ??? */
++	wf_writeBufCnt = 0;
++	return ret;
++}
++
+ /*
+  * write_file does not allow incomplete writes.  It loops internally
+  * until len bytes are written or errno is set.
+@@ -83,7 +98,22 @@
+ 			int len1 = MIN(len, SPARSE_WRITE_SIZE);
+ 			r1 = write_sparse(f, buf, len1);
+ 		} else {
+-			r1 = write(f, buf, len);
++			if (!wf_writeBuf) {
++				wf_writeBufSize = MAX_MAP_SIZE;
++				wf_writeBufCnt  = 0;
++				wf_writeBuf = new_array(char, MAX_MAP_SIZE);
++				if (!wf_writeBuf) out_of_memory("write_file");
++			}
++			r1 = MIN(len, wf_writeBufSize - wf_writeBufCnt);
++			if (r1) {
++				memcpy(wf_writeBuf + wf_writeBufCnt, buf, r1);
++				wf_writeBufCnt += r1;
++			}
++			if (wf_writeBufCnt == wf_writeBufSize) {
++				if (flush_write_file(f) < 0) return -1;
++				if (!r1 && len)
++					continue;
++			}
+ 		}
+ 		if (r1 <= 0) {
+ 			if (ret > 0) return ret;
+--- orig/flist.c	15 Dec 2003 08:10:31 -0000	1.144
++++ rsync-2.6.0/flist.c	24 Dec 2003 01:47:40 -0000
+@@ -925,7 +925,7 @@
  	flist = flist_new();
  
  	if (f != -1) {
 -		io_start_buffering(f);
 +		io_start_buffering_out(f);
- 	}
- 
- 	for (i = 0; i < argc; i++) {
-diff -bur rsync/io.c rsync-craig/io.c
---- rsync/io.c	Wed Apr 10 19:11:50 2002
-+++ rsync-craig/io.c	Sun Dec  8 17:54:23 2002
+ 		if (filesfrom_fd >= 0) {
+ 			if (argv[0] && !push_dir(argv[0], 0)) {
+ 				rprintf(FERROR, "push_dir %s failed: %s\n",
+--- orig/io.c	24 Dec 2003 01:46:07 -0000	1.113
++++ rsync-2.6.0/io.c	24 Dec 2003 01:47:41 -0000
 @@ -41,8 +41,8 @@
  
  static int io_multiplexing_out;
  static int io_multiplexing_in;
 -static int multiplex_in_fd;
 -static int multiplex_out_fd;
 +static int multiplex_in_fd = -1;
 +static int multiplex_out_fd = -1;
  static time_t last_io;
  static int no_flush;
  
-@@ -286,17 +286,31 @@
+@@ -440,17 +440,31 @@
  	static size_t remaining;
  	int tag, ret = 0;
  	char line[1024];
-+        static char *buffer;
-+        static size_t bufferIdx = 0;
-+        static size_t bufferSz;
++	static char *buffer;
++	static size_t bufferIdx = 0;
++	static size_t bufferSz;
  
 -	if (!io_multiplexing_in || fd != multiplex_in_fd)
 +	if (fd != multiplex_in_fd)
  		return read_timeout(fd, buf, len);
  
 +	if (!io_multiplexing_in && remaining == 0) {
 +		if (!buffer) {
 +			bufferSz = 2 * IO_BUFFER_SIZE;
-+			buffer   = malloc(bufferSz);
++			buffer   = new_array(char, bufferSz);
 +			if (!buffer) out_of_memory("read_unbuffered");
 +		}
 +		remaining = read_timeout(fd, buffer, bufferSz);
-+                bufferIdx = 0;
-+        }
++		bufferIdx = 0;
++	}
 +
  	while (ret == 0) {
  		if (remaining) {
  			len = MIN(len, remaining);
 -			read_loop(fd, buf, len);
 +			memcpy(buf, buffer + bufferIdx, len);
@@ -204,170 +214,159 @@
  			ret = len;
 -			continue;
 +			break;
  		}
  
  		read_loop(fd, line, 4);
-@@ -305,8 +319,16 @@
+@@ -459,8 +473,16 @@
  		remaining = tag & 0xFFFFFF;
  		tag = tag >> 24;
  
 -		if (tag == MPLEX_BASE)
 +		if (tag == MPLEX_BASE) {
 +			if (!buffer || remaining > bufferSz) {
-+				buffer = Realloc(buffer, remaining);
++				buffer = realloc_array(buffer, char, remaining);
 +				if (!buffer) out_of_memory("read_unbuffered");
 +				bufferSz = remaining;
 +			}
 +			read_loop(fd, buffer, remaining);
-+                        bufferIdx = 0;
++			bufferIdx = 0;
  			continue;
-+                }
++		}
  
  		tag -= MPLEX_BASE;
  
-@@ -327,7 +349,9 @@
- 		rprintf((enum logcode) tag, "%s", line);
+@@ -482,6 +504,9 @@
  		remaining = 0;
  	}
--
-+        if (remaining == 0) {
+ 
++	if (remaining == 0)
 +		io_flush();
-+	}
++
  	return ret;
  }
  
-@@ -344,8 +368,6 @@
+@@ -498,8 +523,6 @@
  	size_t total=0;  
- 	
+ 
  	while (total < N) {
 -		io_flush();
 -
- 		ret = read_unbuffered (fd, buffer + total, N-total);
+ 		ret = read_unbuffered(fd, buffer + total, N-total);
  		total += ret;
  	}
-@@ -531,7 +553,7 @@
+@@ -682,7 +705,7 @@
  static char *io_buffer;
  static int io_buffer_count;
  
 -void io_start_buffering(int fd)
 +void io_start_buffering_out(int fd)
  {
  	if (io_buffer) return;
  	multiplex_out_fd = fd;
-@@ -540,6 +562,11 @@
+@@ -691,6 +714,11 @@
  	io_buffer_count = 0;
  }
  
 +void io_start_buffering_in(int fd)
 +{
 +	multiplex_in_fd = fd;
 +}
 +
  /**
   * Write an message to a multiplexed stream. If this fails then rsync
   * exits.
-@@ -726,7 +753,7 @@
+@@ -881,7 +909,7 @@
  {
  	multiplex_out_fd = fd;
  	io_flush();
 -	io_start_buffering(fd);
 +	io_start_buffering_out(fd);
  	io_multiplexing_out = 1;
  }
  
-diff -bur rsync/main.c rsync-craig/main.c
---- rsync/main.c	Thu Aug  1 13:46:59 2002
-+++ rsync-craig/main.c	Sun Dec  8 17:39:07 2002
-@@ -346,6 +346,8 @@
+--- orig/main.c	20 Dec 2003 16:57:24 -0000	1.176
++++ rsync-2.6.0/main.c	24 Dec 2003 01:47:41 -0000
+@@ -380,6 +380,8 @@
  		exit_cleanup(0);
  	}
  
-+        io_start_buffering_in(f_in);
-+        io_start_buffering_out(f_out);
++	io_start_buffering_in(f_in);
++	io_start_buffering_out(f_out);
  	send_files(flist,f_out,f_in);
  	io_flush();
  	report(f_out);
-@@ -421,7 +423,7 @@
+@@ -454,7 +456,7 @@
  	close(error_pipe[1]);
  	if (f_in != f_out) close(f_in);
  
 -	io_start_buffering(f_out);
 +	io_start_buffering_out(f_out);
  
  	io_set_error_fd(error_pipe[0]);
  
-@@ -476,6 +478,7 @@
- 		}    
+@@ -508,6 +510,7 @@
+ 		}
  	}
  
-+        io_start_buffering_in(f_in);
++	io_start_buffering_in(f_in);
  	if (delete_mode && !delete_excluded)
  		recv_exclude_list(f_in);
  
-@@ -569,6 +572,7 @@
+@@ -606,6 +609,7 @@
  		extern int cvs_exclude;
  		extern int delete_mode;
  		extern int delete_excluded;
-+                io_start_buffering_out(f_out);
++		io_start_buffering_out(f_out);
  		if (cvs_exclude)
  			add_cvs_excludes();
- 		if (delete_mode && !delete_excluded) 
-@@ -578,7 +582,10 @@
- 		if (verbose > 3) 
+ 		if (delete_mode && !delete_excluded)
+@@ -617,7 +621,10 @@
+ 		if (verbose > 3)
  			rprintf(FINFO,"file list sent\n");
  
-+                io_flush();
-+                io_start_buffering_out(f_out);
++		io_flush();
++		io_start_buffering_out(f_out);
  		send_files(flist,f_out,f_in);
-+                io_flush();
- 		if (remote_version >= 24) {
- 			/* final goodbye message */		
++		io_flush();
+ 		if (protocol_version >= 24) {
+ 			/* final goodbye message */
  			read_int(f_in);
-@@ -590,6 +597,7 @@
+@@ -629,6 +636,7 @@
  			wait_process(pid, &status);
  		}
  		report(-1);
 +		io_flush();
  		exit_cleanup(status);
  	}
  
-diff -bur rsync/progress.c rsync-craig/progress.c
---- rsync/progress.c	Sun Apr  7 22:28:57 2002
-+++ rsync-craig/progress.c	Sat Dec  7 18:57:19 2002
-@@ -97,6 +97,8 @@
- 	extern int do_progress, am_server;
-         struct timeval now;
- 
-+	if (!do_progress) return;
-+
-         gettimeofday(&now, NULL);
- 
-         if (!start_time.tv_sec && !start_time.tv_usec) {
-diff -bur rsync/proto.h rsync-craig/proto.h
---- rsync/proto.h	Wed Jul 31 17:37:02 2002
-+++ rsync-craig/proto.h	Sun Dec  8 16:27:55 2002
-@@ -102,7 +102,8 @@
+--- orig/proto.h	6 Dec 2003 21:07:27 -0000	1.161
++++ rsync-2.6.0/proto.h	24 Dec 2003 01:47:41 -0000
+@@ -68,6 +68,7 @@
+ 		      const char *line, int include);
+ void add_cvs_excludes(void);
+ int sparse_end(int f);
++int flush_write_file(int f);
+ int write_file(int f,char *buf,size_t len);
+ struct map_struct *map_file(int fd,OFF_T len);
+ char *map_ptr(struct map_struct *map,OFF_T offset,int len);
+@@ -101,7 +102,8 @@
  void read_buf(int f,char *buf,size_t len);
  void read_sbuf(int f,char *buf,size_t len);
  unsigned char read_byte(int f);
 -void io_start_buffering(int fd);
 +void io_start_buffering_out(int fd);
 +void io_start_buffering_in(int fd);
  void io_flush(void);
  void io_end_buffering(void);
  void write_int(int f,int32 x);
-diff -bur rsync/receiver.c rsync-craig/receiver.c
---- rsync/receiver.c	Tue May 28 08:42:51 2002
-+++ rsync-craig/receiver.c	Sat Dec  7 22:09:04 2002
-@@ -273,6 +273,11 @@
+--- orig/receiver.c	15 Dec 2003 08:14:27 -0000	1.56
++++ rsync-2.6.0/receiver.c	24 Dec 2003 01:47:41 -0000
+@@ -307,6 +307,8 @@
  		offset += len;
  	}
  
-+	/*
-+	 * do a write flush
-+	 */
-+	write_file(fd, NULL, 0);
++	flush_write_file(fd);
 +
- 	end_progress(total_size);
+ 	if (do_progress)
+ 		end_progress(total_size);
  
- 	if (fd != -1 && offset > 0 && sparse_end(fd) != 0) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/pipe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/pipe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/pipe.c	2002-04-08 15:39:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/pipe.c	2003-12-16 02:45:07.000000000 +0800
@@ -70,15 +70,14 @@
 		if (to_child_pipe[0] != STDIN_FILENO)
 			close(to_child_pipe[0]);
 		if (from_child_pipe[1] != STDOUT_FILENO)
 			close(from_child_pipe[1]);
 		umask(orig_umask);
 		set_blocking(STDIN_FILENO);
-		if (blocking_io) {
+		if (blocking_io > 0)
 			set_blocking(STDOUT_FILENO);
-		}
 		execvp(command[0], command);
 		rprintf(FERROR, "Failed to exec %s : %s\n",
 			command[0], strerror(errno));
 		exit_cleanup(RERR_IPC);
 	}
 
@@ -96,13 +95,16 @@
 pid_t local_child(int argc, char **argv,int *f_in,int *f_out,
 		  int (*child_main)(int, char*[]))
 {
 	pid_t pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
-	extern int read_batch;  /* dw */
+	extern int read_batch;
+	extern int am_sender;
+	extern int am_server;
+	extern int filesfrom_fd;
 
 	if (fd_pair(to_child_pipe) < 0 ||
 	    fd_pair(from_child_pipe) < 0) {
 		rprintf(FERROR,"pipe: %s\n",strerror(errno));
 		exit_cleanup(RERR_IPC);
 	}
@@ -112,30 +114,33 @@
 	if (pid == -1) {
 		rprintf(FERROR,"fork: %s\n",strerror(errno));
 		exit_cleanup(RERR_IPC);
 	}
 
 	if (pid == 0) {
-		extern int am_sender;
-		extern int am_server;
-
 		am_sender = read_batch ? 0 : !am_sender;
 		am_server = 1;		
 
+		if (!am_sender)
+			filesfrom_fd = -1;
+
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
 			rprintf(FERROR,"Failed to dup/close : %s\n",strerror(errno));
 			exit_cleanup(RERR_IPC);
 		}
 		if (to_child_pipe[0] != STDIN_FILENO) close(to_child_pipe[0]);
 		if (from_child_pipe[1] != STDOUT_FILENO) close(from_child_pipe[1]);
 		child_main(argc, argv);
 	}
 
+	if (!am_sender)
+		filesfrom_fd = -1;
+
 	if (close(from_child_pipe[1]) < 0 ||
 	    close(to_child_pipe[0]) < 0) {
 		rprintf(FERROR,"Failed to close : %s\n",strerror(errno));   
 		exit_cleanup(RERR_IPC);
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/progress.c	2002-04-08 13:28:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/progress.c	2003-12-13 01:13:22.000000000 +0800
@@ -1,22 +1,22 @@
 /*  -*- c-file-style: "linux" -*-
- * 
- * Copyright (C) 1996-2000 by Andrew Tridgell 
+ *
+ * Copyright (C) 1996-2000 by Andrew Tridgell
  * Copyright (C) Paul Mackerras 1996
  * Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "rsync.h"
@@ -25,14 +25,14 @@
 static struct timeval print_time;
 static struct timeval start_time;
 static OFF_T  start_ofs;
 
 static unsigned long msdiff(struct timeval *t1, struct timeval *t2)
 {
-    return (t2->tv_sec - t1->tv_sec) * 1000
-        + (t2->tv_usec - t1->tv_usec) / 1000;
+	return (t2->tv_sec - t1->tv_sec) * 1000
+	     + (t2->tv_usec - t1->tv_usec) / 1000;
 }
 
 
 /**
  * @param ofs Current position in file
  * @param size Total size of file
@@ -40,78 +40,80 @@
  * printed for this file, so we should output a newline.  (Not
  * necessarily the same as all bytes being received.)
  **/
 static void rprint_progress(OFF_T ofs, OFF_T size, struct timeval *now,
 			    int is_last)
 {
-    int           pct  = (ofs == size) ? 100 : (int)((100.0*ofs)/size);
-    unsigned long diff = msdiff(&start_time, now);
-    double        rate = diff ? (double) (ofs-start_ofs) * 1000.0 / diff / 1024.0 : 0;
-    const char    *units;
-    /* If we've finished transferring this file, show the time taken;
-     * otherwise show expected time to complete.  That's kind of
-     * inconsistent, but people can probably cope.  Hopefully we'll
-     * get more consistent and complete progress reporting soon. --
-     * mbp */
-    double        remain = is_last
-                        ? (double) diff / 1000.0
-                        : rate ? (double) (size-ofs) / rate / 1000.0 : 0.0;
-    int 	  remain_h, remain_m, remain_s;
-
-    if (rate > 1024*1024) {
-	    rate /= 1024.0 * 1024.0;
-	    units = "GB/s";
-    } else if (rate > 1024) {
-	    rate /= 1024.0;
-	    units = "MB/s";
-    } else {
-	    units = "kB/s";
-    }
-
-    remain_s = (int) remain % 60;
-    remain_m = (int) (remain / 60.0) % 60;
-    remain_h = (int) (remain / 3600.0);
-    
-    rprintf(FINFO, "%12.0f %3d%% %7.2f%s %4d:%02d:%02d%s",
-	    (double) ofs, pct, rate, units,
-	    remain_h, remain_m, remain_s,
-	    is_last ? "\n" : "\r");
+	int pct = (ofs == size) ? 100 : (int)((100.0*ofs)/size);
+	unsigned long diff = msdiff(&start_time, now);
+	double rate = diff ? (double) (ofs-start_ofs) * 1000.0 / diff / 1024.0 : 0;
+	const char *units;
+	/* If we've finished transferring this file, show the time taken;
+	 * otherwise show expected time to complete.  That's kind of
+	 * inconsistent, but people can probably cope.  Hopefully we'll
+	 * get more consistent and complete progress reporting soon. --
+	 * mbp */
+	double remain = is_last ? (double) diff / 1000.0
+	              : rate ? (double) (size-ofs) / rate / 1000.0 : 0.0;
+	int remain_h, remain_m, remain_s;
+
+	if (rate > 1024*1024) {
+		rate /= 1024.0 * 1024.0;
+		units = "GB/s";
+	} else if (rate > 1024) {
+		rate /= 1024.0;
+		units = "MB/s";
+	} else {
+		units = "kB/s";
+	}
+
+	remain_s = (int) remain % 60;
+	remain_m = (int) (remain / 60.0) % 60;
+	remain_h = (int) (remain / 3600.0);
+
+	rprintf(FINFO, "%12.0f %3d%% %7.2f%s %4d:%02d:%02d%s",
+		(double) ofs, pct, rate, units,
+		remain_h, remain_m, remain_s,
+		is_last ? "\n" : "\r");
 }
 
 void end_progress(OFF_T size)
 {
-	extern int do_progress, am_server;
+	extern int am_server;
 
-	if (do_progress && !am_server) {
+	if (!am_server) {
         	struct timeval now;
                 gettimeofday(&now, NULL);
                 rprint_progress(size, size, &now, True);
 	}
-	last_ofs   = 0;
-        start_ofs  = 0;
-        print_time.tv_sec  = print_time.tv_usec  = 0;
-        start_time.tv_sec  = start_time.tv_usec  = 0;
+	last_ofs = 0;
+	start_ofs = 0;
+	print_time.tv_sec = print_time.tv_usec = 0;
+	start_time.tv_sec = start_time.tv_usec = 0;
 }
 
 void show_progress(OFF_T ofs, OFF_T size)
 {
-	extern int do_progress, am_server;
+	extern int am_server;
         struct timeval now;
 
-        gettimeofday(&now, NULL);
-
-        if (!start_time.tv_sec && !start_time.tv_usec) {
-        	start_time.tv_sec  = now.tv_sec;
+	if (!start_time.tv_sec) {
+		gettimeofday(&now, NULL);
+		start_time.tv_sec = now.tv_sec;
                 start_time.tv_usec = now.tv_usec;
-                start_ofs          = ofs;
+		start_ofs = ofs;
+		if (am_server)
+			return;
+	}
+	else {
+		if (am_server)
+			return;
+		gettimeofday(&now, NULL);
         }
 
-	if (do_progress
-            && !am_server
-            && ofs > last_ofs + 1000
-            && msdiff(&print_time, &now) > 250) {
+	if (ofs > last_ofs + 1000 && msdiff(&print_time, &now) > 250) {
         	rprint_progress(ofs, size, &now, False);
                 last_ofs = ofs;
-                print_time.tv_sec  = now.tv_sec;
+		print_time.tv_sec = now.tv_sec;
                 print_time.tv_usec = now.tv_usec;
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/proto.h	2003-12-04 12:23:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/proto.h	2003-12-07 05:07:27.000000000 +0800
@@ -24,13 +24,12 @@
 int read_batch_delta_file(char *buff, int len);
 void show_flist(int index, struct file_struct **fptr);
 void show_argvs(int argc, char *argv[]);
 uint32 get_checksum1(char *buf1,int len);
 void get_checksum2(char *buf,int len,char *sum);
 void file_checksum(char *fname,char *sum,OFF_T size);
-void checksum_init(void);
 void sum_init(void);
 void sum_update(char *p, int len);
 void sum_end(char *sum);
 void close_all(void);
 void _exit_cleanup(int code, const char *file, int line);
 void cleanup_disable(void);
@@ -54,53 +53,52 @@
 int start_socket_client(char *host, char *path, int argc, char *argv[]);
 int start_inband_exchange(char *user, char *path, int f_in, int f_out, int argc);
 int start_daemon(int f_in, int f_out);
 int daemon_main(void);
 void setup_protocol(int f_out,int f_in);
 int claim_connection(char *fname,int max_connections);
-int check_exclude(char *name, struct exclude_struct **local_exclude_list,
-		  STRUCT_STAT *st);
-void add_exclude_list(const char *pattern, struct exclude_struct ***list, int include);
-void add_exclude(const char *pattern, int include);
-struct exclude_struct **make_exclude_list(const char *fname,
-					  struct exclude_struct **list1,
-					  int fatal, int include);
-void add_exclude_file(const char *fname, int fatal, int include);
+void free_exclude_list(struct exclude_struct ***listp);
+int check_exclude(struct exclude_struct **list, char *name, int name_is_dir);
+void add_exclude(struct exclude_struct ***listp, const char *pattern, int include);
+void add_exclude_file(struct exclude_struct ***listp, const char *fname,
+		      int fatal, int include);
 void send_exclude_list(int f);
 void recv_exclude_list(int f);
 char *get_exclude_tok(char *p);
-void add_exclude_line(char *p);
-void add_include_line(char *p);
+void add_exclude_line(struct exclude_struct ***listp,
+		      const char *line, int include);
 void add_cvs_excludes(void);
 int sparse_end(int f);
 int write_file(int f,char *buf,size_t len);
 struct map_struct *map_file(int fd,OFF_T len);
 char *map_ptr(struct map_struct *map,OFF_T offset,int len);
-void unmap_file(struct map_struct *map);
+int unmap_file(struct map_struct *map);
 void show_flist_stats(void);
 int readlink_stat(const char *path, STRUCT_STAT * buffer, char *linkbuf);
 int link_stat(const char *path, STRUCT_STAT * buffer);
-struct file_struct *make_file(int f, char *fname, struct string_area **ap,
-			      int noexcludes);
+struct file_struct *make_file(char *fname, struct string_area **ap,
+			      int exclude_level);
 void send_file_name(int f, struct file_list *flist, char *fname,
 		    int recursive, unsigned base_flags);
 struct file_list *send_file_list(int f, int argc, char *argv[]);
 struct file_list *recv_file_list(int f);
 int file_compare(struct file_struct **f1, struct file_struct **f2);
 int flist_find(struct file_list *flist, struct file_struct *f);
 void free_file(struct file_struct *file);
 struct file_list *flist_new(void);
 void flist_free(struct file_list *flist);
 char *f_name(struct file_struct *f);
+void write_sum_head(int f, struct sum_struct *sum);
 void recv_generator(char *fname, struct file_list *flist, int i, int f_out);
 void generate_files(int f,struct file_list *flist,char *local_name,int f_recv);
-int main(int argc, char *argv[]);
 void init_hard_links(struct file_list *flist);
 int check_hard_link(struct file_struct *file);
 void do_hard_links(void);
 void io_set_error_fd(int fd);
+void io_set_filesfrom_fds(int f_in, int f_out);
+int read_filesfrom_line(int fd, char *fname);
 int32 read_int(int f);
 int64 read_longint(int f);
 void read_buf(int f,char *buf,size_t len);
 void read_sbuf(int f,char *buf,size_t len);
 unsigned char read_byte(int f);
 void io_start_buffering(int fd);
@@ -160,24 +158,24 @@
 void rprintf(enum logcode code, const char *format, ...);
 void rsyserr(enum logcode code, int errcode, const char *format, ...);
 void rflush(enum logcode code);
 void log_send(struct file_struct *file, struct stats *initial_stats);
 void log_recv(struct file_struct *file, struct stats *initial_stats);
 void log_exit(int code, const char *file, int line);
-void log_transfer(struct file_struct *file, const char *fname);
 void wait_process(pid_t pid, int *status);
 int child_main(int argc, char *argv[]);
 void start_server(int f_in, int f_out, int argc, char *argv[]);
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[]);
 int main(int argc,char *argv[]);
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len);
 void match_report(void);
 void usage(enum logcode F);
 void option_error(void);
 int parse_arguments(int *argc, const char ***argv, int frommain);
 void server_options(char **args,int *argc);
+char *find_colon(char *s);
 BOOL pm_process( char *FileName,
                  BOOL (*sfunc)(char *),
                  BOOL (*pfunc)(char *, char *) );
 pid_t piped_child(char **command, int *f_in, int *f_out);
 pid_t local_child(int argc, char **argv,int *f_in,int *f_out,
 		  int (*child_main)(int, char*[]));
@@ -185,16 +183,17 @@
 void show_progress(OFF_T ofs, OFF_T size);
 void delete_files(struct file_list *flist);
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen);
 void free_sums(struct sum_struct *s);
 int delete_file(char *fname);
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
-	      int report);
+		int report);
 void sig_int(void);
 void finish_transfer(char *fname, char *fnametmp, struct file_struct *file);
-void send_files(struct file_list *flist,int f_out,int f_in);
+void read_sum_head(int f, struct sum_struct *sum);
+void send_files(struct file_list *flist, int f_out, int f_in);
 int try_bind_local(int s,
 		   int ai_family, int ai_socktype,
 		   const char *bind_address);
 int open_socket_out(char *host, int port, const char *bind_address,
 		    int af_hint);
 int open_socket_out_wrapped (char *host,
@@ -221,20 +220,17 @@
 int do_stat(const char *fname, STRUCT_STAT *st);
 int do_lstat(const char *fname, STRUCT_STAT *st);
 int do_fstat(int fd, STRUCT_STAT *st);
 OFF_T do_lseek(int fd, OFF_T offset, int whence);
 void *do_mmap(void *start, int len, int prot, int flags, int fd, OFF_T offset);
 char *d_name(struct dirent *di);
-int main(int argc, char **argv);
-int main (int argc, char *argv[]);
 void set_compression(char *fname);
 void send_token(int f,int token,struct map_struct *buf,OFF_T offset,
 		int n,int toklen);
 int recv_token(int f,char **data);
 void see_token(char *data, int toklen);
-int main(int argc, char **argv);
 void add_uid(uid_t uid);
 void add_gid(gid_t gid);
 void send_uid_list(int f);
 void recv_uid_list(int f, struct file_list *flist);
 void set_nonblocking(int fd);
 void set_blocking(int fd);
@@ -255,12 +251,13 @@
 void glob_expand(char *base1, char **argv, int *argc, int maxargs);
 void strlower(char *s);
 void clean_fname(char *name);
 void sanitize_path(char *p, char *reldir);
 char *push_dir(char *dir, int save);
 int pop_dir(char *dir);
+char *full_fname(char *fn);
 int u_strcmp(const char *cs1, const char *cs2);
 int unsafe_symlink(const char *dest, const char *src);
 char *timestring(time_t t);
 int msleep(int t);
 int cmp_modtime(time_t file1, time_t file2);
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/receiver.c	2003-12-04 12:23:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/receiver.c	2003-12-15 16:14:27.000000000 +0800
@@ -1,65 +1,68 @@
 /* -*- c-file-style: "linux" -*-
-   
+
    Copyright (C) 1996-2000 by Andrew Tridgell
    Copyright (C) Paul Mackerras 1996
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
 extern int verbose;
 extern int recurse;
 extern int delete_mode;
-extern int remote_version;
+extern int protocol_version;
 extern int csum_length;
 extern struct stats stats;
 extern int dry_run;
 extern int am_server;
 extern int relative_paths;
 extern int preserve_hard_links;
 extern int cvs_exclude;
 extern int io_error;
 extern char *tmpdir;
 extern char *compare_dest;
 extern int make_backups;
+extern int do_progress;
+extern char *backup_dir;
 extern char *backup_suffix;
+extern int backup_suffix_len;
 
 static struct delete_list {
 	DEV64_T dev;
 	INO64_T inode;
 } *delete_list;
 static int dlist_len, dlist_alloc_len;
 
 /* yuck! This function wouldn't have been necessary if I had the sorting
-   algorithm right. Unfortunately fixing the sorting algorithm would introduce
-   a backward incompatibility as file list indexes are sent over the link.
-*/
+ * algorithm right. Unfortunately fixing the sorting algorithm would introduce
+ * a backward incompatibility as file list indexes are sent over the link.
+ */
 static int delete_already_done(struct file_list *flist,int j)
 {
 	int i;
 	STRUCT_STAT st;
 
 	if (link_stat(f_name(flist->files[j]), &st)) return 1;
 
-	for (i=0;i<dlist_len;i++) {
+	for (i = 0; i < dlist_len; i++) {
 		if (st.st_ino == delete_list[i].inode &&
-		    st.st_dev == delete_list[i].dev)
+		    (DEV64_T)st.st_dev == delete_list[i].dev)
 			return 1;
 	}
 
 	return 0;
 }
 
@@ -77,37 +80,44 @@
 	dlist_len++;
 
 	if (verbose > 3)
 		rprintf(FINFO,"added %s to delete list\n", f_name(file));
 }
 
-static void delete_one(struct file_struct *f)
+static void delete_one(char *fn, int is_dir)
 {
-	if (!S_ISDIR(f->mode)) {
-		if (robust_unlink(f_name(f)) != 0) {
-			rprintf(FERROR,"delete_one: unlink %s: %s\n",f_name(f),strerror(errno));
+	if (!is_dir) {
+		if (robust_unlink(fn) != 0) {
+			rprintf(FERROR, "delete_one: unlink %s failed: %s\n",
+				full_fname(fn), strerror(errno));
 		} else if (verbose) {
-			rprintf(FINFO,"deleting %s\n",f_name(f));
+			rprintf(FINFO, "deleting %s\n", fn);
 		}
-	} else {    
-		if (do_rmdir(f_name(f)) != 0) {
-			if (errno != ENOTEMPTY && errno != EEXIST)
-				rprintf(FERROR,"delete_one: rmdir %s: %s\n",
-                                        f_name(f), strerror(errno));
+	} else {
+		if (do_rmdir(fn) != 0) {
+			if (errno != ENOTEMPTY && errno != EEXIST) {
+				rprintf(FERROR, "delete_one: rmdir %s failed: %s\n",
+					full_fname(fn), strerror(errno));
+			}
 		} else if (verbose) {
-			rprintf(FINFO,"deleting directory %s\n",f_name(f));      
+			rprintf(FINFO, "deleting directory %s\n", fn);
 		}
 	}
 }
 
 
+static int is_backup_file(char *fn)
+{
+	int k = strlen(fn) - backup_suffix_len;
+	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
+}
 
 
 /* this deletes any files on the receiving side that are not present
-   on the sending side. For version 1.6.4 I have changed the behaviour
-   to match more closely what most people seem to expect of this option */
+ * on the sending side. For version 1.6.4 I have changed the behaviour
+ * to match more closely what most people seem to expect of this option */
 void delete_files(struct file_list *flist)
 {
 	struct file_list *local_file_list;
 	int i, j;
 	char *name;
 	extern int module_id;
@@ -121,16 +131,16 @@
 	if (io_error && !(lp_ignore_errors(module_id) || ignore_errors)) {
 		rprintf(FINFO,"IO error encountered - skipping file deletion\n");
 		return;
 	}
 
 	for (j=0;j<flist->count;j++) {
-		if (!S_ISDIR(flist->files[j]->mode) || 
+		if (!S_ISDIR(flist->files[j]->mode) ||
 		    !(flist->files[j]->flags & FLAG_DELETE)) continue;
 
-		if (remote_version < 19 &&
+		if (protocol_version < 19 &&
 		    delete_already_done(flist, j)) continue;
 
 		name = strdup(f_name(flist->files[j]));
 
 		if (!(local_file_list = send_file_list(-1,1,&name))) {
 			free(name);
@@ -140,213 +150,234 @@
 		if (verbose > 1)
 			rprintf(FINFO,"deleting in %s\n", name);
 
 		for (i=local_file_list->count-1;i>=0;i--) {
 			if (max_delete && deletion_count > max_delete) break;
 			if (!local_file_list->files[i]->basename) continue;
-			if (remote_version < 19 &&
+			if (protocol_version < 19 &&
 			    S_ISDIR(local_file_list->files[i]->mode))
 				add_delete_entry(local_file_list->files[i]);
 			if (-1 == flist_find(flist,local_file_list->files[i])) {
 				char *f = f_name(local_file_list->files[i]);
-				int k = strlen(f) - strlen(backup_suffix);
-/* Hi Andrew, do we really need to play with backup_suffix here? */
-				if (make_backups && ((k <= 0) ||
-					    (strcmp(f+k,backup_suffix) != 0))) {
+				if (make_backups && (backup_dir || !is_backup_file(f))) {
 					(void) make_backup(f);
+					if (verbose)
+						rprintf(FINFO, "deleting %s\n", f);
 				} else {
-					deletion_count++;
-					delete_one(local_file_list->files[i]);
+					int mode = local_file_list->files[i]->mode;
+					delete_one(f, S_ISDIR(mode) != 0);
 				}
+				deletion_count++;
 			}
 		}
 		flist_free(local_file_list);
 		free(name);
 	}
 }
 
 
+/*
+ * get_tmpname() - create a tmp filename for a given filename
+ *
+ *   If a tmpdir is defined, use that as the directory to
+ *   put it in.  Otherwise, the tmp filename is in the same
+ *   directory as the given name.  Note that there may be no
+ *   directory at all in the given name!
+ *
+ *   The tmp filename is basically the given filename with a
+ *   dot prepended, and .XXXXXX appended (for mkstemp() to
+ *   put its unique gunk in).  Take care to not exceed
+ *   either the MAXPATHLEN or NAME_MAX, esp. the last, as
+ *   the basename basically becomes 8 chars longer. In that
+ *   case, the original name is shortened sufficiently to
+ *   make it all fit.
+ *
+ *   Of course, there's no real reason for the tmp name to
+ *   look like the original, except to satisfy us humans.
+ *   As long as it's unique, rsync will work.
+ */
+
 static int get_tmpname(char *fnametmp, char *fname)
 {
 	char *f;
+	int     length = 0;
+	int	maxname;
 
-	/* open tmp file */
 	if (tmpdir) {
-		f = strrchr(fname,'/');
-		if (f == NULL) 
-			f = fname;
-		else 
-			f++;
-		if (strlen(tmpdir)+strlen(f)+10 > MAXPATHLEN) {
-			rprintf(FERROR,"filename too long\n");
-			return 0;
-		}
-		snprintf(fnametmp,MAXPATHLEN, "%s/.%s.XXXXXX",tmpdir,f);
-		return 1;
-	} 
+		strlcpy(fnametmp, tmpdir, MAXPATHLEN - 2);
+		length = strlen(fnametmp);
+		fnametmp[length++] = '/';
+		fnametmp[length] = '\0';	/* always NULL terminated */
+	}
+
+	if ((f = strrchr(fname, '/')) != NULL) {
+		++f;
+		if (!tmpdir) {
+			length = f - fname;
+			/* copy up to and including the slash */
+			strlcpy(fnametmp, fname, length + 1);
+		}
+	} else {
+		f = fname;
+	}
+	fnametmp[length++] = '.';
+	fnametmp[length] = '\0';		/* always NULL terminated */
 
-	f = strrchr(fname,'/');
+	maxname = MIN(MAXPATHLEN - 7 - length, NAME_MAX - 8);
 
-	if (strlen(fname)+9 > MAXPATHLEN) {
-		rprintf(FERROR,"filename too long\n");
+	if (maxname < 1) {
+		rprintf(FERROR, "temporary filename too long: %s\n", fname);
+		fnametmp[0] = '\0';
 		return 0;
 	}
 
-	if (f) {
-		*f = 0;
-		snprintf(fnametmp,MAXPATHLEN,"%s/.%s.XXXXXX",
-			 fname,f+1);
-		*f = '/';
-	} else {
-		snprintf(fnametmp,MAXPATHLEN,".%s.XXXXXX",fname);
-	}
+	strlcpy(fnametmp + length, f, maxname);
+	strcat(fnametmp + length, ".XXXXXX");
 
 	return 1;
 }
 
 
 static int receive_data(int f_in,struct map_struct *buf,int fd,char *fname,
 			OFF_T total_size)
 {
 	int i;
-	unsigned int n,remainder,len,count;
+	struct sum_struct sum;
+	unsigned int len;
 	OFF_T offset = 0;
 	OFF_T offset2;
 	char *data;
 	static char file_sum1[MD4_SUM_LENGTH];
 	static char file_sum2[MD4_SUM_LENGTH];
 	char *map=NULL;
-	
-	count = read_int(f_in);
-	n = read_int(f_in);
-	remainder = read_int(f_in);
-	
+
+	read_sum_head(f_in, &sum);
+
 	sum_init();
-	
-	for (i=recv_token(f_in,&data); i != 0; i=recv_token(f_in,&data)) {
 
-		show_progress(offset, total_size);
+	for (i=recv_token(f_in,&data); i != 0; i=recv_token(f_in,&data)) {
+		if (do_progress)
+			show_progress(offset, total_size);
 
 		if (i > 0) {
 			extern int cleanup_got_literal;
 
 			if (verbose > 3) {
 				rprintf(FINFO,"data recv %d at %.0f\n",
 					i,(double)offset);
 			}
 
 			stats.literal_data += i;
 			cleanup_got_literal = 1;
-      
+
 			sum_update(data,i);
 
 			if (fd != -1 && write_file(fd,data,i) != i) {
-				rprintf(FERROR,"write failed on %s : %s\n",fname,strerror(errno));
+				rprintf(FERROR, "write failed on %s: %s\n",
+					full_fname(fname), strerror(errno));
 				exit_cleanup(RERR_FILEIO);
 			}
 			offset += i;
 			continue;
-		} 
+		}
 
 		i = -(i+1);
-		offset2 = i*(OFF_T)n;
-		len = n;
-		if (i == (int) count-1 && remainder != 0)
-			len = remainder;
-		
+		offset2 = i*(OFF_T)sum.blength;
+		len = sum.blength;
+		if (i == (int) sum.count-1 && sum.remainder != 0)
+			len = sum.remainder;
+
 		stats.matched_data += len;
-		
+
 		if (verbose > 3)
 			rprintf(FINFO,"chunk[%d] of size %d at %.0f offset=%.0f\n",
 				i,len,(double)offset2,(double)offset);
-		
+
 		if (buf) {
 			map = map_ptr(buf,offset2,len);
-		
+
 			see_token(map, len);
 			sum_update(map,len);
 		}
-		
+
 		if (fd != -1 && write_file(fd,map,len) != (int) len) {
-			rprintf(FERROR,"write failed on %s : %s\n",
-				fname,strerror(errno));
+			rprintf(FERROR, "write failed on %s: %s\n",
+				full_fname(fname), strerror(errno));
 			exit_cleanup(RERR_FILEIO);
 		}
 		offset += len;
 	}
 
-	end_progress(total_size);
+	if (do_progress)
+		end_progress(total_size);
 
 	if (fd != -1 && offset > 0 && sparse_end(fd) != 0) {
-		rprintf(FERROR,"write failed on %s : %s\n",
-			fname,strerror(errno));
+		rprintf(FERROR, "write failed on %s: %s\n",
+			full_fname(fname), strerror(errno));
 		exit_cleanup(RERR_FILEIO);
 	}
 
 	sum_end(file_sum1);
 
-	if (remote_version >= 14) {
-		read_buf(f_in,file_sum2,MD4_SUM_LENGTH);
-		if (verbose > 2) {
-			rprintf(FINFO,"got file_sum\n");
-		}
-		if (fd != -1 && 
-		    memcmp(file_sum1,file_sum2,MD4_SUM_LENGTH) != 0) {
-			return 0;
-		}
+	read_buf(f_in,file_sum2,MD4_SUM_LENGTH);
+	if (verbose > 2) {
+		rprintf(FINFO,"got file_sum\n");
+	}
+	if (fd != -1 && memcmp(file_sum1,file_sum2,MD4_SUM_LENGTH) != 0) {
+		return 0;
 	}
 	return 1;
 }
 
 
 /**
  * main routine for receiver process.
  *
  * Receiver process runs on the same host as the generator process. */
 int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen)
-{  
+{
 	int fd1,fd2;
 	STRUCT_STAT st;
 	char *fname;
 	char template[MAXPATHLEN];
 	char fnametmp[MAXPATHLEN];
 	char *fnamecmp;
 	char fnamecmpbuf[MAXPATHLEN];
 	struct map_struct *buf;
 	int i;
 	struct file_struct *file;
 	int phase=0;
 	int recv_ok;
-	extern struct stats stats;		
+	extern struct stats stats;
 	extern int preserve_perms;
 	extern int delete_after;
 	extern int orig_umask;
 	struct stats initial_stats;
 
 	if (verbose > 2) {
 		rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
 	}
 
-	while (1) {      
+	while (1) {
 		cleanup_disable();
 
 		i = read_int(f_in);
 		if (i == -1) {
-			if (phase==0 && remote_version >= 13) {
+			if (phase==0) {
 				phase++;
 				csum_length = SUM_LENGTH;
 				if (verbose > 2)
 					rprintf(FINFO,"recv_files phase=%d\n",phase);
 				write_int(f_gen,-1);
 				continue;
 			}
 			break;
 		}
 
 		if (i < 0 || i >= flist->count) {
-			rprintf(FERROR,"Invalid file index %d in recv_files (count=%d)\n", 
+			rprintf(FERROR,"Invalid file index %d in recv_files (count=%d)\n",
 				i, flist->count);
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		file = flist->files[i];
 		fname = f_name(file);
@@ -355,54 +386,67 @@
 		stats.total_transferred_size += file->length;
 
 		if (local_name)
 			fname = local_name;
 
 		if (dry_run) {
-			if (!am_server) {
-				log_transfer(file, fname);
+			if (!am_server && verbose) {	/* log transfer */
+				rprintf(FINFO, "%s\n", fname);
 			}
 			continue;
 		}
 
 		initial_stats = stats;
 
 		if (verbose > 2)
 			rprintf(FINFO,"recv_files(%s)\n",fname);
 
 		fnamecmp = fname;
 
-		/* open the file */  
+		/* open the file */
 		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 
 		if ((fd1 == -1) && (compare_dest != NULL)) {
 			/* try the file at compare_dest instead */
 			snprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",
 						compare_dest,fname);
 			fnamecmp = fnamecmpbuf;
 			fd1 = do_open(fnamecmp, O_RDONLY, 0);
 		}
 
 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
-			rprintf(FERROR,"fstat %s : %s\n",fnamecmp,strerror(errno));
+			rprintf(FERROR, "fstat %s failed: %s\n",
+				full_fname(fnamecmp), strerror(errno));
 			receive_data(f_in,NULL,-1,NULL,file->length);
 			close(fd1);
 			continue;
 		}
 
-		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
-			rprintf(FERROR,"%s : not a regular file (recv_files)\n",fnamecmp);
-			receive_data(f_in,NULL,-1,NULL,file->length);
+		if (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {
+			/* this special handling for directories
+			 * wouldn't be necessary if robust_rename()
+			 * and the underlying robust_unlink could cope
+			 * with directories
+			 */
+			rprintf(FERROR,"recv_files: %s is a directory\n",
+				full_fname(fnamecmp));
+			receive_data(f_in, NULL, -1, NULL, file->length);
 			close(fd1);
 			continue;
 		}
 
+		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
+			close(fd1);
+			fd1 = -1;
+			buf = NULL;
+		}
+
 		if (fd1 != -1 && !preserve_perms) {
-			/* if the file exists already and we aren't perserving
-			   presmissions then act as though the remote end sent
-			   us the file permissions we already have */
+			/* if the file exists already and we aren't preserving
+			 * permissions then act as though the remote end sent
+			 * us the file permissions we already have */
 			file->mode = st.st_mode;
 		}
 
 		if (fd1 != -1 && st.st_size > 0) {
 			buf = map_file(fd1,st.st_size);
 			if (verbose > 2)
@@ -417,63 +461,64 @@
 			continue;
 		}
 
 		strlcpy(template, fnametmp, sizeof(template));
 
 		/* we initially set the perms without the
-		   setuid/setgid bits to ensure that there is no race
-		   condition. They are then correctly updated after
-		   the lchown. Thanks to snabb@epipe.fi for pointing
-		   this out.  We also set it initially without group
-		   access because of a similar race condition. */
+		 * setuid/setgid bits to ensure that there is no race
+		 * condition. They are then correctly updated after
+		 * the lchown. Thanks to snabb@epipe.fi for pointing
+		 * this out.  We also set it initially without group
+		 * access because of a similar race condition. */
 		fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
 
 		/* in most cases parent directories will already exist
-		   because their information should have been previously
-		   transferred, but that may not be the case with -R */
-		if (fd2 == -1 && relative_paths && errno == ENOENT && 
+		 * because their information should have been previously
+		 * transferred, but that may not be the case with -R */
+		if (fd2 == -1 && relative_paths && errno == ENOENT &&
 		    create_directory_path(fnametmp, orig_umask) == 0) {
 			strlcpy(fnametmp, template, sizeof(fnametmp));
 			fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
 		}
 		if (fd2 == -1) {
-			rprintf(FERROR,"mkstemp %s failed: %s\n",fnametmp,strerror(errno));
+			rprintf(FERROR, "mkstemp %s failed: %s\n",
+				full_fname(fnametmp), strerror(errno));
 			receive_data(f_in,buf,-1,NULL,file->length);
 			if (buf) unmap_file(buf);
 			if (fd1 != -1) close(fd1);
 			continue;
 		}
-      
+
 		cleanup_set(fnametmp, fname, file, buf, fd1, fd2);
 
-		if (!am_server) {
-			log_transfer(file, fname);
+		if (!am_server && verbose) {	/* log transfer */
+			rprintf(FINFO, "%s\n", fname);
 		}
 
 		/* recv file data */
 		recv_ok = receive_data(f_in,buf,fd2,fname,file->length);
 
 		log_recv(file, &initial_stats);
-		
+
 		if (buf) unmap_file(buf);
 		if (fd1 != -1) {
 			close(fd1);
 		}
 		close(fd2);
-		
+
 		if (verbose > 2)
 			rprintf(FINFO,"renaming %s to %s\n",fnametmp,fname);
 
 		finish_transfer(fname, fnametmp, file);
 
 		cleanup_disable();
 
 		if (!recv_ok) {
 			if (csum_length == SUM_LENGTH) {
 				rprintf(FERROR,"ERROR: file corruption in %s. File changed during transfer?\n",
-					fname);
+					full_fname(fname));
 			} else {
 				if (verbose > 1)
 					rprintf(FINFO,"redoing %s(%d)\n",fname,i);
 				write_int(f_gen,i);
 			}
 		}
@@ -485,20 +530,20 @@
 		}
 	}
 
 	if (preserve_hard_links)
 		do_hard_links();
 
-	/* now we need to fix any directory permissions that were 
-	   modified during the transfer */
+	/* now we need to fix any directory permissions that were
+	 * modified during the transfer */
 	for (i = 0; i < flist->count; i++) {
 		file = flist->files[i];
 		if (!file->basename || !S_ISDIR(file->mode)) continue;
 		recv_generator(local_name?local_name:f_name(file),flist,i,-1);
 	}
 
 	if (verbose > 2)
 		rprintf(FINFO,"recv_files finished\n");
-	
+
 	return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsync.1	2003-01-28 11:11:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.1	2004-01-02 03:00:11.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsync" "1" "26 Jan 2003" "" "" 
+.TH "rsync" "1" "1 Jan 2004" "" "" 
 .SH "NAME" 
 rsync \- faster, flexible replacement for rcp
 .SH "SYNOPSIS" 
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST:DEST
 .PP 
@@ -22,26 +22,26 @@
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speed up file transfers when the destination file already
 exists\&.
 .PP 
 The rsync remote-update protocol allows rsync to transfer just the
-differences between two sets of files across the network link, using
+differences between two sets of files across the network connection, using
 an efficient checksum-search algorithm described in the technical
 report that accompanies this package\&.
 .PP 
 Some of the additional features of rsync are:
 .PP 
 .IP o 
 support for copying links, devices, owners, groups and permissions
 .IP o 
 exclude and exclude-from options similar to GNU tar
 .IP o 
 a CVS exclude mode for ignoring the same files that CVS would ignore
 .IP o 
-can use any transparent remote shell, including rsh or ssh
+can use any transparent remote shell, including ssh or rsh
 .IP o 
 does not require root privileges
 .IP o 
 pipelining of file transfers to minimize latency costs
 .IP o 
 support for anonymous or authenticated rsync servers (ideal for
@@ -54,14 +54,14 @@
 .IP o 
 for copying local files\&. This is invoked when neither
 source nor destination path contains a : separator
 .IP 
 .IP o 
 for copying from the local machine to a remote machine using
-a remote shell program as the transport (such as rsh or
-ssh)\&. This is invoked when the destination path contains a
+a remote shell program as the transport (such as ssh or
+rsh)\&. This is invoked when the destination path contains a
 single : separator\&.
 .IP 
 .IP o 
 for copying from a remote machine to the local machine
 using a remote shell program\&. This is invoked when the source
 contains a : separator\&.
@@ -101,15 +101,15 @@
 .SH "SETUP" 
 .PP 
 See the file README for installation instructions\&.
 .PP 
 Once installed, you can use rsync to any machine that you can access via
 a remote shell (as well as some that you can access using the rsync
-daemon-mode protocol)\&.  For remote transfers, rsync typically uses rsh
+daemon-mode protocol)\&.  For remote transfers, a modern rsync uses ssh
 for its communications, but it may have been configured to use a
-different remote shell by default, such as ssh\&.
+different remote shell by default, such as rsh or remsh\&.
 .PP 
 You can also specify any remote shell you like, either by using the -e
 command line option, or by setting the RSYNC_RSH environment variable\&.
 .PP 
 One common substitute is to use ssh, which offers a high degree of
 security\&.
@@ -125,60 +125,69 @@
 Perhaps the best way to explain the syntax is some examples:
 .PP 
 .RS 
 rsync *\&.c foo:src/
 .RE 
 .PP 
-this would transfer all files matching the pattern *\&.c from the
+This would transfer all files matching the pattern *\&.c from the
 current directory to the directory src on the machine foo\&. If any of
 the files already exist on the remote system then the rsync
 remote-update protocol is used to update the file by sending only the
 differences\&. See the tech report for details\&.
 .PP 
 .RS 
 rsync -avz foo:src/bar /data/tmp
 .RE 
 .PP 
-this would recursively transfer all files from the directory src/bar on the
+This would recursively transfer all files from the directory src/bar on the
 machine foo into the /data/tmp/bar directory on the local machine\&. The
 files are transferred in "archive" mode, which ensures that symbolic
 links, devices, attributes, permissions, ownerships etc are preserved
 in the transfer\&.  Additionally, compression will be used to reduce the
 size of data portions of the transfer\&.
 .PP 
 .RS 
 rsync -avz foo:src/bar/ /data/tmp
 .RE 
 .PP 
-a trailing slash on the source changes this behavior to transfer
-all files from the directory src/bar on the machine foo into the
-/data/tmp/\&.  A trailing / on a source name means "copy the
-contents of this directory"\&.  Without a trailing slash it means "copy
-the directory"\&. This difference becomes particularly important when
-using the --delete option\&.
+A trailing slash on the source changes this behavior to avoid creating an
+additional directory level at the destination\&.  You can think of a trailing
+/ on a source as meaning "copy the contents of this directory" as opposed
+to "copy the directory by name", but in both cases the attributes of the
+containing directory are transferred to the containing directory on the
+destination\&.  In other words, each of the following commands copies the
+files in the same way, including their setting of the attributes of
+/dest/foo:
+.PP 
+.RS 
+rsync -avz /src/foo /dest
+.RE 
+.RS 
+rsync -avz /src/foo/ /dest/foo
+.RE 
 .PP 
 You can also use rsync in local-only mode, where both the source and
-destination don\'t have a \':\' in the name\&. In this case it behaves like
+destination don\&'t have a \&':\&' in the name\&. In this case it behaves like
 an improved copy command\&.
 .PP 
 .RS 
 rsync somehost\&.mydomain\&.com::
 .RE 
 .PP 
-this would list all the anonymous rsync modules available on the host
+This would list all the anonymous rsync modules available on the host
 somehost\&.mydomain\&.com\&.  (See the following section for more details\&.)
 .PP 
 .SH "CONNECTING TO AN RSYNC SERVER" 
 .PP 
 It is also possible to use rsync without a remote shell as the
 transport\&. In this case you will connect to a remote rsync server
 running on TCP port 873\&. 
 .PP 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
-your web proxy\&.  Note that your web proxy\'s configuration must allow
+your web proxy\&.  Note that your web proxy\&'s configuration must allow
 proxying to port 873\&.
 .PP 
 Using rsync in this way is the same as using it with a remote shell except
 that:
 .PP 
 .IP o 
@@ -206,27 +215,27 @@
 WARNING: On some systems environment variables are visible to all
 users\&. On those systems using --password-file is recommended\&.
 .PP 
 .SH "CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" 
 .PP 
 It is sometimes useful to be able to set up file transfers using rsync
-server capabilities on the remote machine, while still using rsh or
-ssh for transport\&.  This is especially useful when you want to connect
+server capabilities on the remote machine, while still using ssh or
+rsh for transport\&.  This is especially useful when you want to connect
 to a remote machine via ssh (for encryption or to get through a
 firewall), but you still want to have access to the rsync server
 features (see RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM,
 below)\&.  
 .PP 
-From the user\'s perspective, using rsync in this way is the same as
+From the user\&'s perspective, using rsync in this way is the same as
 using it to connect to an rsync server, except that you must
 explicitly set the remote shell program on the command line with
 --rsh=COMMAND\&.  (Setting RSYNC_RSH in the environment will not turn on
 this functionality\&.)
 .PP 
 In order to distinguish between the remote-shell user and the rsync
-server user, you can use \'-l user\' on your remote-shell command:
+server user, you can use \&'-l user\&' on your remote-shell command:
 .PP 
 .RS 
 rsync -av --rsh="ssh -l ssh-user" rsync-user@host::module[/path] local-path
 .RE 
 .PP 
 The "ssh-user" will be used at the ssh level; the "rsync-user" will be
@@ -248,61 +257,47 @@
 .PP 
 Several configuration options will not be available unless the remote
 user is root (e\&.g\&. chroot, setuid/setgid, etc\&.)\&.  There is no need to
 configure inetd or the services map to include the rsync server port
 if you run an rsync server only via a remote shell program\&.
 .PP 
-To run an rsync server out of a single-use ssh key, use the
-"command=\fICOMMAND\fP" syntax in the remote user\'s
-authorized_keys entry, where command would be
-.PP 
-.RS 
-rsync --server --daemon \&.
-.RE 
-.PP 
-NOTE: rsync\'s argument parsing expects the trailing "\&.", so make sure
-that it\'s there\&.  If you want to use a rsyncd\&.conf(5)-style
-configuration file other than the default, you can added a
---config option to the \fIcommand\fP:
-.PP 
-.RS 
-rsync --server --daemon --config=\fIfile\fP \&.
-.RE 
+To run an rsync server out of a single-use ssh key, see this section
+in the rsyncd\&.conf(5) man page\&.
 .PP 
 .SH "EXAMPLES" 
 .PP 
 Here are some examples of how I use rsync\&.
 .PP 
-To backup my wife\'s home directory, which consists of large MS Word
+To backup my wife\&'s home directory, which consists of large MS Word
 files and mail folders, I use a cron job that runs
 .PP 
 .RS 
 rsync -Cavz \&. arvidsjaur:backup
 .RE 
 .PP 
-each night over a PPP link to a duplicate directory on my machine
+each night over a PPP connection to a duplicate directory on my machine
 "arvidsjaur"\&.
 .PP 
 To synchronize my samba source trees I use the following Makefile
 targets:
 .PP 
 .RS 
 get:
 .br 
-rsync -avuzb --exclude \'*~\' samba:samba/ \&.
+rsync -avuzb --exclude \&'*~\&' samba:samba/ \&.
 .PP 
 put:
 .br 
 rsync -Cavuzb \&. samba:samba/
 .PP 
 sync: get put
 .RE 
 .PP 
 this allows me to sync with a CVS directory at the other end of the
-link\&. I then do cvs operations on the remote machine, which saves a
-lot of time as the remote cvs protocol isn\'t very efficient\&.
+connection\&. I then do cvs operations on the remote machine, which saves a
+lot of time as the remote cvs protocol isn\&'t very efficient\&.
 .PP 
 I mirror a directory between my "old" and "new" ftp sites with the
 command
 .PP 
 .RS 
 rsync -az -e ssh --delete ~ftp/pub/samba/ nimbus:"~ftp/pub/tridge/samba"
@@ -322,16 +317,18 @@
  -v, --verbose               increase verbosity
  -q, --quiet                 decrease verbosity
  -c, --checksum              always checksum
  -a, --archive               archive mode, equivalent to -rlptgoD
  -r, --recursive             recurse into directories
  -R, --relative              use relative path names
- -b, --backup                make backups (default ~ suffix)
+     --no-relative           turn off --relative
+     --no-implied-dirs       don\&'t send implied dirs with -R
+ -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir            make backups into this directory
-     --suffix=SUFFIX         define backup suffix
- -u, --update                update only (don\'t overwrite newer files)
+     --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
+ -u, --update                update only (don\&'t overwrite newer files)
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            copy the referent of symlinks
      --copy-unsafe-links     copy links outside the source tree
      --safe-links            ignore links outside the destination tree
  -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
@@ -340,40 +337,42 @@
  -D, --devices               preserve devices (root only)
  -t, --times                 preserve times
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy whole files, no incremental checks
      --no-whole-file         turn off --whole-file
- -x, --one-file-system       don\'t cross filesystem boundaries
+ -x, --one-file-system       don\&'t cross filesystem boundaries
  -B, --block-size=SIZE       checksum blocking size (default 700)
- -e, --rsh=COMMAND           specify the remote shell to use
+ -e, --rsh=COMMAND           specify the remote shell
      --rsync-path=PATH       specify path to rsync on the remote machine
- -C, --cvs-exclude           auto ignore files in the same way CVS does
      --existing              only update files that already exist
-     --ignore-existing       ignore files that already exist on the receiving side
-     --delete                delete files that don\'t exist on the sending side
-     --delete-excluded       also delete excluded files on the receiving side
+     --ignore-existing       ignore files that already exist on receiver
+     --delete                delete files that don\&'t exist on sender
+     --delete-excluded       also delete excluded files on receiver
      --delete-after          delete after transferring, not before
      --ignore-errors         delete even if there are IO errors
-     --max-delete=NUM        don\'t delete more than NUM files
+     --max-delete=NUM        don\&'t delete more than NUM files
      --partial               keep partially transferred files
-     --force                 force deletion of directories even if not empty
-     --numeric-ids           don\'t map uid/gid values by user/group name
+     --force                 force deletion of dirs even if not empty
+     --numeric-ids           don\&'t map uid/gid values by user/group name
      --timeout=TIME          set IO timeout in seconds
- -I, --ignore-times          don\'t exclude files that match length and time
-     --size-only             only use file size when determining if a file should be transferred
-     --modify-window=NUM     Timestamp window (seconds) for file match (default=0)
+ -I, --ignore-times          turn off mod time & file size quick check
+     --size-only             ignore mod time for quick check (use size)
+     --modify-window=NUM     compare mod times with reduced accuracy
  -T  --temp-dir=DIR          create temporary files in directory DIR
-     --compare-dest=DIR      also compare destination files relative to DIR
+     --compare-dest=DIR      also compare received files relative to DIR
      --link-dest=DIR         create hardlinks to DIR for unchanged files
  -P                          equivalent to --partial --progress
  -z, --compress              compress file data
+ -C, --cvs-exclude           auto ignore files in the same way CVS does
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     exclude patterns listed in FILE
-     --include=PATTERN       don\'t exclude files matching PATTERN
-     --include-from=FILE     don\'t exclude patterns listed in FILE
+     --include=PATTERN       don\&'t exclude files matching PATTERN
+     --include-from=FILE     don\&'t exclude patterns listed in FILE
+     --files-from=FILE       read FILE for list of source-file names
+ -0  --from0                 all file lists are delimited by nulls
      --version               print version number
      --daemon                run as a rsync daemon
      --no-detach             do not detach from the parent
      --address=ADDRESS       bind to the specified address
      --config=FILE           specify alternate rsyncd\&.conf file
      --port=PORT             specify alternate rsyncd port number
@@ -381,14 +380,14 @@
      --no-blocking-io        turn off --blocking-io
      --stats                 give some file transfer stats
      --progress              show progress during transfer
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
      --bwlimit=KBPS          limit I/O bandwidth, KBytes per second
-     --read-batch=PREFIX     read batch fileset starting with PREFIX
      --write-batch=PREFIX    write batch fileset starting with PREFIX
+     --read-batch=PREFIX     read batch fileset starting with PREFIX
  -h, --help                  show this help screen
 
 
 
 .fi 
  
@@ -396,13 +395,13 @@
 .PP 
 .SH "OPTIONS" 
 .PP 
 rsync uses the GNU long options package\&. Many of the command line
 options have two variants, one short and one long\&.  These are shown
 below, separated by commas\&. Some options only have a long variant\&.
-The \'=\' for options that take a parameter is optional; whitespace
+The \&'=\&' for options that take a parameter is optional; whitespace
 can be used instead\&.
 .PP 
 .IP "\fB-h, --help\fP" 
 Print a short help page describing the options
 available in rsync
 .IP 
@@ -423,18 +422,18 @@
 are given during the transfer, notably suppressing information messages
 from the remote server\&. This flag is useful when invoking rsync from
 cron\&.
 .IP 
 .IP "\fB-I, --ignore-times\fP" 
 Normally rsync will skip any files that are
-already the same length and have the same time-stamp\&. This option turns
-off this behavior\&.
+already the same size and have the same modification time-stamp\&.
+This option turns off this "quick check" behavior\&.
 .IP 
 .IP "\fB--size-only\fP" 
 Normally rsync will skip any files that are
-already the same length and have the same time-stamp\&. With the
+already the same size and have the same modification time-stamp\&. With the
 --size-only option files will be skipped if they have the same size,
 regardless of timestamp\&. This is useful when starting to use rsync
 after using another mirroring system which may not preserve timestamps
 exactly\&.
 .IP 
 .IP "\fB--modify-window\fP" 
@@ -460,13 +459,13 @@
 Note however that \fB-a\fP \fBdoes not preserve hardlinks\fP, because
 finding multiply-linked files is expensive\&.  You must separately
 specify \fB-H\fP\&.
 .IP 
 .IP "\fB-r, --recursive\fP" 
 This tells rsync to copy directories
-recursively\&. If you don\'t specify this then rsync won\'t copy
+recursively\&. If you don\&'t specify this then rsync won\&'t copy
 directories at all\&.
 .IP 
 .IP "\fB-R, --relative\fP" 
 Use relative paths\&. This means that the full path
 names specified on the command line are sent to the server rather than
 just the last parts of the filenames\&. This is particularly useful when
@@ -490,32 +489,49 @@
 rsync -R foo/bar/foo\&.c remote:/tmp/
 .fi 
  
 
 .IP 
 then a file called /tmp/foo/bar/foo\&.c would be created on the remote
-machine\&. The full path name is preserved\&.
+machine -- the full path name is preserved\&.
+.IP 
+.IP "\fB--no-relative\fP" 
+Turn off the --relative option\&.  This is only
+needed if you want to use --files-from without its implied --relative
+file processing\&.
+.IP 
+.IP "\fB--no-implied-dirs\fP" 
+When combined with the --relative option, the
+implied directories in each path are not explicitly duplicated as part
+of the transfer\&.  This makes the transfer more optimal and also allows
+the two sides to have non-matching symlinks in the implied part of the
+path\&.  For instance, if you transfer the file "/path/foo/file" with -R,
+the default is for rsync to ensure that "/path" and "/path/foo" on the
+destination exactly match the directories/symlinks of the source\&.  Using
+the --no-implied-dirs option would omit both of these implied dirs,
+which means that if "/path" was a real directory on one machine and a
+symlink of the other machine, rsync would not try to change this\&.
 .IP 
 .IP "\fB-b, --backup\fP" 
-With this option preexisting destination files are
-renamed with a ~ extension as each file is transferred\&.  You can
-control the backup suffix using the --suffix option\&.
+With this option, preexisting destination files are
+renamed as each file is transferred or deleted\&.  You can control where the
+backup file goes and what (if any) suffix gets appended using the
+--backup-dir and --suffix options\&.
 .IP 
 .IP "\fB--backup-dir=DIR\fP" 
 In combination with the --backup option, this
 tells rsync to store all backups in the specified directory\&. This is
 very useful for incremental backups\&.  You can additionally
 specify a backup suffix using the --suffix option
 (otherwise the files backed up in the specified directory
 will keep their original filenames)\&.
 .IP 
 .IP "\fB--suffix=SUFFIX\fP" 
 This option allows you to override the default
-backup suffix used with the -b option\&. The default is a ~\&.
-If --backup-dir and --suffix are both specified,
-the SUFFIX is appended to the filename even in the backup directory\&.
+backup suffix used with the --backup (-b) option\&. The default suffix is a ~
+if no --backup-dir was specified, otherwise it is an empty string\&.
 .IP 
 .IP "\fB-u, --update\fP" 
 This forces rsync to skip any files for which the
 destination file already exists and has a date later than the source
 file\&.
 .IP 
@@ -559,14 +575,19 @@
 .IP 
 .IP "\fB--no-whole-file\fP" 
 Turn off --whole-file, for use when it is the
 default\&.
 .IP 
 .IP "\fB-p, --perms\fP" 
-This option causes rsync to update the remote
-permissions to be the same as the local permissions\&.
+This option causes rsync to set the destination
+permissions to be the same as the source permissions\&.
+.IP 
+Without this option, each new file gets its permissions set based on the
+source file\&'s permissions and the umask at the receiving end, while all
+other files (including updated files) retain their existing permissions
+(which is the same behavior as other file-copy utilities, such as cp)\&.
 .IP 
 .IP "\fB-o, --owner\fP" 
 This option causes rsync to set the owner of the
 destination file to be the same as the source file\&.  On most systems,
 only the super-user can set file ownership\&.  Note that if the remote system
 is a daemon using chroot, the --numeric-ids option is implied because the
@@ -587,25 +608,25 @@
 .IP "\fB-t, --times\fP" 
 This tells rsync to transfer modification times along
 with the files and update them on the remote system\&.  Note that if this
 option is not used, the optimization that excludes files that have not been
 modified cannot be effective; in other words, a missing -t or -a will
 cause the next transfer to behave as if it used -I, and all files will have
-their checksums compared and show up in log messages even if they haven\'t
+their checksums compared and show up in log messages even if they haven\&'t
 changed\&.
 .IP 
 .IP "\fB-n, --dry-run\fP" 
 This tells rsync to not do any file transfers,
 instead it will just report the actions it would have taken\&.
 .IP 
 .IP "\fB-S, --sparse\fP" 
 Try to handle sparse files efficiently so they take
 up less space on the destination\&.
 .IP 
-NOTE: Don\'t use this option when the destination is a Solaris "tmpfs"
-filesystem\&. It doesn\'t seem to handle seeks over null regions
+NOTE: Don\&'t use this option when the destination is a Solaris "tmpfs"
+filesystem\&. It doesn\&'t seem to handle seeks over null regions
 correctly and ends up corrupting the files\&.
 .IP 
 .IP "\fB-x, --one-file-system\fP" 
 This tells rsync not to cross filesystem
 boundaries  when recursing\&.  This  is useful for transferring the
 contents of only one filesystem\&.
@@ -622,20 +643,20 @@
 This tells rsync not to delete more than NUM
 files or directories\&. This is useful when mirroring very large trees
 to prevent disasters\&.
 .IP 
 .IP "\fB--delete\fP" 
 This tells rsync to delete any files on the receiving
-side that aren\'t on the sending side\&.   Files that are excluded from
+side that aren\&'t on the sending side\&.   Files that are excluded from
 transfer are excluded from being deleted unless you use --delete-excluded\&.
 .IP 
 This option has no effect if directory recursion is not selected\&.
 .IP 
 This option can be dangerous if used incorrectly!  It is a very good idea
 to run first using the dry run option (-n) to see what files would be
-deleted to make sure important files aren\'t listed\&.
+deleted to make sure important files aren\&'t listed\&.
 .IP 
 If the sending side detects any IO errors then the deletion of any
 files at the destination will be automatically disabled\&. This is to
 prevent temporary filesystem failures (such as NFS errors) on the
 sending side causing a massive deletion of files on the
 destination\&.  You can override this with the --ignore-errors option\&.
@@ -666,14 +687,14 @@
 This controls the block size used in
 the rsync algorithm\&. See the technical report for details\&.
 .IP 
 .IP "\fB-e, --rsh=COMMAND\fP" 
 This option allows you to choose an alternative
 remote shell program to use for communication between the local and
-remote copies of rsync\&. Typically, rsync is configured to use rsh by
-default, but you may prefer to use ssh because of its high security\&.
+remote copies of rsync\&. Typically, rsync is configured to use ssh by
+default, but you may prefer to use rsh on a local network\&.
 .IP 
 If this option is used with \fB[user@]host::module/path\fP, then the
 remote shell \fICOMMMAND\fP will be used to run an rsync server on the
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
 running rsync server on the remote host\&.  See the section "CONNECTING
@@ -693,87 +714,114 @@
 environment variable, which accepts the same range of values as -e\&.
 .IP 
 See also the --blocking-io option which is affected by this option\&.
 .IP 
 .IP "\fB--rsync-path=PATH\fP" 
 Use this to specify the path to the copy of
-rsync on the remote machine\&. Useful when it\'s not in your path\&. Note
+rsync on the remote machine\&. Useful when it\&'s not in your path\&. Note
 that this is the full path to the binary, not just the directory that
 the binary is in\&.
 .IP 
+.IP "\fB-C, --cvs-exclude\fP" 
+This is a useful shorthand for excluding a
+broad range of files that you often don\&'t want to transfer between
+systems\&. It uses the same algorithm that CVS uses to determine if
+a file should be ignored\&.
+.IP 
+The exclude list is initialized to:
+.IP 
+.RS 
+RCS/ SCCS/ CVS/ \&.svn/ CVS\&.adm RCSLOG cvslog\&.* tags TAGS \&.make\&.state
+\&.nse_depinfo *~ #* \&.#* ,* *\&.old *\&.bak *\&.BAK *\&.orig *\&.rej \&.del-*
+*\&.a *\&.o *\&.obj *\&.so *\&.Z *\&.elc *\&.ln core
+.RE 
+.IP 
+then files listed in a $HOME/\&.cvsignore are added to the list and any
+files listed in the CVSIGNORE environment variable (space delimited)\&.
+.IP 
+Finally, any file is ignored if it is in the same directory as a
+\&.cvsignore file and matches one of the patterns listed therein\&.  See
+the \fBcvs(1)\fP manual for more information\&.
+.IP 
 .IP "\fB--exclude=PATTERN\fP" 
 This option allows you to selectively exclude
 certain files from the list of files to be transferred\&. This is most
 useful in combination with a recursive transfer\&.
 .IP 
 You may use as many --exclude options on the command line as you like
 to build up the list of files to exclude\&.
 .IP 
-See the section on exclude patterns for information on the syntax of 
+See the EXCLUDE PATTERNS section for information on the syntax of 
 this option\&.
 .IP 
 .IP "\fB--exclude-from=FILE\fP" 
 This option is similar to the --exclude
 option, but instead it adds all exclude patterns listed in the file
 FILE to the exclude list\&.  Blank lines in FILE and lines starting with
-\';\' or \'#\' are ignored\&.
+\&';\&' or \&'#\&' are ignored\&.
 If \fIFILE\fP is \fB-\fP the list will be read from standard input\&.
 .IP 
 .IP "\fB--include=PATTERN\fP" 
 This option tells rsync to not exclude the
 specified pattern of filenames\&. This is useful as it allows you to
 build up quite complex exclude/include rules\&.
 .IP 
-See the section of exclude patterns for information on the syntax of 
+See the EXCLUDE PATTERNS section for information on the syntax of 
 this option\&.
 .IP 
 .IP "\fB--include-from=FILE\fP" 
 This specifies a list of include patterns
 from a file\&.
 If \fIFILE\fP is \fB-\fP the list will be read from standard input\&.
 .IP 
-.IP "\fB-C, --cvs-exclude\fP" 
-This is a useful shorthand for excluding a
-broad range of files that you often don\'t want to transfer between
-systems\&. It uses the same algorithm that CVS uses to determine if
-a file should be ignored\&.
-.IP 
-The exclude list is initialized to:
+.IP "\fB--files-from=FILE\fP" 
+Using this option allows you to specify the
+exact list of files to transfer (as read from the specified FILE or "-"
+for stdin)\&.  It also tweaks the default behavior of rsync to make
+transferring just the specified files and directories easier\&.  For
+instance, the --relative option is enabled by default when this option
+is used (use --no-relative if you want to turn that off), all
+directories specified in the list are created on the destination (rather
+than being noisily skipped without -r), and the -a (--archive) option\&'s
+behavior does not imply -r (--recursive) -- specify it explicitly, if
+you want it\&.
+.IP 
+The file names that are read from the FILE are all relative to the
+source dir -- any leading slashes are removed and no "\&.\&." references are
+allowed to go higher than the source dir\&.  For example, take this
+command:
 .IP 
 .RS 
-RCS/ SCCS/ CVS/ \&.svn/ CVS\&.adm RCSLOG cvslog\&.* tags TAGS \&.make\&.state
-\&.nse_depinfo *~ #* \&.#* ,* *\&.old *\&.bak *\&.BAK *\&.orig *\&.rej \&.del-*
-*\&.a *\&.o *\&.obj *\&.so *\&.Z *\&.elc *\&.ln core
+rsync -a --files-from=/tmp/foo /usr remote:/backup
 .RE 
 .IP 
-then files listed in a $HOME/\&.cvsignore are added to the list and any
-files listed in the CVSIGNORE environment variable (space delimited)\&.
+If /tmp/foo contains the string "bin" (or even "/bin"), the /usr/bin
+directory will be created as /backup/bin on the remote host (but the
+contents of the /usr/bin dir would not be sent unless you specified -r
+or the names were explicitly listed in /tmp/foo)\&.  Also keep in mind
+that the effect of the (enabled by default) --relative option is to
+duplicate only the path info that is read from the file -- it does not
+force the duplication of the source-spec path (/usr in this case)\&.
+.IP 
+In addition, the --files-from file can be read from the remote host
+instead of the local host if you specify a "host:" in front of the file
+(the host must match one end of the transfer)\&.  As a short-cut, you can
+specify just a prefix of ":" to mean "use the remote end of the
+transfer"\&.  For example:
 .IP 
-Finally, any file is ignored if it is in the same directory as a
-\&.cvsignore file and matches one of the patterns listed therein\&.  See
-the \fBcvs(1)\fP manual for more information\&.
+.RS 
+rsync -a --files-from=:/path/file-list src:/ /tmp/copy
+.RE 
 .IP 
-.IP "\fB--csum-length=LENGTH\fP" 
-By default the primary checksum used in
-rsync is a very strong 16 byte MD4 checksum\&. In most cases you will
-find that a truncated version of this checksum is quite efficient, and
-this will decrease the size of the checksum data sent over the link,
-making things faster\&. 
-.IP 
-You can choose the number of bytes in the truncated checksum using the
---csum-length option\&. Any value less than or equal to 16 is valid\&.
-.IP 
-Note that if you use this option then you run the risk of ending up
-with an incorrect target file\&. The risk with a value of 16 is
-microscopic and can be safely ignored (the universe will probably end
-before it fails) but with smaller values the risk is higher\&.
-.IP 
-Current versions of rsync actually use an adaptive algorithm for the
-checksum length by default, using a 16 byte file checksum to determine
-if a 2nd pass is required with a longer block checksum\&. Only use this
-option if you have read the source code and know what you are doing\&.
+This would copy all the files specified in the /path/file-list file that
+was located on the remote "src" host\&.
+.IP 
+.IP "\fB-0, --from0\fP" 
+This tells rsync that the filenames it reads from a
+file are terminated by a null (\&'\e0\&') character, not a NL, CR, or CR+LF\&.
+This affects --exclude-from, --include-from, and --files-from\&.
 .IP 
 .IP "\fB-T, --temp-dir=DIR\fP" 
 This option instructs rsync to use DIR as a
 scratch directory when creating temporary copies of the files
 transferred on the receiving side\&.  The default behavior is to create
 the temporary files in the receiving directory\&.
@@ -783,28 +831,30 @@
 the destination machine as an additional directory to compare destination
 files against when doing transfers if the files are missing in the
 destination directory\&.  This is useful for doing transfers to a new
 destination while leaving existing files intact, and then doing a
 flash-cutover when all files have been successfully transferred (for
 example by moving directories around and removing the old directory,
-although this skips files that haven\'t changed; see also --link-dest)\&.
+although this skips files that haven\&'t changed; see also --link-dest)\&.
 This option increases the usefulness of --partial because partially
 transferred files will remain in the new temporary destination until they
 have a chance to be completed\&.  If DIR is a relative path, it is relative
 to the destination directory\&.
 .IP 
 .IP "\fB--link-dest=DIR\fP" 
 This option behaves like \fB--compare-dest\fP but
 also will create hard links from \fIDIR\fP to the destination directory for
 unchanged files\&.  Files with changed ownership or permissions will not be
 linked\&.
+Like \fB--compare-dest\fP if DIR is a relative path, it is relative
+to the destination directory\&.
 .IP 
 .IP "\fB-z, --compress\fP" 
 With this option, rsync compresses any data from
 the files that it sends to the destination machine\&.  This
-option is useful on slow links\&.  The compression method used is the
+option is useful on slow connections\&.  The compression method used is the
 same method that gzip uses\&.
 .IP 
 Note this this option typically achieves better compression ratios
 that can be achieved by using a compressing remote shell, or a
 compressing transport, as it takes advantage of the implicit
 information sent for matching data blocks\&.
@@ -842,13 +892,13 @@
 .IP 
 .IP "\fB--no-detach\fP" 
 When running as a daemon, this option instructs
 rsync to not detach itself and become a background process\&.  This
 option is required when running as a service on Cygwin, and may also
 be useful when rsync is supervised by a program such as
-\fBdaemontools\fP or AIX\'s \fBSystem Resource Controller\fP\&.
+\fBdaemontools\fP or AIX\&'s \fBSystem Resource Controller\fP\&.
 \fB--no-detach\fP is also recommended when rsync is run under a
 debugger\&.  This option has no effect if rsync is run from inetd or
 sshd\&.
 .IP 
 .IP "\fB--address\fP" 
 By default rsync will bind to the wildcard address
@@ -867,17 +917,16 @@
 .IP "\fB--port=PORT\fP" 
 This specifies an alternate TCP port number to use
 rather than the default port 873\&.
 .IP 
 .IP "\fB--blocking-io\fP" 
 This tells rsync to use blocking IO when launching
-a remote shell transport\&.  If -e or --rsh are not specified or are set to
-the default "rsh", this defaults to blocking IO, otherwise it defaults to
-non-blocking IO\&.  You may find the --blocking-io option is needed for some
-remote shells that can\'t handle non-blocking IO\&.  (Note that ssh prefers
-non-blocking IO\&.)
+a remote shell transport\&.  If the remote shell is either rsh or remsh,
+rsync defaults to using
+blocking IO, otherwise it defaults to using non-blocking IO\&.  (Note that
+ssh prefers non-blocking IO\&.)
 .IP 
 .IP "\fB--no-blocking-io\fP" 
 Turn off --blocking-io, for use when it is the
 default\&.
 .IP 
 .IP "\fB--log-format=FORMAT\fP" 
@@ -899,15 +948,13 @@
 make a subsequent transfer of the rest of the file much faster\&.
 .IP 
 .IP "\fB--progress\fP" 
 This option tells rsync to print information
 showing the progress of the transfer\&. This gives a bored user
 something to watch\&.
-.IP 
-This option is normally combined with -v\&. Using this option without
-the -v option will produce weird results on your display\&.
+Implies --verbose without incrementing verbosity\&.
 .IP 
 .IP "\fB-P\fP" 
 The -P option is equivalent to --partial --progress\&. I
 found myself typing that combination quite often so I created an
 option to make it easier\&.
 .IP 
@@ -942,58 +989,70 @@
 .SH "EXCLUDE PATTERNS" 
 .PP 
 The exclude and include patterns specified to rsync allow for flexible
 selection of which files to transfer and which files to skip\&.
 .PP 
 rsync builds an ordered list of include/exclude options as specified on
-the command line\&. When a filename is encountered, rsync checks the
+the command line\&. Rsync checks each file and directory 
 name against each exclude/include pattern in turn\&. The first matching
 pattern is acted on\&. If it is an exclude pattern, then that file is
 skipped\&. If it is an include pattern then that filename is not
 skipped\&. If no matching include/exclude pattern is found then the
 filename is not skipped\&.
 .PP 
+The filenames matched against the exclude/include patterns
+are relative to the destination directory, or "top
+directory", so patterns should not include the path elements
+of the source or destination directories\&.  The only way in
+which a pattern will match the absolute path of a file or
+directory is if the source path is the root directory\&.
+.PP 
 Note that when used with -r (which is implied by -a), every subcomponent of
 every path is visited from top down, so include/exclude patterns get
 applied recursively to each subcomponent\&.
 .PP 
 Note also that the --include and --exclude options take one pattern
 each\&. To add multiple patterns use the --include-from and
 --exclude-from options or multiple --include and --exclude options\&. 
 .PP 
 The patterns can take several forms\&. The rules are:
 .PP 
+.IP 
 .IP o 
 if the pattern starts with a / then it is matched against the
 start of the filename, otherwise it is matched against the end of
-the filename\&.  Thus "/foo" would match a file called "foo" at the base of
-the tree\&.  On the other hand, "foo" would match any file called "foo"
+the filename\&.
+This is the equivalent of a leading ^ in regular expressions\&.
+Thus "/foo" would match a file called "foo" at the top of the
+transferred tree\&.
+On the other hand, "foo" would match any file called "foo"
 anywhere in the tree because the algorithm is applied recursively from
 top down; it behaves as if each path component gets a turn at being the
 end of the file name\&.
+The leading / does not make the pattern an absolute pathname\&.
 .IP 
 .IP o 
 if the pattern ends with a / then it will only match a
 directory, not a file, link or device\&.
 .IP 
 .IP o 
 if the pattern contains a wildcard character from the set
 *?[ then expression matching is applied using the shell filename
 matching rules\&. Otherwise a simple string match is used\&.
 .IP 
 .IP o 
-if the pattern includes a double asterisk "**" then all wildcards in
-the pattern will match slashes, otherwise they will stop at slashes\&.
+the double asterisk pattern "**" will match slashes while a
+single asterisk pattern "*" will stop at slashes\&.
 .IP 
 .IP o 
-if the pattern contains a / (not counting a trailing /) then it
-is matched against the full filename, including any leading
-directory\&. If the pattern doesn\'t contain a / then it is matched
-only against the final component of the filename\&.  Again, remember
-that the algorithm is applied recursively so "full filename" can 
-actually be any portion of a path\&.
+if the pattern contains a / (not counting a trailing /) or a "**"
+then it is matched against the full filename, including any leading
+directory\&. If the pattern doesn\&'t contain a / or a "**", then it is
+matched only against the final component of the filename\&.  Again,
+remember that the algorithm is applied recursively so "full filename" can
+actually be any portion of a path below the starting directory\&.
 .IP 
 .IP o 
 if the pattern starts with "+ " (a plus followed by a space)
 then it is always considered an include pattern, even if specified as
 part of an exclude option\&. The "+ " part is discarded before matching\&.
 .IP 
@@ -1003,36 +1062,37 @@
 part of an include option\&. The "- " part is discarded before matching\&.
 .IP 
 .IP o 
 if the pattern is a single exclamation mark ! then the current
 include/exclude list is reset, removing all previously defined patterns\&.
 .PP 
-The +/- rules are most useful in exclude lists, allowing you to have a
-single exclude list that contains both include and exclude options\&.
+The +/- rules are most useful in a list that was read from a file, allowing
+you to have a single exclude list that contains both include and exclude
+options\&.
 .PP 
-If you end an exclude list with --exclude \'*\', note that since the
+If you end an exclude list with --exclude \&'*\&', note that since the
 algorithm is applied recursively that unless you explicitly include
 parent directories of files you want to include then the algorithm
 will stop at the parent directories and never see the files below
-them\&.  To include all directories, use --include \'*/\' before the
---exclude \'*\'\&.
+them\&.  To include all directories, use --include \&'*/\&' before the
+--exclude \&'*\&'\&.
 .PP 
 Here are some exclude/include examples:
 .PP 
 .IP o 
 --exclude "*\&.o" would exclude all filenames matching *\&.o
 .IP o 
---exclude "/foo" would exclude a file in the base directory called foo
+--exclude "/foo" would exclude a file called foo in the top directory
 .IP o 
 --exclude "foo/" would exclude any directory called foo
 .IP o 
 --exclude "/foo/*/bar" would exclude any file called bar two
-levels below a base directory called foo
+levels below a directory called foo in the top directory
 .IP o 
 --exclude "/foo/**/bar" would exclude any file called bar two
-or more levels below a base directory called foo
+or more levels below a directory called foo in the top directory
 .IP o 
 --include "*/" --include "*\&.c" --exclude "*" would include all 
 directories and C source files
 .IP o 
 --include "foo/" --include "foo/bar\&.c" --exclude "*" would include
 only foo/bar\&.c (the foo/ directory must be explicitly included or
@@ -1086,17 +1146,17 @@
 Example:
 .PP 
 
 .nf 
  
 
-$ rsync --write_batch=pfx -a /source/dir/ /adest/dir/
+$ rsync --write-batch=pfx -a /source/dir/ /adest/dir/
 $ rcp pfx\&.rsync_* remote:
-$ rsh remote rsync --read_batch=pfx -a /bdest/dir/
+$ ssh remote rsync --read-batch=pfx -a /bdest/dir/
 # or alternatively
-$ rsh remote \&./pfx\&.rsync_argvs /bdest/dir/
+$ ssh remote \&./pfx\&.rsync_argvs /bdest/dir/
 
 .fi 
  
 
 .PP 
 In this example, rsync is used to update /adest/dir/ with /source/dir/
@@ -1168,13 +1228,13 @@
 remote shell like this:
 .PP 
 
 .nf 
  
 
-   rsh remotehost /bin/true > out\&.dat
+   ssh remotehost /bin/true > out\&.dat
 
 .fi 
  
 
 .PP 
 then look at out\&.dat\&. If everything is working correctly then out\&.dat
@@ -1188,42 +1248,48 @@
 If you are having trouble debugging include and exclude patterns, then
 try specifying the -vv option\&.  At this level of verbosity rsync will
 show why each individual file is included or excluded\&.
 .PP 
 .SH "EXIT VALUES" 
 .PP 
-.IP "\fBRERR_SYNTAX 1\fP" 
+.IP "\fB0\fP" 
+Success
+.IP "\fB1\fP" 
 Syntax or usage error 
-.IP "\fBRERR_PROTOCOL 2\fP" 
+.IP "\fB2\fP" 
 Protocol incompatibility 
-.IP "\fBRERR_FILESELECT 3\fP" 
+.IP "\fB3\fP" 
 Errors selecting input/output files, dirs
-.IP 
-.IP "\fBRERR_UNSUPPORTED 4\fP" 
+.IP "\fB4\fP" 
 Requested action not supported: an attempt
 was made to manipulate 64-bit files on a platform that cannot support
 them; or an option was speciifed that is supported by the client and
 not by the server\&.
-.IP 
-.IP "\fBRERR_SOCKETIO 10\fP" 
+.IP "\fB5\fP" 
+Error starting client-server protocol
+.IP "\fB10\fP" 
 Error in socket IO 
-.IP "\fBRERR_FILEIO 11\fP" 
+.IP "\fB11\fP" 
 Error in file IO 
-.IP "\fBRERR_STREAMIO 12\fP" 
+.IP "\fB12\fP" 
 Error in rsync protocol data stream 
-.IP "\fBRERR_MESSAGEIO 13\fP" 
+.IP "\fB13\fP" 
 Errors with program diagnostics 
-.IP "\fBRERR_IPC 14\fP" 
+.IP "\fB14\fP" 
 Error in IPC code 
-.IP "\fBRERR_SIGNAL 20\fP" 
+.IP "\fB20\fP" 
 Received SIGUSR1 or SIGINT 
-.IP "\fBRERR_WAITCHILD 21\fP" 
+.IP "\fB21\fP" 
 Some error returned by waitpid() 
-.IP "\fBRERR_MALLOC 22\fP" 
+.IP "\fB22\fP" 
 Error allocating core memory buffers 
-.IP "\fBRERR_TIMEOUT 30\fP" 
+.IP "\fB23\fP" 
+Partial transfer due to error
+.IP "\fB24\fP" 
+Partial transfer due to vanished source files
+.IP "\fB30\fP" 
 Timeout in data send/receive 
 .PP 
 .SH "ENVIRONMENT VARIABLES" 
 .PP 
 .IP 
 .IP "\fBCVSIGNORE\fP" 
@@ -1249,13 +1315,13 @@
 .IP 
 .IP "\fBUSER\fP or \fBLOGNAME\fP" 
 The USER or LOGNAME environment variables
 are used to determine the default username sent to a rsync server\&.
 .IP 
 .IP "\fBHOME\fP" 
-The HOME environment variable is used to find the user\'s
+The HOME environment variable is used to find the user\&'s
 default \&.cvsignore file\&.
 .IP 
 .PP 
 .SH "FILES" 
 .PP 
 /etc/rsyncd\&.conf or rsyncd\&.conf
@@ -1301,13 +1367,13 @@
 Jean-loup Gailly and Mark Adler\&.
 .PP 
 .SH "THANKS" 
 .PP 
 Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
 and David Bell for helpful suggestions, patches and testing of rsync\&.
-I\'ve probably missed some people, my apologies if I have\&.
+I\&'ve probably missed some people, my apologies if I have\&.
 .PP 
 Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer\&.
 .PP 
 .SH "AUTHOR" 
 .PP 
 rsync was written by Andrew Tridgell <tridge@samba\&.org> and Paul
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsync.c	2003-12-04 12:23:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.c	2003-12-19 14:52:02.000000000 +0800
@@ -1,20 +1,20 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1996
    Copyright (C) Paul Mackerras 1996
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /* this file contains code used by more than one part of the rsync
@@ -40,14 +40,14 @@
 	if (s->sums) free(s->sums);
 	free(s);
 }
 
 
 /*
- * delete a file or directory. If force_delete is set then delete 
- * recursively 
+ * delete a file or directory. If force_delete is set then delete
+ * recursively
  */
 int delete_file(char *fname)
 {
 	DIR *d;
 	struct dirent *di;
 	char buf[MAXPATHLEN];
@@ -64,49 +64,58 @@
 	if (ret) {
 		return -1;
 	}
 
 	if (!S_ISDIR(st.st_mode)) {
 		if (robust_unlink(fname) == 0 || errno == ENOENT) return 0;
-		rprintf(FERROR,"delete_file: unlink(%s) : %s\n", fname, strerror(errno));
+		rprintf(FERROR, "delete_file: unlink %s failed: %s\n",
+			full_fname(fname), strerror(errno));
 		return -1;
 	}
 
 	if (do_rmdir(fname) == 0 || errno == ENOENT) return 0;
-	if (!force_delete || !recurse || 
+	if (!force_delete || !recurse ||
 	    (errno != ENOTEMPTY && errno != EEXIST)) {
-		rprintf(FERROR,"delete_file: rmdir(%s) : %s\n", fname, strerror(errno));
+		rprintf(FERROR, "delete_file: rmdir %s failed: %s\n",
+			full_fname(fname), strerror(errno));
 		return -1;
 	}
 
 	/* now we do a recsursive delete on the directory ... */
 	d = opendir(fname);
 	if (!d) {
-		rprintf(FERROR,"delete_file: opendir(%s): %s\n",
-			fname,strerror(errno));
+		rprintf(FERROR, "delete_file: opendir %s failed: %s\n",
+			full_fname(fname), strerror(errno));
 		return -1;
 	}
 
-	for (di=readdir(d); di; di=readdir(d)) {
+	for (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {
 		char *dname = d_name(di);
-		if (strcmp(dname,".")==0 ||
-		    strcmp(dname,"..")==0)
+		if (strcmp(dname,".") == 0
+		    || strcmp(dname,"..") == 0)
 			continue;
 		snprintf(buf, sizeof(buf), "%s/%s", fname, dname);
 		if (verbose > 0)
 			rprintf(FINFO,"deleting %s\n", buf);
 		if (delete_file(buf) != 0) {
 			closedir(d);
 			return -1;
 		}
-	}	
+	}
+	if (errno) {
+		rprintf(FERROR, "delete_file: readdir %s failed: %s\n",
+			full_fname(fname), strerror(errno));
+		closedir(d);
+		return -1;
+	}
 
 	closedir(d);
-	
+
 	if (do_rmdir(fname) != 0) {
-		rprintf(FERROR,"delete_file: rmdir(%s) : %s\n", fname, strerror(errno));
+		rprintf(FERROR, "delete_file: rmdir %s failed: %s\n",
+			full_fname(fname), strerror(errno));
 		return -1;
 	}
 
 	return 0;
 }
 
@@ -142,36 +151,37 @@
 #else
 	return 0;
 #endif
 }
 
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
-	      int report)
+		int report)
 {
 	int updated = 0;
 	STRUCT_STAT st2;
 	int change_uid, change_gid;
 
 	if (dry_run) return 0;
 
 	if (!st) {
 		if (link_stat(fname,&st2) != 0) {
-			rprintf(FERROR,"stat %s : %s\n",fname,strerror(errno));
+			rprintf(FERROR, "stat %s failed: %s\n",
+				full_fname(fname), strerror(errno));
 			return 0;
 		}
 		st = &st2;
 	}
 
 	if (preserve_times && !S_ISLNK(st->st_mode) &&
 	    cmp_modtime(st->st_mtime, file->modtime) != 0) {
 		/* don't complain about not setting times on directories
 		   because some filesystems can't do it */
 		if (set_modtime(fname,file->modtime) != 0 &&
 		    !S_ISDIR(st->st_mode)) {
-			rprintf(FERROR,"failed to set times on %s : %s\n",
-				fname,strerror(errno));
+			rprintf(FERROR, "failed to set times on %s: %s\n",
+				full_fname(fname), strerror(errno));
 			return 0;
 		} else {
 			updated = 1;
 		}
 	}
 
@@ -186,13 +196,14 @@
 	if (change_uid || change_gid) {
 		if (do_lchown(fname,
 			      change_uid?file->uid:st->st_uid,
 			      change_gid?file->gid:st->st_gid) != 0) {
 			/* shouldn't have attempted to change uid or gid
 			     unless have the privilege */
-			rprintf(FERROR,"chown %s : %s\n", fname,strerror(errno));
+			rprintf(FERROR, "chown %s failed: %s\n",
+				full_fname(fname), strerror(errno));
 			return 0;
 		}
 		/* a lchown had been done - we have to re-stat if the
                    destination had the setuid or setgid bits set due
                    to the side effect of the chown call */
 		if (st->st_mode & (S_ISUID | S_ISGID)) {
@@ -200,35 +211,44 @@
 		}
 		updated = 1;
 	}
 
 #ifdef HAVE_CHMOD
 	if (!S_ISLNK(st->st_mode)) {
-		if (st->st_mode != file->mode) {
+		if ((st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS)) {
 			updated = 1;
-			if (do_chmod(fname,file->mode) != 0) {
-				rprintf(FERROR,"failed to set permissions on %s : %s\n",
-					fname,strerror(errno));
+			if (do_chmod(fname,(file->mode & CHMOD_BITS)) != 0) {
+				rprintf(FERROR, "failed to set permissions on %s: %s\n",
+					full_fname(fname), strerror(errno));
 				return 0;
 			}
 		}
 	}
 #endif
-    
+
 	if (verbose > 1 && report) {
 		if (updated)
 			rprintf(FINFO,"%s\n",fname);
 		else
 			rprintf(FINFO,"%s is uptodate\n",fname);
 	}
 	return updated;
 }
 
 
 void sig_int(void)
 {
+	/* KLUGE: if the user hits Ctrl-C while ssh is prompting
+	 * for a password, then our cleanup's sending of a SIGUSR1
+	 * signal to all our children may kill ssh before it has a
+	 * chance to restore the tty settings (i.e. turn echo back
+	 * on).  By sleeping for a short time, ssh gets a bigger
+	 * chance to do the right thing.  If child processes are
+	 * not ssh waiting for a password, then this tiny delay
+	 * shouldn't hurt anything. */
+	msleep(400);
 	exit_cleanup(RERR_SIGNAL);
 }
 
 
 /* finish off a file transfer, renaming the file and setting the permissions
    and ownership */
@@ -237,23 +257,24 @@
 	if (make_backups && !make_backup(fname))
 		return;
 
 	/* move tmp file over real file */
 	if (robust_rename(fnametmp,fname) != 0) {
 		if (errno == EXDEV) {
-			/* rename failed on cross-filesystem link.  
+			/* rename failed on cross-filesystem link.
 			   Copy the file instead. */
 			if (copy_file(fnametmp,fname, file->mode & INITACCESSPERMS)) {
-				rprintf(FERROR,"copy %s -> %s : %s\n",
-					fnametmp,fname,strerror(errno));
+				rprintf(FERROR, "copy %s -> \"%s\": %s\n",
+					full_fname(fnametmp), fname,
+					strerror(errno));
 			} else {
 				set_perms(fname,file,NULL,0);
 			}
 		} else {
-			rprintf(FERROR,"rename %s -> %s : %s\n",
-				fnametmp,fname,strerror(errno));
+			rprintf(FERROR,"rename %s -> \"%s\": %s\n",
+				full_fname(fnametmp), fname, strerror(errno));
 		}
 		do_unlink(fnametmp);
 	} else {
 		set_perms(fname,file,NULL,0);
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsyncd.conf.5	2003-01-27 11:07:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsyncd.conf.5	2004-01-02 03:00:11.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsyncd\&.conf" "5" "26 Jan 2003" "" "" 
+.TH "rsyncd\&.conf" "5" "1 Jan 2004" "" "" 
 .SH "NAME" 
 rsyncd\&.conf \- configuration file for rsync server
 .SH "SYNOPSIS" 
 .PP 
 rsyncd\&.conf
 .PP 
@@ -14,13 +14,13 @@
 available modules\&.
 .PP 
 .SH "FILE FORMAT" 
 .PP 
 The file consists of modules and parameters\&. A module begins with the 
 name of the module in square brackets and continues until the next
-module begins\&. Modules contain parameters of the form \'name = value\'\&.
+module begins\&. Modules contain parameters of the form \&'name = value\&'\&.
 .PP 
 The file is line-based - that is, each newline-terminated line represents
 either a comment, a module name or a parameter\&.
 .PP 
 Only the first equals sign in a parameter is significant\&. Whitespace before 
 or after the first equals sign is discarded\&. Leading, trailing and internal
@@ -91,13 +91,13 @@
 usually contains site information and any legal notices\&. The default
 is no motd file\&.
 .IP 
 .IP "\fBlog file\fP" 
 The "log file" option tells the rsync daemon to log
 messages to that file rather than using syslog\&. This is particularly
-useful on systems (such as AIX) where syslog() doesn\'t work for
+useful on systems (such as AIX) where syslog() doesn\&'t work for
 chrooted programs\&.
 .IP 
 .IP "\fBpid file\fP" 
 The "pid file" option tells the rsync daemon to write
 its process id to that file\&.
 .IP 
@@ -188,50 +188,53 @@
 file transfers to and from that module should take place as when the daemon
 was run as root\&. This complements the "uid" option\&. The default is gid -2,
 which is normally the group "nobody"\&.
 .IP 
 .IP "\fBexclude\fP" 
 The "exclude" option allows you to specify a space
-separated list of patterns to add to the exclude list\&. This is equivalent
-to the client specifying these patterns with the --exclude option, except
-that the exclude list is not passed to the client and thus only applies on
+separated list of patterns to add to the exclude list\&.
+This is only superficially equivalent
+to the client specifying these patterns with the --exclude option\&.
+Only one "exclude" option may be specified, but
+you can use "-" and "+" before patterns to specify exclude/include\&.
+.IP 
+Because this exclude list is not passed to the client it only applies on
 the server: that is, it excludes files received by a client when receiving
 from a server and files deleted on a server when sending to a server, but
-it doesn\'t exclude files sent from a client when sending to a server or
+it doesn\&'t exclude files sent from a client when sending to a server or
 files deleted on a client when receiving from a server\&.  
-Only one "exclude" option may be specified, but
-you can use "-" and "+" before patterns to specify exclude/include\&.
 .IP 
 Note that this option is not designed with strong security in
 mind, it is quite possible that a client may find a way to bypass this
 exclude list\&. If you want to absolutely ensure that certain files
 cannot be accessed then use the uid/gid options in combination with
 file permissions\&.
 .IP 
 .IP "\fBexclude from\fP" 
 The "exclude from" option specifies a filename
-on the server that contains exclude patterns, one per line\&. This is
-equivalent to the client specifying the --exclude-from option with a
-equivalent file except that it applies only on the server\&.  See also
-the "exclude" option above\&.
+on the server that contains exclude patterns, one per line\&.
+This is only superficially equivalent
+to the client specifying the --exclude-from option with an equivalent file\&.
+See the "exclude" option above\&.
 .IP 
 .IP "\fBinclude\fP" 
 The "include" option allows you to specify a space
 separated list of patterns which rsync should not exclude\&. This is
-equivalent to the client specifying these patterns with the --include
-option except that it applies only on the server\&.  This is useful as it
+only superficially equivalent to the client specifying these patterns
+with the --include option because it applies only on the server\&.
+This is useful as it
 allows you to build up quite complex exclude/include rules\&.  Only one
 "include" option may be specified, but you can use "+" and "-" before
-patterns to switch include/exclude\&.  See also the "exclude" option above\&.
+patterns to switch include/exclude\&.  See the "exclude" option above\&.
 .IP 
 .IP "\fBinclude from\fP" 
 The "include from" option specifies a filename
 on the server that contains include patterns, one per line\&. This is
-equivalent to the client specifying the --include-from option with a
-equivalent file except that it applies only on the server\&.  See also
-the "exclude" option above\&.
+only superficially equivalent to the client specifying the
+--include-from option with a equivalent file\&.
+See the "exclude" option above\&.
 .IP 
 .IP "\fBauth users\fP" 
 The "auth users" option specifies a comma and
 space separated list of usernames that will be allowed to connect to
 this module\&. The usernames do not need to exist on the local
 system\&. The usernames may also contain shell wildcard characters\&. If
@@ -253,13 +256,13 @@
 authenticating this module\&. This file is only consulted if the "auth
 users" option is specified\&. The file is line based and contains
 username:password pairs separated by a single colon\&. Any line starting
 with a hash (#) is considered a comment and is skipped\&. The passwords
 can contain any characters but be warned that many operating systems
 limit the length of passwords that can be typed at the client end, so
-you may find that passwords longer than 8 characters don\'t work\&. 
+you may find that passwords longer than 8 characters don\&'t work\&. 
 .IP 
 There is no default for the "secrets file" option, you must choose a name
 (such as \f(CW/etc/rsyncd\&.secrets\fP)\&.  The file must normally not be readable
 by "other"; see "strict modes"\&.
 .IP 
 .IP "\fBstrict modes\fP" 
@@ -277,13 +280,13 @@
 connection is rejected\&.
 .IP 
 Each pattern can be in one of five forms:
 .IP 
 .IP o 
 a dotted decimal IPv4 address of the form a\&.b\&.c\&.d, or an IPv6 address
-of the form a:b:c::d:e:f\&. In this case the incoming machine\'s IP address
+of the form a:b:c::d:e:f\&. In this case the incoming machine\&'s IP address
 must match exactly\&.
 .IP 
 .IP o 
 an address/mask in the form ipaddr/n where ipaddr is the IP address
 and n is the number of one bits in the netmask\&.  All IP addresses which
 match the masked IP address will be allowed in\&.
@@ -344,13 +347,13 @@
 behaviour\&. 
 .IP 
 .IP "\fBignore nonreadable\fP" 
 This tells the rsync server to completely
 ignore files that are not readable by the user\&. This is useful for
 public archives that may have some non-readable files among the
-directories, and the sysadmin doesn\'t want those files to be seen at all\&.
+directories, and the sysadmin doesn\&'t want those files to be seen at all\&.
 .IP 
 .IP "\fBtransfer logging\fP" 
 The "transfer logging" option enables per-file 
 logging of downloads and uploads in a format somewhat similar to that
 used by ftp daemons\&. If you want to customize the log formats look at
 the log format option\&.
@@ -395,13 +398,13 @@
 A perl script called rsyncstats to summarize this format is included
 in the rsync source code distribution\&.
 .IP 
 .IP "\fBtimeout\fP" 
 The "timeout" option allows you to override the
 clients choice for IO timeout for this module\&. Using this option you
-can ensure that rsync won\'t wait on a dead client forever\&. The timeout
+can ensure that rsync won\&'t wait on a dead client forever\&. The timeout
 is specified in seconds\&. A value of zero means no timeout and is the
 default\&. A good choice for anonymous rsync servers may be 600 (giving
 a 10 minute timeout)\&.
 .IP 
 .IP "\fBrefuse options\fP" 
 The "refuse options" option allows you to
@@ -414,13 +417,13 @@
 client that requests compression\&.
 .IP 
 .IP "\fBdont compress\fP" 
 The "dont compress" option allows you to select
 filenames based on wildcard patterns that should not be compressed
 during transfer\&. Compression is expensive in terms of CPU usage so it
-is usually good to not try to compress files that won\'t compress well,
+is usually good to not try to compress files that won\&'t compress well,
 such as already compressed files\&. 
 .IP 
 The "dont compress" option takes a space separated list of
 case-insensitive wildcard patterns\&. Any source filename matching one
 of the patterns will not be compressed during transfer\&.
 .IP 
@@ -440,19 +443,49 @@
 demonstrated a brute-force break of this sort of system you should
 realize that this is not a "military strength" authentication system\&.
 It should be good enough for most purposes but if you want really top
 quality security then I recommend that you run rsync over ssh\&.
 .PP 
 Also note that the rsync server protocol does not currently provide any
-encryption of the data that is transferred over the link\&. Only
+encryption of the data that is transferred over the connection\&. Only
 authentication is provided\&. Use ssh as the transport if you want
 encryption\&.
 .PP 
 Future versions of rsync may support SSL for better authentication and
 encryption, but that is still being investigated\&.
 .PP 
+.SH "RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" 
+.PP 
+If rsync is run with both the --daemon and --rsh (-e) options, it will
+spawn an rsync daemon using a remote shell connection\&.  Several
+configuration options will not be available unless the remote user is
+root (e\&.g\&. chroot, setuid/setgid, etc\&.)\&.  There is no need to configure
+inetd or the services map to include the rsync server port if you run an
+rsync server only via a remote shell program\&.
+.PP 
+ADVANCED: To run an rsync server out of a single-use ssh key, use the
+"command=\fICOMMAND\fP" syntax in the remote user\&'s authorized_keys entry,
+where command would be
+.PP 
+.RS 
+rsync --server --daemon \&.
+.RE 
+.PP 
+NOTE: rsync\&'s argument parsing expects the trailing "\&.", so make sure
+that it\&'s there\&.  If you want to use a rsyncd\&.conf(5)-style
+configuration file other than the default, you can added a
+--config option to the \fIcommand\fP:
+.PP 
+.RS 
+rsync --server --daemon --config=\fIfile\fP \&.
+.RE 
+.PP 
+Note that the "--server" here is the internal option that rsync uses to
+run the remote version of rsync that it communicates with, and thus you
+should not be using the --server option under normal circumstances\&.
+.PP 
 .SH "EXAMPLES" 
 .PP 
 A simple rsyncd\&.conf file that allow anonymous rsync to a ftp area at
 \f(CW/home/ftp\fP would be:
 .PP 
 
@@ -533,13 +566,13 @@
 failed\&. The error will have been logged by syslog on the server\&.
 .PP 
 Please report bugs! The rsync bug tracking system is online at
 http://rsync\&.samba\&.org/
 .PP 
 .SH "VERSION" 
-This man page is current for version 2\&.0 of rsync
+This man page is current for version 2\&.x of rsync\&.
 .PP 
 .SH "CREDITS" 
 .PP 
 rsync is distributed under the GNU public license\&.  See the file
 COPYING for details\&.
 .PP 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsyncd.conf.yo	2003-01-27 11:07:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsyncd.conf.yo	2004-01-02 03:00:11.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(26 Jan 2003)()()
+manpage(rsyncd.conf)(5)(1 Jan 2004)()()
 manpagename(rsyncd.conf)(configuration file for rsync server)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -173,47 +173,50 @@
 dit(bf(gid)) The "gid" option specifies the group name or group id that
 file transfers to and from that module should take place as when the daemon
 was run as root. This complements the "uid" option. The default is gid -2,
 which is normally the group "nobody".
 
 dit(bf(exclude)) The "exclude" option allows you to specify a space
-separated list of patterns to add to the exclude list. This is equivalent
-to the client specifying these patterns with the --exclude option, except
-that the exclude list is not passed to the client and thus only applies on
+separated list of patterns to add to the exclude list.
+This is only superficially equivalent
+to the client specifying these patterns with the --exclude option.
+Only one "exclude" option may be specified, but
+you can use "-" and "+" before patterns to specify exclude/include.
+
+Because this exclude list is not passed to the client it only applies on
 the server: that is, it excludes files received by a client when receiving
 from a server and files deleted on a server when sending to a server, but
 it doesn't exclude files sent from a client when sending to a server or
 files deleted on a client when receiving from a server.  
-Only one "exclude" option may be specified, but
-you can use "-" and "+" before patterns to specify exclude/include.
 
 Note that this option is not designed with strong security in
 mind, it is quite possible that a client may find a way to bypass this
 exclude list. If you want to absolutely ensure that certain files
 cannot be accessed then use the uid/gid options in combination with
 file permissions.
 
 dit(bf(exclude from)) The "exclude from" option specifies a filename
-on the server that contains exclude patterns, one per line. This is
-equivalent to the client specifying the --exclude-from option with a
-equivalent file except that it applies only on the server.  See also
-the "exclude" option above.
+on the server that contains exclude patterns, one per line.
+This is only superficially equivalent
+to the client specifying the --exclude-from option with an equivalent file.
+See the "exclude" option above.
 
 dit(bf(include)) The "include" option allows you to specify a space
 separated list of patterns which rsync should not exclude. This is
-equivalent to the client specifying these patterns with the --include
-option except that it applies only on the server.  This is useful as it
+only superficially equivalent to the client specifying these patterns
+with the --include option because it applies only on the server.
+This is useful as it
 allows you to build up quite complex exclude/include rules.  Only one
 "include" option may be specified, but you can use "+" and "-" before
-patterns to switch include/exclude.  See also the "exclude" option above.
+patterns to switch include/exclude.  See the "exclude" option above.
 
 dit(bf(include from)) The "include from" option specifies a filename
 on the server that contains include patterns, one per line. This is
-equivalent to the client specifying the --include-from option with a
-equivalent file except that it applies only on the server.  See also
-the "exclude" option above.
+only superficially equivalent to the client specifying the
+--include-from option with a equivalent file.
+See the "exclude" option above.
 
 dit(bf(auth users)) The "auth users" option specifies a comma and
 space separated list of usernames that will be allowed to connect to
 this module. The usernames do not need to exist on the local
 system. The usernames may also contain shell wildcard characters. If
 "auth users" is set then the client will be challenged to supply a
@@ -386,19 +389,45 @@
 demonstrated a brute-force break of this sort of system you should
 realize that this is not a "military strength" authentication system.
 It should be good enough for most purposes but if you want really top
 quality security then I recommend that you run rsync over ssh.
 
 Also note that the rsync server protocol does not currently provide any
-encryption of the data that is transferred over the link. Only
+encryption of the data that is transferred over the connection. Only
 authentication is provided. Use ssh as the transport if you want
 encryption.
 
 Future versions of rsync may support SSL for better authentication and
 encryption, but that is still being investigated.
 
+manpagesection(RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM)
+
+If rsync is run with both the --daemon and --rsh (-e) options, it will
+spawn an rsync daemon using a remote shell connection.  Several
+configuration options will not be available unless the remote user is
+root (e.g. chroot, setuid/setgid, etc.).  There is no need to configure
+inetd or the services map to include the rsync server port if you run an
+rsync server only via a remote shell program.
+
+ADVANCED: To run an rsync server out of a single-use ssh key, use the
+"command=em(COMMAND)" syntax in the remote user's authorized_keys entry,
+where command would be
+
+quote(rsync --server --daemon .)
+
+NOTE: rsync's argument parsing expects the trailing ".", so make sure
+that it's there.  If you want to use a rsyncd.conf(5)-style
+configuration file other than the default, you can added a
+--config option to the em(command):
+
+quote(rsync --server --daemon --config=em(file) .)
+
+Note that the "--server" here is the internal option that rsync uses to
+run the remote version of rsync that it communicates with, and thus you
+should not be using the --server option under normal circumstances.
+
 manpagesection(EXAMPLES)
 
 A simple rsyncd.conf file that allow anonymous rsync to a ftp area at
 tt(/home/ftp) would be:
 
 verb(
@@ -462,13 +491,13 @@
 failed. The error will have been logged by syslog on the server.
 
 Please report bugs! The rsync bug tracking system is online at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
-This man page is current for version 2.0 of rsync
+This man page is current for version 2.x of rsync.
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsync.h	2003-12-04 12:23:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.h	2003-12-17 07:04:59.000000000 +0800
@@ -21,12 +21,13 @@
 
 #define False 0
 #define True 1
 
 #define BLOCK_SIZE 700
 #define RSYNC_RSH_ENV "RSYNC_RSH"
+#define RSYNC_RSH_IO_ENV "RSYNC_RSH_IO"
 
 #define RSYNC_NAME "rsync"
 #define RSYNCD_SYSCONF "/etc/rsyncd.conf"
 #define RSYNCD_USERCONF "rsyncd.conf"
 
 #define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
@@ -47,51 +48,70 @@
 #define SAME_DIR (1<<5)
 #define SAME_NAME SAME_DIR
 #define LONG_NAME (1<<6)
 #define SAME_TIME (1<<7)
 
 /* update this if you make incompatible changes */
-#define PROTOCOL_VERSION 26
+#define PROTOCOL_VERSION 27
 
 /* We refuse to interoperate with versions that are not in this range.
  * Note that we assume we'll work with later versions: the onus is on
  * people writing them to make sure that they don't send us anything
  * we won't understand.
  *
- * There are two possible explanations for the limit at thirty: either
- * to allow new major-rev versions that do not interoperate with us,
- * and (more likely) so that we can detect an attempt to connect rsync
- * to a non-rsync server, which is unlikely to begin by sending a byte
- * between 15 and 30. */
-#define MIN_PROTOCOL_VERSION 15
-#define MAX_PROTOCOL_VERSION 30
+ * Interoperation with old but supported protocol versions
+ * should cause a warning to be printed.  At a future date
+ * the old protocol will become the minimum and
+ * compatibility code removed.
+ *
+ * There are two possible explanations for the limit at
+ * MAX_PROTOCOL_VERSION: either to allow new major-rev versions that
+ * do not interoperate with us, and (more likely) so that we can
+ * detect an attempt to connect rsync to a non-rsync server, which is
+ * unlikely to begin by sending a byte between MIN_PROTOCL_VERSION and
+ * MAX_PROTOCOL_VERSION. */
+
+#define MIN_PROTOCOL_VERSION 17
+#define OLD_PROTOCOL_VERSION 20
+#define MAX_PROTOCOL_VERSION 40
 
 #define RSYNC_PORT 873
 
 #define SPARSE_WRITE_SIZE (1024)
 #define WRITE_SIZE (32*1024)
 #define CHUNK_SIZE (32*1024)
 #define MAX_MAP_SIZE (256*1024)
 #define IO_BUFFER_SIZE (4092)
 
+#define IOERR_GENERAL	(1<<0) /* For backward compatibility, this must == 1 */
+#define IOERR_VANISHED	(1<<1)
+
 #define MAX_ARGS 1000
 
 #define MPLEX_BASE 7
 
+#define NO_EXCLUDES	0
+#define SERVER_EXCLUDES	1
+#define ALL_EXCLUDES	2
+
+#define MISSING_OK    0
+#define MISSING_FATAL 1
+
+#define ADD_INCLUDE 1
+#define ADD_EXCLUDE 0
+
 /* Log values.  I *think* what these mean is: FLOG goes to the server
  * logfile; FERROR and FINFO try to end up on the client, with
  * different levels of filtering. */
 enum logcode {FNONE=0, FERROR=1, FINFO=2, FLOG=3 };
 
 #include "errcode.h"
 
 #include "config.h"
 
-/* The default RSYNC_RSH is always set in config.h, either to "remsh",
- * "rsh", or otherwise something specified by the user.  HAVE_REMSH
- * controls parameter munging for HP/UX, etc. */
+/* The default RSYNC_RSH is always set in config.h. */
 
 #include <sys/types.h>
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -103,24 +123,24 @@
 #endif
 
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
 
+#if defined(HAVE_MALLOC_H) && (defined(HAVE_MALLINFO) || !defined(HAVE_STDLIB_H))
+#include <malloc.h>
+#endif
+
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
 
 #ifdef HAVE_STRING_H
 #include <string.h>
 #endif
 
-#ifdef HAVE_MALLOC_H
-#include <malloc.h>
-#endif
-
 #ifdef TIME_WITH_SYS_TIME
 #include <sys/time.h>
 #include <time.h>
 #else
 #ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
@@ -171,26 +191,16 @@
 /* apparently AIX needs this for S_ISLNK */
 #ifndef S_ISLNK
 #include <sys/mode.h>
 #endif
 #endif
 
-#ifdef HAVE_FNMATCH
-#include <fnmatch.h>
-#else
-#include "lib/fnmatch.h"
-#endif
-
 #ifdef HAVE_GLOB_H
 #include <glob.h>
 #endif
 
-#ifdef HAVE_MALLOC_H
-#  include <malloc.h>
-#endif
-
 /* these are needed for the uid/gid mapping code */
 #include <pwd.h>
 #include <grp.h>
 
 #include <stdarg.h>
 #include <netinet/in.h>
@@ -270,12 +280,23 @@
 #else
 /* As long as it gets... */
 #define int64 off_t
 #define NO_INT64
 #endif
 
+#if (SIZEOF_LONG == 8) 
+#define uint64 unsigned long
+#elif (SIZEOF_INT == 8) 
+#define uint64 unsigned int
+#elif HAVE_LONGLONG
+#define uint64 unsigned long long
+#else
+/* As long as it gets... */
+#define uint64 unsigned off_t
+#endif
+
 /* Starting from protocol version 26, we always use 64-bit
  * ino_t and dev_t internally, even if this platform does not
  * allow files to have 64-bit inums.  That's because the
  * receiver needs to find duplicate (dev,ino) tuples to detect
  * hardlinks, and it might have files coming from a platform
  * that has 64-bit inums.
@@ -301,14 +322,14 @@
  * to a little one in a useful way.
  *
  * FIXME: Really we need an unsigned type, and we perhaps ought to
  * cope with platforms on which this is an unsigned int or even a
  * struct.  Later.
  */ 
-#define INO64_T int64
-#define DEV64_T int64
+#define INO64_T uint64
+#define DEV64_T uint64
 
 #ifndef MIN
 #define MIN(a,b) ((a)<(b)?(a):(b))
 #endif
 
 #ifndef MAX
@@ -319,17 +340,23 @@
 #define MAXHOSTNAMELEN 256
 #endif
 
 /* the length of the md4 checksum */
 #define MD4_SUM_LENGTH 16
 #define SUM_LENGTH 16
+#define SHORT_SUM_LENGTH 2
+#define BLOCKSUM_BIAS 10
 
 #ifndef MAXPATHLEN
 #define MAXPATHLEN 1024
 #endif
 
+#ifndef NAME_MAX
+#define NAME_MAX 255
+#endif
+
 #ifndef INADDR_NONE
 #define INADDR_NONE 0xffffffff
 #endif
 
 #ifndef IN_LOOPBACKNET
 #define IN_LOOPBACKNET 127
@@ -382,29 +409,41 @@
 };
 
 struct sum_struct {
 	OFF_T flength;		/**< total file length */
 	size_t count;		/**< how many chunks */
 	size_t remainder;	/**< flength % block_length */
-	size_t n;		/**< block_length */
+	size_t blength;		/**< block_length */
+	size_t s2length;	/**< sum2_length */
 	struct sum_buf *sums;	/**< points to info for each chunk */
 };
 
 struct map_struct {
-	char *p;
-	int fd,p_size,p_len;
-	OFF_T file_size, p_offset, p_fd_offset;
+	char *p;		/* Window pointer			*/
+	int fd;			/* File Descriptor			*/
+	int p_size;		/* Window size at allocation		*/
+	int p_len;		/* Window size after fill		*/
+				/*    p_size and p_len could be
+				 *    consolodated by using a local
+				 *    variable in map_ptr()		*/
+	int status;		/* first errno from read errors		*/
+	OFF_T file_size;	/* File size (from stat)		*/
+	OFF_T p_offset;		/* Window start				*/
+	OFF_T p_fd_offset;	/* offset of cursor in fd ala lseek	*/
 };
 
+#define MATCHFLG_WILD		(1<<0) /* pattern has '*', '[', and/or '?' */
+#define MATCHFLG_WILD2		(1<<1) /* pattern has '**' */
+#define MATCHFLG_WILD2_PREFIX	(1<<2) /* pattern starts with '**' */
+#define MATCHFLG_ABS_PATH	(1<<3) /* path-match on absolute path */
 struct exclude_struct {
 	char *pattern;
-	int regular_exp;
-	int fnmatch_flags;
+	int match_flags;
 	int include;
 	int directory;
-	int local;
+	int slash_cnt;
 };
 
 struct stats {
 	int64 total_size;
 	int64 total_transferred_size;
 	int64 total_written;
@@ -425,12 +464,13 @@
 	while (!flist->files[i]->basename) i++;
 	return i;
 }
 
 #include "byteorder.h"
 #include "lib/mdfour.h"
+#include "lib/wildmatch.h"
 #include "lib/permstring.h"
 #include "lib/addrinfo.h"
 
 #include "proto.h"
 
 /* We have replacement versions of these if they're missing. */
@@ -439,17 +479,19 @@
 #endif
 
 #ifndef HAVE_VASPRINTF
 int vasprintf(char **ptr, const char *format, va_list ap);
 #endif
 
-#if !defined(HAVE_VSNPRINTF) && !defined(HAVE_C99_VSNPRINTF)
-int vsnprintf (char *str, size_t count, const char *fmt, va_list args);
+#if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
+#define vsnprintf rsync_vsnprintf
+int vsnprintf(char *str, size_t count, const char *fmt, va_list args);
 #endif
 
-#if !defined(HAVE_SNPRINTF) && !defined(HAVE_C99_VSNPRINTF)
+#if !defined(HAVE_SNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
+#define snprintf rsync_snprintf
 int snprintf(char *str,size_t count,const char *fmt,...);
 #endif
 
 
 #if !HAVE_STRERROR
 extern char *sys_errlist[];
@@ -494,12 +536,22 @@
 #endif
 
 #ifndef S_IWUSR
 #define S_IWUSR 0200
 #endif
 
+#ifndef ACCESSPERMS
+#define ACCESSPERMS 0777
+#endif
+
+#ifndef S_ISVTX
+#define S_ISVTX 0
+#endif
+
+#define CHMOD_BITS (S_ISUID | S_ISGID | S_ISVTX | ACCESSPERMS)
+
 #ifndef _S_IFMT
 #define _S_IFMT        0170000
 #endif
 
 #ifndef _S_IFLNK
 #define _S_IFLNK  0120000
@@ -557,15 +609,12 @@
 #ifndef INADDR_NONE
 #define INADDR_NONE 0xffffffff
 #endif
 
 #define IS_DEVICE(mode) (S_ISCHR(mode) || S_ISBLK(mode) || S_ISSOCK(mode) || S_ISFIFO(mode))
 
-#ifndef ACCESSPERMS
-#define ACCESSPERMS 0777
-#endif
 /* Initial mask on permissions given to temporary files.  Mask off setuid
      bits and group access because of potential race-condition security
      holes, and mask other access because mode 707 is bizarre */
 #define INITACCESSPERMS 0700
 
 /* handler for null strings in printf format */
@@ -596,12 +645,16 @@
      ;
 
 #ifdef REPLACE_INET_NTOA
 #define inet_ntoa rep_inet_ntoa
 #endif
 
+/* Make sure that the O_BINARY flag is defined. */
+#ifndef O_BINARY
+#define O_BINARY 0
+#endif
 
 #ifndef HAVE_STRLCPY
 size_t strlcpy(char *d, const char *s, size_t bufsize);
 #endif
 
 #ifndef HAVE_STRLCAT
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/rsync.yo	2003-01-28 11:11:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.yo	2004-01-02 03:00:11.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(26 Jan 2003)()()
+manpage(rsync)(1)(1 Jan 2004)()()
 manpagename(rsync)(faster, flexible replacement for rcp)
 manpagesynopsis()
 
 rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
 
 rsync [OPTION]... [USER@]HOST:SRC DEST
@@ -22,23 +22,23 @@
 rsync is a program that behaves in much the same way that rcp does,
 but has many more options and uses the rsync remote-update protocol to
 greatly speed up file transfers when the destination file already
 exists.
 
 The rsync remote-update protocol allows rsync to transfer just the
-differences between two sets of files across the network link, using
+differences between two sets of files across the network connection, using
 an efficient checksum-search algorithm described in the technical
 report that accompanies this package.
 
 Some of the additional features of rsync are:
 
 itemize(
   it() support for copying links, devices, owners, groups and permissions
   it() exclude and exclude-from options similar to GNU tar
   it() a CVS exclude mode for ignoring the same files that CVS would ignore
-  it() can use any transparent remote shell, including rsh or ssh
+  it() can use any transparent remote shell, including ssh or rsh
   it() does not require root privileges
   it() pipelining of file transfers to minimize latency costs
   it() support for anonymous or authenticated rsync servers (ideal for
        mirroring)
 )
 
@@ -48,14 +48,14 @@
 
 itemize(
 	it() for copying local files. This is invoked when neither
 	     source nor destination path contains a : separator
 
 	it() for copying from the local machine to a remote machine using
-	a remote shell program as the transport (such as rsh or
-	ssh). This is invoked when the destination path contains a
+	a remote shell program as the transport (such as ssh or
+	rsh). This is invoked when the destination path contains a
 	single : separator.
 
 	it() for copying from a remote machine to the local machine
 	using a remote shell program. This is invoked when the source
 	contains a : separator.
 
@@ -90,15 +90,15 @@
 manpagesection(SETUP)
 
 See the file README for installation instructions.
 
 Once installed, you can use rsync to any machine that you can access via
 a remote shell (as well as some that you can access using the rsync
-daemon-mode protocol).  For remote transfers, rsync typically uses rsh
+daemon-mode protocol).  For remote transfers, a modern rsync uses ssh
 for its communications, but it may have been configured to use a
-different remote shell by default, such as ssh.
+different remote shell by default, such as rsh or remsh.
 
 You can also specify any remote shell you like, either by using the -e
 command line option, or by setting the RSYNC_RSH environment variable.
 
 One common substitute is to use ssh, which offers a high degree of
 security.
@@ -112,43 +112,48 @@
 and a destination, one of which may be remote.
 
 Perhaps the best way to explain the syntax is some examples:
 
 quote(rsync *.c foo:src/)
 
-this would transfer all files matching the pattern *.c from the
+This would transfer all files matching the pattern *.c from the
 current directory to the directory src on the machine foo. If any of
 the files already exist on the remote system then the rsync
 remote-update protocol is used to update the file by sending only the
 differences. See the tech report for details.
 
 quote(rsync -avz foo:src/bar /data/tmp)
 
-this would recursively transfer all files from the directory src/bar on the
+This would recursively transfer all files from the directory src/bar on the
 machine foo into the /data/tmp/bar directory on the local machine. The
 files are transferred in "archive" mode, which ensures that symbolic
 links, devices, attributes, permissions, ownerships etc are preserved
 in the transfer.  Additionally, compression will be used to reduce the
 size of data portions of the transfer.
 
 quote(rsync -avz foo:src/bar/ /data/tmp)
 
-a trailing slash on the source changes this behavior to transfer
-all files from the directory src/bar on the machine foo into the
-/data/tmp/.  A trailing / on a source name means "copy the
-contents of this directory".  Without a trailing slash it means "copy
-the directory". This difference becomes particularly important when
-using the --delete option.
+A trailing slash on the source changes this behavior to avoid creating an
+additional directory level at the destination.  You can think of a trailing
+/ on a source as meaning "copy the contents of this directory" as opposed
+to "copy the directory by name", but in both cases the attributes of the
+containing directory are transferred to the containing directory on the
+destination.  In other words, each of the following commands copies the
+files in the same way, including their setting of the attributes of
+/dest/foo:
+
+quote(rsync -avz /src/foo /dest)
+quote(rsync -avz /src/foo/ /dest/foo)
 
 You can also use rsync in local-only mode, where both the source and
 destination don't have a ':' in the name. In this case it behaves like
 an improved copy command.
 
 quote(rsync somehost.mydomain.com::)
 
-this would list all the anonymous rsync modules available on the host
+This would list all the anonymous rsync modules available on the host
 somehost.mydomain.com.  (See the following section for more details.)
 
 
 manpagesection(CONNECTING TO AN RSYNC SERVER)
 
 It is also possible to use rsync without a remote shell as the
@@ -186,14 +191,14 @@
 WARNING: On some systems environment variables are visible to all
 users. On those systems using --password-file is recommended.
 
 manpagesection(CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM)
 
 It is sometimes useful to be able to set up file transfers using rsync
-server capabilities on the remote machine, while still using rsh or
-ssh for transport.  This is especially useful when you want to connect
+server capabilities on the remote machine, while still using ssh or
+rsh for transport.  This is especially useful when you want to connect
 to a remote machine via ssh (for encryption or to get through a
 firewall), but you still want to have access to the rsync server
 features (see RUNNING AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM,
 below).  
 
 From the user's perspective, using rsync in this way is the same as
@@ -226,35 +231,25 @@
 
 Several configuration options will not be available unless the remote
 user is root (e.g. chroot, setuid/setgid, etc.).  There is no need to
 configure inetd or the services map to include the rsync server port
 if you run an rsync server only via a remote shell program.
 
-To run an rsync server out of a single-use ssh key, use the
-"command=em(COMMAND)" syntax in the remote user's
-authorized_keys entry, where command would be
-
-quote(rsync --server --daemon .)
-
-NOTE: rsync's argument parsing expects the trailing ".", so make sure
-that it's there.  If you want to use a rsyncd.conf(5)-style
-configuration file other than the default, you can added a
---config option to the em(command):
-
-quote(rsync --server --daemon --config=em(file) .)
+To run an rsync server out of a single-use ssh key, see this section
+in the rsyncd.conf(5) man page.
 
 manpagesection(EXAMPLES)
 
 Here are some examples of how I use rsync.
 
 To backup my wife's home directory, which consists of large MS Word
 files and mail folders, I use a cron job that runs
 
 quote(rsync -Cavz . arvidsjaur:backup)
 
-each night over a PPP link to a duplicate directory on my machine
+each night over a PPP connection to a duplicate directory on my machine
 "arvidsjaur".
 
 To synchronize my samba source trees I use the following Makefile
 targets:
 
 quote(      get:nl()
@@ -263,13 +258,13 @@
       put:nl()
        rsync -Cavuzb . samba:samba/
 
       sync: get put)
 
 this allows me to sync with a CVS directory at the other end of the
-link. I then do cvs operations on the remote machine, which saves a
+connection. I then do cvs operations on the remote machine, which saves a
 lot of time as the remote cvs protocol isn't very efficient.
 
 I mirror a directory between my "old" and "new" ftp sites with the
 command
 
 quote(rsync -az -e ssh --delete ~ftp/pub/samba/ nimbus:"~ftp/pub/tridge/samba")
@@ -285,15 +280,17 @@
  -v, --verbose               increase verbosity
  -q, --quiet                 decrease verbosity
  -c, --checksum              always checksum
  -a, --archive               archive mode, equivalent to -rlptgoD
  -r, --recursive             recurse into directories
  -R, --relative              use relative path names
- -b, --backup                make backups (default ~ suffix)
+     --no-relative           turn off --relative
+     --no-implied-dirs       don't send implied dirs with -R
+ -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir            make backups into this directory
-     --suffix=SUFFIX         define backup suffix
+     --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                update only (don't overwrite newer files)
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            copy the referent of symlinks
      --copy-unsafe-links     copy links outside the source tree
      --safe-links            ignore links outside the destination tree
  -H, --hard-links            preserve hard links
@@ -305,38 +302,40 @@
  -S, --sparse                handle sparse files efficiently
  -n, --dry-run               show what would have been transferred
  -W, --whole-file            copy whole files, no incremental checks
      --no-whole-file         turn off --whole-file
  -x, --one-file-system       don't cross filesystem boundaries
  -B, --block-size=SIZE       checksum blocking size (default 700)
- -e, --rsh=COMMAND           specify the remote shell to use
+ -e, --rsh=COMMAND           specify the remote shell
      --rsync-path=PATH       specify path to rsync on the remote machine
- -C, --cvs-exclude           auto ignore files in the same way CVS does
      --existing              only update files that already exist
-     --ignore-existing       ignore files that already exist on the receiving side
-     --delete                delete files that don't exist on the sending side
-     --delete-excluded       also delete excluded files on the receiving side
+     --ignore-existing       ignore files that already exist on receiver
+     --delete                delete files that don't exist on sender
+     --delete-excluded       also delete excluded files on receiver
      --delete-after          delete after transferring, not before
      --ignore-errors         delete even if there are IO errors
      --max-delete=NUM        don't delete more than NUM files
      --partial               keep partially transferred files
-     --force                 force deletion of directories even if not empty
+     --force                 force deletion of dirs even if not empty
      --numeric-ids           don't map uid/gid values by user/group name
      --timeout=TIME          set IO timeout in seconds
- -I, --ignore-times          don't exclude files that match length and time
-     --size-only             only use file size when determining if a file should be transferred
-     --modify-window=NUM     Timestamp window (seconds) for file match (default=0)
+ -I, --ignore-times          turn off mod time & file size quick check
+     --size-only             ignore mod time for quick check (use size)
+     --modify-window=NUM     compare mod times with reduced accuracy
  -T  --temp-dir=DIR          create temporary files in directory DIR
-     --compare-dest=DIR      also compare destination files relative to DIR
+     --compare-dest=DIR      also compare received files relative to DIR
      --link-dest=DIR         create hardlinks to DIR for unchanged files
  -P                          equivalent to --partial --progress
  -z, --compress              compress file data
+ -C, --cvs-exclude           auto ignore files in the same way CVS does
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     exclude patterns listed in FILE
      --include=PATTERN       don't exclude files matching PATTERN
      --include-from=FILE     don't exclude patterns listed in FILE
+     --files-from=FILE       read FILE for list of source-file names
+ -0  --from0                 all file lists are delimited by nulls
      --version               print version number
      --daemon                run as a rsync daemon
      --no-detach             do not detach from the parent
      --address=ADDRESS       bind to the specified address
      --config=FILE           specify alternate rsyncd.conf file
      --port=PORT             specify alternate rsyncd port number
@@ -344,14 +343,14 @@
      --no-blocking-io        turn off --blocking-io
      --stats                 give some file transfer stats
      --progress              show progress during transfer
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
      --bwlimit=KBPS          limit I/O bandwidth, KBytes per second
-     --read-batch=PREFIX     read batch fileset starting with PREFIX
      --write-batch=PREFIX    write batch fileset starting with PREFIX
+     --read-batch=PREFIX     read batch fileset starting with PREFIX
  -h, --help                  show this help screen
 
 
 )
 
 manpageoptions()
@@ -379,17 +378,17 @@
 dit(bf(-q, --quiet)) This option decreases the amount of information you
 are given during the transfer, notably suppressing information messages
 from the remote server. This flag is useful when invoking rsync from
 cron.
 
 dit(bf(-I, --ignore-times)) Normally rsync will skip any files that are
-already the same length and have the same time-stamp. This option turns
-off this behavior.
+already the same size and have the same modification time-stamp.
+This option turns off this "quick check" behavior.
 
 dit(bf(--size-only)) Normally rsync will skip any files that are
-already the same length and have the same time-stamp. With the
+already the same size and have the same modification time-stamp. With the
 --size-only option files will be skipped if they have the same size,
 regardless of timestamp. This is useful when starting to use rsync
 after using another mirroring system which may not preserve timestamps
 exactly.
 
 dit(bf(--modify-window)) When comparing two timestamps rsync treats
@@ -428,29 +427,44 @@
 then this would create a file called foo.c in /tmp/ on the remote
 machine. If instead you used
 
 verb(rsync -R foo/bar/foo.c remote:/tmp/)
 
 then a file called /tmp/foo/bar/foo.c would be created on the remote
-machine. The full path name is preserved.
+machine -- the full path name is preserved.
 
-dit(bf(-b, --backup)) With this option preexisting destination files are
-renamed with a ~ extension as each file is transferred.  You can
-control the backup suffix using the --suffix option.
+dit(bf(--no-relative)) Turn off the --relative option.  This is only
+needed if you want to use --files-from without its implied --relative
+file processing.
+
+dit(bf(--no-implied-dirs)) When combined with the --relative option, the
+implied directories in each path are not explicitly duplicated as part
+of the transfer.  This makes the transfer more optimal and also allows
+the two sides to have non-matching symlinks in the implied part of the
+path.  For instance, if you transfer the file "/path/foo/file" with -R,
+the default is for rsync to ensure that "/path" and "/path/foo" on the
+destination exactly match the directories/symlinks of the source.  Using
+the --no-implied-dirs option would omit both of these implied dirs,
+which means that if "/path" was a real directory on one machine and a
+symlink of the other machine, rsync would not try to change this.
+
+dit(bf(-b, --backup)) With this option, preexisting destination files are
+renamed as each file is transferred or deleted.  You can control where the
+backup file goes and what (if any) suffix gets appended using the
+--backup-dir and --suffix options.
 
 dit(bf(--backup-dir=DIR)) In combination with the --backup option, this
 tells rsync to store all backups in the specified directory. This is
 very useful for incremental backups.  You can additionally
 specify a backup suffix using the --suffix option
 (otherwise the files backed up in the specified directory
 will keep their original filenames).
 
 dit(bf(--suffix=SUFFIX)) This option allows you to override the default
-backup suffix used with the -b option. The default is a ~.
-If --backup-dir and --suffix are both specified,
-the SUFFIX is appended to the filename even in the backup directory.
+backup suffix used with the --backup (-b) option. The default suffix is a ~
+if no --backup-dir was specified, otherwise it is an empty string.
 
 dit(bf(-u, --update)) This forces rsync to skip any files for which the
 destination file already exists and has a date later than the source
 file.
 
 dit(bf(-l, --links)) When symlinks are encountered, recreate the
@@ -485,14 +499,19 @@
 "disk" is actually a networked file system).  This is the default when both
 the source and target are on the local machine.
 
 dit(bf(--no-whole-file)) Turn off --whole-file, for use when it is the
 default.
 
-dit(bf(-p, --perms)) This option causes rsync to update the remote
-permissions to be the same as the local permissions.
+dit(bf(-p, --perms)) This option causes rsync to set the destination
+permissions to be the same as the source permissions.
+
+Without this option, each new file gets its permissions set based on the
+source file's permissions and the umask at the receiving end, while all
+other files (including updated files) retain their existing permissions
+(which is the same behavior as other file-copy utilities, such as cp).
 
 dit(bf(-o, --owner)) This option causes rsync to set the owner of the
 destination file to be the same as the source file.  On most systems,
 only the super-user can set file ownership.  Note that if the remote system
 is a daemon using chroot, the --numeric-ids option is implied because the
 remote system cannot get access to the usernames from /etc/passwd.
@@ -576,14 +595,14 @@
 
 dit(bf(-B , --block-size=BLOCKSIZE)) This controls the block size used in
 the rsync algorithm. See the technical report for details.
 
 dit(bf(-e, --rsh=COMMAND)) This option allows you to choose an alternative
 remote shell program to use for communication between the local and
-remote copies of rsync. Typically, rsync is configured to use rsh by
-default, but you may prefer to use ssh because of its high security.
+remote copies of rsync. Typically, rsync is configured to use ssh by
+default, but you may prefer to use rsh on a local network.
 
 If this option is used with bf([user@]host::module/path), then the
 remote shell em(COMMMAND) will be used to run an rsync server on the
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
 running rsync server on the remote host.  See the section "CONNECTING
@@ -604,20 +623,38 @@
 
 dit(bf(--rsync-path=PATH)) Use this to specify the path to the copy of
 rsync on the remote machine. Useful when it's not in your path. Note
 that this is the full path to the binary, not just the directory that
 the binary is in.
 
+dit(bf(-C, --cvs-exclude)) This is a useful shorthand for excluding a
+broad range of files that you often don't want to transfer between
+systems. It uses the same algorithm that CVS uses to determine if
+a file should be ignored.
+
+The exclude list is initialized to:
+
+quote(RCS/ SCCS/ CVS/ .svn/ CVS.adm RCSLOG cvslog.* tags TAGS .make.state
+.nse_depinfo *~ #* .#* ,* *.old *.bak *.BAK *.orig *.rej .del-*
+*.a *.o *.obj *.so *.Z *.elc *.ln core)
+
+then files listed in a $HOME/.cvsignore are added to the list and any
+files listed in the CVSIGNORE environment variable (space delimited).
+
+Finally, any file is ignored if it is in the same directory as a
+.cvsignore file and matches one of the patterns listed therein.  See
+the bf(cvs(1)) manual for more information.
+
 dit(bf(--exclude=PATTERN)) This option allows you to selectively exclude
 certain files from the list of files to be transferred. This is most
 useful in combination with a recursive transfer.
 
 You may use as many --exclude options on the command line as you like
 to build up the list of files to exclude.
 
-See the section on exclude patterns for information on the syntax of 
+See the EXCLUDE PATTERNS section for information on the syntax of 
 this option.
 
 dit(bf(--exclude-from=FILE)) This option is similar to the --exclude
 option, but instead it adds all exclude patterns listed in the file
 FILE to the exclude list.  Blank lines in FILE and lines starting with
 ';' or '#' are ignored.
@@ -620,61 +657,63 @@
 dit(bf(--exclude-from=FILE)) This option is similar to the --exclude
 option, but instead it adds all exclude patterns listed in the file
 FILE to the exclude list.  Blank lines in FILE and lines starting with
 ';' or '#' are ignored.
 If em(FILE) is bf(-) the list will be read from standard input.
 
-
 dit(bf(--include=PATTERN)) This option tells rsync to not exclude the
 specified pattern of filenames. This is useful as it allows you to
 build up quite complex exclude/include rules.
 
-See the section of exclude patterns for information on the syntax of 
+See the EXCLUDE PATTERNS section for information on the syntax of 
 this option.
 
 dit(bf(--include-from=FILE)) This specifies a list of include patterns
 from a file.
 If em(FILE) is bf(-) the list will be read from standard input.
 
-
-dit(bf(-C, --cvs-exclude)) This is a useful shorthand for excluding a
-broad range of files that you often don't want to transfer between
-systems. It uses the same algorithm that CVS uses to determine if
-a file should be ignored.
-
-The exclude list is initialized to:
-
-quote(RCS/ SCCS/ CVS/ .svn/ CVS.adm RCSLOG cvslog.* tags TAGS .make.state
-.nse_depinfo *~ #* .#* ,* *.old *.bak *.BAK *.orig *.rej .del-*
-*.a *.o *.obj *.so *.Z *.elc *.ln core)
-
-then files listed in a $HOME/.cvsignore are added to the list and any
-files listed in the CVSIGNORE environment variable (space delimited).
-
-Finally, any file is ignored if it is in the same directory as a
-.cvsignore file and matches one of the patterns listed therein.  See
-the bf(cvs(1)) manual for more information.
-
-dit(bf(--csum-length=LENGTH)) By default the primary checksum used in
-rsync is a very strong 16 byte MD4 checksum. In most cases you will
-find that a truncated version of this checksum is quite efficient, and
-this will decrease the size of the checksum data sent over the link,
-making things faster. 
-
-You can choose the number of bytes in the truncated checksum using the
---csum-length option. Any value less than or equal to 16 is valid.
-
-Note that if you use this option then you run the risk of ending up
-with an incorrect target file. The risk with a value of 16 is
-microscopic and can be safely ignored (the universe will probably end
-before it fails) but with smaller values the risk is higher.
-
-Current versions of rsync actually use an adaptive algorithm for the
-checksum length by default, using a 16 byte file checksum to determine
-if a 2nd pass is required with a longer block checksum. Only use this
-option if you have read the source code and know what you are doing.
+dit(bf(--files-from=FILE)) Using this option allows you to specify the
+exact list of files to transfer (as read from the specified FILE or "-"
+for stdin).  It also tweaks the default behavior of rsync to make
+transferring just the specified files and directories easier.  For
+instance, the --relative option is enabled by default when this option
+is used (use --no-relative if you want to turn that off), all
+directories specified in the list are created on the destination (rather
+than being noisily skipped without -r), and the -a (--archive) option's
+behavior does not imply -r (--recursive) -- specify it explicitly, if
+you want it.
+
+The file names that are read from the FILE are all relative to the
+source dir -- any leading slashes are removed and no ".." references are
+allowed to go higher than the source dir.  For example, take this
+command:
+
+quote(rsync -a --files-from=/tmp/foo /usr remote:/backup)
+
+If /tmp/foo contains the string "bin" (or even "/bin"), the /usr/bin
+directory will be created as /backup/bin on the remote host (but the
+contents of the /usr/bin dir would not be sent unless you specified -r
+or the names were explicitly listed in /tmp/foo).  Also keep in mind
+that the effect of the (enabled by default) --relative option is to
+duplicate only the path info that is read from the file -- it does not
+force the duplication of the source-spec path (/usr in this case).
+
+In addition, the --files-from file can be read from the remote host
+instead of the local host if you specify a "host:" in front of the file
+(the host must match one end of the transfer).  As a short-cut, you can
+specify just a prefix of ":" to mean "use the remote end of the
+transfer".  For example:
+
+quote(rsync -a --files-from=:/path/file-list src:/ /tmp/copy)
+
+This would copy all the files specified in the /path/file-list file that
+was located on the remote "src" host.
+
+dit(bf(-0, --from0)) This tells rsync that the filenames it reads from a
+file are terminated by a null ('\0') character, not a NL, CR, or CR+LF.
+This affects --exclude-from, --include-from, and --files-from.
 
 dit(bf(-T, --temp-dir=DIR)) This option instructs rsync to use DIR as a
 scratch directory when creating temporary copies of the files
 transferred on the receiving side.  The default behavior is to create
 the temporary files in the receiving directory.
 
@@ -692,16 +731,18 @@
 to the destination directory.
 
 dit(bf(--link-dest=DIR)) This option behaves like bf(--compare-dest) but
 also will create hard links from em(DIR) to the destination directory for
 unchanged files.  Files with changed ownership or permissions will not be
 linked.
+Like bf(--compare-dest) if DIR is a relative path, it is relative
+to the destination directory.
 
 dit(bf(-z, --compress)) With this option, rsync compresses any data from
 the files that it sends to the destination machine.  This
-option is useful on slow links.  The compression method used is the
+option is useful on slow connections.  The compression method used is the
 same method that gzip uses.
 
 Note this this option typically achieves better compression ratios
 that can be achieved by using a compressing remote shell, or a
 compressing transport, as it takes advantage of the implicit
 information sent for matching data blocks.
@@ -756,17 +797,16 @@
 the default is rsyncd.conf in the current directory (typically $HOME).
 
 dit(bf(--port=PORT)) This specifies an alternate TCP port number to use
 rather than the default port 873.
 
 dit(bf(--blocking-io)) This tells rsync to use blocking IO when launching
-a remote shell transport.  If -e or --rsh are not specified or are set to
-the default "rsh", this defaults to blocking IO, otherwise it defaults to
-non-blocking IO.  You may find the --blocking-io option is needed for some
-remote shells that can't handle non-blocking IO.  (Note that ssh prefers
-non-blocking IO.)
+a remote shell transport.  If the remote shell is either rsh or remsh,
+rsync defaults to using
+blocking IO, otherwise it defaults to using non-blocking IO.  (Note that
+ssh prefers non-blocking IO.)
 
 dit(bf(--no-blocking-io)) Turn off --blocking-io, for use when it is the
 default.
 
 dit(bf(--log-format=FORMAT)) This allows you to specify exactly what the
 rsync client logs to stdout on a per-file basis. The log format is
@@ -783,15 +823,13 @@
 --partial option tells rsync to keep the partial file which should
 make a subsequent transfer of the rest of the file much faster.
 
 dit(bf(--progress)) This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
-
-This option is normally combined with -v. Using this option without
-the -v option will produce weird results on your display.
+Implies --verbose without incrementing verbosity.
 
 dit(bf(-P)) The -P option is equivalent to --partial --progress. I
 found myself typing that combination quite often so I created an
 option to make it easier.
 
 dit(bf(--password-file)) This option allows you to provide a password
@@ -822,19 +860,26 @@
 manpagesection(EXCLUDE PATTERNS)
 
 The exclude and include patterns specified to rsync allow for flexible
 selection of which files to transfer and which files to skip.
 
 rsync builds an ordered list of include/exclude options as specified on
-the command line. When a filename is encountered, rsync checks the
+the command line. Rsync checks each file and directory 
 name against each exclude/include pattern in turn. The first matching
 pattern is acted on. If it is an exclude pattern, then that file is
 skipped. If it is an include pattern then that filename is not
 skipped. If no matching include/exclude pattern is found then the
 filename is not skipped.
 
+The filenames matched against the exclude/include patterns
+are relative to the destination directory, or "top
+directory", so patterns should not include the path elements
+of the source or destination directories.  The only way in
+which a pattern will match the absolute path of a file or
+directory is if the source path is the root directory.
+
 Note that when used with -r (which is implied by -a), every subcomponent of
 every path is visited from top down, so include/exclude patterns get
 applied recursively to each subcomponent.
 
 Note also that the --include and --exclude options take one pattern
 each. To add multiple patterns use the --include-from and
@@ -840,36 +885,41 @@
 each. To add multiple patterns use the --include-from and
 --exclude-from options or multiple --include and --exclude options. 
 
 The patterns can take several forms. The rules are:
 
 itemize(
+
   it() if the pattern starts with a / then it is matched against the
   start of the filename, otherwise it is matched against the end of
-  the filename.  Thus "/foo" would match a file called "foo" at the base of
-  the tree.  On the other hand, "foo" would match any file called "foo"
+  the filename.
+  This is the equivalent of a leading ^ in regular expressions.
+  Thus "/foo" would match a file called "foo" at the top of the
+  transferred tree.
+  On the other hand, "foo" would match any file called "foo"
   anywhere in the tree because the algorithm is applied recursively from
   top down; it behaves as if each path component gets a turn at being the
   end of the file name.
+  The leading / does not make the pattern an absolute pathname.
 
   it() if the pattern ends with a / then it will only match a
   directory, not a file, link or device.
 
   it() if the pattern contains a wildcard character from the set
   *?[ then expression matching is applied using the shell filename
   matching rules. Otherwise a simple string match is used.
 
-  it() if the pattern includes a double asterisk "**" then all wildcards in
-  the pattern will match slashes, otherwise they will stop at slashes.
+  it() the double asterisk pattern "**" will match slashes while a
+  single asterisk pattern "*" will stop at slashes.
 
-  it() if the pattern contains a / (not counting a trailing /) then it
-  is matched against the full filename, including any leading
-  directory. If the pattern doesn't contain a / then it is matched
-  only against the final component of the filename.  Again, remember
-  that the algorithm is applied recursively so "full filename" can 
-  actually be any portion of a path.
+  it() if the pattern contains a / (not counting a trailing /) or a "**"
+  then it is matched against the full filename, including any leading
+  directory. If the pattern doesn't contain a / or a "**", then it is
+  matched only against the final component of the filename.  Again,
+  remember that the algorithm is applied recursively so "full filename" can
+  actually be any portion of a path below the starting directory.
 
   it() if the pattern starts with "+ " (a plus followed by a space)
   then it is always considered an include pattern, even if specified as
   part of an exclude option. The "+ " part is discarded before matching.
 
   it() if the pattern starts with "- " (a minus followed by a space)
@@ -877,32 +927,33 @@
   part of an include option. The "- " part is discarded before matching.
 
   it() if the pattern is a single exclamation mark ! then the current
   include/exclude list is reset, removing all previously defined patterns.
 )
 
-The +/- rules are most useful in exclude lists, allowing you to have a
-single exclude list that contains both include and exclude options.
+The +/- rules are most useful in a list that was read from a file, allowing
+you to have a single exclude list that contains both include and exclude
+options.
 
 If you end an exclude list with --exclude '*', note that since the
 algorithm is applied recursively that unless you explicitly include
 parent directories of files you want to include then the algorithm
 will stop at the parent directories and never see the files below
 them.  To include all directories, use --include '*/' before the
 --exclude '*'.
 
 Here are some exclude/include examples:
 
 itemize(
   it() --exclude "*.o" would exclude all filenames matching *.o
-  it() --exclude "/foo" would exclude a file in the base directory called foo
+  it() --exclude "/foo" would exclude a file called foo in the top directory
   it() --exclude "foo/" would exclude any directory called foo
   it() --exclude "/foo/*/bar" would exclude any file called bar two
-  levels below a base directory called foo
+  levels below a directory called foo in the top directory
   it() --exclude "/foo/**/bar" would exclude any file called bar two
-  or more levels below a base directory called foo
+  or more levels below a directory called foo in the top directory
   it() --include "*/" --include "*.c" --exclude "*" would include all 
   directories and C source files
   it() --include "foo/" --include "foo/bar.c" --exclude "*" would include
   only foo/bar.c (the foo/ directory must be explicitly included or
   it would be excluded by the "*")
 )
@@ -950,17 +1001,17 @@
 be used to transfer the batch update files in parallel to many hosts at
 once, instead of sending the same data to every host individually.
 
 Example:
 
 verb(
-$ rsync --write_batch=pfx -a /source/dir/ /adest/dir/
+$ rsync --write-batch=pfx -a /source/dir/ /adest/dir/
 $ rcp pfx.rsync_* remote:
-$ rsh remote rsync --read_batch=pfx -a /bdest/dir/
+$ ssh remote rsync --read-batch=pfx -a /bdest/dir/
 # or alternatively
-$ rsh remote ./pfx.rsync_argvs /bdest/dir/
+$ ssh remote ./pfx.rsync_argvs /bdest/dir/
 )
 
 In this example, rsync is used to update /adest/dir/ with /source/dir/
 and the information to repeat this operation is stored in the files
 pfx.rsync_*. These files are then copied to the machine named "remote".
 Rsync is then invoked on "remote" to update /bdest/dir/ the same way as
@@ -1026,13 +1077,13 @@
 This message is usually caused by your startup scripts or remote shell
 facility producing unwanted garbage on the stream that rsync is using
 for its transport. The way to diagnose this problem is to run your
 remote shell like this:
 
 verb(
-   rsh remotehost /bin/true > out.dat
+   ssh remotehost /bin/true > out.dat
 )
        
 then look at out.dat. If everything is working correctly then out.dat
 should be a zero length file. If you are getting the above error from
 rsync then you will probably find that out.dat contains some text or
 data. Look at the contents and try to work out what is producing
@@ -1044,30 +1095,32 @@
 try specifying the -vv option.  At this level of verbosity rsync will
 show why each individual file is included or excluded.
 
 manpagesection(EXIT VALUES)
 
 startdit()
-dit(bf(RERR_SYNTAX     1))       Syntax or usage error 
-dit(bf(RERR_PROTOCOL   2))       Protocol incompatibility 
-dit(bf(RERR_FILESELECT 3))       Errors selecting input/output files, dirs
-
-dit(bf(RERR_UNSUPPORTED 4)) Requested action not supported: an attempt
+dit(bf(0)) Success
+dit(bf(1)) Syntax or usage error 
+dit(bf(2)) Protocol incompatibility 
+dit(bf(3)) Errors selecting input/output files, dirs
+dit(bf(4)) Requested action not supported: an attempt
 was made to manipulate 64-bit files on a platform that cannot support
 them; or an option was speciifed that is supported by the client and
 not by the server.
-
-dit(bf(RERR_SOCKETIO   10))      Error in socket IO 
-dit(bf(RERR_FILEIO     11))      Error in file IO 
-dit(bf(RERR_STREAMIO   12))      Error in rsync protocol data stream 
-dit(bf(RERR_MESSAGEIO  13))      Errors with program diagnostics 
-dit(bf(RERR_IPC        14))      Error in IPC code 
-dit(bf(RERR_SIGNAL     20))      Received SIGUSR1 or SIGINT 
-dit(bf(RERR_WAITCHILD  21))      Some error returned by waitpid() 
-dit(bf(RERR_MALLOC     22))      Error allocating core memory buffers 
-dit(bf(RERR_TIMEOUT    30))      Timeout in data send/receive 
+dit(bf(5)) Error starting client-server protocol
+dit(bf(10)) Error in socket IO 
+dit(bf(11)) Error in file IO 
+dit(bf(12)) Error in rsync protocol data stream 
+dit(bf(13)) Errors with program diagnostics 
+dit(bf(14)) Error in IPC code 
+dit(bf(20)) Received SIGUSR1 or SIGINT 
+dit(bf(21)) Some error returned by waitpid() 
+dit(bf(22)) Error allocating core memory buffers 
+dit(bf(23)) Partial transfer due to error
+dit(bf(24)) Partial transfer due to vanished source files
+dit(bf(30)) Timeout in data send/receive 
 enddit()
 
 manpagesection(ENVIRONMENT VARIABLES)
 
 startdit()
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/sender.c	2003-12-04 12:23:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/sender.c	2003-12-20 06:19:54.000000000 +0800
@@ -1,29 +1,28 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1996
    Copyright (C) Paul Mackerras 1996
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int remote_version;
 extern int csum_length;
 extern struct stats stats;
 extern int io_error;
 extern int dry_run;
 extern int am_server;
 
@@ -34,267 +33,292 @@
  * The sender gets checksums from the generator, calculates deltas,
  * and transmits them to the receiver.  The sender process runs on the
  * machine holding the source files.
  **/
 
 
+void read_sum_head(int f, struct sum_struct *sum)
+{
+	extern int protocol_version;
+
+	sum->count = read_int(f);
+	sum->blength = read_int(f);
+	if (protocol_version < 27) {
+		sum->s2length = csum_length;
+	} else {
+		sum->s2length = read_int(f);
+		if (sum->s2length > MD4_SUM_LENGTH) {
+			rprintf(FERROR, "Invalid checksum length %ld\n",
+			    (long)sum->s2length);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+	}
+	sum->remainder = read_int(f);
+}
+
 /**
  * Receive the checksums for a buffer
  **/
 static struct sum_struct *receive_sums(int f)
 {
 	struct sum_struct *s;
 	int i;
 	OFF_T offset = 0;
 
 	s = new(struct sum_struct);
 	if (!s) out_of_memory("receive_sums");
 
-	s->count = read_int(f);
-	s->n = read_int(f);
-	s->remainder = read_int(f);  
+	read_sum_head(f, s);
+
 	s->sums = NULL;
 
 	if (verbose > 3)
-		rprintf(FINFO,"count=%ld n=%ld rem=%ld\n",
-			(long) s->count, (long) s->n, (long) s->remainder);
+		rprintf(FINFO, "count=%ld n=%ld rem=%ld\n",
+			(long) s->count, (long) s->blength,
+			(long) s->remainder);
 
-	if (s->count == 0) 
+	if (s->count == 0)
 		return(s);
 
 	s->sums = new_array(struct sum_buf, s->count);
 	if (!s->sums) out_of_memory("receive_sums");
 
-	for (i=0; i < (int) s->count;i++) {
+	for (i = 0; i < (int) s->count; i++) {
 		s->sums[i].sum1 = read_int(f);
-		read_buf(f,s->sums[i].sum2,csum_length);
+		read_buf(f, s->sums[i].sum2, s->s2length);
 
 		s->sums[i].offset = offset;
 		s->sums[i].i = i;
 
 		if (i == (int) s->count-1 && s->remainder != 0) {
 			s->sums[i].len = s->remainder;
 		} else {
-			s->sums[i].len = s->n;
+			s->sums[i].len = s->blength;
 		}
 		offset += s->sums[i].len;
 
 		if (verbose > 3)
-			rprintf(FINFO,"chunk[%d] len=%d offset=%.0f sum1=%08x\n",
-				i,s->sums[i].len,(double)s->sums[i].offset,s->sums[i].sum1);
+			rprintf(FINFO, "chunk[%d] len=%d offset=%.0f sum1=%08x\n",
+				i, s->sums[i].len, (double)s->sums[i].offset, s->sums[i].sum1);
 	}
 
 	s->flength = offset;
 
 	return s;
 }
 
 
 
-void send_files(struct file_list *flist,int f_out,int f_in)
-{ 
+void send_files(struct file_list *flist, int f_out, int f_in)
+{
 	int fd = -1;
 	struct sum_struct *s;
 	struct map_struct *buf = NULL;
 	STRUCT_STAT st;
-	char fname[MAXPATHLEN];  
+	char fname[MAXPATHLEN];
 	int i;
 	struct file_struct *file;
 	int phase = 0;
-	extern struct stats stats;		
+	extern struct stats stats;
 	struct stats initial_stats;
 	extern int write_batch;   /* dw */
 	extern int read_batch;    /* dw */
 	int checksums_match;   /* dw */
 	int buff_len;  /* dw */
 	char buff[CHUNK_SIZE];    /* dw */
 	int j;   /* dw */
 	int done;   /* dw */
 
 	if (verbose > 2)
-		rprintf(FINFO,"send_files starting\n");
+		rprintf(FINFO, "send_files starting\n");
 
 	while (1) {
-		int offset=0;
+		int offset = 0;
 
 		i = read_int(f_in);
 		if (i == -1) {
-			if (phase==0 && remote_version >= 13) {
+			if (phase == 0) {
 				phase++;
 				csum_length = SUM_LENGTH;
-				write_int(f_out,-1);
+				write_int(f_out, -1);
 				if (verbose > 2)
-					rprintf(FINFO,"send_files phase=%d\n",phase);
+					rprintf(FINFO, "send_files phase=%d\n", phase);
 				continue;
 			}
 			break;
 		}
 
 		if (i < 0 || i >= flist->count) {
-			rprintf(FERROR,"Invalid file index %d (count=%d)\n", 
+			rprintf(FERROR, "Invalid file index %d (count=%d)\n",
 				i, flist->count);
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		file = flist->files[i];
 
 		stats.num_transferred_files++;
 		stats.total_transferred_size += file->length;
 
 		fname[0] = 0;
 		if (file->basedir) {
-			strlcpy(fname,file->basedir,MAXPATHLEN);
+			strlcpy(fname, file->basedir, MAXPATHLEN);
 			if (strlen(fname) == MAXPATHLEN-1) {
-				io_error = 1;
+				io_error |= IOERR_GENERAL;
 				rprintf(FERROR, "send_files failed on long-named directory %s\n",
-					fname);
+					full_fname(fname));
 				return;
 			}
-			strlcat(fname,"/",MAXPATHLEN);
+			strlcat(fname, "/", MAXPATHLEN);
 			offset = strlen(file->basedir)+1;
 		}
-		strlcat(fname,f_name(file),MAXPATHLEN);
-	  
-		if (verbose > 2) 
-			rprintf(FINFO,"send_files(%d,%s)\n",i,fname);
-	  
-		if (dry_run) {	
-			if (!am_server) {
-				log_transfer(file, fname+offset);
+		strlcat(fname, f_name(file), MAXPATHLEN);
+
+		if (verbose > 2)
+			rprintf(FINFO, "send_files(%d, %s)\n", i, fname);
+
+		if (dry_run) {
+			if (!am_server && verbose) {	/* log transfer */
+				rprintf(FINFO, "%s\n", fname+offset);
 			}
-			write_int(f_out,i);
+			write_int(f_out, i);
 			continue;
 		}
 
 		initial_stats = stats;
 
 		s = receive_sums(f_in);
 		if (!s) {
-			io_error = 1;
-			rprintf(FERROR,"receive_sums failed\n");
+			io_error |= IOERR_GENERAL;
+			rprintf(FERROR, "receive_sums failed\n");
 			return;
 		}
 
 		if (write_batch)
-		    write_batch_csum_info(&i,flist->count,s);
-	  
+			write_batch_csum_info(&i, flist->count, s);
+
 		if (!read_batch) {
 			fd = do_open(fname, O_RDONLY, 0);
 			if (fd == -1) {
-				io_error = 1;
-				rprintf(FERROR,"send_files failed to open %s: %s\n",
-					fname,strerror(errno));
+				if (errno == ENOENT) {
+					io_error |= IOERR_VANISHED;
+					rprintf(FINFO, "file has vanished: %s\n",
+			 			full_fname(fname));
+				} else {
+					io_error |= IOERR_GENERAL;
+					rprintf(FERROR, "send_files failed to open %s: %s\n",
+						full_fname(fname), strerror(errno));
+				}
 				free_sums(s);
 				continue;
 			}
-	  
+
 			/* map the local file */
-			if (do_fstat(fd,&st) != 0) {
-				io_error = 1;
-				rprintf(FERROR,"fstat failed : %s\n",strerror(errno));
+			if (do_fstat(fd, &st) != 0) {
+				io_error |= IOERR_GENERAL;
+				rprintf(FERROR, "fstat failed: %s\n", strerror(errno));
 				free_sums(s);
 				close(fd);
 				return;
 			}
-	  
+
 			if (st.st_size > 0) {
-				buf = map_file(fd,st.st_size);
+				buf = map_file(fd, st.st_size);
 			} else {
 				buf = NULL;
 			}
-	  
+
 			if (verbose > 2)
-				rprintf(FINFO,"send_files mapped %s of size %.0f\n",
-					fname,(double)st.st_size);
+				rprintf(FINFO, "send_files mapped %s of size %.0f\n",
+					fname, (double)st.st_size);
+
+			write_int(f_out, i);
 
-			write_int(f_out,i);
-	  
 			if (write_batch)
-				write_batch_delta_file((char *)&i,sizeof(i));
+				write_batch_delta_file((char *)&i, sizeof(i));
 
-			write_int(f_out,s->count);
-			write_int(f_out,s->n);
-			write_int(f_out,s->remainder);
+			write_sum_head(f_out, s);
 		}
-	  
-		if (verbose > 2)
-			if (!read_batch)
-			    rprintf(FINFO,"calling match_sums %s\n",fname);
-	  
-		if (!am_server) {
-			log_transfer(file, fname+offset);
+
+		if (verbose > 2 && !read_batch)
+			rprintf(FINFO, "calling match_sums %s\n", fname);
+
+		if (!am_server && verbose) {	/* log transfer */
+			rprintf(FINFO, "%s\n", fname+offset);
 		}
 
 		set_compression(fname);
 
                 if (read_batch) { /* dw */
-                   /* read checksums originally computed on sender side */
-                   read_batch_csum_info(i, s, &checksums_match);
-                   if (checksums_match) {
-                       read_batch_delta_file( (char *) &j, sizeof(int) );
-                       if (j != i) {    /* if flist index entries don't match*/ 
-                          rprintf(FINFO,"index mismatch in send_files\n");
-                          rprintf(FINFO,"read index = %d flist ndx = %d\n",j,i);
-                          close_batch_delta_file();
-                          close_batch_csums_file();
-                          exit_cleanup(1);
-                       }
-                       else {
-                         write_int(f_out,j);
-                         write_int(f_out,s->count);
-                         write_int(f_out,s->n);
-                         write_int(f_out,s->remainder);
-                         done=0;
-                         while (!done) {
-                            read_batch_delta_file( (char *) &buff_len, sizeof(int) );
-                            write_int(f_out,buff_len);
-                            if (buff_len == 0) {
-                               done = 1;
-                            }
-                            else {
-                               if (buff_len > 0) {
-                                  read_batch_delta_file(buff, buff_len);
-                                  write_buf(f_out,buff,buff_len);
-                               }
-                            }
-                         }  /* end while  */
-                         read_batch_delta_file( buff, MD4_SUM_LENGTH);
-                         write_buf(f_out, buff, MD4_SUM_LENGTH);
-
-                       }  /* j=i */
-                   } else {  /* not checksum match */
-                      rprintf (FINFO,"readbatch & checksums don't match\n");
-                      rprintf (FINFO,"filename=%s is being skipped\n",
-			       fname);
-                      continue;
-                   }
+			/* read checksums originally computed on sender side */
+			read_batch_csum_info(i, s, &checksums_match);
+			if (checksums_match) {
+				read_batch_delta_file( (char *) &j, sizeof(int) );
+				if (j != i) {    /* if flist index entries don't match*/
+					rprintf(FINFO, "index mismatch in send_files\n");
+					rprintf(FINFO, "read index = %d flist ndx = %d\n", j, i);
+					close_batch_delta_file();
+					close_batch_csums_file();
+					exit_cleanup(1);
+				} else {
+					write_int(f_out, j);
+					write_sum_head(f_out, s);
+					done = 0;
+					while (!done) {
+						read_batch_delta_file( (char *) &buff_len, sizeof(int) );
+						write_int(f_out, buff_len);
+						if (buff_len == 0) {
+							done = 1;
+						} else {
+							if (buff_len > 0) {
+								read_batch_delta_file(buff, buff_len);
+								write_buf(f_out, buff, buff_len);
+							}
+						}
+					}  /* end while  */
+					read_batch_delta_file( buff, MD4_SUM_LENGTH);
+					write_buf(f_out, buff, MD4_SUM_LENGTH);
+
+				}  /* j=i */
+			} else {  /* not checksum match */
+				rprintf (FINFO, "readbatch & checksums don't match\n");
+				rprintf (FINFO, "filename=%s is being skipped\n", fname);
+				continue;
+			}
                 } else  {
-		    match_sums(f_out,s,buf,st.st_size);
-		    log_send(file, &initial_stats);
+			match_sums(f_out, s, buf, st.st_size);
+			log_send(file, &initial_stats);
                 }
 
 		if (!read_batch) { /* dw */
-		    if (buf) unmap_file(buf);
-		    close(fd);
+			if (buf) {
+				j = unmap_file(buf);
+				if (j) {
+					io_error |= IOERR_GENERAL;
+					rprintf(FERROR,
+					    "read errors mapping %s: (%d) %s\n",
+					    full_fname(fname), j, strerror(j));
+				}
+			}
+			close(fd);
 		}
-	  
+
 		free_sums(s);
-	  
+
 		if (verbose > 2)
-			rprintf(FINFO,"sender finished %s\n",fname);
+			rprintf(FINFO, "sender finished %s\n", fname);
 	}
 
 	if (verbose > 2)
-		rprintf(FINFO,"send files finished\n");
+		rprintf(FINFO, "send files finished\n");
 
 	match_report();
 
-	write_int(f_out,-1);
+	write_int(f_out, -1);
 	if (write_batch || read_batch) { /* dw */
-	    close_batch_csums_file();
-	    close_batch_delta_file();
+		close_batch_csums_file();
+		close_batch_delta_file();
 	}
 
 }
 
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/socket.c	2003-01-27 11:35:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/socket.c	2003-08-22 13:04:13.000000000 +0800
@@ -371,12 +371,21 @@
          *
          * We now return to your regularly scheduled programming.  */
 	return(getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&v, &l) == 0);
 }
 
 
+static RETSIGTYPE sigchld_handler(UNUSED(int val))
+{
+	signal(SIGCHLD, sigchld_handler);
+#ifdef WNOHANG
+	while (waitpid(-1, NULL, WNOHANG) > 0) {}
+#endif
+}
+
+
 void start_accept_loop(int port, int (*fn)(int, int))
 {
 	int s;
 	extern char *bind_address;
 	extern int default_af_hint;
 
@@ -416,20 +425,13 @@
 		if(!FD_ISSET(s, &fds)) continue;
 
 		fd = accept(s,(struct sockaddr *)&addr,&addrlen);
 
 		if (fd == -1) continue;
 
-		signal(SIGCHLD, SIG_IGN);
-
-		/* we shouldn't have any children left hanging around
-		   but I have had reports that on Digital Unix zombies
-		   are produced, so this ensures that they are reaped */
-#ifdef WNOHANG
-                while (waitpid(-1, NULL, WNOHANG) > 0);
-#endif
+		signal(SIGCHLD, sigchld_handler);
 
 		if ((pid = fork()) == 0) {
 			int ret;
 			close(s);
 			/* open log file in child before possibly giving
 			   up privileges  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/syscall.c	2003-01-27 04:09:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/syscall.c	2003-03-31 07:00:51.000000000 +0800
@@ -82,20 +82,16 @@
 int do_open(char *pathname, int flags, mode_t mode)
 {
 	if (flags != O_RDONLY) {
 	    if (dry_run) return -1;
 	    CHECK_RO
 	}
-#ifdef O_BINARY
-	/* for Windows */
-	flags |= O_BINARY;
-#endif
 	/* some systems can't handle a double / */
 	if (pathname[0] == '/' && pathname[1] == '/') pathname++;
 
-	return open(pathname, flags, mode);
+	return open(pathname, flags | O_BINARY, mode);
 }
 
 #if HAVE_CHMOD
 int do_chmod(const char *path, mode_t mode)
 {
 	int code;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/testsuite/duplicates.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/duplicates.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/testsuite/duplicates.test	2002-12-24 15:25:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/duplicates.test	2003-04-23 00:45:24.000000000 +0800
@@ -18,14 +18,12 @@
 # always rename-and-replace the new copy, they can't affect us.
 
 # This test is not great, because it is a timing-dependent bug.
 
 . $srcdir/testsuite/rsync.fns
 
-test_skipped "Known minor bug in this code"
-
 set -x
 
 # Build some hardlinks
 
 fromdir="$scratchdir/from"
 todir="$scratchdir/to"
@@ -41,16 +39,15 @@
 checkit "$RSYNC -avv \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
     | tee "$outfile"
 
 # Make sure each file was only copied once...
 if [ `grep -c '^name1$' "$outfile"` != 1 ]
 then
-    test_xfail "name1 was not copied exactly once"
+    test_fail "name1 was not copied exactly once"
 fi
-if [ `grep -c '^name2$' "$outfile"` != 1 ]
+if [ `grep -c '^name2 -> ' "$outfile"` != 1 ]
 then
-    test_xfail "name2 was not copied exactly once"
+    test_fail "name2 was not copied exactly once"
 fi
 
 exit 0
 # last [] may have failed but if we get here then we've won
-
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite: exclude.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/testsuite/rsync.fns /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/rsync.fns
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/testsuite/rsync.fns	2003-01-28 11:11:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/rsync.fns	2003-07-06 06:57:08.000000000 +0800
@@ -24,12 +24,18 @@
 LOG=${TMP}/log
 RSYNC="$rsync_bin"
 
 # Berkley's nice.
 PATH="$PATH:/usr/ucb"
 
+if diff -u $srcdir/testsuite/rsync.fns $srcdir/testsuite/rsync.fns >/dev/null 2>&1; then
+    diffopt="-u"
+else
+    diffopt="-c"
+fi
+
 runtest() {
     echo $ECHO_N "Test $1: $ECHO_C"
     if eval "$2"
     then
 	echo "${ECHO_T}	done."
 	return 0
@@ -154,21 +160,21 @@
 
     echo "-------------"
     echo "check how the files compare with diff:"
     echo ""
     for f in `cd "$2"; find . -type f -print `
     do 
-        diff -c "$2"/"$f" "$3"/"$f" || failed=YES
+        diff $diffopt "$2"/"$f" "$3"/"$f" || failed=YES
     done
 
     echo "-------------"
     echo "check how the directory listings compare with diff:"
     echo ""
     ( cd "$2" && rsync_ls_lR . ) > ${TMP}/ls-from 
     ( cd "$3" && rsync_ls_lR . ) > ${TMP}/ls-to 
-    diff -c ${TMP}/ls-from ${TMP}/ls-to || failed=YES
+    diff $diffopt ${TMP}/ls-from ${TMP}/ls-to || failed=YES
     if [ -z "${failed}" ] ; then
 	return 0
     else
 	return 1
     fi
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/testsuite/ssh-basic.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/ssh-basic.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/testsuite/ssh-basic.test	2002-03-22 14:07:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/ssh-basic.test	2003-02-20 00:22:50.000000000 +0800
@@ -20,11 +20,24 @@
 fi
 
 if ! [ "`ssh -o'BatchMode yes' localhost echo yes`" = "yes" ]; then
     test_skipped "Skipping SSH tests because ssh conection to localhost not authorised"
 fi
 
+# Added by Steve Bonds Feb 2 2003
+# Without this, there are no files in the ${FROM} directory, so rsync has
+# nothing to do.
+hands_setup
+
 runtest "ssh: basic test" 'checkit "$RSYNC -avH -e ssh --rsync-path=$RSYNC ${FROM}/ localhost:${TO}" ${FROM}/ ${TO}'
 
+# Added by Steve Bonds Feb 2 2003
+# I assumed that "F1" was intended to hold a single file for testing if
+# rsync could detect a renamed file over ssh.  Without this line below
+# it was unset so the "mv" tried to move a parent directory into a
+# subdirectory of itself.  There is probably a better way of pulling out
+# a sample file to rename.
+F1=`ls ${TO} | head -5 | tail -1`
+
 mv ${TO}/${F1} ${TO}/ThisShouldGo
 
 runtest "ssh: renamed file" 'checkit "$RSYNC --delete -avH -e ssh --rsync-path=$RSYNC ${FROM}/ localhost:${TO}" ${FROM}/ ${TO}'
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/testsuite/trimslash.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/trimslash.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/testsuite/trimslash.test	2002-03-25 11:51:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/trimslash.test	2003-07-06 06:57:08.000000000 +0800
@@ -12,18 +12,16 @@
 set -x
 
 "$TOOLDIR/trimslash" "/usr/local/bin" "/usr/local/bin/" "/usr/local/bin///" \
 	"//a//" "////" \
         "/Users/Wierd Macintosh Name/// Ooh, translucent plastic/" \
 	> "$scratchdir/slash.out"
-diff -c "$scratchdir/slash.out" - <<EOF
+diff $diffopt "$scratchdir/slash.out" - <<EOF
 /usr/local/bin
 /usr/local/bin
 /usr/local/bin
 //a
 /
 /Users/Wierd Macintosh Name/// Ooh, translucent plastic
 EOF
 
 exit 0
-# last [] may have failed but if we get here then we've won
-
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite: wildmatch.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/tls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/tls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/tls.c	2003-01-21 09:35:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/tls.c	2003-09-10 16:27:34.000000000 +0800
@@ -121,13 +121,14 @@
 	       (long) buf.st_uid, (long) buf.st_gid,
 	       buf.st_nlink,
 	       datebuf, fname, linkbuf);
 }
 
 
-int main (int argc, char *argv[])
+int
+main(int argc, char *argv[])
 {
 	if (argc < 2) {
 		fprintf (stderr, "usage: " PROGRAM " DIR ...\n"
 			 "Trivial file listing program for portably checking rsync\n");
 		return 1;
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/TODO	2003-01-28 00:33:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/TODO	2003-12-17 08:52:01.000000000 +0800
@@ -1,89 +1,98 @@
 -*- indented-text -*-
 
 BUGS ---------------------------------------------------------------
+Fix progress indicator to not corrupt log
+lchmod question	
+Do not rely on having a group called "nobody"
+Incorrect timestamps (Debian #100295)
+Win32
 
-rsync-url barfs on upload
+FEATURES ------------------------------------------------------------
+server-imposed bandwidth limits
+rsyncd over ssh
+Use chroot only if supported
+Allow supplementary groups in rsyncd.conf			2002/04/09
+Handling IPv6 on old machines
+Other IPv6 stuff:
+Add ACL support							2001/12/02
+Lazy directory creation
+Conditional -z for old protocols
+proxy authentication						2002/01/23
+SOCKS								2002/01/23
+FAT support
+Allow forcing arbitrary permissions				2002/03/12
+--diff						david.e.sewell	2002/03/15
+Add daemon --no-detach and --no-fork options
+Create more granular verbosity				jw	2003/05/15
 
-  rsync foo rsync://localhost/transfer/
+DOCUMENTATION --------------------------------------------------------
+Update README
+Keep list of open issues and todos on the web site
+Update web site from CVS
+Perhaps redo manual as SGML
 
-  Fix the parser.
+LOGGING --------------------------------------------------------------
+Make dry run list all updates					2002/04/03
+Memory accounting
+Improve error messages
+Better statistics:					Rasmus	2002/03/08
+Perhaps flush stdout like syslog
+Log deamon sessions that just list modules
+Log child death on signal
+Keep stderr and stdout properly separated (Debian #23626)
+Log errors with function that reports process of origin
+verbose output					David Stein	2001/12/20
+Add reason for transfer to file logging
+debugging of daemon						2002/04/08
+internationalization
 
+DEVELOPMENT --------------------------------------------------------
+Handling duplicate names
+Use generic zlib						2002/02/25
+TDB:								2002/03/12
+Splint								2002/03/12
+Memory debugger
+Create release script
+Add machines to build farm
 
-There seems to be a bug with hardlinks
+PERFORMANCE ----------------------------------------------------------
+File list structure in memory
+Traverse just one directory at a time
+Hard-link handling
+Allow skipping MD4 file_sum					2002/04/08
+Accelerate MD4
+String area code
 
-  mbp/2 build$ ls -l /tmp/a /tmp/b -i
-  /tmp/a:
-  total 32
-  2568307 -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a1
-  2568307 -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a2
-  2568307 -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a3
-  2568310 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a4
-  2568310 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a5
-  2568310 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b1
-  2568310 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b2
-  2568310 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b3
-
-  /tmp/b:
-  total 32
-  2568309 -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a1
-  2568309 -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a2
-  2568309 -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a3
-  2568311 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a4
-  2568311 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a5
-  2568311 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b1
-  2568311 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b2
-  2568311 -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b3
-  mbp/2 build$ rm -r /tmp/b && ./rsync -avH /tmp/a/ /tmp/b
-  building file list ... done
-  created directory /tmp/b
-  ./
-  a1
-  a4
-  a2 => a1
-  a3 => a2
-  wrote 350 bytes  read 52 bytes  804.00 bytes/sec
-  total size is 232  speedup is 0.58
-  mbp/2 build$ rm -r /tmp/b
-  mbp/2 build$ ls -l /tmp/b
-  ls: /tmp/b: No such file or directory
-  mbp/2 build$ rm -r /tmp/b && ./rsync -avH /tmp/a/ /tmp/b
-  rm: cannot remove `/tmp/b': No such file or directory
-  mbp/2 build$ rm -f -r /tmp/b && ./rsync -avH /tmp/a/ /tmp/b
-  building file list ... done
-  created directory /tmp/b
-  ./
-  a1
-  a4
-  a2 => a1
-  a3 => a2
-  wrote 350 bytes  read 52 bytes  804.00 bytes/sec
-  total size is 232  speedup is 0.58
-  mbp/2 build$ ls -l /tmp/b
-  total 32
-  -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a1
-  -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a2
-  -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a3
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a4
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a5
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b1
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b2
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b3
-  mbp/2 build$ ls -l /tmp/a
-  total 32
-  -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a1
-  -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a2
-  -rw-rw-r--    3 mbp      mbp            29 Mar 25 17:30 a3
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a4
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 a5
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b1
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b2
-  -rw-rw-r--    5 mbp      mbp            29 Mar 25 17:30 b3
+TESTING --------------------------------------------------------------
+Torture test
+Cross-test versions						2001/08/22
+Test on kernel source
+Test large files
+Create mutator program for testing
+Create configure option to enable dangerous tests
+If tests are skipped, say why.
+Test daemon feature to disallow particular options.
+Create pipe program for testing
+Create test makefile target for some tests
+Test "refuse options" works
 
+RELATED PROJECTS -----------------------------------------------------
+rsyncsh
+http://rsync.samba.org/rsync-and-debian/
+rsyncable gzip patch
+rsyncsplit as alternative to real integration with gzip?
+reverse rsync over HTTP Range
+
+
+
+BUGS ---------------------------------------------------------------
 
-Progress indicator can produce corrupt output when transferring directories:
+Fix progress indicator to not corrupt log
+
+  Progress indicator can produce corrupt output when transferring directories:
 
   main/binary-arm/
   main/binary-arm/admin/
   main/binary-arm/base/
   main/binary-arm/comm/8.56kB/s    0:00:52
   main/binary-arm/devel/
@@ -96,290 +105,329 @@
   main/binary-arm/interpreters/
   main/binary-arm/libs/6.61kB/s    0:00:54
   main/binary-arm/mail/
   main/binary-arm/math/
   main/binary-arm/misc/
 
-
-lchmod
-  I don't think we handle this properly on systems that don't have the
-  call.  Are there any such?
+                      --          --
 
 
-Cross-test versions
-  Part of the regression suite should be making sure that we don't
-  break backwards compatibility: old clients vs new servers and so
-  on.  Ideally we would test the cross product of versions.  
+lchmod question	
 
-  It might be sufficient to test downloads from well-known public
-  rsync servers running different versions of rsync.  This will give
-  some testing and also be the most common case for having different
-  versions and not being able to upgrade.
+  I don't think we handle this properly on systems that don't have the
+  call.  Are there any such?
 
---no-blocking-io might be broken
+                      --          --
 
-  in the same way as --no-whole-file; somebody needs to check.
 
 Do not rely on having a group called "nobody"
 
   http://www.linuxbase.org/spec/refspecs/LSB_1.1.0/gLSB/usernames.html
 
   On Debian it's "nogroup"
 
-Temporary file names can exceed max name length
+                      --          --
 
-  Rsync creates temporary file names that are 10 characters longer
-  than the length of the file being transferred.  This creates
-  problems for operating systems have fairly short maximum lengths
-  (e.g., 32 characters for Stratus VOS). Even on operating systems
-  with long max lengths it can still be a problem as it is perfectly
-  reasonable to be using files with long names.
 
+Incorrect timestamps (Debian #100295)
 
-DAEMON --------------------------------------------------------------
+  A bit hard to believe, but apparently it happens.
 
-server-imposed bandwidth limits
+                      --          --
 
-rsyncd over ssh
 
-  There are already some patches to do this.
+Win32
+
+  Don't detach, because this messes up --srvany.
+
+  http://sources.redhat.com/ml/cygwin/2001-08/msg00234.html
+
 
-  BitKeeper uses a server whose login shell is set to bkd.  That's
-  probably a reasonable approach.
 
+                      --          --
 
 FEATURES ------------------------------------------------------------
 
+server-imposed bandwidth limits
 
---dry-run is too dry
+                      --          --
 
-  Mark Santcroos points out that -n fails to list files which have
-  only metadata changes, though it probably should.
 
-  There may be a Debian bug about this as well.
+rsyncd over ssh
+
+  There are already some patches to do this.
+
+  BitKeeper uses a server whose login shell is set to bkd.  That's
+  probably a reasonable approach.
 
+                      --          --
 
-use chroot
+
+Use chroot only if supported
 
   If the platform doesn't support it, then don't even try.
 
   If running as non-root, then don't fail, just give a warning.
   (There was a thread about this a while ago?)
 
     http://lists.samba.org/pipermail/rsync/2001-August/thread.html
     http://lists.samba.org/pipermail/rsync/2001-September/thread.html
 
+                      --          --
 
---files-from
-
-  Avoids traversal.  Better option than a pile of --include statements
-  for people who want to generate the file list using a find(1)
-  command or a script.
 
-
-supplementary groups
+Allow supplementary groups in rsyncd.conf			2002/04/09
 
   Perhaps allow supplementary groups to be specified in rsyncd.conf;
   then make the first one the primary gid and all the rest be
   supplementary gids.
 
+                      --          --
 
-File list structure in memory
 
-  Rather than one big array, perhaps have a tree in memory mirroring
-  the directory tree.
+Handling IPv6 on old machines
 
-  This might make sorting much faster!  (I'm not sure it's a big CPU
-  problem, mind you.)
+  The KAME IPv6 patch is nice in theory but has proved a bit of a
+  nightmare in practice.  The basic idea of their patch is that rsync
+  is rewritten to use the new getaddrinfo()/getnameinfo() interface,
+  rather than gethostbyname()/gethostbyaddr() as in rsync 2.4.6.
+  Systems that don't have the new interface are handled by providing
+  our own implementation in lib/, which is selectively linked in.
 
-  It might also reduce memory use in storing repeated directory names
--- again I'm not sure this is a problem.
+  The problem with this is that it is really hard to get right on
+  platforms that have a half-working implementation, so redefining
+  these functions clashes with system headers, and leaving them out
+  breaks.  This affects at least OSF/1, RedHat 5, and Cobalt, which
+  are moderately improtant.
 
-Performance
+  Perhaps the simplest solution would be to have two different files
+  implementing the same interface, and choose either the new or the
+  old API.  This is probably necessary for systems that e.g. have
+  IPv6, but gethostbyaddr() can't handle it.  The Linux manpage claims
+  this is currently the case.
 
-  Traverse just one directory at a time.  Tridge says it's possible.
+  In fact, our internal sockets interface (things like
+  open_socket_out(), etc) is much narrower than the getaddrinfo()
+  interface, and so probably simpler to get right.  In addition, the
+  old code is known to work well on old machines.
 
-  At the moment rsync reads the whole file list into memory at the
-  start, which makes us use a lot of memory and also not pipeline
-  network access as much as we could.
+  We could drop the rather large lib/getaddrinfo files.
 
+                      --          --
 
-Handling duplicate names
 
-  We need to be careful of duplicate names getting into the file list.
-  See clean_flist().  This could happen if multiple arguments include
-  the same file.  Bad.
+Other IPv6 stuff:
+  
+  Implement suggestions from http://www.kame.net/newsletter/19980604/
+  and ftp://ftp.iij.ad.jp/pub/RFC/rfc2553.txt
 
-  I think duplicates are only a problem if they're both flowing
-  through the pipeline at the same time.  For example we might have
-  updated the first occurrence after reading the checksums for the
-  second.  So possibly we just need to make sure that we don't have
-  both in the pipeline at the same time.
+  If a host has multiple addresses, then listen try to connect to all
+  in order until we get through.  (getaddrinfo may return multiple
+  addresses.)  This is kind of implemented already.
 
-  Possibly if we did one directory at a time that would be sufficient.
+  Possibly also when starting as a server we may need to listen on
+  multiple passive addresses.  This might be a bit harder, because we
+  may need to select on all of them.  Hm.
 
-  Alternatively we could pre-process the arguments to make sure no
-  duplicates will ever be inserted.  There could be some bad cases
-  when we're collapsing symlinks.
+  Define a syntax for IPv6 literal addresses.  Since they include
+  colons, they tend to break most naming systems, including ours.
+  Based on the HTTP IPv6 syntax, I think we should use
+ 
+     rsync://[::1]/foo/bar [::1]::bar
 
-  We could have a hash table.
+  which should just take a small change to the parser code.
 
-  The root of the problem is that we do not want more than one file
-  list entry referring to the same file.  At first glance there are
-  several ways this could happen: symlinks, hardlinks, and repeated
-  names on the command line.
+                      --          --
 
-  If names are repeated on the command line, they may be present in
-  different forms, perhaps by traversing directory paths in different
-  ways, traversing paths including symlinks.  Also we need to allow
-  for expansion of globs by rsync.
 
-  At the moment, clean_flist() requires having the entire file list in
-  memory.  Duplicate names are detected just by a string comparison.
+Add ACL support							2001/12/02
 
-  We don't need to worry about hard links causing duplicates because
-  files are never updated in place.  Similarly for symlinks.
+  Transfer ACLs.  Need to think of a standard representation.
+  Probably better not to even try to convert between NT and POSIX.
+  Possibly can share some code with Samba.
 
-  I think even if we're using a different symlink mode we don't need
-  to worry.
+                      --          --
 
-  Unless we're really clever this will introduce a protocol
-  incompatibility, so we need to be able to accept the old format as
-  well.
 
+Lazy directory creation
 
-Memory accounting
+  With the current common --include '*/' --exclude '*' pattern, people
+  can end up with many empty directories.  We might avoid this by
+  lazily creating such directories.
 
-  At exit, show how much memory was used for the file list, etc.
+                      --          --
 
-  Also we do a wierd exponential-growth allocation in flist.c.  I'm
-  not sure this makes sense with modern mallocs.  At any rate it will
-  make us allocate a huge amount of memory for large file lists.
 
+Conditional -z for old protocols
 
-Hard-link handling
+  After we get the @RSYNCD greeting from the server, we know it's
+  version but we have not yet sent the command line, so we could just
+  remove the -z option if the server is too old.
 
-  At the moment hardlink handling is very expensive, so it's off by
-  default.  It does not need to be so.
+  For ssh invocation it's not so simple, because we actually use the
+  command line to start the remote process.  However, we only actually
+  do compression in token.c, and we could therefore once we discover
+  the remote version emit an error if it's too old.  I'm not sure if
+  that's a good tradeoff or not.
 
-  Since most of the solutions are rather intertwined with the file
-  list it is probably better to fix that first, although fixing
-  hardlinks is possibly simpler.
+                      --          --
 
-  We can rule out hardlinked directories since they will probably
-  screw us up in all kinds of ways.  They simply should not be used.
 
-  At the moment rsync only cares about hardlinks to regular files.  I
-  guess you could also use them for sockets, devices and other beasts,
-  but I have not seen them.
+proxy authentication						2002/01/23
 
-  When trying to reproduce hard links, we only need to worry about
-  files that have more than one name (nlinks>1 && !S_ISDIR).
+  Allow RSYNC_PROXY to be http://user:pass@proxy.foo:3128/, and do
+  HTTP Basic Proxy-Authentication.
 
-  The basic point of this is to discover alternate names that refer to
-  the same file.  All operations, including creating the file and
-  writing modifications to it need only to be done for the first name.
-  For all later names, we just create the link and then leave it
-  alone.
+  Multiple schemes are possible, up to and including the insanity that
+  is NTLM, but Basic probably covers most cases.
 
-  If hard links are to be preserved:
+                      --          --
 
-    Before the generator/receiver fork, the list of files is received
-    from the sender (recv_file_list), and a table for detecting hard
-    links is built.
 
-    The generator looks for hard links within the file list and does
-    not send checksums for them, though it does send other metadata.
+SOCKS								2002/01/23
 
-    The sender sends the device number and inode with file entries, so
-    that files are uniquely identified.
+  Add --with-socks, and then perhaps a command-line option to put them
+  on or off.  This might be more reliable than LD_PRELOAD hacks.
 
-    The receiver goes through and creates hard links (do_hard_links)
-    after all data has been written, but before directory permissions
-    are set.
+                      --          --
 
-  At the moment device and inum are sent as 4-byte integers, which
-  will probably cause problems on large filesystems.  On Linux the
-  kernel uses 64-bit ino_t's internally, and people will soon have
-  filesystems big enough to use them.  We ought to follow NFS4 in
-  using 64-bit device and inode identification, perhaps with a
-  protocol version bump.
 
-  Once we've seen all the names for a particular file, we no longer
-  need to think about it and we can deallocate the memory.
+FAT support
 
-  We can also have the case where there are links to a file that are
-  not in the tree being transferred.  There's nothing we can do about
-  that.  Because we rename the destination into place after writing,
-  any hardlinks to the old file are always going to be orphaned.  In
-  fact that is almost necessary because otherwise we'd get really
-  confused if we were generating checksums for one name of a file and
-  modifying another.
+  rsync to a FAT partition on a Unix machine doesn't work very well at
+  the moment.  I think we get errors about invalid filenames and
+  perhaps also trying to do atomic renames.
 
-  At the moment the code seems to make a whole second copy of the file
-  list, which seems unnecessary.
+  I guess the code to do this is currently #ifdef'd on Windows;
+  perhaps we ought to intelligently fall back to it on Unix too.
 
-  We should have a test case that exercises hard links.  Since it
-  might be hard to compare ./tls output where the inodes change we
-  might need a little program to check whether several names refer to
-  the same file.
+                      --          --
 
 
+Allow forcing arbitrary permissions				2002/03/12
 
-Handling IPv6 on old machines
+  On 12 Mar 2002, Dave Dykstra <dwd@bell-labs.com> wrote:
+  > If we would add an option to do that functionality, I
+  > would vote for one that was more general which could mask
+  > off any set of permission bits and possibly add any set of
+  > bits.  Perhaps a chmod-like syntax if it could be
+  > implemented simply.
 
-  The KAME IPv6 patch is nice in theory but has proved a bit of a
-  nightmare in practice.  The basic idea of their patch is that rsync
-  is rewritten to use the new getaddrinfo()/getnameinfo() interface,
-  rather than gethostbyname()/gethostbyaddr() as in rsync 2.4.6.
-  Systems that don't have the new interface are handled by providing
-  our own implementation in lib/, which is selectively linked in.
+  I think that would be good too.  For example, people uploading files
+  to a web server might like to say
 
-  The problem with this is that it is really hard to get right on
-  platforms that have a half-working implementation, so redefining
-  these functions clashes with system headers, and leaving them out
-  breaks.  This affects at least OSF/1, RedHat 5, and Cobalt, which
-  are moderately improtant.
+  rsync -avzP --chmod a+rX ./ sourcefrog.net:/home/www/sourcefrog/
 
-  Perhaps the simplest solution would be to have two different files
-  implementing the same interface, and choose either the new or the
-  old API.  This is probably necessary for systems that e.g. have
-  IPv6, but gethostbyaddr() can't handle it.  The Linux manpage claims
-  this is currently the case.
+  Ideally the patch would implement as many of the gnu chmod semantics
+  as possible.  I think the mode parser should be a separate function
+  that passes back something like (mask,set) description to the rest
+  of the program.  For bonus points there would be a test case for the
+  parser.
 
-  In fact, our internal sockets interface (things like
-  open_socket_out(), etc) is much narrower than the getaddrinfo()
-  interface, and so probably simpler to get right.  In addition, the
-  old code is known to work well on old machines.
+  Possibly also --chown
 
-  We could drop the rather large lib/getaddrinfo files.
+  (Debian #23628)
 
+                      --          --
 
-Other IPv6 stuff:
-  
-  Implement suggestions from http://www.kame.net/newsletter/19980604/
-  and ftp://ftp.iij.ad.jp/pub/RFC/rfc2553.txt
 
-  If a host has multiple addresses, then listen try to connect to all
-  in order until we get through.  (getaddrinfo may return multiple
-  addresses.)  This is kind of implemented already.
+--diff						david.e.sewell	2002/03/15
 
-  Possibly also when starting as a server we may need to listen on
-  multiple passive addresses.  This might be a bit harder, because we
-  may need to select on all of them.  Hm.
+  Allow people to specify the diff command.  (Might want to use wdiff,
+  gnudiff, etc.)
 
-  Define a syntax for IPv6 literal addresses.  Since they include
-  colons, they tend to break most naming systems, including ours.
-  Based on the HTTP IPv6 syntax, I think we should use
- 
-     rsync://[::1]/foo/bar [::1]::bar
+  Just diff the temporary file with the destination file, and delete
+  the tmp file rather than moving it into place.
 
-  which should just take a small change to the parser code.
+  Interaction with --partial.
+
+  Security interactions with daemon mode?
+
+                      --          --
+
+
+Add daemon --no-detach and --no-fork options
+
+  Very useful for debugging.  Also good when running under a
+  daemon-monitoring process that tries to restart the service when the
+  parent exits.
 
+                      --          --
+
+
+Create more granular verbosity				jw	2003/05/15
+
+  Control output with the --report option.
+
+  The option takes as a single argument (no whitespace) a
+  comma delimited lists of keywords.
+
+  This would separate debugging from "logging" as well as
+  fine grained selection of statistical reporting and what
+  actions are logged.
+
+  http://lists.samba.org/archive/rsync/2003-May/006059.html
+
+                      --          --
+
+DOCUMENTATION --------------------------------------------------------
+
+Update README
+
+                      --          --
+
+
+Keep list of open issues and todos on the web site
 
-Errors
+                      --          --
+
+
+Update web site from CVS
+
+                      --          --
+
+
+Perhaps redo manual as SGML
+
+  The man page is getting rather large, and there is more information
+  that ought to be added.
+
+  TexInfo source is probably a dying format.
+
+  Linuxdoc looks like the most likely contender.  I know DocBook is
+  favoured by some people, but it's so bloody verbose, even with emacs
+  support.
+
+                      --          --
+
+LOGGING --------------------------------------------------------------
+
+Make dry run list all updates					2002/04/03
+
+  --dry-run is too dry
+
+  Mark Santcroos points out that -n fails to list files which have
+  only metadata changes, though it probably should.
+
+  There may be a Debian bug about this as well.
+
+                      --          --
+
+
+Memory accounting
+
+  At exit, show how much memory was used for the file list, etc.
+
+  Also we do a wierd exponential-growth allocation in flist.c.  I'm
+  not sure this makes sense with modern mallocs.  At any rate it will
+  make us allocate a huge amount of memory for large file lists.
+
+                      --          --
+
+
+Improve error messages
 
   If we hang or get SIGINT, then explain where we were up to.  Perhaps
   have a static buffer that contains the current function name, or
   some kind of description of what we were trying to do.  This is a
   little easier on people than needing to run strace/truss.
 
@@ -394,422 +442,519 @@
 
   What happens if a directory is missing -x attributes.  Do we lose
   our load?  (Debian #28416) Probably fixed now, but a test case would
   be good.
 
 
-File attributes
 
-  Device major/minor numbers should be at least 32 bits each.  See
-  http://lists.samba.org/pipermail/rsync/2001-November/005357.html
+                      --          --
 
-  Transfer ACLs.  Need to think of a standard representation.
-  Probably better not to even try to convert between NT and POSIX.
-  Possibly can share some code with Samba.
 
-Empty directories
+Better statistics:					Rasmus	2002/03/08
 
-  With the current common --include '*/' --exclude '*' pattern, people
-  can end up with many empty directories.  We might avoid this by
-  lazily creating such directories.
+  <Rasmus>
+      hey, how about an rsync option that just gives you the
+      summary without the list of files?  And perhaps gives
+      more information like the number of new files, number
+      of changed, deleted, etc. ?
+
+  <mbp>
+      nice idea there is --stats but at the moment it's very
+      tridge-oriented rather than user-friendly it would be
+      nice to improve it that would also work well with
+      --dryrun
+
+                      --          --
 
 
-zlib
+Perhaps flush stdout like syslog
+
+  Perhaps flush stdout after each filename, so that people trying to
+  monitor progress in a log file can do so more easily.  See
+  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=48108
+
+                      --          --
+
+
+Log deamon sessions that just list modules
+
+  At the connections that just get a list of modules are not logged,
+  but they should be.
+
+                      --          --
+
+
+Log child death on signal
+
+  If a child of the rsync daemon dies with a signal, we should notice
+  that when we reap it and log a message.
+
+                      --          --
+
+
+Keep stderr and stdout properly separated (Debian #23626)
+
+                      --          --
+
+
+Log errors with function that reports process of origin
+
+  Use a separate function for reporting errors; prefix it with
+  "rsync:" or "rsync(remote)", or perhaps even "rsync(local
+  generator): ".
+
+                      --          --
+
+
+verbose output					David Stein	2001/12/20
+  
+  Indicate whether files are new, updated, or deleted
+
+  At end of transfer, show how many files were or were not transferred
+  correctly.
+
+                      --          --
+
+
+Add reason for transfer to file logging
+
+  Explain *why* every file is transferred or not (e.g. "local mtime
+  123123 newer than 1283198")
+
+                      --          --
+
+
+debugging of daemon						2002/04/08
+
+  Add an rsyncd.conf parameter to turn on debugging on the server.
+
+                      --          --
+
+
+internationalization
+
+  Change to using gettext().  Probably need to ship this for platforms
+  that don't have it.
+
+  Solicit translations.
+
+  Does anyone care?  Before we bother modifying the code, we ought to
+  get the manual translated first, because that's possibly more useful
+  and at any rate demonstrates desire.
+
+                      --          --
+
+DEVELOPMENT --------------------------------------------------------
+
+Handling duplicate names
+
+  We need to be careful of duplicate names getting into the file list.
+  See clean_flist().  This could happen if multiple arguments include
+  the same file.  Bad.
+
+  I think duplicates are only a problem if they're both flowing
+  through the pipeline at the same time.  For example we might have
+  updated the first occurrence after reading the checksums for the
+  second.  So possibly we just need to make sure that we don't have
+  both in the pipeline at the same time.
+
+  Possibly if we did one directory at a time that would be sufficient.
+
+  Alternatively we could pre-process the arguments to make sure no
+  duplicates will ever be inserted.  There could be some bad cases
+  when we're collapsing symlinks.
+
+  We could have a hash table.
+
+  The root of the problem is that we do not want more than one file
+  list entry referring to the same file.  At first glance there are
+  several ways this could happen: symlinks, hardlinks, and repeated
+  names on the command line.
+
+  If names are repeated on the command line, they may be present in
+  different forms, perhaps by traversing directory paths in different
+  ways, traversing paths including symlinks.  Also we need to allow
+  for expansion of globs by rsync.
+
+  At the moment, clean_flist() requires having the entire file list in
+  memory.  Duplicate names are detected just by a string comparison.
+
+  We don't need to worry about hard links causing duplicates because
+  files are never updated in place.  Similarly for symlinks.
+
+  I think even if we're using a different symlink mode we don't need
+  to worry.
+
+  Unless we're really clever this will introduce a protocol
+  incompatibility, so we need to be able to accept the old format as
+  well.
+
+                      --          --
+
+
+Use generic zlib						2002/02/25
 
   Perhaps don't use our own zlib.
 
   Advantages:
    
     - will automatically be up to date with bugfixes in zlib
 
     - can leave it out for small rsync on e.g. recovery disks
 
     - can use a shared library
 
-    - avoids people breaking rsync by trying to do this themselves and
-      messing up
+    - avoids people breaking rsync by trying to do this themselves and
+      messing up
+
+  Should we ship zlib for systems that don't have it, or require
+  people to install it separately?
+
+  Apparently this will make us incompatible with versions of rsync
+  that use the patched version of rsync.  Probably the simplest way to
+  do this is to just disable gzip (with a warning) when talking to old
+  versions.
+
+                      --          --
+
+
+TDB:								2002/03/12
+
+  Rather than storing the file list in memory, store it in a TDB.
+
+  This *might* make memory usage lower while building the file list.
+
+  Hashtable lookup will mean files are not transmitted in order,
+  though... hm.
+
+  This would neatly eliminate one of the major post-fork shared data
+  structures.
+
+                      --          --
+
+
+Splint								2002/03/12
+
+  Build rsync with SPLINT to try to find security holes.  Add
+  annotations as necessary.  Keep track of the number of warnings
+  found initially, and see how many of them are real bugs, or real
+  security bugs.  Knowing the percentage of likely hits would be
+  really interesting for other projects.
+
+                      --          --
 
-  Should we ship zlib for systems that don't have it, or require
-  people to install it separately?
 
-  Apparently this will make us incompatible with versions of rsync
-  that use the patched version of rsync.  Probably the simplest way to
-  do this is to just disable gzip (with a warning) when talking to old
-  versions.
+Memory debugger
 
+  jra recommends Valgrind:
 
-logging
+    http://devel-home.kde.org/~sewardj/
 
-  Perhaps flush stdout after each filename, so that people trying to
-  monitor progress in a log file can do so more easily.  See
-  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=48108
+                      --          --
 
-  At the connections that just get a list of modules are not logged,
-  but they should be.
 
-  If a child of the rsync daemon dies with a signal, we should notice
-  that when we reap it and log a message.
+Create release script
+  
+  Script would:
 
-  Keep stderr and stdout properly separated (Debian #23626)
+     Update spec files
 
-  After we get the @RSYNCD greeting from the server, we know it's
-  version but we have not yet sent the command line, so we could just
-  remove the -z option if the server is too old.
+     Build tar file; upload
 
-  For ssh invocation it's not so simple, because we actually use the
-  command line to start the remote process.  However, we only actually
-  do compression in token.c, and we could therefore once we discover
-  the remote version emit an error if it's too old.  I'm not sure if
-  that's a good tradeoff or not.
+     Send announcement to mailing list and c.o.l.a.
+  
+     Make freshmeat announcement
 
+     Update web site
 
-proxy authentication
+                      --          --
 
-  Allow RSYNC_PROXY to be http://user:pass@proxy.foo:3128/, and do
-  HTTP Basic Proxy-Authentication.
 
-  Multiple schemes are possible, up to and including the insanity that
-  is NTLM, but Basic probably covers most cases.
+Add machines to build farm
 
-SOCKS
+  Cygwin (on different versions of Win32?)
 
-  Add --with-socks, and then perhaps a command-line option to put them
-  on or off.  This might be more reliable than LD_PRELOAD hacks.
+  HP-UX variants (via HP?)
 
-FAT support
+  SCO
 
-  rsync to a FAT partition on a Unix machine doesn't work very well at
-  the moment.  I think we get errors about invalid filenames and
-  perhaps also trying to do atomic renames.
 
-  I guess the code to do this is currently #ifdef'd on Windows;
-  perhaps we ought to intelligently fall back to it on Unix too.
 
+                      --          --
 
-Better statistics:
+PERFORMANCE ----------------------------------------------------------
 
-  <Rasmus> mbp: hey, how about an rsync option that just gives you the
-  summary without the list of files?  And perhaps gives more
-  information like the number of new files, number of changed,
-  deleted, etc. ?  <mbp> Rasmus: nice idea <mbp> there is --stats
-  <mbp> but at the moment it's very tridge-oriented <mbp> rather than
-  user-friendly <mbp> it would be nice to improve it <mbp> that would
-  also work well with --dryrun
+File list structure in memory
 
-TDB:
+  Rather than one big array, perhaps have a tree in memory mirroring
+  the directory tree.
 
-  Rather than storing the file list in memory, store it in a TDB.
+  This might make sorting much faster!  (I'm not sure it's a big CPU
+  problem, mind you.)
 
-  This *might* make memory usage lower while building the file list.
+  It might also reduce memory use in storing repeated directory names
+  -- again I'm not sure this is a problem.
 
-  Hashtable lookup will mean files are not transmitted in order,
-  though... hm.
+                      --          --
 
-  This would neatly eliminate one of the major post-fork shared data
-  structures.
 
+Traverse just one directory at a time
 
-chmod:
+  Traverse just one directory at a time.  Tridge says it's possible.
 
-  On 12 Mar 2002, Dave Dykstra <dwd@bell-labs.com> wrote: > If we
-would add an option to do that functionality, I would vote for one >
-that was more general which could mask off any set of permission bits
-and > possibly add any set of bits.  Perhaps a chmod-like syntax if it
-could be > implemented simply.
+  At the moment rsync reads the whole file list into memory at the
+  start, which makes us use a lot of memory and also not pipeline
+  network access as much as we could.
 
-  I think that would be good too.  For example, people uploading files
-  to a web server might like to say
+                      --          --
 
-  rsync -avzP --chmod a+rX ./ sourcefrog.net:/home/www/sourcefrog/
 
-  Ideally the patch would implement as many of the gnu chmod semantics
-  as possible.  I think the mode parser should be a separate function
-  that passes back something like (mask,set) description to the rest
-  of the program.  For bonus points there would be a test case for the
-  parser.
+Hard-link handling
 
-  Possibly also --chown
+  At the moment hardlink handling is very expensive, so it's off by
+  default.  It does not need to be so.
 
-  (Debian #23628)
+  Since most of the solutions are rather intertwined with the file
+  list it is probably better to fix that first, although fixing
+  hardlinks is possibly simpler.
 
+  We can rule out hardlinked directories since they will probably
+  screw us up in all kinds of ways.  They simply should not be used.
 
---diff
+  At the moment rsync only cares about hardlinks to regular files.  I
+  guess you could also use them for sockets, devices and other beasts,
+  but I have not seen them.
 
-  Allow people to specify the diff command.  (Might want to use wdiff,
-  gnudiff, etc.)
+  When trying to reproduce hard links, we only need to worry about
+  files that have more than one name (nlinks>1 && !S_ISDIR).
 
-  Just diff the temporary file with the destination file, and delete
-  the tmp file rather than moving it into place.
+  The basic point of this is to discover alternate names that refer to
+  the same file.  All operations, including creating the file and
+  writing modifications to it need only to be done for the first name.
+  For all later names, we just create the link and then leave it
+  alone.
 
-  Interaction with --partial.
+  If hard links are to be preserved:
 
-  Security interactions with daemon mode?
+    Before the generator/receiver fork, the list of files is received
+    from the sender (recv_file_list), and a table for detecting hard
+    links is built.
 
-  (Suggestion from david.e.sewell)
+    The generator looks for hard links within the file list and does
+    not send checksums for them, though it does send other metadata.
 
+    The sender sends the device number and inode with file entries, so
+    that files are uniquely identified.
 
-Incorrect timestamps (Debian #100295)
+    The receiver goes through and creates hard links (do_hard_links)
+    after all data has been written, but before directory permissions
+    are set.
 
-  A bit hard to believe, but apparently it happens.
+  At the moment device and inum are sent as 4-byte integers, which
+  will probably cause problems on large filesystems.  On Linux the
+  kernel uses 64-bit ino_t's internally, and people will soon have
+  filesystems big enough to use them.  We ought to follow NFS4 in
+  using 64-bit device and inode identification, perhaps with a
+  protocol version bump.
 
+  Once we've seen all the names for a particular file, we no longer
+  need to think about it and we can deallocate the memory.
 
-Check "refuse options works"
+  We can also have the case where there are links to a file that are
+  not in the tree being transferred.  There's nothing we can do about
+  that.  Because we rename the destination into place after writing,
+  any hardlinks to the old file are always going to be orphaned.  In
+  fact that is almost necessary because otherwise we'd get really
+  confused if we were generating checksums for one name of a file and
+  modifying another.
 
-  We need a test case for this...
+  At the moment the code seems to make a whole second copy of the file
+  list, which seems unnecessary.
 
-  Was this broken when we changed to popt?
+  We should have a test case that exercises hard links.  Since it
+  might be hard to compare ./tls output where the inodes change we
+  might need a little program to check whether several names refer to
+  the same file.
 
+                      --          --
 
-PERFORMANCE ----------------------------------------------------------
 
-MD4 file_sum
+Allow skipping MD4 file_sum					2002/04/08
 
   If we're doing a local transfer, or using -W, then perhaps don't
   send the file checksum.  If we're doing a local transfer, then
   calculating MD4 checksums uses 90% of CPU and is unlikely to be
   useful.
 
   Indeed for transfers over zlib or ssh we can also rely on the
   transport to have quite strong protection against corruption.
 
-  Perhaps we should have an option to disable this, analogous to
---whole-file, although it would default to disabled.  The file
-checksum takes up a definite space in the protocol -- we can either
-set it to 0, or perhaps just leave it out.
+  Perhaps we should have an option to disable this,
+  analogous to --whole-file, although it would default to
+  disabled.  The file checksum takes up a definite space in
+  the protocol -- we can either set it to 0, or perhaps just
+  leave it out.
+
+                      --          --
 
-MD4
+
+Accelerate MD4
 
   Perhaps borrow an assembler MD4 from someone?
 
   Make sure we call MD4 with properly-sized blocks whenever possible
   to avoid copying into the residue region?
 
+                      --          --
+
+
 String area code
 
   Test whether this is actually faster than just using malloc().  If
   it's not (anymore), throw it out.
-	  
-
-PLATFORMS ------------------------------------------------------------
-
-Win32
-
-  Don't detach, because this messes up --srvany.
-
-  http://sources.redhat.com/ml/cygwin/2001-08/msg00234.html
-
-
-DEVELOPMENT ----------------------------------------------------------
 
-Splint
+                      --          --
 
-  Build rsync with SPLINT to try to find security holes.  Add
-  annotations as necessary.  Keep track of the number of warnings
-  found initially, and see how many of them are real bugs, or real
-  security bugs.  Knowing the percentage of likely hits would be
-  really interesting for other projects.
+TESTING --------------------------------------------------------------
 
 Torture test
 
   Something that just keeps running rsync continuously over a data set
   likely to generate problems.
 
-Cross-testing
-
-  Run current rsync versions against significant past releases.
-
-Memory debugger
-
-  jra recommends Valgrind:
-
-    http://devel-home.kde.org/~sewardj/
-
-Release script
-  
-  Update spec files
-
-  Build tar file; upload
-
-  Send announcement to mailing list and c.o.l.a.
-  
-  Make freshmeat announcement
-
-  Update web site
+                      --          --
 
 
+Cross-test versions						2001/08/22
 
-TESTING --------------------------------------------------------------
-
-Cross-test versions
+  Part of the regression suite should be making sure that we
+  don't break backwards compatibility: old clients vs new
+  servers and so on.  Ideally we would test both up and down
+  from the current release to all old versions.
 
-  Part of the regression suite should be making sure that we don't
-  break backwards compatibility: old clients vs new servers and so on.
-  Ideally we would test both up and down from the current release to
-  all old versions.
+  Run current rsync versions against significant past releases.
 
   We might need to omit broken old versions, or versions in which
   particular functionality is broken
 
   It might be sufficient to test downloads from well-known public
   rsync servers running different versions of rsync.  This will give
   some testing and also be the most common case for having different
   versions and not being able to upgrade.
 
+  The new --protocol option may help in this.
+
+                      --          --
+
 
 Test on kernel source
 
   Download all versions of kernel; unpack, sync between them.  Also
   sync between uncompressed tarballs.  Compare directories after
   transfer.
 
   Use local mode; ssh; daemon; --whole-file and --no-whole-file.
 
   Use awk to pull out the 'speedup' number for each transfer.  Make
   sure it is >= x.
 
+                      --          --
+
 
 Test large files
 
   Sparse and non-sparse
 
-Mutator program
-
-  Insert bytes, delete bytes, swap blocks, ...
-
-configure option to enable dangerous tests
-
-If tests are skipped, say why.
-
-Test daemon feature to disallow particular options.
-
-Pipe program that makes slow/jerky connections.
-
-Versions of read() and write() that corrupt the stream, or abruptly
-fail
-
-Separate makefile target to run rough tests -- or perhaps just run
-them every time?
-
-Test "refuse options" works
-
-  What about for --recursive?
-
-  If you specify an unrecognized option here, you should get an error.
-
-
-DOCUMENTATION --------------------------------------------------------
-
-Update README
-
-Keep list of open issues and todos on the web site
-
-Update web site from CVS
-
-
-Perhaps redo manual as SGML
-
-  The man page is getting rather large, and there is more information
-  that ought to be added.
-
-  TexInfo source is probably a dying format.
-
-  Linuxdoc looks like the most likely contender.  I know DocBook is
-  favoured by some people, but it's so bloody verbose, even with emacs
-  support.
-
+                      --          --
 
-BUILD FARM -----------------------------------------------------------
 
-Add machines
+Create mutator program for testing
 
-  Cygwin (on different versions of Win32?)
+  Insert bytes, delete bytes, swap blocks, ...
 
-  HP-UX variants (via HP?)
+                      --          --
 
-  SCO
 
+Create configure option to enable dangerous tests
 
-LOGGING --------------------------------------------------------------
+                      --          --
 
-  Perhaps flush stdout after each filename, so that people trying to
-  monitor progress in a log file can do so more easily.  See
-  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=48108
 
-  At the connections that just get a list of modules are not logged,
-  but they should be.
+If tests are skipped, say why.
 
-  If a child of the rsync daemon dies with a signal, we should notice
-  that when we reap it and log a message.
+                      --          --
 
-  Keep stderr and stdout properly separated (Debian #23626)
 
-  Use a separate function for reporting errors; prefix it with
-  "rsync:" or "rsync(remote)", or perhaps even "rsync(local
-  generator): ".
+Test daemon feature to disallow particular options.
 
-verbose output
-  
-  Indicate whether files are new, updated, or deleted
+                      --          --
 
-  At end of transfer, show how many files were or were not transferred
-  correctly.
 
--vv
+Create pipe program for testing
 
-  Explain *why* every file is transferred or not (e.g. "local mtime
-  123123 newer than 1283198")
+  Create pipe program that makes slow/jerky connections for
+  testing Versions of read() and write() that corrupt the
+  stream, or abruptly fail
 
+                      --          --
 
-debugging of daemon
 
-  Add an rsyncd.conf parameter to turn on debugging on the server.
+Create test makefile target for some tests
 
+  Separate makefile target to run rough tests -- or perhaps
+  just run them every time?
 
+                      --          --
 
-NICE -----------------------------------------------------------------
 
---no-detach and --no-fork options
+Test "refuse options" works
 
-  Very useful for debugging.  Also good when running under a
-  daemon-monitoring process that tries to restart the service when the
-  parent exits.
+  What about for --recursive?
 
-hang/timeout friendliness
+  If you specify an unrecognized option here, you should get an error.
 
-internationalization
+  We need a test case for this...
 
-  Change to using gettext().  Probably need to ship this for platforms
-  that don't have it.
+  Was this broken when we changed to popt?
 
-  Solicit translations.
+                      --          --
 
-  Does anyone care?  Before we bother modifying the code, we ought to
-  get the manual translated first, because that's possibly more useful
-  and at any rate demonstrates desire.
+RELATED PROJECTS -----------------------------------------------------
 
 rsyncsh
 
    Write a small emulation of interactive ftp as a Pythonn program
    that calls rsync.  Commands such as "cd", "ls", "ls *.c" etc map
    fairly directly into rsync commands: it just needs to remember the
    current host, directory and so on.  We can probably even do
    completion of remote filenames.
 
+                      --          --
 
-RELATED PROJECTS -----------------------------------------------------
 
 http://rsync.samba.org/rsync-and-debian/
 
+
+                      --          --
+
+
 rsyncable gzip patch
 
   Exhaustive, tortuous testing
 
   Cleanups?
 
+                      --          --
+
+
 rsyncsplit as alternative to real integration with gzip?
 
+                      --          --
+
+
 reverse rsync over HTTP Range
 
   Goswin Brederlow suggested this on Debian; I think tridge and I
   talked about it previous in relation to rproxy.
 
+                      --          --
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/token.c	2003-12-04 12:23:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/token.c	2003-12-07 05:07:27.000000000 +0800
@@ -48,13 +48,13 @@
 	if (!dont || !fname) return;
 
 	strlower(dont);
 	strlower(fname);
 
 	for (tok=strtok(dont," ");tok;tok=strtok(NULL," ")) {
-		if (fnmatch(tok, fname, 0) == 0) {
+		if (wildmatch(tok, fname)) {
 			compression_level = 0;
 			break;
 		}
 	}
 	free(dont);
 	free(fname);
@@ -87,34 +87,34 @@
 
 
 /* non-compressing send token */
 static void simple_send_token(int f,int token,
 			      struct map_struct *buf,OFF_T offset,int n)
 {
-	extern int write_batch; /* dw */
-	int hold_int; /* dw */
+	extern int write_batch;
+	int hold_int;
 
 	if (n > 0) {
 		int l = 0;
 		while (l < n) {
 			int n1 = MIN(CHUNK_SIZE,n-l);
 			write_int(f,n1);
 			write_buf(f,map_ptr(buf,offset+l,n1),n1);
 			if (write_batch) {
-			    write_batch_delta_file( (char *) &n1, sizeof(int) );
-			    write_batch_delta_file(map_ptr(buf,offset+l,n1),n1);
+				write_batch_delta_file( (char *) &n1, sizeof(int) );
+				write_batch_delta_file(map_ptr(buf,offset+l,n1),n1);
 			}
 			l += n1;
 		}
 	}
 	/* a -2 token means to send data only and no token */
 	if (token != -2) {
 		write_int(f,-(token+1));
 		if (write_batch) {
-		    hold_int = -(token+1);
-		    write_batch_delta_file( (char *) &hold_int, sizeof(int) );
+			hold_int = -(token+1);
+			write_batch_delta_file( (char *) &hold_int, sizeof(int) );
 		}
 	}
 }
 
 
 /* Flag bytes in compressed stream are encoded as follows: */
@@ -124,32 +124,46 @@
 #define DEFLATED_DATA	0x40	/* + 6-bit high len, then low len byte */
 #define TOKEN_REL	0x80	/* + 6-bit relative token number */
 #define TOKENRUN_REL	0xc0	/* ditto with 16-bit run count */
 
 #define MAX_DATA_COUNT	16383	/* fit 14 bit count into 2 bytes with flags */
 
+/* zlib.h says that if we want to be able to compress something in a single
+ * call, avail_out must be at least 0.1% larger than avail_in plus 12 bytes.
+ * We'll add in 0.1%+16, just to be safe (and we'll avoid floating point,
+ * to ensure that this is a compile-time value). */
+#define AVAIL_OUT_SIZE(avail_in_size) ((avail_in_size)*1001/1000+16)
+
 /* For coding runs of tokens */
 static int last_token = -1;
 static int run_start;
 static int last_run_end;
 
 /* Deflation state */
 static z_stream tx_strm;
 
 /* Output buffer */
 static char *obuf;
 
+/* We want obuf to be able to hold both MAX_DATA_COUNT+2 bytes as well as
+ * AVAIL_OUT_SIZE(CHUNK_SIZE) bytes, so make sure that it's large enough. */
+#if MAX_DATA_COUNT+2 > AVAIL_OUT_SIZE(CHUNK_SIZE)
+#define OBUF_SIZE	(MAX_DATA_COUNT+2)
+#else
+#define OBUF_SIZE	AVAIL_OUT_SIZE(CHUNK_SIZE)
+#endif
+
 /* Send a deflated token */
 static void
 send_deflated_token(int f, int token,
 		    struct map_struct *buf, OFF_T offset, int nb, int toklen)
 {
 	int n, r;
 	static int init_done, flush_pending;
-	extern int write_batch;  /* dw */
-	char temp_byte;   /* dw */
+	extern int write_batch;
+	char temp_byte;
 
 	if (last_token == -1) {
 		/* initialization */
 		if (!init_done) {
 			tx_strm.next_in = NULL;
 			tx_strm.zalloc = NULL;
@@ -157,13 +171,13 @@
 			if (deflateInit2(&tx_strm, compression_level,
 					 Z_DEFLATED, -15, 8,
 					 Z_DEFAULT_STRATEGY) != Z_OK) {
 				rprintf(FERROR, "compression init failed\n");
 				exit_cleanup(RERR_STREAMIO);
 			}
-			if ((obuf = new_array(char, MAX_DATA_COUNT+2)) == NULL)
+			if ((obuf = new_array(char, OBUF_SIZE)) == NULL)
 				out_of_memory("send_deflated_token");
 			init_done = 1;
 		} else
 			deflateReset(&tx_strm);
 		last_run_end = 0;
 		run_start = token;
@@ -176,32 +190,32 @@
 		   || token >= run_start + 65536) {
 		/* output previous run */
 		r = run_start - last_run_end;
 		n = last_token - run_start;
 		if (r >= 0 && r <= 63) {
 			write_byte(f, (n==0? TOKEN_REL: TOKENRUN_REL) + r);
-			if (write_batch) { /* dw */
-			    temp_byte = (char)( (n==0? TOKEN_REL: TOKENRUN_REL) + r);
-			    write_batch_delta_file(&temp_byte,sizeof(char));
+			if (write_batch) {
+				temp_byte = (char)( (n==0? TOKEN_REL: TOKENRUN_REL) + r);
+				write_batch_delta_file(&temp_byte,sizeof(char));
 			}
 		} else {
 			write_byte(f, (n==0? TOKEN_LONG: TOKENRUN_LONG));
 			write_int(f, run_start);
-			if (write_batch) { /* dw */
-			    temp_byte = (char)(n==0? TOKEN_LONG: TOKENRUN_LONG);
-			    write_batch_delta_file(&temp_byte,sizeof(temp_byte));
-			    write_batch_delta_file((char *)&run_start,sizeof(run_start));
+			if (write_batch) {
+				temp_byte = (char)(n==0? TOKEN_LONG: TOKENRUN_LONG);
+				write_batch_delta_file(&temp_byte,sizeof(temp_byte));
+				write_batch_delta_file((char *)&run_start,sizeof(run_start));
 			}
 		}
 		if (n != 0) {
 			write_byte(f, n);
 			write_byte(f, n >> 8);
-			if (write_batch) { /* dw */
-			    write_batch_delta_file((char *)&n,sizeof(char));
-			    temp_byte = (char) n >> 8;
-			    write_batch_delta_file(&temp_byte,sizeof(temp_byte));
+			if (write_batch) {
+				write_batch_delta_file((char *)&n,sizeof(char));
+				temp_byte = (char)(n >> 8);
+				write_batch_delta_file(&temp_byte,sizeof(temp_byte));
 			}
 		}
 		last_run_end = last_token;
 		run_start = token;
 	}
 
@@ -255,35 +269,35 @@
 					n -= 4;
 				}
 				if (n > 0) {
 					obuf[0] = DEFLATED_DATA + (n >> 8);
 					obuf[1] = n;
 					write_buf(f, obuf, n+2);
-					if (write_batch) /* dw */
-					    write_batch_delta_file(obuf,n+2);
+					if (write_batch)
+						write_batch_delta_file(obuf,n+2);
 				}
 			}
 		} while (nb != 0 || tx_strm.avail_out == 0);
 		flush_pending = token == -2;
 	}
 
 	if (token == -1) {
 		/* end of file - clean up */
 		write_byte(f, END_FLAG);
-		if (write_batch) { /* dw */
-		    temp_byte = END_FLAG;
-		    write_batch_delta_file((char *)&temp_byte,sizeof(temp_byte));
+		if (write_batch) {
+			temp_byte = END_FLAG;
+			write_batch_delta_file((char *)&temp_byte,sizeof(temp_byte));
 		}
 
 	} else if (token != -2) {
 		/* add the data in the current block to the compressor's
 		   history and hash table */
 		tx_strm.next_in = (Bytef *) map_ptr(buf, offset, toklen);
 		tx_strm.avail_in = toklen;
 		tx_strm.next_out = (Bytef *) obuf;
-		tx_strm.avail_out = MAX_DATA_COUNT;
+		tx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);
 		r = deflate(&tx_strm, Z_INSERT_ONLY);
 		if (r != Z_OK || tx_strm.avail_in != 0) {
 			rprintf(FERROR, "deflate on token returned %d (%d bytes left)\n",
 				r, tx_strm.avail_in);
 			exit_cleanup(RERR_STREAMIO);
 		}
@@ -320,13 +334,13 @@
 				rx_strm.zfree = NULL;
 				if (inflateInit2(&rx_strm, -15) != Z_OK) {
 					rprintf(FERROR, "inflate init failed\n");
 					exit_cleanup(RERR_STREAMIO);
 				}
 				if (!(cbuf = new_array(char, MAX_DATA_COUNT))
-				    || !(dbuf = new_array(char, CHUNK_SIZE)))
+				    || !(dbuf = new_array(char, AVAIL_OUT_SIZE(CHUNK_SIZE))))
 					out_of_memory("recv_deflated_token");
 				init_done = 1;
 			} else {
 				inflateReset(&rx_strm);
 			}
 			recv_state = r_idle;
@@ -349,15 +363,15 @@
 				break;
 			}
 			if (recv_state == r_inflated) {
 				/* check previous inflated stuff ended correctly */
 				rx_strm.avail_in = 0;
 				rx_strm.next_out = (Bytef *)dbuf;
-				rx_strm.avail_out = CHUNK_SIZE;
+				rx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);
 				r = inflate(&rx_strm, Z_SYNC_FLUSH);
-				n = CHUNK_SIZE - rx_strm.avail_out;
+				n = AVAIL_OUT_SIZE(CHUNK_SIZE) - rx_strm.avail_out;
 				/*
 				 * Z_BUF_ERROR just means no progress was
 				 * made, i.e. the decompressor didn't have
 				 * any pending output for us.
 				 */
 				if (r != Z_OK && r != Z_BUF_ERROR) {
@@ -405,15 +419,15 @@
 				recv_state = r_running;
 			}
 			return -1 - rx_token;
 
 		case r_inflating:
 			rx_strm.next_out = (Bytef *)dbuf;
-			rx_strm.avail_out = CHUNK_SIZE;
+			rx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);
 			r = inflate(&rx_strm, Z_NO_FLUSH);
-			n = CHUNK_SIZE - rx_strm.avail_out;
+			n = AVAIL_OUT_SIZE(CHUNK_SIZE) - rx_strm.avail_out;
 			if (r != Z_OK) {
 				rprintf(FERROR, "inflate returned %d (%d bytes)\n", r, n);
 				exit_cleanup(RERR_STREAMIO);
 			}
 			if (rx_strm.avail_in == 0)
 				recv_state = r_inflated;
@@ -462,13 +476,13 @@
 				rx_strm.avail_in = blklen;
 				len -= blklen;
 				blklen = 0;
 			}
 		}
 		rx_strm.next_out = (Bytef *)dbuf;
-		rx_strm.avail_out = CHUNK_SIZE;
+		rx_strm.avail_out = AVAIL_OUT_SIZE(CHUNK_SIZE);
 		r = inflate(&rx_strm, Z_SYNC_FLUSH);
 		if (r != Z_OK) {
 			rprintf(FERROR, "inflate (token) returned %d\n", r);
 			exit_cleanup(RERR_STREAMIO);
 		}
 	} while (len || rx_strm.avail_out == 0);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/trimslash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/trimslash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/trimslash.c	2003-01-21 09:35:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/trimslash.c	2003-09-10 16:27:34.000000000 +0800
@@ -26,13 +26,14 @@
 
 /**
  * @file trimslash.c
  *
  * Test harness; not linked into release.
  **/
-int main(int argc, char **argv)
+int
+main(int argc, char **argv)
 {
 	int i;
 	
 	if (argc <= 1) {
 		fprintf(stderr, "trimslash: needs at least one argument\n");
 		return 1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/t_stub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/t_stub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/t_stub.c	2002-04-08 12:12:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/t_stub.c	2003-09-11 12:48:13.000000000 +0800
@@ -24,14 +24,16 @@
  *
  * This file contains really simple implementations for rsync global
  * functions, so that module test harnesses can run standalone.
  **/
 
 int modify_window = 0;
+int module_id = -1;
+struct exclude_struct **server_exclude_list;
 
- void rprintf(enum logcode UNUSED(code), const char *format, ...)
+ void rprintf(UNUSED(enum logcode code), const char *format, ...)
 {
 	va_list ap;
 	va_start(ap, format);
 	vfprintf(stderr, format, ap);
 	va_end(ap);
 }
@@ -39,6 +41,30 @@
  void _exit_cleanup(int code, const char *file, int line)
 {
 	fprintf(stderr, "exit(%d): %s(%d)\n",
 		code, file, line);
 	exit(code);
 }
+
+ int check_exclude(UNUSED(struct exclude_struct **list), UNUSED(char *name),
+		   UNUSED(int name_is_dir))
+{
+	/* This function doesn't really get called in this test context, so
+	 * just return 0. */
+	return 0;
+}
+
+ char *lp_name(UNUSED(int mod))
+{
+    return NULL;
+}
+
+ BOOL lp_use_chroot(UNUSED(int mod))
+{
+    return 0;
+}
+
+ char *lp_path(UNUSED(int mod))
+{
+    return NULL;
+}
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/t_unsafe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/t_unsafe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/t_unsafe.c	2003-01-21 09:35:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/t_unsafe.c	2003-09-10 16:27:34.000000000 +0800
@@ -28,13 +28,14 @@
 #include "rsync.h"
 
 int dry_run, read_only, list_only, verbose;
 int preserve_perms = 0;
 
 
-int main(int argc, char **argv)
+int
+main(int argc, char **argv)
 {
 	if (argc != 3) {
 		fprintf(stderr, "usage: t_unsafe LINKDEST SRCDIR\n");
 		return 1;
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/util.c	2003-12-04 12:23:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/util.c	2003-12-07 05:07:27.000000000 +0800
@@ -342,15 +342,16 @@
 	do {
 		sprintf(&path[pos], "%03d", counter);
 		if (++counter >= MAX_RENAMES)
 			counter = 1;
 	} while (((rc = access(path, 0)) == 0) && (counter != start));
 
-	if (verbose > 0)
+	if (verbose > 0) {
 		rprintf(FINFO,"renaming %s to %s because of text busy\n",
-					    fname, path);
+			fname, path);
+	}
 
 	/* maybe we should return rename()'s exit status? Nah. */
 	if (do_rename(fname, path) != 0) {
 		errno = ETXTBSY;
 		return -1;
 	}
@@ -455,72 +456,92 @@
 	lock.l_len = len;
 	lock.l_pid = 0;
 	
 	return fcntl(fd,F_SETLK,&lock) == 0;
 }
 
+static int exclude_server_path(char *arg)
+{
+	char *s;
+	extern struct exclude_struct **server_exclude_list;
+
+	if (server_exclude_list) {
+		for (s = arg; (s = strchr(s, '/')) != NULL; ) {
+			*s = '\0';
+			if (check_exclude(server_exclude_list, arg, 1)) {
+				/* We must leave arg truncated! */
+				return 1;
+			}
+			*s++ = '/';
+		}
+	}
+	return 0;
+}
 
 static void glob_expand_one(char *s, char **argv, int *argc, int maxargs)
 {
 #if !(defined(HAVE_GLOB) && defined(HAVE_GLOB_H))
 	if (!*s) s = ".";
-	argv[*argc] = strdup(s);
+	s = argv[*argc] = strdup(s);
+	exclude_server_path(s);
 	(*argc)++;
-	return;
 #else
 	extern int sanitize_paths;
 	glob_t globbuf;
 	int i;
 
 	if (!*s) s = ".";
 
-	argv[*argc] = strdup(s);
+	s = argv[*argc] = strdup(s);
 	if (sanitize_paths) {
-		sanitize_path(argv[*argc], NULL);
+		sanitize_path(s, NULL);
 	}
 
 	memset(&globbuf, 0, sizeof(globbuf));
-	glob(argv[*argc], 0, NULL, &globbuf);
+	if (!exclude_server_path(s))
+		glob(s, 0, NULL, &globbuf);
 	if (globbuf.gl_pathc == 0) {
 		(*argc)++;
 		globfree(&globbuf);
 		return;
 	}
 	for (i=0; i<(maxargs - (*argc)) && i < (int) globbuf.gl_pathc;i++) {
-		if (i == 0) free(argv[*argc]);
+		if (i == 0) free(s);
 		argv[(*argc) + i] = strdup(globbuf.gl_pathv[i]);
 		if (!argv[(*argc) + i]) out_of_memory("glob_expand");
 	}
 	globfree(&globbuf);
 	(*argc) += i;
 #endif
 }
 
+/* This routine is only used in daemon mode. */
 void glob_expand(char *base1, char **argv, int *argc, int maxargs)
 {
 	char *s = argv[*argc];
 	char *p, *q;
 	char *base = base1;
+	int base_len = strlen(base);
 
 	if (!s || !*s) return;
 
-	if (strncmp(s, base, strlen(base)) == 0) {
-		s += strlen(base);
-	}
+	if (strncmp(s, base, base_len) == 0)
+		s += base_len;
 
 	s = strdup(s);
 	if (!s) out_of_memory("glob_expand");
 
 	if (asprintf(&base," %s/", base1) <= 0) out_of_memory("glob_expand");
+	base_len++;
 
 	q = s;
 	while ((p = strstr(q,base)) && ((*argc) < maxargs)) {
 		/* split it at this point */
 		*p = 0;
 		glob_expand_one(q, argv, argc, maxargs);
-		q = p+strlen(base);
+		q = p + base_len;
 	}
 
 	if (*q && (*argc < maxargs)) glob_expand_one(q, argv, argc, maxargs);
 
 	free(s);
 	free(base);
@@ -638,13 +659,13 @@
 				;
 			}
 			continue;
 		}
 		allowdotdot = 0;
 		if ((*p == '.') && (*(p+1) == '.') &&
-			    ((*(p+2) == '/') || (*(p+2) == '\0'))) {
+		    ((*(p+2) == '/') || (*(p+2) == '\0'))) {
 			/* ".." component followed by slash or end */
 			if ((depth > 0) && (sanp == start)) {
 				/* allow depth levels of .. at the beginning */
 				--depth;
 				allowdotdot = 1;
 			} else {
@@ -689,13 +710,13 @@
 		*sanp++ = '.';
 	}
 	*sanp = '\0';
 }
 
 
-static char curr_dir[MAXPATHLEN];
+char curr_dir[MAXPATHLEN];
 
 /**
  * Like chdir() but can be reversed with pop_dir() if @p save is set.
  * It is also much faster as it remembers where we have been.
  **/
 char *push_dir(char *dir, int save)
@@ -715,13 +736,13 @@
 	if (save) {
 		ret = strdup(curr_dir);
 	}
 
 	if (*dir == '/') {
 		strlcpy(curr_dir, dir, sizeof(curr_dir));
-	} else {
+	} else if (dir[0] != '.' || dir[1] != '\0') {
 		strlcat(curr_dir,"/", sizeof(curr_dir));
 		strlcat(curr_dir,dir, sizeof(curr_dir));
 	}
 
 	clean_fname(curr_dir);
 
@@ -743,12 +764,58 @@
 
 	free(dir);
 
 	return 0;
 }
 
+/**
+ * Return a quoted string with the full pathname of the indicated filename.
+ * The string " (in MODNAME)" may also be appended.  The returned pointer
+ * remains valid until the next time full_fname() is called.
+ **/
+char *full_fname(char *fn)
+{
+	extern int module_id;
+	static char *result = NULL;
+	char *m1, *m2, *m3;
+	char *p1, *p2;
+
+	if (result)
+		free(result);
+
+	if (*fn == '/')
+		p1 = p2 = "";
+	else {
+		p1 = curr_dir;
+		p2 = "/";
+	}
+	if (module_id >= 0) {
+		m1 = " (in ";
+		m2 = lp_name(module_id);
+		m3 = ")";
+		if (*p1) {
+			if (!lp_use_chroot(module_id)) {
+				char *p = lp_path(module_id);
+				if (*p != '/' || p[1])
+					p1 += strlen(p);
+			}
+			if (!*p1)
+				p2++;
+			else
+				p1++;
+		}
+		else
+			fn++;
+	} else
+		m1 = m2 = m3 = "";
+
+	asprintf(&result, "\"%s%s%s\"%s%s%s", p1, p2, fn, m1, m2, m3);
+
+	return result;
+}
+
 /** We need to supply our own strcmp function for file list comparisons
    to ensure that signed/unsigned usage is consistent between machines. */
 int u_strcmp(const char *cs1, const char *cs2)
 {
 	const uchar *s1 = (const uchar *)cs1;
 	const uchar *s2 = (const uchar *)cs2;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0: wildtest.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0: wildtest.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/zlib/inftrees.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/zlib/inftrees.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.5.7/zlib/inftrees.c	2002-03-12 09:14:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/zlib/inftrees.c	2003-08-22 07:28:24.000000000 +0800
@@ -210,13 +210,13 @@
       {
         h++;
         w += l;                 /* previous table always l bits */
 
         /* compute minimum size table less than or equal to l bits */
         z = g - w;
-        z = z > (uInt)l ? l : z;        /* table size upper limit */
+        z = z > (uInt)l ? (uInt)l : z;  /* table size upper limit */
         if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
         {                       /* too few codes for k-w bit table */
           f -= a + 1;           /* deduct codes from patterns left */
           xp = c + k;
           if (j < z)
             while (++j < z)     /* try smaller tables up to z bits */
@@ -397,13 +397,13 @@
 
 int inflate_trees_fixed(bl, bd, tl, td, z)
 uIntf *bl;               /* literal desired/actual bit depth */
 uIntf *bd;               /* distance desired/actual bit depth */
 inflate_huft * FAR *tl;  /* literal/length tree result */
 inflate_huft * FAR *td;  /* distance tree result */
-z_streamp z;             /* for memory allocation */
+UNUSED(z_streamp z);     /* for memory allocation */
 {
 #ifdef BUILDFIXED
   /* build fixed tables if not already */
   if (!fixed_built)
   {
     int k;              /* temporary variable */
