char *smime_get_field_from_db (char *mailbox, char *query, short public, short may_ask)
{
  int addr_len, query_len, found = 0, ask = 0, choice = 0;
  char cert_path[_POSIX_PATH_MAX];
  char buf[LONG_STRING], prompt[STRING];
  char fields[5][STRING+1]; /* +1 due to use of fscanf() below. the max field width does not include the null terminator (see http://dev.mutt.org/trac/ticket/3636) */
  char key[STRING];  
  int numFields;
  struct stat info;
  char key_trust_level = 0;
  FILE *fp;

  if(!mailbox && !query) return(NULL);

  addr_len = mailbox ? mutt_strlen (mailbox) : 0;
  query_len = query ? mutt_strlen (query) : 0;
  
  *key = '\0';

  /* index-file format:
     mailbox certfile label issuer_certfile trust_flags\n

     certfile is a hash value generated by openssl.
     Note that this was done according to the OpenSSL
     specs on their CA-directory.

  */
  snprintf (cert_path, sizeof (cert_path), "%s/.index",
	    (public ? NONULL(SmimeCertificates) : NONULL(SmimeKeys)));

  if (!stat (cert_path, &info))
  {
    if ((fp = safe_fopen (cert_path, "r")) == NULL)
    {
      mutt_perror (cert_path);
      return (NULL);
    }

    while (fgets (buf, sizeof (buf) - 1, fp) != NULL)
      if (mailbox && !(mutt_strncasecmp (mailbox, buf, addr_len)))
      {
	numFields = sscanf (buf, 
			    MUTT_FORMAT(STRING) " " MUTT_FORMAT(STRING) " " 
			    MUTT_FORMAT(STRING) " " MUTT_FORMAT(STRING) " " 
			    MUTT_FORMAT(STRING) "\n", 
			    fields[0], fields[1],
			   fields[2], fields[3], 
			    fields[4]);
	if (numFields < 2)
	    continue;
	if (mailbox && public && 
	    (*fields[4] == 'i' || *fields[4] == 'e' || *fields[4] == 'r'))
	    continue;

	if (found)
	{
	  if (public && *fields[4] == 'u' )
	    snprintf (prompt, sizeof (prompt),
		      _("ID %s is unverified. Do you want to use it for %s ?"),
		      fields[1], mailbox);
	  else if (public && *fields[4] == 'v' )
	    snprintf (prompt, sizeof (prompt),
		      _("Use (untrusted!) ID %s for %s ?"),
		      fields[1], mailbox);
	  else
	    snprintf (prompt, sizeof (prompt), _("Use ID %s for %s ?"),
		      fields[1], mailbox);
	  if (may_ask == 0)
	    choice = M_YES;
	  if (may_ask && (choice = mutt_yesorno (prompt, M_NO)) == -1)
	  {
	    found = 0;
	    ask = 0;
	    *key = '\0';
	    break;
	  }
	  else if (choice == M_NO) 
	  {
	    ask = 1;
	    continue;
	  }
	  else if (choice == M_YES)
	  {
	    strfcpy (key, fields[1], sizeof (key));
	    ask = 0;
	    break;
	  }
	}
	else
	{
	  if (public) 
	    key_trust_level = *fields[4];
	  strfcpy (key, fields[1], sizeof (key));
	}
	found = 1;
      }
      else if(query)
      {
	numFields = sscanf (buf, 
			    MUTT_FORMAT(STRING) " " MUTT_FORMAT(STRING) " " 
			    MUTT_FORMAT(STRING) " " MUTT_FORMAT(STRING) " " 
			    MUTT_FORMAT(STRING) "\n", 
			    fields[0], fields[1],
			    fields[2], fields[3], 
			    fields[4]);

	/* query = label: return certificate. */
	if (numFields >= 3 && 
	    !(mutt_strncasecmp (query, fields[2], query_len)))
	{
	  ask = 0;
	  strfcpy (key, fields[1], sizeof (key));
	}
	/* query = certificate: return intermediate certificate. */
	else if (numFields >= 4 && 
		 !(mutt_strncasecmp (query, fields[1], query_len)))
	{
	  ask = 0;
	  strfcpy (key, fields[3], sizeof (key));
	}
      }

    safe_fclose (&fp);

    if (ask)
    {
      if (public && *fields[4] == 'u' )
	snprintf (prompt, sizeof (prompt),
		  _("ID %s is unverified. Do you want to use it for %s ?"),
		  fields[1], mailbox);
      else if (public && *fields[4] == 'v' )
	snprintf (prompt, sizeof (prompt),
		  _("Use (untrusted!) ID %s for %s ?"),
		  fields[1], mailbox);
      else
	snprintf (prompt, sizeof(prompt), _("Use ID %s for %s ?"), key,
		  mailbox);
      choice = mutt_yesorno (prompt, M_NO);
      if (choice == -1 || choice == M_NO)
	*key = '\0';
    }
    else if (key_trust_level && may_ask)
    {
      if (key_trust_level == 'u' )
      {
	snprintf (prompt, sizeof (prompt),
		  _("ID %s is unverified. Do you want to use it for %s ?"),
		  key, mailbox);
	choice = mutt_yesorno (prompt, M_NO);
	if (choice != M_YES)
	  *key = '\0';
      }
      else if (key_trust_level == 'v' )
      {
	mutt_error (_("Warning: You have not yet decided to trust ID %s. (any key to continue)"), key);
	mutt_sleep (5);
      }
    }

  }

  /* Note: safe_strdup ("") returns NULL. */
  return safe_strdup (key);
}