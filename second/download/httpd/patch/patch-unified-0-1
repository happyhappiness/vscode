diff -BEr -U 6 apache_1.3.0/ABOUT_APACHE apache_1.3.1/ABOUT_APACHE
--- apache_1.3.0/ABOUT_APACHE	1998-05-19 09:43:44.000000000 +0800
+++ apache_1.3.1/ABOUT_APACHE	1998-07-15 20:31:23.000000000 +0800
@@ -1,12 +1,12 @@
 
                      The Apache HTTP Server Project
 
                          http://www.apache.org/
 
-                               April 1998
+                               July 1998
 
 The Apache Project is a collaborative software development effort aimed
 at creating a robust, commercial-grade, featureful, and freely-available
 source code implementation of an HTTP (Web) server.  The project is
 jointly managed by a group of volunteers located around the world, using
 the Internet and the Web to communicate, plan, and develop the server and
@@ -64,20 +64,22 @@
 
 Less than a year after the group was formed, the Apache server passed
 NCSA's httpd as the #1 server on the Internet.
 
  ============================================================================
 
-Current Apache Group in alphabetical order as of 23 April 1998:
+Current Apache Group in alphabetical order as of 14 July 1998:
 
    Brian Behlendorf       Organic Online, California 
    Ken Coar               MeepZor Consulting, New England, USA 
    Mark J. Cox            C2Net Europe, UK 
+   Lars Eilebrecht        Kreuztal, Germany 
    Ralf S. Engelschall    Munich, Germany.
    Dean Gaudet            Transmeta Corporation, California 
    Rob Hartill            Internet Movie DB, UK 
+   Ben Hyde               Gensym, Massachusetts
    Jim Jagielski          jaguNET ISP, Maryland 
    Alexei Kosut           Stanford University, California 
    Martin Kraemer         Munich, Germany
    Ben Laurie             Freelance Consultant, UK 
    Doug MacEachern        Freelance Consultant, Summer Seasons, Earth
    Aram W. Mirzadeh       Qosina Corporation, New York 
@@ -101,26 +103,26 @@
    Rob McCool (original author of the NCSA httpd),
    Brandon Long and Beth Frank (NCSA Server Development Team, post-1.3),
    Paul Richards (convinced the group to use remote CVS after 1.0),
    Kevin Hughes (creator of all those nifty icons),
    Henry Spencer (author of the regex library), Garey Smiley (OS/2 port),
    Howard Fear (mod_include), Florent Guillaume (language negotiation), 
-   Ambarish Malpani (NT port), Ben Hyde (multi-platform build tests).
+   Ambarish Malpani (NT port).
 
 Many 3rd-party modules, frequently used and recommended, are also
 freely-available and linked from the related projects page:
 <http://modules.apache.org/>, and their authors frequently
 contribute ideas, patches, and testing.  In particular, Doug MacEachern
 (mod_perl) and Rasmus Lerdorf (mod_php).
 
 Hundreds of people have made individual contributions to the Apache
 project.  Patch contributors are listed in the src/CHANGES file.
-Frequent contributors have included Lars Eilebrecht, Petr Lampa, Tom Tromey,
-James H. Cloos Jr., Ed Korthof, Nathan Neulinger, Jason S. Clary,
-Jason A. Dour, Michael Douglass, Tony Sanders, Brian Tao, Michael Smith,
-Adam Sussman, Nathan Schrenk, Matthew Gray, and John Heidemann.
+Frequent contributors have included Petr Lampa, Tom Tromey, James H.
+Cloos Jr., Ed Korthof, Nathan Neulinger, Jason S. Clary, Jason A. Dour,
+Michael Douglass, Tony Sanders, Brian Tao, Michael Smith, Adam Sussman,
+Nathan Schrenk, Matthew Gray, and John Heidemann.
 
  ============================================================================
 
 How to become involved in the Apache project
 
 There are several levels of contributing.  If you just want to send
diff -BEr -U 6 apache_1.3.0/Announcement apache_1.3.1/Announcement
--- apache_1.3.0/Announcement	1998-06-02 06:18:42.000000000 +0800
+++ apache_1.3.1/Announcement	1998-07-19 06:50:14.000000000 +0800
@@ -1,22 +1,72 @@
+Apache 1.3.1 Released
+=====================
 
- Apache 1.3.0 Released
- =====================
+The Apache Group is pleased to announce the release of version 1.3.1 
+of the Apache HTTP server.  
 
- The Apache Group is pleased to announce the release of the long
- awaited 1.3.0 version of the Apache HTTP server.
+The changes in this release consist of UNIX portability fixes, Win32
+security issues, and assorted other minor features or fixes.  
 
- To grab the latest Apache distribution, check out
-     http://www.apache.org/dist/
- and the huge list of available "International Mirror Sites" at
-     http://www.apache.org/mirrors/
-
- For a full list of specific code changes see src/CHANGES.
-
- For an overview of new features in 1.3 please read the CHANGES file 
- in the distribution and the "New Features with Apache 1.3" document at
-     http://www.apache.org/docs/new_features_1_3.html
-
- In general, Apache 1.3.0 offers several substantial improvements
- over previous versions, including better performance, reliability
- and a wider-range of supported platforms, including Windows95 and
- NT.
+WE URGE ALL USERS RUNNING ANY PREVIOUS VERSION OF APACHE ON WIN32
+TO UPGRADE IMMEDIATELY.
+
+Users on other platforms should review the CHANGES file and decide
+on their upgrade plans; the security issues apply only to Apache
+on Win32.  We consider Apache 1.3.1 to be the most stable version
+of Apache available.
+
+Apache 1.3.1 is available for download from
+
+	http://www.apache.org/dist/
+
+Please see the CHANGES file in the same directory for a full list of 
+changes.  The distribution is also available via any of the mirrors
+listed at
+
+	http://www.apache.org/mirrors/
+
+For an overview of new features in 1.3 please see
+
+	http://www.apache.org/docs/new_features_1_3.html
+
+In general, Apache 1.3 offers several substantial improvements
+over version 1.2, including better performance, reliability
+and a wider-range of supported platforms, including Windows 95 and
+NT (which both fall under the "Win32" label).
+
+Apache is the most popular web-server in the known universe; over
+half of the servers on the Internet are running Apache or one of its
+variants.
+
+IMPORTANT NOTE FOR WIN32 USERS: Over the years, many users have
+come to trust Apache as a secure and stable server.  It must
+be realized that the current Win32 code has not yet reached these
+levels and should still be considered to be of beta quality.  Any
+Win32 stability or security problems do not impact, in any way,
+Apache on other platforms.  With the continued donation of time
+and resources by individuals and companies, we hope that the Win32
+version of Apache will grow stronger through the 1.3.x release
+cycle.
+
+Versions of Apache on Win32 prior to version 1.3.1 are vulnerable
+to a number of security holes common to several Win32 servers.
+The problems that impact Apache include:
+
+	- trailing "."s are ignored by the file system.  This allowed
+	  certain types of access restrictions to be bypassed.
+	- directory names of three or more dots (eg. "...") are
+    	  considered to be valid similar to "..".  This allowed people
+	  to gain access to files outside of the configured document
+	  trees.
+
+There have been at least four other similar instances of the same
+basic problem: on Win32, there is more than one name for a file.
+Some of these names are poorly documented or undocumented, and even
+Microsoft's own IIS has been vulnerable to many of these problems.
+This behavior of the Win32 file system and API makes it very difficult
+to insure future security; problems of this type have been known
+about for years, however each specific instance has been discovered
+individually.  It is unknown if there are other, yet unpublicized,
+filename variants.  As a result, we recommend that you use extreme
+caution when dealing with access restrictions on all Win32 web
+servers.
Only in apache_1.3.0/: CHANGES
Only in apache_1.3.0/: compile_commands.json
diff -BEr -U 6 apache_1.3.0/conf/access.conf-dist apache_1.3.1/conf/access.conf-dist
--- apache_1.3.0/conf/access.conf-dist	1998-05-29 09:27:49.000000000 +0800
+++ apache_1.3.1/conf/access.conf-dist	1998-06-07 03:46:59.000000000 +0800
@@ -11,13 +11,13 @@
 # Originally by Rob McCool
 
 # First, we configure the "default" to be a very restrictive set of 
 # permissions.  
 
 <Directory />
-Options None
+Options FollowSymLinks
 AllowOverride None
 </Directory>
 
 # Note that from this point forward you must specifically allow
 # particular features to be enabled - so if something's not working as
 # you might expect, make sure that you have specifically enabled it
diff -BEr -U 6 apache_1.3.0/conf/access.conf-dist-win apache_1.3.1/conf/access.conf-dist-win
--- apache_1.3.0/conf/access.conf-dist-win	1998-05-30 22:46:49.000000000 +0800
+++ apache_1.3.1/conf/access.conf-dist-win	1998-07-17 04:24:40.000000000 +0800
@@ -15,16 +15,17 @@
 
 # Originally by Rob McCool
 
 # First, we configure the "default" to be a very restrictive set of 
 # permissions.  
 
-<Directory />
-Options None
-AllowOverride None
-</Directory>
+# XXXX disabled because it is currently broken on Win32
+#<Directory />
+#Options FollowSymLinks
+#AllowOverride None
+#</Directory>
 
 # Note that from this point forward you must specifically allow
 # particular features to be enabled - so if something's not working as
 # you might expect, make sure that you have specifically enabled it
 # below.
 
@@ -53,13 +54,13 @@
 
 </Directory>
 
 # @@ServerRoot@@/cgi-bin should be changed to whatever your ScriptAliased
 # CGI directory exists, if you have that configured.
 
-<Directory @@ServerRoot@@/cgi-bin>
+<Directory "@@ServerRoot@@/cgi-bin">
 AllowOverride None
 Options None
 </Directory>
 
 # Allow server status reports, with the URL of http://servername/server-status
 # Change the ".your_domain.com" to match your domain to enable.
diff -BEr -U 6 apache_1.3.0/conf/httpd.conf-dist-win apache_1.3.1/conf/httpd.conf-dist-win
--- apache_1.3.0/conf/httpd.conf-dist-win	1998-05-30 22:46:49.000000000 +0800
+++ apache_1.3.1/conf/httpd.conf-dist-win	1998-07-17 04:24:40.000000000 +0800
@@ -44,17 +44,12 @@
 # had to knowingly turn this feature on.
 
 HostnameLookups off
 
 # If you wish httpd to run as a different user or group, you must run
 # httpd as root initially and it will switch.  
-
-# User/Group: The name (or #number) of the user/group to run httpd as.
-User nobody
-Group #-1
-
 # ServerAdmin: Your address, where problems with the server should be
 # e-mailed.
 
 ServerAdmin you@your.address
 
 # ServerRoot: The directory the server's config, error, and log files
@@ -181,13 +176,13 @@
 # enable the proxy server:
 
 #ProxyRequests On
 
 # To enable the cache as well, edit and uncomment the following lines:
 
-#CacheRoot @@ServerRoot@@/proxy
+#CacheRoot "@@ServerRoot@@/proxy"
 #CacheSize 5
 #CacheGcInterval 4
 #CacheMaxExpire 24
 #CacheLastModifiedFactor 0.1
 #CacheDefaultExpire 1
 #NoCache a_domain.com another_domain.edu joes.garage_sale.com
diff -BEr -U 6 apache_1.3.0/conf/magic apache_1.3.1/conf/magic
--- apache_1.3.0/conf/magic	1997-07-08 02:18:36.000000000 +0800
+++ apache_1.3.1/conf/magic	1998-07-18 19:35:53.000000000 +0800
@@ -167,13 +167,16 @@
 0	string		\<Maker		application/x-frame
 
 #------------------------------------------------------------------------------
 # html:  file(1) magic for HTML (HyperText Markup Language) docs
 #
 # from Daniel Quinlan <quinlan@yggdrasil.com>
+# and Anna Shergold <anna@inext.co.uk>
 #
+0	string		\<!DOCTYPE\ HTML	text/html
+0	string		\<!doctype\ html	text/html
 0	string		\<HEAD		text/html
 0	string		\<head		text/html
 0	string		\<TITLE		text/html
 0	string		\<title		text/html
 0       string          \<html          text/html
 0       string          \<HTML          text/html
@@ -282,15 +285,18 @@
 #
 # Contributor claims:
 # Reversed-engineered MS Word magic numbers
 #
 
 0	string		\376\067\0\043			application/msword
-0	string		\320\317\021\340\241\261	application/msword
 0	string		\333\245-\0\0\0			application/msword
 
+# disable this one because it applies also to other
+# Office/OLE documents for which msword is not correct. See PR#2608.
+#0	string		\320\317\021\340\241\261	application/msword
+
 
 
 #------------------------------------------------------------------------------
 # printer:  file(1) magic for printer-formatted files
 #
 
diff -BEr -U 6 apache_1.3.0/conf/srm.conf-dist apache_1.3.1/conf/srm.conf-dist
--- apache_1.3.0/conf/srm.conf-dist	1998-05-22 02:01:58.000000000 +0800
+++ apache_1.3.1/conf/srm.conf-dist	1998-07-15 22:50:28.000000000 +0800
@@ -88,12 +88,17 @@
 
 # AccessFileName: The name of the file to look for in each directory
 # for access control information.
 
 AccessFileName .htaccess
 
+# TypesConfig describes where the mime.types file (or equivalent) is
+# to be found.
+
+TypesConfig conf/mime.types
+
 # DefaultType is the default MIME type for documents which the server
 # cannot find the type of from filename extensions.
 
 DefaultType text/plain
 
 # AddEncoding allows you to have certain browsers (Mosaic/X 2.1+) uncompress
diff -BEr -U 6 apache_1.3.0/conf/srm.conf-dist-win apache_1.3.1/conf/srm.conf-dist-win
--- apache_1.3.0/conf/srm.conf-dist-win	1998-05-30 22:46:49.000000000 +0800
+++ apache_1.3.1/conf/srm.conf-dist-win	1998-07-15 22:50:28.000000000 +0800
@@ -96,12 +96,17 @@
 
 # AccessFileName: The name of the file to look for in each directory
 # for access control information.
 
 AccessFileName .htaccess
 
+# TypesConfig describes where the mime.types file (or equivalent) is
+# to be found.
+
+TypesConfig conf/mime.types
+
 # DefaultType is the default MIME type for documents which the server
 # cannot find the type of from filename extensions.
 
 DefaultType text/plain
 
 # AddEncoding allows you to have certain browsers (Mosaic/X 2.1+) uncompress
@@ -140,18 +145,18 @@
 # Alias fakename realname
 
 # Note that if you include a trailing / on fakename then the server will
 # require it to be present in the URL.  So "/icons" isn't aliased in this
 # example.
 
-Alias /icons/ @@ServerRoot@@/icons/
+Alias /icons/ "@@ServerRoot@@/icons/"
 
 # ScriptAlias: This controls which directories contain server scripts.
 # Format: ScriptAlias fakename realname
 
-#ScriptAlias /cgi-bin/ @@ServerRoot@@/cgi-bin/
+#ScriptAlias /cgi-bin/ "@@ServerRoot@@/cgi-bin/"
 
 # If you want to use server side includes, or CGI outside
 # ScriptAliased directories, uncomment the following lines.
 
 # AddType allows you to tweak mime.types without actually editing it, or to
 # make certain files to be certain types.
diff -BEr -U 6 apache_1.3.0/configure apache_1.3.1/configure
--- apache_1.3.0/configure	1998-05-30 04:45:52.000000000 +0800
+++ apache_1.3.1/configure	1998-07-12 17:25:46.000000000 +0800
@@ -72,12 +72,13 @@
 top=.
 mkf=Makefile
 src=src
 aux=src/helpers
 sedsubst=src/.apaci.sedsubst
 addconf=src/.apaci.addconf
+configstatus=config.status
 
 ##
 ##  pre-determine runtime modes
 ##
 
 quiet=no
@@ -110,53 +111,32 @@
     echo " + Please read the README.configure and INSTALL files"
     echo " + first or at least run '$0 --help' for"
     echo " + a compact summary of available options."
 fi
 
 ##
-##  determine optional Perl interpreter
+##  determine path to (optional) Perl interpreter
 ##
 
 PERL=no-perl-on-this-system
-OIFS="$IFS" IFS=':'
-for dir in $PATH; do
-    OIFS2="$IFS" IFS="$DIFS"
-    for exe in perl5 perl miniperl; do
-        if [ -f "$dir/$exe" ]; then
-            if [ -x "$dir/$exe" ]; then
-                PERL="$dir/$exe"
-                break 2
-            fi
-        fi
-    done
-    IFS="$OIFS2"
-done
-IFS="$OIFS"
-PERL="`echo $PERL | sed -e 's://:/:'`"
+perlpath="`$aux/findprg.sh perl5 perl miniperl`"
+if [ ".$perlpath" != . ]; then
+    PERL="$perlpath"
+fi
 
 ##
 ##  look for the best Awk we can find because some
 ##  standard Awks are really braindead and cause 
 ##  problems for our scripts under some platforms.
 ##
 
 AWK=awk
-OIFS="$IFS" IFS=':'
-for dir in $PATH; do
-    OIFS2="$IFS" IFS="$DIFS"
-    if [ -x "$dir/nawk" ]; then
-        AWK="$dir/nawk"
-        break 2
-    fi
-    if [ -x "$dir/gawk" ]; then
-        AWK="$dir/gawk"
-        break 2
-    fi
-    IFS="$OIFS2"
-done
-IFS="$OIFS"
+awkpath="`$aux/findprg.sh nawk gawk awk`"
+if [ ".$awkpath" != . ]; then
+    AWK="$awkpath"
+fi
 
 ##
 ##  determine default parameters
 ##
 
 #   default paths
@@ -193,12 +173,15 @@
 suexec_gidmin=100
 suexec_safepath="/usr/local/bin:/usr/bin:/bin"
 
 #   with support tools
 support=1
 
+#   with adjustments
+confadjust=1
+
 #   determine rules
 rules=""
 rulelist=""
 OIFS="$IFS" IFS='
 '
 for rule in `grep '^Rule' $src/Configuration.tmpl`; do
@@ -246,22 +229,59 @@
 modules=`echo $modules | sed -e 's/^://'`
 
 #   backward compatibility from old src/Configuration.tmpl
 #   parameter names to the canonical Autoconf-style shell
 #   variable names.
 OIFS="$IFS" IFS="$DIFS"
-for var in CFLAGS LDFLAGS LIBS INCLUDES; do
+for var in CFLAGS LDFLAGS LIBS INCLUDES DEPS; do
     eval "val=\$EXTRA_$var"
     if [ ".$val" != . ]; then
         eval "$var=\$val"
         eval "EXTRA_$var=\"\"; export EXTRA_$var"
         echo " + Hint: please use $var instead of EXTRA_$var next time"
     fi
 done
 IFS="$OIFS"
 
+#   create a config status script for restoring
+#   the configuration via a simple shell script
+rm -f $configstatus 2>/dev/null
+echo "#!/bin/sh" >$configstatus
+echo "##" >>$configstatus
+echo "##  $configstatus -- APACI auto-generated configuration restore script" >>$configstatus
+echo "##" >>$configstatus
+echo "##  Use this shell script to re-run the APACI configure script for" >>$configstatus
+echo "##  restoring your configuration. Additional parameters can be supplied." >>$configstatus
+echo "##" >>$configstatus
+echo "" >>$configstatus
+for var in CC OPTIM CFLAGS CFLAGS_SHLIB LDFLAGS LD_SHLIB LDFLAGS_SHLIB \
+           LDFLAGS_SHLIB_EXPORT LIBS INCLUDES RANLIB; do
+    eval "val=\"\$$var\""
+    if [ ".$val" != . ]; then
+        echo "$var=$val" |\
+        sed -e 's:\(["$\\]\):\\\1:g' \
+            -e 's:\([A-Z]*=\):\1":' \
+            -e 's:$:" \\:' >>$configstatus
+    fi
+done
+if [ $# -eq 0 ]; then
+    echo "./configure" >>$configstatus
+else
+    echo "./configure \\" >>$configstatus
+    for arg
+    do
+        echo "$arg" |\
+        sed -e 's:\(["$\\]\):\\\1:g' \
+            -e 's:^:":' \
+            -e 's:$:" \\:' >>$configstatus
+    done
+fi
+echo '$*' >>$configstatus
+echo '' >>$configstatus
+chmod a+x $configstatus
+
 ##
 ##  parse argument line options
 ##
 
 apc_prev=""
 OIFS1="$IFS" IFS="$DIFS"
@@ -296,13 +316,13 @@
                     echo " + creating Makefile (shadow wrapper)"
                 fi
                 echo "##" > Makefile
                 echo "##  Apache Makefile (shadow wrapper)" >> Makefile
                 echo "##" >> Makefile
                 echo "" >> Makefile
-                echo "GNUTRIPLE=\`$aux/GuessOS | $AWK '{ printf(\"%s\",\$\$1); }' | sed -e 's:/:-:g'\`" >> Makefile
+                echo "GNUTRIPLE=\`$aux/GuessOS | sed -e 's:/:-:g' | $AWK '{ printf(\"%s\",\$\$1); }'\`" >> Makefile
                 echo "" >> Makefile
                 echo "all build install install-quiet clean distclean:" >> Makefile
                 echo "	@\$(MAKE) -f Makefile.\$(GNUTRIPLE) \$(MFLAGS) \$@" >> Makefile
                 echo "" >> Makefile
             fi
             #   set shadow paths
@@ -365,12 +385,13 @@
             echo " --disable-module=NAME  disable a particular Module named 'NAME'"
             $aux/ppl.sh $modulelist
             echo " --enable-shared=NAME   enable  build of Module named 'NAME' as a shared object"
             echo " --disable-shared=NAME  disable build of Module named 'NAME' as a shared object"
             echo " --with-perl=FILE       set the path to the optional Perl interpreter to use"
             echo " --without-support      disable the build and installation of support tools"
+            echo " --without-confadjust   disable some build user/situation adjustments to config files"
             echo ""
             echo "suEXEC options:"
             echo " --enable-suexec        enable the suEXEC feature"
             echo " --suexec-caller=NAME   set the suEXEC username of the allowed caller [$suexec_caller]"
             echo " --suexec-userdir=DIR   set the suEXEC user subdirectory [$suexec_userdir]"
             echo " --suexec-uidmin=UID    set the suEXEC minimal allowed UID [$suexec_uidmin]"
@@ -649,12 +670,15 @@
         --with-perl=*)
             PERL="$apc_optarg"
             ;;
         --without-support)
             support=0
             ;;
+        --without-confadjust)
+            confadjust=0
+            ;;
         --suexec-caller=*)
             suexec_caller="$apc_optarg"
             suexec_ok=1
             ;;
         --suexec-userdir=*)
             suexec_userdir="$apc_optarg"
@@ -724,13 +748,13 @@
            includedir localstatedir runtimedir \
            logfiledir proxycachedir; do
     eval "val=\"\$$var\"";
     val=`echo $val | sed -e 's:/*$::'`
     eval "$var=\"$val\""
     case $var in
-       sysconfdir|datadir|localstatedir|includedir ) 
+       libexecdir|sysconfdir|datadir|localstatedir|includedir ) 
            eval "val=\$$var"
            case $val in
                *apache | *apache* ) ;;
                * ) eval "customized=\$customized_$var"
                    if [ ".$customized" = .0 ]; then
                        eval "$var=\"\$$var/apache\""
@@ -755,12 +779,67 @@
     install_support=
       clean_support=
   distclean_support=
 fi
 
 ##
+##  determine special configuration parameters
+##
+conf_group="#-1"
+conf_port="80"
+conf_serveradmin="you@your.address"
+conf_servername="new.host.name"
+if [ ".$confadjust" = .1 ]; then
+    if [ ".`egrep '^nobody:' /etc/group`" != . ]; then
+        conf_group="nobody"
+        if [ ".`egrep '^nogroup:' /etc/group`" != . ]; then
+            conf_group="nogroup"
+        fi
+    fi
+    if [ ".`id | grep root`" = . ]; then
+        conf_port="8080"
+    fi
+    username="$LOGNAME"
+    if [ ".$username" = . ]; then
+        username="$USER"
+        if [ ".$username" = . ]; then
+            username="`whoami 2>/dev/null | sed -e 's/\n$//'`"
+            if [ ".$username" = . ]; then
+                username="`who am i 2>/dev/null | cut '-d ' -f1`"
+                if [ ".$username" = . ]; then
+                    username="unknown"
+                fi
+            fi
+        fi
+    fi
+    hostname="`uname -n | sed -e 's/\n$//'`"
+    if [ ".$hostname" = . ]; then
+        hostname="`hostname | sed -e 's/\n$//'`"
+        if [ ".$hostname" = . ]; then
+            hostname="hostname"
+        fi
+    fi
+    hostname="`echo $hostname | sed -e 's/\..*//'`"
+    domainname="";
+    if [ -f /etc/resolv.conf ]; then
+        domainname="`egrep '^[ 	]*domain' /etc/resolv.conf |\
+                     sed -e 's/.*domain//' -e 's/^[ 	]*//' \
+                         -e 's/^ *//' -e 's/^	*//' \
+                         -e 's/^\.//' -e 's/^/./'`"
+        if [ ".$domainname" = . ]; then
+            domainname="`egrep '^[ 	]*search' /etc/resolv.conf |\
+                         sed -e 's/.*search//' -e 's/^[ 	]*//' \
+                             -e 's/^ *//' -e 's/^	*//' \
+                             -e 's/ .*//' -e 's/^\.//' -e 's/^/./'`"
+        fi
+    fi
+    conf_serveradmin="$username@$hostname$domainname"
+    conf_servername="$hostname$domainname"
+fi
+ 
+##
 ##  determine prefix-relative paths for directories
 ##  because Apache supports them for the -d and -f 
 ##  options, the LoadModule directive, etc.
 ##
 ##  [we have to make sure that it ends with a slash
 ##   or we cannot support the case where the relative
@@ -837,12 +916,16 @@
 -e "s%@suexec@%$suexec%g" \
 -e "s%@suexec_caller@%$suexec_caller%g" \
 -e "s%@suexec_userdir@%$suexec_userdir%g" \
 -e "s%@suexec_uidmin@%$suexec_uidmin%g" \
 -e "s%@suexec_gidmin@%$suexec_gidmin%g" \
 -e "s%@suexec_safepath@%$suexec_safepath%g" \
+-e "s%@conf_group@%$conf_group%g" \
+-e "s%@conf_port@%$conf_port%g" \
+-e "s%@conf_serveradmin@%$conf_serveradmin%g" \
+-e "s%@conf_servername@%$conf_servername%g" \
 -e "s%@build_support@%$build_support%g" \
 -e "s%@install_support@%$install_support%g" \
 -e "s%@clean_support@%$clean_support%g" \
 -e "s%@distclean_support@%$distclean_support%g"
 
 ##
@@ -877,17 +960,17 @@
 rm -f $sedsubst 2>/dev/null
 touch $sedsubst
 
 #   generate settings from imported environment variables
 OIFS="$IFS" IFS="$DIFS"
 for var in CC OPTIM CFLAGS CFLAGS_SHLIB LDFLAGS LD_SHLIB LDFLAGS_SHLIB \
-           LDFLAGS_SHLIB_EXPORT LIBS INCLUDES RANLIB; do
+           LDFLAGS_SHLIB_EXPORT LIBS INCLUDES RANLIB DEPS; do
     eval "val=\"\$$var\"";
     if [ ".$val" != . ]; then
         case $var in 
-            CFLAGS|LDFLAGS|LIBS|INCLUDES) 
+            CFLAGS|LDFLAGS|LIBS|INCLUDES|DEPS) 
                 echo "s%^#*\\(EXTRA_$var=\\).*%\\1$val%g" >>$sedsubst
                 ;;
             *)
                 echo "s%^#*\\($var=\\).*%\\1$val%g" >>$sedsubst
                 ;;
         esac
diff -BEr -U 6 apache_1.3.0/htdocs/manual/dso.html apache_1.3.1/htdocs/manual/dso.html
--- apache_1.3.0/htdocs/manual/dso.html	1998-06-02 06:30:13.000000000 +0800
+++ apache_1.3.1/htdocs/manual/dso.html	1998-07-19 07:04:21.000000000 +0800
@@ -187,12 +187,13 @@
 o  Solaris            (2.4, 2.5.1, 2.6)
 o  SunOS              (4.1.3)
 o  OSF1               (4.0)
 o  IRIX               (6.2)
 o  HP/UX              (10.20)
 o  UnixWare           (2.01, 2.1.2)
+o  SCO                (5.0.4)
 o  AIX                (3.2, 4.1.5, 4.2, 4.3)
 o  ReliantUNIX/SINIX  (5.43)
 o  SVR4               (-)
 </PRE>
 
 <P>
diff -BEr -U 6 apache_1.3.0/htdocs/manual/misc/compat_notes.html apache_1.3.1/htdocs/manual/misc/compat_notes.html
--- apache_1.3.0/htdocs/manual/misc/compat_notes.html	1998-06-02 06:30:22.000000000 +0800
+++ apache_1.3.1/htdocs/manual/misc/compat_notes.html	1998-07-19 07:04:31.000000000 +0800
@@ -1,9 +1,11 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<HTML><HEAD>
-<TITLE>Apache HTTP Server: Compatibility Notes with NCSA's Server</TITLE>
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
+ "http://www.w3.org/TR/REC-html40/loose.dtd">
+<HTML>
+<HEAD>
+<TITLE>Apache HTTP Server: Notes about Compatibility with NCSA's Server</TITLE>
 </HEAD>
 <!-- Background white, links blue (unvisited), navy (visited), red (active) -->
 <BODY
  BGCOLOR="#FFFFFF"
  TEXT="#000000"
  LINK="#0000FF"
@@ -30,12 +32,20 @@
 HREF="http://www.apache.org/bug_report.html">let us know.</A>
 
 <P>Please also check the <A HREF="known_client_problems.html">known
 client problems</A> page.
 
 <OL>
+<LI>As of Apache 1.3.1, methods named in a
+    <A HREF="../mod/core.html#limit"><SAMP>&lt;Limit&gt;</SAMP></A>
+    section <EM>must</EM> be listed in upper-case.  Lower- or mixed-case
+    method names will result in a configuration error.
+    <P>
+    </P>
+</LI>
+
 <LI>The basic mod_auth <CODE>AuthGroupFile</CODE>-specified group file
     format allows commas between user names - Apache does not.
 
 <P>
 <LI>If you follow the NCSA guidelines for setting up access
     restrictions based on client domain, you may well have added
diff -BEr -U 6 apache_1.3.0/htdocs/manual/misc/custom_errordocs.html apache_1.3.1/htdocs/manual/misc/custom_errordocs.html
--- apache_1.3.0/htdocs/manual/misc/custom_errordocs.html	1998-06-02 06:30:22.000000000 +0800
+++ apache_1.3.1/htdocs/manual/misc/custom_errordocs.html	1998-07-19 07:04:31.000000000 +0800
@@ -28,12 +28,13 @@
  <LI><A HREF="#intro">Introduction</A>
  <LI><A HREF="#createdir">Creating an ErrorDocument directory</A>
  <LI><A HREF="#docnames">Naming the individual error document files</A>
  <LI><A HREF="#headfoot">The common header and footer files</A>
  <LI><A HREF="#createdocs">Creating ErrorDocuments in different languages</A>
  <LI><A HREF="#fallback">The fallback language</A>
+ <LI><A HREF="#proxy">Customizing Proxy Error Messages</A>
  <LI><A HREF="#listings">HTML listing of the discussed example</A>
 </UL>
 <HR>
 <H2><A NAME="intro">Introduction</A></H2>
 This document describes an easy way to provide your apache WWW server
 with a set of customized error messages which take advantage of
@@ -133,17 +134,17 @@
      (i.e., a plain error message in english).
  <LI>Finally, the <A HREF="../mod/core.html#allowoverride">AllowOverride</A>
      directive tells apache that it is not necessary to look for 
      a .htaccess file in the /errordocs directory: a minor speed 
      optimization.
 </OL>
-The resulting <SAMP>httpd.conf</SAMP> configuration would the look
-similar to this: <SMALL>(Note that you can defrine your own error
+The resulting <SAMP>httpd.conf</SAMP> configuration would then look
+similar to this: <SMALL>(Note that you can define your own error
 messages using this method for only part of the document tree,
 e.g., a /~user/ subtree. In this case, the configuration could as well
-be put into the .htaccess file at the root of the subtree. In this case,
+be put into the .htaccess file at the root of the subtree, and
 the &lt;Directory&gt; and &lt;/Directory&gt; directives -but not
 the contained directives- must be omitted.)</SMALL>
 <PRE>
   LanguagePriority en fr de 
   Alias  /errordocs  /usr/local/apache/errordocs
   &lt;Directory /usr/local/apache/errordocs&gt;
@@ -180,16 +181,16 @@
 (I'm using 403 as an example, think of it as a placeholder for any of
 the configured error documents):
 <UL>
  <LI>No file errordocs/403 should exist. Otherwise, it would be found and
      served (with the DefaultType, usually text/plain), all negotiation
      would be bypassed.
- <LI>For each language for which we have a translation (note that this need not
-     be the same set of languages for each error code - you can get by
-     with a single language version until you actually <EM>have</EM>
-     translated versions), a document
+ <LI>For each language for which we have an internationalized version
+     (note that this need not be the same set of languages for each
+     error code - you can get by with a single language version until
+     you actually <EM>have</EM> translated versions), a document
      <SAMP>errordocs/403.shtml.<EM>lang</EM></SAMP> is created and
      filled with the error text in that language (<A HREF="#createdocs">see
      below</A>).
  <LI>One fallback document called <SAMP>errordocs/403.shtml</SAMP> is
      created, usually by creating a symlink to the default language
      variant (<A HREF="#fallback">see below</A>).
@@ -225,13 +226,13 @@
 <STRONG>Example:</STRONG> for English, French and German versions
 (default english)<BR>
 <CODE>foot.shtml.en</CODE>,<BR>
 <CODE>foot.shtml.fr</CODE>,<BR>
 <CODE>foot.shtml.de</CODE>,<BR>
 <CODE>foot.shtml</CODE> symlink to <CODE>foot.shtml.en</CODE><P>
-Both files are then simply included into the error document by using the
+Both files are included into the error document by using the
 directives <CODE>&lt;!--#include virtual="head" --&gt;</CODE>
 and        <CODE>&lt;!--#include virtual="foot" --&gt;</CODE>
 respectively: the rest of the magic occurs in mod_negotiation and
 in mod_include.
 <P>
 
@@ -284,12 +285,51 @@
   done
 </PRE>
 
 <P>
 </P>
 
+<H2><A NAME="proxy">Customizing Proxy Error Messages</A></H2>
+
+<P>
+ As of Apache-1.3, it is possible to use the <CODE>ErrorDocument</CODE>
+ mechanism for proxy error messages as well (previous versions always
+ returned fixed predefined error messages).
+</P>
+<P>
+ Most proxy errors return an error code of [500 Internal Server Error].
+ To find out whether a particular error document was invoked on behalf
+ of a proxy error or because of some other server error, and what the reason
+ for the failure was, you can check the contents of the new
+ <CODE>ERROR_NOTES</CODE> CGI environment variable:
+ if invoked for a proxy error, this variable will contain the actual proxy
+ error message text in HTML form.
+</P>
+<P>
+ The following excerpt demonstrates how to exploit the <CODE>ERROR_NOTES</CODE>
+ variable within an error document:
+</P>
+<PRE>
+ &lt;!--#if expr="\"$REDIRECT_ERROR_NOTES\" = \"\"" --&gt;
+  &lt;p&gt;
+   The server encountered an unexpected condition
+   which prevented it from fulfilling the request. 
+  &lt;/p&gt;
+  &lt;p&gt;
+   &lt;A HREF="mailto:&lt;!--#echo var="SERVER_ADMIN" --&gt;"
+    SUBJECT="Error message [&lt;!--#echo var="REDIRECT_STATUS" --&gt;] &lt;!--#echo var="title" --&gt; for &lt;!--#echo var="REQUEST_URI" --&gt;"&gt;
+   Please forward this error screen to &lt;!--#echo var="SERVER_NAME" --&gt;'s
+   WebMaster&lt;/A&gt;; it includes useful debugging information about
+   the Request which caused the error.
+   &lt;pre&gt;&lt;!--#printenv --&gt;&lt;/pre&gt;
+  &lt;/p&gt;
+ &lt;!--#else --&gt;
+  &lt;!--#echo var="REDIRECT_ERROR_NOTES" --&gt;
+ &lt;!--#endif --&gt;
+</PRE>
+
 <H2><A NAME="listings">HTML listing of the discussed example</A></H2>
 
 So, to summarize our example, here's the complete listing of the
 <SAMP>400.shtml.en</SAMP> document. You will notice that it contains
 almost nothing but the error text (with conditional additions).
 Starting with this example, you will find it easy to add more error
@@ -386,15 +426,20 @@
 </PRE><HR>
 
 
 <H3>More welcome!</H3>
 
 If you have tips to contribute, send mail to <A
-HREF="mailto:Martin.Kraemer@Mch.SNI.De">Martin.Kraemer@Mch.SNI.De</A>
+HREF="mailto:martin@apache.org">martin@apache.org</A>
 
-<HR>
+  <HR>
+
+<H3 ALIGN="CENTER">
+ Apache HTTP Server Version 1.3
+</H3>
 
 <A HREF="./"><IMG SRC="../images/index.gif" ALT="Index"></A>
 <A HREF="../"><IMG SRC="../images/home.gif" ALT="Home"></A>
 
-</BODY></HTML>
+</BODY>
+</HTML>
 
diff -BEr -U 6 apache_1.3.0/htdocs/manual/misc/FAQ.html apache_1.3.1/htdocs/manual/misc/FAQ.html
--- apache_1.3.0/htdocs/manual/misc/FAQ.html	1998-06-02 06:30:21.000000000 +0800
+++ apache_1.3.1/htdocs/manual/misc/FAQ.html	1998-07-19 07:04:31.000000000 +0800
@@ -17,13 +17,13 @@
   Apache HTTP Server Version 1.3
  </H3>
 </DIV>
 
   <H1 ALIGN="CENTER">Apache Server Frequently Asked Questions</H1>
   <P>
-  $Revision: 1.118 $ ($Date: 1998/05/30 01:27:25 $)
+  $Revision: 1.123 $ ($Date: 1998/07/10 00:25:35 $)
   </P>
   <P>
   The latest version of this FAQ is always available from the main
   Apache web site, at
   &lt;<A
        HREF="http://www.apache.org/docs/misc/FAQ.html"
@@ -263,13 +263,13 @@
    </LI>
    <LI><A HREF="#cgi-spec">Where can I find the &quot;CGI
         specification&quot;?</A>
    </LI>
    <LI><A HREF="#year2000">Is Apache Year 2000 compliant?</A>
    </LI>
-   <LI><A HREF="#namevhost">I upgraded to Apache 1.3b and now my
+   <LI><A HREF="#namevhost">I upgraded to Apache 1.3.0 and now my
         virtual hosts don't work!</A>
    </LI>
    <LI><A HREF="#redhat">I'm using RedHat Linux and I have problems with httpd
         dying randomly or not restarting properly</A>
    </LI>
    <LI><A HREF="#stopping">I upgraded from an Apache version earlier
@@ -403,13 +403,13 @@
 
  <LI><A NAME="future">
       <STRONG>What are the future plans for Apache?</STRONG>
      </A>
   <P>
   <UL>
-   <LI>to continue as a public domain HTTP server,
+   <LI>to continue to be an "open source" no-charge-for-use HTTP server,
    </LI>
    <LI>to keep up with advances in HTTP protocol and web developments in
     general,
    </LI>
    <LI>to collect suggestions for fixes/improvements from its users,
    </LI>
@@ -912,12 +912,24 @@
    <LI>Increase the number of file descriptors available to the server
     (see your system's documentation on the <CODE>limit</CODE> or
     <CODE>ulimit</CODE> commands).  For some systems, information on
     how to do this is available in the
     <A HREF="perf.html">performance hints</A> page.  There is a specific
     note for <A HREF="#freebsd-setsize">FreeBSD</A> below.
+    <P>
+    For Windows 95, try modifying your <SAMP>C:\CONFIG.SYS</SAMP> file to
+    include a line like
+    </P>
+    <DL>
+     <DD><CODE>FILES=300</CODE>
+     </DD>
+    </DL>
+    <P>
+    Remember that you'll need to reboot your Windows 95 system in order
+    for the new value to take effect.
+    </P>
    </LI>
    <LI>&quot;Don't do that&quot; - try to run with fewer virtual hosts
    </LI>
    <LI>Spread your operation across multiple server processes (using
     <A HREF="../mod/core.html#listen"><SAMP>Listen</SAMP></A>
     for example, but see the first point) and/or ports.
@@ -1094,25 +1106,21 @@
  <LI><A NAME="cookies1">
       <STRONG>Why does Apache send a cookie on every response?</STRONG>
      </A>
   <P>
   Apache does <EM>not</EM> send automatically send a cookie on every
   response, unless you have re-compiled it with the
-  <A HREF="../mod/mod_cookies.html"><SAMP>mod_cookies</SAMP></A>
-  module.
-  This module was distributed with Apache prior to 1.2.
-  This module may help track users, and uses cookies to do this. If
-  you are not using the data generated by <SAMP>mod_cookies</SAMP>, do
-  not compile it into Apache. Note that in 1.2 this module was renamed
-  to the more correct name
-  <A HREF="../mod/mod_usertrack.html"><SAMP>mod_usertrack</SAMP></A>,
-  and cookies
-  have to be specifically enabled with the
+  <A HREF="../mod/mod_usertrack.html"><SAMP>mod_usertrack</SAMP></A>
+  module, and specifically enabled it with the
   <A HREF="../mod/mod_usertrack.html#cookietracking"
   ><SAMP>CookieTracking</SAMP></A>
   directive.
+  This module has been in Apache since version 1.2.
+  This module may help track users, and uses cookies to do this. If
+  you are not using the data generated by <SAMP>mod_usertrack</SAMP>, do
+  not compile it into Apache. 
   </P>
   <HR>
  </LI>
 
  <LI><A NAME="cookies2">
       <STRONG>Why don't my cookies work, I even compiled in
@@ -1248,65 +1256,22 @@
 
  <LI><A NAME="nph-scripts">
       <STRONG>How can I get my script's output without Apache buffering
       it?  Why doesn't my server push work?</STRONG>
      </A>
   <P>
-  In order to improve network performance, Apache buffers script output
-  into relatively large chunks.  If you have a script that sends
-  information in bursts (eg. as partial-done messages in a multi-commit
-  database transaction or any type of server push), the client will 
-  not necessarily get the output as the script is generating it.
-  </P>
-  <P>
-  To avoid this, Apache recognizes scripts whose names begin with
-  &quot;<SAMP>nph-</SAMP>&quot; as <EM>non-parsed-header</EM> scripts.
-  That is, Apache won't buffer their output, but connect it directly to
-  the socket going back to the client.
-  </P>
-  <P>
-  While this will probably do what you want, there <EM>are</EM> some
-  disadvantages to it:
-  </P>
-  <UL>
-   <LI><STRONG>YOU</STRONG> (the script) are responsible for generating
-     <STRONG>ALL</STRONG> of the HTTP headers, and no longer
-     <EM>just</EM> the &quot;<SAMP>Content-type</SAMP>&quot; or
-     &quot;<SAMP>Location</SAMP>&quot; headers
-   </LI>
-   <LI>Unless your script generates its output carefully, you will see a
-    performance penalty as excessive numbers of packets go back and forth
-   </LI>
-  </UL>
-  <P>
-  As an example how you might handle the former (in a Perl script):
-  </P>
-  <P>
-  <DL>
-   <DD><CODE>if ($0 =~ m:^(.*/)*nph-[^/]*$:) {
-    <BR>
-    &nbsp;&nbsp;&nbsp;&nbsp;
-    $HTTP_headers&nbsp;=&nbsp;
-    &quot;HTTP/1.1&nbsp;200&nbsp;OK\015\012&quot;;
-    <BR>
-    &nbsp;&nbsp;&nbsp;&nbsp;
-    $HTTP_headers&nbsp;.=&nbsp;
-    &quot;Connection:&nbsp;close\015\012&quot;;
-    <BR>
-    &nbsp;&nbsp;&nbsp;&nbsp;
-    print&nbsp;$HTTP_headers;
-    <BR>
-    }</CODE>
-   </DD>
-  </DL>
-  </P>
-  <P>
-  and then follow with your normal non-<SAMP>nph</SAMP> headers.
+  As of Apache 1.3, CGI scripts are essentially not buffered.  Every time
+  your script does a "flush" to output data, that data gets relayed on to
+  the client.  Some scripting languages, for example Perl, have their own
+  buffering for output - this can be disabled by setting the <CODE>$|</CODE>
+  special variable to 1.  Of course this does increase the overall number
+  of packets being transmitted, which can result in a sense of slowness for 
+  the end user.
   </P>
-  <P>Note that in version 1.3, all CGI scripts will be unbuffered
-  so the only difference between nph scripts and normal scripts is
+  <P>Prior to 1.3, you needed to use "nph-" scripts to accomplish non-buffering.
+  Today, the only difference between nph scripts and normal scripts is
   that nph scripts require the full HTTP headers to be sent.
   </P>
   <HR>
  </LI>
 
  <LI><A NAME="linuxiovec">
@@ -2090,13 +2055,13 @@
   at all.
   </P>
   <HR>
  </LI>
 
  <LI><A NAME="namevhost">
-      <STRONG>I upgraded to Apache 1.3b and now my virtual hosts don't
+      <STRONG>I upgraded to Apache 1.3.0 and now my virtual hosts don't
       work!</STRONG>
      </A>
   <P>
   In versions of Apache prior to 1.3b2, there was a lot of confusion
   regarding address-based virtual hosts and (HTTP/1.1) name-based
   virtual hosts, and the rules concerning how the server processed
diff -BEr -U 6 apache_1.3.0/htdocs/manual/misc/perf.html apache_1.3.1/htdocs/manual/misc/perf.html
--- apache_1.3.0/htdocs/manual/misc/perf.html	1998-06-02 06:30:23.000000000 +0800
+++ apache_1.3.1/htdocs/manual/misc/perf.html	1998-07-19 07:04:32.000000000 +0800
@@ -77,17 +77,16 @@
 <P><HR>
 
 <H3><A NAME="Linux">
 Linux
 </A></H3>
 
-The most common problem on Linux shows up on heavily-loaded systems
-where the whole server will appear to freeze for a couple of minutes
-at a time, and then come back to life.  This has been traced to a
-listen() queue overload - certain Linux implementations have a low
-value set for the incoming connection queue which can cause problems.
+There are no known problems with heavily loaded systems running Linux
+kernels 2.0.32 or later.  Earlier kernels have some problems, and an
+upgrade to the latest 2.0.x is a good idea to eliminate various security
+and denial of service attacks.
 
 <P><HR>
 
 <H3><A NAME="Solaris">
 Solaris 2.4
 </A></H3>
diff -BEr -U 6 apache_1.3.0/htdocs/manual/misc/perf-tuning.html apache_1.3.1/htdocs/manual/misc/perf-tuning.html
--- apache_1.3.0/htdocs/manual/misc/perf-tuning.html	1998-06-02 06:30:23.000000000 +0800
+++ apache_1.3.1/htdocs/manual/misc/perf-tuning.html	1998-07-19 07:04:32.000000000 +0800
@@ -705,13 +705,13 @@
 On some architectures it's slower to <CODE>mmap</CODE> small
 files than it is to simply <CODE>read</CODE> them.  The define
 <CODE>MMAP_THRESHOLD</CODE> can be set to the minimum
 size required before using <CODE>mmap</CODE>.  By default
 it's set to 0 (except on SunOS4 where experimentation has
 shown 8192 to be a better value).  Using a tool such as <A
-HREF="http://reality.sgi.com/lm_engr/lmbench/lmbench.html">lmbench</A> you
+HREF="http://www.bitmover.com/lmbench/">lmbench</A> you
 can determine the optimal setting for your environment.
 
 <P>You may also wish to experiment with <CODE>MMAP_SEGMENT_SIZE</CODE>
 (default 32768) which determines the maximum number of bytes that
 will be written at a time from mmap()d files.  Apache only resets the
 client's <CODE>Timeout</CODE> in between write()s.  So setting this
diff -BEr -U 6 apache_1.3.0/htdocs/manual/misc/security_tips.html apache_1.3.1/htdocs/manual/misc/security_tips.html
--- apache_1.3.0/htdocs/manual/misc/security_tips.html	1998-06-02 06:30:23.000000000 +0800
+++ apache_1.3.1/htdocs/manual/misc/security_tips.html	1998-07-19 07:04:32.000000000 +0800
@@ -51,16 +51,16 @@
 
 It is assumed that /, /usr, and /usr/local are only modifiable by root.
 When you install the httpd executable, you should ensure that it is
 similarly protected:
 
 <BLOCKQUOTE><PRE>
-    cp httpd /usr/local/apache/bin
-    chown 0 /usr/local/apache/bin/httpd
-    chgrp 0 /usr/local/apache/bin/httpd
-    chmod 511 /usr/local/apache/bin/httpd
+    cp httpd /usr/local/apache/sbin
+    chown 0 /usr/local/apache/sbin/httpd
+    chgrp 0 /usr/local/apache/sbin/httpd
+    chmod 511 /usr/local/apache/sbin/httpd
 </PRE></BLOCKQUOTE>
 
 <P>You can create an htdocs subdirectory which is modifiable by other
 users -- since root never executes any files out of there, and shouldn't
 be creating files in there.
 
@@ -221,15 +221,15 @@
  </DD>
 </DL>
 
 <HR>
 <P>Please send any other useful security tips to The Apache Group
 by filling out a
-<A HREF="http://www.apache.org/bug_report.html">problem report</A>, or by
-sending mail to
-<A HREF="mailto:apache-bugs@mail.apache.org">apache-bugs@mail.apache.org</A>
+<A HREF="http://www.apache.org/bug_report.html">problem report</A>.  
+Serious security matters should of course be sent to <A HREF="mailto:security@apache.org">
+security@apache.org</A>.
 <P>
 <HR>
 
 <HR>
 
 <H3 ALIGN="CENTER">
diff -BEr -U 6 apache_1.3.0/htdocs/manual/mod/core.html apache_1.3.1/htdocs/manual/mod/core.html
--- apache_1.3.0/htdocs/manual/mod/core.html	1998-06-02 06:30:16.000000000 +0800
+++ apache_1.3.1/htdocs/manual/mod/core.html	1998-07-19 07:04:24.000000000 +0800
@@ -46,12 +46,13 @@
 <LI><A HREF="#errorlog">ErrorLog</A>
 <LI><A HREF="#files">&lt;Files&gt;</A>
 <LI><A HREF="#filesmatch">&lt;FilesMatch&gt;</A>
 <LI><A HREF="#group">Group</A>
 <LI><A HREF="#hostnamelookups">HostNameLookups</A>
 <LI><A HREF="#identitycheck">IdentityCheck</A>
+<LI><A HREF="#ifdefine">&lt;IfDefine&gt;</A>
 <LI><A HREF="#ifmodule">&lt;IfModule&gt;</A>
 <LI><A HREF="#include">Include</A>
 <LI><A HREF="#keepalive">KeepAlive</A>
 <LI><A HREF="#keepalivetimeout">KeepAliveTimeout</A>
 <LI><A HREF="#limit">&lt;Limit&gt;</A>
 <LI><A HREF="#listen">Listen</A>
@@ -917,13 +918,13 @@
 
 <H2><A NAME="filesmatch">&lt;FilesMatch&gt;</A></H2>
 <A
  HREF="directive-dict.html#Syntax"
  REL="Help"
 ><STRONG>Syntax:</STRONG></A> &lt;FilesMatch <EM>regex</EM>&gt;
-... &lt;/Files&gt;<BR>
+... &lt;/FilesMatch&gt;<BR>
 <A
  HREF="directive-dict.html#Context"
  REL="Help"
 ><STRONG>Context:</STRONG></A> server config, virtual host, .htaccess<BR>
 <A
  HREF="directive-dict.html#Status"
@@ -1007,14 +1008,13 @@
  HREF="directive-dict.html#Default"
  REL="Help"
 ><STRONG>Default:</STRONG></A> <CODE>HostNameLookups off</CODE><BR>
 <A
  HREF="directive-dict.html#Context"
  REL="Help"
-><STRONG>Context:</STRONG></A> server config, virtual host, directory,
-.htaccess<BR>
+><STRONG>Context:</STRONG></A> server config, virtual host, directory<BR>
 <A
  HREF="directive-dict.html#Status"
  REL="Help"
 ><STRONG>Status:</STRONG></A> core<BR>
 <A
  HREF="directive-dict.html#Compatibility"
@@ -1088,12 +1088,79 @@
 since every request requires one of these lookups to be performed.  When
 firewalls are involved each lookup might possibly fail and add 30 seconds
 of latency to each hit.  So in general this is not very useful on public
 servers accessible from the Internet.
 <P><HR>
 
+<H2><A NAME="ifdefine">&lt;IfDefine&gt; directive</A></H2>
+<A
+ HREF="directive-dict.html#Syntax"
+ REL="Help"
+><STRONG>Syntax:</STRONG></A> &lt;IfDefine [!]<EM>parameter-name</EM>&gt; <EM>...</EM>
+&lt;/IfDefine&gt;<BR>
+<A
+ HREF="directive-dict.html#Default"
+ REL="Help"
+><STRONG>Default:</STRONG></A> None<BR>
+<A
+ HREF="directive-dict.html#Context"
+ REL="Help"
+><STRONG>Context:</STRONG></A> all<BR>
+<A
+ HREF="directive-dict.html#Status"
+ REL="Help"
+><STRONG>Status:</STRONG></A> Core<BR>
+<A
+ HREF="directive-dict.html#Compatibility"
+ REL="Help"
+><STRONG>Compatibility:</STRONG></A> &lt;IfDefine&gt; is only available in 
+1.3.1 and later.<P>
+
+<P>
+
+The &lt;IfDefine <EM>test</EM>&gt;...&lt;/IfDefine&gt;
+section is used to mark directives that are conditional. The
+directives within an IfDefine section are only
+processed if the <EM>test</EM> is true. If <EM>test</EM>
+is false, everything between the start and end markers
+is ignored.<P>
+
+The <EM>test</EM> in the &lt;IfDefine&gt; section directive
+can be one of two forms:
+
+<UL>
+<LI><EM>parameter-name</EM>
+<LI><CODE>!</CODE><EM>parameter-name</EM>
+</UL>
+
+<P>In the former case, the directives between the start and end markers are
+only processed if the parameter named <EM>parameter-name</EM> is defined.
+The second format reverses the test, and only processes the directives if
+<EM>parameter-name</EM> is <STRONG>not</STRONG> defined.
+
+<P>The <EM>paramater-name</EM> argument is a define as given on the
+<CODE>httpd</CODE> command line via <CODE>-D</CODE><EM>parameter-</EM>, at the
+time the server was started.
+
+<P>&lt;IfDefine&gt; sections are nest-able, which can be used to implement
+simple multiple-parameter tests.
+
+Example:
+
+<PRE>
+  $ httpd -DReverseProxy ...
+
+  # httpd.conf
+  &lt;IfDefine ReverseProxy&gt;
+  LoadModule rewrite_module libexec/mod_rewrite.so
+  LoadModule proxy_module   libexec/libproxy.so
+  &lt;/IfDefine&gt;
+</PRE>
+
+<P> <HR>
+
 <H2><A NAME="ifmodule">&lt;IfModule&gt; directive</A></H2>
 <A
  HREF="directive-dict.html#Syntax"
  REL="Help"
 ><STRONG>Syntax:</STRONG></A> &lt;IfModule [!]<EM>module-name</EM>&gt;
  <EM>...</EM>
@@ -1257,13 +1324,14 @@
 require valid-user<BR>
 &lt;/Limit&gt;</CODE></BLOCKQUOTE>
 
 If an access control directive appears outside a &lt;Limit&gt;
 directive, then it applies to all access methods. The method names
 listed can be one or more of: GET, POST, PUT, DELETE, CONNECT or
-OPTIONS. If GET is used it will also restrict HEAD requests.
+OPTIONS. <STRONG>The method name is case-sensitive.</STRONG>
+If GET is used it will also restrict HEAD requests.
 <STRONG>If you wish to limit all methods, do not include any
 &lt;Limit&gt; directive at all.</STRONG> <P><HR>
 
 <H2><A NAME="listen">Listen directive</A></H2>
 <A
  HREF="directive-dict.html#Syntax"
@@ -1825,25 +1893,30 @@
 a particular directory.
 <P>
 <EM>option</EM> can be set to <CODE>None</CODE>, in which case none of
 the extra features are enabled, or one or more of the following:
 <DL>
 <DT>All
-<DD>All options except for MultiViews.
+<DD>All options except for MultiViews. This is the default setting.
 <DT>ExecCGI
 <DD>
 <!--%plaintext &lt;?INDEX {\tt ExecCGI} option&gt; -->
 Execution of CGI scripts is permitted.
 <DT>FollowSymLinks
 <DD>
 <!--%plaintext &lt;?INDEX {\tt FollowSymLinks} option&gt; -->
 The server will follow symbolic links in this directory.
+<br>
 <STRONG>Note</STRONG>: even though the server follows the symlink it
 does <EM>not</EM>
 change the pathname used to match against <CODE>&lt;Directory&gt;</CODE>
 sections.
+<br>
+<STRONG>Note</STRONG>: this option gets ignored if set inside a
+&lt;Location&gt; section.
+
 <DT>Includes
 <DD>
 <!--%plaintext &lt;?INDEX {\tt Includes} option&gt; -->
 Server-side includes are permitted.
 <DT>IncludesNOEXEC
 <DD>
@@ -1863,12 +1936,15 @@
 allowed.
 <DT>SymLinksIfOwnerMatch
 <DD>
 <!--%plaintext &lt;?INDEX {\tt SymLinksIfOwnerMatch} option&gt; -->
 The server will only follow symbolic links for which the target
 file or directory is owned by the same user id as the link.
+<br>
+<STRONG>Note</STRONG>: this option gets ignored if set inside a
+&lt;Location&gt; section.
 </DL>
 
 Normally, if multiple <CODE>Options</CODE> could apply to a directory,
 then the most specific one is taken complete; the options are not
 merged. However if <EM>all</EM> the options on the <CODE>Options</CODE>
 directive are preceded by a + or - symbol, the options are
@@ -2798,13 +2874,16 @@
 
 The user should have no privileges which result in it being able to access
 files which are not intended to be visible to the outside world, and
 similarly, the user should not be able to execute code which is not
 meant for httpd requests. It is recommended that you set up a new user and
 group specifically for running the server. Some admins use user
-<CODE>nobody</CODE>, but this is not always possible or desirable.<P>
+<CODE>nobody</CODE>, but this is not always possible or desirable.
+For example mod_proxy's cache, when enabled, must be accessible to this user
+(see the <A href="mod_proxy.html#cacheroot"><CODE>CacheRoot</CODE></a> 
+directive</a>).<P>
 
 Notes: If you start the server as a non-root user, it will fail to change
 to the lesser privileged user, and will instead continue to run as
 that original user. If you do start the server as root, then it is normal
 for the parent process to remain running as root.<P>
 
diff -BEr -U 6 apache_1.3.0/htdocs/manual/mod/directives.html apache_1.3.1/htdocs/manual/mod/directives.html
--- apache_1.3.0/htdocs/manual/mod/directives.html	1998-06-02 06:30:16.000000000 +0800
+++ apache_1.3.1/htdocs/manual/mod/directives.html	1998-07-19 07:04:24.000000000 +0800
@@ -74,12 +74,13 @@
 <LI><A HREF="mod_setenvif.html#BrowserMatch">BrowserMatch</A>
 <LI><A HREF="mod_setenvif.html#BrowserMatchNoCase">BrowserMatchNoCase</A>
 <LI><A HREF="core.html#bs2000authfile">BS2000AuthFile</A>
 <LI><A HREF="mod_proxy.html#cachedefaultexpire">CacheDefaultExpire</A>
 <LI><A HREF="mod_proxy.html#cachedirlength">CacheDirLength</A>
 <LI><A HREF="mod_proxy.html#cachedirlevels">CacheDirLevels</A>
+<LI><A HREF="mod_proxy.html#cacheforcecompletion">CacheForceCompletion</A>
 <LI><A HREF="mod_proxy.html#cachegcinterval">CacheGcInterval</A>
 <LI><A HREF="mod_proxy.html#cachelastmodifiedfactor">CacheLastModifiedFactor</A>
 <LI><A HREF="mod_proxy.html#cachemaxexpire">CacheMaxExpire</A>
 <LI><A HREF="mod_negotiation.html#cachenegotiateddocs">CacheNegotiatedDocs</A>
 <LI><A HREF="mod_proxy.html#cacheroot">CacheRoot</A>
 <LI><A HREF="mod_proxy.html#cachesize">CacheSize</A>
@@ -111,12 +112,13 @@
 <LI><A HREF="mod_mime.html#forcetype">ForceType</A>
 <LI><A HREF="core.html#group">Group</A>
 <LI><A HREF="mod_headers.html#header">Header</A>
 <LI><A HREF="mod_autoindex.html#headername">HeaderName</A>
 <LI><A HREF="core.html#hostnamelookups">HostNameLookups</A>
 <LI><A HREF="core.html#identitycheck">IdentityCheck</A>
+<LI><A HREF="core.html#ifdefine">&lt;IfDefine&gt;</A>
 <LI><A HREF="core.html#ifmodule">&lt;IfModule&gt;</A>
 <LI><A HREF="mod_imap.html#imapbase">ImapBase</A>
 <LI><A HREF="mod_imap.html#imapdefault">ImapDefault</A>
 <LI><A HREF="mod_imap.html#imapmenu">ImapMenu</A>
 <LI><A HREF="core.html#include">Include</A>
 <LI><A HREF="mod_autoindex.html#indexignore">IndexIgnore</A>
diff -BEr -U 6 apache_1.3.0/htdocs/manual/mod/mod_auth_anon.html apache_1.3.1/htdocs/manual/mod/mod_auth_anon.html
--- apache_1.3.0/htdocs/manual/mod/mod_auth_anon.html	1998-06-02 06:30:17.000000000 +0800
+++ apache_1.3.1/htdocs/manual/mod/mod_auth_anon.html	1998-07-19 07:04:25.000000000 +0800
@@ -165,13 +165,13 @@
 <A
  HREF="directive-dict.html#Module"
  REL="Help"
 ><STRONG>Module:</STRONG></A> mod_auth_anon<P>
 
         When set 'on', the default, the 'password' entered (which hopefully
-        contains a sensible email address) is logged in the httpd-log file.
+        contains a sensible email address) is logged in the error log.
 <HR>
 
 <H2><A NAME="MustGiveEmail">Anonymous_MustGiveEmail directive</A></H2>
 <!--%plaintext &lt;?INDEX {\tt Anonymous_MustGiveEmail} directive&gt; -->
 <A
  HREF="directive-dict.html#Syntax"
@@ -285,13 +285,13 @@
 '@' and a '.'. (<CODE>Anonymous_VerifyEmail</CODE>)
 <LI>
 The userID must be one of <CODE>anonymous guest www test welcome</CODE>
 and comparison is <STRONG>not</STRONG> case sensitive.
 <LI>
 And the Email addresses entered in the passwd field are logged to
-the httpd-log file
+the error log file
 (<CODE>Anonymous_LogEmail</CODE>)
 </UL>
 <P>
 Excerpt of access.conf:
 <BLOCKQUOTE><CODE>
 Anonymous_NoUserId      off<BR>
diff -BEr -U 6 apache_1.3.0/htdocs/manual/mod/mod_cern_meta.html apache_1.3.1/htdocs/manual/mod/mod_cern_meta.html
--- apache_1.3.0/htdocs/manual/mod/mod_cern_meta.html	1998-06-02 06:30:17.000000000 +0800
+++ apache_1.3.1/htdocs/manual/mod/mod_cern_meta.html	1998-07-19 07:04:25.000000000 +0800
@@ -34,14 +34,14 @@
 the Expires: header, as well as providing other curiosities.
 There are many ways to manage meta information, this one was
 chosen because there is already a large number of CERN users
 who can exploit this module.
 
 <P>More information on the
-<A HREF="http://www.w3.org/pub/WWW/Daemon/User/Config/General.html#MetaDir
-">CERN metafile semantics</A> is available.
+<A HREF="http://www.w3.org/pub/WWW/Daemon/User/Config/General.html#MetaDir"
+>CERN metafile semantics</A> is available.
 
 <H2>Directives</H2>
 <UL>
 <LI><A HREF="#metafiles">MetaFiles</A>
 <LI><A HREF="#metadir">MetaDir</A>
 <LI><A HREF="#metasuffix">MetaSuffix</A>
diff -BEr -U 6 apache_1.3.0/htdocs/manual/mod/mod_mime.html apache_1.3.1/htdocs/manual/mod/mod_mime.html
--- apache_1.3.0/htdocs/manual/mod/mod_mime.html	1998-06-02 06:30:20.000000000 +0800
+++ apache_1.3.1/htdocs/manual/mod/mod_mime.html	1998-07-19 07:04:29.000000000 +0800
@@ -147,12 +147,16 @@
 ><STRONG>Syntax:</STRONG></A> AddHandler <EM>handler-name extension extension...</EM><BR>
 <A
  HREF="directive-dict.html#Context"
  REL="Help"
 ><STRONG>Context:</STRONG></A> server config, virtual host, directory, .htaccess<BR>
 <A
+ HREF="directive-dict.html#Override"
+ REL="Help"
+><STRONG>Override:</STRONG></A> FileInfo<BR>
+<A
  HREF="directive-dict.html#Status"
  REL="Help"
 ><STRONG>Status:</STRONG></A> Base<BR>
 <A
  HREF="directive-dict.html#Module"
  REL="Help"
diff -BEr -U 6 apache_1.3.0/htdocs/manual/mod/mod_proxy.html apache_1.3.1/htdocs/manual/mod/mod_proxy.html
--- apache_1.3.0/htdocs/manual/mod/mod_proxy.html	1998-06-02 06:30:20.000000000 +0800
+++ apache_1.3.1/htdocs/manual/mod/mod_proxy.html	1998-07-19 07:04:30.000000000 +0800
@@ -59,12 +59,13 @@
 <LI><A HREF="#cachemaxexpire">CacheMaxExpire</A>
 <LI><A HREF="#cachedefaultexpire">CacheDefaultExpire</A>
 <LI><A HREF="#cachelastmodifiedfactor">CacheLastModifiedFactor</A>
 <LI><A HREF="#cachegcinterval">CacheGcInterval</A>
 <LI><A HREF="#cachedirlevels">CacheDirLevels</A>
 <LI><A HREF="#cachedirlength">CacheDirLength</A>
+<LI><A HREF="#cacheforcecompletion">CacheForceCompletion</A>
 <LI><A HREF="#nocache">NoCache</A>
 </UL>
 
 <HR>
 
 <H2><A NAME="proxyrequests">ProxyRequests</A></H2>
@@ -554,12 +555,53 @@
   NoProxy         .mycompany.com 192.168.112.0/21 
   ProxyDomain     .mycompany.com
 </PRE>
 
 <HR>
 
+<H2><A NAME="cacheforcecompletion">CacheForceCompletion</A></H2>
+<A
+ HREF="directive-dict.html#Syntax"
+ REL="Help"
+><STRONG>Syntax:</STRONG></A> CacheForceCompletion <EM>&lt;percentage&gt;</EM><BR>
+<A
+ HREF="directive-dict.html#Default"
+ REL="Help"
+><STRONG>Default:</STRONG></A> <EM>90</EM><BR>
+<A
+ HREF="directive-dict.html#Context"
+ REL="Help"
+><STRONG>Context:</STRONG></A> server config, virtual host<BR>
+<A
+ HREF="directive-dict.html#Override"
+ REL="Help"
+><STRONG>Override:</STRONG></A> <EM>Not applicable</EM><BR>
+<A
+ HREF="directive-dict.html#Status"
+ REL="Help"
+><STRONG>Status:</STRONG></A> Base<BR>
+<A
+ HREF="directive-dict.html#Module"
+ REL="Help"
+><STRONG>Module:</STRONG></A> mod_proxy<BR>
+<A
+ HREF="directive-dict.html#Compatibility"
+ REL="Help"
+><STRONG>Compatibility:</STRONG></A> CacheForceCompletion is only available in
+Apache 1.3.1 and later.<P>
+
+If an http transfer that is being cached is cancelled, the proxy module will
+complete the transfer to cache if more than the percentage specified has
+already been transferred.<P>
+
+This is a percentage, and must be a number between 1 and 100, or 0 to use
+the default.  100 will cause a document to be cached only if the transfer
+was allowed to complete.  A number between 60 and 90 is recommended.
+
+<HR>
+
 <H2><A NAME="cacheroot">CacheRoot</A></H2>
 <A
  HREF="directive-dict.html#Syntax"
  REL="Help"
 ><STRONG>Syntax:</STRONG></A> CacheRoot <EM>&lt;directory&gt;</EM><BR>
 <A
@@ -586,14 +628,18 @@
  HREF="directive-dict.html#Compatibility"
  REL="Help"
 ><STRONG>Compatibility:</STRONG></A> CacheRoot is only available in
 Apache 1.1 and later.<P>
 
 Sets the name of the directory to contain cache files; this must be
-writable
-by the httpd server.
+writable by the httpd server.
+(see the <A href="core.html#user"><CODE>User</CODE></a> directive</a>).<BR>
+Setting <CODE>CacheRoot</CODE> enables proxy cacheing; without defining
+a <CODE>CacheRoot</CODE>, proxy functionality will be available
+if <CODE>ProxyRequests</CODE> are set to <CODE>On</CODE>, but no
+cacheing will be available.
 
 <HR>
 
 <H2><A NAME="cachesize">CacheSize</A></H2>
 <A
  HREF="directive-dict.html#Syntax"
@@ -624,13 +670,15 @@
  REL="Help"
 ><STRONG>Compatibility:</STRONG></A> CacheSize is only available in
 Apache 1.1 and later.<P>
 
 Sets the desired space usage of the cache, in KB (1024-byte units). Although
 usage may grow above this setting, the garbage collection will delete files
-until the usage is at or below this setting.
+until the usage is at or below this setting.<BR>
+Depending on the expected proxy traffic volume and <CODE>CacheGcInterval</CODE>,
+use a value which is at least 20 to 40 % lower than the available space.
 
 <HR>
 
 <H2><A NAME="cachegcinterval">CacheGcInterval</A></H2>
 <A
  HREF="directive-dict.html#Syntax"
@@ -660,13 +708,22 @@
  HREF="directive-dict.html#Compatibility"
  REL="Help"
 ><STRONG>Compatibility:</STRONG></A> CacheGcinterval is only available in
 Apache 1.1 and later.<P>
 
 Check the cache every &lt;time&gt; hours, and delete files if the space
-usage is greater than that set by CacheSize.
+usage is greater than that set by CacheSize. Note that &lt;time&gt; accepts a
+float value, you could for example use <CODE>CacheGcInterval 1.5</CODE> to
+check the cache every 90 minutes. (If unset, no garbage collection will
+be performed, and the cache will grow indefinitely.)
+Note also that the larger the <CODE>CacheGcInterval</CODE>, the more
+extra space beyond the configured <CODE>CacheSize</CODE> will be
+needed for the cache between garbage collections.<BR> <!--
+Note that due to a design flaw, Apache does not automatically force a
+garbage collection when the available space on the file system where
+the cache resides is exhausted. -->
 
 <HR>
 
 <H2><A NAME="cachemaxexpire">CacheMaxExpire</A></H2>
 <A
  HREF="directive-dict.html#Syntax"
diff -BEr -U 6 apache_1.3.0/htdocs/manual/mod/mod_rewrite.html apache_1.3.1/htdocs/manual/mod/mod_rewrite.html
--- apache_1.3.0/htdocs/manual/mod/mod_rewrite.html	1998-06-02 06:30:20.000000000 +0800
+++ apache_1.3.1/htdocs/manual/mod/mod_rewrite.html	1998-07-19 07:04:30.000000000 +0800
@@ -54,12 +54,27 @@
 Apache Group
 </DIV>
 </BLOCKQUOTE>
 </BLOCKQUOTE>
 </BLOCKQUOTE>
 
+<BLOCKQUOTE>
+<BLOCKQUOTE>
+<BLOCKQUOTE>
+<EM>``
+Despite the tons of examples and docs, mod_rewrite
+is voodoo. Damned cool voodoo, but still voodoo.
+''</EM>
+<DIV ALIGN=RIGHT>
+-- Brian Moore<BR>
+bem@news.cmc.net
+</DIV>
+</BLOCKQUOTE>
+</BLOCKQUOTE>
+</BLOCKQUOTE>
+
 Welcome to mod_rewrite, the Swiss Army Knife of URL manipulation!
 
 <P>
 This module uses a rule-based rewriting engine (based on a regular-expression
 parser) to rewrite requested URLs on the fly. It supports an unlimited number
 of rules and an unlimited number of attached rule conditions for each rule to
diff -BEr -U 6 apache_1.3.0/htdocs/manual/mod/mod_usertrack.html apache_1.3.1/htdocs/manual/mod/mod_usertrack.html
--- apache_1.3.0/htdocs/manual/mod/mod_usertrack.html	1998-06-02 06:30:21.000000000 +0800
+++ apache_1.3.1/htdocs/manual/mod/mod_usertrack.html	1998-07-19 07:04:30.000000000 +0800
@@ -113,12 +113,54 @@
 When the user track module is compiled in, and "CookieTracking on" is
 set, Apache will start sending a user-tracking cookie for all new
 requests. This directive can be used to turn this behavior on or off
 on a per-server or per-directory basis.  By default, compiling
 mod_usertrack will not activate cookies.
 
+<HR>
+
+<H2>2-digit or 4-digit dates for cookies?</H2>
+
+(the following is from message
+&lt;022701bda43d$9d32bbb0$1201a8c0@christian.office.sane.com&gt; in
+the new-httpd archives)
+
+<P>
+
+<PRE>
+From: "Christian Allen" &lt;christian@sane.com&gt;
+Subject: Re: Apache Y2K bug in mod_usertrack.c
+Date: Tue, 30 Jun 1998 11:41:56 -0400
+
+Did some work with cookies and dug up some info that might be useful.
+
+True, Netscape claims that the correct format NOW is four digit dates, and
+four digit dates do in fact work... for Netscape 4.x (Communicator), that
+is.  However, 3.x and below do NOT accept them.  It seems that Netscape
+originally had a 2-digit standard, and then with all of the Y2K hype and
+probably a few complaints, changed to a four digit date for Communicator.
+Fortunately, 4.x also understands the 2-digit format, and so the best way to
+ensure that your expiration date is legible to the client's browser is to
+use 2-digit dates.
+
+However, this does not limit expiration dates to the year 2000; if you use
+an expiration year of "13", for example, it is interpreted as 2013, NOT
+1913!  In fact, you can use an expiration year of up to "37", and it will be
+understood as "2037" by both MSIE and Netscape versions 3.x and up (not sure
+about versions previous to those).  Not sure why Netscape used that
+particular year as its cut-off point, but my guess is that it was in respect
+to UNIX's 2038 problem.  Netscape/MSIE 4.x seem to be able to understand
+2-digit years beyond that, at least until "50" for sure (I think they
+understand up until about "70", but not for sure).
+
+Summary:  Mozilla 3.x and up understands two digit dates up until "37"
+(2037).  Mozilla 4.x understands up until at least "50" (2050) in 2-digit
+form, but also understands 4-digit years, which can probably reach up until
+9999.  Your best bet for sending a long-life cookie is to send it for some
+time late in the year "37".
+</PRE>
 
 <HR>
 
 <H3 ALIGN="CENTER">
  Apache HTTP Server Version 1.3
 </H3>
diff -BEr -U 6 apache_1.3.0/htdocs/manual/sections.html apache_1.3.1/htdocs/manual/sections.html
--- apache_1.3.0/htdocs/manual/sections.html	1998-06-02 06:30:15.000000000 +0800
+++ apache_1.3.1/htdocs/manual/sections.html	1998-07-19 07:04:22.000000000 +0800
@@ -33,16 +33,16 @@
 
 <H2>Directives allowed in the sections</H2>
 
 Everything that is syntactically allowed in
 <CODE>&lt;Directory&gt;</CODE> is also allowed in
 <CODE>&lt;Location&gt;</CODE> (except a sub-<CODE>&lt;Files&gt;</CODE>
-section, but the code doesn't test for that, Lars has an open bug
-report on that).  Semantically however some things, and the most
-notable is AllowOverride, make no sense in
-<CODE>&lt;Location&gt;</CODE>.  The same for
+section).  Semantically however some things, and the most
+notable are <CODE>AllowOverride</CODE> and the two options
+<CODE>FollowSymLinks</CODE> and <CODE>SymLinksIfOwnerMatch</CODE>,
+make no sense in <CODE>&lt;Location&gt;</CODE>.  The same for
 <CODE>&lt;Files&gt;</CODE> -- syntactically everything is fine, but
 semantically some things are different.
 
 <H2>How the sections are merged</H2>
 
 The order of merging is:
@@ -121,19 +121,46 @@
     <CODE>&lt;Location&gt;</CODE>.  A future version of the config
     language should probably switch this to
     <CODE>&lt;Location&gt;</CODE>.
 </LI>
 </UL>
 
-Note also that modifying .htaccess parsing during Location doesn't do
-anything because .htaccess parsing has already occurred.
+<P>
+Note about .htaccess parsing:
+</P>
+<UL>
+<LI>
+    Modifying .htaccess parsing during Location doesn't do
+    anything because .htaccess parsing has already occurred.
+</UL>
+
+<P>
+<CODE>&lt;Location&gt;</CODE> and symbolic links:
+</P>
+<UL>
+<LI>
+    It is not possible to use "<CODE>Options FollowSymLinks</CODE>"
+    or "<CODE>Options SymLinksIfOwnerMatch</CODE>" inside a
+    <CODE>&lt;Location&gt;</CODE>/<CODE>&lt;LocationMatch&gt;</CODE> section
+    (the options are simply ignored).
+    Using the options in question is only possible inside a
+    <CODE>&lt;Directory&gt;</CODE> section (or a <CODE>.htaccess</CODE> file).
+</UL>
 
 <P>
+<CODE>&lt;Files&gt;</CODE> and <CODE>Options</CODE>:
+</P>
+<UL>
+<LI>
+    Apache won't check for it, but using an <CODE>Options</CODE>
+    directive inside a <CODE>&lt;Files&gt;</CODE> section has no effect.
+</UL>
 
-Another note:
 <P>
+Another note:
+</P>
 
 <UL>
 <LI>
     There is actually a
     <CODE>&lt;Location&gt;</CODE>/<CODE>&lt;LocationMatch&gt;</CODE>
     sequence performed just before the name translation phase (where
diff -BEr -U 6 apache_1.3.0/htdocs/manual/suexec.html apache_1.3.1/htdocs/manual/suexec.html
--- apache_1.3.0/htdocs/manual/suexec.html	1998-06-02 06:30:15.000000000 +0800
+++ apache_1.3.1/htdocs/manual/suexec.html	1998-07-19 07:04:22.000000000 +0800
@@ -380,13 +380,14 @@
 </PRE>
 </P>
 
 <P ALIGN="LEFT">
 <STRONG>COMPILING THE SUEXEC WRAPPER</STRONG><BR>
 You now need to compile the suEXEC wrapper.  At the shell command prompt,
-type:&nbsp;&nbsp;<STRONG><CODE>cc suexec.c -o suexec [ENTER]</CODE></STRONG>.
+after compiling Apache, 
+type:&nbsp;&nbsp;<STRONG><CODE>make suexec[ENTER]</CODE></STRONG>.
 This should create the <STRONG><EM>suexec</EM></STRONG> wrapper executable.
 </P>
 
 <P ALIGN="LEFT">
 <STRONG>COMPILING APACHE FOR USE WITH SUEXEC</STRONG><BR>
 By default, Apache is compiled to look for the suEXEC wrapper in the following
diff -BEr -U 6 apache_1.3.0/htdocs/manual/upgrading_to_1_3.html apache_1.3.1/htdocs/manual/upgrading_to_1_3.html
--- apache_1.3.0/htdocs/manual/upgrading_to_1_3.html	1998-06-02 06:30:15.000000000 +0800
+++ apache_1.3.1/htdocs/manual/upgrading_to_1_3.html	1998-07-19 07:04:24.000000000 +0800
@@ -75,14 +75,15 @@
       procedure for the complete Apache package.
 </UL>
 
 <H3>Run-Time Configuration Changes</H3>
 
 <UL>
-  <LI><STRONG><SAMP>AuthName</SAMP> strings may need to be quoted</STRONG>
-    in <SAMP>.htaccess</SAMP> or server configuration files.  If you use
+  <LI><STRONG><SAMP>AuthName</SAMP> strings will need to be quoted</STRONG>
+    in <SAMP>.htaccess</SAMP> or server configuration files if they contain
+    blank characters (like spaces). For example, if you use
     an <SAMP>AuthName</SAMP> directive like this:
     <P>
     <PRE>
      AuthName This and That
     </PRE>
     </P>
@@ -90,12 +91,31 @@
     <P>
     <PRE>
      AuthName "This and That"
     </PRE>
     </P>
     This change was made for consistency in the config language.
+  <LI><STRONG>As of Apache 1.3.1, methods listed in <SAMP>&lt;Limit&gt;</SAMP>
+    directives must be uppercase.</STRONG>  Method names, such as
+    <SAMP>GET</SAMP>, <SAMP>POST</SAMP>, and <SAMP>PUT</SAMP> are
+    defined as being case-sensitive.  That is, a <SAMP>GET</SAMP>
+    request is different from a <SAMP>get</SAMP> request.  Prior
+    to Apache 1.3.1, the <SAMP>&lt;Limit&gt;</SAMP> directive
+    parser incorrectly treated both of these as being the same.
+    Apache's built-in method limit processing currently only understands
+    uppercase method names, so if you've used clauses such as
+    "<SAMP>&lt;Limit&nbsp;Get&nbsp;post&gt;</SAMP>" in your configuration
+    files, you need to correct them to use uppercase names.
+    <P>
+    Unrecognised method names in the server configuration files will
+    result in the server logging an error message and failing to start.
+    In <SAMP>.htaccess</SAMP> files, unknown methods will cause the
+    server to log an error to its error log and return an 'Internal
+    Server Error' page to the client.
+    </P>
+  </LI>
   <LI><STRONG>The default Apache ServerRoot directory changed</STRONG>
     from the NCSA-compatible <SAMP>/usr/local/etc/httpd/</SAMP> to
     <SAMP>/usr/local/apache/</SAMP>. This change covers only the default
     setting (and the documentation); it is of course possible to override it
     using the <EM>-d ServerRoot</EM> and <EM>-f httpd.conf</EM> switches
     when starting apache.
@@ -114,12 +134,24 @@
     vhosts using HTTP/1.1 Host: headers, and the
     <A HREF="mod/core.html#serverpath">ServerPath</A> directive).  Now
     the earlier vhosts in the file have precedence over the later vhosts.
 
   <LI><CODE>HostnameLookups</CODE> defaults to Off.
 
+  <LI><STRONG><SAMP>REMOTE_HOST</SAMP> CGI variable changed.</STRONG>
+    In Apache 1.2 and earlier, the <SAMP>REMOTE_HOST</SAMP> environment
+    variable made available to CGI scripts was set to either the
+    full DNS name of the client, or else to the client's IP address
+    if the name was not known.  This behaviour differed from that
+    specified by the CGI specification, which defines this variable as being
+    NULL if the name isn't known.  In Apache 1.3, we have made this correction.
+    <SAMP>REMOTE_ADDR</SAMP> always contains the client's IP address,
+    but <SAMP>REMOTE_HOST</SAMP> is only defined when the server has
+    been able to determine the client's DNS name.
+  </LI>
+
   <LI>The undocumented
     <A HREF="mod/mod_access.html"><CODE>mod_access</CODE></A>
     syntax "allow user-agents" was removed.  The replacement is the
     more general "allow from env".
 
   <LI>When using wildcards in pathnames (such as * and ?) they no longer
diff -BEr -U 6 apache_1.3.0/htdocs/manual/vhosts/host.html apache_1.3.1/htdocs/manual/vhosts/host.html
--- apache_1.3.0/htdocs/manual/vhosts/host.html	1998-06-02 06:30:24.000000000 +0800
+++ apache_1.3.1/htdocs/manual/vhosts/host.html	1998-07-19 07:04:33.000000000 +0800
@@ -126,13 +126,13 @@
 <CODE>Host:</CODE> header functionality now allows someone who has
 access to <CODE>www.foo.com</CODE> to get
 <CODE>private.foo.com</CODE>, if they send a <CODE>Host:
 private.foo.com</CODE> header.  It is important to note that this
 condition exists only if you only implement this policy at the IP
 layer - all security controls used by Apache (i.e., <A
-HREF="mod/mod_access.html">allow, deny from,</A> etc.) are consistently
+HREF="../mod/mod_access.html">allow, deny from,</A> etc.) are consistently
 respected.
 
 <H2>Compatibility with Older Browsers</H2>
 
 <P>As mentioned earlier, a majority of browsers do not send the
 required data for the new virtual hosts to work properly. These
diff -BEr -U 6 apache_1.3.0/htdocs/manual/vhosts/virtual-host.html apache_1.3.1/htdocs/manual/vhosts/virtual-host.html
--- apache_1.3.0/htdocs/manual/vhosts/virtual-host.html	1998-06-02 06:30:24.000000000 +0800
+++ apache_1.3.1/htdocs/manual/vhosts/virtual-host.html	1998-07-19 07:04:33.000000000 +0800
@@ -69,45 +69,45 @@
 Either by running a separate httpd daemon for each hostname, or by running a
 single daemon which supports all the virtual hosts.
 <P>
 Use multiple daemons when:
 <UL>
 <LI>The different virtual hosts need very different httpd configurations, such
-   as different values for: <A HREF="mod/core.html#servertype">ServerType</A>,
-   <A HREF="mod/core.html#user">User</A>,
-   <A HREF="mod/core.html#group">Group</A>,
-   <A HREF="mod/mod_mime.html#typesconfig">TypesConfig</A> or
-   <A HREF="mod/core.html#serverroot">ServerRoot</A>.
+   as different values for: <A HREF="../mod/core.html#servertype">ServerType</A>,
+   <A HREF="../mod/core.html#user">User</A>,
+   <A HREF="../mod/core.html#group">Group</A>,
+   <A HREF="../mod/mod_mime.html#typesconfig">TypesConfig</A> or
+   <A HREF="../mod/core.html#serverroot">ServerRoot</A>.
 <LI>The machine does not process a very high request rate.
 </UL>
 Use a single daemon when:
 <UL>
 <LI>Sharing of the httpd configuration between virtual hosts is acceptable.
 <LI>The machine services a large number of requests, and so the performance
    loss in running separate daemons may be significant.
 </UL>
 
 <H2>Setting up multiple daemons</H2>
 Create a separate httpd installation for each virtual host.
 For each installation, use the
-<A HREF="mod/core.html#bindaddress">BindAddress</A> directive in the
+<A HREF="../mod/core.html#bindaddress">BindAddress</A> directive in the
 configuration
 file to select which IP address (or virtual host) that daemon services.
 <EM>E.g.</EM>,
 <BLOCKQUOTE><CODE>BindAddress www.smallco.com</CODE></BLOCKQUOTE>
 This hostname can also be given as an IP address.
 
 <H2>Setting up a single daemon</H2>
 For this case, a single httpd will service requests for all the virtual hosts.
-The <A HREF="mod/core.html#virtualhost">VirtualHost</A> directive in the
+The <A HREF="../mod/core.html#virtualhost">VirtualHost</A> directive in the
  configuration file is used to set the values of
-<A HREF="mod/core.html#serveradmin">ServerAdmin</A>,
-<A HREF="mod/core.html#servername">ServerName</A>,
-<A HREF="mod/core.html#documentroot">DocumentRoot</A>,
-<A HREF="mod/core.html#errorlog">ErrorLog</A> and
-<A HREF="mod/mod_log_config.html#transferlog">TransferLog</A> configuration
+<A HREF="../mod/core.html#serveradmin">ServerAdmin</A>,
+<A HREF="../mod/core.html#servername">ServerName</A>,
+<A HREF="../mod/core.html#documentroot">DocumentRoot</A>,
+<A HREF="../mod/core.html#errorlog">ErrorLog</A> and
+<A HREF="../mod/mod_log_config.html#transferlog">TransferLog</A> configuration
 directives to different values for each virtual host.
 <EM>E.g.</EM>,
 <BLOCKQUOTE><CODE>
 &lt;VirtualHost www.smallco.com&gt;<BR>
 ServerAdmin webmaster@mail.smallco.com<BR>
 DocumentRoot /groups/smallco/www<BR>
@@ -128,30 +128,30 @@
 This VirtualHost hostnames can also be given as IP addresses.
 
 <P>
 
 Almost <STRONG>ANY</STRONG> configuration directive can be put
 in the VirtualHost directive, with the exception of
-<A HREF="mod/core.html#servertype">ServerType</A>,
-<A HREF="mod/core.html#user">User</A>,
-<A HREF="mod/core.html#group">Group</A>,
-<A HREF="mod/core.html#startservers">StartServers</A>,
-<A HREF="mod/core.html#maxspareservers">MaxSpareServers</A>,
-<A HREF="mod/core.html#minspareservers">MinSpareServers</A>,
-<A HREF="mod/core.html#maxrequestsperchild">MaxRequestsPerChild</A>,
-<A HREF="mod/core.html#bindaddress">BindAddress</A>,
-<A HREF="mod/core.html#pidfile">PidFile</A>,
-<A HREF="mod/mod_mime.html#typesconfig">TypesConfig</A>, and
-<A HREF="mod/core.html#serverroot">ServerRoot</A>.
+<A HREF="../mod/core.html#servertype">ServerType</A>,
+<A HREF="../mod/core.html#user">User</A>,
+<A HREF="../mod/core.html#group">Group</A>,
+<A HREF="../mod/core.html#startservers">StartServers</A>,
+<A HREF="../mod/core.html#maxspareservers">MaxSpareServers</A>,
+<A HREF="../mod/core.html#minspareservers">MinSpareServers</A>,
+<A HREF="../mod/core.html#maxrequestsperchild">MaxRequestsPerChild</A>,
+<A HREF="../mod/core.html#bindaddress">BindAddress</A>,
+<A HREF="../mod/core.html#pidfile">PidFile</A>,
+<A HREF="../mod/mod_mime.html#typesconfig">TypesConfig</A>, and
+<A HREF="../mod/core.html#serverroot">ServerRoot</A>.
 
 <P>
 
 <EM>SECURITY:</EM> When specifying where to write log files, be aware
 of some security risks which are present if anyone other than the
 user that starts Apache has write access to the directory where they
-are written.  See the <A HREF="misc/security_tips.html">security
+are written.  See the <A HREF="../misc/security_tips.html">security
 tips</A> document for details.
 
 <P>
 
 <H2>File Handle/Resource Limits:</H2>
 When using a large number of Virtual Hosts, Apache may run out of available
diff -BEr -U 6 apache_1.3.0/htdocs/manual/windows.html apache_1.3.1/htdocs/manual/windows.html
--- apache_1.3.0/htdocs/manual/windows.html	1998-06-02 06:30:15.000000000 +0800
+++ apache_1.3.1/htdocs/manual/windows.html	1998-07-19 07:04:24.000000000 +0800
@@ -50,12 +50,13 @@
   <LI><A HREF="#req">Requirements</A>
   <LI><A HREF="#down">Downloading Apache for Windows</A>
   <LI><A HREF="#inst">Installing Apache for Windows (binary install)</A>
   <LI><A HREF="#run">Running Apache for Windows</A>
   <LI><A HREF="#use">Using Apache for Windows</A>
   <LI><A HREF="#cmdline">Running Apache for Windows from the Command Line</A>
+  <LI><A HREF="#signal">Signalling Apache when running</A>
   <LI><A HREF="#comp">Compiling Apache for Windows</A>
 </UL>
 
 <HR>
 
 <H2><A NAME="req">Requirements</A></H2>
@@ -155,22 +156,22 @@
 configured during the install ready for Apache to be run from the
 directory where it was installed, with the documents served from the
 subdirectory <SAMP>htdocs</SAMP>. There are lots of other options
 which should be set before you start really using Apache. However to
 get started quickly the files should work as installed.
 
-<H2><A NAME="inst">Running Apache for Windows</A></H2>
+<H2><A NAME="run">Running Apache for Windows</A></H2>
 
 There are two ways you can run Apache:
 
 <UL>
  <LI>As a "service" (available on NT only). This is the best option if
     you want Apache to automatically start when you machine boots, and to
     keep Apache running when you log-off.
 
- <LI>From a console window. This is the only option available for
+ <LI>From a <a ref="#cmdline">console window</a>. This is the only option available for
     Windows 95 users.
 </UL>
 
 To start Apache as a service, you first need to install it as a
 service. Run the "Install Apache as Service" option from the Start
 menu. Once this is done you can start Apache by opening the Services
@@ -275,38 +276,63 @@
 
 The Start menu icons and the NT Service manager can provide an simple
 interafce for administering Apache. But in some cases it is easier to
 work from the command line.
 
 <P>
-
 When working with Apache it is important to know how it will find the
-configuration files. During installation, a registry key will have
-been installed. For the 1.3 beta releases the key is:
+configuration files.  Apache will try one of the following, in this order.
 
-<PRE>
-  HKEY_LOCAL_MACHINE\Software\Apache Group\Apache\1.3 beta\ServerRoot
-</PRE>
+<ul>
+<li>A ServerRoot directive via a -C switch.
+<li>The -f switch on the command line.
+<li>The -d switch on the command line.
+<li>A registry entry, created if you did a binary install.
+<li>The server root compiled into the server.
+</ul>
 
-While for the final 1.3.0 release it is called:
+<P>
+The server root compiled into the server is usually "/apache".
+invoking apache with the -v switch will display this value
+labeled as HTTPD_ROOT.
+
+<P>
+Your current working directory when Apache is started up has no
+effect on Apache's behavior.
+
+<P>
+Under windows, when invoked from the start menu or the Service Manager Apache is
+usually passed no arguments.  So using the registry entry is the perfered
+technique.
 
+<P>
+During a binary installation, a registry key will have
+been installed, for example:
 <PRE>
   HKEY_LOCAL_MACHINE\Software\Apache Group\Apache\1.3.0\ServerRoot
 </PRE>
 
-(The use of different keys lets you install later versions without
-affect any previous versions already installed. For example, when
-1.3.1 comes out it will use "1.3.1" instead of "1.3.0" in the registry
-key, so you can install and test 1.3.1 without affecting you existing
-1.3.0 installation. Note however that Windows NT service manager only
-ever allows one service with the same name, so you cannot install the
-newer version as a service whilst the older version is still
-installed).
+For the 1.3 beta releases the key was:
+<PRE>
+  HKEY_LOCAL_MACHINE\Software\Apache Group\Apache\1.3 beta\ServerRoot
+</PRE>
 
 <P>
+This key is compiled into the server and can enable you to test 
+new versions without affecting the current version.  Of course
+you must take care not to install the new version on top of the
+old version in the file system.  You can not run two invocations
+of Apache on Windows simultaneously.
 
+<P>
+If you did not do a binary install then Apache will in some
+senarios complain that about the missing registry key.  This
+warning can be ignored if it otherwise was able to find it's
+configuration files.
+
+<P>
 The value of this key is the "ServerRoot" directory, containing the
 <SAMP>conf</SAMP> directory. When Apache starts it will read the
 <SAMP>httpd.conf</SAMP> file from this directory. If this file
 contains a <SAMP>ServerRoot</SAMP> directive which is different from
 the directory obtained from the registry key above, Apache will forget
 the registry key and use the directory from the configuration file.
@@ -320,40 +345,58 @@
 following command:
 
 <PRE>
     apache -s
 </PRE>
 
-(The -s option is not required by Windows 95, but on Windows NT it
-prevents Apache waiting to see if Apache is running as a
-service). Apache will execute, and will remain running until it
-is stopped by pressing control-C.
+Apache will execute, and will remain running until it is stopped by pressing
+control-C.  (The -s option is not required by Windows 95, but on Windows NT it
+prevents Apache waiting to see if Apache is running as a service.)
 
 <P>
 
-To install Apache as a Windows NT service, use the following:
+To install Apache as a Windows NT service as follows:
 
 <PRE>
     apache -i
 </PRE>
 
 and to remove the Apache service, use
 
 <PRE>
     apache -u
 </PRE>
 
-If you want to run an installation of Apache in a directory other than
-the one in the registry key as above, use the <CODE>-f</CODE>
-command-line to specify the path to the <SAMP>httpd.conf</SAMP> file,
-or the <CODE>-d</CODE> option to specify the server root
-directory. These options can be used with any of the other flags as
-listed above. Again note that once Apache has read the
-<SAMP>httpd.conf</SAMP> file it will then start using the directory
-given on the <SAMP>ServerRoot</SAMP> directive line instead of the -f
-or -d command line argument.
+
+<H2><A NAME="signal">Signalling Apache when running</A></H2>
+
+<P>When Apache is running you may request that it reread it's
+configuration files as follows:
+
+<PRE>
+    apache -Z @@whatever?@@>
+</PRE>
+
+and to request that it shutdown gracefully, via:
+
+<PRE>
+    apache -Z @@whatever?@@>
+</PRE>
+
+and you can force it to stop via:
+
+<PRE>
+    apache -Z @@whatever?@@
+</PRE>
+
+
+<P>
+Other techinques of shutting down the server (e.g. using the
+task manager to "End Process", distroying the command 
+window containing the server, or using control-C to interupt
+it) all have the downside of @@whatever@@.
 
 <H2><A NAME="comp">Compiling Apache for Windows</A></H2>
 
 <P>Compiling Apache requires Microsoft Visual C++ 5.0 to be properly
    installed. It is easiest to compile with the command-line tools
    (nmake, etc...). Consult the VC++ manual to determine how to install
@@ -415,12 +458,19 @@
   <LI><CODE><EM>dir</EM>\logs</CODE> - Empty logging directory
 </UL>
 
 <P>If you do not have nmake, or wish to install in a different directory,
    be sure to use a similar naming scheme.</P>
 
+<P>
+Before running the server you must fill out the conf directory.
+Copy the *.conf-dist-win from the distribution conf directory
+and rename *.conf.  Edit the @@ServerRoot@@ entries to your
+actual server root (for example "C:\apache").  Copy over
+the conf/magic and conf/mime.types files as well.
+
 <HR>
  <H3 ALIGN="CENTER">
   Apache HTTP Server Version 1.3
  </H3>
 
 <A HREF="./"><IMG SRC="images/index.gif" ALT="Index"></A>
diff -BEr -U 6 apache_1.3.0/INSTALL apache_1.3.1/INSTALL
--- apache_1.3.0/INSTALL	1998-05-22 15:25:01.000000000 +0800
+++ apache_1.3.1/INSTALL	1998-07-08 19:09:34.000000000 +0800
@@ -28,12 +28,16 @@
 
      $ ./configure --prefix=PREFIX
      $ make
      $ make install
      $ PREFIX/sbin/apachectl start
 
+     NOTE: PREFIX is not the string "PREFIX". Instead use the Unix
+           filesystem path under which Apache should be installed. For
+           instance use "/usr/local/apache" for PREFIX above.
+
   2. Requirements
      ------------
 
      The following requirements exist for building Apache:
 
      o  Disk Space: 
@@ -77,13 +81,13 @@
         o Out-of-the-box supported platforms are:
            - Linux     - IRIX
            - FreeBSD   - HPUX
            - OpenBSD   - OSF1
            - NetBSD    - UnixWare
            - SunOS     - AIX
-           - Solaris 
+           - Solaris   - SCO
 
         o Entirely unsupported platforms are:
            - Ultrix
 
         If your system is not on these lists but has the dlopen-style
         interface, you either have to provide the appropriate compiler and
@@ -97,17 +101,17 @@
         mechanism can have strange side-effects if you are not carefully. BE
         WARNED!
 
   3. Configuring the source tree
      ---------------------------
 
-     NOTE: Although we'll often advice you to read the src/Configuration.tmpl
+     NOTE: Although we'll often advise you to read the src/Configuration.tmpl
            file parts to better understand the various options in this
            section, there is _AT NO TIME_ any need to _EDIT_ this file. The
            _COMPLETE_ configuration takes place via command line arguments and
-           loal shell variables for the ./configure script. The
+           local shell variables for the ./configure script. The
            src/Configuration.tmpl file is just a _READ-ONLY_ resource, here.
 
      Introduction:
 
      The next step is to configure the Apache source tree for your particular
      platform and personal requirements. The most important setup here is the
@@ -152,12 +156,13 @@
                                [--proxycachedir=DIR]  [--suexec-uidmin=UID]
                                [--compat]             [--suexec-gidmin=GID]
                                                       [--suexec-safepath=PATH] 
 
                                                       [--with-perl=FILE]   
                                                       [--without-support]  
+                                                      [--without-confadjust]
 
      Use the CC, OPTIM, CFLAGS, INCLUDES, LDFLAGS, LIBS, CFLAGS_SHLIB,
      LD_SHLIB, LDFLAGS_SHLIB, LDFLAGS_SHLIB_EXPORT and RANLIB environment
      variables to override the corresponding default entries in the
      src/Configuration.tmpl file (see there for more information about their
      usage).
@@ -225,14 +230,70 @@
      src/Configuration.tmpl file. The correct module names (no `mod_' prefix!)
      and defaults (yes=enabled, no=disabled) can be seen when running
      `./configure --help'.  There are two special NAME variants: "all" for
      enabling or disabling all modules and "most" for enabling or disabling
      only these modules which are useable on all platforms (currently this is
      "all" minus the modules auth_db, log_agent, log_referer, example, so and
-     mmap_static).
- 
+     mmap_static). For a compact overview of available modules see the
+     following list (remove the "mod_" prefix to get the NAME).
+
+     _________________________________________________________________________
+     LIST OF AVAILABLE MODULES
+
+     Environment creation
+      (+) mod_env .......... Set environment variables for CGI/SSI scripts
+      (+) mod_setenvif ..... Set environment variables based on HTTP headers
+      (-) mod_unique_id .... Generate unique identifiers for request
+     Content type decisions
+      (+) mod_mime ......... Content type/encoding determination (configured)
+      (-) mod_mime_magic ... Content type/encoding determination (automatic)
+      (+) mod_negotiation .. Content selection based on the HTTP Accept* headers
+     URL mapping
+      (+) mod_alias ........ Simple   URL translation and redirection
+      (-) mod_rewrite ...... Advanced URL translation and redirection
+      (+) mod_userdir ...... Selection of resource directories by username
+      (-) mod_speling ...... Correction of misspelled URLs
+     Directory Handling
+      (+) mod_dir .......... Directory and directory default file handling
+      (+) mod_auto_index ... Automated directory index file generation
+     Access Control
+      (+) mod_access ....... Access Control (user, host, network)
+      (+) mod_auth ......... HTTP Basic Authentication (user, passwd)
+      (-) mod_auth_dbm ..... HTTP Basic Authentication via Unix NDBM files
+      (-) mod_auth_db ...... HTTP Basic Authentication via Berkeley-DB files
+      (-) mod_auth_anon .... HTTP Basic Authentication for Anonymous-style users
+      (-) mod_digest ....... HTTP Digest Authentication
+     HTTP response
+      (-) mod_headers ...... Arbitrary HTTP response headers (configured)
+      (-) mod_cern_meta .... Arbitrary HTTP response headers (CERN-style files)
+      (+) mod_asis ......... Raw HTTP responses 
+     Scripting
+      (+) mod_include ...... Server Side Includes (SSI) support
+      (+) mod_cgi .......... Common Gateway Interface (CGI) support
+      (+) mod_actions ...... Map CGI scripts to act as internal `handlers'
+     Internal Content Handlers
+      (-) mod_status ....... Content handler for server run-time status
+      (-) mod_info ......... Content handler for server configuration summary
+     Request Logging
+      (+) mod_log_config ... Customizable logging of requests
+      (-) mod_log_agent .... Specialized HTTP User-Agent logging (deprecated)
+      (-) mod_log_refer .... Specialized HTTP Referrer logging   (deprecated)
+      (-) mod_usertrack .... Logging of user click-trails via HTTP Cookies
+     Miscellaneous
+      (+) mod_imap ......... Server-side Image Map support
+      (-) mod_proxy ........ Caching Proxy Module (HTTP, HTTPS, FTP)
+     Experimental
+      (-) mod_so ........... Dynamic Shared Object (DSO) bootstrapping
+      (-) mod_mmap_static .. Caching of frequently served pages via mmap()
+     Development
+      (-) mod_example ...... Apache API demonstration (developers only)
+     _________________________________________________________________________
+                    (+) = enabled  per default [disable with --disable-module]
+                    (-) = disabled per default [enable  with --enable-module ]
+
+
      Use the --enable-shared=NAME and --disable-shared=NAME options to enable
      or disable the shared object support for a particular module from the
      Apache src/Configuration.tmpl file. The defaults (yes=enabled,
      no=disabled) can be seen when running `./configure --help'. There are two
      special NAME variants: "max" for enabling or disabling all modules except
      the bootstrapping "so" module and "remain" for enabling or disabling only
@@ -261,12 +322,17 @@
      have to select the correct one manually.
  
      Use the --without-support option to explicitly disable the build and
      installation of support tools from the src/support/ area. This can be
      useful when you have compilation problems with one or more of these not
      programs on your platform or if you just don't need them.
+
+     Use the --without-confadjust option to explicitly disable some built
+     user/situation dependent adjustments to the config files (Group, Port,
+     ServerAdmin, ServerName, etc.).  This is usually only interesting for
+     vendor package maintainers who wants to force the keeping of defaults.
  
      Use the --enable-suexec option to enable the suEXEC feature by building
      and installing the "suexec" support program. Use --suexec-caller=UID to
      set the allowed caller user id, the --suexec-userdir=DIR to set the user
      subdirectory, the --suexec-uidmin=UID/--suexec-gidmin=GID to set the
      minimal allowed UID/GID and --suexec-safepath=PATH to set the safe shell
diff -BEr -U 6 apache_1.3.0/KEYS apache_1.3.1/KEYS
--- apache_1.3.0/KEYS	1998-03-26 02:39:54.000000000 +0800
+++ apache_1.3.1/KEYS	1998-07-15 20:31:23.000000000 +0800
@@ -320,6 +320,134 @@
 AmwbvL/UwgiDnm95qBBfCZtmGkkFaoOePtBevWFaviFZM2pErPRcjY8A/1cZsycj
 JPMFYqBKGDIk76ulDSjU0Q8dqhCEDf0o2oQEg6msjDtetVFEDw9yJe0AGIkAPwMF
 GDTsCJl9bb/R8I4BKhECBKgAoNRtRaRMdYNwajSO7056eKazCGSDAKDShamaRjAe
 ThQ1KefmJKyzfcosZQ==
 =25Cv
 -----END PGP PUBLIC KEY BLOCK-----
+
+
+Type Bits/KeyID    Date       User ID
+pub   999/F88341D9 1994/11/08 Lars Eilebrecht <sfx@unix-ag.org>
+                              Lars Eilebrecht <Lars.Eilebrecht@unix-ag.org>
+
+-----BEGIN PGP PUBLIC KEY BLOCK-----
+Version: 2.6.3i
+
+mQCKAi6+wOsAAAED53PJgrIYS7iHbZn0ycrnzS03fwvwsDpoAVouoqqBSVNoVXH+
+lL+8HzX/fADvNyk1lYi5kTiYR2meKB1p0qpvj4bQ8ZEmcBemhV0FbESJ4CxIgy6V
+euxOD3v9gauyf1u4lkfyLIsCepuJqpkH+aOviE9VhTcE/D6Pt/L4g0HZAAURtCFM
+YXJzIEVpbGVicmVjaHQgPHNmeEB1bml4LWFnLm9yZz6JAJIDBRAzzQ7YPo+38viD
+QdkBAcaXA+du8KHJjdox8QpJiJiA/mDFRfINUYo9whMvqCwGYojVkkcY9pVkx4bF
+WV7cxed/gA+/ayaqxYWVAsflurxuOrizLrt/1aZxH6tkLA9HesyFL0gxSMbMv7OJ
+J8r4HzHl3Mx5m+74xmxrMj/ZqowMjezFHKoAQQDR+B1/QkkTfLQtTGFycyBFaWxl
+YnJlY2h0IDxMYXJzLkVpbGVicmVjaHRAdW5peC1hZy5vcmc+iQCSAwUQM80MBT6P
+t/L4g0HZAQGt9QPnT77EcNc1r8jA6dmkMKiGsCItsIhZeepWH6ZMFlo7HX7bitBx
+3voHpNGidby8CRZa4r66BLpBdSWit5Ev6G9rv0zSGeDClo34W5CVuNGO4AiglCT8
+4eoQ8NZ2H3ODfVyp8Lm4kVXVtooNR1aCmVDfQHdN+Jt9IzBxM6l2zuC0MUxhcnMg
+YFNGWCcgRWlsZWJyZWNodCA8U0ZYQHVuaXgtYWcudW5pLXNpZWdlbi5kZT6JAHUD
+BRAzEfV1S1wlNB5o8N0BAX7QAwC3iuW6C34zc8We4NVTx8OpOkMElBEsIjyQphky
+E+X/eNWIR6qIYMDeZBkfVw8VggiQKkHxb28YYmb9M7uB70OxWC1Szts8Ga1bzn0d
+ufY7xgxaT6kQatXHMUzV7r39muOJAJUCBRAw+R5/voJFl2Zsya0BAVlWA/0eFxcS
+JrCcc6WspLfB5eJKUDVmFh3eWnvNUBZWv73yKZQanlVq9vfaVGztcQbeBBT4uWsm
+vAhsF7PLkbByp97u9dY3064tZiqYjAVrdePQbFJOZRQpxPYFaOVMWHKTNr29SOQy
+nqP/Pw7mM9RUIV8DsRqgaiK/oIENXze0NL+as4kBFQMFEDEsVXTwiYRjAFcYEQEB
+WnwH/jmcYmaqYHgN4jGc2zq9e7+GIy/yeDd6Ya3MvLLIdK5kwWzR1jn0UdMsxpQF
+3rKQki8wZ0kDKYdjF3NwJedSyuM+PO4gEMabuZP2Sq4OWoWSO1+aJL4k3EY5l5KW
+216frDLOid2Tjo8TtbVsrUl1uf95SsG482lEZW1GwQPUEEhgGD57MGfgjykTblLJ
+NhCN8uA1lY7mmznAnjcuEy3wfVCGPNaF31zsk/othcGdH9W3n3mbrjyAhkCMZRBY
+tx3d4QxAIDSfB7vQulwAp2Ink+3VWLZWB9eFE5OvwiypG1jYXfyOUkDD24oyits1
+OVN7z3KJQNVGpUgXJH7Q0Nok5pmJAJUDBRAw+UGLHilwjxqEmVEBAchWA/46j8dr
+vA9WkMyh72akvT1GErDzE4J9dBUf7adnPQoetH/gUPenzlAs5kbfeCKtYjGbCdKE
+8iy3+sH/zHW9S4b7Bn+61xQE4duTlKT8daj1FrLUk6B0p9PmX/HtQdKejyfenbiO
+q4pqHPDSqaTsEpkb6gA9wEwiqTIjksFnvfpgWYkAVQMFEDD5fUoJNGLsuYI5PQEB
+F9gCAJQqYY+CSP8r6HWCJaQtjDzrPoX072jD1YUgmWdBFX2YE2aS0F0A4lKJWAb0
+xyZ4wWcl2aM5Z/3X+DAR0IClsJiJAFUCBRAw+UT5PjTM7Dn4WRsBAeRKAgCDTEFm
+WZ/tdq9pxUnAknH+U2iqZvmOjHxLL1YNLa73hCe+Im2xQ6PAAWdoOhYM3w8QDG8T
+bFEGjK4YdE2kgvRMiQCVAgUQMPjujh3Ztnhw/dexAQH49QP+P3GBBGu4zfPqbZsW
+SrH2dMTj9ncbD54nA0+FUdejBzeq5Fa7aO/Nl0okcd2VLHfUY1Jnx2QN5h6CSBqO
+iURVTnso4NyxAEkkn2a+GBZIbrZ39JQ5STnhCoaryMP3UjuzA8HS8YTqgBb/VMwJ
+aTpuBi8fadTetcQ5dXSGBJ2PXDiJAJUCBRAw+UJ8hWrdG2nWnOkBAQgjBACletAH
+nVmcl1qJHMFiG1vzy4DUwofCS9b4o1xpwb09j7gNC+/6wlz4W29tAK66vj+sWxhc
+YuNolonnlNk+czeSJTzm0+nD3kViZMT52kn/GQ992NWpZnLoYWDFHO5ZC+8qkqNS
+fE0VQksY0OFtPkA1BSBL64oG+UnHe82BxjqqEokAVQIFEDD4zdqb2lGD8IQbEQEB
+jYUB/2eiJQSOIXRm/LXnpTIGNpH9yKtPDQcssoCQCOPB6k3tHCiFugT3AZCajKKC
+bUSU1+kZLfH0SnvyDxnhxqslt3iJAO4DBRAw4VEeit1k1hLNdSkBAU55BsEBICTJ
+PEh0ftogZjiUNsfpL+C1Zj6fIXWiggXX7yQ5q0qbhIKwVhSPTw6UsBezViz6hEj5
+1qOXXfGHsp82M92goiFwDlAdKxvLboxdXUp/5BVAjKoKr2zzlN7Er+rVZRAiAIeu
+xkzR5+tSCISzNChuL/XpaNC5P0qVsEUTyWVv5bUAQKY7Ufo7hToquvOvnhPZCgQi
+JgiLYQXhP3H+iX8LkuPtbovjJpJKq5zvPtO23Y25Fk0s0y95ddr/7TNqfBcKqbON
+cvt5yBDs6uyLH+MwY38NmSnl2xF6tDNMYXJzIGBTRlgnIEVpbGVicmVjaHQgPFNG
+WEBhcHBsMi5ocnoudW5pLXNpZWdlbi5kZT6JAJUCBRAw+R7+voJFl2Zsya0BAQ/U
+A/4iCLzlKsikQVox4CQ+86LJMQ0B/2FYSbufc6AhDiRsFxTy5U93HpnjAmlS2uV7
+6A5y2Fmf23yOZxXfbxfRsMG5j/P8d/WdzdsSnyaQ/Hh+Yp7uQMLSLJH145nGYUnw
+4L9l6QGhYoM98CAbfl25D0cSScX6g+aCdcrNKjXtFOo48okBFQMFEDEsVa7wiYRj
+AFcYEQEBy1YH/3FuhZc5jniLyf98ge74UjpaYr52NNIip88wqVizmrGguDT2s4aj
+SHsAWtNSkrmpiInGJM15PDHmk6uRGkHycgPjbXVkpv9/4rylqDuCmqiW1T58Wg5w
+digR/tpqtASeK0uIto1WbqKW7TAB1fpUFB2lR/NumGhT2vuNuQPx/jmqp9hHZC/N
+H6SCbAArLnWDwxgikt83DI7KVStXF6jUQ8yDmfCP17cjRCacNckRn7eI65+JY/Y1
+OMtL+rBTreo6brwJskTf6Xm8I2CcNWHuvezDJJ9JxGnx+eRLfl33QTmDZt0m/ydo
+PI9iVVYTeiSrhWMjNZLytd0ZMt0oiz1Mw/eJAJUCBRAw+UKqhWrdG2nWnOkBAeh7
+A/0aKD0eqRZ0orAnq05T4UrwyNoJdh1DBcNAmSeSSlZY+RhQ2aeY5dMoYAhQsHhb
+hO0VIDDpLxnhKBD2XsoqWnLK1SHDtumgkMnqy00HeiU4DrghHhL5IwcIqjq1TUhD
+zOU1j80HO0OyA7Sk7Ak/sTRrTuj4tvgK2WqHWU7aeLV5AokAVQIFEDD4zgub2lGD
+8IQbEQEB3VQB/3iIApOn6N/zL8buyBEnQyzP6M4deMr2c+hbwv1SrUqedYKKrFeY
+yPcCgDSI6Jy3juxibm4zvpah77BFbBkPsKSJAO4DBRAw4VIzit1k1hLNdSkBAYE1
+BsEBh/CHO8zWlJUZmJuSfEd++Yj/Aqyf8SC2xE+vVbEdmgxtjANs/DQQZFdQEawA
+tmFmvbDvdcgsn9zQCOiNaKrW7/9PSJv7NG07uunVq6kQIrkwdzrvoBydH3POYE1n
+AXff8Uv5jZWW9f2V45AWmHZdAc5u9nN/h6mYx80955cVWORwoteSeIg4Argj83qN
+a/EIBprGz+3w/tB5Gu7ZV2/O1sT2bfp5IxkvcZi6zR8Of7yaXDePn83r84U0A/CH
+LFK9EHGVB/Y2aZusVqYmzxec+xc106K4Ln/ltDNMYXJzIGBTRlgnIEVpbGVicmVj
+aHQgPFNGWEBhcHBsMS5ocnoudW5pLXNpZWdlbi5kZT6JAJUCBRAw+R7avoJFl2Zs
+ya0BAY7MA/9TcJu8qFerI+6k4imlvUtw0A9yyl7cHog3WBdJafetSFpLsgbq+GmA
+TUTkCvNsxUKijSn7JvhV7vjegGENsxFCRFJE/UUIJrK31NatOu2aKPnXJOU9s7h/
+v5KphfbdvBr+I48VU4regvdjRIXIrrTTuPJCt9gU9poF9sO7XbOhuIkBFQMFEDEs
+VbzwiYRjAFcYEQEBVCoH/2OA43qNfPmQH69ASpdeD9vXSit6fDi3J6l4eo7gX00Y
+lpxSba0Hxh/cN6UL6YtkUbg2U00M4TuHjqtoOYMvTMrVNYbS0VaVcAZ5poy0Vs9F
+hqq+MuGVC24N4WuTbHwaaXYBypOWPgabbyC/9+2QZM7ZIgV37NGW3N32UeG0lNcQ
+zhPh0tAaHzsbm6n2awmbwIzAguTSeEddx/MZ2IOjSkAgKjn3gjlVpBp3PwSu1QKz
+F4wvKP/Z0A82Nn0TyDT5wm+H/+D7p8DqxM2usy8V34Da2kCdfW6D2/6PQwZbzTlp
+KvYEplZ0xJKqxDLYl3d9SgFPy1QkR/+9Jse12ZBefzeJAFUDBRAw+X2OCTRi7LmC
+OT0BAVtJAf9LPQKmsB6if9KzvY7DIZN77hzYMFReA6Cky+RAyDkRE3HAH+FGVSaP
+ic5o2MXNX9kZMJDJJPzfWnymZnDUmM7XiQBVAgUQMPlFGT40zOw5+FkbAQGoewIA
+iFkfxzbfldtGw7ngjvZocBoq6uRO0yVPgvcU/twXmV5ssvwEe7ViXSpwupWhgy5z
+JKNwlq/10Sg/qwtOdJzbK4kAlQIFEDD47t0d2bZ4cP3XsQEBdGsD/3F8CAWhAI+A
+/0oczJ2tzUPxDOGk54gB3VSB+HelIdkcAwqGLeh8BD9dcXwcCOmw1pUIXVIA8xjl
+5jsSsb/17YuL4hzsDtSqo0bRzsg3+ISP6LtqdG57VzGeclb9FmpMlu5GHeysU22H
+fwkynvBwfvMJI/IdaW99SSaF81rIJsF4iQCVAgUQMPlC2IVq3Rtp1pzpAQEFMAP/
+QFKhULF1vZDIuUaKCE4kG0cp7pz4dmqmnVZ7i2aAIcadenPhEGKXOEIuoyzwVXph
+3UuD1vLyXoBdaSbQ2eFXyzcMJCMY+2NIVPAOAXB1CHxXThEe0sG1v4u0E1PLt7zR
+35oCKHb9fQ+6xcRM6qj8TB0aSLPPyDhvS983N5FfK52JAFUCBRAw+M4sm9pRg/CE
+GxEBAYOpAgDY/Zq9tIHGEWeHg357k0pEr7Y7yqMdBLTPlJwAIIocVKubzQmQxHqI
+WUmQUf6dqZLXErvnHZOWwRR7c5GjU7fNiQBVAgUQL9LtnJk1TqNo/f9NAQHbmwIA
+nJkJd4L3XkLgNs0pqhzawhF3ZoyCJbTlnPFhQjyYw7enNnAXZrsKDmJJ1lhgzCl7
+05YepT4CFcd34ZYaG8cRSokAlQIFEC/TPkdGsYn74N6qbQEBe7QD+we/Mvd4GqIw
+zAvDcH4jSoe5eXAYdDjQPltYNzu2CxOVu2f3zoOB96Tro56lOx9zbAoZg8bQSkCC
+ImV6ZzYODbdxe+ubfBD6zJo40CeGuvvAh35l5nzUlqjzHY4CVuMpDJ1GrBoYBdWf
+H5TTZHx+YH1vRq/FHApYCqmucb5IQuXMiQBVAwUQL9M7ykMGd0cf7QM7AQFbNAH/
+dXBIx96GTyGsnUmcT1IxdUhN6fdzZ2OgN5imUdb5HsBurEalWuDDuJcPMPAFO4Ht
+q78LqRd8HhdWfQxtm2rhpokAlQIFEC/TOErly4YMq0SgyQEB/70EAIxjN+9DMHCH
+5rUPXv9I9J87UMENfHVzAPnTMjR4hq3PiQu9buc48cJju0dVb+2UgGn/T7JRf9df
+MEunxYPQT/izuU+A+OMDCU34jDL99EOEn8Z/Q1/Td4mMy9T0x5pQjnwkEKrwuOdV
+23FxAqpqlhxKiCPP/+MP4fcq5f+Rf7l5iQBVAgUQL9JXH/2YSvmy1vClAQHP6wH/
+a5ieejuNEFQ/NN/m1Nc0okhNcfhVEbfnHgLKM6qPbWhaESBl02vDKbMErcgC5ySq
+cg5BhJ030XQEVULXBM2CZ4kAVQIFEC/SQ78RGQkc+pTPfwEBtscB/iEACWRL5XTR
+83opHs9fE8ctdhJyfZPs2tq4z1Z5V+/rXiGN1TTtYaJlIMKo6Dh6WZHRoHTnZrnz
+oJU90aq5ORWJAJUCBRAv0bftSUmmLBOdkOEBAc1GBADKJ3N1BTYxqJ/Bf6JnNDzw
+N63x9iEuht9RTen0Wq1tT8JOwlpcd8IB5uoDvcX1eZQ4wSfpVZm5i8/9TGYYOuOn
+hUW7oLQWGzl8BOs5jaygYXIVbnlTjc8FjyAPAWbUdi8OgopADoSoJeJ3YPDzvFFI
+PIIdFVChkzwytDCke2QqRokAVQIFEC/SFz55jBgMe7ddiQEBqSAB/2a5delC8N/4
+Je09dRG52wPU9y417g+ExtyBnhFd89cG0adtu8jddmtz22rxCiY9Zn1q2Wk/PV7d
+bJmAWiMF+GqJAJUCBRAvGBnqSF+rLyPZK+MBAZztA/9UeB5VDONwlI8XYp83Iozi
+cUTXu4nl6ae8TZ/UriaLQ1Xgiw0RUqZhdhBW9Cg8qF9m2NfMT0/bFrSDGL+F4oEg
+cH7kfkqfidQi3T/s85iGW2QXPtxucTOp4qb2ipdQ5IUpS6nnVuHZoNayoAjl2Ch3
+cx1HGp3jROK5KFpVcBua4YkAlQIFEC7Nfr8eKXCPGoSZUQEB8FwD/Aiiw1hSyexX
+NyWdDJ7j8Vu/TPZ0UMC9kyP1XeJQlEogzlHRL41OOTC5i4FPuDmTT3l2gUi5DeM/
+D1JMRhBL0nghRO7tOFTatRidmgvnx1Rc7lm6dC7Hs6g0p5usbwcc+NMhGmZ5F7t/
+uupF2VfxOATSJAmgeVdql8awSINA9dIgiQCUAgUQLse2rg9HL1s0103BAQEzVQP4
+1Pm01Kp5WXa3+ioAr/oQzrOlTud/HBMUDbAZe8fNg426fEObdtWBFfC4hTdYpri2
+Kh16gxB7e6ra6DWgWF4J0duEIyN7q3pfpGDIm2VsRq6t/NgtmqUXmhA5kNarRMz/
+pF3sWmsAMyjKPFSljJ140GAS2aIblKn3IhPQOzkBdYkARQIFEC6+xa2V04tRZnGp
+VQEBTi0Bf1grk33LBHO89ViuQTEJbQoJzb7s9IYpjT9hcT5eIOa6t7vItN3aj27l
+cH68Us8vpg==
+=8Cs1
+-----END PGP PUBLIC KEY BLOCK-----
+
Only in apache_1.3.0/: Makefile
diff -BEr -U 6 apache_1.3.0/Makefile.tmpl apache_1.3.1/Makefile.tmpl
--- apache_1.3.0/Makefile.tmpl	1998-05-12 19:52:11.000000000 +0800
+++ apache_1.3.1/Makefile.tmpl	1998-07-16 01:03:25.000000000 +0800
@@ -115,12 +115,18 @@
 suexec_caller   = @suexec_caller@
 suexec_userdir  = @suexec_userdir@
 suexec_uidmin   = @suexec_uidmin@
 suexec_gidmin   = @suexec_gidmin@
 suexec_safepath = @suexec_safepath@
 
+#   some substituted configuration parameters
+conf_group       = @conf_group@
+conf_port        = @conf_port@
+conf_serveradmin = @conf_serveradmin@
+conf_servername  = @conf_servername@
+
 #   usage of src/support stuff
 build-support     = @build_support@
 install-support   = @install_support@
 clean-support     = @clean_support@
 distclean-support = @distclean_support@
 
@@ -174,13 +180,15 @@
 
 #   the install target for installing the complete Apache
 #   package. This is implemented by running subtargets for the
 #   separate parts of the installation process.
 install:
 	@if [ ! -f $(TOP)/$(SRC)/.apaci.build.ok ]; then \
-	    $(MAKE) -f $(MKF) $(MFLAGS) $(MFWD) build; \
+		$(MAKE) -f $(MKF) $(MFLAGS) $(MFWD) build; \
+	else \
+		:; \
 	fi
 	@$(MAKE) -f $(MKF) $(MFLAGS) $(MFWD) \
 		install-mktree install-programs $(install-support) \
 		install-include install-data install-config
 	-@$(RM) $(SRC)/.apaci.install.tmp
 	-@$(RM) $(SRC)/.apaci.install.conf
@@ -319,13 +327,13 @@
 
 #   install the Apache C header files
 install-include:
 	@echo "===> [include: Installing Apache C header files]"
 	$(UMASK) 022; $(CP) $(TOP)/$(SRC)/include/*.h $(root)$(includedir)/
 	@osdir=`grep '^OSDIR=' $(TOP)/$(SRC)/Makefile.config | sed -e 's:^OSDIR=.*/os:os:'`; \
-	echo "$(UMASK) 022; $(CP) $(TOP)/$(SRC)/$${osdir}/os.h $(includedir)/"; \
+	echo "$(UMASK) 022; $(CP) $(TOP)/$(SRC)/$${osdir}/os.h $(root)$(includedir)/"; \
 	$(UMASK) 022; $(CP) $(TOP)/$(SRC)/$${osdir}/os.h $(root)$(includedir)/
 	@echo "<=== [include]"
 
 #   create an initial document root containing the Apache manual,
 #   icons and distributed CGI scripts.
 install-data:
@@ -377,12 +385,17 @@
 			-e 's;logs/httpd.pid;$(runtimedir)/httpd.pid;' \
 			-e 's;logs/access_log;$(logfiledir)/access_log;' \
 			-e 's;logs/error_log;$(logfiledir)/error_log;' \
 			-e 's;logs/referer_log;$(logfiledir)/referer_log;' \
 			-e 's;logs/agent_log;$(logfiledir)/agent_log;' \
 			-e 's;conf/magic;$(sysconfdir)/magic;' \
+			-e 's;conf/mime.types;$(sysconfdir)/mime.types;' \
+			-e 's;Group #-1;Group $(conf_group);' \
+			-e 's;Port 80;Port $(conf_port);' \
+			-e 's;ServerAdmin you@your.address;ServerAdmin $(conf_serveradmin);' \
+			-e 's;ServerName new.host.name;ServerName $(conf_servername);' \
         	> $(TOP)/$(SRC)/.apaci.install.tmp && \
 		echo "$(INSTALL_DATA) $(TOP)/conf/$${conf}-dist[*] $(root)$(sysconfdir)/$${conf}.default"; \
 		$(INSTALL_DATA) $(TOP)/$(SRC)/.apaci.install.tmp $(root)$(sysconfdir)/$${conf}.default; \
 		if [ ! -f "$(root)$(sysconfdir)/$${conf}" ]; then \
 			echo "$(INSTALL_DATA) $(TOP)/conf/$${conf}-dist[*] $(root)$(sysconfdir)/$${conf}"; \
 			$(INSTALL_DATA) $(TOP)/$(SRC)/.apaci.install.tmp $(root)$(sysconfdir)/$${conf}; \
@@ -419,17 +432,17 @@
 clean-std:
 	@cd $(TOP)/$(SRC); $(MAKE) $(MFLAGS) SDP=$(SRC)/ clean
 
 #   clean additional support stuff
 clean-support:
 	@echo "===> $(SRC)/support"; \
-	    cd $(TOP)/$(SRC)/support; $(MAKE) $(MFLAGS) clean; \
-	    if [ ".$(suexec)" = .1 ]; then \
+	cd $(TOP)/$(SRC)/support; $(MAKE) $(MFLAGS) clean; \
+	if [ ".$(suexec)" = .1 ]; then \
 	        echo "$(RM) suexec"; \
 	        $(RM) suexec; \
-	    fi; \
+	fi; \
 	echo "<=== $(SRC)/support"
 
 #   cleanup the source tree by removing anything which was
 #   created by the configure step and the build target.
 #   When --shadow is used we just remove the complete shadow tree.
 distclean:
@@ -444,12 +457,13 @@
 	@$(MAKE) -f $(MKF) $(MFLAGS) $(MFWD) distclean-std $(distclean-support)
 	@echo "<=== $(SRC)"
 	-$(RM) $(SRC)/Configuration.apaci
 	-$(RM) $(SRC)/apaci
 	@$(RM) $(SRC)/.apaci.build.ok
 	-$(RM) Makefile
+	-$(RM) config.status
 
 #   clean the standard stuff
 distclean-std:
 	@cd $(TOP)/$(SRC); $(MAKE) $(MFLAGS) SDP=$(SRC)/ distclean
 
 distclean-support:
diff -BEr -U 6 apache_1.3.0/README.configure apache_1.3.1/README.configure
--- apache_1.3.0/README.configure	1998-05-30 23:24:59.000000000 +0800
+++ apache_1.3.1/README.configure	1998-06-28 23:42:21.000000000 +0800
@@ -15,12 +15,16 @@
 
     $ gunzip <apache-1.3.X.tar.gz | tar xvf -
     $ ./configure --prefix=PREFIX [...]
     $ make
     $ make install
   
+  NOTE: PREFIX is not the string "PREFIX". Instead use the Unix
+        filesystem path under which Apache should be installed. For
+        instance use "/usr/local/apache" for PREFIX above.
+
   After these steps Apache 1.3 is completely installed under PREFIX and
   already initially configured, so you can immediately fire it up the first
   time via
 
     $ PREFIX/sbin/apachectl start
 
Only in apache_1.3.0/src/ap: ap_cpystrn.o
diff -BEr -U 6 apache_1.3.0/src/ap/ap.dsp apache_1.3.1/src/ap/ap.dsp
--- apache_1.3.0/src/ap/ap.dsp	1998-02-05 21:09:30.000000000 +0800
+++ apache_1.3.1/src/ap/ap.dsp	1998-06-24 03:16:29.000000000 +0800
@@ -90,16 +90,12 @@
 SOURCE=.\ap_slack.c
 # End Source File
 # Begin Source File
 
 SOURCE=.\ap_snprintf.c
 # End Source File
-# Begin Source File
-
-SOURCE=.\ap_strings.c
-# End Source File
 # End Group
 # Begin Group "Header Files"
 
 # PROP Default_Filter ""
 # End Group
 # End Target
Only in apache_1.3.0/src/ap: ap_execve.o
diff -BEr -U 6 apache_1.3.0/src/ap/ap.mak apache_1.3.1/src/ap/ap.mak
--- apache_1.3.0/src/ap/ap.mak	1998-02-05 21:09:30.000000000 +0800
+++ apache_1.3.1/src/ap/ap.mak	1998-06-24 03:16:30.000000000 +0800
@@ -47,13 +47,12 @@
 
 CLEAN :
 	-@erase "$(INTDIR)\ap_cpystrn.obj"
 	-@erase "$(INTDIR)\ap_signal.obj"
 	-@erase "$(INTDIR)\ap_slack.obj"
 	-@erase "$(INTDIR)\ap_snprintf.obj"
-	-@erase "$(INTDIR)\ap_strings.obj"
 	-@erase "$(INTDIR)\vc50.idb"
 	-@erase "$(OUTDIR)\ap.lib"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
@@ -68,14 +67,13 @@
 LIB32=link.exe -lib
 LIB32_FLAGS=/nologo /out:"$(OUTDIR)\ap.lib" 
 LIB32_OBJS= \
 	"$(INTDIR)\ap_cpystrn.obj" \
 	"$(INTDIR)\ap_signal.obj" \
 	"$(INTDIR)\ap_slack.obj" \
-	"$(INTDIR)\ap_snprintf.obj" \
-	"$(INTDIR)\ap_strings.obj"
+	"$(INTDIR)\ap_snprintf.obj"
 
 "$(OUTDIR)\ap.lib" : "$(OUTDIR)" $(DEF_FILE) $(LIB32_OBJS)
     $(LIB32) @<<
   $(LIB32_FLAGS) $(DEF_FLAGS) $(LIB32_OBJS)
 <<
 
@@ -99,13 +97,12 @@
 
 CLEAN :
 	-@erase "$(INTDIR)\ap_cpystrn.obj"
 	-@erase "$(INTDIR)\ap_signal.obj"
 	-@erase "$(INTDIR)\ap_slack.obj"
 	-@erase "$(INTDIR)\ap_snprintf.obj"
-	-@erase "$(INTDIR)\ap_strings.obj"
 	-@erase "$(INTDIR)\vc50.idb"
 	-@erase "$(OUTDIR)\ap.lib"
 
 "$(OUTDIR)" :
     if not exist "$(OUTDIR)/$(NULL)" mkdir "$(OUTDIR)"
 
@@ -120,14 +117,13 @@
 LIB32=link.exe -lib
 LIB32_FLAGS=/nologo /out:"$(OUTDIR)\ap.lib" 
 LIB32_OBJS= \
 	"$(INTDIR)\ap_cpystrn.obj" \
 	"$(INTDIR)\ap_signal.obj" \
 	"$(INTDIR)\ap_slack.obj" \
-	"$(INTDIR)\ap_snprintf.obj" \
-	"$(INTDIR)\ap_strings.obj"
+	"$(INTDIR)\ap_snprintf.obj"
 
 "$(OUTDIR)\ap.lib" : "$(OUTDIR)" $(DEF_FILE) $(LIB32_OBJS)
     $(LIB32) @<<
   $(LIB32_FLAGS) $(DEF_FLAGS) $(LIB32_OBJS)
 <<
 
@@ -163,79 +159,190 @@
    $(CPP_PROJ) $< 
 <<
 
 
 !IF "$(CFG)" == "ap - Win32 Release" || "$(CFG)" == "ap - Win32 Debug"
 SOURCE=.\ap_cpystrn.c
+
+!IF  "$(CFG)" == "ap - Win32 Release"
+
+DEP_CPP_AP_CP=\
+	"..\include\alloc.h"\
+	"..\include\ap.h"\
+	"..\include\buff.h"\
+	"..\include\conf.h"\
+	"..\include\hsregex.h"\
+	"..\include\httpd.h"\
+	"..\include\util_uri.h"\
+	"..\os\win32\os.h"\
+	"..\os\win32\readdir.h"\
+	{$(INCLUDE)}"sys\stat.h"\
+	{$(INCLUDE)}"sys\types.h"\
+	
+NODEP_CPP_AP_CP=\
+	"..\include\ebcdic.h"\
+	"..\include\os.h"\
+	"..\include\sfio.h"\
+	
+
+"$(INTDIR)\ap_cpystrn.obj" : $(SOURCE) $(DEP_CPP_AP_CP) "$(INTDIR)"
+
+
+!ELSEIF  "$(CFG)" == "ap - Win32 Debug"
+
 DEP_CPP_AP_CP=\
 	"..\include\alloc.h"\
 	"..\include\ap.h"\
 	"..\include\buff.h"\
 	"..\include\conf.h"\
 	"..\include\hsregex.h"\
 	"..\include\httpd.h"\
+	"..\include\util_uri.h"\
 	"..\os\win32\os.h"\
 	"..\os\win32\readdir.h"\
 	
 
 "$(INTDIR)\ap_cpystrn.obj" : $(SOURCE) $(DEP_CPP_AP_CP) "$(INTDIR)"
 
 
+!ENDIF 
+
 SOURCE=.\ap_signal.c
+
+!IF  "$(CFG)" == "ap - Win32 Release"
+
+DEP_CPP_AP_SI=\
+	"..\include\alloc.h"\
+	"..\include\ap.h"\
+	"..\include\buff.h"\
+	"..\include\conf.h"\
+	"..\include\hsregex.h"\
+	"..\include\httpd.h"\
+	"..\include\util_uri.h"\
+	"..\os\win32\os.h"\
+	"..\os\win32\readdir.h"\
+	{$(INCLUDE)}"sys\stat.h"\
+	{$(INCLUDE)}"sys\types.h"\
+	
+NODEP_CPP_AP_SI=\
+	"..\include\ebcdic.h"\
+	"..\include\os.h"\
+	"..\include\sfio.h"\
+	
+
+"$(INTDIR)\ap_signal.obj" : $(SOURCE) $(DEP_CPP_AP_SI) "$(INTDIR)"
+
+
+!ELSEIF  "$(CFG)" == "ap - Win32 Debug"
+
 DEP_CPP_AP_SI=\
 	"..\include\alloc.h"\
 	"..\include\ap.h"\
 	"..\include\buff.h"\
 	"..\include\conf.h"\
 	"..\include\hsregex.h"\
 	"..\include\httpd.h"\
+	"..\include\util_uri.h"\
 	"..\os\win32\os.h"\
 	"..\os\win32\readdir.h"\
 	
 
 "$(INTDIR)\ap_signal.obj" : $(SOURCE) $(DEP_CPP_AP_SI) "$(INTDIR)"
 
 
+!ENDIF 
+
 SOURCE=.\ap_slack.c
+
+!IF  "$(CFG)" == "ap - Win32 Release"
+
 DEP_CPP_AP_SL=\
 	"..\include\alloc.h"\
 	"..\include\ap.h"\
 	"..\include\buff.h"\
 	"..\include\conf.h"\
 	"..\include\hsregex.h"\
 	"..\include\http_log.h"\
 	"..\include\httpd.h"\
+	"..\include\util_uri.h"\
 	"..\os\win32\os.h"\
 	"..\os\win32\readdir.h"\
+	{$(INCLUDE)}"sys\stat.h"\
+	{$(INCLUDE)}"sys\types.h"\
+	
+NODEP_CPP_AP_SL=\
+	"..\include\ebcdic.h"\
+	"..\include\os.h"\
+	"..\include\sfio.h"\
 	
 
 "$(INTDIR)\ap_slack.obj" : $(SOURCE) $(DEP_CPP_AP_SL) "$(INTDIR)"
 
 
+!ELSEIF  "$(CFG)" == "ap - Win32 Debug"
+
+DEP_CPP_AP_SL=\
+	"..\include\alloc.h"\
+	"..\include\ap.h"\
+	"..\include\buff.h"\
+	"..\include\conf.h"\
+	"..\include\hsregex.h"\
+	"..\include\http_log.h"\
+	"..\include\httpd.h"\
+	"..\include\util_uri.h"\
+	"..\os\win32\os.h"\
+	"..\os\win32\readdir.h"\
+	
+
+"$(INTDIR)\ap_slack.obj" : $(SOURCE) $(DEP_CPP_AP_SL) "$(INTDIR)"
+
+
+!ENDIF 
+
 SOURCE=.\ap_snprintf.c
+
+!IF  "$(CFG)" == "ap - Win32 Release"
+
 DEP_CPP_AP_SN=\
+	"..\include\alloc.h"\
+	"..\include\ap.h"\
+	"..\include\buff.h"\
 	"..\include\conf.h"\
 	"..\include\hsregex.h"\
+	"..\include\httpd.h"\
+	"..\include\util_uri.h"\
 	"..\os\win32\os.h"\
+	"..\os\win32\readdir.h"\
+	{$(INCLUDE)}"sys\stat.h"\
+	{$(INCLUDE)}"sys\types.h"\
+	
+NODEP_CPP_AP_SN=\
+	"..\include\ebcdic.h"\
+	"..\include\os.h"\
+	"..\include\sfio.h"\
 	
 
 "$(INTDIR)\ap_snprintf.obj" : $(SOURCE) $(DEP_CPP_AP_SN) "$(INTDIR)"
 
 
-SOURCE=.\ap_strings.c
-DEP_CPP_AP_ST=\
+!ELSEIF  "$(CFG)" == "ap - Win32 Debug"
+
+DEP_CPP_AP_SN=\
 	"..\include\alloc.h"\
 	"..\include\ap.h"\
 	"..\include\buff.h"\
 	"..\include\conf.h"\
 	"..\include\hsregex.h"\
 	"..\include\httpd.h"\
+	"..\include\util_uri.h"\
 	"..\os\win32\os.h"\
 	"..\os\win32\readdir.h"\
 	
 
-"$(INTDIR)\ap_strings.obj" : $(SOURCE) $(DEP_CPP_AP_ST) "$(INTDIR)"
+"$(INTDIR)\ap_snprintf.obj" : $(SOURCE) $(DEP_CPP_AP_SN) "$(INTDIR)"
+
 
+!ENDIF 
 
 
 !ENDIF 
 
Only in apache_1.3.0/src/ap: ap_signal.o
diff -BEr -U 6 apache_1.3.0/src/ap/ap_slack.c apache_1.3.1/src/ap/ap_slack.c
--- apache_1.3.0/src/ap/ap_slack.c	1998-04-11 20:00:17.000000000 +0800
+++ apache_1.3.1/src/ap/ap_slack.c	1998-06-17 14:57:05.000000000 +0800
@@ -95,13 +95,13 @@
 	     * how libraries and such are going to fail.  If we can't
 	     * do this F_DUPFD there's a good chance that apache has too
 	     * few descriptors available to it.  Note we don't warn on
 	     * the high line, because if it fails we'll eventually try
 	     * the low line...
 	     */
-	    ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
 		        "unable to open a file descriptor above %u, "
 			"you may need to increase the number of descriptors",
 			LOW_SLACK_LINE);
 	    low_warned = 1;
 	}
 	return fd;
Only in apache_1.3.0/src/ap: ap_slack.o
diff -BEr -U 6 apache_1.3.0/src/ap/ap_snprintf.c apache_1.3.1/src/ap/ap_snprintf.c
--- apache_1.3.0/src/ap/ap_snprintf.c	1998-05-12 01:49:21.000000000 +0800
+++ apache_1.3.1/src/ap/ap_snprintf.c	1998-07-09 01:46:56.000000000 +0800
@@ -69,14 +69,18 @@
 #include <math.h>
 
 typedef enum {
     NO = 0, YES = 1
 } boolean_e;
 
+#ifndef FALSE
 #define FALSE			0
+#endif
+#ifndef TRUE
 #define TRUE			1
+#endif
 #define NUL			'\0'
 #define INT_NULL		((int *)0)
 #define WIDE_INT		long
 
 typedef WIDE_INT wide_int;
 typedef unsigned WIDE_INT u_wide_int;
@@ -281,13 +285,13 @@
 	    }
 
 #define NUM( c )			( c - '0' )
 
 #define STR_TO_DEC( str, num )		\
     num = NUM( *str++ ) ;		\
-    while ( isdigit( *str ) )		\
+    while ( ap_isdigit( *str ) )		\
     {					\
 	num *= 10 ;			\
 	num += NUM( *str++ ) ;		\
     }
 
 /*
@@ -441,13 +445,13 @@
     else			/* either e or E format */
 	p = ap_ecvt(num, precision + 1, &decimal_point, is_negative, buf1);
 
     /*
      * Check for Infinity and NaN
      */
-    if (isalpha(*p)) {
+    if (ap_isalpha(*p)) {
 	*len = strlen(strcpy(buf, p));
 	*is_negative = FALSE;
 	return (buf);
     }
 
     if (format == 'f') {
@@ -601,13 +605,13 @@
 
 	    fmt++;
 
 	    /*
 	     * Try to avoid checking for flags, width or precision
 	     */
-	    if (isascii(*fmt) && !islower(*fmt)) {
+	    if (!ap_islower(*fmt)) {
 		/*
 		 * Recognize flags: -, #, BLANK, +
 		 */
 		for (;; fmt++) {
 		    if (*fmt == '-')
 			adjust = LEFT;
@@ -623,13 +627,13 @@
 			break;
 		}
 
 		/*
 		 * Check if a width was specified
 		 */
-		if (isdigit(*fmt)) {
+		if (ap_isdigit(*fmt)) {
 		    STR_TO_DEC(fmt, min_width);
 		    adjust_width = YES;
 		}
 		else if (*fmt == '*') {
 		    min_width = va_arg(ap, int);
 		    fmt++;
@@ -649,13 +653,13 @@
 		 * resulting in overflow of num_buf. Currently we
 		 * ignore this possibility.
 		 */
 		if (*fmt == '.') {
 		    adjust_precision = YES;
 		    fmt++;
-		    if (isdigit(*fmt)) {
+		    if (ap_isdigit(*fmt)) {
 			STR_TO_DEC(fmt, precision);
 		    }
 		    else if (*fmt == '*') {
 			precision = va_arg(ap, int);
 			fmt++;
 			if (precision < 0)
Only in apache_1.3.0/src/ap: ap_snprintf.o
Only in apache_1.3.0/src/ap: ap_strings.c
Only in apache_1.3.0/src/ap: ap_strings.o
Only in apache_1.3.0/src/ap: libap.a
Only in apache_1.3.0/src/ap: Makefile
diff -BEr -U 6 apache_1.3.0/src/ap/Makefile.tmpl apache_1.3.1/src/ap/Makefile.tmpl
--- apache_1.3.0/src/ap/Makefile.tmpl	1998-05-10 21:04:30.000000000 +0800
+++ apache_1.3.1/src/ap/Makefile.tmpl	1998-07-13 19:32:32.000000000 +0800
@@ -3,13 +3,13 @@
 INCLUDES=$(INCLUDES1) $(INCLUDES0) $(EXTRA_INCLUDES)
 LDFLAGS=$(LDFLAGS1) $(EXTRA_LDFLAGS)
 
 LIB=libap.a
 
 OBJS=ap_execve.o ap_cpystrn.o ap_signal.o \
-     ap_slack.o ap_snprintf.o ap_strings.o
+     ap_slack.o ap_snprintf.o
 
 .c.o:
 	$(CC) -c $(INCLUDES) $(CFLAGS) $<
 
 all: $(LIB)
 
@@ -36,24 +36,26 @@
 	    && sed -e '1,$$s: $(INCDIR)/: $$(INCDIR)/:g' \
 	           -e '1,$$s: $(OSDIR)/: $$(OSDIR)/:g' Makefile.new \
 		> Makefile.tmpl \
 	    && rm Makefile.new
 
 # DO NOT REMOVE
-ap_cpystrn.o: ap_cpystrn.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h
-ap_execve.o: ap_execve.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h
-ap_signal.o: ap_signal.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h
-ap_slack.o: ap_slack.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_log.h
-ap_snprintf.o: ap_snprintf.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h
-ap_strings.o: ap_strings.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h
+ap_cpystrn.o: ap_cpystrn.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h
+ap_execve.o: ap_execve.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h
+ap_signal.o: ap_signal.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h
+ap_slack.o: ap_slack.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_log.h
+ap_snprintf.o: ap_snprintf.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h
Only in apache_1.3.0/src: apaci
diff -BEr -U 6 apache_1.3.0/src/buildmark.c apache_1.3.1/src/buildmark.c
--- apache_1.3.0/src/buildmark.c	1998-05-07 20:24:23.000000000 +0800
+++ apache_1.3.1/src/buildmark.c	1998-07-13 19:32:29.000000000 +0800
@@ -52,13 +52,13 @@
  * Supercomputing Applications, University of Illinois, Urbana-Champaign.
  * For more information on the Apache Group and the Apache HTTP server
  * project, please see <http://www.apache.org/>.
  *
  */
 
-#include "conf.h"
+#include "ap_config.h"
 #include "httpd.h"
 
 #if defined(__DATE__) && defined(__TIME__)
 static const char server_built[] = __DATE__ " " __TIME__;
 #else
 static const char server_built[] = "unknown";
diff -BEr -U 6 apache_1.3.0/src/CHANGES apache_1.3.1/src/CHANGES
--- apache_1.3.0/src/CHANGES	1998-05-31 03:15:37.000000000 +0800
+++ apache_1.3.1/src/CHANGES	1998-07-19 06:50:15.000000000 +0800
@@ -1,7 +1,336 @@
-Changes with Apache 1.3b8
+Changes with Apache 1.3.1
+
+  *) Disable the incorrect entry for application/msword in the 
+     mod_mime_magic "magic" file because it also matches other Office
+     documents.  [Ralf S. Engelschall] PR#2608
+
+  *) Fix broken RANLIB handling in src/Configure (the entry from
+     src/Configuration.tmpl was ignored) and additionally force RANLIB to
+     /bin/true under HP/UX where ranlib exists but is deprecated.
+     [Ralf S. Engelschall] PR#2627
+     
+  *) 'apachectl status' failed on some systems.
+     [Steve VanDevender <stevev@darkwing.uoregon.edu>, Lars Eilebrecht] PR#2613
+
+  *) Add new flags for ap_unparse_uri_components() to make it generate
+     the scheme://sitepart string only, or to omit the query string.
+     [Martin Kraemer]
+
+  *) WIN32: Canonicalize ServerRoot before checking to see if it
+     is a valid directory.  The failure to do this caused certain
+     ServerRoot settings (eg. "ServerRoot /apache") to be improperly
+     rejected.  [Marc Slemko]
+
+  *) Global renaming of C header files to both get rid of conflicts with third
+     party packages and to again reach consistency:
+       1. conf.h      -> ap_config.h
+       2. conf_auto.h -> ap_config_auto.h \ these are now merged
+       3. ap_config.h -> ap_config_auto.h / in the config process
+       4. compat.h    -> ap_compat.h
+       5. apctype.h   -> ap_ctype.h
+     Backward compatibility files for conf.h and compat.h were created.
+
+  *) mod_mmap_static will no longer take action on requests unless at 
+     least one "mmapfile" directive is present in the configuration. 
+     This experimental module has to do some black magic to operate 
+     inside the current API and thus creates side-effects for other 
+     modules under some circumstances.
+     [Ralf S. Engelschall]
+ 
+  *) Add conservative ticks around more egrep arguments in top-level configure
+     to avoid problems under brain-dead platforms like Digital Unix (OSF1).
+     [Ralf S. Engelschall] PR#2596
+
+  *) mod_rewrite created RewriteLock files under the UID of the parent
+     process, thus the child processes had no write access to the files.
+     Now a chown() is done on the file to the uid of the children,
+     if applicable.  [Lars Eilebrecht, Ralf S. Engelschall] PR#2341
+
+  *) Autogenerate some HAVE_XXXXX_H defines in conf_auto.h (determined via
+     TestCompile) instead of defining them manually in conf.h based on less
+     accurate platform definitions.  This way we no longer have to fiddle with
+     OS-type and/or OS-version identifiers to discover whether a system header
+     file exists or not.  Instead we now directly check for the existence of
+     those esoteric ones. 
+     [Ralf S. Engelschall] PR#2093, PR#2361, PR#2377, PR#2434,
+                           PR#2524, PR#2525, PR#2533, PR#2569
+
+  *) mod_setenvif (BrowserMatch* and friends) will now match a missing
+     field with "^$".  [Ken Coar]
+
+  *) Set the RTLD_GLOBAL dlopen mode parameter to allow dynamically loaded
+     modules to load their own modules dynamically.  This improves mod_perl
+     and mod_php3 when these modules are loaded dynamically into Apache.
+     [Rasmus Lerdorf]
+
+  *) Cache a proxied request in the event that the client cancels the
+     transfer, provided that the configured percentage of the file has
+     already been transfered. It works for HTTP transfers only.  The 
+     new configuration directive is called CacheForceCompletion. 
+     [Glen Parker <glenebob@nwlink.com>] PR#2277
+
+  *) Add the "<!DOCTYPE HTML" magic cookie used by modern documents (and
+     required by HTML 3.2 and later) to mod_mime_magic's conf/magic.
+     [Anna Shergold <anna@inext.co.uk>]
+
+  *) Fix yet another signal-based race condition involving nested timers.
+     Signals suck.  [Dean Gaudet]
+
+  *) suexec's error messages have been clarified a little bit.  [Ken Coar]
+
+  *) Clean up some, but perhaps not all, 8-bit character set problems
+     with config file parsing, and URL parsing.  We now define
+     ap_isdigit(), ap_isupper(), ... which cast to an (unsigned char).
+     This should work on most modern unixes.
+     [Dean Gaudet] PR#800, 2282, 2553  (and others)
+
+  *) The "handler not found" error was issued in cases where the handler
+     really did exist, but was just declining to serve the request.
+     [John Van Essen <jve@gamers.org>] PR#2529
+
+  *) Add Dynamic Shared Object (DSO) support for SCO5 (OpenServer 5.0.x).
+     [Ronald Record <rr@sco.com>] PR#2533
+
+  *) The APACI libexecdir was not extended with an "apache/" subdir
+     if the installation prefix didn't already contain "apache", but
+     it should be because the DSO files are Apache-specific.  Now
+     libexecdir is treated the same way sysconfdir, datadir, localstatedir
+     and includedir are already treated.
+     [Charles Levert <charles@comm.polymtl.ca>] PR#2551
+
+  *) The <Limit> parsing routine was incorrectly treating methods as
+     case-insensitive.  [Ken Coar]
+
+  *) The ap_bprintf() code neglected to test if there was an error on
+     the connection.  ap_bflush() misdiagnosed a failure as a success.
+     [Dean Gaudet]
+
+  *) add support for #perl arg interpolation in mod_include
+     [Doug MacEachern]
+
+  *) API: Name changes of table_elts to ap_table_elts, is_table_empty
+     to ap_is_table_empty and bgetflag to ap_bgetflag. [Ben Laurie]
+
+  *) PORT: Add UnixWare 7 support
+     [Vadim Kostoglodoff <vadim@olly.ru>] PR#2463
+
+  *) Fix the Guess-DSO-flags-from-Perl stuff in src/Configure: "perl" was
+     used instead of "$PERL" which contains the correctly determined Perl
+     interpreter (important for instance on systems where "perl" and "perl5"
+     exists, like BSDI or FreeBSD, etc).
+     [Ralf S. Engelschall] PR#2505
+
+  *) Move the initial suEXEC-related startup message from plain
+     fprintf()/stderr to a delayed ap_log_error()-based one to avoid problems
+     when Apache is started from inetd (instead of standalone). Under this
+     situation startup messages on stderr lead to problems (the line is sent
+     to the client in front of the requested document).
+     [Ralf S. Engelschall] PR#871, PR#1318
+
+  *) Add a flag so ap_fnmatch() can be used for case-blind pattern matching.
+     [Ken Coar, Dean Gaudet]
+
+  *) WIN32: Don't collapse multiple slashes in PATH_INFO.
+     [Ben Laurie, Bill Stoddard <wgstodda@us.ibm.com>] PR#2274
+
+  *) WIN32 SECURITY: Eliminate trailing "."s in path components. These are
+     ignored by the Windows filesystem, and so can be used to bypass security.
+     [Ben Laurie, Alexei Kosut].
+
+  *) We now attempt to dump core when we get SIGILL. [Jim Jagielski]
+
+  *) PORT: remove broken test for MAP_FILE in http_main.c.
+     [Wilfredo Sanchez <wsanchez@apple.com>]
+
+  *) PORT: Change support/apachectl to use "kill -0 $pid" to test if the
+     httpd is running.  This should be more portable than figuring out
+     which of three dozen different versions of "ps" are installed.
+     [a cast of dozens]
+
+  *) WIN32: If we can't figure out how to execute a file in a script
+     directory, bail out of the request with an error message.  [W G Stoddard]
+
+  *) WIN32 SECURITY: Eliminate directories consisting of three or more dots;
+     these are treated by Win32 as if they are ".." but are not detected by
+     other machinery within Apache. This is something of a kludge but
+     eliminates a security hole. [Manoj Kasichainula, Ben Laurie]
+
+  *) Move ap_escape_quotes() from src/ap to src/main/util.c; it uses
+     pools and thus pollutes libap (until the pool stuff is moved there).
+     [Ken Coar]
+
+  *) IndexIgnore should be case-blind on Win32 (and any other case-aware
+     but case-insensitive platforms).  New #define for this added to conf.h
+     (CASE_BLIND_FILESYSTEM).  [Ken Coar] PR#2455
+
+  *) Enable DSO support for OpenBSD in general, not only for 2.x, because it
+     also works for OpenBSD 1.x. [Ralf S. Engelschall]
+
+  *) PORT: Fix compilation problem on ARM Linux.
+     [Sam Kington <sam@illuminated.co.uk>] PR#2443
+
+  *) Let APACI's configure script determine some configuration parameters
+     (Group, Port, ServerAdmin, ServerName) via some intelligent tests to
+     remove some of the classical hurdles for new users when setting up
+     Apache. This is done per default because it is useful for the average
+     user. Package authors can use the --without-confadjust option to disable
+     these configuration adjustments.
+     [Ralf S. Engelschall]
+
+  *) Added an EXTRA_DEPS configuration parameter which can be used
+     to add an extra Makefile dependency for the httpd target, for instance
+     to external third-party libraries, etc.
+     [Ralf S. Engelschall]
+
+  *) Add <IfDefine>..</IfDefine> sections to the core module (with same spirit
+     as <IfModule>..</IfModule> sections) which can be used to skip or process
+     contained commands dependend of ``-D PARAMETER'' options on the command
+     line. This can be used to achieve logical conditions like <IfDefine
+     ReverseProxy> instead of physically ones (e.g. <IfModule mod_proxy.c>)
+     and thus especially can be used for conditionally loading DSO-based
+     modules via LoadModule, etc. [Ralf S. Engelschall]
+
+  *) PORT: clean up a warning in mod_status for OS/2.  [Brian Havard]
+
+  *) Make table elements const. This may prevent obscure errors. [Ben Laurie]
+
+  *) Fix parsing of FTP `SIZE' responses in proxy module: The newline was not
+     truncated which forced following HTTP headers to be data in the HTTP
+     reponse. [Ralf S. Engelschall, Charles Fu <ccwf@bacchus.com>] 
+     PR#2412, 2367
+
+  *) Portability fix for APACI shadow tree support: Swap order of awk and sed
+     in top-level configure script to avoid sed fails on some platforms (for
+     instance SunOS 4.1.3 and NCR SysV) because of the non-newline-termined
+     output of Awk. [Bill Houle <bhoule@sandiegoca.ncr.com>] PR#2435
+
+  *) Improve performance of directory listings (mod_autoindex) by comparing
+     integer keys (last-modified and size) as integers rather than converting
+     them to strings first.  Also use a set of explicit byte tests rather
+     than strcmp() to check for parent directory-ness of an entry.  Oh, and
+     make sure the parent directory (if displayed) is *always* listed first
+     regardless of the sort key.  Overall performance winnage should be good
+     in CPU time, instruction cache, and memory usage, particularly for large
+     directories.  [Ken Coar]
+
+  *) Add a tiny but useful goody to APACI's configure script: The generation
+     of a config.status script (as GNU Autoconf does) which remembers the used
+     configure command and hence can be used to restore the configuration by
+     just re-running this script or for remembering the configuration between
+     releases.
+     [Ralf S. Engelschall]
+
+  *) Add httpd -t (test) option for running configuration syntax tests only.
+     If something is broken it complains and exits with a return code
+     non-equal to 0. This can be used manually by the user to check the Apache
+     configuration after editing and is also automatically used by apachectl
+     on (graceful) restart command to make sure Apache doesn't die on restarts
+     because of a configuration which is now broken since the last (re)start.
+     This way `apachectl restart' can be used inside cronjobs without having
+     to expect Apache to be falling down. Additionally the httpd -t can be run
+     via `apachectl configtest'.
+     [Ralf S. Engelschall] PR#2393
+  
+  *) Minor display fix for "install" target of top-level Makefile:
+     the displayed installation command was incorrect although the
+     executed command was correct. Now they are in sync.
+     [Ralf S. Engelschall] PR#2402
+
+  *) Correct initialization of variable `allowed_globals' in http_main.c
+     [Justin Bradford <justin@ukans.edu>] PR#2400
+
+  *) Apache would incorrectly downcase the entire Content-Type passed from
+     CGIs.  This affected server-push scripts and such which use
+     multipart/x-mixed-replace;boundary=ThisRandomString.
+     [Dean Gaudet] PR#2394
+
+  *) PORT: QNX update to properly guess 32-bit systems.
+     [Sean Boudreau <seanb@qnx.com>] PR#2390
+
+  *) Make sure the DSO emulation code for HPUX finds the proprietary shl_xxx()
+     functions which are in libdld under HPUX 9/10.
+     [Ralf S. Engelschall] PR#2378
+
+  *) Make sure the "install" target of the top-level Makefile doesn't break
+     because of a return code of 1 from an "if" (for instance under braindead
+     Ultrix the result code of an "if" construct is 1 if the "then" clause
+     didn't match). [Ralf S. Engelschall]
+
+  *) Add an additional "dummy" target to the "$(LIB)" target in generated
+     modules/xxx/Makefile's to avoid problems with SVR4 Make under "full-DSO"
+     situation (no libxxx.a built, only mod_xxx.so's) where LIB and OBJS are
+     empty. [Ralf S. Engelschall, Dean Gaudet, Martin Kraemer]
+
+  *) Replace two bad sprintf() calls with ap_snprintf() variants in
+     mod_rewrite. [Ralf S. Engelschall]
+
+  *) Fix missing usage description for MetaFiles directive.
+     [David MacKenzie <djm@va.pubnix.com>] PR#2384
+
+  *) mod_log_config wouldn't let vhosts use log formats defined in the
+     main server.  [Christof Damian <damian@mediaconsult.com>] PR#2090
+
+  *) mod_usertrack was corrupting the client hostname.  As part of the
+     fix, the cookie values were slightly extended to include the
+     fully qualified hostname of the client.
+     [Dean Gaudet] PR#2190, 2229, 2366
+
+  *) Fix a typo in pool debugging code.  [Alvaro Martinez Echevarria]
+
+  *) mod_unique_id did not work on alpha linux (in general on any
+     architecture that has 64-bit time_t).
+     [Alvaro Martinez Echevarria]
+
+  *) PORT: Make SCO 5 (and probably 3) compile again. [Ben Laurie]
+
+  *) PORT: NCR MPRAS systems have the same bug with SIGHUP restart that
+     Solaris systems experience.  So define WORKAROUND_SOLARIS_BUG.
+     [Klaus Weber <kweber@chephren.germany.ncr.com>] PR#1973
+
+  *) Change "Options None" to "Options FollowSymLinks" in the 
+     <Directory /> section of the default access.conf-dist
+     (and -win even though it doesn't matter there).  This has better
+     performance, and more intuitive semantics.  [Dean Gaudet]
+
+  *) PORT: Updated support for UTS 2.1.2.
+     [Dave Dykstra <dwd@bell-labs.com>] PR#2320
+
+  *) Fix symbol export list (src/support/httpd.exp) after recent
+     API changes in the child spawning area.
+     [Jens-Uwe Mager <jum@helios.de>]
+
+  *) Workaround for configure script and old `test' commands which do not
+     support the -x flag (for instance under platforms like Ultrix). This is
+     solved by another helper script findprg.sh which searches for Perl and
+     Awk like PrintPath but _via different names_.
+     [Ralf S. Engelschall]
+
+  *) Remove the system() call from htpasswd.c, which eliminates a system
+     dependancy.  ["M.D.Parker" <mdpc@netcom.com>] PR#2332
+
+  *) PORT: Fix compilation failures on NEXTSTEP.
+     [Rex Dieter <rdieter@math.unl.edu>] PR#2293, 2316
+
+  *) PORT: F_NDELAY is a typo, should have been FNDELAY.  There's also
+     O_NDELAY on various systems.  [Dave Dykstra <dwd@bell-labs.com>] PR#2313
+
+  *) PORT: helpers/GuessOS updates for various versions for NCR SVR4.
+     [juerg schreiner <j.schreiner@zh.ch>,
+     Bill Houle <Bill.Houle@SanDiegoCA.NCR.COM>] PR#2310
+
+  *) Fix recently introduced Win32 child spawning code in mod_rewrite.c which
+     was broken because of invalid ap_pstrcat() -> strcat() transformation.
+     [Ralf S. Engelschall]
+
+  *) Proxy Cache Fixes: account for directory sizes, fork off garbage collection
+     to continue in background, use predefined types (off_t, size_t, time_t),
+     log the current cache usage percentage at LogLevel debug
+     [Martin Kraemer, based on discussion between Dean Gaudet & Dirk vanGulik]
+
+Changes with Apache 1.3.0
 
   *) Using a type map file as a custom error document was not possible.
      [Lars Eilebrecht] PR#1031
 
   *) Avoid problems with braindead Awks by additionally searching for gawk 
      and nawk in APACI's configure script.
@@ -60,13 +389,13 @@
      cgi-env-var REDIRECT_ERROR_NOTES for use by ErrorDocuments.
      The old proxy special error routine ap_proxy_log_uerror()
      was replaced by regular ap_log_error() calls, many messages were made
      more informative. 
      [Martin Kraemer] PR#494, 1259
 
-  *) [SECURITY] A possible buffer overflow in the ftp proxy was fixed.
+  *) SECURITY: A possible buffer overflow in the ftp proxy was fixed.
      [Martin Kraemer]
 
   *) Transform the configure message "You need root privileges for suEXEC"
      from a fatal error into a (more friendly) warning because the building
      ("make") of Apache we can allow, of course. Root privileges are needed
      only for the installation step ("make install"). So make sure the
@@ -206,20 +535,21 @@
 
   *) Apache will now log the reason its httpd children exit if they exit
      due to an unexpected signal.  (It requires a new porting define,
      SYS_SIGLIST, which if defined should point to a list of text
      descriptions of the signals available.  See PORTING.)  [Dean Gaudet]
 
-  *) chdir() doesn't make sense in a multithreaded environment like WIN32.
-     Before, Win32 CGI's could have had sporadic failures if a chdir call
-     from one thread was made between another chdir call and a spawn in
-     another thread.  So, for now don't chdir for CGI scripts in WIN32.
-     The current CGI "spec" is unclear as to whether it's necessary.  Long-
-     term fix is to either serialize the chdir/spawn combo or use WIN32
-     native calls to spawn a process.  This temp fix was necessary to remove 
-     this as a showstopper for 1.3's release. [Brian Behlendorf]
+  *) WIN32: chdir() doesn't make sense in a multithreaded environment 
+     like WIN32.  Before, Win32 CGI's could have had sporadic failures 
+     if a chdir call from one thread was made between another chdir call 
+     and a spawn in another thread.  So, for now don't chdir for CGI scripts 
+     in WIN32.  The current CGI "spec" is unclear as to whether it's 
+     necessary.  Long-term fix is to either serialize the chdir/spawn combo 
+     or use WIN32 native calls to spawn a process.  This temp fix was 
+     necessary to remove this as a showstopper for 1.3's release. 
+     [Brian Behlendorf]
 
   *) Cleanup the suEXEC support in APACI and make it more safe:
      1. Add big fat hint in INSTALL about risks and to read the
         htdocs/manual/suexec.html document before using the suexec-related
         configure options.
      2. Make sure the user has at least provided one --suexec-xxxx option
Only in apache_1.3.0/src: compile_commands.json
diff -BEr -U 6 apache_1.3.0/src/Configuration apache_1.3.1/src/Configuration
--- apache_1.3.0/src/Configuration	2017-09-16 15:35:38.284036649 +0800
+++ apache_1.3.1/src/Configuration	1998-07-19 07:03:37.000000000 +0800
@@ -44,16 +44,21 @@
 # Optimization note: 
 # Be careful when adding optimization flags (like -O3 or -O6) on the OPTIM
 # entry, especially when using some GCC variants. Experience showed that using
 # these for compiling Apache is risky. If you don't want to see Apache dumping
 # core regularly then at most use -O or -O2.
 #
+# The EXTRA_DEPS can be used to add extra Makefile dependencies to external
+# files (for instance third-party libraries) for the httpd target. The effect
+# is that httpd is relinked when those files are changed.
+#
 EXTRA_CFLAGS=
 EXTRA_LDFLAGS=
 EXTRA_LIBS=
 EXTRA_INCLUDES=
+EXTRA_DEPS=
 
 #CC=
 #OPTIM=
 #RANLIB=
 
 ################################################################
@@ -180,12 +185,19 @@
 # configuration.  If you want the functionality provided by a particular
 # module, remove the "#" sign at the beginning of the line. But remember, 
 # the more modules you compile into the server, the larger the executable
 # is and the more memory it will take, so if you are unlikely to use the
 # functionality of a particular module you might wish to leave it out.
 
+## mod_mmap_static is an experimental module, you almost certainly
+## don't need it.  It can make some webservers faster.  No further
+## documentation is provided here because you'd be foolish
+## to use mod_mmap_static without reading the full documentation.
+
+# AddModule modules/experimental/mod_mmap_static.o
+
 ##
 ## Config manipulation modules
 ##
 ## mod_env sets up additional or restricted environment variables to be
 ## passed to CGI/SSI scripts.  It is listed first (lowest priority) since
 ## it does not do per-request stuff.
@@ -357,19 +369,12 @@
 ## This is an experimental feature at this stage and only supported 
 ## on a subset of the platforms we generally support. 
 ## Don't change this entry to a 'SharedModule' variant (Bootstrapping!)
 
 # AddModule modules/standard/mod_so.o
 
-## mod_mmap_static is an experimental module, you almost certainly
-## don't need it.  It can make some webservers faster.  No further
-## documentation is provided here because you'd be foolish
-## to use mod_mmap_static without reading the full documentation.
-
-# AddModule modules/experimental/mod_mmap_static.o
-
 ## mod_setenvif lets you set environment variables based on the HTTP header
 ## fields in the request; this is useful for conditional HTML, for example.
 ## Since it is also used to detect buggy browsers for workarounds, it
 ## should be the last (highest priority) module.
 
 AddModule modules/standard/mod_setenvif.o
Only in apache_1.3.0/src: Configuration.apaci
diff -BEr -U 6 apache_1.3.0/src/Configuration.tmpl apache_1.3.1/src/Configuration.tmpl
--- apache_1.3.0/src/Configuration.tmpl	1998-05-12 20:13:50.000000000 +0800
+++ apache_1.3.1/src/Configuration.tmpl	1998-07-12 00:44:33.000000000 +0800
@@ -44,16 +44,21 @@
 # Optimization note: 
 # Be careful when adding optimization flags (like -O3 or -O6) on the OPTIM
 # entry, especially when using some GCC variants. Experience showed that using
 # these for compiling Apache is risky. If you don't want to see Apache dumping
 # core regularly then at most use -O or -O2.
 #
+# The EXTRA_DEPS can be used to add extra Makefile dependencies to external
+# files (for instance third-party libraries) for the httpd target. The effect
+# is that httpd is relinked when those files are changed.
+#
 EXTRA_CFLAGS=
 EXTRA_LDFLAGS=
 EXTRA_LIBS=
 EXTRA_INCLUDES=
+EXTRA_DEPS=
 
 #CC=
 #OPTIM=
 #RANLIB=
 
 ################################################################
@@ -180,12 +185,19 @@
 # configuration.  If you want the functionality provided by a particular
 # module, remove the "#" sign at the beginning of the line. But remember, 
 # the more modules you compile into the server, the larger the executable
 # is and the more memory it will take, so if you are unlikely to use the
 # functionality of a particular module you might wish to leave it out.
 
+## mod_mmap_static is an experimental module, you almost certainly
+## don't need it.  It can make some webservers faster.  No further
+## documentation is provided here because you'd be foolish
+## to use mod_mmap_static without reading the full documentation.
+
+# AddModule modules/experimental/mod_mmap_static.o
+
 ##
 ## Config manipulation modules
 ##
 ## mod_env sets up additional or restricted environment variables to be
 ## passed to CGI/SSI scripts.  It is listed first (lowest priority) since
 ## it does not do per-request stuff.
@@ -357,19 +369,12 @@
 ## This is an experimental feature at this stage and only supported 
 ## on a subset of the platforms we generally support. 
 ## Don't change this entry to a 'SharedModule' variant (Bootstrapping!)
 
 # AddModule modules/standard/mod_so.o
 
-## mod_mmap_static is an experimental module, you almost certainly
-## don't need it.  It can make some webservers faster.  No further
-## documentation is provided here because you'd be foolish
-## to use mod_mmap_static without reading the full documentation.
-
-# AddModule modules/experimental/mod_mmap_static.o
-
 ## mod_setenvif lets you set environment variables based on the HTTP header
 ## fields in the request; this is useful for conditional HTML, for example.
 ## Since it is also used to detect buggy browsers for workarounds, it
 ## should be the last (highest priority) module.
 
 AddModule modules/standard/mod_setenvif.o
diff -BEr -U 6 apache_1.3.0/src/Configure apache_1.3.1/src/Configure
--- apache_1.3.0/src/Configure	1998-05-12 20:13:50.000000000 +0800
+++ apache_1.3.1/src/Configure	1998-07-18 18:51:52.000000000 +0800
@@ -255,17 +255,12 @@
 TARGET="httpd"
 SUBTARGET="target_static"
 SHLIB_SUFFIX_LIST=""
 AP_PRINTPATH=PrintPath
 export AP_PRINTPATH
 CAT="cat"
-if ./helpers/$AP_PRINTPATH -s ranlib; then
-    RANLIB="ranlib"
-else
-    RANLIB="true"
-fi
 
 ####################################################################
 ## Now we determine the OS/Platform automagically, thanks to
 ## GuessOS, a home-brewed OS-determiner ala config.guess
 ##
 ## We adjust CFLAGS, LIBS, LDFLAGS and INCLUDES (and other Makefile
@@ -360,30 +355,33 @@
 	OS='HI-UX'
 	CFLAGS="$CFLAGS -DHIUX"
 	;;
     *-hp-hpux11.*)
 	OS='HP-UX 11'
 	CFLAGS="$CFLAGS -DHPUX11"
+	RANLIB="/bin/true"
 	LIBS="$LIBS -lm -lpthread"
 	DEF_WANTHSREGEX=yes
 	;;
     *-hp-hpux10.*)
 	OS='HP-UX 10'
 	CFLAGS="$CFLAGS -DHPUX10"
+	RANLIB="/bin/true"
  	case "$PLAT" in
  	  *-hp-hpux10.01)
 	       # We know this is a problem in 10.01.
                # Not a problem in 10.20.  Otherwise, who knows?
                CFLAGS="$CFLAGS -DSELECT_NEEDS_CAST"
                ;;	     
  	esac
 	DEF_WANTHSREGEX=yes
 	;;
     *-hp-hpux*)
 	OS='HP-UX'
 	CFLAGS="$CFLAGS -DHPUX"
+	RANLIB="/bin/true"
 	DEF_WANTHSREGEX=yes
 	LIBS="$LIBS -lm"
 	;;
     *-sgi-irix64)
         # Note: We'd like to see patches to compile 64-bit, but for now...
 	echo "You are running 64-bit Irix. For now, we will compile 32-bit"
@@ -481,16 +479,25 @@
     *-openbsd*)
 	OS='OpenBSD'
 	DBM_LIB=""
 	;;
     *-next-nextstep*)
 	OS='NeXT'
+	OPTIM='-O'
 	CFLAGS="$CFLAGS -DNEXT"
 	DEF_WANTHSREGEX=yes
-	RANLIB="sleep 5; /bin/ranlib"
-	# ranlib on most NeXTs sets the time wrong. 5 secs wait does much good
+	;;
+    *-next-openstep*)
+	OS='Openstep for Mach'
+	CC='cc'
+	OPTIM='-O'
+	CFLAGS="$CFLAGS -DNEXT"
+	CFLAGS_SHLIB='-dynamic -fno-common'
+	LD_SHLIB='cc'
+	LDFLAGS_SHLIB='-dynamiclib -undefined warning'
+	DEF_WANTHSREGEX=yes
 	;;
     *-dec-osf*)
 	OS='DEC OSF/1'
 	CFLAGS="$CFLAGS -DOSF1"
 	LIBS="$LIBS -lm"
 	;;
@@ -572,12 +579,18 @@
     *-unixware212)
 	OS='UnixWare 2.1.2'
 	CFLAGS="$CFLAGS -DUW=212"
 	LIBS="$LIBS -lsocket -lnsl -lcrypt -lgen"
 	DBM_LIB=""
 	;;
+    *-unixware7)
+	OS='UnixWare 7'
+	CFLAGS="$CFLAGS -DUW=700"
+	LIBS="$LIBS -lsocket -lnsl -lcrypt -lgen"
+	DBM_LIB=""
+	;;
     maxion-*-sysv4*)
     	OS='SVR4'
 	CFLAGS="$CFLAGS -DSVR4"
 	DEF_WANTHSREGEX=yes
 	LIBS="$LIBS -lsocket -lnsl -lc -lgen"
 	;;
@@ -604,12 +617,18 @@
     *-tandem-sysv4*)
 	OS='SVR4'
 	CFLAGS="$CFLAGS -DSVR4"
 	LIBS="$LIBS -lsocket -lnsl"
 	DEF_WANTHSREGEX=yes
 	;;
+    *-ncr-sysv4)
+	OS='NCR MP/RAS'
+	CFLAGS="$CFLAGS -DSVR4 -DMPRAS"
+	LIBS="$LIBS -lsocket -lnsl -lc -L/usr/ucblib -lucb"
+	DEF_WANTHSREGEX=yes
+	;;
     *-sysv4*)
 	OS='SVR4'
 	CFLAGS="$CFLAGS -DSVR4"
 	LIBS="$LIBS -lsocket -lnsl -lc"
 	;;
     88k-encore-sysv4)
@@ -617,14 +636,15 @@
 	CFLAGS="$CFLAGS -DSVR4 -DENCORE"
 	DEF_WANTHSREGEX=yes
 	LIBS="$LIBS -lPW"
 	;;
     *-uts*)
 	OS='Amdahl UTS'
-	CFLAGS="$CFLAGS -Xa -eft -DUTS21"
+	CFLAGS="$CFLAGS -Xa -eft -DUTS21 -DUSEBCOPY"
 	LIBS="$LIBS -lsocket -lbsd -la"
+	DEF_WANTHSREGEX=yes
 	;;
     *-ultrix)
 	OS='ULTRIX'
 	CFLAGS="-DULTRIX"
 	DEF_WANTHSREGEX=yes
 	SHELL="/bin/sh5"
@@ -772,12 +792,13 @@
 fi
 
 ####################################################################
 ## Look for OPTIM and save for later
 ##
 TOPTIM=`egrep '^OPTIM=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+TRANLIB=`egrep '^RANLIB=' Makefile.config | tail -1 | awk -F= '{print $2}'`
 
 ####################################################################
 ## Check for user provided flags for shared object support
 ##
 TLD_SHLIB=`egrep '^LD_SHLIB=' Makefile.config | tail -1 | awk -F= '{print $2}'`
 TLDFLAGS_SHLIB=`egrep '^LDFLAGS_SHLIB=' Makefile.config | tail -1 | awk -F= '{print $2}'`
@@ -808,13 +829,13 @@
         *-freebsd*)
             CFLAGS_SHLIB="-fpic"
             LDFLAGS_SHLIB="-Bshareable"
             LDFLAGS_SHLIB_EXPORT=""
             SHLIB_SUFFIX_DEPTH=2
             ;;
-        *-openbsd2*)
+        *-openbsd*)
             CFLAGS_SHLIB="-fPIC"
             LDFLAGS_SHLIB="-Bforcearchive -Bshareable"
             LDFLAGS_SHLIB_EXPORT=""
             SHLIB_SUFFIX_DEPTH=2
             ;;
         alpha-*-netbsd*|mips-*-netbsd*|powerpc-*-netbsd*)
@@ -893,12 +914,21 @@
                 */gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
                 */cc|cc   ) CFLAGS_SHLIB="-KPIC" ;;
             esac
             LDFLAGS_SHLIB="-Bdynamic -G"
             LDFLAGS_SHLIB_EXPORT="-Wl,-Bexport"
             ;;
+         *-sco5*)
+             case $CC in
+                 */gcc*|gcc* ) CFLAGS_SHLIB="-fpic" ;;
+                 */cc*|cc*   ) CFLAGS_SHLIB="-KPIC" ;;
+             esac
+             LDFLAGS_SHLIB="-G"
+             LDFLAGS_SHLIB_EXPORT="-Wl,-Bexport"
+             SHLIB_SUFFIX_DEPTH=1
+             ;;
         RM*-sni-sysv4*)
             # MIPS hosts can take advantage of the LDFLAGS_SHLIB_EXPORT switch
             case $CC in
                 */gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
                 */cc|cc   ) CFLAGS_SHLIB="-KPIC" ;;
             esac
@@ -980,15 +1010,15 @@
             done
             if [ ".$PERL" != . ]; then
                 #   cool, Perl is installed on this platform...
                 if [ ".`$PERL -V:dlsrc 2>/dev/null | grep dlopen`" != . ]; then
                     #   ...and actually uses the dlopen-style interface,
                     #   so we can guess the flags from its knowledge
-                    CFLAGS_SHLIB="`perl -V:cccdlflags | cut -d\' -f2`"
-                    LDFLAGS_SHLIB="`perl -V:lddlflags | cut -d\' -f2`"
-                    LDFLAGS_SHLIB_EXPORT="`perl -V:ccdlflags | cut -d\' -f2`"
+                    CFLAGS_SHLIB="`$PERL -V:cccdlflags | cut -d\' -f2`"
+                    LDFLAGS_SHLIB="`$PERL -V:lddlflags | cut -d\' -f2`"
+                    LDFLAGS_SHLIB_EXPORT="`$PERL -V:ccdlflags | cut -d\' -f2`"
                     #   but additionally we have to inform the
                     #   user that we are just guessing the flags
                     echo ""
                     echo "** WARNING: We have no explicit knowledge about shared object"
                     echo "** support for your particular platform. But perhaps you have"
                     echo "** luck: We were able to guess the compiler and linker flags"
@@ -1043,38 +1073,12 @@
     if [ "x$TLDFLAGS_SHLIB_EXPORT" = "x" ]; then
         echo "LDFLAGS_SHLIB_EXPORT=$LDFLAGS_SHLIB_EXPORT" >> Makefile.config
     fi
 fi
 
 ####################################################################
-## Some OS-related stuff for the DSO mechanism:
-## Finding the vendor DSO functions
-##
-if [ "x$using_shlib" = "x1" ] ; then
-    DL_LIB=""
-    case $PLAT in
-        *-ibm-aix* )
-            DL_LIB="-lld"
-            ;;
-        * )
-            if ./helpers/TestCompile func dlopen; then
-                :
-            else
-                if ./helpers/TestCompile lib dl; then
-                    DL_LIB="-ldl"
-                fi
-            fi
-            ;;
-    esac
-    if [ ".$DL_LIB" != . ]; then
-        LIBS="$LIBS $DL_LIB"
-        echo " + using $DL_LIB for vendor DSO support"
-    fi
-fi
-
-####################################################################
 ## Now we do some OS specific adjustments... for some OSs, we need
 ## to adjust CFLAGS and/or OPTIM depending on which compiler we
 ## are going to use. This is easy, since this can be gleamed from
 ## Makefile.config
 ##
 case "$OS" in
@@ -1136,12 +1140,27 @@
 ##
 if [ "x$TOPTIM" = "x" ]; then
     echo "OPTIM=$OPTIM" >> Makefile.config
 fi
 
 ####################################################################
+## OK, now handle RANLIB
+##
+if [ ".$RANLIB" = . ]; then
+    if [ ".$TRANLIB" != . ]; then
+        RANLIB=$TRANLIB
+    else
+        if ./helpers/$AP_PRINTPATH -s ranlib; then
+            RANLIB="ranlib"
+        else
+            RANLIB="true"
+        fi
+    fi
+fi
+
+####################################################################
 ## Now we do some general checks and some intelligent Configuration
 ## control.
 
 # Use TestCompile to look for various LIBS
 case "$PLAT" in
     *-linux*)
@@ -1198,12 +1217,23 @@
         *-solaris2* )
             LIBS="$LIBS -lresolv"
             ;;
     esac
 fi
 
+# AIX 4.x support: Special Case: need to check for sys/processor.h
+# before we usually would.
+# Processor Binding
+case "$PLAT" in
+    *-ibm-aix*)
+        if ./helpers/TestCompile header sys/processor.h ; then
+            CFLAGS="$CFLAGS -DAIX_BIND_PROCESSOR"
+        fi
+        ;;
+esac
+
 ####################################################################
 ## Find out what modules we want and try and configure things for them
 ## Module lines can look like this:
 ##
 ##  Module  name_module    some/path/mod_name[.[oa]]
 ##  AddModule              some/path/mod_name[.[oa]]
@@ -1558,51 +1588,123 @@
 	MFLAGS_STATIC=
 else
 	MFLAGS_STATIC=--no-print-directory
 fi
 
 ####################################################################
-## Continue building Makefile.config.
+## Continue building Makefile.config. Fill in all entries except
+## for $LIBS at this point. This implies that anything below
+## can only alter $LIBS
 ##
 echo "CFLAGS1=$CFLAGS">> Makefile.config
 echo "OSDIR=\$(SRCDIR)/$OSDIR">> Makefile.config
 echo "INCDIR=\$(SRCDIR)/include" >>Makefile.config
 echo "INCLUDES0=-I\$(OSDIR) -I\$(INCDIR)">> Makefile.config
 echo "INCLUDES1=$INCLUDES">> Makefile.config
-echo "LIBS1=$LIBS">> Makefile.config
 echo "LDFLAGS1=$LDFLAGS">> Makefile.config
 echo "MFLAGS_STATIC=$MFLAGS_STATIC">> Makefile.config
 echo "REGLIB=$REGLIB">> Makefile.config
 echo "RANLIB=$RANLIB">> Makefile.config
 echo "SHELL=$SHELL">> Makefile.config
-echo "##" >> Makefile.config
-echo "##  (End of automatically generated section)">> Makefile.config
-echo "##" >> Makefile.config
-echo "" >> Makefile.config
 
 ####################################################################
-## Continue building include/ap_config.h
+## Some OS-related stuff for the DSO mechanism:
+## Finding the vendor DSO functions
+##
+if [ "x$using_shlib" = "x1" ] ; then
+    DL_LIB=""
+    case $PLAT in
+        *-ibm-aix* )
+            DL_LIB="-lld"
+            ;;
+        *-hp-hpux*)
+            if ./helpers/TestCompile func shl_load; then
+                :
+            else
+                if ./helpers/TestCompile lib dld; then
+                    DL_LIB="-ldld"
+                fi
+            fi
+            ;;
+        * )
+            if ./helpers/TestCompile func dlopen; then
+                :
+            else
+                if ./helpers/TestCompile lib dl; then
+                    DL_LIB="-ldl"
+                fi
+            fi
+            ;;
+    esac
+    if [ ".$DL_LIB" != . ]; then
+        LIBS="$LIBS $DL_LIB"
+        echo " + using $DL_LIB for vendor DSO support"
+    fi
+fi
+
+####################################################################
+## Now check for existance of non-standard system header files
+## and start generation of the ap_config_auto.h header
+##
+AP_CONFIG_AUTO_H="include/ap_config_auto.h"
+echo "/*" >$AP_CONFIG_AUTO_H
+echo " *  ap_config_auto.h -- Automatically determined configuration stuff" >>$AP_CONFIG_AUTO_H
+echo " *  THIS FILE WAS AUTOMATICALLY GENERATED - DO NOT EDIT!" >>$AP_CONFIG_AUTO_H
+echo " */" >>$AP_CONFIG_AUTO_H
+echo "" >>$AP_CONFIG_AUTO_H
+echo "#ifndef AP_CONFIG_AUTO_H" >>$AP_CONFIG_AUTO_H
+echo "#define AP_CONFIG_AUTO_H" >>$AP_CONFIG_AUTO_H
+
+echo " + checking for system header files"
+CHECK_FOR_HEADERS="dlfcn.h dl.h bstring.h crypt.h unistd.h sys/resource.h sys/select.h sys/processor.h"
+for header in $CHECK_FOR_HEADERS; do
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* check: #include <$header> */" >>$AP_CONFIG_AUTO_H
+    name="`echo $header | sed -e 's:/:_:g' -e 's:\.:_:g' | tr '[a-z]' '[A-Z]'`"
+    if ./helpers/TestCompile header $header; then
+        echo "#ifndef HAVE_${name}" >>$AP_CONFIG_AUTO_H
+        echo "#define HAVE_${name} 1" >>$AP_CONFIG_AUTO_H
+        echo "#endif" >>$AP_CONFIG_AUTO_H
+    else
+        echo "#ifdef HAVE_${name}" >>$AP_CONFIG_AUTO_H
+        echo "#undef HAVE_${name}" >>$AP_CONFIG_AUTO_H
+        echo "#endif" >>$AP_CONFIG_AUTO_H
+    fi
+done
+
+## Finish building ap_config_auto.h
 ##
-## We pick out all -D's from CFLAGS and create ap_config.h which
-## can be used by external modules needing to include Apache
-## header files.
+## We pick out all -D's from CFLAGS and insert them as defines into
+## ap_config_auto.h so they are available to external modules needing to
+## include Apache header files.
 ##
 for cflag in $CFLAGS; do
 	echo $cflag | sed 's/\\\"/\"/g' >>$tmpconfig ;
 done
-awk > include/ap_config.h < $tmpconfig '
-	BEGIN {
-		printf "/* Automatically generated file - do not edit */\n\n"
-	}
+awk >>$AP_CONFIG_AUTO_H <$tmpconfig '
 	/^-D.*/ {
 		define = substr($1, 3, length($1)-2)
 		split(define, parts, "=")
+		printf ("\n/* build flag: %s */\n", $0)
 		printf ("#ifndef %s\n#define %s %s\n#endif\n", parts[1],parts[1],parts[2])
 	}
 '
 
+# finish header file
+echo "" >>$AP_CONFIG_AUTO_H
+echo "#endif /* AP_CONFIG_AUTO_H */" >>$AP_CONFIG_AUTO_H
+
+####################################################################
+## Finish creating the Makefile.config file
+##
+echo "LIBS1=$LIBS">> Makefile.config
+echo "##" >> Makefile.config
+echo "##  (End of automatically generated section)">> Makefile.config
+echo "##" >> Makefile.config
+echo "" >> Makefile.config
+
 ####################################################################
 ## Use TestCompile to see if $(CC) is ANSI and as a "final" sanity
 ## check
 ##
 echo " + doing sanity check on compiler and options"
 if ./helpers/TestCompile sanity; then
@@ -1722,13 +1824,13 @@
 all: lib shlib
 
 lib:	$(LIB) 
 
 shlib:	$(SHLIBS)
 
-$(LIB): $(OBJS)
+dummy $(LIB): $(OBJS)
 	rm -f $@
 	ar cr $@ $(OBJS)
 	$(RANLIB) $@
 
 .SUFFIXES: .o .so
 
Only in apache_1.3.1/src/helpers: findprg.sh
diff -BEr -U 6 apache_1.3.0/src/helpers/GuessOS apache_1.3.1/src/helpers/GuessOS
--- apache_1.3.0/src/helpers/GuessOS	1998-02-21 23:00:41.000000000 +0800
+++ apache_1.3.1/src/helpers/GuessOS	1998-06-29 20:21:04.000000000 +0800
@@ -47,12 +47,17 @@
 		    echo "${MACHINE}-whatever-unixware2"; exit 0
 		fi
 		;;
 	    4.2)
 		echo "whatever-whatever-unixware1"; exit 0
 		;;
+	    5)
+		if [ "x$VERSION" = "x7" ]; then
+		    echo "${MACHINE}-whatever-unixware7"; exit 0
+		fi
+		;;
 	esac
     fi
 fi
 # Now we simply scan though... In most cases, the SYSTEM info is enough
 #
 case "${SYSTEM}:${RELEASE}:${VERSION}:${MACHINE}" in
@@ -136,20 +141,17 @@
 
     OSF1:*:*:*alpha*)
 	echo "${MACHINE}-dec-osf"; exit 0
 	;;
 
     QNX:*)
-	case "$VERSION" in
-	    423)
-		echo "${MACHINE}-qssl-qnx32"
-		;;
-	    *)
-		echo "${MACHINE}-qssl-qnx"
-		;;
-	esac
+	if [ "$VERSION" -gt 422 ]; then
+	    echo "${MACHINE}-qssl-qnx32"
+	else
+	    echo "${MACHINE}-qssl-qnx"
+	fi
 	exit 0
 	;;
 
     Paragon*:*:*:*)
 	echo "i860-intel-osf1"; exit 0
 	;;
@@ -186,14 +188,14 @@
 	;;
 
     DYNIX/ptx:4*:*)
 	echo "${MACHINE}-whatever-sysv4"; exit 0
 	;;
 
-    *:4.0:3.0:3[34]?? | *:4.0:3.0:3[34]??,*)
-	echo "i486-ncr-sysv4"; exit 0
+    *:4.0:3.0:[345][0-9]?? | *:4.0:3.0:3[34]??[/,]* | library:*)
+	echo "x86-ncr-sysv4"; exit 0
 	;;
 
     ULTRIX:*)
 	echo "${MACHINE}-unknown-ultrix"; exit 0
 	;;
 
@@ -206,16 +208,12 @@
 	;;
 
     machten:*)
        echo "${MACHINE}-tenon-${SYSTEM}"; exit 0;
        ;;
 
-    library:*)
-	echo "${MACHINE}-ncr-sysv4"; exit 0
-	;;
-
     ConvexOS:*:11.*:*)
 	echo "${MACHINE}-v11-${SYSTEM}"; exit 0;
 	;;
     
     UNIX_SV:*:*:maxion)
 	echo "${MACHINE}-ccur-sysv4"; exit 0;
@@ -249,13 +247,27 @@
 fi
 
 # Now NeXT
 ISNEXT=`hostinfo 2>/dev/null`
 case "$ISNEXT" in
     *NeXT*)
-	echo "whatever-next-nextstep"; exit 0
+#	echo "whatever-next-nextstep"; exit 0
+
+#	Swiped from a friendly uname clone for NEXT/OPEN Step.
+     	NEXTOSVER="`hostinfo | sed -n 's/.*NeXT Mach \([0-9\.]*\).*/\1/p'`"
+	if [ "$NEXTOSVER" -gt 3.3 ]
+     	then
+          NEXTOS="openstep"
+     	else
+          NEXTOS="nextstep"
+     	fi
+
+	NEXTREL="`hostinfo | sed -n 's/.*NeXT Mach \([0-9\.]*\).*/\1/p'`" 
+	NEXTARCH=`arch`
+	echo "${NEXTARCH}-next-${NEXTOS}${NEXTREL}" ; exit 0
+
 	;;
 esac
 
 # At this point we gone through all the one's
 # we know of: Punt
 
Only in apache_1.3.1/src/helpers: MakeEtags
diff -BEr -U 6 apache_1.3.0/src/helpers/TestCompile apache_1.3.1/src/helpers/TestCompile
--- apache_1.3.0/src/helpers/TestCompile	1998-04-11 23:45:59.000000000 +0800
+++ apache_1.3.1/src/helpers/TestCompile	1998-07-18 23:30:41.000000000 +0800
@@ -1,24 +1,27 @@
 #!/bin/sh
 exstat=1
-trap 'rm -f Makefile dummy testfunc.c testfunc; exit $exstat' 0 1 2 3 15
+trap 'rm -f Makefile dummy dummy.exe testfunc.c testfunc testfunc.exe; exit $exstat' 0 1 2 3 15
 #
 # Yet another Apache Configure helper script.
 # This script tests certain aspects of the compilation
-# process. Right now, it can perform 3 tests:
+# process. Right now, it can perform 5 tests:
 #
 # ./helpers/TestCompile lib <libname>
 #    Which checks to see if <libname> exists on this system
 #
 # ./helpers/TestCompile lib <libname> <func>
 #    Which checks to see if <libname> exists on this system and
 #    contains func.
 #
 # ./helpers/TestCompile func <function>
 #    Which checks to see if <function> exists
 #
+# ./helpers/TestCompile header <header>
+#    Which checks to see if header file <header> exists
+#
 # ./helpers/TestCompile sanity
 #    Which does a simple sanity check/test compile
 #
 # It does these by creating a small mini-makefile, based on
 # ../Makefile.config and trying to compile a small dummy
 # program. If the compilation succeeds, we assume the test
@@ -91,12 +94,28 @@
 	cat <<EOF >testfunc.c
 void main(void) {
     $2();
 }
 EOF
 	;;
+    "header")
+	if [ "x$2" = "x" ]; then
+	    exit
+	fi
+	TLIB=""
+	if [ "$VERBOSE" = "yes" ]; then
+	    ERRDIR=""
+	else
+	    ERRDIR='2>/dev/null'
+	fi
+	TARGET='testfunc'
+	cat <<EOF >testfunc.c
+#include <$2>
+void main(void) { }
+EOF
+	;;
     *)
     	exit
 	;;
 esac
 
 #
diff -BEr -U 6 apache_1.3.0/src/include/alloc.h apache_1.3.1/src/include/alloc.h
--- apache_1.3.0/src/include/alloc.h	1998-05-29 06:09:45.000000000 +0800
+++ apache_1.3.1/src/include/alloc.h	1998-06-28 02:09:28.000000000 +0800
@@ -176,13 +176,13 @@
     char *val;
 } table_entry;
 
 API_EXPORT(table *) ap_make_table(pool *p, int nelts);
 API_EXPORT(table *) ap_copy_table(pool *p, const table *);
 API_EXPORT(void) ap_clear_table(table *);
-API_EXPORT(char *) ap_table_get(const table *, const char *);
+API_EXPORT(const char *) ap_table_get(const table *, const char *);
 API_EXPORT(void) ap_table_set(table *, const char *name, const char *val);
 API_EXPORT(void) ap_table_setn(table *, const char *name, const char *val);
 API_EXPORT(void) ap_table_merge(table *, const char *name, const char *more_val);
 API_EXPORT(void) ap_table_mergen(table *, const char *name, const char *more_val);
 API_EXPORT(void) ap_table_unset(table *, const char *key);
 API_EXPORT(void) ap_table_add(table *, const char *name, const char *val);
@@ -194,14 +194,14 @@
 
 /* XXX: these know about the definition of struct table in alloc.c.  That
  * definition is not here because it is supposed to be private, and by not
  * placing it here we are able to get compile-time diagnostics from modules
  * written which assume that a table is the same as an array_header. -djg
  */
-#define table_elts(t) ((array_header *)(t))
-#define is_empty_table(t) (((t) == NULL)||(((array_header *)(t))->nelts == 0))
+#define ap_table_elts(t) ((array_header *)(t))
+#define ap_is_empty_table(t) (((t) == NULL)||(((array_header *)(t))->nelts == 0))
 
 /* routines to remember allocation of other sorts of things...
  * generic interface first.  Note that we want to have two separate
  * cleanup functions in the general case, one for exec() preparation,
  * to keep CGI scripts and the like from inheriting access to things
  * they shouldn't be able to touch, and one for actually cleaning up,
Only in apache_1.3.1/src/include: ap_compat.h
diff -BEr -U 6 apache_1.3.0/src/include/ap_config.h apache_1.3.1/src/include/ap_config.h
--- apache_1.3.0/src/include/ap_config.h	2017-09-16 15:36:21.356035070 +0800
+++ apache_1.3.1/src/include/ap_config.h	1998-07-18 23:30:43.000000000 +0800
@@ -1,8 +1,1175 @@
-/* Automatically generated file - do not edit */
+/* ====================================================================
+ * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * 4. The names "Apache Server" and "Apache Group" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Group.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Group and was originally based
+ * on public domain software written at the National Center for
+ * Supercomputing Applications, University of Illinois, Urbana-Champaign.
+ * For more information on the Apache Group and the Apache HTTP server
+ * project, please see <http://www.apache.org/>.
+ *
+ */
 
-#ifndef LINUX
-#define LINUX 2
+#ifndef AP_CONFIG_H
+#define AP_CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * ap_config.h: system-dependant #defines and includes...
+ * See PORTING for a listing of what they mean
+ */
+
+/*
+ * Support for platform dependent autogenerated defines
+ */
+#ifndef WIN32
+#include "ap_config_auto.h"
+#else
+/* not available under WIN32, so provide important entries manually */
+#undef HAVE_UNISTD_H
+#endif
+
+/* Have to include sys/stat.h before ../os/win32/os.h so we can override
+stat() properly */
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#ifdef WIN32
+/* include process.h first so we can override spawn[lv]e* properly */
+#include <process.h>
+#include "../os/win32/os.h"
+#else
+#include "os.h"
+#endif
+
+#if !defined(QNX) && !defined(MPE) && !defined(WIN32)
+#include <sys/param.h>
+#endif
+
+/* Define one of these according to your system. */
+#if defined(MINT)
+typedef int rlim_t;
+#define JMP_BUF sigjmp_buf
+#define NO_LONG_DOUBLE
+#define USE_FLOCK_SERIALIZED_ACCEPT
+#define _BSD_SOURCE
+#define EAGAIN EWOULDBLOCK
+int initgroups (char *, int);     
+char *crypt (const char *pw, const char *salt);
+int gethostname (char *name, int namelen);
+
+#elif defined(MPE)
+#include <sys/times.h>
+#define NO_SETSID
+#define NO_KILLPG
+#define NO_WRITEV
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define SHM_R 0400  /* Read permission */
+#define SHM_W 0200  /* Write permission */
+#define NEED_INITGROUPS
+#define NEED_STRCASECMP
+#define NEED_STRDUP
+#define NEED_STRNCASECMP
+extern void GETPRIVMODE();
+extern void GETUSERMODE();
+extern char *inet_ntoa();
+#define NO_SLACK
+#define NO_GETTIMEOFDAY
+#define S_IEXEC  S_IXUSR
+#define S_IREAD  S_IRUSR
+#define S_IWRITE S_IWUSR
+#define PF_INET  AF_INET
+
+#elif defined(SUNOS4)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+char *crypt(const char *pw, const char *salt);
+char *mktemp(char *template);
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#include <sys/time.h>
+#define NEED_STRERROR
+typedef int rlim_t;
+#define memmove(a,b,c) bcopy(b,a,c)
+#define NO_LINGCLOSE
+#define USE_FLOCK_SERIALIZED_ACCEPT
+#define NEED_DIFFTIME
+#define HAVE_SYSLOG 1
+
+#elif defined(SOLARIS2)
+#undef HAVE_GMTOFF
+#define NO_KILLPG
+#undef NO_SETSID
+#define bzero(a,b) memset(a,0,b)
+#if !defined(USE_SYSVSEM_SERIALIZED_ACCEPT) && \
+    !defined(USE_PTHREAD_SERIALIZED_ACCEPT)
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+#define NEED_UNION_SEMUN
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+int gethostname(char *name, int namelen);
+#define HAVE_SYSLOG 1
+#define SYS_SIGLIST _sys_siglist
+
+#elif defined(IRIX)
+#undef HAVE_GMTOFF
+/* IRIX has killpg, but it's only in _BSD_COMPAT, so don't use it in case
+ * there's some weird conflict with non-BSD signals */
+#define NO_KILLPG
+#undef NO_SETSID
+#if !defined(USE_FCNTL_SERIALIZED_ACCEPT) && !defined(USE_USLOCK_SERIALIZED_ACCEPT)
+#define USE_SYSVSEM_SERIALIZED_ACCEPT
+#endif
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define HAVE_MMAP 1
+#define USE_MMAP_FILES
+#define NO_LONG_DOUBLE
+#define NO_LINGCLOSE
+#define HAVE_SYSLOG 1
+
+#elif defined(HIUX)
+#undef HAVE_GMTOFF
+#define NO_KILLPG
+#undef NO_SETSID
+#ifndef _HIUX_SOURCE
+#define _HIUX_SOURCE
+#endif
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define SELECT_NEEDS_CAST
+#define HAVE_SYSLOG 1
+
+#elif defined(HPUX) || defined(HPUX10)
+#undef HAVE_GMTOFF
+#define NO_KILLPG
+#undef NO_SETSID
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#ifndef _HPUX_SOURCE
+#define _HPUX_SOURCE
+#endif
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define HAVE_SYSLOG 1
+#ifndef HPUX10
+#define SELECT_NEEDS_CAST
+typedef int rlim_t;
+#endif
+
+#elif defined(HPUX11)
+#ifndef _HPUX_SOURCE
+#define _HPUX_SOURCE
+#endif
+#define HAVE_SHMGET
+#define USE_SHMGET_SCOREBOARD
+#undef  HAVE_GMTOFF
+#define USE_FCNTL_SERIALIZED_ACCEPT
+/* feeling brave?  want to try using POSIX mutexes? */
+/* #define HAVE_MMAP */
+/* #define USE_MMAP_SCOREBOARD */
+/* #define USE_MMAP_FILES */
+/* #define USE_PTHREAD_SERIALIZED_ACCEPT */
+#define NO_KILLPG
+#undef  NO_SETSID
+#define HAVE_SYSLOG
+
+#elif defined(AIX)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#ifndef __ps2__
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SYSLOG 1
+#ifndef DEFAULT_GROUP
+#define DEFAULT_GROUP "nobody"
+#endif
+#endif
+#ifndef DEFAULT_USER
+#define DEFAULT_USER "nobody"
+#endif
+#ifdef NEED_RLIM_T
+typedef int rlim_t;
+#endif
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#ifdef USEBCOPY
+#define memmove(a,b,c) bcopy(b,a,c)
+#endif
+#if AIX >= 42
+#define NET_SIZE_T size_t
+#endif
+
+#elif defined(ULTRIX)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define ULTRIX_BRAIN_DEATH
+#define NEED_STRDUP
+/* If you have Ultrix 4.3, and are using cc, const is broken */
+#ifndef __ultrix__		/* Hack to check for pre-Ultrix 4.4 cc */
+#define const			/* Not implemented */
+#endif
+
+#elif defined(OSF1)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define NO_LONG_DOUBLE
+#define HAVE_SYSLOG 1
+#define USE_FLOCK_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+
+#elif defined(PARAGON)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define NO_LONG_DOUBLE
+#define HAVE_SYSLOG 1
+typedef int rlim_t;
+
+#elif defined(SEQUENT)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#define NO_SETSID
+#define NEED_STRDUP
+#define HAVE_SYSLOG 1
+
+#elif defined(NEXT)
+typedef unsigned short mode_t;
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#define NO_SETSID
+#define NEED_STRDUP
+#define NO_LINGCLOSE
+#undef _POSIX_SOURCE
+#ifndef FD_CLOEXEC
+#define FD_CLOEXEC 1
+#endif
+#ifndef S_ISDIR
+#define S_ISDIR(m)      (((m)&(S_IFMT)) == (S_IFDIR))
+#endif
+#ifndef S_ISREG
+#define S_ISREG(m)      (((m)&(S_IFMT)) == (S_IFREG))
+#endif
+#ifndef S_IXUSR
+#define S_IXUSR 00100
+#endif
+#ifndef S_IRGRP
+#define S_IRGRP 00040
+#endif
+#ifndef S_IXGRP
+#define S_IXGRP 00010
+#endif
+#ifndef S_IROTH
+#define S_IROTH 00004
+#endif
+#ifndef S_IXOTH
+#define S_IXOTH 00001
+#endif
+#ifndef S_IRUSR
+#define S_IRUSR S_IREAD
+#endif
+#ifndef S_IWUSR
+#define S_IWUSR S_IWRITE
+#endif
+#ifndef S_IWGRP
+#define S_IWGRP	000020
+#endif
+#ifndef S_IWOTH
+#define S_IWOTH 000002
+#ifndef rlim_t
+typedef int rlim_t;
+#endif
+typedef u_long n_long;
+#endif
+
+#define STDIN_FILENO  0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+
+/* PR#2293 fix */
+#define	ap_wait_t	union wait
+#define waitpid(a,b,c) wait4((a) == -1 ? 0 : (a),(union wait *)(b),c,NULL)
+#define WEXITSTATUS(status)     (int)( WIFEXITED(status) ? ( (status).w_retcode ) : -1)
+#define WTERMSIG(status)	(int)( (status).w_termsig )
+
+typedef int pid_t;
+#define USE_LONGJMP
+#define NO_USE_SIGACTION
+#define HAVE_SYSLOG 1
+
+#elif defined(LINUX)
+
+#if LINUX > 1
+#include <features.h>
+
+/* libc4 systems probably still work, it probably doesn't define
+ *  __GNU_LIBRARY__
+ * libc5 systems define __GNU_LIBRARY__ == 1, but don't define __GLIBC__
+ * glibc 2.x and later systems define __GNU_LIBRARY__ == 6, but list it as
+ * "deprecated in favour of __GLIBC__"; the value 6 will never be changed.
+ * glibc 1.x systems (i.e. redhat 4.x on sparc/alpha) should have
+ * __GLIBC__ < 2
+ * all glibc based systems need crypt.h
+ */
+#if defined(__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
+#include <crypt.h>
+#endif
+
+/* glibc 2.0.0 through 2.0.4 need size_t * here, where 2.0.5 needs socklen_t *
+ * there's no way to discern between these two libraries.  But using int should
+ * be portable because otherwise these libs would be hopelessly broken with
+ * reams of existing networking code.  We'll use socklen_t * for 2.1.x and
+ * later.
+ *
+ * int works for all the earlier libs, and is picked up by default later.
+ */
+#if defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 0))
+#define NET_SIZE_T socklen_t
+#endif
+
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define HAVE_MMAP 1
+#define USE_MMAP_FILES
+
+/* glibc 2.1 and later finally define rlim_t */
+#if !defined(__GLIBC__) || __GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 1)
+typedef int rlim_t;
+#endif
+
+/* flock is faster ... but hasn't been tested on 1.x systems */
+#define USE_FLOCK_SERIALIZED_ACCEPT
+
+#define SYS_SIGLIST	_sys_siglist
+
+#else
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#undef NEED_STRDUP
+#include <sys/time.h>
+#define HAVE_SYSLOG 1
+
+#elif defined(SCO)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#define NEED_INITGROUPS
+#define NO_WRITEV
+#include <sys/time.h>
+#define HAVE_SYSLOG 1
+
+#elif defined(SCO5)
+
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define SecureWare
+#define HAVE_SYSLOG 1
+
+/* Although SCO 5 defines these in <strings.h> (note the "s") they don't have
+   consts. Sigh. */
+extern int strcasecmp(const char *, const char *);
+extern int strncasecmp(const char *, const char *, unsigned);
+
+#elif defined(AUX3)
+/* These are to let -Wall compile more cleanly */
+extern int strcasecmp(const char *, const char *);
+extern int strncasecmp(const char *, const char *, unsigned);
+extern int set42sig(), getopt(), getpeername(), bzero();
+extern int listen(), bind(), socket(), getsockname();
+extern int accept(), gethostname(), connect(), lstat();
+extern int select(), killpg(), shutdown();
+extern int initgroups(), setsockopt();
+extern char *shmat();
+extern int shmctl();
+extern int shmget();
+extern char *sbrk();
+extern char *crypt();
+#include <sys/time.h>
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#define NEED_STRDUP
+/* fcntl() locking is expensive with NFS */
+#define USE_FLOCK_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+/*
+ * NOTE: If when you run Apache under A/UX and you get a warning
+ * that httpd couldn't move break, then the below value for
+ * MOVEBREAK (64megs) is too large for your setup. Try reducing
+ * to 0x2000000 which is still PLENTY of space. I doubt if
+ * even on heavy systems sbrk() would be called at all...
+ */
+#define MOVEBREAK		0x4000000
+#define NO_LINGCLOSE
+#define NO_SLACK
+#define HAVE_SYSLOG 1
+#undef HAVE_SYS_RESOURCE_H	/* exists but does not provide *rlimit funcs */
+
+#elif defined(SVR4)
+#define NO_KILLPG
+#undef  NO_SETSID
+#undef NEED_STRDUP
+#ifndef MPRAS
+#define NEED_STRCASECMP
+#ifndef ENCORE
+#define NEED_STRNCASECMP
+#endif /* ENCORE */
+#endif /* MPRAS */
+#define bzero(a,b) memset(a,0,b)
+/* A lot of SVR4 systems need this */
+#ifndef USE_SYSVSEM_SERIALIZED_ACCEPT
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+#define HAVE_SYSLOG 1
+#define NET_SIZE_T size_t
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#ifdef _OSD_POSIX /* BS2000-POSIX mainframe needs initgroups */
+#define NEED_INITGROUPS
+#define NEED_HASHBANG_EMUL /* execve() doesn't start shell scripts by default */
+#undef HAVE_SHMGET
+#undef USE_SHMGET_SCOREBOARD
+#undef bzero
+#endif /*_OSD_POSIX*/
+
+#elif defined(UW)
+#define NO_LINGCLOSE
+#define NO_KILLPG
+#undef  NO_SETSID
+#undef NEED_STRDUP
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#define bzero(a,b) memset(a,0,b)
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SHMGET 1
+#undef USE_SHMGET_SCOREBOARD	/* force use of mmap() scoreboard */
+#include <sys/time.h>
+#if UW >= 200
+#define _POSIX_SOURCE
+#endif
+#define NET_SIZE_T size_t
+#define HAVE_SYSLOG 1
+#define USE_FCNTL_SERIALIZED_ACCEPT
+
+#elif defined(DGUX)
+#define NO_KILLPG
+#undef  NO_SETSID
+#undef NEED_STRDUP
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#define bzero(a,b) memset(a,0,b)
+/* A lot of SVR4 systems need this */
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#define ap_inet_addr inet_network
+#define HAVE_SYSLOG 1
+
+#elif defined(__NetBSD__) || defined(__OpenBSD__) || defined(NETBSD)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_SYSLOG 1
+#ifndef DEFAULT_USER
+#define DEFAULT_USER "nobody"
+#endif
+#ifndef DEFAULT_GROUP
+#define DEFAULT_GROUP "nogroup"
+#define HAVE_SHMGET 1
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#endif
+
+#elif defined(UTS21)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#define NO_SETSID
+#define NEED_WAITPID
+#define STDIN_FILENO 0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+#define HAVE_SYSLOG 1
+#define USE_LONGJMP
+#define JMP_BUF jmp_buf
+#define NO_USE_SIGACTION
+#define NEED_STRERROR
+#define NEED_STRSTR
+#define NEED_HASHBANG_EMUL
+#define NDELAY_PIPE_RETURNS_ZERO
+#define NO_DATA NO_ADDRESS
+#define	ap_wait_t		union wait
+#define WEXITSTATUS(status)	(int)((status).w_retcode)
+#define WTERMSIG(status)	(int)((status).w_termsig)
+#define strftime(buf,bufsize,fmt,tm)    ascftime(buf,fmt,tm)
+#include <sys/types.h>
+#include <sys/time.h>     
+
+#elif defined(APOLLO)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_SYSLOG 1
+
+#elif defined(__FreeBSD__) || defined(__bsdi__)
+#if defined(__FreeBSD__)
+#include <osreldate.h>
+#endif
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#ifndef DEFAULT_USER
+#define DEFAULT_USER "nobody"
+#endif
+#ifndef DEFAULT_GROUP
+#define DEFAULT_GROUP "nogroup"
+#endif
+#if defined(__bsdi__) || \
+(defined(__FreeBSD_version) && (__FreeBSD_version < 220000))
+typedef quad_t rlim_t;
+#endif
+#define USE_FLOCK_SERIALIZED_ACCEPT
+#define HAVE_SYSLOG 1
+#define SYS_SIGLIST sys_siglist
+
+#elif defined(QNX)
+#ifndef crypt
+char *crypt(const char *pw, const char *salt);
+#endif
+#ifndef initgroups
+int initgroups(char *, int);
+#endif
+#ifndef strncasecmp
+#define strncasecmp strnicmp
+#endif
+#undef NO_KILLPG
+#undef NO_SETSID
+#define NEED_INITGROUPS
+#define NEED_SELECT_H
+#define NEED_PROCESS_H
+#include <unix.h>
+#define HAVE_MMAP 1
+#define USE_POSIX_SCOREBOARD
+#define USE_FLOCK_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define HAVE_SYSLOG 1
+
+#elif defined(LYNXOS)
+#undef HAVE_GMTOFF
+#undef USE_MMAP_SCOREBOARD
+#undef USE_SHMGET_SCOREBOARD
+#undef USE_FCNTL_SERIALIZED_ACCEPT
+#undef USE_FLOCK_SERIALIZED_ACCEPT
+#define USE_LONGJMP
+#undef NO_KILLPG
+#undef NO_SETSID
+#undef NO_USE_SIGACTION
+#undef NO_LINGCLOSE
+extern char *crypt(char *pw, char *salt);
+typedef int rlim_t;
+#define HAVE_SYSLOG 1
+
+#elif defined(UXPDS)
+#undef NEED_STRCASECMP
+#undef NEED_STRNCASECMP
+#undef NEED_STRDUP
+#undef HAVE_GMTOFF
+#define NO_KILLPG
+#undef NO_SETSID
+#define bzero(a,b) memset(a,0,b)
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SYSLOG 1
+
+#elif defined(__EMX__)
+/* Defines required for EMX OS/2 port. */
+#define NO_KILLPG
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#define NO_SETSID
+#define NO_TIMES
+/* ap_config_auto.h gets this wrong, force sys/select.h to be included */
+#define HAVE_SYS_SELECT_H
+#define CASE_BLIND_FILESYSTEM
+/* Add some drive name support */
+#define chdir _chdir2
+#include <sys/time.h>
+#define MAXSOCKETS 4096
+#define USE_OS2_SCOREBOARD
+#define NO_RELIABLE_PIPED_LOGS
+
+#elif defined(__MACHTEN__)
+typedef int rlim_t;
+#undef NO_KILLPG
+#define NO_SETSID
+#define HAVE_GMTOFF 1
+#ifndef __MACHTEN_PPC__
+#ifndef __MACHTEN_68K__
+#define __MACHTEN_68K__
+#endif
+#define USE_FLOCK_SERIALIZED_ACCEPT
+#define NO_USE_SIGACTION
+#define JMP_BUF sigjmp_buf
+#define USE_LONGJMP
+#undef NEED_STRDUP
+#else
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+
+/* Convex OS v11 */
+#elif defined(CONVEXOS11)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#undef NEED_STRDUP
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SYSLOG 1
+
+#define NO_TIMEZONE
+#include <stdio.h>
+#include <sys/types.h>
+typedef int rlim_t;
+
+#elif defined(ISC)
+#include <net/errno.h>
+#define NO_KILLPG
+#undef NO_SETSID
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_SYSLOG 1
+
+#elif defined(NEWSOS)
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define USE_LONGJMP
+#define NO_SETSID
+#define NO_USE_SIGACTION
+#define NEED_WAITPID
+#define NO_OTHER_CHILD
+#define HAVE_SYSLOG 1
+#include <sys/time.h>
+#include <stdlib.h>
+#include <sys/types.h>
+typedef int pid_t;
+typedef int rlim_t;
+typedef int mode_t;
+
+#elif defined(RISCIX)
+#include <sys/time.h>
+typedef int rlim_t;
+#define NO_USE_SIGACTION
+#define USE_LONGJMP
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#define NEED_STRDUP
+
+#elif defined(BEOS)
+#include <stddef.h>
+
+#define NO_WRITEV
+#define NO_KILLPG
+#define NEED_INITGROUPS
+
+#elif defined(WIN32)
+
+/* All windows stuff is now in os/win32/os.h */
+
+#else
+/* Unknown system - Edit these to match */
+#ifdef BSD
+#define HAVE_GMTOFF 1
+#else
+#undef HAVE_GMTOFF
 #endif
-#ifndef USE_HSREGEX
-#define USE_HSREGEX 
+/* NO_KILLPG is set on systems that don't have killpg */
+#undef NO_KILLPG
+/* NO_SETSID is set on systems that don't have setsid */
+#undef NO_SETSID
+/* NEED_STRDUP is set on stupid systems that don't have strdup. */
+#undef NEED_STRDUP
 #endif
+
+/* stuff marked API_EXPORT is part of the API, and intended for use
+ * by modules
+ */
+#ifndef API_EXPORT
+#define API_EXPORT(type)    type
+#endif
+
+/* Stuff marked API_EXPORT_NONSTD is part of the API, and intended for
+ * use by modules.  The difference between API_EXPORT and
+ * API_EXPORT_NONSTD is that the latter is required for any functions
+ * which use varargs or are used via indirect function call.  This
+ * is to accomodate the two calling conventions in windows dlls.
+ */
+#ifndef API_EXPORT_NONSTD
+#define API_EXPORT_NONSTD(type)    type
+#endif
+
+#ifndef MODULE_VAR_EXPORT
+#define MODULE_VAR_EXPORT
+#endif
+#ifndef API_VAR_EXPORT
+#define API_VAR_EXPORT
+#endif
+
+/* modules should not used functions marked CORE_EXPORT
+ * or CORE_EXPORT_NONSTD */
+#ifndef CORE_EXPORT
+#define CORE_EXPORT	API_EXPORT
+#endif
+#ifndef CORE_EXPORT_NONSTD
+#define CORE_EXPORT_NONSTD	API_EXPORT_NONSTD
+#endif
+
+/* So that we can use inline on some critical functions, and use
+ * GNUC attributes (such as to get -Wall warnings for printf-like
+ * functions).  Only do this in gcc 2.7 or later ... it may work
+ * on earlier stuff, but why chance it.
+ *
+ * We've since discovered that the gcc shipped with NeXT systems
+ * as "cc" is completely broken.  It claims to be __GNUC__ and so
+ * on, but it doesn't implement half of the things that __GNUC__
+ * means.  In particular it's missing inline and the __attribute__
+ * stuff.  So we hack around it.  PR#1613. -djg
+ */
+#if !defined(__GNUC__) || __GNUC__ < 2 || __GNUC_MINOR__ < 7 || defined(NEXT)
+#define ap_inline
+#define __attribute__(__x)
+#define ENUM_BITFIELD(e,n,w)  signed int n : w
+#else
+#define ap_inline __inline__
+#define USE_GNU_INLINE
+#define ENUM_BITFIELD(e,n,w)  e n : w
+#endif
+
+/*
+ * The particular directory style your system supports. If you have dirent.h
+ * in /usr/include (POSIX) or /usr/include/sys (SYSV), #include 
+ * that file and define DIR_TYPE to be dirent. Otherwise, if you have 
+ * /usr/include/sys/dir.h, define DIR_TYPE to be direct and include that
+ * file. If you have neither, I'm confused.
+ */
+
+#include <sys/types.h>
+#include <stdarg.h>
+
+#if !defined(NEXT) && !defined(WIN32)
+#include <dirent.h>
+#define DIR_TYPE dirent
+#elif !defined(WIN32)
+#include <sys/dir.h>
+#define DIR_TYPE direct
+#else
+#define DIR_TYPE dirent
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "ap_ctype.h"
+#if !defined(MPE) && !defined(WIN32)
+#include <sys/file.h>
+#endif
+#ifndef WIN32
+#include <sys/socket.h>
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif /* HAVE_SYS_SELECT_H */
+#include <netinet/in.h>
+#include <netdb.h>
+#include <sys/ioctl.h>
+#if !defined(MPE) && !defined(BEOS)
+#include <arpa/inet.h>		/* for inet_ntoa */
+#endif
+#include <sys/wait.h>
+#include <pwd.h>
+#include <grp.h>
+#include <fcntl.h>
+#include <limits.h>
+#define closesocket(s) close(s)
+#ifndef O_BINARY
+#define O_BINARY (0)
+#endif
+
+#else /* WIN32 */
+#include <winsock.h>
+#include <malloc.h>
+#include <io.h>
+#include <fcntl.h>
+#endif /* ndef WIN32 */
+
+#include <time.h>		/* for ctime */
+#include <signal.h>
+#include <errno.h>
+#if !defined(QNX) && !defined(CONVEXOS11) && !defined(NEXT)
+#include <memory.h>
+#endif
+
+#ifdef NEED_PROCESS_H
+#include <process.h>
+#endif
+
+#ifdef WIN32
+#include "../include/hsregex.h"
+#elif defined(USE_HSREGEX)
+#include "hsregex.h"
+#else
+#include <regex.h>
+#endif
+
+#ifdef HAVE_SYS_RESOURCE_H
+#include <sys/resource.h>
+#ifdef SUNOS4
+int getrlimit(int, struct rlimit *);
+int setrlimit(int, struct rlimit *);
+#endif
+#endif
+#ifdef USE_MMAP_SCOREBOARD
+#if !defined(__EMX__) && !defined(WIN32)
+/* This file is not needed for OS/2 */
+#include <sys/mman.h>
+#endif
+#endif
+#if !defined(MAP_ANON) && defined(MAP_ANONYMOUS)
+#define MAP_ANON MAP_ANONYMOUS
+#endif
+
+#if defined(USE_MMAP_FILES) && (defined(NO_MMAP) || !defined(HAVE_MMAP))
+#undef USE_MMAP_FILES
+#endif
+
+#if defined(USE_MMAP_SCOREBOARD) && (defined(NO_MMAP) || !defined(HAVE_MMAP))
+#undef USE_MMAP_SCOREBOARD
+#endif
+
+#if defined(USE_SHMGET_SCOREBOARD) && (defined(NO_SHMGET) || !defined(HAVE_SHMGET))
+#undef USE_SHMGET_SCOREBOARD
+#endif
+
+#ifndef LOGNAME_MAX
+#define LOGNAME_MAX 25
+#endif
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#ifdef ultrix
+#define ULTRIX_BRAIN_DEATH
+#endif
+
+#ifndef S_ISLNK
+#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#endif
+
+#ifndef INADDR_NONE
+#define INADDR_NONE ((unsigned long) -1)
+#endif
+
+/*
+ * Replace signal function with sigaction equivalent
+ */
+#ifndef NO_USE_SIGACTION
+typedef void Sigfunc(int);
+
+#if defined(SIG_IGN) && !defined(SIG_ERR)
+#define SIG_ERR ((Sigfunc *)-1)
+#endif
+
+/*
+ * For some strange reason, QNX defines signal to signal. Eliminate it.
+ */
+#ifdef signal
+#undef signal
+#endif
+#define signal(s,f)	ap_signal(s,f)
+Sigfunc *signal(int signo, Sigfunc * func);
+#endif
+
+#include <setjmp.h>
+
+#if defined(USE_LONGJMP)
+#define ap_longjmp(x, y)        longjmp((x), (y))
+#define ap_setjmp(x)            setjmp(x)
+#ifndef JMP_BUF
+#define JMP_BUF jmp_buf
+#endif
+#else
+#define ap_longjmp(x, y)        siglongjmp((x), (y))
+#define ap_setjmp(x)            sigsetjmp((x), 1)
+#ifndef JMP_BUF
+#define JMP_BUF sigjmp_buf
+#endif
+#endif
+
+#ifdef SELECT_NEEDS_CAST
+#define ap_select(_a, _b, _c, _d, _e)	\
+    select((_a), (int *)(_b), (int *)(_c), (int *)(_d), (_e))
+#else
+#define ap_select	select
+#endif
+
+#ifdef ULTRIX_BRAIN_DEATH
+#define ap_fdopen(d,m) fdopen((d), (char *)(m))
+#else
+#define ap_fdopen(d,m) fdopen((d), (m))
+#endif
+
+#ifndef ap_inet_addr
+#define ap_inet_addr inet_addr
+#endif
+
+#ifdef NO_OTHER_CHILD
+#define NO_RELIABLE_PIPED_LOGS
+#endif
+
+/* When the underlying OS doesn't support exec() of scripts which start
+ * with a HASHBANG (#!) followed by interpreter name and args, define this.
+ */
+#ifdef NEED_HASHBANG_EMUL
+extern int ap_execle(const char *filename, const char *arg,...);
+extern int ap_execve(const char *filename, const char *argv[],
+                     const char *envp[]);
+/* ap_execle() is a wrapper function around ap_execve(). */
+#define execle  ap_execle
+#define execve(path,argv,envp)  ap_execve(path,argv,envp)
+#endif
+
+/* Finding offsets of elements within structures.
+ * Taken from the X code... they've sweated portability of this stuff
+ * so we don't have to.  Sigh...
+ */
+
+#if defined(CRAY) || (defined(__arm) && !defined(LINUX))
+#ifdef __STDC__
+#define XtOffset(p_type,field) _Offsetof(p_type,field)
+#else
+#ifdef CRAY2
+#define XtOffset(p_type,field) \
+	(sizeof(int)*((unsigned int)&(((p_type)NULL)->field)))
+
+#else /* !CRAY2 */
+
+#define XtOffset(p_type,field) ((unsigned int)&(((p_type)NULL)->field))
+
+#endif /* !CRAY2 */
+#endif /* __STDC__ */
+#else /* ! (CRAY || __arm) */
+
+#define XtOffset(p_type,field) \
+	((long) (((char *) (&(((p_type)NULL)->field))) - ((char *) NULL)))
+
+#endif /* !CRAY */
+
+#ifdef offsetof
+#define XtOffsetOf(s_type,field) offsetof(s_type,field)
+#else
+#define XtOffsetOf(s_type,field) XtOffset(s_type*,field)
+#endif
+
+/*
+ * NET_SIZE_T exists because of shortsightedness on the POSIX committee.  BSD
+ * systems used "int *" as the parameter to accept(), getsockname(),
+ * getpeername() et al.  Consequently many unixes took an int * for that
+ * parameter.  The POSIX committee decided that "int" was just too generic and
+ * had to be replaced with size_t almost everywhere.  There's no problem with
+ * that when you're passing by value.  But when you're passing by reference
+ * this creates a gross source incompatibility with existing programs.  On
+ * 32-bit architectures it creates only a warning.  On 64-bit architectures it
+ * creates broken code -- because "int *" is a pointer to a 64-bit quantity and
+ * "size_t *" is frequently a pointer to a 32-bit quantity.
+ *
+ * Some Unixes adopted "size_t *" for the sake of POSIX compliance.  Others
+ * ignored it because it was such a broken interface.  Chaos ensued.  POSIX
+ * finally woke up and decided that it was wrong and created a new type
+ * socklen_t.  The only useful value for socklen_t is int, and that's how
+ * everyone who has a clue implements it.  It is almost always the case that
+ * NET_SIZE_T should be defined to be an int, unless the system being compiled
+ * for was created in the window of POSIX madness.
+ */
+#ifndef NET_SIZE_T
+#define NET_SIZE_T int
+#endif
+
+/* Linux defines __WCOREDUMP, but doesn't define WCOREDUMP unless __USE_BSD
+ * is in use... we'd prefer to just use WCOREDUMP everywhere.
+ */
+#if defined(__WCOREDUMP) && !defined(WCOREDUMP)
+#define WCOREDUMP __WCOREDUMP
+#endif
+
+#ifdef SUNOS_LIB_PROTOTYPES
+/* Prototypes needed to get a clean compile with gcc -Wall.
+ * Believe it or not, these do have to be declared, at least on SunOS,
+ * because they aren't mentioned in the relevant system headers.
+ * Sun Quality Software.  Gotta love it.  This section is not 
+ * currently (13Nov97) used.
+ */
+
+int getopt(int, char **, char *);
+
+int strcasecmp(const char *, const char *);
+int strncasecmp(const char *, const char *, int);
+int toupper(int);
+int tolower(int);
+
+int printf(char *,...);
+int fprintf(FILE *, char *,...);
+int fputs(char *, FILE *);
+int fread(char *, int, int, FILE *);
+int fwrite(char *, int, int, FILE *);
+int fgetc(FILE *);
+char *fgets(char *s, int, FILE*);
+int fflush(FILE *);
+int fclose(FILE *);
+int ungetc(int, FILE *);
+int _filbuf(FILE *);	/* !!! */
+int _flsbuf(unsigned char, FILE *);	/* !!! */
+int sscanf(char *, char *,...);
+void setbuf(FILE *, char *);
+void perror(char *);
+
+time_t time(time_t *);
+int strftime(char *, int, const char *, struct tm *);
+
+int initgroups(char *, int);
+int wait3(int *, int, void *);	/* Close enough for us... */
+int lstat(const char *, struct stat *);
+int stat(const char *, struct stat *);
+int flock(int, int);
+#ifndef NO_KILLPG
+int killpg(int, int);
+#endif
+int socket(int, int, int);
+int setsockopt(int, int, int, const char *, int);
+int listen(int, int);
+int bind(int, struct sockaddr *, int);
+int connect(int, struct sockaddr *, int);
+int accept(int, struct sockaddr *, int *);
+int shutdown(int, int);
+
+int getsockname(int s, struct sockaddr *name, int *namelen);
+int getpeername(int s, struct sockaddr *name, int *namelen);
+int gethostname(char *name, int namelen);
+void syslog(int, char *,...);
+char *mktemp(char *);
+
+long vfprintf(FILE *, const char *, va_list);
+
+#endif /* SUNOS_LIB_PROTOTYPES */
+
+/* The assumption is that when the functions are missing,
+ * then there's no matching prototype available either.
+ * Declare what is needed exactly as the replacement routines implement it.
+ */
+#ifdef NEED_STRDUP
+extern char *strdup (const char *str);
+#endif
+#ifdef NEED_STRCASECMP
+extern int strcasecmp (const char *a, const char *b);
+#endif
+#ifdef NEED_STRNCASECMP
+extern int strncasecmp (const char *a, const char *b, int n);
+#endif
+#ifdef NEED_INITGROUPS
+extern int initgroups(const char *name, gid_t basegid);
+#endif
+#ifdef NEED_WAITPID
+extern int waitpid(pid_t pid, int *statusp, int options);
+#endif
+#ifdef NEED_STRERROR
+extern char *strerror (int err);
+#endif
+#ifdef NEED_DIFFTIME
+extern double difftime(time_t time1, time_t time0);
+#endif
+
+#ifndef ap_wait_t
+#define ap_wait_t int
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !AP_CONFIG_H */
Only in apache_1.3.1/src/include: ap_ctype.h
diff -BEr -U 6 apache_1.3.0/src/include/ap.h apache_1.3.1/src/include/ap.h
--- apache_1.3.0/src/include/ap.h	1998-05-12 04:42:35.000000000 +0800
+++ apache_1.3.1/src/include/ap.h	1998-07-09 02:02:16.000000000 +0800
@@ -50,27 +50,26 @@
  * individuals on behalf of the Apache Group and was originally based
  * on public domain software written at the National Center for
  * Supercomputing Applications, University of Illinois, Urbana-Champaign.
  * For more information on the Apache Group and the Apache HTTP server
  * project, please see <http://www.apache.org/>.
  *
- * This code is based on, and used with the permission of, the
- * SIO stdio-replacement strx_* functions by Panos Tsirigotis
- * <panos@alumni.cs.colorado.edu> for xinetd.
+ * The ap_vsnprintf/ap_snprintf functions are based on, and used with the
+ * permission of, the  SIO stdio-replacement strx_* functions by Panos
+ * Tsirigotis <panos@alumni.cs.colorado.edu> for xinetd.
  */
 
 #ifndef APACHE_AP_H
 #define APACHE_AP_H
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 API_EXPORT(char *) ap_cpystrn(char *, const char *, size_t);
 int ap_slack(int, int);
-API_EXPORT(char *) ap_escape_quotes(pool *, const char *);
 API_EXPORT(int) ap_snprintf(char *, size_t, const char *, ...);
 API_EXPORT(int) ap_vsnprintf(char *, size_t, const char *, va_list ap);
 int ap_execle(const char *, const char *, ...);
 int ap_execve(const char *, const char *argv[], const char *envp[]);
 
 /* small utility macros to make things easier to read */
diff -BEr -U 6 apache_1.3.0/src/include/buff.h apache_1.3.1/src/include/buff.h
--- apache_1.3.0/src/include/buff.h	1998-05-29 06:09:46.000000000 +0800
+++ apache_1.3.1/src/include/buff.h	1998-07-05 00:07:25.000000000 +0800
@@ -150,13 +150,13 @@
 #endif
 API_EXPORT(int) ap_bsetopt(BUFF *fb, int optname, const void *optval);
 API_EXPORT(int) ap_bgetopt(BUFF *fb, int optname, void *optval);
 API_EXPORT(int) ap_bsetflag(BUFF *fb, int flag, int value);
 API_EXPORT(int) ap_bclose(BUFF *fb);
 
-#define bgetflag(fb, flag)	((fb)->flags & (flag))
+#define ap_bgetflag(fb, flag)	((fb)->flags & (flag))
 
 /* Error handling */
 API_EXPORT(void) ap_bonerror(BUFF *fb, void (*error) (BUFF *, int, void *),
 			  void *data);
 
 /* I/O */
diff -BEr -U 6 apache_1.3.0/src/include/compat.h apache_1.3.1/src/include/compat.h
--- apache_1.3.0/src/include/compat.h	1998-05-29 06:09:46.000000000 +0800
+++ apache_1.3.1/src/include/compat.h	1998-07-15 11:27:03.000000000 +0800
@@ -1,417 +1,9 @@
 /*
-**  compat.h -- Apache Backward Compatibility
-**
-**  INCLUDE THIS HEADER FILE ONLY IF YOU REALLY NEED
-**  BACKWARD COMPATIBILITY TO OLD APACHE RESOURCES.
-*/
-
-#ifndef APACHE_COMPAT_H
-#define APACHE_COMPAT_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* 
- *   Mapping of Apache 1.2 global symbols to the
- *   namespace conflict free variants used in Apache 1.3
- */
-
-#define MD5Final                       ap_MD5Final
-#define MD5Init                        ap_MD5Init
-#define MD5Update                      ap_MD5Update
-#define acquire_mutex                  ap_acquire_mutex
-#define add_cgi_vars                   ap_add_cgi_vars
-#define add_common_vars                ap_add_common_vars
-#define add_module                     ap_add_module
-#define add_named_module               ap_add_named_module
-#define add_per_dir_conf               ap_add_per_dir_conf
-#define add_per_url_conf               ap_add_per_url_conf
-#define allow_options                  ap_allow_options
-#define allow_overrides                ap_allow_overrides
-#define apapi_get_server_built         ap_get_server_built
-#define apapi_get_server_version       ap_get_server_version
-#define aplog_error                    ap_log_error
-#define append_arrays                  ap_append_arrays
-#define array_cat                      ap_array_cat
-#define auth_name                      ap_auth_name
-#define auth_type                      ap_auth_type
-#define basic_http_header              ap_basic_http_header
-#define bclose                         ap_bclose
-#define bcreate                        ap_bcreate
-#define bfilbuf                        ap_bfilbuf
-#define bfileno                        ap_bfileno
-#define bflsbuf                        ap_bflsbuf
-#define bflush                         ap_bflush
-#define bgetc                          ap_bgetc
-#define bgetopt                        ap_bgetopt
-#define bgets                          ap_bgets
-#define bhalfduplex                    ap_bhalfduplex
-#define bind_address                   ap_bind_address
-#define block_alarms                   ap_block_alarms
-#define blookc                         ap_blookc
-#define bnonblock                      ap_bnonblock
-#define bonerror                       ap_bonerror
-#define bprintf                        ap_bprintf
-#define bpushfd                        ap_bpushfd
-#define bputc                          ap_bputc
-#define bputs                          ap_bputs
-#define bread                          ap_bread
-#define bsetflag                       ap_bsetflag
-#define bsetopt                        ap_bsetopt
-#define bskiplf                        ap_bskiplf
-#define bvputs                         ap_bvputs
-#define bwrite                         ap_bwrite
-#define bytes_in_free_blocks           ap_bytes_in_free_blocks
-#define bytes_in_pool                  ap_bytes_in_pool
-#define call_exec                      ap_call_exec
-#define can_exec                       ap_can_exec
-#define cfg_closefile                  ap_cfg_closefile
-#define cfg_getc                       ap_cfg_getc
-#define cfg_getline                    ap_cfg_getline
-#define chdir_file                     ap_chdir_file
-#define check_access                   ap_check_access
-#define check_alarm                    ap_check_alarm
-#define check_auth                     ap_check_auth
-#define check_cmd_context              ap_check_cmd_context
-#define check_user_id                  ap_check_user_id
-#define checkmask                      ap_checkmask
-#define child_exit_modules             ap_child_exit_modules
-#define child_init_modules             ap_child_init_modules
-#define child_terminate                ap_child_terminate
-#define cleanup_for_exec               ap_cleanup_for_exec
-#define clear_module_list              ap_clear_module_list
-#define clear_pool                     ap_clear_pool
-#define clear_table                    ap_clear_table
-#define close_piped_log                ap_close_piped_log
-#define construct_server               ap_construct_server
-#define construct_url                  ap_construct_url
-#define copy_array                     ap_copy_array
-#define copy_array_hdr                 ap_copy_array_hdr
-#define copy_table                     ap_copy_table
-#define core_reorder_directories       ap_core_reorder_directories
-#define coredump_dir                   ap_coredump_dir
-#define count_dirs                     ap_count_dirs
-#define create_environment             ap_create_environment
-#define create_mutex                   ap_create_mutex
-#define create_per_dir_config          ap_create_per_dir_config
-#define create_request_config          ap_create_request_config
-#define daemons_limit                  ap_daemons_limit
-#define daemons_max_free               ap_daemons_max_free
-#define daemons_min_free               ap_daemons_min_free
-#define daemons_to_start               ap_daemons_to_start
-#define day_snames                     ap_day_snames
-#define default_port                   ap_default_port
-#define default_port_for_request       ap_default_port_for_request
-#define default_port_for_scheme        ap_default_port_for_scheme
-#define default_type                   ap_default_type
-#define destroy_mutex                  ap_destroy_mutex
-#define destroy_pool                   ap_destroy_pool
-#define destroy_sub_req                ap_destroy_sub_req
-#define die                            ap_die
-#define discard_request_body           ap_discard_request_body
-#define document_root                  ap_document_root
-#define dummy_mutex                    ap_dummy_mutex
-#define each_byterange                 ap_each_byterange
-#define error_log2stderr               ap_error_log2stderr
-#define escape_html                    ap_escape_html
-#define escape_path_segment            ap_escape_path_segment
-#define escape_shell_cmd               ap_escape_shell_cmd
-#define excess_requests_per_child      ap_excess_requests_per_child
-#define exists_scoreboard_image        ap_exists_scoreboard_image
-#define finalize_request_protocol      ap_finalize_request_protocol
-#define finalize_sub_req_protocol      ap_finalize_sub_req_protocol
-#define find_command                   ap_find_command
-#define find_command_in_modules        ap_find_command_in_modules
-#define find_last_token                ap_find_last_token
-#define find_linked_module             ap_find_linked_module
-#define find_module_name               ap_find_module_name
-#define find_path_info                 ap_find_path_info
-#define find_pool                      ap_find_pool
-#define find_token                     ap_find_token
-#define find_types                     ap_find_types
-#define fini_vhost_config              ap_fini_vhost_config
-#define fnmatch                        ap_fnmatch
-#define force_library_loading          ap_force_library_loading
-#define get_basic_auth_pw              ap_get_basic_auth_pw
-#define get_client_block               ap_get_client_block
-#define get_gmtoff                     ap_get_gmtoff
-#define get_local_host                 ap_get_local_host
-#define get_module_config              ap_get_module_config
-#define get_remote_host                ap_get_remote_host
-#define get_remote_logname             ap_get_remote_logname
-#define get_server_name                ap_get_server_name
-#define get_server_port                ap_get_server_port
-#define get_time                       ap_get_time
-#define get_token                      ap_get_token
-#define get_virthost_addr              ap_get_virthost_addr
-#define getparents                     ap_getparents
-#define getword                        ap_getword
-#define getword_conf                   ap_getword_conf
-#define getword_conf_nc                ap_getword_conf_nc
-#define getword_nc                     ap_getword_nc
-#define getword_nulls                  ap_getword_nulls
-#define getword_nulls_nc               ap_getword_nulls_nc
-#define getword_white                  ap_getword_white
-#define getword_white_nc               ap_getword_white_nc
-#define gm_timestr_822                 ap_gm_timestr_822
-#define gname2id                       ap_gname2id
-#define group_id                       ap_group_id
-#define handle_command                 ap_handle_command
-#define hard_timeout                   ap_hard_timeout
-#define header_parse                   ap_header_parse
-#define ht_time                        ap_ht_time
-#define http_method                    ap_http_method
-#define ind                            ap_ind
-#define index_of_response              ap_index_of_response
-#define init_alloc                     ap_init_alloc
-#define init_modules                   ap_init_modules
-#define init_vhost_config              ap_init_vhost_config
-#define init_virtual_host              ap_init_virtual_host
-#define internal_redirect              ap_internal_redirect
-#define internal_redirect_handler      ap_internal_redirect_handler
-#define invoke_handler                 ap_invoke_handler
-#define is_default_port                ap_is_default_port
-#define is_directory                   ap_is_directory
-#define is_fnmatch                     ap_is_fnmatch
-#define is_initial_req                 ap_is_initial_req
-#define is_matchexp                    ap_is_matchexp
-#define is_url                         ap_is_url
-#define keepalive_timeout              ap_keepalive_timeout
-#define kill_cleanup                   ap_kill_cleanup
-#define kill_cleanups_for_fd           ap_kill_cleanups_for_fd
-#define kill_cleanups_for_socket       ap_kill_cleanups_for_socket
-#define kill_timeout                   ap_kill_timeout
-#define limit_section                  ap_limit_section
-#define listenbacklog                  ap_listenbacklog
-#define listeners                      ap_listeners
-#define lock_fname                     ap_lock_fname
-#define log_assert                     ap_log_assert
-#define log_error                      ap_log_error_old
-#define log_pid                        ap_log_pid
-#define log_printf                     ap_log_printf
-#define log_reason                     ap_log_reason
-#define log_transaction                ap_log_transaction
-#define log_unixerr                    ap_log_unixerr
-#define make_array                     ap_make_array
-#define make_dirstr                    ap_make_dirstr
-#define make_dirstr_parent             ap_make_dirstr_parent
-#define make_dirstr_prefix             ap_make_dirstr_prefix
-#define make_full_path                 ap_make_full_path
-#define make_sub_pool                  ap_make_sub_pool
-#define make_table                     ap_make_table
-#define matches_request_vhost          ap_matches_request_vhost
-#define max_requests_per_child         ap_max_requests_per_child
-#define md5                            ap_md5
-#define meets_conditions               ap_meets_conditions
-#define merge_per_dir_configs          ap_merge_per_dir_configs
-#define month_snames                   ap_month_snames
-#define no2slash                       ap_no2slash
-#define note_auth_failure              ap_note_auth_failure
-#define note_basic_auth_failure        ap_note_basic_auth_failure
-#define note_cleanups_for_fd           ap_note_cleanups_for_fd
-#define note_cleanups_for_file         ap_note_cleanups_for_file
-#define note_cleanups_for_socket       ap_note_cleanups_for_socket
-#define note_digest_auth_failure       ap_note_digest_auth_failure
-#define note_subprocess                ap_note_subprocess
-#define null_cleanup                   ap_null_cleanup
-#define open_logs                      ap_open_logs
-#define open_mutex                     ap_open_mutex
-#define open_piped_log                 ap_open_piped_log
-#define os_canonical_filename          ap_os_canonical_filename
-#define os_dl_load                     ap_os_dso_load
-#define os_dl_unload                   ap_os_dso_unload
-#define os_dl_sym                      ap_os_dso_sym
-#define os_dl_error                    ap_os_dso_error
-#define os_escape_path                 ap_os_escape_path
-#define os_is_path_absolute            ap_os_is_path_absolute
-#define overlay_tables                 ap_overlay_tables
-#define palloc                         ap_palloc
-#define parseHTTPdate                  ap_parseHTTPdate
-#define parse_hostinfo_components      ap_parse_hostinfo_components
-#define parse_htaccess                 ap_parse_htaccess
-#define parse_uri                      ap_parse_uri
-#define parse_uri_components           ap_parse_uri_components
-#define parse_vhost_addrs              ap_parse_vhost_addrs
-#define pcalloc                        ap_pcalloc
-#define pcfg_open_custom               ap_pcfg_open_custom
-#define pcfg_openfile                  ap_pcfg_openfile
-#define pclosedir                      ap_pclosedir
-#define pclosef                        ap_pclosef
-#define pclosesocket                   ap_pclosesocket
-#define pduphostent                    ap_pduphostent
-#define pfclose                        ap_pfclose
-#define pfdopen                        ap_pfdopen
-#define pfopen                         ap_pfopen
-#define pgethostbyname                 ap_pgethostbyname
-#define pid_fname                      ap_pid_fname
-#define piped_log_read_fd              ap_piped_log_read_fd
-#define piped_log_write_fd             ap_piped_log_write_fd
-#define pool_is_ancestor               ap_pool_is_ancestor
-#define pool_join                      ap_pool_join
-#define popendir                       ap_popendir
-#define popenf                         ap_popenf
-#define pregcomp                       ap_pregcomp
-#define pregfree                       ap_pregfree
-#define pregsub                        ap_pregsub
-#define process_request                ap_process_request
-#define process_resource_config        ap_process_resource_config
-#define proxy_add_header               ap_proxy_add_header
-#define proxy_c2hex                    ap_proxy_c2hex
-#define proxy_cache_check              ap_proxy_cache_check
-#define proxy_cache_error              ap_proxy_cache_error
-#define proxy_cache_tidy               ap_proxy_cache_tidy
-#define proxy_cache_update             ap_proxy_cache_update
-#define proxy_canon_netloc             ap_proxy_canon_netloc
-#define proxy_canonenc                 ap_proxy_canonenc
-#define proxy_connect_handler          ap_proxy_connect_handler
-#define proxy_date_canon               ap_proxy_date_canon
-#define proxy_del_header               ap_proxy_del_header
-#define proxy_doconnect                ap_proxy_doconnect
-#define proxy_ftp_canon                ap_proxy_ftp_canon
-#define proxy_ftp_handler              ap_proxy_ftp_handler
-#define proxy_garbage_coll             ap_proxy_garbage_coll
-#define proxy_garbage_init             ap_proxy_garbage_init
-#define proxy_get_header               ap_proxy_get_header
-#define proxy_hash                     ap_proxy_hash
-#define proxy_hex2c                    ap_proxy_hex2c
-#define proxy_hex2sec                  ap_proxy_hex2sec
-#define proxy_host2addr                ap_proxy_host2addr
-#define proxy_http_canon               ap_proxy_http_canon
-#define proxy_http_handler             ap_proxy_http_handler
-#define proxy_is_domainname            ap_proxy_is_domainname
-#define proxy_is_hostname              ap_proxy_is_hostname
-#define proxy_is_ipaddr                ap_proxy_is_ipaddr
-#define proxy_is_word                  ap_proxy_is_word
-#define proxy_liststr                  ap_proxy_liststr
-#define proxy_read_headers             ap_proxy_read_headers
-#define proxy_sec2hex                  ap_proxy_sec2hex
-#define proxy_send_fb                  ap_proxy_send_fb
-#define proxy_send_headers             ap_proxy_send_headers
-#define proxyerror                     ap_proxyerror
-#define psignature                     ap_psignature
-#define psocket                        ap_psocket
-#define psprintf                       ap_psprintf
-#define pstrcat                        ap_pstrcat
-#define pstrdup                        ap_pstrdup
-#define pstrndup                       ap_pstrndup
-#define push_array                     ap_push_array
-#define pvsprintf                      ap_pvsprintf
-#define rationalize_mtime              ap_rationalize_mtime
-#define read_config                    ap_read_config
-#define read_request                   ap_read_request
-#define register_cleanup               ap_register_cleanup
-#define register_other_child           ap_register_other_child
-#define release_mutex                  ap_release_mutex
-#define remove_module                  ap_remove_module
-#define requires                       ap_requires
-#define reset_timeout                  ap_reset_timeout
-#define response_code_string           ap_response_code_string
-#define restart_time                   ap_restart_time
-#define rfc1413                        ap_rfc1413
-#define rfc1413_timeout                ap_rfc1413_timeout
-#define rflush                         ap_rflush
-#define rind                           ap_rind
-#define rprintf                        ap_rprintf
-#define rputc                          ap_rputc
-#define rputs                          ap_rputs
-#define run_cleanup                    ap_run_cleanup
-#define run_fixups                     ap_run_fixups
-#define run_post_read_request          ap_run_post_read_request
-#define run_sub_req                    ap_run_sub_req
-#define rvputs                         ap_rvputs
-#define rwrite                         ap_rwrite
-#define satisfies                      ap_satisfies
-#define scan_script_header_err         ap_scan_script_header_err
-#define scan_script_header_err_buff    ap_scan_script_header_err_buff
-#define scoreboard_fname               ap_scoreboard_fname
-#define scoreboard_image               ap_scoreboard_image
-#define send_error_response            ap_send_error_response
-#define send_fb                        ap_send_fb
-#define send_fb_length                 ap_send_fb_length
-#define send_fd                        ap_send_fd
-#define send_fd_length                 ap_send_fd_length
-#define send_header_field              ap_send_header_field
-#define send_http_header               ap_send_http_header
-#define send_http_options              ap_send_http_options
-#define send_http_trace                ap_send_http_trace
-#define send_mmap                      ap_send_mmap
-#define send_size                      ap_send_size
-#define server_argv0                   ap_server_argv0
-#define server_confname                ap_server_confname
-#define server_post_read_config        ap_server_post_read_config
-#define server_pre_read_config         ap_server_pre_read_config
-#define server_root                    ap_server_root
-#define server_root_relative           ap_server_root_relative
-#define set_byterange                  ap_set_byterange
-#define set_callback_and_alarm         ap_set_callback_and_alarm
-#define set_content_length             ap_set_content_length
-#define set_etag                       ap_set_etag
-#define set_file_slot                  ap_set_file_slot
-#define set_flag_slot                  ap_set_flag_slot
-#define set_keepalive                  ap_set_keepalive
-#define set_last_modified              ap_set_last_modified
-#define set_module_config              ap_set_module_config
-#define set_name_virtual_host          ap_set_name_virtual_host
-#define set_string_slot                ap_set_string_slot
-#define set_string_slot_lower          ap_set_string_slot_lower
-#define set_sub_req_protocol           ap_set_sub_req_protocol
-#define setup_client_block             ap_setup_client_block
-#define setup_prelinked_modules        ap_setup_prelinked_modules
-#define should_client_block            ap_should_client_block
-#define show_directives                ap_show_directives
-#define show_modules                   ap_show_modules
-#define soft_timeout                   ap_soft_timeout
-#define some_auth_required             ap_some_auth_required
-#define spawn_child_err                ap_spawn_child
-#define spawn_child_err_buff           ap_bspawn_child
-#define srm_command_loop               ap_srm_command_loop
-#define standalone                     ap_standalone
-#define start_restart                  ap_start_restart
-#define start_shutdown                 ap_start_shutdown
-#define str_tolower                    ap_str_tolower
-#define strcasecmp_match               ap_strcasecmp_match
-#define strcmp_match                   ap_strcmp_match
-#define sub_req_lookup_file            ap_sub_req_lookup_file
-#define sub_req_lookup_uri             ap_sub_req_lookup_uri
-#define suexec_enabled                 ap_suexec_enabled
-#define sync_scoreboard_image          ap_sync_scoreboard_image
-#define table_add                      ap_table_add
-#define table_addn                     ap_table_addn
-#define table_do                       ap_table_do
-#define table_get                      ap_table_get
-#define table_merge                    ap_table_merge
-#define table_mergen                   ap_table_mergen
-#define table_set                      ap_table_set
-#define table_setn                     ap_table_setn
-#define table_unset                    ap_table_unset
-#define threads_per_child              ap_threads_per_child
-#define time_process_request           ap_time_process_request
-#define tm2sec                         ap_tm2sec
-#define translate_name                 ap_translate_name
-#define uname2id                       ap_uname2id
-#define unblock_alarms                 ap_unblock_alarms
-#define unescape_url                   ap_unescape_url
-#define unparse_uri_components         ap_unparse_uri_components
-#define unregister_other_child         ap_unregister_other_child
-#define update_child_status            ap_update_child_status
-#define update_mtime                   ap_update_mtime
-#define update_vhost_from_headers      ap_update_vhost_from_headers
-#define update_vhost_given_ip          ap_update_vhost_given_ip
-#define user_id                        ap_user_id
-#define user_name                      ap_user_name
-#define util_init                      ap_util_init
-#define util_uri_init                  ap_util_uri_init
-#define uudecode                       ap_uudecode
-#define vbprintf                       ap_vbprintf
-
-/* 
- *  Macros for routines whose arguments have changed over time.
+ *  compat.h -- backward compatibility header for ap_compat.h
  */
-#define spawn_child(p,f,v,k,in,out) ap_spawn_child(p,f,v,k,in,out,NULL)
 
-#ifdef __cplusplus
-}
+#ifdef __GNUC__
+#warning "This header is obsolete, use ap_compat.h instead"
 #endif
 
-#endif /* APACHE_COMPAT_H */
+#include "ap_compat.h"
diff -BEr -U 6 apache_1.3.0/src/include/conf.h apache_1.3.1/src/include/conf.h
--- apache_1.3.0/src/include/conf.h	1998-05-29 08:15:56.000000000 +0800
+++ apache_1.3.1/src/include/conf.h	1998-07-15 11:27:03.000000000 +0800
@@ -1,1173 +1,9 @@
-/* ====================================================================
- * Copyright (c) 1995-1998 The Apache Group.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the Apache Group
- *    for use in the Apache HTTP server project (http://www.apache.org/)."
- *
- * 4. The names "Apache Server" and "Apache Group" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    apache@apache.org.
- *
- * 5. Products derived from this software may not be called "Apache"
- *    nor may "Apache" appear in their names without prior written
- *    permission of the Apache Group.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the Apache Group
- *    for use in the Apache HTTP server project (http://www.apache.org/)."
- *
- * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Apache Group and was originally based
- * on public domain software written at the National Center for
- * Supercomputing Applications, University of Illinois, Urbana-Champaign.
- * For more information on the Apache Group and the Apache HTTP server
- * project, please see <http://www.apache.org/>.
- *
- */
-
-#ifndef APACHE_CONF_H
-#define APACHE_CONF_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * conf.h: system-dependant #defines and includes...
- * See PORTING for a listing of what they mean
- */
-
-
-/* Have to include sys/stat.h before ../os/win32/os.h so we can override
-stat() properly */
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#ifdef WIN32
-/* include process.h first so we can override spawn[lv]e* properly */
-#include <process.h>
-#include "../os/win32/os.h"
-#else
-#include "os.h"
-#endif
-
-#if !defined(QNX) && !defined(MPE) && !defined(WIN32)
-#include <sys/param.h>
-#endif
-
-/* Define one of these according to your system. */
-#if defined(MINT)
-typedef int rlim_t;
-#define HAVE_SYS_RESOURCE_H 1
-#define JMP_BUF sigjmp_buf
-#define NO_LONG_DOUBLE
-#define USE_FLOCK_SERIALIZED_ACCEPT
-#define _BSD_SOURCE
-#define EAGAIN EWOULDBLOCK
-int initgroups (char *, int);     
-char *crypt (const char *pw, const char *salt);
-int gethostname (char *name, int namelen);
-
-#elif defined(MPE)
-#include <sys/times.h>
-#define NO_SETSID
-#define NO_KILLPG
-#define NO_WRITEV
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#define SHM_R 0400  /* Read permission */
-#define SHM_W 0200  /* Write permission */
-#define NEED_INITGROUPS
-#define NEED_STRCASECMP
-#define NEED_STRDUP
-#define NEED_STRNCASECMP
-extern void GETPRIVMODE();
-extern void GETUSERMODE();
-extern char *inet_ntoa();
-#define NO_SLACK
-#define NO_GETTIMEOFDAY
-#define S_IEXEC  S_IXUSR
-#define S_IREAD  S_IRUSR
-#define S_IWRITE S_IWUSR
-#define PF_INET  AF_INET
-
-#elif defined(SUNOS4)
-#define HAVE_GMTOFF 1
-#define HAVE_SYS_RESOURCE_H 1
-#undef NO_KILLPG
-#undef NO_SETSID
-char *crypt(const char *pw, const char *salt);
-char *mktemp(char *template);
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#include <sys/time.h>
-#define NEED_STRERROR
-typedef int rlim_t;
-#define memmove(a,b,c) bcopy(b,a,c)
-#define NO_LINGCLOSE
-#define USE_FLOCK_SERIALIZED_ACCEPT
-#define NEED_DIFFTIME
-#define HAVE_SYSLOG 1
-
-#elif defined(SOLARIS2)
-#undef HAVE_GMTOFF
-#define NO_KILLPG
-#undef NO_SETSID
-#define HAVE_SYS_RESOURCE_H 1
-#define HAVE_DLFCN_H 1
-#define bzero(a,b) memset(a,0,b)
-#if !defined(USE_SYSVSEM_SERIALIZED_ACCEPT) && \
-    !defined(USE_PTHREAD_SERIALIZED_ACCEPT)
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#endif
-#define NEED_UNION_SEMUN
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#define HAVE_CRYPT_H 1
-int gethostname(char *name, int namelen);
-#define HAVE_SYSLOG 1
-#define SYS_SIGLIST _sys_siglist
-
-#elif defined(IRIX)
-#undef HAVE_GMTOFF
-/* IRIX has killpg, but it's only in _BSD_COMPAT, so don't use it in case
- * there's some weird conflict with non-BSD signals */
-#define NO_KILLPG
-#undef NO_SETSID
-#if !defined(USE_FCNTL_SERIALIZED_ACCEPT) && !defined(USE_USLOCK_SERIALIZED_ACCEPT)
-#define USE_SYSVSEM_SERIALIZED_ACCEPT
-#endif
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#define HAVE_MMAP 1
-#define USE_MMAP_FILES
-#define HAVE_CRYPT_H 1
-#define HAVE_DLFCN_H 1
-#define NO_LONG_DOUBLE
-#define HAVE_BSTRING_H 1
-#define NO_LINGCLOSE
-#define HAVE_SYSLOG 1
-
-#elif defined(HIUX)
-#define HAVE_SYS_RESOURCE_H 1
-#undef HAVE_GMTOFF
-#define NO_KILLPG
-#undef NO_SETSID
-#ifndef _HIUX_SOURCE
-#define _HIUX_SOURCE
-#endif
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#define SELECT_NEEDS_CAST
-#define HAVE_SYSLOG 1
-
-#elif defined(HPUX) || defined(HPUX10)
-#define HAVE_SYS_RESOURCE_H 1
-#undef HAVE_GMTOFF
-#define NO_KILLPG
-#undef NO_SETSID
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#ifndef _HPUX_SOURCE
-#define _HPUX_SOURCE
-#endif
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#define HAVE_SYSLOG 1
-#ifndef HPUX10
-#define SELECT_NEEDS_CAST
-typedef int rlim_t;
-#endif
-
-#elif defined(HPUX11)
-#ifndef _HPUX_SOURCE
-#define _HPUX_SOURCE
-#endif
-#define HAVE_SHMGET
-#define USE_SHMGET_SCOREBOARD
-#undef  HAVE_GMTOFF
-#define HAVE_RESOURCE
-#define HAVE_CRYPT_H
-#undef  HAVE_SYS_SELECT_H
-#define HAVE_SYS_RESOURCE_H
-#define USE_FCNTL_SERIALIZED_ACCEPT
-/* feeling brave?  want to try using POSIX mutexes? */
-/* #define HAVE_MMAP */
-/* #define USE_MMAP_SCOREBOARD */
-/* #define USE_MMAP_FILES */
-/* #define USE_PTHREAD_SERIALIZED_ACCEPT */
-#define NO_KILLPG
-#undef  NO_SETSID
-#define HAVE_SYSLOG
-
-#elif defined(AIX)
-#undef HAVE_GMTOFF
-#undef NO_KILLPG
-#undef NO_SETSID
-#define HAVE_SYS_SELECT_H 1
-#ifndef __ps2__
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#define HAVE_SYSLOG 1
-#ifndef DEFAULT_GROUP
-#define DEFAULT_GROUP "nobody"
-#endif
-#endif
-#ifndef DEFAULT_USER
-#define DEFAULT_USER "nobody"
-#endif
-#ifdef NEED_RLIM_T
-typedef int rlim_t;
-#endif
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#ifdef USEBCOPY
-#define memmove(a,b,c) bcopy(b,a,c)
-#endif
-#if AIX >= 42
-#define NET_SIZE_T size_t
-#endif
-
-#elif defined(ULTRIX)
-#define HAVE_GMTOFF 1
-#undef NO_KILLPG
-#undef NO_SETSID
-#define ULTRIX_BRAIN_DEATH
-#define NEED_STRDUP
-/* If you have Ultrix 4.3, and are using cc, const is broken */
-#ifndef __ultrix__		/* Hack to check for pre-Ultrix 4.4 cc */
-#define const			/* Not implemented */
-#endif
-
-#elif defined(OSF1)
-#define HAVE_GMTOFF 1
-#undef NO_KILLPG
-#undef NO_SETSID
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#define HAVE_CRYPT_H 1
-#define NO_LONG_DOUBLE
-#define HAVE_SYSLOG 1
-#define USE_FLOCK_SERIALIZED_ACCEPT
-#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
-
-#elif defined(PARAGON)
-#define HAVE_GMTOFF 1
-#undef NO_KILLPG
-#undef NO_SETSID
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#define HAVE_CRYPT_H 1
-#define NO_LONG_DOUBLE
-#define HAVE_SYSLOG 1
-typedef int rlim_t;
-
-#elif defined(SEQUENT)
-#define HAVE_GMTOFF 1
-#undef NO_KILLPG
-#define NO_SETSID
-#define NEED_STRDUP
-#define HAVE_SYSLOG 1
-#define tolower(c) (isupper(c) ? tolower(c) : c)
-
-#elif defined(NEXT)
-typedef unsigned short mode_t;
-#define HAVE_GMTOFF 1
-#undef NO_KILLPG
-#define NO_SETSID
-#define NEED_STRDUP
-#define NO_LINGCLOSE
-#define NO_UNISTD_H
-#undef _POSIX_SOURCE
-#ifndef FD_CLOEXEC
-#define FD_CLOEXEC 1
-#endif
-#ifndef S_ISDIR
-#define S_ISDIR(m)      (((m)&(S_IFMT)) == (S_IFDIR))
-#endif
-#ifndef S_ISREG
-#define S_ISREG(m)      (((m)&(S_IFMT)) == (S_IFREG))
-#endif
-#ifndef S_IXUSR
-#define S_IXUSR 00100
-#endif
-#ifndef S_IRGRP
-#define S_IRGRP 00040
-#endif
-#ifndef S_IXGRP
-#define S_IXGRP 00010
-#endif
-#ifndef S_IROTH
-#define S_IROTH 00004
-#endif
-#ifndef S_IXOTH
-#define S_IXOTH 00001
-#endif
-#ifndef S_IRUSR
-#define S_IRUSR S_IREAD
-#endif
-#ifndef S_IWUSR
-#define S_IWUSR S_IWRITE
-#endif
-#ifndef S_IWGRP
-#define S_IWGRP	000020
-#endif
-#ifndef S_IWOTH
-#define S_IWOTH 000002
-#ifndef rlim_t
-typedef int rlim_t;
-#endif
-typedef u_long n_long;
-#endif
-
-#define STDIN_FILENO  0
-#define STDOUT_FILENO 1
-#define STDERR_FILENO 2
-#define waitpid(a,b,c) wait4((a) == -1 ? 0 : (a),(union wait *)(b),c,NULL)
-typedef int pid_t;
-#define USE_LONGJMP
-#define NO_USE_SIGACTION
-#define HAVE_SYSLOG 1
-
-#elif defined(LINUX)
-#define HAVE_DLFCN_H 1
-
-#if LINUX > 1
-#include <features.h>
-
-/* libc4 systems probably still work, it probably doesn't define
- *  __GNU_LIBRARY__
- * libc5 systems define __GNU_LIBRARY__ == 1, but don't define __GLIBC__
- * glibc 2.x and later systems define __GNU_LIBRARY__ == 6, but list it as
- * "deprecated in favour of __GLIBC__"; the value 6 will never be changed.
- * glibc 1.x systems (i.e. redhat 4.x on sparc/alpha) should have
- * __GLIBC__ < 2
- * all glibc based systems need crypt.h
- */
-#if defined(__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
-#include <crypt.h>
-#endif
-
-/* glibc 2.0.0 through 2.0.4 need size_t * here, where 2.0.5 needs socklen_t *
- * there's no way to discern between these two libraries.  But using int should
- * be portable because otherwise these libs would be hopelessly broken with
- * reams of existing networking code.  We'll use socklen_t * for 2.1.x and
- * later.
- *
- * int works for all the earlier libs, and is picked up by default later.
- */
-#if defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 0))
-#define NET_SIZE_T socklen_t
-#endif
-
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#define HAVE_MMAP 1
-#define USE_MMAP_FILES
-#define HAVE_SYS_RESOURCE_H 1
-
-/* glibc 2.1 and later finally define rlim_t */
-#if !defined(__GLIBC__) || __GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 1)
-typedef int rlim_t;
-#endif
-
-/* flock is faster ... but hasn't been tested on 1.x systems */
-#define USE_FLOCK_SERIALIZED_ACCEPT
-
-#define SYS_SIGLIST	_sys_siglist
-
-#else
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#endif
-
-#undef HAVE_GMTOFF
-#undef NO_KILLPG
-#undef NO_SETSID
-#undef NEED_STRDUP
-#include <sys/time.h>
-#define HAVE_SYSLOG 1
-
-#elif defined(SCO)
-#undef HAVE_GMTOFF
-#undef NO_KILLPG
-#undef NO_SETSID
-#define NEED_INITGROUPS
-#define NO_WRITEV
-#include <sys/time.h>
-#define HAVE_SYSLOG 1
-
-#elif defined(SCO5)
-
-#define HAVE_SYS_SELECT_H 1
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#define HAVE_SYS_RESOURCE_H 1
-#define SecureWare
-#define HAVE_SYSLOG 1
-
-/* Although SCO 5 defines these in <strings.h> (note the "s") they don't have
-   consts. Sigh. */
-extern int strcasecmp(const char *, const char *);
-extern int strncasecmp(const char *, const char *, unsigned);
-
-#elif defined(AUX3)
-/* These are to let -Wall compile more cleanly */
-extern int strcasecmp(const char *, const char *);
-extern int strncasecmp(const char *, const char *, unsigned);
-extern int set42sig(), getopt(), getpeername(), bzero();
-extern int listen(), bind(), socket(), getsockname();
-extern int accept(), gethostname(), connect(), lstat();
-extern int select(), killpg(), shutdown();
-extern int initgroups(), setsockopt();
-extern char *shmat();
-extern int shmctl();
-extern int shmget();
-extern char *sbrk();
-extern char *crypt();
-#include <sys/time.h>
-#undef HAVE_GMTOFF
-#undef NO_KILLPG
-#undef NO_SETSID
-#define NEED_STRDUP
-/* fcntl() locking is expensive with NFS */
-#define USE_FLOCK_SERIALIZED_ACCEPT
-#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
 /*
- * NOTE: If when you run Apache under A/UX and you get a warning
- * that httpd couldn't move break, then the below value for
- * MOVEBREAK (64megs) is too large for your setup. Try reducing
- * to 0x2000000 which is still PLENTY of space. I doubt if
- * even on heavy systems sbrk() would be called at all...
- */
-#define MOVEBREAK		0x4000000
-#define NO_LINGCLOSE
-#define NO_SLACK
-#define HAVE_SYSLOG 1
-
-#elif defined(SVR4)
-#define NO_KILLPG
-#undef  NO_SETSID
-#undef NEED_STRDUP
-#ifndef MPRAS
-#define NEED_STRCASECMP
-#ifndef ENCORE
-#define NEED_STRNCASECMP
-#endif /* ENCORE */
-#endif /* MPRAS */
-#define bzero(a,b) memset(a,0,b)
-/* A lot of SVR4 systems need this */
-#ifndef USE_SYSVSEM_SERIALIZED_ACCEPT
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#endif
-#define HAVE_SYSLOG 1
-#define NET_SIZE_T size_t
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#ifdef _OSD_POSIX /* BS2000-POSIX mainframe needs initgroups */
-#define NEED_INITGROUPS
-#define NEED_HASHBANG_EMUL /* execve() doesn't start shell scripts by default */
-#undef HAVE_SHMGET
-#undef USE_SHMGET_SCOREBOARD
-#undef bzero
-#endif /*_OSD_POSIX*/
-
-#elif defined(UW)
-#define NO_LINGCLOSE
-#define NO_KILLPG
-#undef  NO_SETSID
-#undef NEED_STRDUP
-#define NEED_STRCASECMP
-#define NEED_STRNCASECMP
-#define bzero(a,b) memset(a,0,b)
-#define HAVE_RESOURCE 1
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#define HAVE_SHMGET 1
-#undef USE_SHMGET_SCOREBOARD	/* force use of mmap() scoreboard */
-#define HAVE_CRYPT_H 1
-#define HAVE_SYS_SELECT_H 1
-#define HAVE_SYS_RESOURCE_H 1
-#include <sys/time.h>
-#if UW >= 200
-#define _POSIX_SOURCE
-#endif
-#define NET_SIZE_T size_t
-#define HAVE_SYSLOG 1
-#define USE_FCNTL_SERIALIZED_ACCEPT
-
-#elif defined(DGUX)
-#define NO_KILLPG
-#undef  NO_SETSID
-#undef NEED_STRDUP
-#define NEED_STRCASECMP
-#define NEED_STRNCASECMP
-#define bzero(a,b) memset(a,0,b)
-/* A lot of SVR4 systems need this */
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#define ap_inet_addr inet_network
-#define HAVE_SYSLOG 1
-
-#elif defined(__NetBSD__) || defined(__OpenBSD__) || defined(NETBSD)
-#define HAVE_SYS_RESOURCE_H 1
-#define HAVE_GMTOFF 1
-#undef NO_KILLPG
-#undef NO_SETSID
-#define HAVE_SYSLOG 1
-#ifndef DEFAULT_USER
-#define DEFAULT_USER "nobody"
-#endif
-#ifndef DEFAULT_GROUP
-#define DEFAULT_GROUP "nogroup"
-#define HAVE_SHMGET 1
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#endif
-
-#elif defined(UTS21)
-#undef HAVE_GMTOFF
-#undef NO_KILLPG
-#define NO_SETSID
-#define NEED_WAITPID
-#define NO_OTHER_CHILD
-#define STDIN_FILENO 0
-#define STDOUT_FILENO 1
-#define STDERR_FILENO 2
-#define HAVE_SYSLOG 1
-#define strftime(buf,bufsize,fmt,tm)    ascftime(buf,fmt,tm)
-#include <sys/types.h>
-
-#elif defined(APOLLO)
-#undef HAVE_GMTOFF
-#undef NO_KILLPG
-#undef NO_SETSID
-#define HAVE_SYSLOG 1
-
-#elif defined(__FreeBSD__) || defined(__bsdi__)
-#if defined(__FreeBSD__)
-#include <osreldate.h>
-#endif
-#define HAVE_DLFCN_H 1
-#define HAVE_SYS_RESOURCE_H 1
-#define HAVE_GMTOFF 1
-#undef NO_KILLPG
-#undef NO_SETSID
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#ifndef DEFAULT_USER
-#define DEFAULT_USER "nobody"
-#endif
-#ifndef DEFAULT_GROUP
-#define DEFAULT_GROUP "nogroup"
-#endif
-#if defined(__bsdi__) || \
-(defined(__FreeBSD_version) && (__FreeBSD_version < 220000))
-typedef quad_t rlim_t;
-#endif
-#define USE_FLOCK_SERIALIZED_ACCEPT
-#define HAVE_SYSLOG 1
-#define SYS_SIGLIST sys_siglist
-
-#elif defined(QNX)
-#ifndef crypt
-char *crypt(const char *pw, const char *salt);
-#endif
-#ifndef initgroups
-int initgroups(char *, int);
-#endif
-#ifndef strncasecmp
-#define strncasecmp strnicmp
-#endif
-#undef NO_KILLPG
-#undef NO_SETSID
-#define NEED_INITGROUPS
-#define NEED_SELECT_H
-#define NEED_PROCESS_H
-#define HAVE_SYS_SELECT_H 1
-#include <unix.h>
-#define HAVE_MMAP 1
-#define USE_POSIX_SCOREBOARD
-#define USE_FLOCK_SERIALIZED_ACCEPT
-#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
-#define HAVE_SYSLOG 1
-
-#elif defined(LYNXOS)
-#undef HAVE_GMTOFF
-#define HAVE_RESOURCE 1
-#undef USE_MMAP_SCOREBOARD
-#undef USE_SHMGET_SCOREBOARD
-#undef HAVE_CRYPT_H
-#undef HAVE_SYS_SELECT_H
-#define HAVE_SYS_RESOURCE_H 1
-#undef USE_FCNTL_SERIALIZED_ACCEPT
-#undef USE_FLOCK_SERIALIZED_ACCEPT
-#define USE_LONGJMP
-#undef NO_UNISTD_H
-#undef NO_KILLPG
-#undef NO_SETSID
-#undef NO_USE_SIGACTION
-#undef NO_LINGCLOSE
-extern char *crypt(char *pw, char *salt);
-typedef int rlim_t;
-#define HAVE_SYSLOG 1
-
-#elif defined(UXPDS)
-#undef NEED_STRCASECMP
-#undef NEED_STRNCASECMP
-#undef NEED_STRDUP
-#undef HAVE_GMTOFF
-#define NO_KILLPG
-#undef NO_SETSID
-#define HAVE_RESOURCE 1 
-#define bzero(a,b) memset(a,0,b)
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#define HAVE_CRYPT_H 1
-#define HAVE_SYSLOG 1
-
-#elif defined(__EMX__)
-/* Defines required for EMX OS/2 port. */
-#define NO_KILLPG
-#define NEED_STRCASECMP
-#define NEED_STRNCASECMP
-#define NO_SETSID
-#define NO_TIMES
-/* Add some drive name support */
-#define chdir _chdir2
-#include <sys/time.h>
-#define MAXSOCKETS 4096
-#define USE_OS2_SCOREBOARD
-#define NO_RELIABLE_PIPED_LOGS
-#define HAVE_SYS_SELECT_H 1
-
-#elif defined(__MACHTEN__)
-typedef int rlim_t;
-#undef NO_KILLPG
-#define NO_SETSID
-#define HAVE_GMTOFF 1
-#ifndef __MACHTEN_PPC__
-#ifndef __MACHTEN_68K__
-#define __MACHTEN_68K__
-#endif
-#define USE_FLOCK_SERIALIZED_ACCEPT
-#define NO_USE_SIGACTION
-#define JMP_BUF sigjmp_buf
-#define USE_LONGJMP
-#undef NEED_STRDUP
-#else
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#endif
-
-/* Convex OS v11 */
-#elif defined(CONVEXOS11)
-#undef HAVE_GMTOFF
-#undef NO_KILLPG
-#undef NO_SETSID
-#undef NEED_STRDUP
-#define HAVE_MMAP 1
-#define USE_MMAP_SCOREBOARD
-#define USE_MMAP_FILES
-#define HAVE_SYSLOG 1
-
-#define NO_TIMEZONE
-#include <stdio.h>
-#include <sys/types.h>
-typedef int rlim_t;
-
-#elif defined(ISC)
-#include <net/errno.h>
-#define NO_KILLPG
-#undef NO_SETSID
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#define USE_FCNTL_SERIALIZED_ACCEPT
-#define HAVE_SYSLOG 1
-
-#elif defined(NEWSOS)
-#define HAVE_SYS_RESOURCE_H 1
-#define HAVE_SHMGET 1
-#define USE_SHMGET_SCOREBOARD
-#define USE_LONGJMP
-#define NO_SETSID
-#define NO_USE_SIGACTION
-#define NEED_WAITPID
-#define NO_OTHER_CHILD
-#define HAVE_SYSLOG 1
-#include <sys/time.h>
-#include <stdlib.h>
-#include <sys/types.h>
-typedef int pid_t;
-typedef int rlim_t;
-typedef int mode_t;
-
-#elif defined(RISCIX)
-#include <sys/time.h>
-typedef int rlim_t;
-#define NO_USE_SIGACTION
-#define USE_LONGJMP
-#define NEED_STRCASECMP
-#define NEED_STRNCASECMP
-#define NEED_STRDUP
-
-#elif defined(BEOS)
-#include <stddef.h>
-
-#define NO_WRITEV
-#define NO_KILLPG
-#define NEED_INITGROUPS
-
-#define isascii(c)	(!((c) & ~0177))
-
-#elif defined(WIN32)
-
-/* All windows stuff is now in os/win32/os.h */
-
-#else
-/* Unknown system - Edit these to match */
-#ifdef BSD
-#define HAVE_GMTOFF 1
-#else
-#undef HAVE_GMTOFF
-#endif
-/* NO_KILLPG is set on systems that don't have killpg */
-#undef NO_KILLPG
-/* NO_SETSID is set on systems that don't have setsid */
-#undef NO_SETSID
-/* NEED_STRDUP is set on stupid systems that don't have strdup. */
-#undef NEED_STRDUP
-#endif
-
-/* stuff marked API_EXPORT is part of the API, and intended for use
- * by modules
+ *  conf.h -- backward compatibility header for ap_config.h
  */
-#ifndef API_EXPORT
-#define API_EXPORT(type)    type
-#endif
-
-/* Stuff marked API_EXPORT_NONSTD is part of the API, and intended for
- * use by modules.  The difference between API_EXPORT and
- * API_EXPORT_NONSTD is that the latter is required for any functions
- * which use varargs or are used via indirect function call.  This
- * is to accomodate the two calling conventions in windows dlls.
- */
-#ifndef API_EXPORT_NONSTD
-#define API_EXPORT_NONSTD(type)    type
-#endif
-
-#ifndef MODULE_VAR_EXPORT
-#define MODULE_VAR_EXPORT
-#endif
-#ifndef API_VAR_EXPORT
-#define API_VAR_EXPORT
-#endif
-
-/* modules should not used functions marked CORE_EXPORT
- * or CORE_EXPORT_NONSTD */
-#ifndef CORE_EXPORT
-#define CORE_EXPORT	API_EXPORT
-#endif
-#ifndef CORE_EXPORT_NONSTD
-#define CORE_EXPORT_NONSTD	API_EXPORT_NONSTD
-#endif
-
-/* So that we can use inline on some critical functions, and use
- * GNUC attributes (such as to get -Wall warnings for printf-like
- * functions).  Only do this in gcc 2.7 or later ... it may work
- * on earlier stuff, but why chance it.
- *
- * We've since discovered that the gcc shipped with NeXT systems
- * as "cc" is completely broken.  It claims to be __GNUC__ and so
- * on, but it doesn't implement half of the things that __GNUC__
- * means.  In particular it's missing inline and the __attribute__
- * stuff.  So we hack around it.  PR#1613. -djg
- */
-#if !defined(__GNUC__) || __GNUC__ < 2 || __GNUC_MINOR__ < 7 || defined(NEXT)
-#define ap_inline
-#define __attribute__(__x)
-#define ENUM_BITFIELD(e,n,w)  signed int n : w
-#else
-#define ap_inline __inline__
-#define USE_GNU_INLINE
-#define ENUM_BITFIELD(e,n,w)  e n : w
-#endif
-
-/* Do we have sys/resource.h; assume that BSD does. */
-#ifndef HAVE_SYS_RESOURCE_H
-#ifdef BSD
-#define HAVE_SYS_RESOURCE_H 1
-#endif
-#endif /* HAVE_SYS_RESOURCE_H */
-
-/*
- * The particular directory style your system supports. If you have dirent.h
- * in /usr/include (POSIX) or /usr/include/sys (SYSV), #include 
- * that file and define DIR_TYPE to be dirent. Otherwise, if you have 
- * /usr/include/sys/dir.h, define DIR_TYPE to be direct and include that
- * file. If you have neither, I'm confused.
- */
-
-#include <sys/types.h>
-#include <stdarg.h>
-
-#if !defined(NEXT) && !defined(WIN32)
-#include <dirent.h>
-#define DIR_TYPE dirent
-#elif !defined(WIN32)
-#include <sys/dir.h>
-#define DIR_TYPE direct
-#else
-#define DIR_TYPE dirent
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#if !defined(MPE) && !defined(WIN32)
-#include <sys/file.h>
-#endif
-#ifndef WIN32
-#include <sys/socket.h>
-#ifdef HAVE_SYS_SELECT_H
-#include <sys/select.h>
-#endif /* HAVE_SYS_SELECT_H */
-#include <netinet/in.h>
-#include <netdb.h>
-#include <sys/ioctl.h>
-#if !defined(MPE) && !defined(BEOS)
-#include <arpa/inet.h>		/* for inet_ntoa */
-#endif
-#include <sys/wait.h>
-#include <pwd.h>
-#include <grp.h>
-#include <fcntl.h>
-#include <limits.h>
-#define closesocket(s) close(s)
-#ifndef O_BINARY
-#define O_BINARY (0)
-#endif
-
-#else /* WIN32 */
-#include <winsock.h>
-#include <malloc.h>
-#include <io.h>
-#include <fcntl.h>
-#endif /* ndef WIN32 */
-
-#include <time.h>		/* for ctime */
-#include <signal.h>
-#include <errno.h>
-#if !defined(QNX) && !defined(CONVEXOS11) && !defined(NEXT)
-#include <memory.h>
-#endif
-
-#ifdef NEED_PROCESS_H
-#include <process.h>
-#endif
-
-#ifdef WIN32
-#include "../include/hsregex.h"
-#elif defined(USE_HSREGEX)
-#include "hsregex.h"
-#else
-#include <regex.h>
-#endif
-
-#ifdef HAVE_SYS_RESOURCE_H
-#include <sys/resource.h>
-#ifdef SUNOS4
-int getrlimit(int, struct rlimit *);
-int setrlimit(int, struct rlimit *);
-#endif
-#endif
-#ifdef USE_MMAP_SCOREBOARD
-#if !defined(__EMX__) && !defined(WIN32)
-/* This file is not needed for OS/2 */
-#include <sys/mman.h>
-#endif
-#endif
-#if !defined(MAP_ANON) && defined(MAP_ANONYMOUS)
-#define MAP_ANON MAP_ANONYMOUS
-#endif
-
-#if defined(USE_MMAP_FILES) && (defined(NO_MMAP) || !defined(HAVE_MMAP))
-#undef USE_MMAP_FILES
-#endif
-
-#if defined(USE_MMAP_SCOREBOARD) && (defined(NO_MMAP) || !defined(HAVE_MMAP))
-#undef USE_MMAP_SCOREBOARD
-#endif
-
-#if defined(USE_SHMGET_SCOREBOARD) && (defined(NO_SHMGET) || !defined(HAVE_SHMGET))
-#undef USE_SHMGET_SCOREBOARD
-#endif
-
-#ifndef LOGNAME_MAX
-#define LOGNAME_MAX 25
-#endif
-
-#ifndef NO_UNISTD_H
-#include <unistd.h>
-#endif
-
-#ifdef ultrix
-#define ULTRIX_BRAIN_DEATH
-#endif
-
-#ifndef S_ISLNK
-#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
-#endif
-
-#ifndef INADDR_NONE
-#define INADDR_NONE ((unsigned long) -1)
-#endif
-
-/*
- * Replace signal function with sigaction equivalent
- */
-#ifndef NO_USE_SIGACTION
-typedef void Sigfunc(int);
-
-#if defined(SIG_IGN) && !defined(SIG_ERR)
-#define SIG_ERR ((Sigfunc *)-1)
-#endif
-
-/*
- * For some strange reason, QNX defines signal to signal. Eliminate it.
- */
-#ifdef signal
-#undef signal
-#endif
-#define signal(s,f)	ap_signal(s,f)
-Sigfunc *signal(int signo, Sigfunc * func);
-#endif
-
-#include <setjmp.h>
-
-#if defined(USE_LONGJMP)
-#define ap_longjmp(x, y)        longjmp((x), (y))
-#define ap_setjmp(x)            setjmp(x)
-#ifndef JMP_BUF
-#define JMP_BUF jmp_buf
-#endif
-#else
-#define ap_longjmp(x, y)        siglongjmp((x), (y))
-#define ap_setjmp(x)            sigsetjmp((x), 1)
-#ifndef JMP_BUF
-#define JMP_BUF sigjmp_buf
-#endif
-#endif
-
-#ifdef SELECT_NEEDS_CAST
-#define ap_select(_a, _b, _c, _d, _e)	\
-    select((_a), (int *)(_b), (int *)(_c), (int *)(_d), (_e))
-#else
-#define ap_select	select
-#endif
-
-#ifdef ULTRIX_BRAIN_DEATH
-#define ap_fdopen(d,m) fdopen((d), (char *)(m))
-#else
-#define ap_fdopen(d,m) fdopen((d), (m))
-#endif
-
-#ifndef ap_inet_addr
-#define ap_inet_addr inet_addr
-#endif
-
-#ifdef NO_OTHER_CHILD
-#define NO_RELIABLE_PIPED_LOGS
-#endif
-
-/* When the underlying OS doesn't support exec() of scripts which start
- * with a HASHBANG (#!) followed by interpreter name and args, define this.
- */
-#ifdef NEED_HASHBANG_EMUL
-extern int ap_execle(const char *filename, const char *arg,...);
-extern int ap_execve(const char *filename, const char *argv[],
-                     const char *envp[]);
-/* ap_execle() is a wrapper function around ap_execve(). */
-#define execle  ap_execle
-#define execve(path,argv,envp)  ap_execve(path,argv,envp)
-#endif
-
-/* Finding offsets of elements within structures.
- * Taken from the X code... they've sweated portability of this stuff
- * so we don't have to.  Sigh...
- */
-
-#if defined(CRAY) || defined(__arm)
-#ifdef __STDC__
-#define XtOffset(p_type,field) _Offsetof(p_type,field)
-#else
-#ifdef CRAY2
-#define XtOffset(p_type,field) \
-	(sizeof(int)*((unsigned int)&(((p_type)NULL)->field)))
-
-#else /* !CRAY2 */
-
-#define XtOffset(p_type,field) ((unsigned int)&(((p_type)NULL)->field))
-
-#endif /* !CRAY2 */
-#endif /* __STDC__ */
-#else /* ! (CRAY || __arm) */
-
-#define XtOffset(p_type,field) \
-	((long) (((char *) (&(((p_type)NULL)->field))) - ((char *) NULL)))
-
-#endif /* !CRAY */
-
-#ifdef offsetof
-#define XtOffsetOf(s_type,field) offsetof(s_type,field)
-#else
-#define XtOffsetOf(s_type,field) XtOffset(s_type*,field)
-#endif
-
-/* some architectures require size_t * pointers where others require int *
- * pointers in functions such as accept(), getsockname(), getpeername()
- */
-#ifndef NET_SIZE_T
-#define NET_SIZE_T int
-#endif
-
-/* Linux defines __WCOREDUMP, but doesn't define WCOREDUMP unless __USE_BSD
- * is in use... we'd prefer to just use WCOREDUMP everywhere.
- */
-#if defined(__WCOREDUMP) && !defined(WCOREDUMP)
-#define WCOREDUMP __WCOREDUMP
-#endif
-
-#ifdef SUNOS_LIB_PROTOTYPES
-/* Prototypes needed to get a clean compile with gcc -Wall.
- * Believe it or not, these do have to be declared, at least on SunOS,
- * because they aren't mentioned in the relevant system headers.
- * Sun Quality Software.  Gotta love it.  This section is not 
- * currently (13Nov97) used.
- */
-
-int getopt(int, char **, char *);
-
-int strcasecmp(const char *, const char *);
-int strncasecmp(const char *, const char *, int);
-int toupper(int);
-int tolower(int);
-
-int printf(char *,...);
-int fprintf(FILE *, char *,...);
-int fputs(char *, FILE *);
-int fread(char *, int, int, FILE *);
-int fwrite(char *, int, int, FILE *);
-int fgetc(FILE *);
-char *fgets(char *s, int, FILE*);
-int fflush(FILE *);
-int fclose(FILE *);
-int ungetc(int, FILE *);
-int _filbuf(FILE *);	/* !!! */
-int _flsbuf(unsigned char, FILE *);	/* !!! */
-int sscanf(char *, char *,...);
-void setbuf(FILE *, char *);
-void perror(char *);
-
-time_t time(time_t *);
-int strftime(char *, int, const char *, struct tm *);
-
-int initgroups(char *, int);
-int wait3(int *, int, void *);	/* Close enough for us... */
-int lstat(const char *, struct stat *);
-int stat(const char *, struct stat *);
-int flock(int, int);
-#ifndef NO_KILLPG
-int killpg(int, int);
-#endif
-int socket(int, int, int);
-int setsockopt(int, int, int, const char *, int);
-int listen(int, int);
-int bind(int, struct sockaddr *, int);
-int connect(int, struct sockaddr *, int);
-int accept(int, struct sockaddr *, int *);
-int shutdown(int, int);
-
-int getsockname(int s, struct sockaddr *name, int *namelen);
-int getpeername(int s, struct sockaddr *name, int *namelen);
-int gethostname(char *name, int namelen);
-void syslog(int, char *,...);
-char *mktemp(char *);
-
-long vfprintf(FILE *, const char *, va_list);
-
-#endif /* SUNOS_LIB_PROTOTYPES */
-
-/* The assumption is that when the functions are missing,
- * then there's no matching prototype available either.
- * Declare what is needed exactly as the replacement routines implement it.
- */
-#ifdef NEED_STRDUP
-extern char *strdup (const char *str);
-#endif
-#ifdef NEED_STRCASECMP
-extern int strcasecmp (const char *a, const char *b);
-#endif
-#ifdef NEED_STRNCASECMP
-extern int strncasecmp (const char *a, const char *b, int n);
-#endif
-#ifdef NEED_INITGROUPS
-extern int initgroups(const char *name, gid_t basegid);
-#endif
-#ifdef NEED_WAITPID
-extern int waitpid(pid_t pid, int *statusp, int options);
-#endif
-#ifdef NEED_STRERROR
-extern char *strerror (int err);
-#endif
-#ifdef NEED_DIFFTIME
-extern double difftime(time_t time1, time_t time0);
-#endif
 
-#ifdef __cplusplus
-}
+#ifdef __GNUC__
+#warning "This header is obsolete, use ap_config.h instead"
 #endif
 
-#endif	/* !APACHE_CONF_H */
+#include "ap_config.h"
diff -BEr -U 6 apache_1.3.0/src/include/fnmatch.h apache_1.3.1/src/include/fnmatch.h
--- apache_1.3.0/src/include/fnmatch.h	1998-05-04 01:31:08.000000000 +0800
+++ apache_1.3.1/src/include/fnmatch.h	1998-07-13 19:32:35.000000000 +0800
@@ -32,13 +32,13 @@
  *
  *	@(#)fnmatch.h	8.1 (Berkeley) 6/2/93
  */
 
 /* This file has been modified by the Apache Group. */
 
-#include "conf.h"
+#include "ap_config.h"
 
 #ifndef	_FNMATCH_H_
 #define	_FNMATCH_H_
 
 #ifdef __cplusplus
 extern "C" {
@@ -46,12 +46,14 @@
 
 #define	FNM_NOMATCH	1	/* Match failed. */
 
 #define	FNM_NOESCAPE	0x01	/* Disable backslash escaping. */
 #define	FNM_PATHNAME	0x02	/* Slash must be matched by slash. */
 #define	FNM_PERIOD	0x04	/* Period must be matched by period. */
+/* This flag is an Apache addition */
+#define FNM_CASE_BLIND  0x08    /* Compare characters case-insensitively. */
 
 API_EXPORT(int) ap_fnmatch(const char *, const char *, int);
 
 /* this function is an Apache addition */
 API_EXPORT(extern int) ap_is_fnmatch(const char *);
 
diff -BEr -U 6 apache_1.3.0/src/include/hsregex.h apache_1.3.1/src/include/hsregex.h
--- apache_1.3.0/src/include/hsregex.h	1998-04-06 13:21:41.000000000 +0800
+++ apache_1.3.1/src/include/hsregex.h	1998-07-09 08:04:57.000000000 +0800
@@ -1,6 +1,8 @@
+/* DON'T EVEN THINK ABOUT EDITING THIS, go see regex/Makefile,
+ * search for mkh */
 #ifndef _REGEX_H_
 #define	_REGEX_H_	/* never again */
 /* ========= begin header generated by ./mkh ========= */
 #ifdef __cplusplus
 extern "C" {
 #endif
diff -BEr -U 6 apache_1.3.0/src/include/http_conf_globals.h apache_1.3.1/src/include/http_conf_globals.h
--- apache_1.3.0/src/include/http_conf_globals.h	1998-05-12 04:08:06.000000000 +0800
+++ apache_1.3.1/src/include/http_conf_globals.h	1998-06-16 11:37:24.000000000 +0800
@@ -99,15 +99,16 @@
  * statically...
  */
 
 extern API_VAR_EXPORT char ap_server_root[MAX_STRING_LEN];
 extern char ap_server_confname[MAX_STRING_LEN];
 
-/* for -C and -c switches */
+/* for -C, -c and -D switches */
 extern array_header *ap_server_pre_read_config;
 extern array_header *ap_server_post_read_config;
+extern array_header *ap_server_config_defines;
 
 /* We want this to have the least chance of being corrupted if there
  * is some memory corruption, so we allocate it statically.
  */
 extern char ap_coredump_dir[MAX_STRING_LEN];
 
diff -BEr -U 6 apache_1.3.0/src/include/http_config.h apache_1.3.1/src/include/http_config.h
--- apache_1.3.0/src/include/http_config.h	1998-05-27 22:01:31.000000000 +0800
+++ apache_1.3.1/src/include/http_config.h	1998-07-13 19:32:35.000000000 +0800
@@ -272,13 +272,13 @@
  * really set up once we start running.  Note that the first word
  * is a version check; this should allow us to deal with changes to
  * the API (the server can detect an old-format module, and either
  * handle it back-compatibly, or at least signal an error).
  */
 
-#define MODULE_MAGIC_NUMBER 19980527
+#define MODULE_MAGIC_NUMBER 19980713
 #define STANDARD_MODULE_STUFF MODULE_MAGIC_NUMBER, -1, __FILE__, NULL, NULL
 
 /* Generic accessors for other modules to get at their own module-specific
  * data
  */
 
diff -BEr -U 6 apache_1.3.0/src/include/http_core.h apache_1.3.1/src/include/http_core.h
--- apache_1.3.0/src/include/http_core.h	1998-05-04 01:31:08.000000000 +0800
+++ apache_1.3.1/src/include/http_core.h	1998-07-02 05:19:51.000000000 +0800
@@ -94,14 +94,14 @@
 #define SATISFY_ALL 0
 #define SATISFY_ANY 1
 #define SATISFY_NOSPEC 2
 
 API_EXPORT(int) ap_allow_options (request_rec *);
 API_EXPORT(int) ap_allow_overrides (request_rec *);
-API_EXPORT(char *) ap_default_type (request_rec *);     
-API_EXPORT(char *) ap_document_root (request_rec *); /* Don't use this!  If your request went
+API_EXPORT(const char *) ap_default_type (request_rec *);     
+API_EXPORT(const char *) ap_document_root (request_rec *); /* Don't use this!  If your request went
 				      * through a Userdir, or something like
 				      * that, it'll screw you.  But it's
 				      * back-compatible...
 				      */
 API_EXPORT(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config, int type);
 API_EXPORT(const char *) ap_get_remote_logname(request_rec *r);
@@ -122,16 +122,16 @@
     
 typedef struct {
     int method_mask;
     char *requirement;
 } require_line;
      
-API_EXPORT(char *) ap_auth_type (request_rec *);
-API_EXPORT(char *) ap_auth_name (request_rec *);     
+API_EXPORT(const char *) ap_auth_type (request_rec *);
+API_EXPORT(const char *) ap_auth_name (request_rec *);     
 API_EXPORT(int) ap_satisfies (request_rec *r);
-API_EXPORT(array_header *) ap_requires (request_rec *);    
+API_EXPORT(const array_header *) ap_requires (request_rec *);    
 
 #ifdef CORE_PRIVATE
 
 /*
  * Core is also unlike other modules in being implemented in more than
  * one file... so, data structures are declared here, even though most of
diff -BEr -U 6 apache_1.3.0/src/include/httpd.h apache_1.3.1/src/include/httpd.h
--- apache_1.3.0/src/include/httpd.h	1998-06-02 06:18:43.000000000 +0800
+++ apache_1.3.1/src/include/httpd.h	1998-07-19 06:57:27.000000000 +0800
@@ -65,13 +65,13 @@
 /*
  * httpd.h: header for simple (ha! not anymore) http daemon
  */
 
 /* Headers in which EVERYONE has an interest... */
 
-#include "conf.h"
+#include "ap_config.h"
 #include "alloc.h"
 #include "buff.h"
 #include "ap.h"
 
 /* ----------------------------- config dir ------------------------------ */
 
@@ -379,13 +379,13 @@
  * "Product tokens should be short and to the point -- use of them for 
  * advertizing or other non-essential information is explicitly forbidden."
  *
  * Example: "Apache/1.1.0 MrWidget/0.1-alpha" 
  */
 
-#define SERVER_BASEVERSION "Apache/1.3.0"	/* SEE COMMENTS ABOVE */
+#define SERVER_BASEVERSION "Apache/1.3.1"	/* SEE COMMENTS ABOVE */
 #define SERVER_VERSION  SERVER_BASEVERSION
 enum server_token_type {
     SrvTk_MIN,		/* eg: Apache/1.3.0 */
     SrvTk_OS,		/* eg: Apache/1.3.0 (UNIX) */
     SrvTk_FULL		/* eg: Apache/1.3.0 (UNIX) PHP/3.0 FooBar/1.2b */
 };
@@ -393,14 +393,16 @@
 API_EXPORT(const char *) ap_get_server_version(void);
 API_EXPORT(void) ap_add_version_component(const char *component);
 API_EXPORT(const char *) ap_get_server_built(void);
 
 /* Numeric release version identifier: major minor bugfix betaseq
  * Always increases along the same track as the source branch.
+ * For a final release, 'betaseq' should be set to '99'.
+ * For example, Apache 1.4.2 should be '1040299'
  */
-#define APACHE_RELEASE 1030000
+#define APACHE_RELEASE 1030199
 
 #define SERVER_PROTOCOL "HTTP/1.1"
 #ifndef SERVER_SUPPORT
 #define SERVER_SUPPORT "http://www.apache.org/"
 #endif
 
@@ -595,13 +597,13 @@
     int assbackwards;		/* HTTP/0.9, "simple" request */
     int proxyreq;		/* A proxy request (calculated during
 				 * post_read_request or translate_name) */
     int header_only;		/* HEAD request, as opposed to GET */
     char *protocol;		/* Protocol, as given to us, or HTTP/0.9 */
     int proto_num;		/* Number version of protocol; 1.1 = 1001 */
-    char *hostname;		/* Host, as set by full URI or Host: */
+    const char *hostname;	/* Host, as set by full URI or Host: */
 
     time_t request_time;	/* When the request started */
 
     char *status_line;		/* Status line, if set by script */
     int status;			/* In any case */
 
@@ -640,13 +642,13 @@
 
     /* HTTP/1.1 connection-level features */
 
     int chunked;		/* sending chunked transfer-coding */
     int byterange;		/* number of byte ranges */
     char *boundary;		/* multipart/byteranges boundary */
-    char *range;		/* The Range: header */
+    const char *range;		/* The Range: header */
     long clength;		/* The "real" content length */
 
     long remaining;		/* bytes left to read */
     long read_length;		/* bytes that have been read */
     int read_body;		/* how the request body should be read */
     int read_chunked;		/* reading chunked transfer-coding */
@@ -670,17 +672,17 @@
     table *notes;
 
     /* content_type, handler, content_encoding, content_language, and all
      * content_languages MUST be lowercased strings.  They may be pointers
      * to static strings; they should not be modified in place.
      */
-    char *content_type;		/* Break these out --- we dispatch on 'em */
-    char *handler;		/* What we *really* dispatch on           */
+    const char *content_type;	/* Break these out --- we dispatch on 'em */
+    const char *handler;	/* What we *really* dispatch on           */
 
-    char *content_encoding;
-    char *content_language;	/* for back-compat. only -- do not use */
+    const char *content_encoding;
+    const char *content_language;	/* for back-compat. only -- do not use */
     array_header *content_languages;	/* array of (char*) */
 
     int no_cache;
     int no_local_copy;
 
     /* What object is being requested (either directly, or via include
@@ -857,13 +859,13 @@
 API_EXPORT(char *) ap_getword_white_nc(pool *p, char **line);
 API_EXPORT(char *) ap_getword_nulls(pool *p, const char **line, char stop);
 API_EXPORT(char *) ap_getword_nulls_nc(pool *p, char **line, char stop);
 API_EXPORT(char *) ap_getword_conf(pool *p, const char **line);
 API_EXPORT(char *) ap_getword_conf_nc(pool *p, char **line);
 
-API_EXPORT(char *) ap_get_token(pool *p, char **accept_line, int accept_white);
+API_EXPORT(char *) ap_get_token(pool *p, const char **accept_line, int accept_white);
 API_EXPORT(int) ap_find_token(pool *p, const char *line, const char *tok);
 API_EXPORT(int) ap_find_last_token(pool *p, const char *line, const char *tok);
 
 API_EXPORT(int) ap_is_url(const char *u);
 API_EXPORT(int) ap_unescape_url(char *url);
 API_EXPORT(void) ap_no2slash(char *name);
@@ -891,12 +893,13 @@
 void os2pathname(char *path);
 #endif
 
 API_EXPORT(char *) ap_pregsub(pool *p, const char *input, const char *source,
 			   size_t nmatch, regmatch_t pmatch[]);
 
+API_EXPORT(void) ap_content_type_tolower(char *);
 API_EXPORT(void) ap_str_tolower(char *);
 API_EXPORT(int) ap_ind(const char *, char);	/* Sigh... */
 API_EXPORT(int) ap_rind(const char *, char);
 
 API_EXPORT(char *) ap_escape_quotes (pool *p, const char *instring);
 
@@ -986,12 +989,14 @@
 #else
 int ap_slack(int fd, int line);
 #define AP_SLACK_LOW	1
 #define AP_SLACK_HIGH	2
 #endif
 
+API_EXPORT(char *) ap_escape_quotes(pool *p, const char *instr);
+
 /*
  * Redefine assert() to something more useful for an Apache...
  */
 API_EXPORT(void) ap_log_assert(const char *szExp, const char *szFile, int nLine)
 			    __attribute__((noreturn));
 #define ap_assert(exp) (void)( (exp) || (ap_log_assert(#exp, __FILE__, __LINE__), 0) )
diff -BEr -U 6 apache_1.3.0/src/include/http_main.h apache_1.3.1/src/include/http_main.h
--- apache_1.3.0/src/include/http_main.h	1998-05-04 01:31:09.000000000 +0800
+++ apache_1.3.1/src/include/http_main.h	1998-06-05 04:13:17.000000000 +0800
@@ -140,13 +140,13 @@
  * write_fd is an fd that is probed for writing by select() if it is ever
  * unwritable, then maintenance is invoked with reason OC_REASON_UNWRITABLE.
  * This is useful for log pipe children, to know when they've blocked.  To
  * disable this feature, use -1 for write_fd.
  */
 API_EXPORT(void) ap_register_other_child(int pid,
-       void (*maintenance) (int reason, void *data, int status), void *data,
+       void (*maintenance) (int reason, void *data, ap_wait_t status), void *data,
 				      int write_fd);
 #define OC_REASON_DEATH		0	/* child has died, caller must call
 					 * unregister still */
 #define OC_REASON_UNWRITABLE	1	/* write_fd is unwritable */
 #define OC_REASON_RESTART	2	/* a restart is occuring, perform
 					 * any necessary cleanup (including
diff -BEr -U 6 apache_1.3.0/src/include/http_protocol.h apache_1.3.1/src/include/http_protocol.h
--- apache_1.3.0/src/include/http_protocol.h	1998-05-06 23:04:11.000000000 +0800
+++ apache_1.3.1/src/include/http_protocol.h	1998-07-02 05:19:51.000000000 +0800
@@ -192,13 +192,13 @@
  *
  */
 
 API_EXPORT(void) ap_note_auth_failure(request_rec *r);
 API_EXPORT(void) ap_note_basic_auth_failure(request_rec *r);
 API_EXPORT(void) ap_note_digest_auth_failure(request_rec *r);
-API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, char **pw);
+API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, const char **pw);
 
 /*
  * Setting up the protocol fields for subsidiary requests...
  * Also, a wrapup function to keep the internal accounting straight.
  */
 
diff -BEr -U 6 apache_1.3.0/src/include/util_script.h apache_1.3.1/src/include/util_script.h
--- apache_1.3.0/src/include/util_script.h	1998-05-17 00:34:47.000000000 +0800
+++ apache_1.3.1/src/include/util_script.h	1998-06-13 23:22:49.000000000 +0800
@@ -74,13 +74,13 @@
 API_EXPORT(int) ap_find_path_info(const char *uri, const char *path_info);
 API_EXPORT(void) ap_add_cgi_vars(request_rec *r);
 API_EXPORT(void) ap_add_common_vars(request_rec *r);
 #define scan_script_header(a1,a2) ap_scan_script_header_err(a1,a2,NULL)
 API_EXPORT(int) ap_scan_script_header_err(request_rec *r, FILE *f, char *buffer);
 API_EXPORT(int) ap_scan_script_header_err_buff(request_rec *r, BUFF *f,
-                                            char *buffer);
+                                               char *buffer);
 API_EXPORT(void) ap_send_size(size_t size, request_rec *r);
 API_EXPORT(int) ap_call_exec(request_rec *r, child_info *pinfo, char *argv0, char **env,
                           int shellcmd);
 
 #ifdef __cplusplus
 }
diff -BEr -U 6 apache_1.3.0/src/include/util_uri.h apache_1.3.1/src/include/util_uri.h
--- apache_1.3.0/src/include/util_uri.h	1998-05-04 01:31:11.000000000 +0800
+++ apache_1.3.1/src/include/util_uri.h	1998-07-16 07:49:12.000000000 +0800
@@ -72,22 +72,23 @@
 
 #define	DEFAULT_FTP_DATA_PORT	20
 #define	DEFAULT_FTP_PORT	21
 #define	DEFAULT_GOPHER_PORT	70
 #define	DEFAULT_NNTP_PORT	119
 #define	DEFAULT_WAIS_PORT	210
-#define	DEFAULT_HTTPS_PORT	443
 #define	DEFAULT_SNEWS_PORT	563
 #define	DEFAULT_PROSPERO_PORT	1525	/* WARNING: conflict w/Oracle */
 
 /* Flags passed to unparse_uri_components(): */
 #define UNP_OMITSITEPART	(1U<<0)	/* suppress "scheme://user@site:port" */
 #define	UNP_OMITUSER		(1U<<1)	/* Just omit user */
 #define	UNP_OMITPASSWORD	(1U<<2)	/* Just omit password */
 #define	UNP_OMITUSERINFO	(UNP_OMITUSER|UNP_OMITPASSWORD)	/* omit "user:password@" part */
 #define	UNP_REVEALPASSWORD	(1U<<3)	/* Show plain text password (default: show XXXXXXXX) */
+#define UNP_OMITPATHINFO	(1U<<4)	/* Show "scheme://user@site:port" only */
+#define UNP_OMITQUERY	        (1U<<5)	/* Omit the "?queryarg" from the path */
 
 typedef struct {
     char *scheme;		/* scheme ("http"/"ftp"/...) */
     char *hostinfo;             /* combined [user[:password]@]host[:port] */
     char *user;			/* user name, as in http://user:passwd@host:port/ */
     char *password;		/* password, as in http://user:passwd@host:port/ */
@@ -108,13 +109,13 @@
 
 } uri_components;
 
 /* util_uri.c */
 API_EXPORT(unsigned short) ap_default_port_for_scheme(const char *scheme_str);
 API_EXPORT(unsigned short) ap_default_port_for_request(const request_rec *r);
-API_EXPORT(struct hostent *) ap_pduphostent(pool *p, struct hostent *hp);
+API_EXPORT(struct hostent *) ap_pduphostent(pool *p, const struct hostent *hp);
 API_EXPORT(struct hostent *) ap_pgethostbyname(pool *p, const char *hostname);
 API_EXPORT(char *) ap_unparse_uri_components(pool *p, const uri_components *uptr,
     unsigned flags);
 API_EXPORT(int) ap_parse_uri_components(pool *p, const char *uri, uri_components *uptr);
 API_EXPORT(int) ap_parse_hostinfo_components(pool *p, const char *hostinfo, uri_components *uptr);
 /* called by the core in main() */
diff -BEr -U 6 apache_1.3.0/src/main/alloc.c apache_1.3.1/src/main/alloc.c
--- apache_1.3.0/src/main/alloc.c	1998-05-29 06:09:50.000000000 +0800
+++ apache_1.3.1/src/main/alloc.c	1998-06-13 23:22:52.000000000 +0800
@@ -1114,13 +1114,13 @@
 
 API_EXPORT(void) ap_clear_table(table *t)
 {
     t->a.nelts = 0;
 }
 
-API_EXPORT(char *) ap_table_get(const table *t, const char *key)
+API_EXPORT(const char *) ap_table_get(const table *t, const char *key)
 {
     table_entry *elts = (table_entry *) t->a.elts;
     int i;
 
     if (key == NULL)
 	return NULL;
@@ -1175,13 +1175,13 @@
     {
 	if (!ap_pool_is_ancestor(ap_find_pool(key), t->a.pool)) {
 	    fprintf(stderr, "table_set: key not in ancestor pool of t\n");
 	    abort();
 	}
 	if (!ap_pool_is_ancestor(ap_find_pool(val), t->a.pool)) {
-	    fprintf(stderr, "table_set: key not in ancestor pool of t\n");
+	    fprintf(stderr, "table_set: val not in ancestor pool of t\n");
 	    abort();
 	}
     }
 #endif
 
     for (i = 0; i < t->a.nelts; ) {
Only in apache_1.3.0/src/main: alloc.o
diff -BEr -U 6 apache_1.3.0/src/main/buff.c apache_1.3.1/src/main/buff.c
--- apache_1.3.0/src/main/buff.c	1998-05-17 00:34:48.000000000 +0800
+++ apache_1.3.1/src/main/buff.c	1998-07-05 02:22:11.000000000 +0800
@@ -430,13 +430,13 @@
 static void start_chunk(BUFF *fb)
 {
     if (fb->outchunk != -1) {
 	/* already chunking */
 	return;
     }
-    if (!(fb->flags & B_WR) || (fb->flags & (B_WRERR | B_EOUT))) {
+    if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR) {
 	/* unbuffered writes */
 	return;
     }
 
     /* we need at least the header_len + at least 1 data byte
      * remember that we've overallocated fb->outbase so that we can always
@@ -526,14 +526,16 @@
 {
     int fd;
 
     fd = (direction == B_RD) ? fb->fd_in : fb->fd;
 #if defined(O_NONBLOCK)
     return fcntl(fd, F_SETFL, O_NONBLOCK);
-#elif defined(F_NDELAY)
-    return fcntl(fd, F_SETFL, F_NDELAY);
+#elif defined(O_NDELAY)
+    return fcntl(fd, F_SETFL, O_NDELAY);
+#elif defined(FNDELAY)
+    return fcntl(fd, F_SETFL, FNDELAY);
 #else
     /* XXXX: this breaks things, but an alternative isn't obvious...*/
     return 0;
 #endif
 }
 
@@ -684,13 +686,13 @@
 	    fb->incnt -= i;
 	    fb->inptr += i;
 	    return i;
 	}
 	i = read_with_errors(fb, buf, nbyte);
 #ifdef CHARSET_EBCDIC
-	if (i > 0 && bgetflag(fb, B_ASCII2EBCDIC))
+	if (i > 0 && ap_bgetflag(fb, B_ASCII2EBCDIC))
 	    ascii2ebcdic(buf, buf, i);
 #endif /*CHARSET_EBCDIC*/
 	return i;
     }
 
     nrd = fb->incnt;
@@ -723,13 +725,13 @@
 
 /* do a single read */
     if (nbyte >= fb->bufsiz) {
 /* read directly into caller's buffer */
 	i = read_with_errors(fb, buf, nbyte);
 #ifdef CHARSET_EBCDIC
-	if (i > 0 && bgetflag(fb, B_ASCII2EBCDIC))
+	if (i > 0 && ap_bgetflag(fb, B_ASCII2EBCDIC))
 	    ascii2ebcdic(buf, buf, i);
 #endif /*CHARSET_EBCDIC*/
 	if (i == -1) {
 	    return nrd ? nrd : -1;
 	}
     }
@@ -928,13 +930,14 @@
 	    return i;
 	fb->incnt = i;
     }
 }
 
 /*
- * Empty the buffer after putting a single character in it
+ * output a single character.  Used by ap_bputs when the buffer
+ * is full... and so it'll cause the buffer to be flushed first.
  */
 API_EXPORT(int) ap_bflsbuf(int c, BUFF *fb)
 {
     char ss[1];
 
     ss[0] = c;
@@ -1188,13 +1191,14 @@
 {
     int i, nwr, useable_bufsiz;
 #ifdef CHARSET_EBCDIC
     static char *cbuf = NULL;
     static int csize = 0;
 
-    if (bgetflag(fb, B_EBCDIC2ASCII)) {
+    /* XXX: martin don't you want to do this after the error tests below? */
+    if (ap_bgetflag(fb, B_EBCDIC2ASCII)) {
         if (nbyte > csize) {
             if (cbuf != NULL)
                 free(cbuf);
             cbuf = malloc(csize = nbyte+HUGE_STRING_LEN);
             if (cbuf == NULL)
                 csize = 0;
@@ -1356,16 +1360,13 @@
  * Returns 0 on success or -1 on error
  */
 API_EXPORT(int) ap_bflush(BUFF *fb)
 {
     int ret;
 
-    if (!(fb->flags & B_WR) || (fb->flags & B_EOUT))
-	return 0;
-
-    if (fb->flags & B_WRERR)
+    if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
 	return -1;
 
     if (fb->flags & B_CHUNK)
 	end_chunk(fb);
 
     ret = bflush_core(fb);
@@ -1518,12 +1519,15 @@
 API_EXPORT_NONSTD(int) ap_bprintf(BUFF *fb, const char *fmt, ...)
 {
     va_list ap;
     int res;
     struct bprintf_data b;
 
+    /* XXX: only works with buffered writes */
+    if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
+	return -1;
     b.vbuff.curpos = (char *)&fb->outbase[fb->outcnt];
     b.vbuff.endpos = (char *)&fb->outbase[fb->bufsiz];
     b.fb = fb;
     va_start(ap, fmt);
     res = ap_vformatter(bprintf_flush, &b.vbuff, fmt, ap);
     va_end(ap);
@@ -1542,12 +1546,15 @@
 
 API_EXPORT(int) ap_vbprintf(BUFF *fb, const char *fmt, va_list ap)
 {
     struct bprintf_data b;
     int res;
 
+    /* XXX: only works with buffered writes */
+    if ((fb->flags & (B_WRERR | B_EOUT | B_WR)) != B_WR)
+	return -1;
     b.vbuff.curpos = (char *)&fb->outbase[fb->outcnt];
     b.vbuff.endpos = (char *)&fb->outbase[fb->bufsiz];
     b.fb = fb;
     res = ap_vformatter(bprintf_flush, &b.vbuff, fmt, ap);
     if (res != -1) {
 #ifdef CHARSET_EBCDIC
Only in apache_1.3.0/src/main: buff.o
diff -BEr -U 6 apache_1.3.0/src/main/fnmatch.c apache_1.3.1/src/main/fnmatch.c
--- apache_1.3.0/src/main/fnmatch.c	1998-04-11 20:00:28.000000000 +0800
+++ apache_1.3.1/src/main/fnmatch.c	1998-07-13 19:32:39.000000000 +0800
@@ -40,143 +40,167 @@
 
 /*
  * Function fnmatch() as specified in POSIX 1003.2-1992, section B.6.
  * Compares a filename or pathname to a pattern.
  */
 
-#include "conf.h"
+#include "ap_config.h"
 #include "fnmatch.h"
 #include <string.h>
 
 #define	EOS	'\0'
 
 static const char *rangematch(const char *, int, int);
 
-API_EXPORT(int) ap_fnmatch(pattern, string, flags)
-     const char *pattern, *string;
-     int flags;
+API_EXPORT(int) ap_fnmatch(const char *pattern, const char *string, int flags)
 {
     const char *stringstart;
     char c, test;
 
-    for (stringstart = string;;)
+    for (stringstart = string;;) {
 	switch (c = *pattern++) {
 	case EOS:
 	    return (*string == EOS ? 0 : FNM_NOMATCH);
 	case '?':
-	    if (*string == EOS)
+	    if (*string == EOS) {
 		return (FNM_NOMATCH);
-	    if (*string == '/' && (flags & FNM_PATHNAME))
+	    }
+	    if (*string == '/' && (flags & FNM_PATHNAME)) {
 		return (FNM_NOMATCH);
+	    }
 	    if (*string == '.' && (flags & FNM_PERIOD) &&
 		(string == stringstart ||
-		 ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
+		 ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
 		return (FNM_NOMATCH);
+	    }
 	    ++string;
 	    break;
 	case '*':
 	    c = *pattern;
 	    /* Collapse multiple stars. */
-	    while (c == '*')
+	    while (c == '*') {
 		c = *++pattern;
+	    }
 
 	    if (*string == '.' && (flags & FNM_PERIOD) &&
 		(string == stringstart ||
-		 ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
+		 ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
 		return (FNM_NOMATCH);
+	    }
 
 	    /* Optimize for pattern with * at end or before /. */
 	    if (c == EOS) {
 		if (flags & FNM_PATHNAME) {
-		    return (strchr(string, '/') == NULL ?
-			    0 : FNM_NOMATCH);
+		    return (strchr(string, '/') == NULL ? 0 : FNM_NOMATCH);
 		}
 		else {
 		    return (0);
 		}
 	    }
 	    else if (c == '/' && flags & FNM_PATHNAME) {
-		if ((string = strchr(string, '/')) == NULL)
+	        if ((string = strchr(string, '/')) == NULL) {
 		    return (FNM_NOMATCH);
+		}
 		break;
 	    }
 
 	    /* General case, use recursion. */
 	    while ((test = *string) != EOS) {
-		if (!ap_fnmatch(pattern, string, flags & ~FNM_PERIOD))
+	        if (!ap_fnmatch(pattern, string, flags & ~FNM_PERIOD)) {
 		    return (0);
-		if (test == '/' && flags & FNM_PATHNAME)
+		}
+		if (test == '/' && flags & FNM_PATHNAME) {
 		    break;
+		}
 		++string;
 	    }
 	    return (FNM_NOMATCH);
 	case '[':
-	    if (*string == EOS)
+	    if (*string == EOS) {
 		return (FNM_NOMATCH);
-	    if (*string == '/' && flags & FNM_PATHNAME)
+	    }
+	    if (*string == '/' && flags & FNM_PATHNAME) {
 		return (FNM_NOMATCH);
+	    }
 	    if (*string == '.' && (flags & FNM_PERIOD) &&
 		(string == stringstart ||
-		((flags & FNM_PATHNAME) && *(string - 1) == '/')))
-		    return (FNM_NOMATCH);
-	    if ((pattern =
-		 rangematch(pattern, *string, flags)) == NULL)
+		 ((flags & FNM_PATHNAME) && *(string - 1) == '/'))) {
 		return (FNM_NOMATCH);
+	    }
+	    if ((pattern = rangematch(pattern, *string, flags)) == NULL) {
+		return (FNM_NOMATCH);
+	    }
 	    ++string;
 	    break;
 	case '\\':
 	    if (!(flags & FNM_NOESCAPE)) {
 		if ((c = *pattern++) == EOS) {
 		    c = '\\';
 		    --pattern;
 		}
 	    }
 	    /* FALLTHROUGH */
-	    default:
-		if (c != *string++)
+	default:
+	    if (flags & FNM_CASE_BLIND) {
+	        if (ap_tolower(c) != ap_tolower(*string)) {
+		    return (FNM_NOMATCH);
+		}
+	    }
+	    else if (c != *string) {
 		return (FNM_NOMATCH);
+	    }
+	    string++;
 	    break;
 	}
     /* NOTREACHED */
+    }
 }
 
-static const char *
-     rangematch(pattern, test, flags)
-     const char *pattern;
-     int test, flags;
+static const char *rangematch(const char *pattern, int test, int flags)
 {
     int negate, ok;
     char c, c2;
 
     /*
      * A bracket expression starting with an unquoted circumflex
      * character produces unspecified results (IEEE 1003.2-1992,
      * 3.13.2).  This implementation treats it like '!', for
      * consistency with the regular expression syntax.
      * J.T. Conklin (conklin@ngai.kaleida.com)
      */
-    if ((negate = (*pattern == '!' || *pattern == '^')))
+    if ((negate = (*pattern == '!' || *pattern == '^'))) {
 	++pattern;
+    }
 
     for (ok = 0; (c = *pattern++) != ']';) {
-	if (c == '\\' && !(flags & FNM_NOESCAPE))
+        if (c == '\\' && !(flags & FNM_NOESCAPE)) {
 	    c = *pattern++;
-	if (c == EOS)
+	}
+	if (c == EOS) {
 	    return (NULL);
-	if (*pattern == '-'
-	    && (c2 = *(pattern + 1)) != EOS && c2 != ']') {
+	}
+	if (*pattern == '-' && (c2 = *(pattern + 1)) != EOS && c2 != ']') {
 	    pattern += 2;
-	    if (c2 == '\\' && !(flags & FNM_NOESCAPE))
+	    if (c2 == '\\' && !(flags & FNM_NOESCAPE)) {
 		c2 = *pattern++;
-	    if (c2 == EOS)
+	    }
+	    if (c2 == EOS) {
 		return (NULL);
-	    if (c <= test && test <= c2)
+	    }
+	    if ((c <= test && test <= c2)
+		|| ((flags & FNM_CASE_BLIND)
+		    && ((ap_tolower(c) <= ap_tolower(test))
+			&& (ap_tolower(test) <= ap_tolower(c2))))) {
 		ok = 1;
+	    }
 	}
-	else if (c == test)
+	else if ((c == test)
+		 || ((flags & FNM_CASE_BLIND)
+		     && (ap_tolower(c) == ap_tolower(test)))) {
 	    ok = 1;
+	}
     }
     return (ok == negate ? NULL : pattern);
 }
 
 
 /* This function is an Apache addition */
@@ -200,14 +224,15 @@
 
 	case '[':	/* '[' is only a glob if it has a matching ']' */
 	    ++nesting;
 	    break;
 
 	case ']':
-	    if (nesting)
+	    if (nesting) {
 		return 1;
+	    }
 	    break;
 	}
 	++pattern;
     }
     return 0;
 }
Only in apache_1.3.0/src/main: gen_test_char
diff -BEr -U 6 apache_1.3.0/src/main/gen_test_char.c apache_1.3.1/src/main/gen_test_char.c
--- apache_1.3.0/src/main/gen_test_char.c	1998-04-13 03:02:03.000000000 +0800
+++ apache_1.3.1/src/main/gen_test_char.c	1998-07-09 01:47:05.000000000 +0800
@@ -38,22 +38,22 @@
 
 	/* escape_shell_cmd */
 	if (strchr("&;`'\"|*?~<>^()[]{}$\\\n", c)) {
 	    flags |= T_ESCAPE_SHELL_CMD;
 	}
 
-	if (!isalnum(c) && !strchr("$-_.+!*'(),:@&=~", c)) {
+	if (!ap_isalnum(c) && !strchr("$-_.+!*'(),:@&=~", c)) {
 	    flags |= T_ESCAPE_PATH_SEGMENT;
 	}
 
-	if (!isalnum(c) && !strchr("$-_.+!*'(),:@&=/~", c)) {
+	if (!ap_isalnum(c) && !strchr("$-_.+!*'(),:@&=/~", c)) {
 	    flags |= T_OS_ESCAPE_PATH;
 	}
 
 	/* these are the "tspecials" from RFC2068 */
-	if (iscntrl(c) || strchr(" \t()<>@,;:\\/[]?={}", c)) {
+	if (ap_iscntrl(c) || strchr(" \t()<>@,;:\\/[]?={}", c)) {
 	    flags |= T_HTTP_TOKEN_STOP;
 	}
 	printf("%u%c", flags, (c < 255) ? ',' : ' ');
 
     }
     printf("\n};\n");
Only in apache_1.3.0/src/main: gen_test_char.o
Only in apache_1.3.0/src/main: gen_uri_delims
Only in apache_1.3.0/src/main: gen_uri_delims.o
diff -BEr -U 6 apache_1.3.0/src/main/http_config.c apache_1.3.1/src/main/http_config.c
--- apache_1.3.0/src/main/http_config.c	1998-05-06 23:18:01.000000000 +0800
+++ apache_1.3.1/src/main/http_config.c	1998-07-07 12:06:20.000000000 +0800
@@ -473,14 +473,16 @@
     ph->hr.handler = NULL;
 }
 
 int ap_invoke_handler(request_rec *r)
 {
     fast_handler_rec *handp;
-    char *handler, *p;
+    const char *handler;
+    char *p;
     size_t handler_len;
+    int result = NOT_IMPLEMENTED;
 
     if (r->handler) {
 	handler = r->handler;
 	handler_len = strlen(handler);
     }
     else {
@@ -497,25 +499,30 @@
 
     /* Pass one --- direct matches */
 
     for (handp = handlers; handp->hr.content_type; ++handp) {
 	if (handler_len == handp->len
 	    && !strncmp(handler, handp->hr.content_type, handler_len)) {
-            int result = (*handp->hr.handler) (r);
+            result = (*handp->hr.handler) (r);
 
             if (result != DECLINED)
                 return result;
         }
     }
 
+    if (result == NOT_IMPLEMENTED && r->handler) {
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, r->server,
+            "handler \"%s\" not found for: %s", r->handler, r->filename);
+    }
+
     /* Pass two --- wildcard matches */
 
     for (handp = wildhandlers; handp->hr.content_type; ++handp) {
 	if (handler_len >= handp->len
 	    && !strncmp(handler, handp->hr.content_type, handp->len)) {
-             int result = (*handp->hr.handler) (r);
+             result = (*handp->hr.handler) (r);
 
              if (result != DECLINED)
                  return result;
          }
     }
 
Only in apache_1.3.0/src/main: http_config.o
diff -BEr -U 6 apache_1.3.0/src/main/http_core.c apache_1.3.1/src/main/http_core.c
--- apache_1.3.0/src/main/http_core.c	1998-05-28 23:28:13.000000000 +0800
+++ apache_1.3.1/src/main/http_core.c	1998-07-13 19:32:39.000000000 +0800
@@ -101,188 +101,228 @@
  * but may not be worth preserving.
  *
  * This file could almost be mod_core.c, except for the stuff which affects
  * the http_conf_globals.
  */
 
-static void *create_core_dir_config (pool *a, char *dir)
+static void *create_core_dir_config(pool *a, char *dir)
 {
-    core_dir_config *conf =
-      (core_dir_config *)ap_pcalloc(a, sizeof(core_dir_config));
-  
-    if (!dir || dir[strlen(dir) - 1] == '/') conf->d = dir;
-    else if (strncmp(dir,"proxy:",6)==0) conf->d = ap_pstrdup (a, dir);
-    else conf->d = ap_pstrcat (a, dir, "/", NULL);
-    conf->d_is_fnmatch = conf->d ? (ap_is_fnmatch (conf->d) != 0) : 0;
-    conf->d_components = conf->d ? ap_count_dirs (conf->d) : 0;
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_pcalloc(a, sizeof(core_dir_config));
+    if (!dir || dir[strlen(dir) - 1] == '/') {
+        conf->d = dir;
+    }
+    else if (strncmp(dir, "proxy:", 6) == 0) {
+        conf->d = ap_pstrdup(a, dir);
+    }
+    else {
+        conf->d = ap_pstrcat(a, dir, "/", NULL);
+    }
+    conf->d_is_fnmatch = conf->d ? (ap_is_fnmatch(conf->d) != 0) : 0;
+    conf->d_components = conf->d ? ap_count_dirs(conf->d) : 0;
 
     conf->opts = dir ? OPT_UNSET : OPT_UNSET|OPT_ALL;
     conf->opts_add = conf->opts_remove = OPT_NONE;
     conf->override = dir ? OR_UNSET : OR_UNSET|OR_ALL;
 
     conf->content_md5 = 2;
 
     conf->use_canonical_name = 1 | 2;	/* 2 = unset, default on */
 
     conf->hostname_lookups = HOSTNAME_LOOKUP_UNSET;
-    conf->do_rfc1413 = DEFAULT_RFC1413 | 2;  /* set bit 1 to indicate default */
+    conf->do_rfc1413 = DEFAULT_RFC1413 | 2; /* set bit 1 to indicate default */
     conf->satisfy = SATISFY_NOSPEC;
 
 #ifdef RLIMIT_CPU
     conf->limit_cpu = NULL;
 #endif
 #if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
     conf->limit_mem = NULL;
 #endif
 #ifdef RLIMIT_NPROC
     conf->limit_nproc = NULL;
 #endif
 
-    conf->sec = ap_make_array (a, 2, sizeof(void *));
+    conf->sec = ap_make_array(a, 2, sizeof(void *));
 
     return (void *)conf;
 }
 
-static void *merge_core_dir_configs (pool *a, void *basev, void *newv)
+static void *merge_core_dir_configs(pool *a, void *basev, void *newv)
 {
     core_dir_config *base = (core_dir_config *)basev;
     core_dir_config *new = (core_dir_config *)newv;
-    core_dir_config *conf =
-      (core_dir_config *)ap_palloc (a, sizeof(core_dir_config));
+    core_dir_config *conf;
     int i;
   
-    memcpy ((char *)conf, (const char *)base, sizeof(core_dir_config));
-    if( base->response_code_strings ) {
-	conf->response_code_strings = ap_palloc(a,
-	    sizeof(*conf->response_code_strings) * RESPONSE_CODES );
-	memcpy( conf->response_code_strings, base->response_code_strings,
-	    sizeof(*conf->response_code_strings) * RESPONSE_CODES );
+    conf = (core_dir_config *)ap_palloc(a, sizeof(core_dir_config));
+    memcpy((char *)conf, (const char *)base, sizeof(core_dir_config));
+    if (base->response_code_strings) {
+	conf->response_code_strings =
+	    ap_palloc(a, sizeof(*conf->response_code_strings)
+		      * RESPONSE_CODES);
+	memcpy(conf->response_code_strings, base->response_code_strings,
+	       sizeof(*conf->response_code_strings) * RESPONSE_CODES);
     }
     
     conf->d = new->d;
     conf->d_is_fnmatch = new->d_is_fnmatch;
     conf->d_components = new->d_components;
     conf->r = new->r;
     
     if (new->opts & OPT_UNSET) {
 	/* there was no explicit setting of new->opts, so we merge
 	 * preserve the invariant (opts_add & opts_remove) == 0
 	 */
 	conf->opts_add = (conf->opts_add & ~new->opts_remove) | new->opts_add;
-	conf->opts_remove = (conf->opts_remove & ~new->opts_add) | new->opts_remove;
+	conf->opts_remove = (conf->opts_remove & ~new->opts_add)
+	                    | new->opts_remove;
 	conf->opts = (conf->opts & ~conf->opts_remove) | conf->opts_add;
-        if ((base->opts & OPT_INCNOEXEC) && (new->opts & OPT_INCLUDES))
-          conf->opts = (conf->opts & ~OPT_INCNOEXEC) | OPT_INCLUDES;
+        if ((base->opts & OPT_INCNOEXEC) && (new->opts & OPT_INCLUDES)) {
+            conf->opts = (conf->opts & ~OPT_INCNOEXEC) | OPT_INCLUDES;
+	}
     }
     else {
 	/* otherwise we just copy, because an explicit opts setting
 	 * overrides all earlier +/- modifiers
 	 */
 	conf->opts = new->opts;
 	conf->opts_add = new->opts_add;
 	conf->opts_remove = new->opts_remove;
     }
 
-    if (!(new->override & OR_UNSET)) conf->override = new->override;
-    if (new->ap_default_type) conf->ap_default_type = new->ap_default_type;
+    if (!(new->override & OR_UNSET)) {
+        conf->override = new->override;
+    }
+    if (new->ap_default_type) {
+        conf->ap_default_type = new->ap_default_type;
+    }
     
-    if (new->ap_auth_type) conf->ap_auth_type = new->ap_auth_type;
-    if (new->ap_auth_name) conf->ap_auth_name = new->ap_auth_name;
-    if (new->ap_requires) conf->ap_requires = new->ap_requires;
+    if (new->ap_auth_type) {
+        conf->ap_auth_type = new->ap_auth_type;
+    }
+    if (new->ap_auth_name) {
+        conf->ap_auth_name = new->ap_auth_name;
+    }
+    if (new->ap_requires) {
+        conf->ap_requires = new->ap_requires;
+    }
 
-    if( new->response_code_strings ) {
-	if( conf->response_code_strings == NULL ) {
+    if (new->response_code_strings) {
+	if (conf->response_code_strings == NULL) {
 	    conf->response_code_strings = ap_palloc(a,
-		sizeof(*conf->response_code_strings) * RESPONSE_CODES );
-	    memcpy( conf->response_code_strings, new->response_code_strings,
-		sizeof(*conf->response_code_strings) * RESPONSE_CODES );
-	} else {
-	    for (i = 0; i < RESPONSE_CODES; ++i)
-		if (new->response_code_strings[i] != NULL)
-		conf->response_code_strings[i] = new->response_code_strings[i];
+		sizeof(*conf->response_code_strings) * RESPONSE_CODES);
+	    memcpy(conf->response_code_strings, new->response_code_strings,
+		   sizeof(*conf->response_code_strings) * RESPONSE_CODES);
+	}
+	else {
+	    for (i = 0; i < RESPONSE_CODES; ++i) {
+	        if (new->response_code_strings[i] != NULL) {
+		    conf->response_code_strings[i]
+		        = new->response_code_strings[i];
+		}
+	    }
 	}
     }
-    if (new->hostname_lookups != HOSTNAME_LOOKUP_UNSET)
+    if (new->hostname_lookups != HOSTNAME_LOOKUP_UNSET) {
 	conf->hostname_lookups = new->hostname_lookups;
-    if ((new->do_rfc1413 & 2) == 0) conf->do_rfc1413 = new->do_rfc1413;
-    if ((new->content_md5 & 2) == 0) conf->content_md5 = new->content_md5;
+    }
+    if ((new->do_rfc1413 & 2) == 0) {
+        conf->do_rfc1413 = new->do_rfc1413;
+    }
+    if ((new->content_md5 & 2) == 0) {
+        conf->content_md5 = new->content_md5;
+    }
     if ((new->use_canonical_name & 2) == 0) {
 	conf->use_canonical_name = new->use_canonical_name;
     }
 
 #ifdef RLIMIT_CPU
-    if (new->limit_cpu) conf->limit_cpu = new->limit_cpu;
+    if (new->limit_cpu) {
+        conf->limit_cpu = new->limit_cpu;
+    }
 #endif
 #if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
-    if (new->limit_mem) conf->limit_mem = new->limit_mem;
+    if (new->limit_mem) {
+        conf->limit_mem = new->limit_mem;
+    }
 #endif
 #ifdef RLIMIT_NPROC    
-    if (new->limit_nproc) conf->limit_nproc = new->limit_nproc;
+    if (new->limit_nproc) {
+        conf->limit_nproc = new->limit_nproc;
+    }
 #endif
 
-    conf->sec = ap_append_arrays (a, base->sec, new->sec);
+    conf->sec = ap_append_arrays(a, base->sec, new->sec);
 
-    if (new->satisfy != SATISFY_NOSPEC) conf->satisfy = new->satisfy;
+    if (new->satisfy != SATISFY_NOSPEC) {
+        conf->satisfy = new->satisfy;
+    }
     return (void*)conf;
 }
 
-static void *create_core_server_config (pool *a, server_rec *s)
+static void *create_core_server_config(pool *a, server_rec *s)
 {
-    core_server_config *conf =
-      (core_server_config *)ap_pcalloc(a, sizeof(core_server_config));
+    core_server_config *conf;
     int is_virtual = s->is_virtual;
   
+    conf = (core_server_config *)ap_pcalloc(a, sizeof(core_server_config));
     conf->access_name = is_virtual ? NULL : DEFAULT_ACCESS_FNAME;
     conf->ap_document_root = is_virtual ? NULL : DOCUMENT_LOCATION;
-    conf->sec = ap_make_array (a, 40, sizeof(void *));
-    conf->sec_url = ap_make_array (a, 40, sizeof(void *));
+    conf->sec = ap_make_array(a, 40, sizeof(void *));
+    conf->sec_url = ap_make_array(a, 40, sizeof(void *));
     
     return (void *)conf;
 }
 
-static void *merge_core_server_configs (pool *p, void *basev, void *virtv)
+static void *merge_core_server_configs(pool *p, void *basev, void *virtv)
 {
     core_server_config *base = (core_server_config *)basev;
     core_server_config *virt = (core_server_config *)virtv;
-    core_server_config *conf = 
-	(core_server_config *)ap_pcalloc(p, sizeof(core_server_config));
+    core_server_config *conf;
 
+    conf = (core_server_config *)ap_pcalloc(p, sizeof(core_server_config));
     *conf = *virt;
-    if (!conf->access_name) conf->access_name = base->access_name;
-    if (!conf->ap_document_root) conf->ap_document_root = base->ap_document_root;
-    conf->sec = ap_append_arrays (p, base->sec, virt->sec);
-    conf->sec_url = ap_append_arrays (p, base->sec_url, virt->sec_url);
+    if (!conf->access_name) {
+        conf->access_name = base->access_name;
+    }
+    if (!conf->ap_document_root) {
+        conf->ap_document_root = base->ap_document_root;
+    }
+    conf->sec = ap_append_arrays(p, base->sec, virt->sec);
+    conf->sec_url = ap_append_arrays(p, base->sec_url, virt->sec_url);
 
     return conf;
 }
 
 /* Add per-directory configuration entry (for <directory> section);
  * these are part of the core server config.
  */
 
-CORE_EXPORT(void) ap_add_per_dir_conf (server_rec *s, void *dir_config)
+CORE_EXPORT(void) ap_add_per_dir_conf(server_rec *s, void *dir_config)
 {
-    core_server_config *sconf = ap_get_module_config (s->module_config,
-						   &core_module);
-    void **new_space = (void **) ap_push_array (sconf->sec);
+    core_server_config *sconf = ap_get_module_config(s->module_config,
+						     &core_module);
+    void **new_space = (void **)ap_push_array(sconf->sec);
     
     *new_space = dir_config;
 }
 
-CORE_EXPORT(void) ap_add_per_url_conf (server_rec *s, void *url_config)
+CORE_EXPORT(void) ap_add_per_url_conf(server_rec *s, void *url_config)
 {
-    core_server_config *sconf = ap_get_module_config (s->module_config,
-						   &core_module);
-    void **new_space = (void **) ap_push_array (sconf->sec_url);
+    core_server_config *sconf = ap_get_module_config(s->module_config,
+						     &core_module);
+    void **new_space = (void **)ap_push_array(sconf->sec_url);
     
     *new_space = url_config;
 }
 
-static void add_file_conf (core_dir_config *conf, void *url_config)
+static void add_file_conf(core_dir_config *conf, void *url_config)
 {
-    void **new_space = (void **) ap_push_array (conf->sec);
+    void **new_space = (void **)ap_push_array(conf->sec);
     
     *new_space = url_config;
 }
 
 /* core_reorder_directories reorders the directory sections such that the
  * 1-component sections come first, then the 2-component, and so on, finally
@@ -308,72 +348,75 @@
  */
 struct reorder_sort_rec {
     void *elt;
     int orig_index;
 };
 
-static int reorder_sorter (const void *va, const void *vb)
+static int reorder_sorter(const void *va, const void *vb)
 {
     const struct reorder_sort_rec *a = va;
     const struct reorder_sort_rec *b = vb;
     core_dir_config *core_a;
     core_dir_config *core_b;
 
-    core_a = (core_dir_config *)ap_get_module_config (a->elt, &core_module);
-    core_b = (core_dir_config *)ap_get_module_config (b->elt, &core_module);
+    core_a = (core_dir_config *)ap_get_module_config(a->elt, &core_module);
+    core_b = (core_dir_config *)ap_get_module_config(b->elt, &core_module);
     if (IS_SPECIAL(core_a)) {
 	if (!IS_SPECIAL(core_b)) {
 	    return 1;
 	}
-    } else if (IS_SPECIAL(core_b)) {
+    }
+    else if (IS_SPECIAL(core_b)) {
 	return -1;
-    } else {
+    }
+    else {
 	/* we know they're both not special */
 	if (core_a->d_components < core_b->d_components) {
 	    return -1;
-	} else if (core_a->d_components > core_b->d_components) {
+	}
+	else if (core_a->d_components > core_b->d_components) {
 	    return 1;
 	}
     }
     /* Either they're both special, or they're both not special and have the
      * same number of components.  In any event, we now have to compare
      * the minor key. */
     return a->orig_index - b->orig_index;
 }
 
-void ap_core_reorder_directories (pool *p, server_rec *s)
+void ap_core_reorder_directories(pool *p, server_rec *s)
 {
     core_server_config *sconf;
     array_header *sec;
     struct reorder_sort_rec *sortbin;
     int nelts;
     void **elts;
     int i;
 
     /* XXX: we are about to waste some ram ... we will build a new array
      * and we need some scratch space to do it.  The old array and the
      * scratch space are never freed.
      */
-    sconf = ap_get_module_config (s->module_config, &core_module);
+    sconf = ap_get_module_config(s->module_config, &core_module);
     sec = sconf->sec;
     nelts = sec->nelts;
     elts = (void **)sec->elts;
 
     /* build our sorting space */
-    sortbin = ap_palloc (p, sec->nelts * sizeof (*sortbin));
+    sortbin = ap_palloc(p, sec->nelts * sizeof(*sortbin));
     for (i = 0; i < nelts; ++i) {
 	sortbin[i].orig_index = i;
 	sortbin[i].elt = elts[i];
     }
 
-    qsort (sortbin, nelts, sizeof (*sortbin), reorder_sorter);
+    qsort(sortbin, nelts, sizeof(*sortbin), reorder_sorter);
 
     /* and now build a new array */
-    sec = ap_make_array (p, nelts, sizeof (void *));
+    sec = ap_make_array(p, nelts, sizeof(void *));
     for (i = 0; i < nelts; ++i) {
-	*(void **)ap_push_array (sec) = sortbin[i].elt;
+	*(void **)ap_push_array(sec) = sortbin[i].elt;
     }
 
     sconf->sec = sec;
 }
 
 /*****************************************************************
@@ -381,88 +424,99 @@
  * There are some elements of the core config structures in which
  * other modules have a legitimate interest (this is ugly, but necessary
  * to preserve NCSA back-compatibility).  So, we have a bunch of accessors
  * here...
  */
 
-API_EXPORT(int) ap_allow_options (request_rec *r)
+API_EXPORT(int) ap_allow_options(request_rec *r)
 {
     core_dir_config *conf = 
       (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
 
     return conf->opts; 
 } 
 
-API_EXPORT(int) ap_allow_overrides (request_rec *r) 
+API_EXPORT(int) ap_allow_overrides(request_rec *r) 
 { 
-    core_dir_config *conf = 
-      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
+    core_dir_config *conf;
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
 
     return conf->override; 
 } 
 
-API_EXPORT(char *) ap_auth_type (request_rec *r)
+API_EXPORT(const char *) ap_auth_type(request_rec *r)
 {
-    core_dir_config *conf = 
-      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
+    core_dir_config *conf;
 
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
     return conf->ap_auth_type;
 }
 
-API_EXPORT(char *) ap_auth_name (request_rec *r)
+API_EXPORT(const char *) ap_auth_name(request_rec *r)
 {
-    core_dir_config *conf = 
-      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
+    core_dir_config *conf;
 
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
     return conf->ap_auth_name;
 }
 
-API_EXPORT(char *) ap_default_type (request_rec *r)
+API_EXPORT(const char *) ap_default_type(request_rec *r)
 {
-    core_dir_config *conf = 
-      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
+    core_dir_config *conf;
 
-    return conf->ap_default_type ? conf->ap_default_type : DEFAULT_CONTENT_TYPE;
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
+    return conf->ap_default_type 
+               ? conf->ap_default_type 
+               : DEFAULT_CONTENT_TYPE;
 }
 
-API_EXPORT(char *) ap_document_root (request_rec *r) /* Don't use this!!! */
+API_EXPORT(const char *) ap_document_root(request_rec *r) /* Don't use this! */
 {
-    core_server_config *conf = 
-      (core_server_config *)ap_get_module_config(r->server->module_config,
-					      &core_module); 
+    core_server_config *conf;
 
+    conf = (core_server_config *)ap_get_module_config(r->server->module_config,
+						      &core_module); 
     return conf->ap_document_root;
 }
 
-API_EXPORT(array_header *) ap_requires (request_rec *r)
+API_EXPORT(const array_header *) ap_requires(request_rec *r)
 {
-    core_dir_config *conf = 
-      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
+    core_dir_config *conf;
 
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
     return conf->ap_requires;
 }
 
-API_EXPORT(int) ap_satisfies (request_rec *r)
+API_EXPORT(int) ap_satisfies(request_rec *r)
 {
-    core_dir_config *conf =
-      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module);
 
     return conf->satisfy;
 }
 
 /* Should probably just get rid of this... the only code that cares is
  * part of the core anyway (and in fact, it isn't publicised to other
  * modules).
  */
 
-char *ap_response_code_string (request_rec *r, int error_index)
+char *ap_response_code_string(request_rec *r, int error_index)
 {
-    core_dir_config *conf = 
-      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
 
-    if( conf->response_code_strings == NULL ) {
+    if (conf->response_code_strings == NULL) {
 	return NULL;
     }
     return conf->response_code_strings[error_index];
 }
 
 
@@ -492,13 +546,14 @@
 	    }
 	}
     }
     conn->double_reverse = -1;
 }
 
-API_EXPORT(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config, int type)
+API_EXPORT(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config,
+					    int type)
 {
     struct in_addr *iaddr;
     struct hostent *hptr;
     int hostname_lookups;
 #ifdef STATUS
     int old_stat = SERVER_DEAD;	/* we shouldn't ever be in this state */
@@ -509,95 +564,107 @@
 	hostname_lookups =
 	    ((core_dir_config *)ap_get_module_config(dir_config, &core_module))
 		->hostname_lookups;
 	if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {
 	    hostname_lookups = HOSTNAME_LOOKUP_OFF;
 	}
-    } else {
+    }
+    else {
 	/* the default */
 	hostname_lookups = HOSTNAME_LOOKUP_OFF;
     }
 
     if (type != REMOTE_NOLOOKUP
 	&& conn->remote_host == NULL
 	&& (type == REMOTE_DOUBLE_REV
 	    || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {
 #ifdef STATUS
 	old_stat = ap_update_child_status(conn->child_num, SERVER_BUSY_DNS,
-					    (request_rec*)NULL);
+					  (request_rec*)NULL);
 #endif /* STATUS */
 	iaddr = &(conn->remote_addr.sin_addr);
 	hptr = gethostbyaddr((char *)iaddr, sizeof(struct in_addr), AF_INET);
 	if (hptr != NULL) {
 	    conn->remote_host = ap_pstrdup(conn->pool, (void *)hptr->h_name);
-	    ap_str_tolower (conn->remote_host);
+	    ap_str_tolower(conn->remote_host);
 	   
 	    if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {
-		do_double_reverse (conn);
+		do_double_reverse(conn);
 		if (conn->double_reverse != 1) {
 		    conn->remote_host = NULL;
 		}
 	    }
 	}
 	/* if failed, set it to the NULL string to indicate error */
-	if (conn->remote_host == NULL) conn->remote_host = "";
+	if (conn->remote_host == NULL) {
+	    conn->remote_host = "";
+	}
     }
     if (type == REMOTE_DOUBLE_REV) {
-	do_double_reverse (conn);
+	do_double_reverse(conn);
 	if (conn->double_reverse == -1) {
 	    return NULL;
 	}
     }
 #ifdef STATUS
     if (old_stat != SERVER_DEAD) {
-	(void)ap_update_child_status(conn->child_num,old_stat,(request_rec*)NULL);
+	(void)ap_update_child_status(conn->child_num, old_stat,
+				     (request_rec*)NULL);
     }
 #endif /* STATUS */
 
 /*
  * Return the desired information; either the remote DNS name, if found,
  * or either NULL (if the hostname was requested) or the IP address
  * (if any identifier was requested).
  */
-    if (conn->remote_host != NULL && conn->remote_host[0] != '\0')
+    if (conn->remote_host != NULL && conn->remote_host[0] != '\0') {
 	return conn->remote_host;
-    else
-    {
-	if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) return NULL;
-	else return conn->remote_ip;
+    }
+    else {
+	if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {
+	    return NULL;
+	}
+	else {
+	    return conn->remote_ip;
+	}
     }
 }
 
 API_EXPORT(const char *) ap_get_remote_logname(request_rec *r)
 {
     core_dir_config *dir_conf;
 
-    if (r->connection->remote_logname != NULL)
+    if (r->connection->remote_logname != NULL) {
 	return r->connection->remote_logname;
+    }
 
 /* If we haven't checked the identity, and we want to */
-    dir_conf = (core_dir_config *)
-	ap_get_module_config(r->per_dir_config, &core_module);
+    dir_conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						       &core_module);
 
-    if (dir_conf->do_rfc1413 & 1)
+    if (dir_conf->do_rfc1413 & 1) {
 	return ap_rfc1413(r->connection, r->server);
-    else
+    }
+    else {
 	return NULL;
+    }
 }
 
 /* There are two options regarding what the "name" of a server is.  The
  * "canonical" name as defined by ServerName and Port, or the "client's
  * name" as supplied by a possible Host: header or full URI.  We never
  * trust the port passed in the client's headers, we always use the
  * port of the actual socket.
  */
 API_EXPORT(const char *) ap_get_server_name(const request_rec *r)
 {
-    core_dir_config *d =
-      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
-    
+    core_dir_config *d;
+
+    d = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						&core_module);
     if (d->use_canonical_name & 1) {
 	return r->server->server_hostname;
     }
     return r->hostname ? r->hostname : r->server->server_hostname;
 }
 
@@ -610,33 +677,37 @@
     port = r->server->port ? r->server->port : ap_default_port(r);
 
     if (d->use_canonical_name & 1) {
 	return port;
     }
     return r->hostname ? ntohs(r->connection->local_addr.sin_port)
-			: port;
+		       : port;
 }
 
-API_EXPORT(char *) ap_construct_url(pool *p, const char *uri, const request_rec *r)
+API_EXPORT(char *) ap_construct_url(pool *p, const char *uri,
+				    const request_rec *r)
 {
     unsigned port;
     const char *host;
     core_dir_config *d =
       (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
 
     if (d->use_canonical_name & 1) {
 	port = r->server->port ? r->server->port : ap_default_port(r);
 	host = r->server->server_hostname;
     }
     else {
-        if (r->hostname)
+        if (r->hostname) {
             port = ntohs(r->connection->local_addr.sin_port);
-        else if (r->server->port)
+	}
+        else if (r->server->port) {
             port = r->server->port;
-        else
+	}
+        else {
             port = ap_default_port(r);
+	}
 
 	host = r->hostname ? r->hostname : r->server->server_hostname;
     }
     if (ap_is_default_port(port, r)) {
 	return ap_pstrcat(p, ap_http_method(r), "://", host, uri, NULL);
     }
@@ -654,109 +725,133 @@
 static const char end_location_section[] = "</Location>";
 static const char end_locationmatch_section[] = "</LocationMatch>";
 static const char end_files_section[] = "</Files>";
 static const char end_filesmatch_section[] = "</FilesMatch>";
 static const char end_virtualhost_section[] = "</VirtualHost>";
 static const char end_ifmodule_section[] = "</IfModule>";
+static const char end_ifdefine_section[] = "</IfDefine>";
 
 
-API_EXPORT(const char *) ap_check_cmd_context(cmd_parms *cmd, unsigned forbidden)
+API_EXPORT(const char *) ap_check_cmd_context(cmd_parms *cmd,
+					      unsigned forbidden)
 {
     const char *gt = (cmd->cmd->name[0] == '<'
-		   && cmd->cmd->name[strlen(cmd->cmd->name)-1] != '>') ? ">" : "";
+		      && cmd->cmd->name[strlen(cmd->cmd->name)-1] != '>')
+                         ? ">" : "";
 
-    if ((forbidden & NOT_IN_VIRTUALHOST) && cmd->server->is_virtual)
+    if ((forbidden & NOT_IN_VIRTUALHOST) && cmd->server->is_virtual) {
 	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
-		       " cannot occur within <VirtualHost> section", NULL);
+			  " cannot occur within <VirtualHost> section", NULL);
+    }
 
-    if ((forbidden & NOT_IN_LIMIT) && cmd->limited != -1)
+    if ((forbidden & NOT_IN_LIMIT) && cmd->limited != -1) {
 	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
-		       " cannot occur within <Limit> section", NULL);
+			  " cannot occur within <Limit> section", NULL);
+    }
 
-    if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE && cmd->path != NULL)
+    if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE
+	&& cmd->path != NULL) {
 	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
-		       " cannot occur within <Directory/Location/Files> section", NULL);
+			  " cannot occur within <Directory/Location/Files> "
+			  "section", NULL);
+    }
     
-    if (((forbidden & NOT_IN_DIRECTORY) && (cmd->end_token == end_directory_section
-	    || cmd->end_token == end_directorymatch_section)) ||
-	((forbidden & NOT_IN_LOCATION) && (cmd->end_token == end_location_section
-	    || cmd->end_token == end_locationmatch_section)) ||
-	((forbidden & NOT_IN_FILES) && (cmd->end_token == end_files_section
-	    || cmd->end_token == end_filesmatch_section)))
-	
+    if (((forbidden & NOT_IN_DIRECTORY)
+	 && (cmd->end_token == end_directory_section
+	     || cmd->end_token == end_directorymatch_section)) 
+	|| ((forbidden & NOT_IN_LOCATION)
+	    && (cmd->end_token == end_location_section
+		|| cmd->end_token == end_locationmatch_section)) 
+	|| ((forbidden & NOT_IN_FILES)
+	    && (cmd->end_token == end_files_section
+		|| cmd->end_token == end_filesmatch_section))) {
 	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
-		       " cannot occur within <", cmd->end_token+2,
-		       " section", NULL);
+			  " cannot occur within <", cmd->end_token+2,
+			  " section", NULL);
+    }
 
     return NULL;
 }
 
-static const char *set_access_name (cmd_parms *cmd, void *dummy, char *arg)
+static const char *set_access_name(cmd_parms *cmd, void *dummy, char *arg)
 {
     void *sconf = cmd->server->module_config;
-    core_server_config *conf = ap_get_module_config (sconf, &core_module);
+    core_server_config *conf = ap_get_module_config(sconf, &core_module);
 
-    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
 
     conf->access_name = ap_pstrdup(cmd->pool, arg);
     return NULL;
 }
 
-static const char *set_document_root (cmd_parms *cmd, void *dummy, char *arg)
+static const char *set_document_root(cmd_parms *cmd, void *dummy, char *arg)
 {
     void *sconf = cmd->server->module_config;
-    core_server_config *conf = ap_get_module_config (sconf, &core_module);
+    core_server_config *conf = ap_get_module_config(sconf, &core_module);
   
-    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
 
     arg = ap_os_canonical_filename(cmd->pool, arg);
-    if (!ap_is_directory (arg)) {
+    if (!ap_is_directory(arg)) {
 	if (cmd->server->is_virtual) {
-	    fprintf (stderr, "Warning: DocumentRoot [%s] does not exist\n", arg);
+	    fprintf(stderr, "Warning: DocumentRoot [%s] does not exist\n",
+		    arg);
 	}
 	else {
 	    return "DocumentRoot must be a directory";
 	}
     }
     
     conf->ap_document_root = arg;
     return NULL;
 }
 
-static const char *set_error_document (cmd_parms *cmd, core_dir_config *conf,
-				char *line)
+static const char *set_error_document(cmd_parms *cmd, core_dir_config *conf,
+				      char *line)
 {
     int error_number, index_number, idx500;
     char *w;
                 
     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     /* 1st parameter should be a 3 digit number, which we recognize;
      * convert it into an array index
      */
   
-    w = ap_getword_conf_nc (cmd->pool, &line);
+    w = ap_getword_conf_nc(cmd->pool, &line);
     error_number = atoi(w);
 
     idx500 = ap_index_of_response(HTTP_INTERNAL_SERVER_ERROR);
 
-    if (error_number == HTTP_INTERNAL_SERVER_ERROR)
+    if (error_number == HTTP_INTERNAL_SERVER_ERROR) {
         index_number = idx500;
-    else if ((index_number = ap_index_of_response(error_number)) == idx500)
-        return ap_pstrcat(cmd->pool, "Unsupported HTTP response code ", w, NULL);
+    }
+    else if ((index_number = ap_index_of_response(error_number)) == idx500) {
+        return ap_pstrcat(cmd->pool, "Unsupported HTTP response code ",
+			  w, NULL);
+    }
                 
     /* Store it... */
 
-    if( conf->response_code_strings == NULL ) {
-	conf->response_code_strings = ap_pcalloc(cmd->pool,
-	    sizeof(*conf->response_code_strings) * RESPONSE_CODES );
+    if (conf->response_code_strings == NULL) {
+	conf->response_code_strings =
+	    ap_pcalloc(cmd->pool,
+		       sizeof(*conf->response_code_strings) * RESPONSE_CODES);
     }
-    conf->response_code_strings[index_number] = ap_pstrdup (cmd->pool, line);
+    conf->response_code_strings[index_number] = ap_pstrdup(cmd->pool, line);
 
     return NULL;
 }
 
 /* access.conf commands...
  *
@@ -764,85 +859,107 @@
  * <Directory> section.  NB we need to have a way to cut the srm_command_loop
  * invoked by dirsection (i.e., <Directory>) short when </Directory> is seen.
  * We do that by returning an error, which dirsection itself recognizes and
  * discards as harmless.  Cheesy, but it works.
  */
 
-static const char *set_override (cmd_parms *cmd, core_dir_config *d, const char *l)
+static const char *set_override(cmd_parms *cmd, core_dir_config *d,
+				const char *l)
 {
     char *w;
   
     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
     if (err != NULL) {
         return err;
     }
 
     d->override = OR_NONE;
-    while(l[0]) {
-        w = ap_getword_conf (cmd->pool, &l);
-	if(!strcasecmp(w,"Limit"))
+    while (l[0]) {
+        w = ap_getword_conf(cmd->pool, &l);
+	if (!strcasecmp(w, "Limit")) {
 	    d->override |= OR_LIMIT;
-	else if(!strcasecmp(w,"Options"))
+	}
+	else if (!strcasecmp(w, "Options")) {
 	    d->override |= OR_OPTIONS;
-	else if(!strcasecmp(w,"FileInfo"))
+	}
+	else if (!strcasecmp(w, "FileInfo")) {
             d->override |= OR_FILEINFO;
-	else if(!strcasecmp(w,"AuthConfig"))
+	}
+	else if (!strcasecmp(w, "AuthConfig")) {
 	    d->override |= OR_AUTHCFG;
-	else if(!strcasecmp(w,"Indexes"))
+	}
+	else if (!strcasecmp(w, "Indexes")) {
             d->override |= OR_INDEXES;
-	else if(!strcasecmp(w,"None"))
+	}
+	else if (!strcasecmp(w, "None")) {
 	    d->override = OR_NONE;
-	else if(!strcasecmp(w,"All")) 
+	}
+	else if (!strcasecmp(w, "All")) {
 	    d->override = OR_ALL;
-	else 
-	    return ap_pstrcat (cmd->pool, "Illegal override option ", w, NULL);
+	}
+	else {
+	    return ap_pstrcat(cmd->pool, "Illegal override option ", w, NULL);
+	}
 	d->override &= ~OR_UNSET;
     }
 
     return NULL;
 }
 
-static const char *set_options (cmd_parms *cmd, core_dir_config *d, const char *l)
+static const char *set_options(cmd_parms *cmd, core_dir_config *d,
+			       const char *l)
 {
     allow_options_t opt;
     int first = 1;
     char action;
 
-    while(l[0]) {
+    while (l[0]) {
         char *w = ap_getword_conf(cmd->pool, &l);
 	action = '\0';
 
-	if (*w == '+' || *w == '-')
+	if (*w == '+' || *w == '-') {
 	    action = *(w++);
+	}
 	else if (first) {
   	    d->opts = OPT_NONE;
             first = 0;
         }
 	    
-	if(!strcasecmp(w,"Indexes"))
+	if (!strcasecmp(w, "Indexes")) {
 	    opt = OPT_INDEXES;
-	else if(!strcasecmp(w,"Includes"))
+	}
+	else if (!strcasecmp(w, "Includes")) {
 	    opt = OPT_INCLUDES;
-	else if(!strcasecmp(w,"IncludesNOEXEC"))
+	}
+	else if (!strcasecmp(w, "IncludesNOEXEC")) {
 	    opt = (OPT_INCLUDES | OPT_INCNOEXEC);
-	else if(!strcasecmp(w,"FollowSymLinks"))
+	}
+	else if (!strcasecmp(w, "FollowSymLinks")) {
 	    opt = OPT_SYM_LINKS;
-	else if(!strcasecmp(w,"SymLinksIfOwnerMatch"))
+	}
+	else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
 	    opt = OPT_SYM_OWNER;
-	else if(!strcasecmp(w,"execCGI"))
+	}
+	else if (!strcasecmp(w, "execCGI")) {
 	    opt = OPT_EXECCGI;
-	else if (!strcasecmp(w,"MultiViews"))
+	}
+	else if (!strcasecmp(w, "MultiViews")) {
 	    opt = OPT_MULTI;
-	else if (!strcasecmp(w,"RunScripts")) /* AI backcompat. Yuck */
+	}
+	else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
 	    opt = OPT_MULTI|OPT_EXECCGI;
-	else if(!strcasecmp(w,"None")) 
+	}
+	else if (!strcasecmp(w, "None")) {
 	    opt = OPT_NONE;
-	else if(!strcasecmp(w,"All")) 
+	}
+	else if (!strcasecmp(w, "All")) {
 	    opt = OPT_ALL;
-	else 
-	    return ap_pstrcat (cmd->pool, "Illegal option ", w, NULL);
+	}
+	else {
+	    return ap_pstrcat(cmd->pool, "Illegal option ", w, NULL);
+	}
 
 	/* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
 	if (action == '-') {
 	    d->opts_remove |= opt;
 	    d->opts_add &= ~opt;
 	    d->opts &= ~opt;
@@ -857,83 +974,107 @@
 	}
     }
 
     return NULL;
 }
 
-static const char *satisfy (cmd_parms *cmd, core_dir_config *c, char *arg)
+static const char *satisfy(cmd_parms *cmd, core_dir_config *c, char *arg)
 {
-    if(!strcasecmp(arg,"all"))
+    if (!strcasecmp(arg, "all")) {
         c->satisfy = SATISFY_ALL;
-    else if(!strcasecmp(arg,"any"))
+    }
+    else if (!strcasecmp(arg, "any")) {
         c->satisfy = SATISFY_ANY;
-    else
+    }
+    else {
         return "Satisfy either 'any' or 'all'.";
+    }
     return NULL;
 }
 
-static const char *require (cmd_parms *cmd, core_dir_config *c, char *arg)
+static const char *require(cmd_parms *cmd, core_dir_config *c, char *arg)
 {
     require_line *r;
   
-    if (!c->ap_requires)
-        c->ap_requires = ap_make_array (cmd->pool, 2, sizeof(require_line));
-    
-    r = (require_line *)ap_push_array (c->ap_requires);
-    r->requirement = ap_pstrdup (cmd->pool, arg);
+    if (!c->ap_requires) {
+        c->ap_requires = ap_make_array(cmd->pool, 2, sizeof(require_line));
+    }
+    r = (require_line *)ap_push_array(c->ap_requires);
+    r->requirement = ap_pstrdup(cmd->pool, arg);
     r->method_mask = cmd->limited;
     return NULL;
 }
 
-CORE_EXPORT_NONSTD(const char *) ap_limit_section (cmd_parms *cmd, void *dummy, const char *arg)
+CORE_EXPORT_NONSTD(const char *) ap_limit_section(cmd_parms *cmd, void *dummy,
+						  const char *arg)
 {
-    const char *limited_methods = ap_getword(cmd->pool,&arg,'>');
+    const char *limited_methods = ap_getword(cmd->pool, &arg, '>');
     int limited = 0;
   
     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     /* XXX: NB: Currently, we have no way of checking
      * whether <Limit> sections are closed properly.
      * (If we would add a srm_command_loop() here we might...)
      */
     
-    while(limited_methods[0]) {
-        char *method = ap_getword_conf (cmd->pool, &limited_methods);
-	if(!strcasecmp(method,"GET")) limited |= (1 << M_GET);
-	else if(!strcasecmp(method,"PUT")) limited |= (1 << M_PUT);
-	else if(!strcasecmp(method,"POST")) limited |= (1 << M_POST);
-	else if(!strcasecmp(method,"DELETE")) limited |= (1 << M_DELETE);
-        else if(!strcasecmp(method,"CONNECT")) limited |= (1 << M_CONNECT);
-	else if(!strcasecmp(method,"OPTIONS")) limited |= (1 << M_OPTIONS);
-	else return "unknown method in <Limit>";
+    while (limited_methods[0]) {
+        char *method = ap_getword_conf(cmd->pool, &limited_methods);
+	if (!strcmp(method, "GET")) {
+	    limited |= (1 << M_GET);
+	}
+	else if (!strcmp(method, "PUT")) {
+	    limited |= (1 << M_PUT);
+	}
+	else if (!strcmp(method, "POST")) {
+	    limited |= (1 << M_POST);
+	}
+	else if (!strcmp(method, "DELETE")) {
+	    limited |= (1 << M_DELETE);
+	}
+        else if (!strcmp(method, "CONNECT")) {
+	    limited |= (1 << M_CONNECT);
+	}
+	else if (!strcmp(method, "OPTIONS")) {
+	    limited |= (1 << M_OPTIONS);
+	}
+	else {
+	    return ap_pstrcat(cmd->pool, "unknown method \"",
+			      method, "\" in <Limit>", NULL);
+	}
     }
 
     cmd->limited = limited;
     return NULL;
 }
 
-static const char *endlimit_section (cmd_parms *cmd, void *dummy, void *dummy2)
+static const char *endlimit_section(cmd_parms *cmd, void *dummy, void *dummy2)
 {
-    if (cmd->limited == -1) return "</Limit> unexpected";
+    if (cmd->limited == -1) {
+        return "</Limit> unexpected";
+    }
     
     cmd->limited = -1;
     return NULL;
 }
 
 /*
  * When a section is not closed properly when end-of-file is reached,
  * then an error message should be printed:
  */
-static const char *missing_endsection (cmd_parms *cmd, int nest)
+static const char *missing_endsection(cmd_parms *cmd, int nest)
 {
-    if (nest < 2)
+    if (nest < 2) {
 	return ap_psprintf(cmd->pool, "Missing %s directive at end-of-file",
-		    cmd->end_token);
+			   cmd->end_token);
+    }
     return ap_psprintf(cmd->pool, "%d missing %s directives at end-of-file",
-		    nest, cmd->end_token);
+		       nest, cmd->end_token);
 }
 
 /* We use this in <DirectoryMatch> and <FilesMatch>, to ensure that 
  * people don't get bitten by wrong-cased regex matches
  */
 
@@ -953,689 +1094,891 @@
 	return ap_pstrcat(cmd->pool, "Expected ", cmd->end_token, " but saw ",
 	    cmd->cmd->name, NULL);
     }
     return cmd->end_token;
 }
 
-static const char *dirsection (cmd_parms *cmd, void *dummy, const char *arg)
+static const char *dirsection(cmd_parms *cmd, void *dummy, const char *arg)
 {
     const char *errmsg;
-    char *endp = strrchr (arg, '>');
+    char *endp = strrchr(arg, '>');
     int old_overrides = cmd->override;
     char *old_path = cmd->path;
     core_dir_config *conf;
-    void *new_dir_conf = ap_create_per_dir_config (cmd->pool);
+    void *new_dir_conf = ap_create_per_dir_config(cmd->pool);
     regex_t *r = NULL;
     const char *old_end_token;
     const command_rec *thiscmd = cmd->cmd;
 
-    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
 
-    if (endp) *endp = '\0';
+    if (endp) {
+        *endp = '\0';
+    }
 
-    cmd->path = ap_getword_conf (cmd->pool, &arg);
+    cmd->path = ap_getword_conf(cmd->pool, &arg);
 #ifdef __EMX__
     /* Fix OS/2 HPFS filename case problem. */
     cmd->path = strlwr(cmd->path);
 #endif    
     cmd->override = OR_ALL|ACCESS_CONF;
 
     if (thiscmd->cmd_data) { /* <DirectoryMatch> */
 	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
     }
     else if (!strcmp(cmd->path, "~")) {
-	cmd->path = ap_getword_conf (cmd->pool, &arg);
+	cmd->path = ap_getword_conf(cmd->pool, &arg);
 	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
     }
     else {
 	/* Ensure that the pathname is canonical */
 	cmd->path = ap_os_canonical_filename(cmd->pool, cmd->path);
     }
 
     old_end_token = cmd->end_token;
     cmd->end_token = thiscmd->cmd_data ? end_directorymatch_section : end_directory_section;
-    errmsg = ap_srm_command_loop (cmd, new_dir_conf);
+    errmsg = ap_srm_command_loop(cmd, new_dir_conf);
     if (errmsg == NULL) {
 	errmsg = missing_endsection(cmd, 1);
     }
     cmd->end_token = old_end_token;
-    if (errmsg != (thiscmd->cmd_data ? end_directorymatch_section : end_directory_section))
+    if (errmsg != (thiscmd->cmd_data 
+		       ? end_directorymatch_section 
+		   : end_directory_section)) {
 	return errmsg;
+    }
 
     conf = (core_dir_config *)ap_get_module_config(new_dir_conf, &core_module);
     conf->r = r;
 
-    ap_add_per_dir_conf (cmd->server, new_dir_conf);
+    ap_add_per_dir_conf(cmd->server, new_dir_conf);
 
-    if (*arg != '\0')
-	return ap_pstrcat (cmd->pool, "Multiple ", thiscmd->name,
-			"> arguments not (yet) supported.", NULL);
+    if (*arg != '\0') {
+	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+			  "> arguments not (yet) supported.", NULL);
+    }
 
     cmd->path = old_path;
     cmd->override = old_overrides;
 
     return NULL;
 }
 
-static const char *urlsection (cmd_parms *cmd, void *dummy, const char *arg)
+static const char *urlsection(cmd_parms *cmd, void *dummy, const char *arg)
 {
     const char *errmsg;
-    char *endp = strrchr (arg, '>');
+    char *endp = strrchr(arg, '>');
     int old_overrides = cmd->override;
     char *old_path = cmd->path;
     core_dir_config *conf;
     regex_t *r = NULL;
     const char *old_end_token;
     const command_rec *thiscmd = cmd->cmd;
 
-    void *new_url_conf = ap_create_per_dir_config (cmd->pool);
+    void *new_url_conf = ap_create_per_dir_config(cmd->pool);
 
-    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
 
-    if (endp) *endp = '\0';
+    if (endp) {
+        *endp = '\0';
+    }
 
-    cmd->path = ap_getword_conf (cmd->pool, &arg);
+    cmd->path = ap_getword_conf(cmd->pool, &arg);
     cmd->override = OR_ALL|ACCESS_CONF;
 
     if (thiscmd->cmd_data) { /* <LocationMatch> */
 	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED);
     }
     else if (!strcmp(cmd->path, "~")) {
-	cmd->path = ap_getword_conf (cmd->pool, &arg);
+	cmd->path = ap_getword_conf(cmd->pool, &arg);
 	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED);
     }
 
     old_end_token = cmd->end_token;
-    cmd->end_token = thiscmd->cmd_data ? end_locationmatch_section : end_location_section;
-    errmsg = ap_srm_command_loop (cmd, new_url_conf);
+    cmd->end_token = thiscmd->cmd_data ? end_locationmatch_section
+                                       : end_location_section;
+    errmsg = ap_srm_command_loop(cmd, new_url_conf);
     if (errmsg == NULL) {
 	errmsg = missing_endsection(cmd, 1);
     }
     cmd->end_token = old_end_token;
-    if (errmsg != (thiscmd->cmd_data ? end_locationmatch_section : end_location_section))
+    if (errmsg != (thiscmd->cmd_data 
+		       ? end_locationmatch_section 
+		       : end_location_section)) {
 	return errmsg;
+    }
 
     conf = (core_dir_config *)ap_get_module_config(new_url_conf, &core_module);
     conf->d = ap_pstrdup(cmd->pool, cmd->path);	/* No mangling, please */
-    conf->d_is_fnmatch = ap_is_fnmatch( conf->d ) != 0;
+    conf->d_is_fnmatch = ap_is_fnmatch(conf->d) != 0;
     conf->r = r;
 
-    ap_add_per_url_conf (cmd->server, new_url_conf);
+    ap_add_per_url_conf(cmd->server, new_url_conf);
     
-    if (*arg != '\0')
-	return ap_pstrcat (cmd->pool, "Multiple ", thiscmd->name,
-			"> arguments not (yet) supported.", NULL);
+    if (*arg != '\0') {
+	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+			  "> arguments not (yet) supported.", NULL);
+    }
 
     cmd->path = old_path;
     cmd->override = old_overrides;
 
     return NULL;
 }
 
-static const char *filesection (cmd_parms *cmd, core_dir_config *c, const char *arg)
+static const char *filesection(cmd_parms *cmd, core_dir_config *c,
+			       const char *arg)
 {
     const char *errmsg;
-    char *endp = strrchr (arg, '>');
+    char *endp = strrchr(arg, '>');
     int old_overrides = cmd->override;
     char *old_path = cmd->path;
     core_dir_config *conf;
     regex_t *r = NULL;
     const char *old_end_token;
     const command_rec *thiscmd = cmd->cmd;
 
-    void *new_file_conf = ap_create_per_dir_config (cmd->pool);
+    void *new_file_conf = ap_create_per_dir_config(cmd->pool);
 
-    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT | NOT_IN_LOCATION);
-    if (err != NULL) return err;
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT|NOT_IN_LOCATION);
+    if (err != NULL) {
+        return err;
+    }
 
-    if (endp) *endp = '\0';
+    if (endp) {
+        *endp = '\0';
+    }
 
-    cmd->path = ap_getword_conf (cmd->pool, &arg);
+    cmd->path = ap_getword_conf(cmd->pool, &arg);
     /* Only if not an .htaccess file */
-    if (!old_path)
+    if (!old_path) {
 	cmd->override = OR_ALL|ACCESS_CONF;
+    }
 
     if (thiscmd->cmd_data) { /* <FilesMatch> */
         r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
     }
     else if (!strcmp(cmd->path, "~")) {
-	cmd->path = ap_getword_conf (cmd->pool, &arg);
+	cmd->path = ap_getword_conf(cmd->pool, &arg);
 	r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
     }
     else {
 	/* Ensure that the pathname is canonical */
 	cmd->path = ap_os_canonical_filename(cmd->pool, cmd->path);
     }
 
     old_end_token = cmd->end_token;
     cmd->end_token = thiscmd->cmd_data ? end_filesmatch_section : end_files_section;
-    errmsg = ap_srm_command_loop (cmd, new_file_conf);
+    errmsg = ap_srm_command_loop(cmd, new_file_conf);
     if (errmsg == NULL) {
 	errmsg = missing_endsection(cmd, 1);
     }
     cmd->end_token = old_end_token;
-    if (errmsg != (thiscmd->cmd_data ? end_filesmatch_section : end_files_section))
+    if (errmsg != (thiscmd->cmd_data 
+		       ? end_filesmatch_section 
+		   : end_files_section)) {
 	return errmsg;
+    }
 
-    conf = (core_dir_config *)ap_get_module_config(new_file_conf, &core_module);
+    conf = (core_dir_config *)ap_get_module_config(new_file_conf,
+						   &core_module);
     conf->d = cmd->path;
     conf->d_is_fnmatch = ap_is_fnmatch(conf->d) != 0;
     conf->r = r;
 
-    add_file_conf (c, new_file_conf);
+    add_file_conf(c, new_file_conf);
 
-    if (*arg != '\0')
-	return ap_pstrcat (cmd->pool, "Multiple ", thiscmd->name,
-			"> arguments not (yet) supported.", NULL);
+    if (*arg != '\0') {
+	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+			  "> arguments not (yet) supported.", NULL);
+    }
 
     cmd->path = old_path;
     cmd->override = old_overrides;
 
     return NULL;
 }
 
 /* XXX: NB: Currently, we have no way of checking
  * whether <IfModule> sections are closed properly.
  * Extra (redundant, unpaired) </IfModule> directives are
  * simply silently ignored.
  */
-static const char *end_ifmod (cmd_parms *cmd, void *dummy) {
+static const char *end_ifmod(cmd_parms *cmd, void *dummy)
+{
     return NULL;
 }
 
-static const char *start_ifmod (cmd_parms *cmd, void *dummy, char *arg)
+static const char *start_ifmod(cmd_parms *cmd, void *dummy, char *arg)
 {
-    char *endp = strrchr (arg, '>');
+    char *endp = strrchr(arg, '>');
     char l[MAX_STRING_LEN];
     int not = (arg[0] == '!');
     module *found;
     int nest = 1;
 
-    if (endp) *endp = '\0';
-    if (not) arg++;
+    if (endp) {
+        *endp = '\0';
+    }
+    if (not) {
+        arg++;
+    }
 
     found = ap_find_linked_module(arg);
 
-    if ((!not && found) || (not && !found))
-      return NULL;
+    if ((!not && found) || (not && !found)) {
+        return NULL;
+    }
 
-    while (nest && !(ap_cfg_getline (l, MAX_STRING_LEN, cmd->config_file))) {
-        if (!strncasecmp(l, "<IfModule", 9))
-	  nest++;
-	if (!strcasecmp(l, "</IfModule>"))
+    while (nest && !(ap_cfg_getline(l, MAX_STRING_LEN, cmd->config_file))) {
+        if (!strncasecmp(l, "<IfModule", 9)) {
+	    nest++;
+	}
+	if (!strcasecmp(l, "</IfModule>")) {
 	  nest--;
+	}
     }
 
     if (nest) {
 	cmd->end_token = end_ifmodule_section;
 	return missing_endsection(cmd, nest);
     }
     return NULL;
 }
 
+static int ap_exists_config_define(char *name)
+{
+    char **defines;
+    int i;
+
+    defines = (char **)ap_server_config_defines->elts;
+    for (i = 0; i < ap_server_config_defines->nelts; i++) {
+        if (strcmp(defines[i], name) == 0) {
+            return 1;
+	}
+    }
+    return 0;
+}
+
+static const char *end_ifdefine(cmd_parms *cmd, void *dummy) 
+{
+    return NULL;
+}
+
+static const char *start_ifdefine(cmd_parms *cmd, void *dummy, char *arg)
+{
+    char *endp;
+    char l[MAX_STRING_LEN];
+    int defined;
+    int not = 0;
+    int nest = 1;
+
+    endp = strrchr(arg, '>');
+    if (endp) {
+	*endp = '\0';
+    }
+    if (arg[0] == '!') {
+        not = 1;
+	arg++;
+    }
+
+    defined = ap_exists_config_define(arg);
+
+    if ((!not && defined) || (not && !defined)) {
+	return NULL;
+    }
+
+    while (nest && !(ap_cfg_getline(l, MAX_STRING_LEN, cmd->config_file))) {
+        if (!strncasecmp(l, "<IfDefine", 9)) {
+	    nest++;
+	}
+	if (!strcasecmp(l, "</IfDefine>")) {
+	    nest--;
+	}
+    }
+    if (nest) {
+	cmd->end_token = end_ifdefine_section;
+	return missing_endsection(cmd, nest);
+    }
+    return NULL;
+}
+
 /* httpd.conf commands... beginning with the <VirtualHost> business */
 
-static const char *virtualhost_section (cmd_parms *cmd, void *dummy, char *arg)
+static const char *virtualhost_section(cmd_parms *cmd, void *dummy, char *arg)
 {
     server_rec *main_server = cmd->server, *s;
     const char *errmsg;
-    char *endp = strrchr (arg, '>');
+    char *endp = strrchr(arg, '>');
     pool *p = cmd->pool, *ptemp = cmd->temp_pool;
     const char *old_end_token;
 
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    if (endp) *endp = '\0';
+    if (endp) {
+        *endp = '\0';
+    }
     
     /* FIXME: There's another feature waiting to happen here -- since you
 	can now put multiple addresses/names on a single <VirtualHost>
 	you might want to use it to group common definitions and then
 	define other "subhosts" with their individual differences.  But
 	personally I'd rather just do it with a macro preprocessor. -djg */
-    if (main_server->is_virtual)
+    if (main_server->is_virtual) {
 	return "<VirtualHost> doesn't nest!";
+    }
     
-    errmsg = ap_init_virtual_host (p, arg, main_server, &s);
-    if (errmsg)
+    errmsg = ap_init_virtual_host(p, arg, main_server, &s);
+    if (errmsg) {
 	return errmsg;
+    }
 
     s->next = main_server->next;
     main_server->next = s;
 
     s->defn_name = cmd->config_file->name;
     s->defn_line_number = cmd->config_file->line_number;
 
     old_end_token = cmd->end_token;
     cmd->end_token = end_virtualhost_section;
     cmd->server = s;
-    errmsg = ap_srm_command_loop (cmd, s->lookup_defaults);
+    errmsg = ap_srm_command_loop(cmd, s->lookup_defaults);
     cmd->server = main_server;
     if (errmsg == NULL) {
 	errmsg = missing_endsection(cmd, 1);
     }
     cmd->end_token = old_end_token;
 
-    if (s->srm_confname)
-	ap_process_resource_config (s, s->srm_confname, p, ptemp);
+    if (s->srm_confname) {
+	ap_process_resource_config(s, s->srm_confname, p, ptemp);
+    }
 
-    if (s->access_confname)
-	ap_process_resource_config (s, s->access_confname, p, ptemp);
+    if (s->access_confname) {
+	ap_process_resource_config(s, s->access_confname, p, ptemp);
+    }
     
-    if (errmsg == end_virtualhost_section)
+    if (errmsg == end_virtualhost_section) {
 	return NULL;
+    }
     return errmsg;
 }
 
-static const char *set_server_alias(cmd_parms *cmd, void *dummy, const char *arg)
+static const char *set_server_alias(cmd_parms *cmd, void *dummy,
+				    const char *arg)
 {
-    if (!cmd->server->names)
+    if (!cmd->server->names) {
 	return "ServerAlias only used in <VirtualHost>";
+    }
     while (*arg) {
 	char **item, *name = ap_getword_conf(cmd->pool, &arg);
-	if (ap_is_matchexp(name))
-	    item = (char **) ap_push_array(cmd->server->wild_names);
-	else
-	    item = (char **) ap_push_array(cmd->server->names);
+	if (ap_is_matchexp(name)) {
+	    item = (char **)ap_push_array(cmd->server->wild_names);
+	}
+	else {
+	    item = (char **)ap_push_array(cmd->server->names);
+	}
 	*item = name;
     }
     return NULL;
 }
 
-static const char *add_module_command (cmd_parms *cmd, void *dummy, char *arg)
+static const char *add_module_command(cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    if (!ap_add_named_module(arg))
+    if (!ap_add_named_module(arg)) {
 	return ap_pstrcat(cmd->pool, "Cannot add module via name '", arg, 
 			  "': not in list of loaded modules", NULL);
+    }
     return NULL;
 }
 
-static const char *clear_module_list_command (cmd_parms *cmd, void *dummy)
+static const char *clear_module_list_command(cmd_parms *cmd, void *dummy)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_clear_module_list ();
+    ap_clear_module_list();
     return NULL;
 }
 
-static const char *set_server_string_slot (cmd_parms *cmd, void *dummy,
-		                                   char *arg)
+static const char *set_server_string_slot(cmd_parms *cmd, void *dummy,
+					  char *arg)
 {
     /* This one's pretty generic... */
   
     int offset = (int)(long)cmd->info;
     char *struct_ptr = (char *)cmd->server;
     
-    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    const char *err = ap_check_cmd_context(cmd, 
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
 
     *(char **)(struct_ptr + offset) = arg;
     return NULL;
 }
 
-static const char *server_type (cmd_parms *cmd, void *dummy, char *arg)
+static const char *server_type(cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    if (!strcasecmp (arg, "inetd")) ap_standalone = 0;
-    else if (!strcasecmp (arg, "standalone")) ap_standalone = 1;
-    else return "ServerType must be either 'inetd' or 'standalone'";
+    if (!strcasecmp(arg, "inetd")) {
+        ap_standalone = 0;
+    }
+    else if (!strcasecmp(arg, "standalone")) {
+        ap_standalone = 1;
+    }
+    else {
+        return "ServerType must be either 'inetd' or 'standalone'";
+    }
 
     return NULL;
 }
 
-static const char *server_port (cmd_parms *cmd, void *dummy, char *arg)
+static const char *server_port(cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
     int port;
 
-    if (err != NULL) 
+    if (err != NULL) {
 	return err;
+    }
     port = atoi(arg);
-    if (port <= 0 || port >= 65536) /* 65536 == 1<<16 */
+    if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */
 	return ap_pstrcat(cmd->temp_pool, "The port number \"", arg, 
-		       "\" is outside the appropriate range (i.e. 1..65535).",
-		       NULL);
+			  "\" is outside the appropriate range "
+			  "(i.e., 1..65535).", NULL);
+    }
     cmd->server->port = port;
     return NULL;
 }
 
-static const char *set_signature_flag (cmd_parms *cmd, core_dir_config *d, 
-		                               char *arg)
+static const char *set_signature_flag(cmd_parms *cmd, core_dir_config *d, 
+				      char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    if (strcasecmp(arg, "On") == 0)
+    if (strcasecmp(arg, "On") == 0) {
 	d->server_signature = srv_sig_on;
-    else if (strcasecmp(arg, "Off") == 0)
+    }
+    else if (strcasecmp(arg, "Off") == 0) {
 	d->server_signature = srv_sig_off;
-    else if (strcasecmp(arg, "EMail") == 0)
+    }
+    else if (strcasecmp(arg, "EMail") == 0) {
 	d->server_signature = srv_sig_withmail;
-    else
+    }
+    else {
 	return "ServerSignature: use one of: off | on | email";
+    }
     return NULL;
 }
 
-static const char *set_send_buffer_size (cmd_parms *cmd, void *dummy, char *arg)
+static const char *set_send_buffer_size(cmd_parms *cmd, void *dummy, char *arg)
 {
-    int s = atoi (arg);
+    int s = atoi(arg);
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     if (s < 512 && s != 0) {
         return "SendBufferSize must be >= 512 bytes, or 0 for system default.";
     }
     cmd->server->send_buffer_size = s;
     return NULL;
 }
 
-static const char *set_user (cmd_parms *cmd, void *dummy, char *arg)
+static const char *set_user(cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     if (!cmd->server->is_virtual) {
 	ap_user_name = arg;
 	cmd->server->server_uid = ap_user_id = ap_uname2id(arg);
     }
     else {
-	if (ap_suexec_enabled)
+        if (ap_suexec_enabled) {
 	    cmd->server->server_uid = ap_uname2id(arg);
+	}
 	else {
 	    cmd->server->server_uid = ap_user_id;
 	    fprintf(stderr,
-		"Warning: User directive in <VirtualHost> "
-		"requires SUEXEC wrapper.\n");
+		    "Warning: User directive in <VirtualHost> "
+		    "requires SUEXEC wrapper.\n");
 	}
     }
 #if !defined (BIG_SECURITY_HOLE) && !defined (__EMX__)
     if (cmd->server->server_uid == 0) {
-	fprintf (stderr,
-"Error:\tApache has not been designed to serve pages while running\n"
-"\tas root.  There are known race conditions that will allow any\n"
-"\tlocal user to read any file on the system.  Should you still\n"
-"\tdesire to serve pages as root then add -DBIG_SECURITY_HOLE to\n"
-"\tthe EXTRA_CFLAGS line in your src/Configuration file and rebuild\n"
-"\tthe server.  It is strongly suggested that you instead modify the\n"
-"\tUser directive in your httpd.conf file to list a non-root user.\n");
+	fprintf(stderr,
+		"Error:\tApache has not been designed to serve pages while\n"
+		"\trunning as root.  There are known race conditions that\n"
+		"\twill allow any local user to read any file on the system.\n"
+		"\tShould you still desire to serve pages as root then\n"
+		"\tadd -DBIG_SECURITY_HOLE to the EXTRA_CFLAGS line in your\n"
+		"\tsrc/Configuration file and rebuild the server.  It is\n"
+		"\tstrongly suggested that you instead modify the User\n"
+		"\tdirective in your httpd.conf file to list a non-root\n"
+		"\tuser.\n");
 	exit (1);
     }
 #endif
 
     return NULL;
 }
 
-static const char *set_group (cmd_parms *cmd, void *dummy, char *arg)
+static const char *set_group(cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    if (!cmd->server->is_virtual)
+    if (!cmd->server->is_virtual) {
 	cmd->server->server_gid = ap_group_id = ap_gname2id(arg);
+    }
     else {
-	if (ap_suexec_enabled)
+        if (ap_suexec_enabled) {
 	    cmd->server->server_gid = ap_gname2id(arg);
+	}
 	else {
 	    cmd->server->server_gid = ap_group_id;
 	    fprintf(stderr,
-		    "Warning: Group directive in <VirtualHost> requires SUEXEC wrapper.\n");
+		    "Warning: Group directive in <VirtualHost> requires "
+		    "SUEXEC wrapper.\n");
 	}
     }
 
     return NULL;
 }
 
-static const char *set_server_root (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_server_root(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
 
-    if (!ap_is_directory (arg)) return "ServerRoot must be a valid directory";
-    ap_cpystrn (ap_server_root, ap_os_canonical_filename(cmd->pool, arg), sizeof(ap_server_root));
+    if (err != NULL) {
+        return err;
+    }
+
+    arg = ap_os_canonical_filename(cmd->pool, arg);
+
+    if (!ap_is_directory(arg)) {
+        return "ServerRoot must be a valid directory";
+    }
+    ap_cpystrn(ap_server_root, arg,
+	       sizeof(ap_server_root));
     return NULL;
 }
 
-static const char *set_timeout (cmd_parms *cmd, void *dummy, char *arg) {
+static const char *set_timeout(cmd_parms *cmd, void *dummy, char *arg)
+{
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    cmd->server->timeout = atoi (arg);
+    cmd->server->timeout = atoi(arg);
     return NULL;
 }
 
-static const char *set_keep_alive_timeout (cmd_parms *cmd, void *dummy,
-		                                   char *arg)
+static const char *set_keep_alive_timeout(cmd_parms *cmd, void *dummy,
+					  char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    cmd->server->keep_alive_timeout = atoi (arg);
+    cmd->server->keep_alive_timeout = atoi(arg);
     return NULL;
 }
 
-static const char *set_keep_alive (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_keep_alive(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     /* We've changed it to On/Off, but used to use numbers
      * so we accept anything but "Off" or "0" as "On"
      */
-    if (!strcasecmp(arg, "off") || !strcmp(arg, "0"))
+    if (!strcasecmp(arg, "off") || !strcmp(arg, "0")) {
 	cmd->server->keep_alive = 0;
-    else
+    }
+    else {
 	cmd->server->keep_alive = 1;
+    }
     return NULL;
 }
 
-static const char *set_keep_alive_max (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_keep_alive_max(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    cmd->server->keep_alive_max = atoi (arg);
+    cmd->server->keep_alive_max = atoi(arg);
     return NULL;
 }
 
-static const char *set_pidfile (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_pidfile(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    if (cmd->server->is_virtual)
+    if (cmd->server->is_virtual) {
 	return "PidFile directive not allowed in <VirtualHost>";
+    }
     ap_pid_fname = arg;
     return NULL;
 }
 
-static const char *set_scoreboard (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_scoreboard(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     ap_scoreboard_fname = arg;
     return NULL;
 }
 
-static const char *set_lockfile (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_lockfile(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     ap_lock_fname = arg;
     return NULL;
 }
 
-static const char *set_idcheck (cmd_parms *cmd, core_dir_config *d, int arg) 
+static const char *set_idcheck(cmd_parms *cmd, core_dir_config *d, int arg) 
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     d->do_rfc1413 = arg != 0;
     return NULL;
 }
 
-static const char *set_hostname_lookups (cmd_parms *cmd, core_dir_config *d,
-		                                 char *arg)
+static const char *set_hostname_lookups(cmd_parms *cmd, core_dir_config *d,
+					char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    if (!strcasecmp (arg, "on")) {
+    if (!strcasecmp(arg, "on")) {
 	d->hostname_lookups = HOSTNAME_LOOKUP_ON;
-    } else if (!strcasecmp (arg, "off")) {
+    }
+    else if (!strcasecmp(arg, "off")) {
 	d->hostname_lookups = HOSTNAME_LOOKUP_OFF;
-    } else if (!strcasecmp (arg, "double")) {
+    }
+    else if (!strcasecmp(arg, "double")) {
 	d->hostname_lookups = HOSTNAME_LOOKUP_DOUBLE;
-    } else {
+    }
+    else {
 	return "parameter must be 'on', 'off', or 'double'";
     }
     return NULL;
 }
 
-static const char *set_serverpath (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_serverpath(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     cmd->server->path = arg;
-    cmd->server->pathlen = strlen (arg);
+    cmd->server->pathlen = strlen(arg);
     return NULL;
 }
 
-static const char *set_content_md5 (cmd_parms *cmd, core_dir_config *d, int arg) 
+static const char *set_content_md5(cmd_parms *cmd, core_dir_config *d, int arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     d->content_md5 = arg != 0;
     return NULL;
 }
 
-static const char *set_use_canonical_name (cmd_parms *cmd, core_dir_config *d, 
-		                                   int arg)
+static const char *set_use_canonical_name(cmd_parms *cmd, core_dir_config *d, 
+					  int arg)
 {
     const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
 
-    if (err != NULL)
+    if (err != NULL) {
 	return err;
+    }
     
     d->use_canonical_name = arg != 0;
     return NULL;
 }
 
-static const char *set_daemons_to_start (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, char *arg) 
 {
+#ifdef WIN32
+    fprintf(stderr, "WARNING: StartServers has no effect on Win32\n");
+#else
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_daemons_to_start = atoi (arg);
+    ap_daemons_to_start = atoi(arg);
+#endif
     return NULL;
 }
 
-static const char *set_min_free_servers (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_min_free_servers(cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_daemons_min_free = atoi (arg);
+    ap_daemons_min_free = atoi(arg);
     if (ap_daemons_min_free <= 0) {
        fprintf(stderr, "WARNING: detected MinSpareServers set to non-positive.\n");
        fprintf(stderr, "Resetting to 1 to avoid almost certain Apache failure.\n");
        fprintf(stderr, "Please read the documentation.\n");
        ap_daemons_min_free = 1;
     }
        
     return NULL;
 }
 
-static const char *set_max_free_servers (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_max_free_servers(cmd_parms *cmd, void *dummy, char *arg)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_daemons_max_free = atoi (arg);
+    ap_daemons_max_free = atoi(arg);
     return NULL;
 }
 
 static const char *set_server_limit (cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_daemons_limit = atoi (arg);
+    ap_daemons_limit = atoi(arg);
     if (ap_daemons_limit > HARD_SERVER_LIMIT) {
        fprintf(stderr, "WARNING: MaxClients of %d exceeds compile time limit "
            "of %d servers,\n", ap_daemons_limit, HARD_SERVER_LIMIT);
        fprintf(stderr, " lowering MaxClients to %d.  To increase, please "
            "see the\n", HARD_SERVER_LIMIT);
        fprintf(stderr, " HARD_SERVER_LIMIT define in src/httpd.h.\n");
        ap_daemons_limit = HARD_SERVER_LIMIT;
-    } else if (ap_daemons_limit < 1) {
-	fprintf (stderr, "WARNING: Require MaxClients > 0, setting to 1\n");
+    } 
+    else if (ap_daemons_limit < 1) {
+	fprintf(stderr, "WARNING: Require MaxClients > 0, setting to 1\n");
 	ap_daemons_limit = 1;
     }
     return NULL;
 }
 
-static const char *set_max_requests (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_max_requests(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_max_requests_per_child = atoi (arg);
+    ap_max_requests_per_child = atoi(arg);
     return NULL;
 }
 
-static const char *set_threads (cmd_parms *cmd, void *dummy, char *arg) {
+static const char *set_threads(cmd_parms *cmd, void *dummy, char *arg) {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_threads_per_child = atoi (arg);
+    ap_threads_per_child = atoi(arg);
 #ifdef WIN32
-    if(ap_threads_per_child > 64)
+    if (ap_threads_per_child > 64) {
 	return "Can't have more than 64 threads in Windows (for now)";
+    }
 #endif
 
     return NULL;
 }
 
-static const char *set_excess_requests (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_excess_requests(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_excess_requests_per_child = atoi (arg);
+    ap_excess_requests_per_child = atoi(arg);
     return NULL;
 }
 
 
 #if defined(RLIMIT_CPU) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)
 static void set_rlimit(cmd_parms *cmd, struct rlimit **plimit, const char *arg,
                        const char * arg2, int type)
 {
     char *str;
     struct rlimit *limit;
-    /* If your platform doesn't define rlim_t then typedef it in conf.h */
+    /* If your platform doesn't define rlim_t then typedef it in ap_config.h */
     rlim_t cur = 0;
     rlim_t max = 0;
 
-    *plimit = (struct rlimit *)ap_pcalloc(cmd->pool,sizeof **plimit);
+    *plimit = (struct rlimit *)ap_pcalloc(cmd->pool, sizeof(**plimit));
     limit = *plimit;
     if ((getrlimit(type, limit)) != 0)	{
 	*plimit = NULL;
 	ap_log_error(APLOG_MARK, APLOG_ERR, cmd->server,
-		    "%s: getrlimit failed", cmd->cmd->name);
+		     "%s: getrlimit failed", cmd->cmd->name);
 	return;
     }
 
     if ((str = ap_getword_conf(cmd->pool, &arg))) {
 	if (!strcasecmp(str, "max")) {
 	    cur = limit->rlim_max;
@@ -1643,146 +1986,167 @@
 	else {
 	    cur = atol(str);
 	}
     }
     else {
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
-		    "Invalid parameters for %s", cmd->cmd->name);
+		     "Invalid parameters for %s", cmd->cmd->name);
 	return;
     }
     
-    if (arg2 && (str = ap_getword_conf(cmd->pool, &arg2)))
+    if (arg2 && (str = ap_getword_conf(cmd->pool, &arg2))) {
 	max = atol(str);
+    }
 
     /* if we aren't running as root, cannot increase max */
     if (geteuid()) {
 	limit->rlim_cur = cur;
-	if (max)
+	if (max) {
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
-			"Must be uid 0 to raise maximum %s", cmd->cmd->name);
+			 "Must be uid 0 to raise maximum %s", cmd->cmd->name);
+	}
     }
     else {
-	if (cur)
+        if (cur) {
 	    limit->rlim_cur = cur;
-	if (max)
+	}
+        if (max) {
 	    limit->rlim_max = max;
+	}
     }
 }
 #endif
 
 #if !defined (RLIMIT_CPU) || !(defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)) || !defined (RLIMIT_NPROC)
-static const char *no_set_limit (cmd_parms *cmd, core_dir_config *conf,
-				 char *arg, char *arg2)
+static const char *no_set_limit(cmd_parms *cmd, core_dir_config *conf,
+				char *arg, char *arg2)
 {
     ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
 		"%s not supported on this platform", cmd->cmd->name);
     return NULL;
 }
 #endif
 
 #ifdef RLIMIT_CPU
-static const char *set_limit_cpu (cmd_parms *cmd, core_dir_config *conf, 
-	                          char *arg, char *arg2)
+static const char *set_limit_cpu(cmd_parms *cmd, core_dir_config *conf, 
+				 char *arg, char *arg2)
 {
-    set_rlimit(cmd,&conf->limit_cpu,arg,arg2,RLIMIT_CPU);
+    set_rlimit(cmd, &conf->limit_cpu, arg, arg2, RLIMIT_CPU);
     return NULL;
 }
 #endif
 
 #if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)
-static const char *set_limit_mem (cmd_parms *cmd, core_dir_config *conf, 
-	                          char *arg, char * arg2)
+static const char *set_limit_mem(cmd_parms *cmd, core_dir_config *conf, 
+				 char *arg, char * arg2)
 {
 #if defined(RLIMIT_AS)
-    set_rlimit(cmd,&conf->limit_mem,arg,arg2,RLIMIT_AS);
+    set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);
 #elif defined(RLIMIT_DATA)
-    set_rlimit(cmd,&conf->limit_mem,arg,arg2,RLIMIT_DATA);
+    set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);
 #elif defined(RLIMIT_VMEM)
-    set_rlimit(cmd,&conf->limit_mem,arg,arg2,RLIMIT_VMEM);
+    set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);
 #endif
     return NULL;
 }
 #endif
 
 #ifdef RLIMIT_NPROC
-static const char *set_limit_nproc (cmd_parms *cmd, core_dir_config *conf,  
-	                            char *arg, char * arg2)
+static const char *set_limit_nproc(cmd_parms *cmd, core_dir_config *conf,  
+				   char *arg, char * arg2)
 {
-    set_rlimit(cmd,&conf->limit_nproc,arg,arg2,RLIMIT_NPROC);
+    set_rlimit(cmd, &conf->limit_nproc, arg, arg2, RLIMIT_NPROC);
     return NULL;
 }
 #endif
 
-static const char *set_bind_address (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_bind_address(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ap_bind_address.s_addr = ap_get_virthost_addr (arg, NULL);
+    ap_bind_address.s_addr = ap_get_virthost_addr(arg, NULL);
     return NULL;
 }
 
 static const char *set_listener(cmd_parms *cmd, void *dummy, char *ips)
 {
     listen_rec *new;
     char *ports;
     unsigned short port;
 
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    ports=strchr(ips, ':');
-    if (ports != NULL)
-    {
-	if (ports == ips) return "Missing IP address";
-	else if (ports[1] == '\0')
+    ports = strchr(ips, ':');
+    if (ports != NULL) {
+	if (ports == ips) {
+	    return "Missing IP address";
+	}
+	else if (ports[1] == '\0') {
 	    return "Address must end in :<port-number>";
+	}
 	*(ports++) = '\0';
-    } else
+    }
+    else {
 	ports = ips;
+    }
 
     new=ap_pcalloc(cmd->pool, sizeof(listen_rec));
     new->local_addr.sin_family = AF_INET;
-    if (ports == ips) /* no address */
+    if (ports == ips) { /* no address */
 	new->local_addr.sin_addr.s_addr = htonl(INADDR_ANY);
-    else
+    }
+    else {
 	new->local_addr.sin_addr.s_addr = ap_get_virthost_addr(ips, NULL);
-    port=atoi(ports);
-    if(!port)
+    }
+    port = atoi(ports);
+    if (!port) {
 	return "Port must be numeric";
+    }
     new->local_addr.sin_port = htons(port);
     new->fd = -1;
     new->used = 0;
     new->next = ap_listeners;
     ap_listeners = new;
     return NULL;
 }
 
-static const char *set_listenbacklog (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_listenbacklog(cmd_parms *cmd, void *dummy, char *arg) 
 {
     int b;
 
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    b = atoi (arg);
-    if (b < 1) return "ListenBacklog must be > 0";
+    b = atoi(arg);
+    if (b < 1) {
+        return "ListenBacklog must be > 0";
+    }
     ap_listenbacklog = b;
     return NULL;
 }
 
 static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg) 
 {
     struct stat finfo;
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     arg = ap_server_root_relative(cmd->pool, arg);
     if ((stat(arg, &finfo) == -1) || !S_ISDIR(finfo.st_mode)) {
 	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", arg, 
-	    " does not exist or is not a directory", NULL);
+			  " does not exist or is not a directory", NULL);
     }
     ap_cpystrn(ap_coredump_dir, arg, sizeof(ap_coredump_dir));
     return NULL;
 }
 
 static const char *include_config (cmd_parms *cmd, void *dummy, char *name)
@@ -1791,65 +2155,82 @@
     
     ap_process_resource_config(cmd->server, name, cmd->pool, cmd->temp_pool);
 
     return NULL;
 }
 
-static const char *set_loglevel (cmd_parms *cmd, void *dummy, const char *arg) 
+static const char *set_loglevel(cmd_parms *cmd, void *dummy, const char *arg) 
 {
-   char *str;
+    char *str;
     
-    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
-    if (err != NULL) return err;
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    if ((str = ap_getword_conf(cmd->pool, &arg))) {
+        if (!strcasecmp(str, "emerg")) {
+	    cmd->server->loglevel = APLOG_EMERG;
+	}
+	else if (!strcasecmp(str, "alert")) {
+	    cmd->server->loglevel = APLOG_ALERT;
+	}
+	else if (!strcasecmp(str, "crit")) {
+	    cmd->server->loglevel = APLOG_CRIT;
+	}
+	else if (!strcasecmp(str, "error")) {
+	    cmd->server->loglevel = APLOG_ERR;
+	}
+	else if (!strcasecmp(str, "warn")) {
+	    cmd->server->loglevel = APLOG_WARNING;
+	}
+	else if (!strcasecmp(str, "notice")) {
+	    cmd->server->loglevel = APLOG_NOTICE;
+	}
+	else if (!strcasecmp(str, "info")) {
+	    cmd->server->loglevel = APLOG_INFO;
+	}
+	else if (!strcasecmp(str, "debug")) {
+	    cmd->server->loglevel = APLOG_DEBUG;
+	}
+	else {
+            return "LogLevel requires level keyword: one of "
+	           "emerg/alert/crit/error/warn/notice/info/debug";
+	}
+    }
+    else {
+        return "LogLevel requires level keyword";
+    }
 
-   if ((str = ap_getword_conf(cmd->pool, &arg))) {
-       if (!strcasecmp(str, "emerg"))
-	   cmd->server->loglevel = APLOG_EMERG;
-       else if (!strcasecmp(str, "alert"))
-	   cmd->server->loglevel = APLOG_ALERT;
-       else if (!strcasecmp(str, "crit"))
-	   cmd->server->loglevel = APLOG_CRIT;
-       else if (!strcasecmp(str, "error"))
-	   cmd->server->loglevel = APLOG_ERR;
-       else if (!strcasecmp(str, "warn"))
-	   cmd->server->loglevel = APLOG_WARNING;
-       else if (!strcasecmp(str, "notice"))
-	   cmd->server->loglevel = APLOG_NOTICE;
-       else if (!strcasecmp(str, "info"))
-	   cmd->server->loglevel = APLOG_INFO;
-       else if (!strcasecmp(str, "debug"))
-	   cmd->server->loglevel = APLOG_DEBUG;
-       else
-           return "LogLevel requires level keyword: one of emerg/alert/crit/error/warn/notice/info/debug";
-   }
-   else
-       return "LogLevel requires level keyword";
-   
-   return NULL;
+    return NULL;
 }
 
 API_EXPORT(const char *) ap_psignature(const char *prefix, request_rec *r)
 {
     char sport[20];
-    core_dir_config *conf =
-    (core_dir_config *) ap_get_module_config(r->per_dir_config, &core_module);
+    core_dir_config *conf;
 
-    if (conf->server_signature == srv_sig_off)
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module);
+    if (conf->server_signature == srv_sig_off) {
 	return "";
+    }
 
     ap_snprintf(sport, sizeof sport, "%u", (unsigned) ap_get_server_port(r));
 
     if (conf->server_signature == srv_sig_withmail) {
 	return ap_pstrcat(r->pool, prefix, "<ADDRESS>" SERVER_BASEVERSION
-	     " Server at <A HREF=\"mailto:", r->server->server_admin, "\">",
-		       ap_get_server_name(r), "</A> Port ", sport,
-		       "</ADDRESS>\n", NULL);
+			  " Server at <A HREF=\"mailto:",
+			  r->server->server_admin, "\">",
+			  ap_get_server_name(r), "</A> Port ", sport,
+			  "</ADDRESS>\n", NULL);
     }
     return ap_pstrcat(r->pool, prefix, "<ADDRESS>" SERVER_BASEVERSION
-	     " Server at ", ap_get_server_name(r), " Port ", sport,
-		   "</ADDRESS>\n", NULL);
+		      " Server at ", ap_get_server_name(r), " Port ", sport,
+		      "</ADDRESS>\n", NULL);
 }
 
 /*
  * Load an authorisation realm into our location configuration, applying the
  * usual rules that apply to realms.
  */
@@ -1859,16 +2240,18 @@
 
     aconfig->ap_auth_name = ap_escape_quotes(cmd->pool, word1);
     return NULL;
 }
 
 #ifdef _OSD_POSIX /* BS2000 Logon Passwd file */
-static const char *set_bs2000_authfile (cmd_parms *cmd, void *dummy, char *name)
+static const char *set_bs2000_authfile(cmd_parms *cmd, void *dummy, char *name)
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
     return os_set_authfile(cmd->pool, name);
 }
 #endif /*_OSD_POSIX*/
 
 /*
@@ -1876,23 +2259,28 @@
  * response header field (the ServerTokens directive).  Unfortunately
  * this requires a new global in order to communicate the setting back to
  * http_main so it can insert the information in the right place in the
  * string.
  */
 
-static const char *set_serv_tokens (cmd_parms *cmd, void *dummy, char *arg) 
+static const char *set_serv_tokens(cmd_parms *cmd, void *dummy, char *arg) 
 {
     const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
-    if (err != NULL) return err;
+    if (err != NULL) {
+        return err;
+    }
 
-    if (!strcasecmp(arg, "OS"))
+    if (!strcasecmp(arg, "OS")) {
         ap_server_tokens = SrvTk_OS;
-    else if (!strcasecmp(arg, "Min") || !strcasecmp(arg, "Minimal"))
+    }
+    else if (!strcasecmp(arg, "Min") || !strcasecmp(arg, "Minimal")) {
         ap_server_tokens = SrvTk_MIN;
-    else
+    }
+    else {
         ap_server_tokens = SrvTk_FULL;
+    }
     return NULL;
 }
 
 /* Note --- ErrorDocument will now work from .htaccess files.  
  * The AllowOverride of Fileinfo allows webmasters to turn it off
  */
@@ -1901,64 +2289,103 @@
 
 /* Old access config file commands */
 
 { "<Directory", dirsection, NULL, RSRC_CONF, RAW_ARGS,
   "Container for directives affecting resources located in the specified "
   "directories" },
-{ end_directory_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS, "Marks end of <Directory>" },
-{ "<Location", urlsection, NULL, RSRC_CONF, RAW_ARGS, "Container for directives affecting resources accessed through the specified URL paths" },
-{ end_location_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS, "Marks end of <Location>" },
-{ "<VirtualHost", virtualhost_section, NULL, RSRC_CONF, RAW_ARGS, "Container to map directives to a particular virtual host, takes one or more host addresses" },
-{ end_virtualhost_section, end_nested_section, NULL, RSRC_CONF, NO_ARGS, "Marks end of <VirtualHost>" },
-{ "<Files", filesection, NULL, OR_ALL, RAW_ARGS, "Container for directives affecting files matching specified patterns" },
-{ end_files_section, end_nested_section, NULL, OR_ALL, NO_ARGS, "Marks end of <Files>" },
-{ "<Limit", ap_limit_section, NULL, OR_ALL, RAW_ARGS, "Container for authentication directives when accessed using specified HTTP methods" },
-{ "</Limit>", endlimit_section, NULL, OR_ALL, NO_ARGS, "Marks end of <Limit>" },
-{ "<IfModule", start_ifmod, NULL, OR_ALL, RAW_ARGS, "Container for directives based on existance of specified modules" },
-{ end_ifmodule_section, end_ifmod, NULL, OR_ALL, NO_ARGS, "Marks end of <IfModule>" },
-{ "<DirectoryMatch", dirsection, (void*)1, RSRC_CONF, RAW_ARGS, "Container for directives affecting resources located in the specified directories" },
-{ end_directorymatch_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS, "Marks end of <DirectoryMatch>" },
-{ "<LocationMatch", urlsection, (void*)1, RSRC_CONF, RAW_ARGS, "Container for directives affecting resources accessed through the specified URL paths" },
-{ end_locationmatch_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS, "Marks end of <LocationMatch>" },
-{ "<FilesMatch", filesection, (void*)1, OR_ALL, RAW_ARGS, "Container for directives affecting files matching specified patterns" },
-{ end_filesmatch_section, end_nested_section, NULL, OR_ALL, NO_ARGS, "Marks end of <FilesMatch>" },
-{ "AuthType", ap_set_string_slot, (void*)XtOffsetOf(core_dir_config, ap_auth_type),
-    OR_AUTHCFG, TAKE1, "An HTTP authorization type (e.g., \"Basic\")" },
+{ end_directory_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
+  "Marks end of <Directory>" },
+{ "<Location", urlsection, NULL, RSRC_CONF, RAW_ARGS,
+  "Container for directives affecting resources accessed through the "
+  "specified URL paths" },
+{ end_location_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
+  "Marks end of <Location>" },
+{ "<VirtualHost", virtualhost_section, NULL, RSRC_CONF, RAW_ARGS,
+  "Container to map directives to a particular virtual host, takes one or "
+  "more host addresses" },
+{ end_virtualhost_section, end_nested_section, NULL, RSRC_CONF, NO_ARGS,
+  "Marks end of <VirtualHost>" },
+{ "<Files", filesection, NULL, OR_ALL, RAW_ARGS, "Container for directives "
+  "affecting files matching specified patterns" },
+{ end_files_section, end_nested_section, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <Files>" },
+{ "<Limit", ap_limit_section, NULL, OR_ALL, RAW_ARGS, "Container for "
+  "authentication directives when accessed using specified HTTP methods" },
+{ "</Limit>", endlimit_section, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <Limit>" },
+{ "<IfModule", start_ifmod, NULL, OR_ALL, RAW_ARGS,
+  "Container for directives based on existance of specified modules" },
+{ end_ifmodule_section, end_ifmod, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <IfModule>" },
+{ "<IfDefine", start_ifdefine, NULL, OR_ALL, RAW_ARGS,
+  "Container for directives based on existance of command line defines" },
+{ end_ifdefine_section, end_ifdefine, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <IfDefine>" },
+{ "<DirectoryMatch", dirsection, (void*)1, RSRC_CONF, RAW_ARGS,
+  "Container for directives affecting resources located in the "
+  "specified directories" },
+{ end_directorymatch_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
+  "Marks end of <DirectoryMatch>" },
+{ "<LocationMatch", urlsection, (void*)1, RSRC_CONF, RAW_ARGS,
+  "Container for directives affecting resources accessed through the "
+  "specified URL paths" },
+{ end_locationmatch_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
+  "Marks end of <LocationMatch>" },
+{ "<FilesMatch", filesection, (void*)1, OR_ALL, RAW_ARGS,
+  "Container for directives affecting files matching specified patterns" },
+{ end_filesmatch_section, end_nested_section, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <FilesMatch>" },
+{ "AuthType", ap_set_string_slot,
+  (void*)XtOffsetOf(core_dir_config, ap_auth_type), OR_AUTHCFG, TAKE1,
+  "An HTTP authorization type (e.g., \"Basic\")" },
 { "AuthName", set_authname, NULL, OR_AUTHCFG, TAKE1,
-    "The authentication realm (e.g. \"Members Only\")" },
-{ "Require", require, NULL, OR_AUTHCFG, RAW_ARGS, "Selects which authenticated users or groups may access a protected space" },
+  "The authentication realm (e.g. \"Members Only\")" },
+{ "Require", require, NULL, OR_AUTHCFG, RAW_ARGS,
+  "Selects which authenticated users or groups may access a protected space" },
 { "Satisfy", satisfy, NULL, OR_AUTHCFG, TAKE1,
-    "access policy if both allow and require used ('all' or 'any')" },    
+  "access policy if both allow and require used ('all' or 'any')" },    
 
 /* Old resource config file commands */
   
-{ "AccessFileName", set_access_name, NULL, RSRC_CONF, RAW_ARGS, "Name(s) of per-directory config files (default: .htaccess)" },
-{ "DocumentRoot", set_document_root, NULL, RSRC_CONF, TAKE1, "Root directory of the document tree"  },
-{ "ErrorDocument", set_error_document, NULL, OR_FILEINFO, RAW_ARGS, "Change responses for HTTP errors" },
-{ "AllowOverride", set_override, NULL, ACCESS_CONF, RAW_ARGS, "Controls what groups of directives can be configured by per-directory config files" },
-{ "Options", set_options, NULL, OR_OPTIONS, RAW_ARGS, "Set a number of attributes for a given directory" },
+{ "AccessFileName", set_access_name, NULL, RSRC_CONF, RAW_ARGS,
+  "Name(s) of per-directory config files (default: .htaccess)" },
+{ "DocumentRoot", set_document_root, NULL, RSRC_CONF, TAKE1,
+  "Root directory of the document tree"  },
+{ "ErrorDocument", set_error_document, NULL, OR_FILEINFO, RAW_ARGS,
+  "Change responses for HTTP errors" },
+{ "AllowOverride", set_override, NULL, ACCESS_CONF, RAW_ARGS,
+  "Controls what groups of directives can be configured by per-directory "
+  "config files" },
+{ "Options", set_options, NULL, OR_OPTIONS, RAW_ARGS,
+  "Set a number of attributes for a given directory" },
 { "DefaultType", ap_set_string_slot,
-    (void*)XtOffsetOf (core_dir_config, ap_default_type),
-    OR_FILEINFO, TAKE1, "the default MIME type for untypable files" },
+  (void*)XtOffsetOf (core_dir_config, ap_default_type),
+  OR_FILEINFO, TAKE1, "the default MIME type for untypable files" },
 
 /* Old server config file commands */
 
-{ "ServerType", server_type, NULL, RSRC_CONF, TAKE1,"'inetd' or 'standalone'"},
+{ "ServerType", server_type, NULL, RSRC_CONF, TAKE1,
+  "'inetd' or 'standalone'"},
 { "Port", server_port, NULL, RSRC_CONF, TAKE1, "A TCP port number"},
-{ "HostnameLookups", set_hostname_lookups, NULL, ACCESS_CONF|RSRC_CONF, TAKE1, "\"on\" to enable, \"off\" to disable reverse DNS lookups, or \"double\" to enable double-reverse DNS lookups" },
-{ "User", set_user, NULL, RSRC_CONF, TAKE1, "Effective user id for this server"},
-{ "Group", set_group, NULL, RSRC_CONF, TAKE1, "Effective group id for this server"},
+{ "HostnameLookups", set_hostname_lookups, NULL, ACCESS_CONF|RSRC_CONF, TAKE1,
+  "\"on\" to enable, \"off\" to disable reverse DNS lookups, or \"double\" to "
+  "enable double-reverse DNS lookups" },
+{ "User", set_user, NULL, RSRC_CONF, TAKE1,
+  "Effective user id for this server"},
+{ "Group", set_group, NULL, RSRC_CONF, TAKE1,
+  "Effective group id for this server"},
 { "ServerAdmin", set_server_string_slot,
   (void *)XtOffsetOf (server_rec, server_admin), RSRC_CONF, TAKE1,
   "The email address of the server administrator" },
 { "ServerName", set_server_string_slot,
   (void *)XtOffsetOf (server_rec, server_hostname), RSRC_CONF, TAKE1,
   "The hostname of the server" },
 { "ServerSignature", set_signature_flag, NULL, ACCESS_CONF|RSRC_CONF, TAKE1,
   "En-/disable server signature (on|off|email)" },
-{ "ServerRoot", set_server_root, NULL, RSRC_CONF, TAKE1, "Common directory of server-related files (logs, confs, etc)" },
+{ "ServerRoot", set_server_root, NULL, RSRC_CONF, TAKE1,
+  "Common directory of server-related files (logs, confs, etc.)" },
 { "ErrorLog", set_server_string_slot,
   (void *)XtOffsetOf (server_rec, error_fname), RSRC_CONF, TAKE1,
   "The filename of the error log" },
 { "PidFile", set_pidfile, NULL, RSRC_CONF, TAKE1,
     "A file for logging the server process ID"},
 { "ScoreBoardFile", set_scoreboard, NULL, RSRC_CONF, TAKE1,
@@ -1972,111 +2399,140 @@
   (void *)XtOffsetOf (server_rec, srm_confname), RSRC_CONF, TAKE1,
   "The filename of the resource config file" },
 { "ServerAlias", set_server_alias, NULL, RSRC_CONF, RAW_ARGS,
   "A name or names alternately used to access the server" },
 { "ServerPath", set_serverpath, NULL, RSRC_CONF, TAKE1,
   "The pathname the server can be reached at" },
-{ "Timeout", set_timeout, NULL, RSRC_CONF, TAKE1, "Timeout duration (sec)"},
-{ "KeepAliveTimeout", set_keep_alive_timeout, NULL, RSRC_CONF, TAKE1, "Keep-Alive timeout duration (sec)"},
-{ "MaxKeepAliveRequests", set_keep_alive_max, NULL, RSRC_CONF, TAKE1, "Maximum number of Keep-Alive requests per connection, or 0 for infinite" },
-{ "KeepAlive", set_keep_alive, NULL, RSRC_CONF, TAKE1, "Whether persistent connections should be On or Off" },
-{ "IdentityCheck", set_idcheck, NULL, RSRC_CONF|ACCESS_CONF, FLAG, "Enable identd (RFC 1413) user lookups - SLOW" },
-{ "ContentDigest", set_content_md5, NULL, RSRC_CONF|ACCESS_CONF|OR_AUTHCFG, FLAG, "whether or not to send a Content-MD5 header with each request" },
-{ "UseCanonicalName", set_use_canonical_name, NULL, RSRC_CONF|ACCESS_CONF|OR_AUTHCFG, FLAG, "whether or not to always use the canonical ServerName : Port when constructing URLs" },
-{ "StartServers", set_daemons_to_start, NULL, RSRC_CONF, TAKE1, "Number of child processes launched at server startup" },
-{ "MinSpareServers", set_min_free_servers, NULL, RSRC_CONF, TAKE1, "Minimum number of idle children, to handle request spikes" },
-{ "MaxSpareServers", set_max_free_servers, NULL, RSRC_CONF, TAKE1, "Maximum number of idle children" },
-{ "MaxServers", set_max_free_servers, NULL, RSRC_CONF, TAKE1, "Deprecated equivalent to MaxSpareServers" },
-{ "ServersSafetyLimit", set_server_limit, NULL, RSRC_CONF, TAKE1, "Deprecated equivalent to MaxClients" },
-{ "MaxClients", set_server_limit, NULL, RSRC_CONF, TAKE1, "Maximum number of children alive at the same time" },
-{ "MaxRequestsPerChild", set_max_requests, NULL, RSRC_CONF, TAKE1, "Maximum number of requests a particular child serves before dying." },
+{ "Timeout", set_timeout, NULL, RSRC_CONF, TAKE1, "Timeout duration (sec)" },
+{ "KeepAliveTimeout", set_keep_alive_timeout, NULL, RSRC_CONF, TAKE1,
+  "Keep-Alive timeout duration (sec)"},
+{ "MaxKeepAliveRequests", set_keep_alive_max, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of Keep-Alive requests per connection, or 0 for infinite" },
+{ "KeepAlive", set_keep_alive, NULL, RSRC_CONF, TAKE1,
+  "Whether persistent connections should be On or Off" },
+{ "IdentityCheck", set_idcheck, NULL, RSRC_CONF|ACCESS_CONF, FLAG,
+  "Enable identd (RFC 1413) user lookups - SLOW" },
+{ "ContentDigest", set_content_md5, NULL, RSRC_CONF|ACCESS_CONF|OR_AUTHCFG,
+  FLAG, "whether or not to send a Content-MD5 header with each request" },
+{ "UseCanonicalName", set_use_canonical_name, NULL,
+  RSRC_CONF|ACCESS_CONF|OR_AUTHCFG, FLAG,
+  "Whether or not to always use the canonical ServerName : Port when "
+  "constructing URLs" },
+{ "StartServers", set_daemons_to_start, NULL, RSRC_CONF, TAKE1,
+  "Number of child processes launched at server startup" },
+{ "MinSpareServers", set_min_free_servers, NULL, RSRC_CONF, TAKE1,
+  "Minimum number of idle children, to handle request spikes" },
+{ "MaxSpareServers", set_max_free_servers, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of idle children" },
+{ "MaxServers", set_max_free_servers, NULL, RSRC_CONF, TAKE1,
+  "Deprecated equivalent to MaxSpareServers" },
+{ "ServersSafetyLimit", set_server_limit, NULL, RSRC_CONF, TAKE1,
+  "Deprecated equivalent to MaxClients" },
+{ "MaxClients", set_server_limit, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of children alive at the same time" },
+{ "MaxRequestsPerChild", set_max_requests, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of requests a particular child serves before dying." },
 { "RLimitCPU",
 #ifdef RLIMIT_CPU
- set_limit_cpu, (void*)XtOffsetOf(core_dir_config, limit_cpu),
+  set_limit_cpu, (void*)XtOffsetOf(core_dir_config, limit_cpu),
 #else
- no_set_limit, NULL,
+  no_set_limit, NULL,
 #endif
-      OR_ALL, TAKE12, "soft/hard limits for max CPU usage in seconds" },
+  OR_ALL, TAKE12, "Soft/hard limits for max CPU usage in seconds" },
 { "RLimitMEM",
 #if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined (RLIMIT_AS)
- set_limit_mem, (void*)XtOffsetOf(core_dir_config, limit_mem),
+  set_limit_mem, (void*)XtOffsetOf(core_dir_config, limit_mem),
 #else
- no_set_limit, NULL,
+  no_set_limit, NULL,
 #endif
-      OR_ALL, TAKE12, "soft/hard limits for max memory usage per process" },
+  OR_ALL, TAKE12, "Soft/hard limits for max memory usage per process" },
 { "RLimitNPROC",
 #ifdef RLIMIT_NPROC
- set_limit_nproc, (void*)XtOffsetOf(core_dir_config, limit_nproc),
+  set_limit_nproc, (void*)XtOffsetOf(core_dir_config, limit_nproc),
 #else
- no_set_limit, NULL,
+  no_set_limit, NULL,
 #endif
-      OR_ALL, TAKE12, "soft/hard limits for max number of processes per uid" },
+   OR_ALL, TAKE12, "soft/hard limits for max number of processes per uid" },
 { "BindAddress", set_bind_address, NULL, RSRC_CONF, TAKE1,
   "'*', a numeric IP address, or the name of a host with a unique IP address"},
 { "Listen", set_listener, NULL, RSRC_CONF, TAKE1,
-      "a port number or a numeric IP address and a port number"},
-{ "SendBufferSize", set_send_buffer_size, NULL, RSRC_CONF, TAKE1, "send buffer size in bytes"},
+  "A port number or a numeric IP address and a port number"},
+{ "SendBufferSize", set_send_buffer_size, NULL, RSRC_CONF, TAKE1,
+  "Send buffer size in bytes"},
 { "AddModule", add_module_command, NULL, RSRC_CONF, ITERATE,
-  "the name of a module" },
-{ "ClearModuleList", clear_module_list_command, NULL, RSRC_CONF, NO_ARGS, NULL },
-{ "ThreadsPerChild", set_threads, NULL, RSRC_CONF, TAKE1, "Number of threads a child creates" },
-{ "ExcessRequestsPerChild", set_excess_requests, NULL, RSRC_CONF, TAKE1, "Maximum number of requests a particular child serves after it is ready to die." },
-{ "ListenBacklog", set_listenbacklog, NULL, RSRC_CONF, TAKE1, "maximum length of the queue of pending connections, as used by listen(2)" },
-{ "CoreDumpDirectory", set_coredumpdir, NULL, RSRC_CONF, TAKE1, "The location of the directory Apache changes to before dumping core" },
-{ "Include", include_config, NULL, RSRC_CONF, TAKE1, "config file to be included" },
-{ "LogLevel", set_loglevel, NULL, RSRC_CONF, TAKE1, "set level of verbosity in error logging" },
+  "The name of a module" },
+{ "ClearModuleList", clear_module_list_command, NULL, RSRC_CONF, NO_ARGS, 
+  NULL },
+{ "ThreadsPerChild", set_threads, NULL, RSRC_CONF, TAKE1,
+  "Number of threads a child creates" },
+{ "ExcessRequestsPerChild", set_excess_requests, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of requests a particular child serves after it is ready "
+  "to die." },
+{ "ListenBacklog", set_listenbacklog, NULL, RSRC_CONF, TAKE1,
+  "Maximum length of the queue of pending connections, as used by listen(2)" },
+{ "CoreDumpDirectory", set_coredumpdir, NULL, RSRC_CONF, TAKE1,
+  "The location of the directory Apache changes to before dumping core" },
+{ "Include", include_config, NULL, RSRC_CONF, TAKE1,
+  "Name of the config file to be included" },
+{ "LogLevel", set_loglevel, NULL, RSRC_CONF, TAKE1,
+  "Level of verbosity in error logging" },
 { "NameVirtualHost", ap_set_name_virtual_host, NULL, RSRC_CONF, TAKE1,
-  "a numeric ip address:port, or the name of a host" },
+  "A numeric IP address:port, or the name of a host" },
 #ifdef _OSD_POSIX
 { "BS2000AuthFile", set_bs2000_authfile, NULL, RSRC_CONF, TAKE1,
-  "server User's bs2000 logon password file (read-protected)" },
+  "Name of server User's bs2000 logon password file (read-protected)" },
 #endif
 { "ServerTokens", set_serv_tokens, NULL, RSRC_CONF, TAKE1,
   "Determine tokens displayed in the Server: header - Min(imal), OS or Full" },
 { NULL },
 };
 
 /*****************************************************************
  *
  * Core handlers for various phases of server operation...
  */
 
-static int core_translate (request_rec *r)
+static int core_translate(request_rec *r)
 {
     void *sconf = r->server->module_config;
-    core_server_config *conf = ap_get_module_config (sconf, &core_module);
+    core_server_config *conf = ap_get_module_config(sconf, &core_module);
   
-    if (r->proxyreq) return HTTP_FORBIDDEN;
+    if (r->proxyreq) {
+        return HTTP_FORBIDDEN;
+    }
     if ((r->uri[0] != '/') && strcmp(r->uri, "*")) {
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
-		    "Invalid URI in request %s", r->the_request);
+		     "Invalid URI in request %s", r->the_request);
 	return BAD_REQUEST;
     }
     
-    if (r->server->path &&
-	!strncmp(r->uri, r->server->path, r->server->pathlen) &&
-	(r->server->path[r->server->pathlen - 1] == '/' ||
-	 r->uri[r->server->pathlen] == '/' ||
-	 r->uri[r->server->pathlen] == '\0'))
-      r->filename = ap_pstrcat (r->pool, conf->ap_document_root,
-			     (r->uri + r->server->pathlen), NULL);
-    else
-      r->filename = ap_pstrcat (r->pool, conf->ap_document_root, r->uri, NULL);
+    if (r->server->path 
+	&& !strncmp(r->uri, r->server->path, r->server->pathlen)
+	&& (r->server->path[r->server->pathlen - 1] == '/'
+	    || r->uri[r->server->pathlen] == '/'
+	    || r->uri[r->server->pathlen] == '\0')) {
+        r->filename = ap_pstrcat(r->pool, conf->ap_document_root,
+				 (r->uri + r->server->pathlen), NULL);
+    }
+    else {
+        r->filename = ap_pstrcat(r->pool, conf->ap_document_root, r->uri,
+				 NULL);
+    }
 
     return OK;
 }
 
-static int do_nothing (request_rec *r) { return OK; }
+static int do_nothing(request_rec *r) { return OK; }
 
 #ifdef USE_MMAP_FILES
 struct mmap {
     void *mm;
     size_t length;
 };
 
-static void mmap_cleanup (void *mmv)
+static void mmap_cleanup(void *mmv)
 {
     struct mmap *mmd = mmv;
 
     munmap(mmd->mm, mmd->length);
 }
 #endif
@@ -2086,97 +2542,101 @@
  * and OPTIONS at this point... anyone who wants to write a generic
  * handler for PUT or POST is free to do so, but it seems unwise to provide
  * any defaults yet... So, for now, we assume that this will always be
  * the last handler called and return 405 or 501.
  */
 
-static int default_handler (request_rec *r)
+static int default_handler(request_rec *r)
 {
     core_dir_config *d =
       (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
     int rangestatus, errstatus;
     FILE *f;
 #ifdef USE_MMAP_FILES
     caddr_t mm;
 #endif
 
-    if (r->handler) {
-	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
-	    r->server, "handler \"%s\" not found, using default "
-	    "handler for: %s", r->handler, r->filename);
-    }
-
     /* This handler has no use for a request body (yet), but we still
      * need to read and discard it if the client sent one.
      */
-    if ((errstatus = ap_discard_request_body(r)) != OK)
+    if ((errstatus = ap_discard_request_body(r)) != OK) {
         return errstatus;
+    }
 
     r->allowed |= (1 << M_GET) | (1 << M_OPTIONS);
 
     if (r->method_number == M_INVALID) {
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
 		    "Invalid method in request %s", r->the_request);
 	return NOT_IMPLEMENTED;
     }
-    if (r->method_number == M_OPTIONS) return ap_send_http_options(r);
-    if (r->method_number == M_PUT) return METHOD_NOT_ALLOWED;
+    if (r->method_number == M_OPTIONS) {
+        return ap_send_http_options(r);
+    }
+    if (r->method_number == M_PUT) {
+        return METHOD_NOT_ALLOWED;
+    }
 
     if (r->finfo.st_mode == 0 || (r->path_info && *r->path_info)) {
 	ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r->server, 
-                    "File does not exist: %s", r->path_info ? 
-                    ap_pstrcat(r->pool, r->filename, r->path_info, NULL)
-		    : r->filename);
+                    "File does not exist: %s", 
+		     r->path_info 
+		         ? ap_pstrcat(r->pool, r->filename, r->path_info, NULL)
+		         : r->filename);
 	return NOT_FOUND;
     }
-    if (r->method_number != M_GET) return METHOD_NOT_ALLOWED;
+    if (r->method_number != M_GET) {
+        return METHOD_NOT_ALLOWED;
+    }
 	
 #if defined(__EMX__) || defined(WIN32)
     /* Need binary mode for OS/2 */
-    f = ap_pfopen (r->pool, r->filename, "rb");
+    f = ap_pfopen(r->pool, r->filename, "rb");
 #else
-    f = ap_pfopen (r->pool, r->filename, "r");
+    f = ap_pfopen(r->pool, r->filename, "r");
 #endif
 
     if (f == NULL) {
         ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-		    "file permissions deny server access: %s", r->filename);
+		     "file permissions deny server access: %s", r->filename);
         return FORBIDDEN;
     }
 	
-    ap_update_mtime (r, r->finfo.st_mtime);
+    ap_update_mtime(r, r->finfo.st_mtime);
     ap_set_last_modified(r);
     ap_set_etag(r);
     ap_table_setn(r->headers_out, "Accept-Ranges", "bytes");
     if (((errstatus = ap_meets_conditions(r)) != OK)
-	|| (errstatus = ap_set_content_length (r, r->finfo.st_size))) {
-	    return errstatus;
+	|| (errstatus = ap_set_content_length(r, r->finfo.st_size))) {
+        return errstatus;
     }
 
 #ifdef USE_MMAP_FILES
     ap_block_alarms();
     if ((r->finfo.st_size >= MMAP_THRESHOLD)
-	&& ( !r->header_only || (d->content_md5 & 1))) {
+	&& (!r->header_only || (d->content_md5 & 1))) {
 	/* we need to protect ourselves in case we die while we've got the
  	 * file mmapped */
-	mm = mmap (NULL, r->finfo.st_size, PROT_READ, MAP_PRIVATE,
-		    fileno(f), 0);
+	mm = mmap(NULL, r->finfo.st_size, PROT_READ, MAP_PRIVATE,
+		  fileno(f), 0);
 	if (mm == (caddr_t)-1) {
 	    ap_log_error(APLOG_MARK, APLOG_CRIT, r->server,
-			"default_handler: mmap failed: %s", r->filename);
+			 "default_handler: mmap failed: %s", r->filename);
 	}
-    } else {
+    }
+    else {
 	mm = (caddr_t)-1;
     }
 
     if (mm == (caddr_t)-1) {
 	ap_unblock_alarms();
 #endif
 
 	if (d->content_md5 & 1) {
-	    ap_table_setn(r->headers_out, "Content-MD5", ap_md5digest(r->pool, f));
+	    ap_table_setn(r->headers_out, "Content-MD5",
+			  ap_md5digest(r->pool, f));
 	}
 
 	rangestatus = ap_set_byterange(r);
 #ifdef CHARSET_EBCDIC
 	/* To make serving of "raw ASCII text" files easy (they serve faster 
 	 * since they don't have to be converted from EBCDIC), a new
@@ -2185,51 +2645,54 @@
 	 * the type to the real text/{plain,html,...} type. Otherwise, we
 	 * set a flag that translation is required later on.
 	 */
         ap_checkconv(r);
 #endif /*CHARSET_EBCDIC*/
 
-	ap_send_http_header (r);
+	ap_send_http_header(r);
 	
 	if (!r->header_only) {
-	    if (!rangestatus)
-		ap_send_fd (f, r);
+	    if (!rangestatus) {
+		ap_send_fd(f, r);
+	    }
 	    else {
 		long offset, length;
 		while (ap_each_byterange(r, &offset, &length)) {
 		    fseek(f, offset, SEEK_SET);
 		    ap_send_fd_length(f, r, length);
 		}
 	    }
 	}
 
 #ifdef USE_MMAP_FILES
-    } else {
+    }
+    else {
 	struct mmap *mmd;
 
-	mmd = ap_palloc (r->pool, sizeof (*mmd));
+	mmd = ap_palloc(r->pool, sizeof(*mmd));
 	mmd->mm = mm;
 	mmd->length = r->finfo.st_size;
-	ap_register_cleanup (r->pool, (void *)mmd, mmap_cleanup, mmap_cleanup);
+	ap_register_cleanup(r->pool, (void *)mmd, mmap_cleanup, mmap_cleanup);
 	ap_unblock_alarms();
 
 	if (d->content_md5 & 1) {
 	    AP_MD5_CTX context;
 	    
 	    ap_MD5Init(&context);
 	    ap_MD5Update(&context, (void *)mm, r->finfo.st_size);
 	    ap_table_setn(r->headers_out, "Content-MD5",
-		ap_md5contextTo64(r->pool, &context));
+			  ap_md5contextTo64(r->pool, &context));
 	}
 
 	rangestatus = ap_set_byterange(r);
-	ap_send_http_header (r);
+	ap_send_http_header(r);
 	
 	if (!r->header_only) {
-	    if (!rangestatus)
-		ap_send_mmap (mm, r, 0, r->finfo.st_size);
+	    if (!rangestatus) {
+		ap_send_mmap(mm, r, 0, r->finfo.st_size);
+	    }
 	    else {
 		long offset, length;
 		while (ap_each_byterange(r, &offset, &length)) {
 		    ap_send_mmap(mm, r, offset, length);
 		}
 	    }
@@ -2244,26 +2707,26 @@
 static const handler_rec core_handlers[] = {
 { "*/*", default_handler },
 { NULL }
 };
 
 API_VAR_EXPORT module core_module = {
-   STANDARD_MODULE_STUFF,
-   NULL,			/* initializer */
-   create_core_dir_config,	/* create per-directory config structure */
-   merge_core_dir_configs,	/* merge per-directory config structures */
-   create_core_server_config,	/* create per-server config structure */
-   merge_core_server_configs,	/* merge per-server config structures */
-   core_cmds,			/* command table */
-   core_handlers,		/* handlers */
-   core_translate,		/* translate_handler */
-   NULL,			/* check_user_id */
-   NULL,			/* check auth */
-   do_nothing,			/* check access */
-   do_nothing,			/* type_checker */
-   NULL,			/* pre-run fixups */
-   NULL,			/* logger */
-   NULL,			/* header parser */
-   NULL,			/* child_init */
-   NULL,			/* child_exit */
-   NULL				/* post_read_request */
+    STANDARD_MODULE_STUFF,
+    NULL,			/* initializer */
+    create_core_dir_config,	/* create per-directory config structure */
+    merge_core_dir_configs,	/* merge per-directory config structures */
+    create_core_server_config,	/* create per-server config structure */
+    merge_core_server_configs,	/* merge per-server config structures */
+    core_cmds,			/* command table */
+    core_handlers,		/* handlers */
+    core_translate,		/* translate_handler */
+    NULL,			/* check_user_id */
+    NULL,			/* check auth */
+    do_nothing,			/* check access */
+    do_nothing,			/* type_checker */
+    NULL,			/* pre-run fixups */
+    NULL,			/* logger */
+    NULL,			/* header parser */
+    NULL,			/* child_init */
+    NULL,			/* child_exit */
+    NULL			/* post_read_request */
 };
Only in apache_1.3.0/src/main: http_core.o
diff -BEr -U 6 apache_1.3.0/src/main/http_log.c apache_1.3.1/src/main/http_log.c
--- apache_1.3.0/src/main/http_log.c	1998-05-29 08:09:22.000000000 +0800
+++ apache_1.3.1/src/main/http_log.c	1998-06-05 04:13:19.000000000 +0800
@@ -476,13 +476,13 @@
 }
 
 /* piped log support */
 
 #ifndef NO_RELIABLE_PIPED_LOGS
 /* forward declaration */
-static void piped_log_maintenance (int reason, void *data, int status);
+static void piped_log_maintenance (int reason, void *data, ap_wait_t status);
 
 static int piped_log_spawn (piped_log *pl)
 {
     int pid;
 
     ap_block_alarms();
@@ -516,13 +516,13 @@
     pl->pid = pid;
     ap_register_other_child (pid, piped_log_maintenance, pl, pl->fds[1]);
     return 0;
 }
 
 
-static void piped_log_maintenance (int reason, void *data, int status)
+static void piped_log_maintenance (int reason, void *data, ap_wait_t status)
 {
     piped_log *pl = data;
 
     switch (reason) {
     case OC_REASON_DEATH:
     case OC_REASON_LOST:
Only in apache_1.3.0/src/main: http_log.o
diff -BEr -U 6 apache_1.3.0/src/main/http_main.c apache_1.3.1/src/main/http_main.c
--- apache_1.3.0/src/main/http_main.c	1998-05-29 16:18:49.000000000 +0800
+++ apache_1.3.1/src/main/http_main.c	1998-07-14 17:57:56.000000000 +0800
@@ -277,12 +277,13 @@
 API_VAR_EXPORT char ap_server_root[MAX_STRING_LEN];
 char ap_server_confname[MAX_STRING_LEN];
 char ap_coredump_dir[MAX_STRING_LEN];
 
 array_header *ap_server_pre_read_config;
 array_header *ap_server_post_read_config;
+array_header *ap_server_config_defines;
 
 /* *Non*-shared http_main globals... */
 
 static server_rec *server_conf;
 static JMP_BUF APACHE_TLS jmpbuffer;
 static int sd;
@@ -315,13 +316,13 @@
 #ifndef NO_OTHER_CHILD
 /* used to maintain list of children which aren't part of the scoreboard */
 typedef struct other_child_rec other_child_rec;
 struct other_child_rec {
     other_child_rec *next;
     int pid;
-    void (*maintenance) (int, void *, int);
+    void (*maintenance) (int, void *, ap_wait_t);
     void *data;
     int write_fd;
 };
 static other_child_rec *other_children;
 #endif
 
@@ -874,26 +875,28 @@
 #ifdef SHARED_CORE
     fprintf(stderr, "Usage: %s [-L directory] [-d directory] [-f file]\n", bin);
 #else
     fprintf(stderr, "Usage: %s [-d directory] [-f file]\n", bin);
 #endif
     fprintf(stderr, "       %s [-C \"directive\"] [-c \"directive\"]\n", pad);
-    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-S]\n", pad);
+    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-S] [-t]\n", pad);
     fprintf(stderr, "Options:\n");
 #ifdef SHARED_CORE
     fprintf(stderr, "  -L directory     : specify an alternate location for shared object files\n");
 #endif
+    fprintf(stderr, "  -D name          : define a name for use in <IfDefine name> directives\n");
     fprintf(stderr, "  -d directory     : specify an alternate initial ServerRoot\n");
     fprintf(stderr, "  -f file          : specify an alternate ServerConfigFile\n");
     fprintf(stderr, "  -C \"directive\"   : process directive before reading config files\n");
     fprintf(stderr, "  -c \"directive\"   : process directive after  reading config files\n");
     fprintf(stderr, "  -v               : show version number\n");
     fprintf(stderr, "  -V               : show compile settings\n");
     fprintf(stderr, "  -h               : list available configuration directives\n");
     fprintf(stderr, "  -l               : list compiled-in modules\n");
     fprintf(stderr, "  -S               : show parsed settings (currently only vhost settings)\n");
+    fprintf(stderr, "  -t               : run syntax test for configuration files only\n");
     exit(1);
 }
 
 /*****************************************************************
  *
  * Timeout handling.  DISTINCTLY not thread-safe, but all this stuff
@@ -948,34 +951,41 @@
     if (timeout_req) {
 	/* Someone has asked for this transaction to just be aborted
 	 * if it times out...
 	 */
 
 	request_rec *log_req = timeout_req;
+	request_rec *save_req = timeout_req;
+
+	/* avoid looping... if ap_log_transaction started another
+	 * timer (say via rfc1413.c) we could loop...
+	 */
+	timeout_req = NULL;
 
 	while (log_req->main || log_req->prev) {
 	    /* Get back to original request... */
 	    if (log_req->main)
 		log_req = log_req->main;
 	    else
 		log_req = log_req->prev;
 	}
 
 	if (!current_conn->keptalive)
 	    ap_log_transaction(log_req);
 
-	ap_bsetflag(timeout_req->connection->client, B_EOUT, 1);
-	ap_bclose(timeout_req->connection->client);
+	ap_bsetflag(save_req->connection->client, B_EOUT, 1);
+	ap_bclose(save_req->connection->client);
 
 	if (!ap_standalone)
 	    exit(0);
 
 	ap_longjmp(jmpbuffer, 1);
     }
     else {			/* abort the connection */
 	ap_bsetflag(current_conn->client, B_EOUT, 1);
+	ap_bclose(current_conn->client);
 	current_conn->aborted = 1;
     }
 }
 
 /*
  * These two called from alloc.c to protect its critical sections...
@@ -1040,15 +1050,17 @@
     }
     else {
 	alarm_fn = fn;
 	alarm_expiry_time = time(NULL) + x;
     }
 #else
-    if (x) {
-	alarm_fn = fn;
+    if (alarm_fn && x && fn != alarm_fn) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, NULL,
+	    "ap_set_callback_and_alarm: possible nested timer!");
     }
+    alarm_fn = fn;
 #ifndef OPTIMIZE_TIMEOUTS
     old = alarm(x);
 #else
     if (child_timeouts) {
 	old = alarm(x);
     }
@@ -1162,13 +1174,13 @@
  * block the server process on close() when SO_LINGER is used.
  * For those that don't, see USE_SO_LINGER below.  For the rest,
  * we have created a home-brew lingering_close.
  *
  * Many operating systems tend to block, puke, or otherwise mishandle
  * calls to shutdown only half of the connection.  You should define
- * NO_LINGCLOSE in conf.h if such is the case for your system.
+ * NO_LINGCLOSE in ap_config.h if such is the case for your system.
  */
 #ifndef MAX_SECS_TO_LINGER
 #define MAX_SECS_TO_LINGER 30
 #endif
 
 #ifdef USE_SO_LINGER
@@ -1295,13 +1307,13 @@
 /*****************************************************************
  * dealing with other children
  */
 
 #ifndef NO_OTHER_CHILD
 API_EXPORT(void) ap_register_other_child(int pid,
-		       void (*maintenance) (int reason, void *, int status),
+		       void (*maintenance) (int reason, void *, ap_wait_t status),
 			  void *data, int write_fd)
 {
     other_child_rec *ocr;
 
     ocr = ap_palloc(pconf, sizeof(*ocr));
     ocr->pid = pid;
@@ -1381,13 +1393,13 @@
 	    continue;
 	(*ocr->maintenance) (OC_REASON_UNWRITABLE, ocr->data, -1);
     }
 }
 
 /* possibly reap an other_child, return 0 if yes, -1 if not */
-static int reap_other_child(int pid, int status)
+static int reap_other_child(int pid, ap_wait_t status)
 {
     other_child_rec *ocr, *nocr;
 
     for (ocr = other_children; ocr; ocr = nocr) {
 	nocr = ocr->next;
 	if (ocr->pid != pid)
@@ -1539,13 +1551,13 @@
  * does NOT support BSD style anonymous mapping. So, the order of 
  * conditional compilation is important: 
  * this #ifdef section must be ABOVE the next one (BSD style).
  *
  * I tested this stuff and it works fine for me, but if it provides 
  * trouble for you, just comment out USE_MMAP_SCOREBOARD in QNX section
- * of conf.h
+ * of ap_config.h
  *
  * June 5, 1997, 
  * Igor N. Kovalenko -- infoh@mail.wplus.net
  */
 
 static void cleanup_shared_mem(void *d)
@@ -1588,13 +1600,13 @@
 #elif defined(USE_MMAP_SCOREBOARD)
 
 static void setup_shared_mem(pool *p)
 {
     caddr_t m;
 
-#if defined(MAP_ANON) || defined(MAP_FILE)
+#if defined(MAP_ANON)
 /* BSD style */
 #ifdef CONVEXOS11
     /*
      * 9-Aug-97 - Jeff Venters (venters@convex.hp.com)
      * ConvexOS maps address space as follows:
      *   0x00000000 - 0x7fffffff : Kernel
@@ -2126,35 +2138,32 @@
 	}
     }
 #endif /* ndef MULTITHREAD */
 }
 
 
-#if defined(BROKEN_WAIT) || defined(NEED_WAITPID)
+#if defined(NEED_WAITPID)
 /*
-   Some systems appear to fail to deliver dead children to wait() at times.
-   This sorts them out. In fact, this may have been caused by a race condition
-   in wait_or_timeout(). But this routine is still useful for systems with no
-   waitpid().
+   Systems without a real waitpid sometimes lose a child's exit while waiting
+   for another.  Search through the scoreboard for missing children.
  */
-int reap_children(void)
+int reap_children(ap_wait_t *status)
 {
-    int status, n;
-    int ret = 0;
+    int n, pid;
 
     for (n = 0; n < max_daemons_limit; ++n) {
-	if (ap_scoreboard_image->servers[n].status != SERVER_DEAD
-	    && waitpid(ap_scoreboard_image->parent[n].pid, &status, WNOHANG)
-	    == -1
-	    && errno == ECHILD) {
-	    ap_sync_scoreboard_image();
+        ap_sync_scoreboard_image();
+	if (ap_scoreboard_image->servers[n].status != SERVER_DEAD &&
+		kill((pid = ap_scoreboard_image->parent[n].pid), 0) == -1) {
 	    ap_update_child_status(n, SERVER_DEAD, NULL);
-	    ret = 1;
+	    /* just mark it as having a successful exit status */
+	    bzero((char *) status, sizeof(ap_wait_t));
+	    return(pid);
 	}
     }
-    return ret;
+    return 0;
 }
 #endif
 
 /* Finally, this routine is used by the caretaker process to wait for
  * a while...
  */
@@ -2162,13 +2171,13 @@
 /* number of calls to wait_or_timeout between writable probes */
 #ifndef INTERVAL_OF_WRITABLE_PROBES
 #define INTERVAL_OF_WRITABLE_PROBES 10
 #endif
 static int wait_or_timeout_counter;
 
-static int wait_or_timeout(int *status)
+static int wait_or_timeout(ap_wait_t *status)
 {
 #ifdef WIN32
 #define MAXWAITOBJ MAXIMUM_WAIT_OBJECTS
     HANDLE h[MAXWAITOBJ];
     int e[MAXWAITOBJ];
     int round, pi, hi, rv, err;
@@ -2211,12 +2220,17 @@
     if (ret == -1 && errno == EINTR) {
 	return -1;
     }
     if (ret > 0) {
 	return ret;
     }
+#ifdef NEED_WAITPID
+    if ((ret = reap_children(status)) > 0) {
+	return ret;
+    }
+#endif
     tv.tv_sec = SCOREBOARD_MAINTENANCE_INTERVAL / 1000000;
     tv.tv_usec = SCOREBOARD_MAINTENANCE_INTERVAL % 1000000;
     ap_select(0, NULL, NULL, NULL, &tv);
     return -1;
 #endif /* WIN32 */
 }
@@ -2539,12 +2553,16 @@
 	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABORT)");
 #endif
 #ifdef SIGABRT
 	if (sigaction(SIGABRT, &sa, NULL) < 0)
 	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABRT)");
 #endif
+#ifdef SIGILL
+	if (sigaction(SIGILL, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGILL)");
+#endif
 	sa.sa_flags = 0;
     }
     sa.sa_handler = sig_term;
     if (sigaction(SIGTERM, &sa, NULL) < 0)
 	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGTERM)");
 #ifdef SIGINT
@@ -2579,12 +2597,15 @@
 #ifdef SIGABORT
 	signal(SIGABORT, sig_coredump);
 #endif /* SIGABORT */
 #ifdef SIGABRT
 	signal(SIGABRT, sig_coredump);
 #endif /* SIGABRT */
+#ifdef SIGILL
+	signal(SIGILL, sig_coredump);
+#endif /* SIGILL */
 #ifdef SIGXCPU
 	signal(SIGXCPU, SIG_DFL);
 #endif /* SIGXCPU */
 #ifdef SIGXFSZ
 	signal(SIGXFSZ, SIG_DFL);
 #endif /* SIGXFSZ */
@@ -2739,13 +2760,12 @@
 
     if ((stat(SUEXEC_BIN, &wrapper)) != 0)
 	return (ap_suexec_enabled);
 
     if ((wrapper.st_mode & S_ISUID) && wrapper.st_uid == 0) {
 	ap_suexec_enabled = 1;
-	fprintf(stderr, "Configuring Apache for use with suexec wrapper.\n");
     }
 #endif /* ndef WIN32 */
     return (ap_suexec_enabled);
 }
 
 /*****************************************************************
@@ -2838,12 +2858,17 @@
 
     /* PR#1282 Unixware 1.x appears to have the same problem as solaris */
 #if defined (UW) && UW < 200
 #define WORKAROUND_SOLARIS_BUG
 #endif
 
+    /* PR#1973 NCR SVR4 systems appear to have the same problem */
+#if defined (MPRAS)
+#define WORKAROUND_SOLARIS_BUG
+#endif
+
 #ifndef WORKAROUND_SOLARIS_BUG
     s = ap_slack(s, AP_SLACK_HIGH);
 
     ap_note_cleanups_for_socket(p, s);	/* arrange to close on exec or restart */
 #endif
 
@@ -3232,22 +3257,12 @@
 {
     INIT_SIGLIST()
 #ifdef AUX3
     (void) set42sig();
 #endif
 
-#ifdef SecureWare
-    if (set_auth_parameters(argc, argv) < 0)
-	perror("set_auth_parameters");
-    if (getluid() < 0)
-	if (setluid(getuid()) < 0)
-	    perror("setluid");
-    if (setreuid(0, 0) < 0)
-	perror("setreuid");
-#endif
-
 #ifdef WIN32
     /* Initialize the stupid sockets */
     AMCSocketInitialize();
 #endif /* WIN32 */
 
     pconf = ap_init_alloc();
@@ -3256,12 +3271,13 @@
     ap_util_init();
     ap_util_uri_init();
 
     pcommands = ap_make_sub_pool(NULL);
     ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
     ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
+    ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));
 }
 
 #ifndef MULTITHREAD
 /*****************************************************************
  * Child process main loop.
  * The following vars are static to avoid getting clobbered by longjmp();
@@ -3381,13 +3397,12 @@
 
 	/*
 	 * (Re)initialize this child to a pre-connection state.
 	 */
 
 	ap_kill_timeout(0);	/* Cancel any outstanding alarms. */
-	timeout_req = NULL;	/* No request in progress */
 	current_conn = NULL;
 
 	ap_clear_pool(ptrans);
 
 	ap_sync_scoreboard_image();
 	if (ap_scoreboard_image->global.exit_generation >= generation) {
@@ -3716,13 +3731,13 @@
 	sleep(10);
 
 	return -1;
     }
 
     if (!pid) {
-#if defined(AIX) && (AIX >= 41)
+#ifdef AIX_BIND_PROCESSOR
 /* by default AIX binds to a single processor
  * this bit unbinds children which will then bind to another cpu
  */
 #include <sys/processor.h>
 	int status = bindprocessor(BINDPROCESS, (int)getpid(), 
 				   PROCESSOR_CLASS_ANY);
@@ -3911,13 +3926,13 @@
     else {
 	idle_spawn_rate = 1;
     }
 }
 
 
-static void process_child_status(int pid, int status)
+static void process_child_status(int pid, ap_wait_t status)
 {
     /* Child died... if it died due to a fatal error,
 	* we should simply bail out.
 	*/
     if ((WIFEXITED(status)) &&
 	WEXITSTATUS(status) == APEXIT_CHILDFATAL) {
@@ -4056,17 +4071,21 @@
 
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
 		    "%s configured -- resuming normal operations",
 		    ap_get_server_version());
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
 		    "Server built: %s", ap_get_server_built());
+	if (ap_suexec_enabled) {
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+		         "suEXEC mechanism enabled (wrapper: %s)", SUEXEC_BIN);
+	}
 	restart_pending = shutdown_pending = 0;
 
 	while (!restart_pending && !shutdown_pending) {
 	    int child_slot;
-	    int status;
+	    ap_wait_t status;
 	    int pid = wait_or_timeout(&status);
 
 	    /* XXX: if it takes longer than 1 second for all our children
 	     * to start up and get into IDLE state then we may spawn an
 	     * extra child
 	     */
@@ -4201,12 +4220,23 @@
 extern char *optarg;
 extern int optind;
 
 int REALMAIN(int argc, char *argv[])
 {
     int c;
+    int configtestonly = 0;
+
+#ifdef SecureWare
+    if (set_auth_parameters(argc, argv) < 0)
+	perror("set_auth_parameters");
+    if (getluid() < 0)
+	if (setluid(getuid()) < 0)
+	    perror("setluid");
+    if (setreuid(0, 0) < 0)
+	perror("setreuid");
+#endif
 
 #ifdef SOCKS
     SOCKSinit(argv[0]);
 #endif
 
     MONCONTROL(0);
@@ -4217,13 +4247,13 @@
     ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));
     ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));
 
     ap_setup_prelinked_modules();
 
     while ((c = getopt(argc, argv,
-				    "C:c:Xd:f:vVhlL:S"
+				    "D:C:c:Xd:f:vVhlL:St"
 #ifdef DEBUG_SIGSTOP
 				    "Z:"
 #endif
 			)) != -1) {
 	char **new;
 	switch (c) {
@@ -4232,12 +4262,16 @@
 	    *new = ap_pstrdup(pcommands, optarg);
 	    break;
 	case 'C':
 	    new = (char **)ap_push_array(ap_server_pre_read_config);
 	    *new = ap_pstrdup(pcommands, optarg);
 	    break;
+	case 'D':
+	    new = (char **)ap_push_array(ap_server_config_defines);
+	    *new = ap_pstrdup(pcommands, optarg);
+	    break;
 	case 'd':
 	    ap_cpystrn(ap_server_root, optarg, sizeof(ap_server_root));
 	    break;
 	case 'f':
 	    ap_cpystrn(ap_server_confname, optarg, sizeof(ap_server_confname));
 	    break;
@@ -4273,20 +4307,28 @@
 	     */
 	    break;
 #endif
 	case 'S':
 	    ap_dump_settings = 1;
 	    break;
+	case 't':
+	    configtestonly = 1;
+	    break;
 	case '?':
 	    usage(argv[0]);
 	}
     }
 
     ap_suexec_enabled = init_suexec();
     server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
 
+    if (configtestonly) {
+        fprintf(stderr, "Syntax OK\n");
+        exit(0);
+    }
+
     child_timeouts = !ap_standalone || one_process;
 
     if (ap_standalone) {
 	ap_open_logs(server_conf, pconf);
 	ap_set_version();
 	ap_init_modules(pconf, server_conf);
@@ -4474,13 +4516,13 @@
     joblist *jobtail;
     mutex *jobmutex;
     int jobcount;
 } globals;
 
 globals allowed_globals =
-{0, NULL, NULL, NULL, 0};
+{0, NULL, NULL, NULL, NULL, 0};
 
 /*
  * add_job()/remove_job() - add or remove an accepted socket from the
  * list of sockets connected to clients. allowed_globals.jobmutex protects
  * against multiple concurrent access to the linked list of jobs.
  */
@@ -5030,13 +5072,13 @@
     ap_child_exit_modules(pconf, server_conf);
     ap_destroy_pool(pchild);
 
     cleanup_scoreboard();
 
     APD2("process PID %d exited", my_pid);
-    exit(0);
+    clean_parent_exit(0);
 }				/* standalone_main */
 
 /* Spawn a child Apache process. The child process has the command
  * line arguments from argc and argv[], plus a -Z argument giving the
  * name of an event. The child should open and poll or wait on this
  * event. When it is signalled, the child should die.  prefix is a
@@ -5346,12 +5388,13 @@
 {
     int c;
     int child = 0;
     char *cp;
     int run_as_service = 1;
     int install = 0;
+    int configtestonly = 0;
     
     common_init();
 
     ap_server_argv0 = argv[0];
 
     /* Get the serverroot from the registry, if it exists. This can be
@@ -5370,23 +5413,27 @@
 	ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));
     }
     ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));
 
     ap_setup_prelinked_modules();
 
-    while ((c = getopt(argc, argv, "C:c:Xd:f:vVhlZ:iusS")) != -1) {
+    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVhlZ:iusSt")) != -1) {
         char **new;
 	switch (c) {
 	case 'c':
 	    new = (char **)ap_push_array(ap_server_post_read_config);
 	    *new = ap_pstrdup(pcommands, optarg);
 	    break;
 	case 'C':
 	    new = (char **)ap_push_array(ap_server_pre_read_config);
 	    *new = ap_pstrdup(pcommands, optarg);
 	    break;
+	case 'D':
+	    new = (char **)ap_push_array(ap_server_config_defines);
+	    *new = ap_pstrdup(pcommands, optarg);
+	    break;
 #ifdef WIN32
 	case 'Z':
 	    exit_event = open_event(optarg);
 	    APD2("child: opened process event %s", optarg);
 	    cp = strchr(optarg, '_');
 	    ap_assert(cp);
@@ -5428,22 +5475,31 @@
 	case 'l':
 	    ap_show_modules();
 	    exit(0);
 	case 'X':
 	    ++one_process;	/* Weird debugging mode. */
 	    break;
+	case 't':
+	    configtestonly = 1;
+	    break;
 	case '?':
 	    usage(argv[0]);
 	}
     }
 
     if (!child && run_as_service) {
 	service_cd();
     }
 
     server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
+
+    if (configtestonly) {
+        fprintf(stderr, "Syntax OK\n");
+        exit(0);
+    }
+
     if (!child) {
 	ap_log_pid(pconf, ap_pid_fname);
     }
     ap_set_version();
     ap_init_modules(pconf, server_conf);
     ap_suexec_enabled = init_suexec();
@@ -5478,13 +5534,14 @@
     }
     else {
 	service_main(master_main, argc, argv,
 			"Apache", install, run_as_service);
     }
 
-    return (0);
+    clean_parent_exit(0);
+    return 0;	/* purely to avoid a warning */
 }
 
 #endif /* ndef MULTITHREAD */
 
 #else  /* ndef SHARED_CORE_TIESTATIC */
 
@@ -5517,13 +5574,13 @@
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
-#include "conf.h"
+#include "ap_config.h"
 #include "httpd.h"
 
 #define VARNAME "LD_LIBRARY_PATH"
 
 #ifndef SHARED_CORE_DIR 
 #define SHARED_CORE_DIR HTTPD_ROOT "/libexec"
@@ -5547,24 +5604,27 @@
 
     /* 
      * parse argument line, 
      * but only handle the -L option 
      */
     llp_dir = SHARED_CORE_DIR;
-    while ((c = getopt(argc, argv, "C:c:Xd:f:vVhlL:Z:")) != -1) {
+    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVhlL:SZ:t")) != -1) {
 	switch (c) {
+	case 'D':
 	case 'C':
 	case 'c':
 	case 'X':
 	case 'd':
 	case 'f':
 	case 'v':
 	case 'V':
 	case 'h':
 	case 'l':
+	case 'S':
 	case 'Z':
+	case 't':
 	case '?':
 	    break;
 	case 'L':
 	    llp_dir = strdup(optarg);
 	    break;
 	}
Only in apache_1.3.0/src/main: http_main.o
diff -BEr -U 6 apache_1.3.0/src/main/http_protocol.c apache_1.3.1/src/main/http_protocol.c
--- apache_1.3.0/src/main/http_protocol.c	1998-05-28 06:55:59.000000000 +0800
+++ apache_1.3.1/src/main/http_protocol.c	1998-07-09 01:47:05.000000000 +0800
@@ -113,18 +113,18 @@
     if (*start > *end)
 	return 0;
 
     return (*start > 0 || *end < clength - 1);
 }
 
-static int internal_byterange(int, long *, request_rec *, char **, long *,
+static int internal_byterange(int, long *, request_rec *, const char **, long *,
                               long *);
 
 API_EXPORT(int) ap_set_byterange(request_rec *r)
 {
-    char *range, *if_range, *match;
+    const char *range, *if_range, *match;
     long range_start, range_end;
 
     if (!r->clength || r->assbackwards)
         return 0;
 
     /* Check for Range request-header (HTTP/1.1) or Request-Range for
@@ -170,13 +170,13 @@
 		range_start, range_end, r->clength));
         ap_table_setn(r->headers_out, "Content-Length",
 	    ap_psprintf(r->pool, "%ld", range_end - range_start + 1));
     }
     else {
         /* a multiple range */
-        char *r_range = ap_pstrdup(r->pool, range + 6);
+        const char *r_range = ap_pstrdup(r->pool, range + 6);
         long tlength = 0;
 
         r->byterange = 2;
         r->boundary = ap_psprintf(r->pool, "%lx%lx",
 				r->request_time, (long) getpid());
         while (internal_byterange(0, &tlength, r, &r_range, NULL, NULL));
@@ -203,13 +203,13 @@
  * it *would* have used with realreq=1.
  *
  * Either case will return 1 if it should be called again, and 0
  * when done.
  */
 static int internal_byterange(int realreq, long *tlength, request_rec *r,
-                              char **r_range, long *offset, long *length)
+                              const char **r_range, long *offset, long *length)
 {
     long range_start, range_end;
     char *range;
 
     if (!**r_range) {
         if (r->byterange > 1) {
@@ -218,20 +218,20 @@
             else
                 *tlength += 4 + strlen(r->boundary) + 4;
         }
         return 0;
     }
 
-    range = ap_getword_nc(r->pool, r_range, ',');
+    range = ap_getword(r->pool, r_range, ',');
     if (!parse_byterange(range, r->clength, &range_start, &range_end))
         /* Skip this one */
         return internal_byterange(realreq, tlength, r, r_range, offset,
                                   length);
 
     if (r->byterange > 1) {
-        char *ct = r->content_type ? r->content_type : ap_default_type(r);
+        const char *ct = r->content_type ? r->content_type : ap_default_type(r);
         char ts[MAX_STRING_LEN];
 
         ap_snprintf(ts, sizeof(ts), "%ld-%ld/%ld", range_start, range_end,
                     r->clength);
         if (realreq)
             ap_rvputs(r, "\015\012--", r->boundary, "\015\012Content-type: ",
@@ -261,13 +261,13 @@
 
 API_EXPORT(int) ap_set_keepalive(request_rec *r)
 {
     int ka_sent = 0;
     int wimpy = ap_find_token(r->pool,
                            ap_table_get(r->headers_out, "Connection"), "close");
-    char *conn = ap_table_get(r->headers_in, "Connection");
+    const char *conn = ap_table_get(r->headers_in, "Connection");
 
     /* The following convoluted conditional determines whether or not
      * the current connection should remain persistent after this response
      * (a.k.a. HTTP Keep-Alive) and whether or not the output message
      * body should use the HTTP/1.1 chunked transfer-coding.  In English,
      *
@@ -372,14 +372,14 @@
     now = (mtime < r->request_time) ? r->request_time : time(NULL);
     return (mtime > now) ? now : mtime;
 }
 
 API_EXPORT(int) ap_meets_conditions(request_rec *r)
 {
-    char *etag = ap_table_get(r->headers_out, "ETag");
-    char *if_match, *if_modified_since, *if_unmodified, *if_nonematch;
+    const char *etag = ap_table_get(r->headers_out, "ETag");
+    const char *if_match, *if_modified_since, *if_unmodified, *if_nonematch;
     time_t mtime;
 
     /* Check for conditional requests --- note that we only want to do
      * this if we are successful so far and we are not processing a
      * subrequest or an ErrorDocument.
      *
@@ -644,13 +644,13 @@
      * for the final buffer flush from us, and we will block in the implicit
      * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
      * have to block during a read.
      */
     ap_bsetflag(conn->client, B_SAFEREAD, 1);
     while ((len = getline(l, HUGE_STRING_LEN, conn->client, 0)) <= 0) {
-        if ((len < 0) || bgetflag(conn->client, B_EOF)) {
+        if ((len < 0) || ap_bgetflag(conn->client, B_EOF)) {
             ap_bsetflag(conn->client, B_SAFEREAD, 0);
             return 0;
         }
     }
     /* we've probably got something to do, ignore graceful restart requests */
 #ifdef SIGUSR1
@@ -737,13 +737,13 @@
 
         *value = '\0';
         ++value;
 	/* XXX: RFC2068 defines only SP and HT as whitespace, this test is
 	 * wrong... and so are many others probably.
 	 */
-        while (isspace(*value))
+        while (ap_isspace(*value))
             ++value;            /* Skip to start of value   */
 
 	/* XXX: should strip trailing whitespace as well */
 
         ap_table_mergen(r->headers_in, copy, value);
 
@@ -910,18 +910,18 @@
     ap_table_setn(r->err_headers_out,
 	    r->proxyreq ? "Proxy-Authenticate" : "WWW-Authenticate",
 	    ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%lu\"",
 		ap_auth_name(r), r->request_time));
 }
 
-API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, char **pw)
+API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)
 {
     const char *auth_line = ap_table_get(r->headers_in,
                                       r->proxyreq ? "Proxy-Authorization"
                                                   : "Authorization");
-    char *t;
+    const char *t;
 
     if (!(t = ap_auth_type(r)) || strcasecmp(t, "Basic"))
         return DECLINED;
 
     if (!ap_auth_name(r)) {
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR,
@@ -944,13 +944,13 @@
 
     t = ap_uudecode(r->pool, auth_line);
     /* Note that this allocation has to be made from r->connection->pool
      * because it has the lifetime of the connection.  The other allocations
      * are temporary and can be tossed away any time.
      */
-    r->connection->user = ap_getword_nulls_nc (r->connection->pool, &t, ':');
+    r->connection->user = ap_getword_nulls (r->connection->pool, &t, ':');
     r->connection->ap_auth_type = "Basic";
 
     *pw = t;
 
     return OK;
 }
@@ -1047,13 +1047,13 @@
 }
 
 API_EXPORT(void) ap_basic_http_header(request_rec *r)
 {
     char *protocol;
 #ifdef CHARSET_EBCDIC
-    int convert = bgetflag(r->connection->client, B_EBCDIC2ASCII);
+    int convert = ap_bgetflag(r->connection->client, B_EBCDIC2ASCII);
 #endif /*CHARSET_EBCDIC*/
 
     if (r->assbackwards)
         return;
 
     if (!r->status_line)
@@ -1195,24 +1195,24 @@
  * look for the Request-Range header (e.g. Netscape 2 and 3) as an indication
  * that the browser supports an older protocol. We also check User-Agent
  * for Microsoft Internet Explorer 3, which needs this as well.
  */
 static int use_range_x(request_rec *r)
 {
-    char *ua;
+    const char *ua;
     return (ap_table_get(r->headers_in, "Request-Range") ||
             ((ua = ap_table_get(r->headers_in, "User-Agent"))
              && strstr(ua, "MSIE 3")));
 }
 
 API_EXPORT(void) ap_send_http_header(request_rec *r)
 {
     int i;
     const long int zero = 0L;
 #ifdef CHARSET_EBCDIC
-    int convert = bgetflag(r->connection->client, B_EBCDIC2ASCII);
+    int convert = ap_bgetflag(r->connection->client, B_EBCDIC2ASCII);
 #endif /*CHARSET_EBCDIC*/
 
     if (r->assbackwards) {
         if (!r->main)
             ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
         r->sent_bodyct = 1;
@@ -1221,13 +1221,13 @@
 
     /*
      * Now that we are ready to send a response, we need to combine the two
      * header field tables into a single table.  If we don't do this, our
      * later attempts to set or unset a given fieldname might be bypassed.
      */
-    if (!is_empty_table(r->err_headers_out))
+    if (!ap_is_empty_table(r->err_headers_out))
         r->headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
                                         r->headers_out);
 
     ap_hard_timeout("send headers", r);
 
     ap_basic_http_header(r);
@@ -1353,14 +1353,14 @@
  *    return 0 if EOF, or -1 if there was an error.
  *    If an error occurs on input, we force an end to keepalive.
  */
 
 API_EXPORT(int) ap_setup_client_block(request_rec *r, int read_policy)
 {
-    char *tenc = ap_table_get(r->headers_in, "Transfer-Encoding");
-    char *lenp = ap_table_get(r->headers_in, "Content-Length");
+    const char *tenc = ap_table_get(r->headers_in, "Transfer-Encoding");
+    const char *lenp = ap_table_get(r->headers_in, "Content-Length");
 
     r->read_body = read_policy;
     r->read_chunked = 0;
     r->remaining = 0;
 
     if (tenc) {
@@ -1375,15 +1375,15 @@
             return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;
         }
 
         r->read_chunked = 1;
     }
     else if (lenp) {
-        char *pos = lenp;
+        const char *pos = lenp;
 
-        while (isdigit(*pos) || isspace(*pos))
+        while (ap_isdigit(*pos) || ap_isspace(*pos))
             ++pos;
         if (*pos != '\0') {
             ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
                         "Invalid Content-Length %s", lenp);
             return HTTP_BAD_REQUEST;
         }
@@ -1718,20 +1718,36 @@
 #endif
 
     ap_soft_timeout("send body", r);
 
     FD_ZERO(&fds);
     while (!r->connection->aborted) {
+#ifdef NDELAY_PIPE_RETURNS_ZERO
+	/* Contributed by dwd@bell-labs.com for UTS 2.1.2, where the fcntl */
+	/*   O_NDELAY flag causes read to return 0 when there's nothing */
+	/*   available when reading from a pipe.  That makes it tricky */
+	/*   to detect end-of-file :-(.  This stupid bug is even documented */
+	/*   in the read(2) man page where it says that everything but */
+	/*   pipes return -1 and EAGAIN.  That makes it a feature, right? */
+	int afterselect = 0;
+#endif
         if ((length > 0) && (total_bytes_sent + IOBUFSIZE) > length)
             len = length - total_bytes_sent;
         else
             len = IOBUFSIZE;
 
         do {
             n = ap_bread(fb, buf, len);
-            if (n >= 0 || r->connection->aborted)
+#ifdef NDELAY_PIPE_RETURNS_ZERO
+	    if ((n > 0) || (n == 0 && afterselect))
+		break;
+#else
+            if (n >= 0)
+                break;
+#endif
+            if (r->connection->aborted)
                 break;
             if (n < 0 && errno != EAGAIN)
                 break;
             /* we need to block, so flush the output first */
             ap_bflush(r->connection->client);
             if (r->connection->aborted)
@@ -1739,12 +1755,15 @@
             FD_SET(fd, &fds);
             /*
              * we don't care what select says, we might as well loop back
              * around and try another read
              */
             ap_select(fd + 1, &fds, NULL, NULL, NULL);
+#ifdef NDELAY_PIPE_RETURNS_ZERO
+	    afterselect = 1;
+#endif
         } while (!r->connection->aborted);
 
         if (n < 1 || r->connection->aborted) {
             break;
         }
 
@@ -1938,20 +1957,20 @@
 void ap_send_error_response(request_rec *r, int recursive_error)
 {
     BUFF *fd = r->connection->client;
     int status = r->status;
     int idx = ap_index_of_response(status);
     char *custom_response;
-    char *location = ap_table_get(r->headers_out, "Location");
+    const char *location = ap_table_get(r->headers_out, "Location");
 
     /* We need to special-case the handling of 204 and 304 responses,
      * since they have specific HTTP requirements and do not include a
      * message body.  Note that being assbackwards here is not an option.
      */
     if (status == HTTP_NOT_MODIFIED) {
-        if (!is_empty_table(r->err_headers_out))
+        if (!ap_is_empty_table(r->err_headers_out))
             r->headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
                                                r->headers_out);
         ap_hard_timeout("send 304", r);
 
         ap_basic_http_header(r);
         ap_set_keepalive(r);
@@ -2042,24 +2061,24 @@
         while (r->prev && (r->prev->status != HTTP_OK))
             r = r->prev;
     }
     {
         char *title = status_lines[idx];
         char *h1;
-        char *error_notes;
+        const char *error_notes;
 
         /* Accept a status_line set by a module, but only if it begins
          * with the 3 digit status code
          */
         if (r->status_line != NULL
             && strlen(r->status_line) > 4       /* long enough */
-            && isdigit(r->status_line[0])
-            && isdigit(r->status_line[1])
-            && isdigit(r->status_line[2])
-            && isspace(r->status_line[3])
-            && isalnum(r->status_line[4])) {
+            && ap_isdigit(r->status_line[0])
+            && ap_isdigit(r->status_line[1])
+            && ap_isdigit(r->status_line[2])
+            && ap_isspace(r->status_line[3])
+            && ap_isalnum(r->status_line[4])) {
             title = r->status_line;
         }
 
         /* folks decided they didn't want the error code in the H1 text */
         h1 = &title[4];
 
@@ -2120,13 +2139,13 @@
                  "An appropriate representation of the requested resource ",
                           ap_escape_html(r->pool, r->uri),
                           " could not be found on this server.<P>\n", NULL);
                 /* fall through */
             case MULTIPLE_CHOICES:
                 {
-                    char *list;
+                    const char *list;
                     if ((list = ap_table_get(r->notes, "variant-list")))
                         ap_bputs(list, fd);
                 }
                 break;
             case LENGTH_REQUIRED:
                 ap_bvputs(fd, "A request of the requested method ", r->method,
diff -BEr -U 6 apache_1.3.0/src/main/http_request.c apache_1.3.1/src/main/http_request.c
--- apache_1.3.0/src/main/http_request.c	1998-05-28 06:56:00.000000000 +0800
+++ apache_1.3.1/src/main/http_request.c	1998-07-02 05:19:54.000000000 +0800
@@ -940,13 +940,13 @@
              * status...
              */
             r->status = REDIRECT;
             ap_table_setn(r->headers_out, "Location", custom_response);
         }
         else if (custom_response[0] == '/') {
-            char *error_notes;
+            const char *error_notes;
             r->no_local_copy = 1;       /* Do NOT send USE_LOCAL_COPY for
                                          * error documents! */
             /*
              * This redirect needs to be a GET no matter what the original
              * method was.
              */
@@ -991,13 +991,13 @@
 }
 
 API_EXPORT(int) ap_some_auth_required(request_rec *r)
 {
     /* Is there a require line configured for the type of *this* req? */
 
-    array_header *reqs_arr = ap_requires(r);
+    const array_header *reqs_arr = ap_requires(r);
     require_line *reqs;
     int i;
 
     if (!reqs_arr)
         return 0;
 
@@ -1210,13 +1210,13 @@
     ap_time_process_request(r->connection->child_num, STOP_PREQUEST);
 #endif
 }
 
 static table *rename_original_env(pool *p, table *t)
 {
-    array_header *env_arr = table_elts(t);
+    array_header *env_arr = ap_table_elts(t);
     table_entry *elts = (table_entry *) env_arr->elts;
     table *new = ap_make_table(p, env_arr->nalloc);
     int i;
 
     for (i = 0; i < env_arr->nelts; ++i) {
         if (!elts[i].key)
Only in apache_1.3.0/src/main: Makefile
diff -BEr -U 6 apache_1.3.0/src/main/Makefile.tmpl apache_1.3.1/src/main/Makefile.tmpl
--- apache_1.3.0/src/main/Makefile.tmpl	1998-05-30 02:20:54.000000000 +0800
+++ apache_1.3.1/src/main/Makefile.tmpl	1998-07-13 19:32:38.000000000 +0800
@@ -55,87 +55,111 @@
 
 #Dependencies
 
 $(OBJS): Makefile
 
 # DO NOT REMOVE
-alloc.o: alloc.c $(INCDIR)/httpd.h $(INCDIR)/conf.h $(OSDIR)/os.h \
- $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/multithread.h $(INCDIR)/http_log.h
-buff.o: buff.c $(INCDIR)/httpd.h $(INCDIR)/conf.h $(OSDIR)/os.h \
- $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_main.h $(INCDIR)/http_log.h
-fnmatch.o: fnmatch.c $(INCDIR)/conf.h $(OSDIR)/os.h \
- $(INCDIR)/fnmatch.h
-gen_test_char.o: gen_test_char.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h
+alloc.o: alloc.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/multithread.h \
+ $(INCDIR)/http_log.h
+buff.o: buff.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_main.h \
+ $(INCDIR)/http_log.h
+fnmatch.o: fnmatch.c $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/fnmatch.h
+gen_test_char.o: gen_test_char.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h $(INCDIR)/alloc.h \
+ $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h
 gen_uri_delims.o: gen_uri_delims.c
-http_config.o: http_config.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_conf_globals.h $(INCDIR)/http_vhost.h \
- $(INCDIR)/explain.h
-http_core.o: http_core.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_protocol.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_conf_globals.h $(INCDIR)/http_vhost.h \
- $(INCDIR)/http_main.h $(INCDIR)/http_log.h $(INCDIR)/rfc1413.h \
- $(INCDIR)/util_md5.h $(INCDIR)/ap_md5.h $(INCDIR)/scoreboard.h \
- $(INCDIR)/fnmatch.h
-http_log.o: http_log.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_main.h
-http_main.o: http_main.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_main.h $(INCDIR)/http_log.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_protocol.h \
+http_config.o: http_config.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
  $(INCDIR)/http_request.h $(INCDIR)/http_conf_globals.h \
- $(INCDIR)/http_core.h $(INCDIR)/http_vhost.h \
- $(INCDIR)/util_script.h $(INCDIR)/scoreboard.h \
- $(INCDIR)/multithread.h $(INCDIR)/explain.h
-http_protocol.o: http_protocol.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_vhost.h $(INCDIR)/explain.h
+http_core.o: http_core.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_protocol.h \
+ $(INCDIR)/http_request.h $(INCDIR)/http_conf_globals.h \
+ $(INCDIR)/http_vhost.h $(INCDIR)/http_main.h $(INCDIR)/http_log.h \
+ $(INCDIR)/rfc1413.h $(INCDIR)/util_md5.h $(INCDIR)/ap_md5.h \
+ $(INCDIR)/scoreboard.h $(INCDIR)/fnmatch.h
+http_log.o: http_log.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h $(INCDIR)/http_main.h
+http_main.o: http_main.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_main.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_request.h \
+ $(INCDIR)/http_conf_globals.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_vhost.h $(INCDIR)/util_script.h \
+ $(INCDIR)/scoreboard.h $(INCDIR)/multithread.h $(INCDIR)/explain.h
+http_protocol.o: http_protocol.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h $(INCDIR)/alloc.h \
+ $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
+ $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
  $(INCDIR)/http_protocol.h $(INCDIR)/http_main.h \
  $(INCDIR)/http_request.h $(INCDIR)/http_vhost.h \
  $(INCDIR)/http_log.h $(INCDIR)/util_date.h \
  $(INCDIR)/http_conf_globals.h
-http_request.o: http_request.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
- $(INCDIR)/http_request.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_protocol.h $(INCDIR)/http_log.h \
- $(INCDIR)/http_main.h $(INCDIR)/scoreboard.h $(INCDIR)/fnmatch.h
-http_vhost.o: http_vhost.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+http_request.o: http_request.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h $(INCDIR)/alloc.h \
+ $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
+ $(INCDIR)/http_config.h $(INCDIR)/http_request.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_protocol.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_main.h $(INCDIR)/scoreboard.h \
+ $(INCDIR)/fnmatch.h
+http_vhost.o: http_vhost.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
  $(INCDIR)/http_conf_globals.h $(INCDIR)/http_log.h \
  $(INCDIR)/http_vhost.h $(INCDIR)/http_protocol.h
-md5c.o: md5c.c $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/ap_md5.h
-rfc1413.o: rfc1413.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_log.h $(INCDIR)/rfc1413.h \
- $(INCDIR)/http_main.h
-util.o: util.c $(INCDIR)/httpd.h $(INCDIR)/conf.h $(OSDIR)/os.h \
- $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_conf_globals.h \
+md5c.o: md5c.c $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/ap_md5.h
+rfc1413.o: rfc1413.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_log.h \
+ $(INCDIR)/rfc1413.h $(INCDIR)/http_main.h
+util.o: util.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_conf_globals.h \
  $(INCDIR)/http_log.h test_char.h
-util_date.o: util_date.c $(INCDIR)/conf.h $(OSDIR)/os.h \
- $(INCDIR)/util_date.h
-util_md5.o: util_md5.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/util_md5.h $(INCDIR)/ap_md5.h
-util_script.o: util_script.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+util_date.o: util_date.c $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/util_date.h
+util_md5.o: util_md5.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/util_md5.h \
+ $(INCDIR)/ap_md5.h
+util_script.o: util_script.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
  $(INCDIR)/http_conf_globals.h $(INCDIR)/http_main.h \
  $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h \
  $(INCDIR)/http_core.h $(INCDIR)/http_request.h \
  $(INCDIR)/util_script.h $(INCDIR)/util_date.h
-util_uri.o: util_uri.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
- $(INCDIR)/util_uri.h $(INCDIR)/http_log.h \
+util_uri.o: util_uri.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
+ $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_log.h \
  $(INCDIR)/http_conf_globals.h uri_delims.h
diff -BEr -U 6 apache_1.3.0/src/main/md5c.c apache_1.3.1/src/main/md5c.c
--- apache_1.3.0/src/main/md5c.c	1998-05-30 02:20:54.000000000 +0800
+++ apache_1.3.1/src/main/md5c.c	1998-07-13 19:32:40.000000000 +0800
@@ -87,13 +87,13 @@
  * project, please see <http://www.apache.org/>.
  *
  */
 
 #include <string.h>
 
-#include "conf.h"
+#include "ap_config.h"
 #include "ap_md5.h"
 #ifdef CHARSET_EBCDIC
 #include "ebcdic.h"
 #endif /*CHARSET_EBCDIC*/
 
 /* Constants for MD5Transform routine.
diff -BEr -U 6 apache_1.3.0/src/main/rfc1413.c apache_1.3.1/src/main/rfc1413.c
--- apache_1.3.0/src/main/rfc1413.c	1998-05-19 05:56:11.000000000 +0800
+++ apache_1.3.1/src/main/rfc1413.c	1998-07-13 19:32:40.000000000 +0800
@@ -65,13 +65,13 @@
  * 
  * Author: Wietse Venema, Eindhoven University of Technology,
  * The Netherlands.
  */
 
 /* Some small additions for Apache --- ditch the "sccsid" var if
- * compiling with gcc (it *has* changed), include conf.h for the
+ * compiling with gcc (it *has* changed), include ap_config.h for the
  * prototypes it defines on at least one system (SunlOSs) which has
  * them missing from the standard header files, and one minor change
  * below (extra parens around assign "if (foo = bar) ..." to shut up
  * gcc -Wall).
  */
 
@@ -226,14 +226,13 @@
      */
     if (ap_setjmp(timebuf) == 0) {
 	ap_set_callback_and_alarm(ident_timeout, ap_rfc1413_timeout);
 
 	if (get_rfc1413(sock, &conn->local_addr, &conn->remote_addr, user, srv) >= 0)
 	    result = user;
-
-	ap_set_callback_and_alarm(NULL, 0);
     }
+    ap_set_callback_and_alarm(NULL, 0);
     ap_pclosesocket(conn->pool, sock);
     conn->remote_logname = result;
 
     return conn->remote_logname;
 }
Only in apache_1.3.0/src/main: test_char.h
Only in apache_1.3.0/src/main: uri_delims.h
diff -BEr -U 6 apache_1.3.0/src/main/util.c apache_1.3.1/src/main/util.c
--- apache_1.3.0/src/main/util.c	1998-06-02 02:20:30.000000000 +0800
+++ apache_1.3.1/src/main/util.c	1998-07-13 19:32:41.000000000 +0800
@@ -69,13 +69,13 @@
  */
 
 #include "httpd.h"
 #include "http_conf_globals.h"	/* for user_id & group_id */
 #include "http_log.h"
 #if defined(SUNOS4)
-/* stdio.h has been read in conf.h already. Add missing prototypes here: */
+/* stdio.h has been read in ap_config.h already. Add missing prototypes here: */
 extern int fgetc(FILE *);
 extern char *fgets(char *s, int, FILE*);
 extern int fclose(FILE *);
 #endif
 
 /* A bunch of functions in util.c scan strings looking for certain characters.
@@ -254,13 +254,13 @@
 		int ret;
 		if ((ret = ap_strcasecmp_match(&str[x++], &exp[y])) != 1)
 		    return ret;
 	    }
 	    return -1;
 	}
-	else if ((exp[y] != '?') && (tolower(str[x]) != tolower(exp[y])))
+	else if ((exp[y] != '?') && (ap_tolower(str[x]) != ap_tolower(exp[y])))
 	    return 1;
     }
     return (str[x] != '\0');
 }
 
 API_EXPORT(int) ap_is_matchexp(const char *str)
@@ -305,13 +305,13 @@
 
     len = 0;
 
     while ((c = *src++) != '\0') {
 	if (c == '&')
 	    no = 0;
-	else if (c == '$' && isdigit(*src))
+	else if (c == '$' && ap_isdigit(*src))
 	    no = *src++ - '0';
 	else
 	    no = 10;
 
 	if (no > 9) {		/* Ordinary character. */
 	    if (c == '\\' && (*src == '$' || *src == '&'))
@@ -330,13 +330,13 @@
 
     src = input;
 
     while ((c = *src++) != '\0') {
 	if (c == '&')
 	    no = 0;
-	else if (c == '$' && isdigit(*src))
+	else if (c == '$' && ap_isdigit(*src))
 	    no = *src++ - '0';
 	else
 	    no = 10;
 
 	if (no > 9) {		/* Ordinary character. */
 	    if (c == '\\' && (*src == '$' || *src == '&'))
@@ -579,13 +579,13 @@
 API_EXPORT(char *) ap_getword_white(pool *atrans, const char **line)
 {
     int pos = -1, x;
     char *res;
 
     for (x = 0; (*line)[x]; x++) {
-	if (isspace((*line)[x])) {
+	if (ap_isspace((*line)[x])) {
 	    pos = x;
 	    break;
 	}
     }
 
     if (pos == -1) {
@@ -594,13 +594,13 @@
 	return res;
     }
 
     res = ap_palloc(atrans, pos + 1);
     ap_cpystrn(res, *line, pos + 1);
 
-    while (isspace((*line)[pos]))
+    while (ap_isspace((*line)[pos]))
 	++pos;
 
     *line += pos;
 
     return res;
 }
@@ -660,13 +660,13 @@
 API_EXPORT(char *) ap_getword_conf(pool *p, const char **line)
 {
     const char *str = *line, *strend;
     char *res;
     char quote;
 
-    while (*str && isspace(*str))
+    while (*str && ap_isspace(*str))
 	++str;
 
     if (!*str) {
 	*line = str;
 	return "";
     }
@@ -683,19 +683,19 @@
 
 	if (*strend == quote)
 	    ++strend;
     }
     else {
 	strend = str;
-	while (*strend && !isspace(*strend))
+	while (*strend && !ap_isspace(*strend))
 	    ++strend;
 
 	res = substring_conf(p, str, strend - str, 0);
     }
 
-    while (*strend && isspace(*strend))
+    while (*strend && ap_isspace(*strend))
 	++strend;
     *line = strend;
     return res;
 }
 
 API_EXPORT(int) ap_cfg_closefile(configfile_t *cfp)
@@ -864,29 +864,29 @@
 	}
 
 	/* Compress the line, reducing all blanks and tabs to one space.
 	 * Leading and trailing white space is eliminated completely
 	 */
 	src = dst = buf;
-	while (isspace(*src))
+	while (ap_isspace(*src))
 	    ++src;
 	while (*src != '\0')
 	{
 	    /* Copy words */
-	    while (!isspace(*dst = *src) && *src != '\0') {
+	    while (!ap_isspace(*dst = *src) && *src != '\0') {
 		++src;
 		++dst;
 	    }
 	    if (*src == '\0') break;
 	    *dst++ = ' ';
-	    while (isspace(*src))
+	    while (ap_isspace(*src))
 		++src;
 	}
 	*dst = '\0';
 	/* blast trailing whitespace */
-	while (--dst >= buf && isspace(*dst))
+	while (--dst >= buf && ap_isspace(*dst))
 	    *dst = '\0';
 
 #ifdef DEBUG_CFG_LINES
 	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, NULL, "Read config: %s", buf);
 #endif
 	return 0;
@@ -937,13 +937,13 @@
 		    /* else nothing needs be done because
 		     * then the backslash is escaped and
 		     * we just strip to a single one
 		     */
 		}
 		/* blast trailing whitespace */
-		while (i > 0 && isspace(buf[i - 1]))
+		while (i > 0 && ap_isspace(buf[i - 1]))
 		    --i;
 		buf[i] = '\0';
 #ifdef DEBUG_CFG_LINES
 		ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, NULL, "Read config: %s", buf);
 #endif
 		return 0;
@@ -958,44 +958,44 @@
 /* Retrieve a token, spacing over it and returning a pointer to
  * the first non-white byte afterwards.  Note that these tokens
  * are delimited by semis and commas; and can also be delimited
  * by whitespace at the caller's option.
  */
 
-API_EXPORT(char *) ap_get_token(pool *p, char **accept_line, int accept_white)
+API_EXPORT(char *) ap_get_token(pool *p, const char **accept_line, int accept_white)
 {
-    char *ptr = *accept_line;
-    char *tok_start;
+    const char *ptr = *accept_line;
+    const char *tok_start;
     char *token;
     int tok_len;
 
     /* Find first non-white byte */
 
-    while (*ptr && isspace(*ptr))
+    while (*ptr && ap_isspace(*ptr))
 	++ptr;
 
     tok_start = ptr;
 
     /* find token end, skipping over quoted strings.
      * (comments are already gone).
      */
 
-    while (*ptr && (accept_white || !isspace(*ptr))
+    while (*ptr && (accept_white || !ap_isspace(*ptr))
 	   && *ptr != ';' && *ptr != ',') {
 	if (*ptr++ == '"')
 	    while (*ptr)
 		if (*ptr++ == '"')
 		    break;
     }
 
     tok_len = ptr - tok_start;
     token = ap_pstrndup(p, tok_start, tok_len);
 
     /* Advance accept_line pointer to the next non-white byte */
 
-    while (*ptr && isspace(*ptr))
+    while (*ptr && ap_isspace(*ptr))
 	++ptr;
 
     *accept_line = ptr;
     return token;
 }
 
@@ -1044,13 +1044,13 @@
 
     llen = strlen(line);
     tlen = strlen(tok);
     lidx = llen - tlen;
 
     if ((lidx < 0) ||
-	((lidx > 0) && !(isspace(line[lidx - 1]) || line[lidx - 1] == ',')))
+	((lidx > 0) && !(ap_isspace(line[lidx - 1]) || line[lidx - 1] == ',')))
 	return 0;
 
     return (strncasecmp(&line[lidx], tok, tlen) == 0);
 }
 
 API_EXPORT(char *) ap_escape_shell_cmd(pool *p, const char *str)
@@ -1306,13 +1306,13 @@
 API_EXPORT(int) ap_is_url(const char *u)
 {
     register int x;
 
     for (x = 0; u[x] != ':'; x++) {
 	if ((!u[x]) ||
-	    ((!isalpha(u[x])) && (!isdigit(u[x])) &&
+	    ((!ap_isalpha(u[x])) && (!ap_isdigit(u[x])) &&
 	     (u[x] != '+') && (u[x] != '-') && (u[x] != '.'))) {
 	    return 0;
 	}
     }
 
     return (x ? 1 : 0);		/* If the first character is ':', it's broken, too */
@@ -1361,13 +1361,13 @@
 #ifdef NEED_STRCASECMP
 int strcasecmp(const char *a, const char *b)
 {
     const char *p = a;
     const char *q = b;
     for (p = a, q = b; *p && *q; p++, q++) {
-	int diff = tolower(*p) - tolower(*q);
+	int diff = ap_tolower(*p) - ap_tolower(*q);
 	if (diff)
 	    return diff;
     }
     if (*p)
 	return 1;		/* p was longer than q */
     if (*q)
@@ -1386,21 +1386,49 @@
     for (p = a, q = b; /*NOTHING */ ; p++, q++) {
 	int diff;
 	if (p == a + n)
 	    return 0;		/*   Match up to n characters */
 	if (!(*p && *q))
 	    return *p - *q;
-	diff = tolower(*p) - tolower(*q);
+	diff = ap_tolower(*p) - ap_tolower(*q);
 	if (diff)
 	    return diff;
     }
     /*NOTREACHED */
 }
 #endif
 
-
+/* The following routine was donated for UTS21 by dwd@bell-labs.com */
+#ifdef NEED_STRSTR
+char *strstr(char *s1, char *s2)
+{
+    char *p1, *p2;
+    if (*s2 == '\0') {
+	/* an empty s2 */
+        return(s1);
+    }
+    while((s1 = strchr(s1, *s2)) != NULL) {
+	/* found first character of s2, see if the rest matches */
+        p1 = s1;
+        p2 = s2;
+        while (*++p1 == *++p2) {
+            if (*p1 == '\0') {
+                /* both strings ended together */
+                return(s1);
+            }
+        }
+        if (*p2 == '\0') {
+            /* second string ended, a match */
+            break;
+        }
+	/* didn't find a match here, try starting at next character in s1 */
+        s1++;
+    }
+    return(s1);
+}
+#endif
 
 #ifdef NEED_INITGROUPS
 int initgroups(const char *name, gid_t basegid)
 {
 #if defined(QNX) || defined(MPE) || defined(BEOS) || defined(_OSD_POSIX)
 /* QNX, MPE and BeOS do not appear to support supplementary groups. */
@@ -1430,22 +1458,25 @@
 }
 #endif /* def NEED_INITGROUPS */
 
 #ifdef NEED_WAITPID
 /* From ikluft@amdahl.com
  * this is not ideal but it works for SVR3 variants
- * httpd does not use the options so this doesn't implement them
+ * Modified by dwd@bell-labs.com to call wait3 instead of wait because
+ *   apache started to use the WNOHANG option.
  */
 int waitpid(pid_t pid, int *statusp, int options)
 {
     int tmp_pid;
     if (kill(pid, 0) == -1) {
 	errno = ECHILD;
 	return -1;
     }
-    while (((tmp_pid = wait(statusp)) != pid) && (tmp_pid != -1));
+    while (((tmp_pid = wait3(statusp, options, 0)) != pid) &&
+		(tmp_pid != -1) && (tmp_pid != 0) && (pid != -1))
+	;
     return tmp_pid;
 }
 #endif
 
 API_EXPORT(int) ap_ind(const char *s, char c)
 {
@@ -1469,13 +1500,13 @@
     return -1;
 }
 
 API_EXPORT(void) ap_str_tolower(char *str)
 {
     while (*str) {
-	*str = tolower(*str);
+	*str = ap_tolower(*str);
 	++str;
     }
 }
 
 API_EXPORT(uid_t) ap_uname2id(const char *name)
 {
@@ -1747,6 +1778,80 @@
 #if defined(NEED_DIFFTIME)
 double difftime(time_t time1, time_t time0)
 {
     return (time1 - time0);
 }
 #endif
+
+/* we want to downcase the type/subtype for comparison purposes
+ * but nothing else because ;parameter=foo values are case sensitive.
+ * XXX: in truth we want to downcase parameter names... but really,
+ * apache has never handled parameters and such correctly.  You
+ * also need to compress spaces and such to be able to compare
+ * properly. -djg
+ */
+API_EXPORT(void) ap_content_type_tolower(char *str)
+{
+    char *semi;
+
+    semi = strchr(str, ';');
+    if (semi) {
+	*semi = '\0';
+    }
+    while (*str) {
+	*str = ap_tolower(*str);
+	++str;
+    }
+    if (semi) {
+	*semi = ';';
+    }
+}
+
+/*
+ * Given a string, replace any bare " with \" .
+ */
+API_EXPORT(char *) ap_escape_quotes (pool *p, const char *instring)
+{
+    int newlen = 0;
+    const char *inchr = instring;
+    char *outchr, *outstring;
+
+    /*
+     * Look through the input string, jogging the length of the output
+     * string up by an extra byte each time we find an unescaped ".
+     */
+    while (*inchr != '\0') {
+	newlen++;
+        if (*inchr == '"') {
+	    newlen++;
+	}
+	/*
+	 * If we find a slosh, and it's not the last byte in the string,
+	 * it's escaping something - advance past both bytes.
+	 */
+	if ((*inchr == '\\') && (inchr[1] != '\0')) {
+	    inchr++;
+	}
+	inchr++;
+    }
+    outstring = ap_palloc(p, newlen + 1);
+    inchr = instring;
+    outchr = outstring;
+    /*
+     * Now copy the input string to the output string, inserting a slosh
+     * in front of every " that doesn't already have one.
+     */
+    while (*inchr != '\0') {
+	if ((*inchr == '\\') && (inchr[1] != '\0')) {
+	    *outchr++ = *inchr++;
+	    *outchr++ = *inchr++;
+	}
+	if (*inchr == '"') {
+	    *outchr++ = '\\';
+	}
+	if (*inchr != '\0') {
+	    *outchr++ = *inchr++;
+	}
+    }
+    *outchr = '\0';
+    return outstring;
+}
diff -BEr -U 6 apache_1.3.0/src/main/util_date.c apache_1.3.1/src/main/util_date.c
--- apache_1.3.0/src/main/util_date.c	1998-04-11 20:00:32.000000000 +0800
+++ apache_1.3.1/src/main/util_date.c	1998-07-13 19:32:41.000000000 +0800
@@ -63,13 +63,13 @@
  *     Extracted (with many modifications) from mod_proxy.c and
  *     tested with over 50,000 randomly chosen valid date strings
  *     and several hundred variations of invalid date strings.
  * 
  */
 
-#include "conf.h"
+#include "ap_config.h"
 #include "util_date.h"
 #include <ctype.h>
 #include <string.h>
 
 /*
  * Compare a string to a mask
@@ -94,29 +94,29 @@
 	    return (d == '\0');
 
 	case '*':
 	    return 1;
 
 	case '@':
-	    if (!isupper(d))
+	    if (!ap_isupper(d))
 		return 0;
 	    break;
 	case '$':
-	    if (!islower(d))
+	    if (!ap_islower(d))
 		return 0;
 	    break;
 	case '#':
-	    if (!isdigit(d))
+	    if (!ap_isdigit(d))
 		return 0;
 	    break;
 	case '&':
 	    if (!isxdigit(d))
 		return 0;
 	    break;
 	case '~':
-	    if ((d != ' ') && !isdigit(d))
+	    if ((d != ' ') && !ap_isdigit(d))
 		return 0;
 	    break;
 	default:
 	    if (mask[i] != d)
 		return 0;
 	    break;
@@ -228,13 +228,13 @@
 	('S' << 16) | ('e' << 8) | 'p', ('O' << 16) | ('c' << 8) | 't',
 	('N' << 16) | ('o' << 8) | 'v', ('D' << 16) | ('e' << 8) | 'c'};
 
     if (!date)
 	return BAD_DATE;
 
-    while (*date && isspace(*date))	/* Find first non-whitespace char */
+    while (*date && ap_isspace(*date))	/* Find first non-whitespace char */
 	++date;
 
     if (*date == '\0')
 	return BAD_DATE;
 
     if ((date = strchr(date, ' ')) == NULL)	/* Find space after weekday */
diff -BEr -U 6 apache_1.3.0/src/main/util_script.c apache_1.3.1/src/main/util_script.c
--- apache_1.3.0/src/main/util_script.c	1998-05-29 07:26:41.000000000 +0800
+++ apache_1.3.1/src/main/util_script.c	1998-07-10 16:33:36.000000000 +0800
@@ -97,27 +97,32 @@
     char **av;
     char *w;
     int idx = 0;
 
     /* count the number of keywords */
 
-    for (x = 0, numwords = 1; args[x]; x++)
-	if (args[x] == '+')
+    for (x = 0, numwords = 1; args[x]; x++) {
+        if (args[x] == '+') {
 	    ++numwords;
+	}
+    }
 
     if (numwords > APACHE_ARG_MAX - 5) {
 	numwords = APACHE_ARG_MAX - 5;	/* Truncate args to prevent overrun */
     }
     av = (char **) ap_palloc(p, (numwords + 5) * sizeof(char *));
 
-    if (path)
+    if (path) {
 	av[idx++] = path;
-    if (user)
+    }
+    if (user) {
 	av[idx++] = user;
-    if (group)
+    }
+    if (group) {
 	av[idx++] = group;
+    }
 
     av[idx++] = av0;
 
     for (x = 1; x <= numwords; x++) {
 	w = ap_getword_nulls(p, &args, '+');
 	ap_unescape_url(w);
@@ -131,48 +136,50 @@
 static char *http2env(pool *a, char *w)
 {
     char *res = ap_pstrcat(a, "HTTP_", w, NULL);
     char *cp = res;
 
     while (*++cp) {
-	if (!isalnum(*cp) && *cp != '_') {
+	if (!ap_isalnum(*cp) && *cp != '_') {
 	    *cp = '_';
 	}
 	else {
-	    *cp = toupper(*cp);
+	    *cp = ap_toupper(*cp);
 	}
     }
 
     return res;
 }
 
 API_EXPORT(char **) ap_create_environment(pool *p, table *t)
 {
-    array_header *env_arr = table_elts(t);
+    array_header *env_arr = ap_table_elts(t);
     table_entry *elts = (table_entry *) env_arr->elts;
     char **env = (char **) ap_palloc(p, (env_arr->nelts + 2) * sizeof(char *));
     int i, j;
     char *tz;
     char *whack;
 
     j = 0;
     if (!ap_table_get(t, "TZ")) {
 	tz = getenv("TZ");
-	if (tz != NULL)
+	if (tz != NULL) {
 	    env[j++] = ap_pstrcat(p, "TZ=", tz, NULL);
+	}
     }
     for (i = 0; i < env_arr->nelts; ++i) {
-	if (!elts[i].key)
+        if (!elts[i].key) {
 	    continue;
+	}
 	env[j] = ap_pstrcat(p, elts[i].key, "=", elts[i].val, NULL);
 	whack = env[j];
-	if (isdigit(*whack)) {
+	if (ap_isdigit(*whack)) {
 	    *whack++ = '_';
 	}
 	while (*whack != '=') {
-	    if (!isalnum(*whack) && *whack != '_') {
+	    if (!ap_isalnum(*whack) && *whack != '_') {
 		*whack = '_';
 	    }
 	    ++whack;
 	}
 	++j;
     }
@@ -190,90 +197,106 @@
     char *env_path;
 #ifdef WIN32
     char *env_temp;
 #endif
     const char *host;
 
-    array_header *hdrs_arr = table_elts(r->headers_in);
+    array_header *hdrs_arr = ap_table_elts(r->headers_in);
     table_entry *hdrs = (table_entry *) hdrs_arr->elts;
     int i;
 
     /* First, add environment vars from headers... this is as per
      * CGI specs, though other sorts of scripting interfaces see
      * the same vars...
      */
 
     for (i = 0; i < hdrs_arr->nelts; ++i) {
-	if (!hdrs[i].key)
+        if (!hdrs[i].key) {
 	    continue;
+	}
 
 	/* A few headers are special cased --- Authorization to prevent
 	 * rogue scripts from capturing passwords; content-type and -length
 	 * for no particular reason.
 	 */
 
-	if (!strcasecmp(hdrs[i].key, "Content-type"))
+	if (!strcasecmp(hdrs[i].key, "Content-type")) {
 	    ap_table_setn(e, "CONTENT_TYPE", hdrs[i].val);
-	else if (!strcasecmp(hdrs[i].key, "Content-length"))
+	}
+	else if (!strcasecmp(hdrs[i].key, "Content-length")) {
 	    ap_table_setn(e, "CONTENT_LENGTH", hdrs[i].val);
+	}
 	/*
 	 * You really don't want to disable this check, since it leaves you
 	 * wide open to CGIs stealing passwords and people viewing them
 	 * in the environment with "ps -e".  But, if you must...
 	 */
 #ifndef SECURITY_HOLE_PASS_AUTHORIZATION
-	else if (!strcasecmp(hdrs[i].key, "Authorization") ||
-                 !strcasecmp(hdrs[i].key, "Proxy-Authorization"))
+	else if (!strcasecmp(hdrs[i].key, "Authorization") 
+		 || !strcasecmp(hdrs[i].key, "Proxy-Authorization")) {
 	    continue;
+	}
 #endif
-	else
+	else {
 	    ap_table_setn(e, http2env(r->pool, hdrs[i].key), hdrs[i].val);
+	}
     }
 
-    if (!(env_path = getenv("PATH")))
+    if (!(env_path = getenv("PATH"))) {
 	env_path = DEFAULT_PATH;
+    }
 
 #ifdef WIN32
-    if (env_temp = getenv("SystemRoot"))
+    if (env_temp = getenv("SystemRoot")) {
         ap_table_setn(e, "SystemRoot", env_temp);         
-    if (env_temp = getenv("COMSPEC"))
+    }
+    if (env_temp = getenv("COMSPEC")) {
         ap_table_setn(e, "COMSPEC", env_temp);            
-    if (env_temp = getenv("WINDIR"))
-        ap_table_setn(e, "WINDIR", env_temp);             
+    }
+    if (env_temp = getenv("WINDIR")) {
+        ap_table_setn(e, "WINDIR", env_temp);
+    }
 #endif
 
     ap_table_setn(e, "PATH", env_path);
     ap_table_setn(e, "SERVER_SOFTWARE", ap_get_server_version());
     ap_table_setn(e, "SERVER_NAME", ap_get_server_name(r));
-    ap_table_setn(e, "SERVER_PORT", ap_psprintf(r->pool, "%u", ap_get_server_port(r)));
+    ap_table_setn(e, "SERVER_PORT",
+		  ap_psprintf(r->pool, "%u", ap_get_server_port(r)));
     host = ap_get_remote_host(c, r->per_dir_config, REMOTE_HOST);
     if (host) {
 	ap_table_setn(e, "REMOTE_HOST", host);
     }
     ap_table_setn(e, "REMOTE_ADDR", c->remote_ip);
     ap_table_setn(e, "DOCUMENT_ROOT", ap_document_root(r));	/* Apache */
     ap_table_setn(e, "SERVER_ADMIN", s->server_admin);	/* Apache */
     ap_table_setn(e, "SCRIPT_FILENAME", r->filename);	/* Apache */
 
-    ap_table_setn(e, "REMOTE_PORT", ap_psprintf(r->pool, "%d", ntohs(c->remote_addr.sin_port)));
+    ap_table_setn(e, "REMOTE_PORT",
+		  ap_psprintf(r->pool, "%d", ntohs(c->remote_addr.sin_port)));
 
-    if (c->user)
+    if (c->user) {
 	ap_table_setn(e, "REMOTE_USER", c->user);
-    if (c->ap_auth_type)
+    }
+    if (c->ap_auth_type) {
 	ap_table_setn(e, "AUTH_TYPE", c->ap_auth_type);
+    }
     rem_logname = ap_get_remote_logname(r);
-    if (rem_logname)
+    if (rem_logname) {
 	ap_table_setn(e, "REMOTE_IDENT", ap_pstrdup(r->pool, rem_logname));
+    }
 
     /* Apache custom error responses. If we have redirected set two new vars */
 
     if (r->prev) {
-	if (r->prev->args)
+        if (r->prev->args) {
 	    ap_table_setn(e, "REDIRECT_QUERY_STRING", r->prev->args);
-	if (r->prev->uri)
+	}
+	if (r->prev->uri) {
 	    ap_table_setn(e, "REDIRECT_URL", r->prev->uri);
+	}
     }
 }
 
 /* This "cute" little function comes about because the path info on
  * filenames and URLs aren't always the same. So we take the two,
  * and find as much of the two that match as possible.
@@ -283,41 +306,46 @@
 {
     int lu = strlen(uri);
     int lp = strlen(path_info);
 
     while (lu-- && lp-- && uri[lu] == path_info[lp]);
 
-    if (lu == -1)
+    if (lu == -1) {
 	lu = 0;
+    }
 
-    while (uri[lu] != '\0' && uri[lu] != '/')
+    while (uri[lu] != '\0' && uri[lu] != '/') {
 	lu++;
-
+    }
     return lu;
 }
 
 /* Obtain the Request-URI from the original request-line, returning
  * a new string from the request pool containing the URI or "".
  */
 static char *original_uri(request_rec *r)
 {
     char *first, *last;
 
-    if (r->the_request == NULL)
+    if (r->the_request == NULL) {
 	return (char *) ap_pcalloc(r->pool, 1);
+    }
 
     first = r->the_request;	/* use the request-line */
 
-    while (*first && !isspace(*first))
+    while (*first && !ap_isspace(*first)) {
 	++first;		/* skip over the method */
-    while (isspace(*first))
+    }
+    while (ap_isspace(*first)) {
 	++first;		/*   and the space(s)   */
+    }
 
     last = first;
-    while (*last && !isspace(*last))
+    while (*last && !ap_isspace(*last)) {
 	++last;			/* end at next whitespace */
+    }
 
     return ap_pstrndup(r->pool, first, last - first);
 }
 
 API_EXPORT(void) ap_add_cgi_vars(request_rec *r)
 {
@@ -334,42 +362,44 @@
      * args and path_info of the original request, and not any that may have
      * come with the script URI in the include command.  Ugh.
      */
 
     if (!strcmp(r->protocol, "INCLUDED")) {
 	ap_table_setn(e, "SCRIPT_NAME", r->uri);
-	if (r->path_info && *r->path_info)
+	if (r->path_info && *r->path_info) {
 	    ap_table_setn(e, "PATH_INFO", r->path_info);
+	}
     }
     else if (!r->path_info || !*r->path_info) {
 	ap_table_setn(e, "SCRIPT_NAME", r->uri);
     }
     else {
 	int path_info_start = ap_find_path_info(r->uri, r->path_info);
 
-	ap_table_setn(e, "SCRIPT_NAME", ap_pstrndup(r->pool, r->uri,
-					     path_info_start));
+	ap_table_setn(e, "SCRIPT_NAME",
+		      ap_pstrndup(r->pool, r->uri, path_info_start));
 
 	ap_table_setn(e, "PATH_INFO", r->path_info);
     }
 
     if (r->path_info && r->path_info[0]) {
 	/*
 	 * To get PATH_TRANSLATED, treat PATH_INFO as a URI path.
 	 * Need to re-escape it for this, since the entire URI was
 	 * un-escaped before we determined where the PATH_INFO began.
 	 */
-	request_rec *pa_req = ap_sub_req_lookup_uri(escape_uri(r->pool, r->path_info),
-						 r);
+	request_rec *pa_req;
+
+	pa_req = ap_sub_req_lookup_uri(escape_uri(r->pool, r->path_info), r);
 
 	if (pa_req->filename) {
 #ifdef WIN32
 	    char buffer[HUGE_STRING_LEN];
 #endif
 	    char *pt = ap_pstrcat(r->pool, pa_req->filename, pa_req->path_info,
-			       NULL);
+				  NULL);
 #ifdef WIN32
 	    /* We need to make this a real Windows path name */
 	    GetFullPathName(pt, HUGE_STRING_LEN, buffer, NULL);
 	    ap_table_setn(e, "PATH_TRANSLATED", ap_pstrdup(r->pool, buffer));
 #else
 	    ap_table_setn(e, "PATH_TRANSLATED", pt);
@@ -378,42 +408,46 @@
 	ap_destroy_sub_req(pa_req);
     }
 }
 
 
 static int scan_script_header_err_core(request_rec *r, char *buffer,
-		 int (*getsfunc) (char *, int, void *), void *getsfunc_data)
+				       int (*getsfunc) (char *, int, void *),
+				       void *getsfunc_data)
 {
     char x[MAX_STRING_LEN];
     char *w, *l;
     int p;
     int cgi_status = HTTP_OK;
 
-    if (buffer)
+    if (buffer) {
 	*buffer = '\0';
+    }
     w = buffer ? buffer : x;
 
     ap_hard_timeout("read script header", r);
 
     while (1) {
 
 	if ((*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data) == 0) {
 	    ap_kill_timeout(r);
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
-			"Premature end of script headers: %s", r->filename);
+			 "Premature end of script headers: %s", r->filename);
 	    return SERVER_ERROR;
 	}
 
 	/* Delete terminal (CR?)LF */
 
 	p = strlen(w);
 	if (p > 0 && w[p - 1] == '\n') {
-	    if (p > 1 && w[p - 2] == '\015')
+	    if (p > 1 && w[p - 2] == '\015') {
 		w[p - 2] = '\0';
-	    else
+	    }
+	    else {
 		w[p - 1] = '\0';
+	    }
 	}
 
 	/*
 	 * If we've finished reading the headers, check to make sure any
 	 * HTTP/1.1 conditions are met.  If so, we're done; normal processing
 	 * will handle the script's output.  If not, just return the error.
@@ -435,41 +469,49 @@
 	    return cond_status;
 	}
 
 	/* if we see a bogus header don't ignore it. Shout and scream */
 
 	if (!(l = strchr(w, ':'))) {
-	    char malformed[(sizeof MALFORMED_MESSAGE) + 1 + MALFORMED_HEADER_LENGTH_TO_SHOW];
+	    char malformed[(sizeof MALFORMED_MESSAGE) + 1
+			   + MALFORMED_HEADER_LENGTH_TO_SHOW];
+
 	    strcpy(malformed, MALFORMED_MESSAGE);
 	    strncat(malformed, w, MALFORMED_HEADER_LENGTH_TO_SHOW);
 
-	    if (!buffer)
-		/* Soak up all the script output --- may save an outright kill */
-		while ((*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data))
+	    if (!buffer) {
+		/* Soak up all the script output - may save an outright kill */
+	        while ((*getsfunc) (w, MAX_STRING_LEN - 1, getsfunc_data)) {
 		    continue;
+		}
+	    }
 
 	    ap_kill_timeout(r);
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
-			"%s: %s", malformed, r->filename);
+			 "%s: %s", malformed, r->filename);
 	    return SERVER_ERROR;
 	}
 
 	*l++ = '\0';
-	while (*l && isspace(*l))
+	while (*l && ap_isspace(*l)) {
 	    ++l;
+	}
 
 	if (!strcasecmp(w, "Content-type")) {
+	    char *tmp;
 
 	    /* Nuke trailing whitespace */
 
 	    char *endp = l + strlen(l) - 1;
-	    while (endp > l && isspace(*endp))
+	    while (endp > l && ap_isspace(*endp)) {
 		*endp-- = '\0';
+	    }
 
-	    r->content_type = ap_pstrdup(r->pool, l);
-	    ap_str_tolower(r->content_type);
+	    tmp = ap_pstrdup(r->pool, l);
+	    ap_content_type_tolower(tmp);
+	    r->content_type = tmp;
 	}
 	/*
 	 * If the script returned a specific status, that's what
 	 * we'll use - otherwise we assume 200 OK.
 	 */
 	else if (!strcasecmp(w, "Status")) {
@@ -511,56 +553,65 @@
 
 static int getsfunc_FILE(char *buf, int len, void *f)
 {
     return fgets(buf, len, (FILE *) f) != NULL;
 }
 
-API_EXPORT(int) ap_scan_script_header_err(request_rec *r, FILE *f, char *buffer)
+API_EXPORT(int) ap_scan_script_header_err(request_rec *r, FILE *f,
+					  char *buffer)
 {
     return scan_script_header_err_core(r, buffer, getsfunc_FILE, f);
 }
 
 static int getsfunc_BUFF(char *w, int len, void *fb)
 {
     return ap_bgets(w, len, (BUFF *) fb) > 0;
 }
 
 API_EXPORT(int) ap_scan_script_header_err_buff(request_rec *r, BUFF *fb,
-					    char *buffer)
+					       char *buffer)
 {
     return scan_script_header_err_core(r, buffer, getsfunc_BUFF, fb);
 }
 
 
 API_EXPORT(void) ap_send_size(size_t size, request_rec *r)
 {
     /* XXX: this -1 thing is a gross hack */
-    if (size == (size_t)-1)
+    if (size == (size_t)-1) {
 	ap_rputs("    -", r);
-    else if (!size)
+    }
+    else if (!size) {
 	ap_rputs("   0k", r);
-    else if (size < 1024)
+    }
+    else if (size < 1024) {
 	ap_rputs("   1k", r);
-    else if (size < 1048576)
+    }
+    else if (size < 1048576) {
 	ap_rprintf(r, "%4dk", (size + 512) / 1024);
-    else if (size < 103809024)
+    }
+    else if (size < 103809024) {
 	ap_rprintf(r, "%4.1fM", size / 1048576.0);
-    else
+    }
+    else {
 	ap_rprintf(r, "%4dM", (size + 524288) / 1048576);
+    }
 }
 
 #if defined(__EMX__) || defined(WIN32)
 static char **create_argv_cmd(pool *p, char *av0, const char *args, char *path)
 {
     register int x, n;
     char **av;
     char *w;
 
-    for (x = 0, n = 2; args[x]; x++)
-	if (args[x] == '+')
+    for (x = 0, n = 2; args[x]; x++) {
+        if (args[x] == '+') {
 	    ++n;
+	}
+    }
 
     /* Add extra strings to array. */
     n = n + 2;
 
     av = (char **) ap_palloc(p, (n + 1) * sizeof(char *));
     av[0] = av0;
@@ -577,20 +628,22 @@
     av[n] = NULL;
     return av;
 }
 #endif
 
 
-API_EXPORT(int) ap_call_exec(request_rec *r, child_info *pinfo, char *argv0, char **env, int shellcmd)
+API_EXPORT(int) ap_call_exec(request_rec *r, child_info *pinfo, char *argv0,
+			     char **env, int shellcmd)
 {
     int pid = 0;
 #if defined(RLIMIT_CPU)  || defined(RLIMIT_NPROC) || \
     defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined (RLIMIT_AS)
 
-    core_dir_config *conf =
-    (core_dir_config *) ap_get_module_config(r->per_dir_config, &core_module);
+    core_dir_config *conf;
+    conf = (core_dir_config *) ap_get_module_config(r->per_dir_config,
+						    &core_module);
 
 #endif
 
 #ifndef WIN32
     /* the fd on r->server->error_log is closed, but we need somewhere to
      * put the error messages from the log_* functions. So, we use stderr,
@@ -598,50 +651,64 @@
      * this on Win32, though, since we haven't fork()'d.
      */
     r->server->error_log = stderr;
 #endif
 
 #ifdef RLIMIT_CPU
-    if (conf->limit_cpu != NULL)
-	if ((setrlimit(RLIMIT_CPU, conf->limit_cpu)) != 0)
+    if (conf->limit_cpu != NULL) {
+        if ((setrlimit(RLIMIT_CPU, conf->limit_cpu)) != 0) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-			"setrlimit: failed to set CPU usage limit");
+			 "setrlimit: failed to set CPU usage limit");
+	}
+    }
 #endif
 #ifdef RLIMIT_NPROC
-    if (conf->limit_nproc != NULL)
-	if ((setrlimit(RLIMIT_NPROC, conf->limit_nproc)) != 0)
+    if (conf->limit_nproc != NULL) {
+        if ((setrlimit(RLIMIT_NPROC, conf->limit_nproc)) != 0) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-			"setrlimit: failed to set process limit");
+			 "setrlimit: failed to set process limit");
+	}
+    }
 #endif
 #if defined(RLIMIT_AS)
-    if (conf->limit_mem != NULL)
-	if ((setrlimit(RLIMIT_AS, conf->limit_mem)) != 0)
+    if (conf->limit_mem != NULL) {
+        if ((setrlimit(RLIMIT_AS, conf->limit_mem)) != 0) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-			"setrlimit(RLIMIT_AS): failed to set memory usage limit");
+			 "setrlimit(RLIMIT_AS): failed to set memory "
+			 "usage limit");
+	}
+    }
 #elif defined(RLIMIT_DATA)
-    if (conf->limit_mem != NULL)
-	if ((setrlimit(RLIMIT_DATA, conf->limit_mem)) != 0)
+    if (conf->limit_mem != NULL) {
+        if ((setrlimit(RLIMIT_DATA, conf->limit_mem)) != 0) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-			"setrlimit(RLIMIT_DATA): failed to set memory usage limit");
+			 "setrlimit(RLIMIT_DATA): failed to set memory "
+			 "usage limit");
+	}
+    }
 #elif defined(RLIMIT_VMEM)
-    if (conf->limit_mem != NULL)
-	if ((setrlimit(RLIMIT_VMEM, conf->limit_mem)) != 0)
+    if (conf->limit_mem != NULL) {
+        if ((setrlimit(RLIMIT_VMEM, conf->limit_mem)) != 0) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-			"setrlimit(RLIMIT_VMEM): failed to set memory usage limit");
+			 "setrlimit(RLIMIT_VMEM): failed to set memory "
+			 "usage limit");
+	}
+    }
 #endif
 
 #ifdef __EMX__
     {
 	/* Additions by Alec Kloss, to allow exec'ing of scripts under OS/2 */
 	int is_script;
-	char interpreter[2048];	/* hope this is large enough for the interpreter path */
+	char interpreter[2048];	/* hope it's enough for the interpreter path */
 	FILE *program;
+
 	program = fopen(r->filename, "rt");
 	if (!program) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server, "fopen(%s) failed",
-			r->filename);
+			 r->filename);
 	    return (pid);
 	}
 	fgets(interpreter, sizeof(interpreter), program);
 	fclose(program);
 	if (!strncmp(interpreter, "#!", 2)) {
 	    is_script = 1;
@@ -653,19 +720,20 @@
 
 	if ((!r->args) || (!r->args[0]) || strchr(r->args, '=')) {
 	    int emxloop;
 	    char *emxtemp;
 
 	    /* For OS/2 place the variables in the current
-	     * enviornment then it will be inherited. This way
+	     * environment then it will be inherited. This way
 	     * the program will also get all of OS/2's other SETs.
 	     */
-	    for (emxloop = 0; ((emxtemp = env[emxloop]) != NULL); emxloop++)
+	    for (emxloop = 0; ((emxtemp = env[emxloop]) != NULL); emxloop++) {
 		putenv(emxtemp);
+	    }
 
-	    /* Additions by Alec Kloss, to allow exec'ing of scripts under OS/2 */
+	    /* More additions by Alec Kloss for OS/2 */
 	    if (is_script) {
 		/* here's the stuff to run the interpreter */
 		execl(interpreter + 2, interpreter + 2, r->filename, NULL);
 	    }
 	    else if (strstr(strupr(r->filename), ".CMD") > 0) {
 		/* Special case to allow use of REXX commands as scripts. */
@@ -681,32 +749,35 @@
 	    char *emxtemp;
 
 	    /* For OS/2 place the variables in the current
 	     * environment so that they will be inherited. This way
 	     * the program will also get all of OS/2's other SETs.
 	     */
-	    for (emxloop = 0; ((emxtemp = env[emxloop]) != NULL); emxloop++)
+	    for (emxloop = 0; ((emxtemp = env[emxloop]) != NULL); emxloop++) {
 		putenv(emxtemp);
+	    }
 
 	    if (strstr(strupr(r->filename), ".CMD") > 0) {
 		/* Special case to allow use of REXX commands as scripts. */
 		os2pathname(r->filename);
-		execv(SHELL_PATH, create_argv_cmd(r->pool, argv0, r->args, r->filename));
+		execv(SHELL_PATH, create_argv_cmd(r->pool, argv0, r->args,
+						  r->filename));
 	    }
-	    else
+	    else {
 		execv(r->filename,
-		    create_argv(r->pool, NULL, NULL, NULL, argv0, r->args));
+		      create_argv(r->pool, NULL, NULL, NULL, argv0, r->args));
+	    }
 	}
 	return (pid);
     }
 #elif defined(WIN32)
     {
-	/* Adapted from work by Alec Kloss, to allow exec'ing of scripts under OS/2 */
+	/* Adapted from Alec Kloss' work for OS/2 */
 	int is_script = 0;
 	int is_binary = 0;
-	char interpreter[2048];	/* hope this is large enough for the interpreter path */
+	char interpreter[2048];	/* hope it's enough for the interpreter path */
 	FILE *program;
 	int i, sz;
 	char *dot;
 	char *exename;
 	int is_exe = 0;
 	STARTUPINFO si;
@@ -716,77 +787,93 @@
         int iEnvBlockLen;
 
 	memset(&si, 0, sizeof(si));
 	memset(&pi, 0, sizeof(pi));
 
 	interpreter[0] = 0;
+	pid = -1;
 
 	exename = strrchr(r->filename, '/');
-	if (!exename)
+	if (!exename) {
 	    exename = strrchr(r->filename, '\\');
-	if (!exename)
+	}
+	if (!exename) {
 	    exename = r->filename;
-	else
+	}
+	else {
 	    exename++;
+	}
 	dot = strrchr(exename, '.');
 	if (dot) {
-	    if (!strcasecmp(dot, ".BAT") ||
-		!strcasecmp(dot, ".CMD") ||
-		!strcasecmp(dot, ".EXE") ||
-		!strcasecmp(dot, ".COM"))
+	    if (!strcasecmp(dot, ".BAT")
+		|| !strcasecmp(dot, ".CMD")
+		|| !strcasecmp(dot, ".EXE")
+		||  !strcasecmp(dot, ".COM")) {
 		is_exe = 1;
+	    }
 	}
 
 	if (!is_exe) {
 	    program = fopen(r->filename, "rb");
 	    if (!program) {
 		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-			    "fopen(%s) failed", r->filename);
+			     "fopen(%s) failed", r->filename);
 		return (pid);
 	    }
 	    sz = fread(interpreter, 1, sizeof(interpreter) - 1, program);
 	    if (sz < 0) {
 		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-			    "fread of %s failed", r->filename);
+			     "fread of %s failed", r->filename);
 		fclose(program);
 		return (pid);
 	    }
 	    interpreter[sz] = 0;
 	    fclose(program);
 	    if (!strncmp(interpreter, "#!", 2)) {
 		is_script = 1;
 		for (i = 2; i < sizeof(interpreter); i++) {
-		    if ((interpreter[i] == '\r') ||
-			(interpreter[i] == '\n'))
+		    if ((interpreter[i] == '\r')
+			|| (interpreter[i] == '\n')) {
 			break;
+		    }
 		}
 		interpreter[i] = 0;
 		for (i = 2; interpreter[i] == ' '; ++i)
 		    ;
 		memmove(interpreter+2,interpreter+i,strlen(interpreter+i)+1);
 	    }
 	    else {
-                        /* Check to see if it's a executable */
+	        /* Check to see if it's a executable */
                 IMAGE_DOS_HEADER *hdr = (IMAGE_DOS_HEADER*)interpreter;
-                if (hdr->e_magic == IMAGE_DOS_SIGNATURE && hdr->e_cblp < 512)
+                if (hdr->e_magic == IMAGE_DOS_SIGNATURE && hdr->e_cblp < 512) {
                     is_binary = 1;
+		}
 	    }
 	}
+        /* Bail out if we haven't figured out what kind of
+         * file this is by now..
+         */
+        if (!is_exe && !is_script && !is_binary) {
+            ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r->server,
+		"%s is not executable; ensure interpreted scripts have "
+		"\"#!\" first line", 
+		r->filename);
+            return (pid);
+	}
 
 	/*
 	 * Make child process use hPipeOutputWrite as standard out,
 	 * and make sure it does not show on screen.
 	 */
 	si.cb = sizeof(si);
 	si.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
 	si.wShowWindow = SW_HIDE;
 	si.hStdInput   = pinfo->hPipeInputRead;
 	si.hStdOutput  = pinfo->hPipeOutputWrite;
 	si.hStdError   = pinfo->hPipeErrorWrite;
-	
-	pid = -1;      
+
 	if ((!r->args) || (!r->args[0]) || strchr(r->args, '=')) { 
 	    if (is_exe || is_binary) {
 	        /*
 	         * When the CGI is a straight binary executable, 
 		 * we can run it as is
 	         */
@@ -930,86 +1017,97 @@
 	    }
 	}
 #endif
 	return (pid);
     }
 #else
-    if (ap_suexec_enabled &&
-	((r->server->server_uid != ap_user_id) ||
-	 (r->server->server_gid != ap_group_id) ||
-	 (!strncmp("/~", r->uri, 2)))) {
+    if (ap_suexec_enabled
+	&& ((r->server->server_uid != ap_user_id)
+	    || (r->server->server_gid != ap_group_id)
+	    || (!strncmp("/~", r->uri, 2)))) {
 
 	char *execuser, *grpname;
 	struct passwd *pw;
 	struct group *gr;
 
 	if (!strncmp("/~", r->uri, 2)) {
 	    gid_t user_gid;
 	    char *username = ap_pstrdup(r->pool, r->uri + 2);
 	    char *pos = strchr(username, '/');
 
-	    if (pos)
+	    if (pos) {
 		*pos = '\0';
+	    }
 
 	    if ((pw = getpwnam(username)) == NULL) {
 		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-			    "getpwnam: invalid username %s", username);
+			     "getpwnam: invalid username %s", username);
 		return (pid);
 	    }
 	    execuser = ap_pstrcat(r->pool, "~", pw->pw_name, NULL);
 	    user_gid = pw->pw_gid;
 
 	    if ((gr = getgrgid(user_gid)) == NULL) {
-		if ((grpname = ap_palloc(r->pool, 16)) == NULL)
+	        if ((grpname = ap_palloc(r->pool, 16)) == NULL) {
 		    return (pid);
-		else
+		}
+		else {
 		    ap_snprintf(grpname, 16, "%ld", (long) user_gid);
+		}
 	    }
-	    else
+	    else {
 		grpname = gr->gr_name;
+	    }
 	}
 	else {
 	    if ((pw = getpwuid(r->server->server_uid)) == NULL) {
 		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-		            "getpwuid: invalid userid %ld",
-		            (long) r->server->server_uid);
+			     "getpwuid: invalid userid %ld",
+			     (long) r->server->server_uid);
 		return (pid);
 	    }
 	    execuser = ap_pstrdup(r->pool, pw->pw_name);
 
 	    if ((gr = getgrgid(r->server->server_gid)) == NULL) {
 		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
-		            "getgrgid: invalid groupid %ld",
-		            (long) r->server->server_gid);
+			     "getgrgid: invalid groupid %ld",
+			     (long) r->server->server_gid);
 		return (pid);
 	    }
 	    grpname = gr->gr_name;
 	}
 
-	if (shellcmd)
-	    execle(SUEXEC_BIN, SUEXEC_BIN, execuser, grpname, argv0, NULL, env);
+	if (shellcmd) {
+	    execle(SUEXEC_BIN, SUEXEC_BIN, execuser, grpname, argv0,
+		   NULL, env);
+	}
 
-	else if ((!r->args) || (!r->args[0]) || strchr(r->args, '='))
-	    execle(SUEXEC_BIN, SUEXEC_BIN, execuser, grpname, argv0, NULL, env);
+	else if ((!r->args) || (!r->args[0]) || strchr(r->args, '=')) {
+	    execle(SUEXEC_BIN, SUEXEC_BIN, execuser, grpname, argv0,
+		   NULL, env);
+	}
 
 	else {
 	    execve(SUEXEC_BIN,
 		   create_argv(r->pool, SUEXEC_BIN, execuser, grpname,
 			       argv0, r->args),
 		   env);
 	}
     }
     else {
-	if (shellcmd)
+        if (shellcmd) {
 	    execle(SHELL_PATH, SHELL_PATH, "-c", argv0, NULL, env);
+	}
 
-	else if ((!r->args) || (!r->args[0]) || strchr(r->args, '='))
+	else if ((!r->args) || (!r->args[0]) || strchr(r->args, '=')) {
 	    execle(r->filename, argv0, NULL, env);
+	}
 
-	else
+	else {
 	    execve(r->filename,
 		   create_argv(r->pool, NULL, NULL, NULL, argv0, r->args),
 		   env);
+	}
     }
     return (pid);
 #endif
 }
diff -BEr -U 6 apache_1.3.0/src/main/util_uri.c apache_1.3.1/src/main/util_uri.c
--- apache_1.3.0/src/main/util_uri.c	1998-05-30 09:54:30.000000000 +0800
+++ apache_1.3.1/src/main/util_uri.c	1998-07-16 07:49:13.000000000 +0800
@@ -63,20 +63,22 @@
 #include "http_log.h"
 #include "http_conf_globals.h"	/* for user_id & group_id */
 #include "util_uri.h"
 
 /* Some WWW schemes and their default ports; this is basically /etc/services */
 /* This will become global when the protocol abstraction comes */
+/* As the schemes are searched by a linear search, */
+/* they are sorted by their expected frequency */
 static schemes_t schemes[] =
 {
+    {"http",   DEFAULT_HTTP_PORT},
     {"ftp",    DEFAULT_FTP_PORT},
+    {"https",  DEFAULT_HTTPS_PORT},
     {"gopher", DEFAULT_GOPHER_PORT},
-    {"http",   DEFAULT_HTTP_PORT},
-    {"nntp",   DEFAULT_NNTP_PORT},
     {"wais",   DEFAULT_WAIS_PORT},
-    {"https",  DEFAULT_HTTPS_PORT},
+    {"nntp",   DEFAULT_NNTP_PORT},
     {"snews",  DEFAULT_SNEWS_PORT},
     {"prospero", DEFAULT_PROSPERO_PORT},
     { NULL, 0xFFFF }			/* unknown port */
 };
 
 
@@ -99,22 +101,22 @@
 }
 
 /* Create a copy of a "struct hostent" record; it was presumably returned
  * from a call to gethostbyname() and lives in static storage.
  * By creating a copy we can tuck it away for later use.
  */
-API_EXPORT(struct hostent *) ap_pduphostent(pool *p, struct hostent *hp)
+API_EXPORT(struct hostent *) ap_pduphostent(pool *p, const struct hostent *hp)
 {
     struct hostent *newent;
     char	  **ptrs;
     char	  **aliases;
     struct in_addr *addrs;
     int		   i = 0, j = 0;
 
     if (hp == NULL)
-	return hp;
+	return NULL;
 
     /* Count number of alias entries */
     if (hp->h_aliases != NULL)
 	for (; hp->h_aliases[j] != NULL; ++j)
 	    continue;
 
@@ -166,41 +168,48 @@
  * Optionally suppress the password for security reasons.
  */
 API_EXPORT(char *) ap_unparse_uri_components(pool *p, const uri_components *uptr, unsigned flags)
 {
     char *ret = "";
 
-    /* Construct a "user:password@" string, honoring the passed UNP_ flags: */
-    if (uptr->user||uptr->password)
-	ret = ap_pstrcat (p,
-		(uptr->user     && !(flags & UNP_OMITUSER)) ? uptr->user : "",
-		(uptr->password && !(flags & UNP_OMITPASSWORD)) ? ":" : "",
-		(uptr->password && !(flags & UNP_OMITPASSWORD))
-		   ? ((flags & UNP_REVEALPASSWORD) ? uptr->password : "XXXXXXXX")
-		   : "",
-		"@", NULL);
+    /* If suppressing the site part, omit both user name & scheme://hostname */
+    if (!(flags & UNP_OMITSITEPART)) {
 
-    /* Construct scheme://site string */
-    if (uptr->hostname && !(flags & UNP_OMITSITEPART)) {
-	ret = ap_pstrcat (p,
-		uptr->scheme, "://", ret, 
-		uptr->hostname ? uptr->hostname : "",
-		       uptr->port_str ? ":" : "",
-		       uptr->port_str ? uptr->port_str : "",
-		       NULL);
+	/* Construct a "user:password@" string, honoring the passed UNP_ flags: */
+	if (uptr->user||uptr->password)
+	    ret = ap_pstrcat (p,
+			(uptr->user     && !(flags & UNP_OMITUSER)) ? uptr->user : "",
+			(uptr->password && !(flags & UNP_OMITPASSWORD)) ? ":" : "",
+			(uptr->password && !(flags & UNP_OMITPASSWORD))
+			   ? ((flags & UNP_REVEALPASSWORD) ? uptr->password : "XXXXXXXX")
+			   : "",
+			"@", NULL);
+
+	/* Construct scheme://site string */
+	if (uptr->hostname) {
+	    ret = ap_pstrcat (p,
+			uptr->scheme, "://", ret, 
+			uptr->hostname ? uptr->hostname : "",
+			uptr->port_str ? ":" : "",
+			uptr->port_str ? uptr->port_str : "",
+			NULL);
+	}
     }
 
-    /* Append path, query and fragment strings: */
-    ret = ap_pstrcat (p,
-		   ret,
-		   uptr->path ? uptr->path : "",
-		   uptr->query ? "?" : "",
-		   uptr->query ? uptr->query : "",
-		   uptr->fragment ? "#" : NULL,
-		   uptr->fragment ? uptr->fragment : NULL,
-		   NULL);
+    /* Should we suppress all path info? */
+    if (!(flags & UNP_OMITPATHINFO)) {
+	/* Append path, query and fragment strings: */
+	ret = ap_pstrcat (p,
+		ret,
+		uptr->path ? uptr->path : "",
+		(uptr->query    && !(flags & UNP_OMITQUERY)) ? "?" : "",
+		(uptr->query    && !(flags & UNP_OMITQUERY)) ? uptr->query : "",
+		(uptr->fragment && !(flags & UNP_OMITQUERY)) ? "#" : NULL,
+		(uptr->fragment && !(flags & UNP_OMITQUERY)) ? uptr->fragment : NULL,
+		NULL);
+    }
     return ret;
 }
 
 /* The regex version of parse_uri_components has the advantage that it is
  * relatively easy to understand and extend.  But it has the disadvantage
  * that the regexes are complex enough that regex libraries really
Only in apache_1.3.0/src: Makefile
Only in apache_1.3.0/src: Makefile.config
diff -BEr -U 6 apache_1.3.0/src/Makefile.tmpl apache_1.3.1/src/Makefile.tmpl
--- apache_1.3.0/src/Makefile.tmpl	1998-05-22 14:56:56.000000000 +0800
+++ apache_1.3.1/src/Makefile.tmpl	1998-07-13 19:32:29.000000000 +0800
@@ -20,13 +20,13 @@
 	@echo "++ File '@@Configuration@@' older than 'Configuration.tmpl',"
 	@echo "++ or still doesn't exist. Please consider copying 'Configuration.tmpl'"
 	@echo "++ to '@@Configuration@@', editing and rerunning 'Configure'."
 	@echo "++ If not, you will at least have to touch '@@Configuration@@'."
 	@false
 
-$(TARGET): $(SUBTARGET)
+$(TARGET): $(EXTRA_DEPS) $(SUBTARGET)
 
 target_static: subdirs modules.o
 	$(CC) -c $(INCLUDES) $(CFLAGS) buildmark.c
 	$(CC) $(CFLAGS) $(LDFLAGS) $(LDFLAGS_SHLIB_EXPORT) \
 	      -o $(TARGET) buildmark.o $(OBJS) $(REGLIB) $(LIBS)
 
@@ -77,13 +77,13 @@
 	-rm -f $(TARGET) *.o
 	@for i in $(SUBDIRS); do \
 		echo "===> $(SDP)$$i"; \
 		( cd $$i && $(MAKE) $(MFLAGS_STATIC) SDP='$(SDP)' $@ ) || exit 1; \
 		echo "<=== $(SDP)$$i"; \
 	done
-	-rm -f include/ap_config.h
+	-rm -f include/ap_config_auto.h
 	-rm -f modules.c
 	-rm -f modules/Makefile
 	-rm -f regex/Makefile
 	-rm -f Makefile.config
 	-rm -f Makefile
 
@@ -108,11 +108,13 @@
 
 #Dependencies
 
 $(OBJS): Makefile
 
 # DO NOT REMOVE
-buildmark.o: buildmark.c include/conf.h os/unix/os.h include/httpd.h \
+buildmark.o: buildmark.c include/ap_config.h include/ap_config_auto.h \
+ os/unix/os.h include/ap_ctype.h include/hsregex.h include/httpd.h \
  include/alloc.h include/buff.h include/ap.h include/util_uri.h
-modules.o: modules.c include/httpd.h include/conf.h os/unix/os.h \
- include/alloc.h include/buff.h include/ap.h include/util_uri.h \
- include/http_config.h
+modules.o: modules.c include/httpd.h include/ap_config.h \
+ include/ap_config_auto.h os/unix/os.h include/ap_ctype.h \
+ include/hsregex.h include/alloc.h include/buff.h include/ap.h \
+ include/util_uri.h include/http_config.h
diff -BEr -U 6 apache_1.3.0/src/modules/example/Makefile.tmpl apache_1.3.1/src/modules/example/Makefile.tmpl
--- apache_1.3.0/src/modules/example/Makefile.tmpl	1998-05-10 21:04:31.000000000 +0800
+++ apache_1.3.1/src/modules/example/Makefile.tmpl	1998-07-13 19:32:44.000000000 +0800
@@ -2,11 +2,13 @@
 #Dependencies
 
 $(OBJS) $(OBJS_PIC): Makefile
 
 # DO NOT REMOVE
 mod_example.o: mod_example.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_main.h \
- $(INCDIR)/http_protocol.h $(INCDIR)/util_script.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_main.h $(INCDIR)/http_protocol.h \
+ $(INCDIR)/util_script.h
diff -BEr -U 6 apache_1.3.0/src/modules/example/mod_example.c apache_1.3.1/src/modules/example/mod_example.c
--- apache_1.3.0/src/modules/example/mod_example.c	1998-05-06 19:14:43.000000000 +0800
+++ apache_1.3.1/src/modules/example/mod_example.c	1998-06-15 05:10:25.000000000 +0800
@@ -113,13 +113,13 @@
  * trace.  As each API callback is made to us, we'll tack on the particulars
  * to whatever we've already recorded.  To avoid massive memory bloat as
  * directories are walked again and again, we record the routine/environment
  * the first time (non-request context only), and ignore subsequent calls for
  * the same routine/environment.
  */
-static char *trace = NULL;
+static const char *trace = NULL;
 static table *static_calls_made = NULL;
 
 /*
  * To avoid leaking memory from pools other than the per-request one, we
  * allocate a module-private pool, and then use a sub-pool of that which gets
  * freed each time we modify the trace.  That way previous layers of trace
@@ -326,17 +326,17 @@
 #define TRACE_NOTE "example-trace"
 
 static void trace_add(server_rec *s, request_rec *r, excfg *mconfig,
                       const char *note)
 {
 
-    char *sofar;
+    const char *sofar;
     char *addon;
     char *where;
     pool *p;
-    char *trace_copy;
+    const char *trace_copy;
 
     /*
      * Make sure our pools and tables are set up - we need 'em.
      */
     setup_module_cells();
     /*
diff -BEr -U 6 apache_1.3.0/src/modules/experimental/Makefile.tmpl apache_1.3.1/src/modules/experimental/Makefile.tmpl
--- apache_1.3.0/src/modules/experimental/Makefile.tmpl	1998-05-10 21:04:32.000000000 +0800
+++ apache_1.3.1/src/modules/experimental/Makefile.tmpl	1998-07-13 19:32:44.000000000 +0800
@@ -2,11 +2,12 @@
 #Dependencies
 
 $(OBJS) $(OBJS_PIC): Makefile
 
 # DO NOT REMOVE
 mod_mmap_static.o: mod_mmap_static.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_log.h \
- $(INCDIR)/http_protocol.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_core.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h \
+ $(INCDIR)/http_request.h $(INCDIR)/http_core.h
diff -BEr -U 6 apache_1.3.0/src/modules/experimental/mod_mmap_static.c apache_1.3.1/src/modules/experimental/mod_mmap_static.c
--- apache_1.3.0/src/modules/experimental/mod_mmap_static.c	1998-04-11 20:00:38.000000000 +0800
+++ apache_1.3.1/src/modules/experimental/mod_mmap_static.c	1998-07-12 17:35:42.000000000 +0800
@@ -277,18 +277,23 @@
 {
     a_server_config *sconf;
     a_file tmp;
     a_file *match;
     int res;
 
+    sconf = ap_get_module_config(r->server->module_config, &mmap_static_module);
+
+    /* we only operate when at least one mmapfile directive was used */
+    if (ap_is_empty_table(sconf->files))
+	return DECLINED;
+
     /* we require other modules to first set up a filename */
     res = core_module.translate_handler(r);
     if (res == DECLINED || !r->filename) {
 	return res;
     }
-    sconf = ap_get_module_config(r->server->module_config, &mmap_static_module);
     tmp.filename = r->filename;
     match = (a_file *)bsearch(&tmp, sconf->files->elts, sconf->files->nelts,
 	sizeof(a_file), file_compare);
     if (match == NULL) {
 	return DECLINED;
     }
Only in apache_1.3.0/src/modules: Makefile
diff -BEr -U 6 apache_1.3.0/src/modules/proxy/Makefile.tmpl apache_1.3.1/src/modules/proxy/Makefile.tmpl
--- apache_1.3.0/src/modules/proxy/Makefile.tmpl	1998-05-30 02:20:58.000000000 +0800
+++ apache_1.3.1/src/modules/proxy/Makefile.tmpl	1998-07-13 19:32:45.000000000 +0800
@@ -50,42 +50,51 @@
 #Dependencies
 
 $(OBJS) $(OBJS_PIC): Makefile
 
 # DO NOT REMOVE
 mod_proxy.o: mod_proxy.c mod_proxy.h $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/explain.h $(INCDIR)/http_log.h \
- $(INCDIR)/http_vhost.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/explain.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_vhost.h
 proxy_cache.o: proxy_cache.c mod_proxy.h $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/explain.h $(INCDIR)/http_log.h \
- $(INCDIR)/http_main.h $(INCDIR)/util_date.h \
- $(INCDIR)/multithread.h $(INCDIR)/ap_md5.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/explain.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_main.h \
+ $(INCDIR)/util_date.h $(INCDIR)/multithread.h \
+ $(INCDIR)/ap_md5.h
 proxy_connect.o: proxy_connect.c mod_proxy.h $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/explain.h $(INCDIR)/http_log.h \
- $(INCDIR)/http_main.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/explain.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_main.h
 proxy_ftp.o: proxy_ftp.c mod_proxy.h $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/explain.h $(INCDIR)/http_main.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/explain.h \
+ $(INCDIR)/http_main.h $(INCDIR)/http_log.h
 proxy_http.o: proxy_http.c mod_proxy.h $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/explain.h $(INCDIR)/http_log.h \
- $(INCDIR)/http_main.h $(INCDIR)/http_core.h \
- $(INCDIR)/util_date.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/explain.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_main.h \
+ $(INCDIR)/http_core.h $(INCDIR)/util_date.h
 proxy_util.o: proxy_util.c mod_proxy.h $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/explain.h $(INCDIR)/http_main.h $(INCDIR)/ap_md5.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/explain.h \
+ $(INCDIR)/http_main.h $(INCDIR)/ap_md5.h \
  $(INCDIR)/multithread.h $(INCDIR)/http_log.h
diff -BEr -U 6 apache_1.3.0/src/modules/proxy/mod_proxy.c apache_1.3.1/src/modules/proxy/mod_proxy.c
--- apache_1.3.0/src/modules/proxy/mod_proxy.c	1998-05-28 06:56:02.000000000 +0800
+++ apache_1.3.1/src/modules/proxy/mod_proxy.c	1998-07-10 03:45:55.000000000 +0800
@@ -241,13 +241,14 @@
 /* servers like Netscape's allow this and access hosts from the local */
 /* domain in this case. I think it is better to redirect to a FQDN, since */
 /* these will later be found in the bookmarks files. */
 /* The "ProxyDomain" directive determines what domain will be appended */
 static int proxy_needsdomain(request_rec *r, const char *url, const char *domain)
 {
-    char *nuri, *ref;
+    char *nuri;
+    const char *ref;
 
     /* We only want to worry about GETs */
     if (!r->proxyreq || r->method_number != M_GET || !r->parsed_uri.hostname)
 	return DECLINED;
 
     /* If host does contain a dot already, or it is "localhost", decline */
@@ -401,12 +402,13 @@
     ps->cache.defaultexpire = DEFAULT_CACHE_EXPIRE;
     ps->cache.lmfactor = DEFAULT_CACHE_LMFACTOR;
     ps->cache.gcinterval = -1;
     /* at these levels, the cache can have 2^18 directories (256,000)  */
     ps->cache.dirlevels = 3;
     ps->cache.dirlength = 1;
+    ps->cache.cache_completion = DEFAULT_CACHE_COMPLETION;
 
     return ps;
 }
 
 static const char *
      add_proxy(cmd_parms *cmd, void *dummy, char *f, char *r)
@@ -738,12 +740,28 @@
     }
 
     psf->recv_buffer_size = s;
     return NULL;
 }
 
+static const char*
+    set_cache_completion(cmd_parms *parms, void *dummy, char *arg)
+{
+    proxy_server_conf *psf =
+    ap_get_module_config(parms->server->module_config, &proxy_module);
+    int s = atoi(arg);
+    if (s > 100 || s < 0) {
+	return "CacheForceCompletion must be <= 100 percent, "
+               "or 0 for system default.";
+    }
+
+    if (s > 0)
+      psf->cache.cache_completion = ((float)s / 100);
+    return NULL;    
+}
+
 static const handler_rec proxy_handlers[] =
 {
     {"proxy-server", proxy_handler},
     {NULL}
 };
 
@@ -780,12 +798,14 @@
     {"CacheDirLevels", set_cache_dirlevels, NULL, RSRC_CONF, TAKE1,
      "The number of levels of subdirectories in the cache"},
     {"CacheDirLength", set_cache_dirlength, NULL, RSRC_CONF, TAKE1,
      "The number of characters in subdirectory names"},
     {"NoCache", set_cache_exclude, NULL, RSRC_CONF, ITERATE,
      "A list of names, hosts or domains for which caching is *not* provided"},
+    {"CacheForceCompletion", set_cache_completion, NULL, RSRC_CONF, TAKE1,
+     "Force a http cache completion after this percentage is loaded"},
     {NULL}
 };
 
 module MODULE_VAR_EXPORT proxy_module =
 {
     STANDARD_MODULE_STUFF,
diff -BEr -U 6 apache_1.3.0/src/modules/proxy/mod_proxy.h apache_1.3.1/src/modules/proxy/mod_proxy.h
--- apache_1.3.0/src/modules/proxy/mod_proxy.h	1998-05-28 06:56:04.000000000 +0800
+++ apache_1.3.1/src/modules/proxy/mod_proxy.h	1998-07-10 03:45:56.000000000 +0800
@@ -181,41 +181,43 @@
 };
 
 #define DEFAULT_CACHE_SPACE 5
 #define DEFAULT_CACHE_MAXEXPIRE SEC_ONE_DAY
 #define DEFAULT_CACHE_EXPIRE    SEC_ONE_HR
 #define DEFAULT_CACHE_LMFACTOR (0.1)
+#define DEFAULT_CACHE_COMPLETION (0.9)
 
 /* static information about the local cache */
 struct cache_conf {
     const char *root;		/* the location of the cache directory */
-    int space;			/* Maximum cache size (in 1024 bytes) */
-    int maxexpire;		/* Maximum time to keep cached files in secs */
-    int defaultexpire;		/* default time to keep cached file in secs */
+    off_t space;			/* Maximum cache size (in 1024 bytes) */
+    time_t maxexpire;		/* Maximum time to keep cached files in secs */
+    time_t defaultexpire;	/* default time to keep cached file in secs */
     double lmfactor;		/* factor for estimating expires date */
-    int gcinterval;		/* garbage collection interval, in seconds */
+    time_t gcinterval;		/* garbage collection interval, in seconds */
     int dirlevels;		/* Number of levels of subdirectories */
     int dirlength;		/* Length of subdirectory names */
+    float cache_completion;	/* Force cache completion after this point */
 };
 
 typedef struct {
     struct cache_conf cache;	/* cache configuration */
     array_header *proxies;
     array_header *aliases;
     array_header *raliases;
     array_header *noproxies;
     array_header *dirconn;
     array_header *nocaches;
     char *domain;		/* domain name to use in absence of a domain name in the request */
     int req;			/* true if proxy requests are enabled */
-    int recv_buffer_size;
+    size_t recv_buffer_size;
 } proxy_server_conf;
 
 struct hdr_entry {
-    char *field;
-    char *value;
+    const char *field;
+    const char *value;
 };
 
 /* caching information about a request */
 struct cache_req {
     request_rec *req;		/* the request */
     char *url;			/* the URL requested */
@@ -226,15 +228,17 @@
 				   and may be returned, or NULL if the file is
 				   not cached (or must be reloaded) */
     time_t expire;		/* calculated expire date of cached entity */
     time_t lmod;		/* last-modified date of cached entity */
     time_t date;		/* the date the cached file was last touched */
     int version;		/* update count of the file */
-    unsigned int len;		/* content length */
+    off_t len;			/* content length */
     char *protocol;		/* Protocol, and major/minor number, e.g. HTTP/1.1 */
     int status;			/* the status of the cached file */
+    unsigned int written;	/* total *content* bytes written to cache */
+    float cache_completion;	/* specific to this request */
     char *resp_line;		/* the whole status like (protocol, code + message) */
     array_header *hdrs;		/* the HTTP headers of the file */
 };
 
 /* Function prototypes */
 
@@ -269,18 +273,18 @@
 int ap_proxy_hex2c(const char *x);
 void ap_proxy_c2hex(int ch, char *x);
 char *ap_proxy_canonenc(pool *p, const char *x, int len, enum enctype t,
 		     int isenc);
 char *ap_proxy_canon_netloc(pool *p, char **const urlp, char **userp,
 			 char **passwordp, char **hostp, int *port);
-char *ap_proxy_date_canon(pool *p, char *x);
+const char *ap_proxy_date_canon(pool *p, const char *x);
 array_header *ap_proxy_read_headers(pool *p, char *buffer, int size, BUFF *f);
 long int ap_proxy_send_fb(BUFF *f, request_rec *r, BUFF *f2, struct cache_req *c);
 struct hdr_entry *ap_proxy_get_header(array_header *hdrs_arr, const char *name);
-struct hdr_entry *ap_proxy_add_header(array_header *hdrs_arr, char *field,
-				   char *value, int rep);
+struct hdr_entry *ap_proxy_add_header(array_header *hdrs_arr, const char *field,
+				      const char *value, int rep);
 void ap_proxy_del_header(array_header *hdrs_arr, const char *field);
 void ap_proxy_send_headers(request_rec *r, const char *respline,
 			array_header *hdrs_arr);
 int ap_proxy_liststr(const char *list, const char *val);
 void ap_proxy_hash(const char *it, char *val, int ndepth, int nlength);
 int ap_proxy_hex2sec(const char *x);
diff -BEr -U 6 apache_1.3.0/src/modules/proxy/proxy_cache.c apache_1.3.1/src/modules/proxy/proxy_cache.c
--- apache_1.3.0/src/modules/proxy/proxy_cache.c	1998-05-30 02:20:58.000000000 +0800
+++ apache_1.3.1/src/modules/proxy/proxy_cache.c	1998-07-10 03:45:56.000000000 +0800
@@ -68,39 +68,43 @@
 #endif /* WIN32 */
 #include "multithread.h"
 #include "ap_md5.h"
 
 DEF_Explain
 
-#ifndef abs
-#define	abs(c)	((c) >= 0 ? (c) : -(c))
-#endif
-
 struct gc_ent {
     unsigned long int len;
     time_t expire;
     char file[HASH_LEN + 1];
-
 };
 
-static int gcdiff(const void *ap, const void *bp)
-{
-    const struct gc_ent *a = *(const struct gc_ent * const *) ap;
-    const struct gc_ent *b = *(const struct gc_ent * const *) bp;
-
-    if (a->expire > b->expire)
-	return 1;
-    else if (a->expire < b->expire)
-	return -1;
-    else
-	return 0;
-}
-
-static int curbytes, cachesize, every;
-static unsigned long int curblocks;
-static time_t garbage_now, garbage_expire;
+/* Poor man's 61 bit arithmetic */
+typedef struct {
+    long lower;	/* lower 30 bits of result */
+    long upper; /* upper 31 bits of result */
+} long61_t;
+
+/* FIXME: The block size can be different on a `per file system' base.
+ * This would make automatic detection highly OS specific.
+ * In the GNU fileutils code for du(1), you can see how complicated it can
+ * become to detect the block size. And, with BSD-4.x fragments, it
+ * it even more difficult to get precise results.
+ * As a compromise (and to improve on the incorrect counting of cache
+ * size on byte level, omitting directory sizes entirely, which was
+ * used up to apache-1.3b7) we're rounding to multiples of 512 here.
+ * Your file system may be using larger blocks (I certainly hope so!)
+ * but it will hardly use smaller blocks.
+ * (So this approximation is still closer to reality than the old behavior).
+ * The best solution would be automatic detection, the next best solution
+ * IMHO is a sensible default and the possibility to override it.
+ */
+
+#define ROUNDUP2BLOCKS(_bytes) (((_bytes)+block_size-1) & ~(block_size-1))
+static long block_size = 512;	/* this must be a power of 2 */
+static long61_t curbytes, cachesize;
+static time_t every, garbage_now, garbage_expire;
 static char *filename;
 static mutex *garbage_mutex = NULL;
 
 
 int ap_proxy_garbage_init(server_rec *r, pool *p)
 {
@@ -111,12 +115,16 @@
 }
 
 
 static int sub_garbage_coll(request_rec *r, array_header *files,
 			    const char *cachedir, const char *cachesubdir);
 static void help_proxy_garbage_coll(request_rec *r);
+#if !defined(WIN32) && !defined(MPE) && !defined(__EMX__)
+static void detached_proxy_garbage_coll(request_rec *r);
+#endif
+
 
 void ap_proxy_garbage_coll(request_rec *r)
 {
     static int inside = 0;
 
     (void) ap_acquire_mutex(garbage_mutex);
@@ -125,40 +133,163 @@
 	return;
     }
     else
 	inside = 1;
     (void) ap_release_mutex(garbage_mutex);
 
+    ap_block_alarms();		/* avoid SIGALRM on big cache cleanup */
+#if !defined(WIN32) && !defined(MPE) && !defined(__EMX__)
+    detached_proxy_garbage_coll(r);
+#else
     help_proxy_garbage_coll(r);
+#endif
+    ap_unblock_alarms();
 
     (void) ap_acquire_mutex(garbage_mutex);
     inside = 0;
     (void) ap_release_mutex(garbage_mutex);
 }
 
 
+static void
+add_long61 (long61_t *accu, long val)
+{
+    /* Add in lower 30 bits */
+    accu->lower += (val & 0x3FFFFFFFL);
+    /* add in upper bits, and carry */
+    accu->upper += (val >> 30) + ((accu->lower & ~0x3FFFFFFFL) != 0L);
+    /* Clear carry */
+    accu->lower &= 0x3FFFFFFFL;
+}
+
+static void
+sub_long61 (long61_t *accu, long val)
+{
+    int carry = (val & 0x3FFFFFFFL) > accu->lower;
+    /* Subtract lower 30 bits */
+    accu->lower = accu->lower - (val & 0x3FFFFFFFL) + ((carry) ? 0x40000000 : 0);
+    /* add in upper bits, and carry */
+    accu->upper -= (val >> 30) + carry;
+}
+
+/* Compare two long61's:
+ * return <0 when left < right
+ * return  0 when left == right
+ * return >0 when left > right
+ */
+static long
+cmp_long61 (long61_t *left, long61_t *right)
+{
+    return (left->upper == right->upper) ? (left->lower - right->lower)
+					 : (left->upper - right->upper);
+}
+
+/* Compare two gc_ent's, sort them by expiration date */
+static int gcdiff(const void *ap, const void *bp)
+{
+    const struct gc_ent *a = (const struct gc_ent * const) ap;
+    const struct gc_ent *b = (const struct gc_ent * const) bp;
+
+    if (a->expire > b->expire)
+	return 1;
+    else if (a->expire < b->expire)
+	return -1;
+    else
+	return 0;
+}
+
+#if !defined(WIN32) && !defined(MPE) && !defined(__EMX__)
+static void detached_proxy_garbage_coll(request_rec *r)
+{
+    pid_t pid;
+    int status;
+    pid_t pgrp;
+
+    switch (pid = fork()) {
+	case -1:
+	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+			 "proxy: fork() for cache cleanup failed");
+	    return;
+
+	case 0:	/* Child */
+
+	    /* close all sorts of things, including the socket fd */
+	    ap_cleanup_for_exec();
+
+	    /* Fork twice to disassociate from the child */
+	    switch (pid = fork()) {
+		case -1:
+		    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+			 "proxy: fork(2nd) for cache cleanup failed");
+		    exit(1);
+
+		case 0:	/* Child */
+		    /* The setpgrp() stuff was snarfed from http_main.c */
+#ifndef NO_SETSID
+		    if ((pgrp = setsid()) == -1) {
+			perror("setsid");
+			fprintf(stderr, "httpd: setsid failed\n");
+			exit(1);
+		    }
+#elif defined(NEXT) || defined(NEWSOS)
+		    if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
+			perror("setpgrp");
+			fprintf(stderr, "httpd: setpgrp or getpgrp failed\n");
+			exit(1);
+		    }
+#else
+		    if ((pgrp = setpgrp(getpid(), 0)) == -1) {
+			perror("setpgrp");
+			fprintf(stderr, "httpd: setpgrp failed\n");
+			exit(1);
+		    }
+#endif
+		    help_proxy_garbage_coll(r);
+		    exit(0);
+
+		default:    /* Father */
+		    /* After grandson has been forked off, */
+		    /* there's nothing else to do. */
+		    exit(0);		    
+	    }
+	default:
+	    /* Wait until grandson has been forked off */
+	    /* (without wait we'd leave a zombie) */
+	    waitpid(pid, &status, 0);
+	    return;
+    }
+}
+#endif /* ndef WIN32 */
+
 static void help_proxy_garbage_coll(request_rec *r)
 {
     const char *cachedir;
     void *sconf = r->server->module_config;
     proxy_server_conf *pconf =
     (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
     const struct cache_conf *conf = &pconf->cache;
     array_header *files;
     struct stat buf;
-    struct gc_ent *fent, **elts;
+    struct gc_ent *fent;
     int i, timefd;
-    static time_t lastcheck = BAD_DATE;		/* static data!!! */
+    static time_t lastcheck = BAD_DATE;		/* static (per-process) data!!! */
 
     cachedir = conf->root;
-    cachesize = conf->space;
+    /* configured size is given in kB. Make it bytes, convert to long61_t: */
+    cachesize.lower = cachesize.upper = 0;
+    add_long61(&cachesize, conf->space << 10);
     every = conf->gcinterval;
 
     if (cachedir == NULL || every == -1)
 	return;
     garbage_now = time(NULL);
+    /* Usually, the modification time of <cachedir>/.time can only increase.
+     * Thus, even with several child processes having their own copy of
+     * lastcheck, if time(NULL) still < lastcheck then it's not time
+     * for GC yet.
+     */
     if (garbage_now != -1 && lastcheck != BAD_DATE && garbage_now < lastcheck + every)
 	return;
 
     ap_block_alarms();		/* avoid SIGALRM on big cache cleanup */
 
     filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
@@ -173,13 +304,13 @@
 	}
 	if ((timefd = creat(filename, 0666)) == -1) {
 	    if (errno != EEXIST)
 		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			     "proxy: creat(%s)", filename);
 	    else
-		lastcheck = abs(garbage_now);	/* someone else got in there */
+		lastcheck = garbage_now;	/* someone else got in there */
 	    ap_unblock_alarms();
 	    return;
 	}
 	close(timefd);
     }
     else {
@@ -189,28 +320,30 @@
 	    return;
 	}
 	if (utime(filename, NULL) == -1)
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			 "proxy: utimes(%s)", filename);
     }
-    files = ap_make_array(r->pool, 100, sizeof(struct gc_ent *));
-    curblocks = 0;
-    curbytes = 0;
+    files = ap_make_array(r->pool, 100, sizeof(struct gc_ent));
+    curbytes.upper = curbytes.lower = 0L;
 
     sub_garbage_coll(r, files, cachedir, "/");
 
-    if (curblocks < cachesize || curblocks + curbytes <= cachesize) {
+    if (cmp_long61(&curbytes, &cachesize) < 0L) {
+	ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server,
+			 "proxy GC: Cache is %ld%% full (nothing deleted)",
+			 (long)(((curbytes.upper<<20)|(curbytes.lower>>10))*100/conf->space));
 	ap_unblock_alarms();
 	return;
     }
 
-    qsort(files->elts, files->nelts, sizeof(struct gc_ent *), gcdiff);
+    /* sort the files we found by expiration date */
+    qsort(files->elts, files->nelts, sizeof(struct gc_ent), gcdiff);
 
-    elts = (struct gc_ent **) files->elts;
     for (i = 0; i < files->nelts; i++) {
-	fent = elts[i];
+	fent = &((struct gc_ent *) files->elts)[i];
 	sprintf(filename, "%s%s", cachedir, fent->file);
 	Explain3("GC Unlinking %s (expiry %ld, garbage_now %ld)", filename, fent->expire, garbage_now);
 #if TESTING
 	fprintf(stderr, "Would unlink %s\n", filename);
 #else
 	if (unlink(filename) == -1) {
@@ -218,22 +351,21 @@
 		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			     "proxy gc: unlink(%s)", filename);
 	}
 	else
 #endif
 	{
-	    curblocks -= fent->len >> 10;
-	    curbytes -= fent->len & 0x3FF;
-	    if (curbytes < 0) {
-		curbytes += 1024;
-		curblocks--;
-	    }
-	    if (curblocks < cachesize || curblocks + curbytes <= cachesize)
+	    sub_long61(&curbytes, ROUNDUP2BLOCKS(fent->len));
+	    if (cmp_long61(&curbytes, &cachesize) < 0)
 		break;
 	}
     }
+
+    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r->server,
+			 "proxy GC: Cache is %ld%% full (%d deleted)",
+			 (long)(((curbytes.upper<<20)|(curbytes.lower>>10))*100/conf->space), i);
     ap_unblock_alarms();
 }
 
 static int sub_garbage_coll(request_rec *r, array_header *files,
 			  const char *cachebasedir, const char *cachesubdir)
 {
@@ -339,12 +471,15 @@
 #if TESTING
 		fprintf(stderr, "Would remove directory %s\n", newcachedir);
 #else
 		rmdir(newcachedir);
 #endif
 		--nfiles;
+	    } else {
+		/* Directory is not empty. Account for its size: */
+		add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
 	    }
 	    continue;
 	}
 #endif
 
 	i = read(fd, line, 26);
@@ -375,28 +510,20 @@
 /*
  * we need to calculate an 'old' factor, and remove the 'oldest' files
  * so that the space requirement is met; sort by the expires date of the
  * file.
  *
  */
-	/* FIXME: We should make the array an array of gc_ents, not gc_ent *s
-	 */
-	fent = ap_palloc(r->pool, sizeof(struct gc_ent));
+	fent = (struct gc_ent *) ap_push_array(files);
 	fent->len = buf.st_size;
 	fent->expire = garbage_expire;
 	strcpy(fent->file, cachesubdir);
 	strcat(fent->file, ent->d_name);
-	*(struct gc_ent **) ap_push_array(files) = fent;
 
 /* accumulate in blocks, to cope with directories > 4Gb */
-	curblocks += buf.st_size >> 10;		/* Kbytes */
-	curbytes += buf.st_size & 0x3FF;
-	if (curbytes >= 1024) {
-	    curbytes -= 1024;
-	    curblocks++;
-	}
+	add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
     }
 
     closedir(dir);
 
     return nfiles;
 
@@ -464,13 +591,13 @@
 	return -1;
     if (c->len != -1) {		/* add a content-length header */
 	struct hdr_entry *q;
 	q = ap_proxy_get_header(c->hdrs, "Content-Length");
 	if (q == NULL) {
 	    strp = ap_palloc(p, 15);
-	    ap_snprintf(strp, 15, "%u", c->len);
+	    ap_snprintf(strp, 15, "%lu", (unsigned long)c->len);
 	    ap_proxy_add_header(c->hdrs, "Content-Length", strp, HDR_REP);
 	}
     }
     return 1;
 }
 
@@ -489,13 +616,14 @@
  *         if last modified after if-modified-since then add
  *            last modified date to request
  */
 int ap_proxy_cache_check(request_rec *r, char *url, struct cache_conf *conf,
 		      struct cache_req **cr)
 {
-    char hashfile[66], *imstr, *pragma, *auth;
+    char hashfile[66];
+    const char *imstr, *pragma, *auth;
     struct cache_req *c;
     time_t now;
     BUFF *cachefp;
     int cfd, i;
     const long int zero = 0L;
     void *sconf = r->server->module_config;
@@ -562,14 +690,17 @@
 			 "proxy: bad (short?) cache file: %s", c->filename);
 	if (i != 1) {
 	    ap_pclosef(r->pool, cachefp->fd);
 	    cachefp = NULL;
 	}
     }
+/* fixed?  in this case, we want to get the headers from the remote server
+   it will be handled later if we don't do this (I hope ;-)
     if (cachefp == NULL)
 	c->hdrs = ap_make_array(r->pool, 2, sizeof(struct hdr_entry));
+*/
     /* FIXME: Shouldn't we check the URL somewhere? */
     now = time(NULL);
 /* Ok, have we got some un-expired data? */
     if (cachefp != NULL && c->expire != BAD_DATE && now < c->expire) {
 	Explain0("Unexpired data available");
 /* check IMS */
@@ -587,13 +718,13 @@
 		q = ap_proxy_get_header(c->hdrs, "Expires");
 		if (q != NULL && q->value != NULL)
 		    ap_table_set(r->headers_out, "Expires", q->value);
 	    }
 	    ap_pclosef(r->pool, cachefp->fd);
 	    Explain0("Use local copy, cached file hasn't changed");
-	    return USE_LOCAL_COPY;
+	    return HTTP_NOT_MODIFIED;
 	}
 
 /* Ok, has been modified */
 	Explain0("Local copy modified, send it");
 	r->status_line = strchr(c->resp_line, ' ') + 1;
 	r->status = c->status;
@@ -732,13 +863,13 @@
     now = time(NULL);
 
     if (date == BAD_DATE) {	/* No, or bad date */
 /* no date header! */
 /* add one; N.B. use the time _now_ rather than when we were checking the cache
  */
-	date = abs(now);
+	date = now;
 	p = ap_gm_timestr_822(r->pool, now);
 	dates = ap_proxy_add_header(resp_hdrs, "Date", p, HDR_REP);
 	Explain0("Added date header");
     }
 
 /* check last-modified date */
@@ -772,16 +903,16 @@
     if (expc == BAD_DATE) {
 	if (lmod != BAD_DATE) {
 	    double x = (double) (date - lmod) * conf->cache.lmfactor;
 	    double maxex = conf->cache.maxexpire;
 	    if (x > maxex)
 		x = maxex;
-	    expc = abs(now) + (int) x;
+	    expc = now + (int) x;
 	}
 	else
-	    expc = abs(now) + conf->cache.defaultexpire;
+	    expc = now + conf->cache.defaultexpire;
 	Explain1("Expiry date calculated %ld", expc);
     }
 
 /* get the content-length header */
     clen = ap_proxy_get_header(resp_hdrs, "Content-Length");
     if (clen == NULL)
@@ -817,13 +948,13 @@
 				 "proxy: error updating cache file %s",
 				 c->filename);
 	    }
 	    ap_pclosef(r->pool, c->fp->fd);
 	    Explain0("Remote document not modified, use local copy");
 	    /* CHECKME: Is this right? Shouldn't we check IMS again here? */
-	    return USE_LOCAL_COPY;
+	    return HTTP_NOT_MODIFIED;
 	}
 	else {
 /* return the whole document */
 	    Explain0("Remote document updated, sending");
 	    r->status_line = strchr(c->resp_line, ' ') + 1;
 	    r->status = c->status;
@@ -903,27 +1034,32 @@
     server_rec *s = c->req->server;
     long int bc;
 
     if (c->fp == NULL)
 	return;
 
+/* don't care how much was sent, but rather how much was written to cache
     ap_bgetopt(c->req->connection->client, BO_BYTECT, &bc);
+ */
+    bc = c->written;
 
     if (c->len != -1) {
 /* file lengths don't match; don't cache it */
 	if (bc != c->len) {
 	    ap_pclosef(c->req->pool, c->fp->fd);	/* no need to flush */
 	    unlink(c->tempfile);
 	    return;
 	}
     }
+/* don't care if aborted, cache it if fully retrieved from host!
     else if (c->req->connection->aborted) {
-	ap_pclosef(c->req->pool, c->fp->fd);	/* no need to flush */
+	ap_pclosef(c->req->pool, c->fp->fd);	/ no need to flush /
 	unlink(c->tempfile);
 	return;
     }
+*/
     else {
 /* update content-length of file */
 	char buff[9];
 	off_t curpos;
 
 	c->len = bc;
diff -BEr -U 6 apache_1.3.0/src/modules/proxy/proxy_connect.c apache_1.3.1/src/modules/proxy/proxy_connect.c
--- apache_1.3.0/src/modules/proxy/proxy_connect.c	1998-05-28 06:56:04.000000000 +0800
+++ apache_1.3.1/src/modules/proxy/proxy_connect.c	1998-06-08 22:23:50.000000000 +0800
@@ -159,24 +159,24 @@
 	return ap_proxyerror(r, err);	/* give up */
 
     sock = ap_psocket(r->pool, PF_INET, SOCK_STREAM, IPPROTO_TCP);
     if (sock == -1) {
 	ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 		    "proxy: error creating socket");
-	return SERVER_ERROR;
+	return HTTP_INTERNAL_SERVER_ERROR;
     }
 
 #ifndef WIN32
     if (sock >= FD_SETSIZE) {
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
 	    "proxy_connect_handler: filedescriptor (%u) "
 	    "larger than FD_SETSIZE (%u) "
 	    "found, you probably need to rebuild Apache with a "
 	    "larger FD_SETSIZE", sock, FD_SETSIZE);
 	ap_pclosesocket(r->pool, sock);
-	return SERVER_ERROR;
+	return HTTP_INTERNAL_SERVER_ERROR;
     }
 #endif
 
     j = 0;
     while (server_hp.h_addr_list[j] != NULL) {
 	memcpy(&server.sin_addr, server_hp.h_addr_list[j],
diff -BEr -U 6 apache_1.3.0/src/modules/proxy/proxy_ftp.c apache_1.3.1/src/modules/proxy/proxy_ftp.c
--- apache_1.3.0/src/modules/proxy/proxy_ftp.c	1998-05-28 06:56:05.000000000 +0800
+++ apache_1.3.1/src/modules/proxy/proxy_ftp.c	1998-07-10 03:45:56.000000000 +0800
@@ -192,14 +192,14 @@
     char linebuff[100], buff[5];
 
     len = ap_bgets(linebuff, sizeof linebuff, f);
     if (len == -1)
 	return -1;
 /* check format */
-    if (len < 5 || !isdigit(linebuff[0]) || !isdigit(linebuff[1]) ||
-	!isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
+    if (len < 5 || !ap_isdigit(linebuff[0]) || !ap_isdigit(linebuff[1]) ||
+	!ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
 	status = 0;
     else
 	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
 
     if (linebuff[len - 1] != '\n') {
 	(void)ap_bskiplf(f);
@@ -233,14 +233,14 @@
     char *mb = msgbuf,
 	 *me = &msgbuf[msglen];
 
     len = ap_bgets(linebuff, sizeof linebuff, f);
     if (len == -1)
 	return -1;
-    if (len < 5 || !isdigit(linebuff[0]) || !isdigit(linebuff[1]) ||
-	!isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
+    if (len < 5 || !ap_isdigit(linebuff[0]) || !ap_isdigit(linebuff[1]) ||
+	!ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
 	status = 0;
     else
 	status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
 
     mb = ap_cpystrn(mb, linebuff+4, me - mb);
 
@@ -373,14 +373,14 @@
 	      link_ptr[n - 1] = '\0';
 	    ap_snprintf(urlptr, sizeof(urlptr), "%s%s%s", url+hostlen, (url[strlen(url) - 1] == '/' ? "" : "/"), filename);
 	    ap_snprintf(buf2, sizeof(buf2), "%s <A HREF=\"%s\">%s %s</A>\n", buf, filename, filename, link_ptr);
 	    ap_cpystrn(buf, buf2, sizeof(buf));
 	    n = strlen(buf);
 	}
-	else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || isdigit(buf[0])) {
-	    if (isdigit(buf[0])) {	/* handle DOS dir */
+	else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || ap_isdigit(buf[0])) {
+	    if (ap_isdigit(buf[0])) {	/* handle DOS dir */
 		searchptr = strchr(buf, '<');
 		if (searchptr != NULL)
 		    *searchptr = '[';
 		searchptr = strchr(buf, '>');
 		if (searchptr != NULL)
 		    *searchptr = ']';
@@ -496,13 +496,13 @@
     int resplen;
     char *size = NULL;
 
 /* we only support GET and HEAD */
 
     if (r->method_number != M_GET)
-	return NOT_IMPLEMENTED;
+	return HTTP_NOT_IMPLEMENTED;
 
 /* allocate a buffer for the response message */
 	resplen = MAX_STRING_LEN;
 	resp = (char *)ap_palloc(r->pool, resplen);
 
 /* We break the URL into host, port, path-search */
@@ -540,13 +540,13 @@
 	passlen = strlen(password);
     }
 
     strp = strchr(host, ':');
     if (strp != NULL) {
 	*(strp++) = '\0';
-	if (isdigit(*strp))
+	if (ap_isdigit(*strp))
 	    port = atoi(strp);
     }
 
 /* check if ProxyBlock directive on this host */
     destaddr.s_addr = ap_inet_addr(host);
     for (i = 0; i < conf->noproxies->nelts; i++) {
@@ -569,13 +569,13 @@
 	return ap_proxyerror(r, err);	/* give up */
 
     sock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
     if (sock == -1) {
 	ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 		     "proxy: error creating socket");
-	return SERVER_ERROR;
+	return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     if (conf->recv_buffer_size) {
 	if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
 		       (const char *) &conf->recv_buffer_size, sizeof(int))
 	    == -1) {
@@ -587,13 +587,13 @@
     if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &one,
 		   sizeof(one)) == -1) {
 #ifndef _OSD_POSIX /* BS2000 has this option "always on" */
 	ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 		     "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
 	ap_pclosesocket(p, sock);
-	return SERVER_ERROR;
+	return HTTP_INTERNAL_SERVER_ERROR;
 #endif /*_OSD_POSIX*/
     }
 
 #ifdef SINIX_D_RESOLVER_BUG
     {
 	struct in_addr *ip_addr = (struct in_addr *) *server_hp.h_addr_list;
@@ -638,13 +638,13 @@
     if (i == -1) {
 	ap_kill_timeout(r);
 	return ap_proxyerror(r, "Error reading from remote server");
     }
     if (i != 220) {
 	ap_kill_timeout(r);
-	return BAD_GATEWAY;
+	return HTTP_BAD_GATEWAY;
     }
 
     Explain0("FTP: connected.");
 
     ap_bputs("USER ", f);
     ap_bwrite(f, user, userlen);
@@ -663,18 +663,18 @@
     if (i == 530) {
 	ap_kill_timeout(r);
 	return ap_proxyerror(r, "Not logged in");
     }
     if (i != 230 && i != 331) {
 	ap_kill_timeout(r);
-	return BAD_GATEWAY;
+	return HTTP_BAD_GATEWAY;
     }
 
     if (i == 331) {		/* send password */
 	if (password == NULL)
-	    return FORBIDDEN;
+	    return HTTP_FORBIDDEN;
 	ap_bputs("PASS ", f);
 	ap_bwrite(f, password, passlen);
 	ap_bputs(CRLF, f);
 	ap_bflush(f);
 	Explain1("FTP: PASS %s", password);
 /* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
@@ -691,13 +691,13 @@
 	if (i == 530) {
 	    ap_kill_timeout(r);
 	    return ap_proxyerror(r, "Not logged in");
 	}
 	if (i != 230 && i != 202) {
 	    ap_kill_timeout(r);
-	    return BAD_GATEWAY;
+	    return HTTP_BAD_GATEWAY;
 	}
     }
 
 /* set the directory */
 /* this is what we must do if we don't know the OS type of the remote
  * machine
@@ -721,17 +721,17 @@
 	if (i == -1) {
 	    ap_kill_timeout(r);
 	    return ap_proxyerror(r, "Error sending to remote server");
 	}
 	if (i == 550) {
 	    ap_kill_timeout(r);
-	    return NOT_FOUND;
+	    return HTTP_NOT_FOUND;
 	}
 	if (i != 250) {
 	    ap_kill_timeout(r);
-	    return BAD_GATEWAY;
+	    return HTTP_BAD_GATEWAY;
 	}
 
 	path = strp + 1;
     }
 
     if (parms != NULL && strncmp(parms, "type=", 5) == 0) {
@@ -758,13 +758,13 @@
 	if (i == -1) {
 	    ap_kill_timeout(r);
 	    return ap_proxyerror(r, "Error sending to remote server");
 	}
 	if (i != 200 && i != 504) {
 	    ap_kill_timeout(r);
-	    return BAD_GATEWAY;
+	    return HTTP_BAD_GATEWAY;
 	}
 /* Allow not implemented */
 	if (i == 504)
 	    parms[0] = '\0';
     }
 
@@ -772,13 +772,13 @@
     dsock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
     if (dsock == -1) {
 	ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 		     "proxy: error creating PASV socket");
 	ap_bclose(f);
 	ap_kill_timeout(r);
-	return SERVER_ERROR;
+	return HTTP_INTERNAL_SERVER_ERROR;
     }
 
     if (conf->recv_buffer_size) {
 	if (setsockopt(dsock, SOL_SOCKET, SO_RCVBUF,
 	       (const char *) &conf->recv_buffer_size, sizeof(int)) == -1) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
@@ -795,13 +795,13 @@
     if (i == -1) {
 	ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r->server,
 		     "PASV: control connection is toast");
 	ap_pclosesocket(p, dsock);
 	ap_bclose(f);
 	ap_kill_timeout(r);
-	return SERVER_ERROR;
+	return HTTP_INTERNAL_SERVER_ERROR;
     }
     else {
 	pasv[i - 1] = '\0';
 	pstr = strtok(pasv, " ");	/* separate result code */
 	if (pstr != NULL) {
 	    presult = atoi(pstr);
@@ -849,46 +849,46 @@
 	clen = sizeof(struct sockaddr_in);
 	if (getsockname(sock, (struct sockaddr *) &server, &clen) < 0) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			 "proxy: error getting socket address");
 	    ap_bclose(f);
 	    ap_kill_timeout(r);
-	    return SERVER_ERROR;
+	    return HTTP_INTERNAL_SERVER_ERROR;
 	}
 
 	dsock = ap_psocket(p, PF_INET, SOCK_STREAM, IPPROTO_TCP);
 	if (dsock == -1) {
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			 "proxy: error creating socket");
 	    ap_bclose(f);
 	    ap_kill_timeout(r);
-	    return SERVER_ERROR;
+	    return HTTP_INTERNAL_SERVER_ERROR;
 	}
 
 	if (setsockopt(dsock, SOL_SOCKET, SO_REUSEADDR, (void *) &one,
 		       sizeof(one)) == -1) {
 #ifndef _OSD_POSIX /* BS2000 has this option "always on" */
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			 "proxy: error setting reuseaddr option");
 	    ap_pclosesocket(p, dsock);
 	    ap_bclose(f);
 	    ap_kill_timeout(r);
-	    return SERVER_ERROR;
+	    return HTTP_INTERNAL_SERVER_ERROR;
 #endif /*_OSD_POSIX*/
 	}
 
 	if (bind(dsock, (struct sockaddr *) &server,
 		 sizeof(struct sockaddr_in)) == -1) {
 	    char buff[22];
 
 	    ap_snprintf(buff, sizeof(buff), "%s:%d", inet_ntoa(server.sin_addr), server.sin_port);
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			 "proxy: error binding to ftp data socket %s", buff);
 	    ap_bclose(f);
 	    ap_pclosesocket(p, dsock);
-	    return SERVER_ERROR;
+	    return HTTP_INTERNAL_SERVER_ERROR;
 	}
 	listen(dsock, 2);	/* only need a short queue */
     }
 
 /* set request */
     len = decodeenc(path);
@@ -920,23 +920,27 @@
 		if (i == -1) {
 		    ap_kill_timeout(r);
 		    return ap_proxyerror(r, "Error sending to remote server");
 		}
 		if (i == 550) {
 		    ap_kill_timeout(r);
-		    return NOT_FOUND;
+		    return HTTP_NOT_FOUND;
 		}
 		if (i != 250) {
 		    ap_kill_timeout(r);
-		    return BAD_GATEWAY;
+		    return HTTP_BAD_GATEWAY;
 		}
 		path = "";
 		len = 0;
 	    }
 	    else if (i == 213) { /* Size command ok */
-	        size = resp;
+		for (j = 0; j < resplen && ap_isdigit(resp[j]); j++)
+			;
+		resp[j] = '\0';
+		if (resp[0] != '\0')
+		    size = ap_pstrdup(p, resp);
 	    }
 	}
     }
 
     if (parms[0] == 'd') {
 	if (len != 0)
@@ -973,35 +977,37 @@
 	if (rc == -1) {
 	    ap_kill_timeout(r);
 	    return ap_proxyerror(r, "Error sending to remote server");
 	}
 	if (rc == 550) {
 	    ap_kill_timeout(r);
-	    return NOT_FOUND;
+	    return HTTP_NOT_FOUND;
 	}
 	if (rc != 250) {
 	    ap_kill_timeout(r);
-	    return BAD_GATEWAY;
+	    return HTTP_BAD_GATEWAY;
 	}
 
 	ap_bputs("LIST -lag" CRLF, f);
 	ap_bflush(f);
 	Explain0("FTP: LIST -lag");
 	rc = ftp_getrc(f);
 	Explain1("FTP: returned status %d", rc);
 	if (rc == -1)
 	    return ap_proxyerror(r, "Error sending to remote server");
     }
     ap_kill_timeout(r);
     if (rc != 125 && rc != 150 && rc != 226 && rc != 250)
-	return BAD_GATEWAY;
+	return HTTP_BAD_GATEWAY;
 
     r->status = 200;
     r->status_line = "200 OK";
 
     resp_hdrs = ap_make_array(p, 2, sizeof(struct hdr_entry));
+    c->hdrs = resp_hdrs;
+
     if (parms[0] == 'd')
 	ap_proxy_add_header(resp_hdrs, "Content-Type", "text/html", HDR_REP);
     else {
 	if (r->content_type != NULL) {
 	    ap_proxy_add_header(resp_hdrs, "Content-Type", r->content_type,
 			     HDR_REP);
@@ -1027,14 +1033,17 @@
 
     if (i != DECLINED) {
 	ap_pclosesocket(p, dsock);
 	ap_bclose(f);
 	return i;
     }
+
     cache = c->fp;
 
+    c->hdrs = resp_hdrs;
+
     if (!pasvmode) {		/* wait for connection */
 	ap_hard_timeout("proxy ftp data connect", r);
 	clen = sizeof(struct sockaddr_in);
 	do
 	    csd = accept(dsock, (struct sockaddr *) &server, &clen);
 	while (csd == -1 && errno == EINTR);
@@ -1042,13 +1051,13 @@
 	    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			 "proxy: failed to accept data connection");
 	    ap_pclosesocket(p, dsock);
 	    ap_bclose(f);
 	    ap_kill_timeout(r);
 	    ap_proxy_cache_error(c);
-	    return BAD_GATEWAY;
+	    return HTTP_BAD_GATEWAY;
 	}
 	ap_note_cleanups_for_socket(p, csd);
 	data = ap_bcreate(p, B_RDWR | B_SOCKET);
 	ap_bpushfd(data, csd, -1);
 	ap_kill_timeout(r);
     }
@@ -1093,15 +1102,17 @@
 	    cache = ap_proxy_cache_error(c);
 
     ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
     r->sent_bodyct = 1;
 /* send body */
     if (!r->header_only) {
-	if (parms[0] != 'd')
+	if (parms[0] != 'd') {
+/* we need to set this for ap_proxy_send_fb()... */
+	    c->cache_completion = 0;
 	    ap_proxy_send_fb(data, r, cache, c);
-	else
+	} else
 	    send_dir(data, r, cache, c, url);
 
 	if (rc == 125 || rc == 150)
 	    rc = ftp_getrc(f);
 	if (rc != 226 && rc != 250)
 	    ap_proxy_cache_error(c);
diff -BEr -U 6 apache_1.3.0/src/modules/proxy/proxy_http.c apache_1.3.1/src/modules/proxy/proxy_http.c
--- apache_1.3.0/src/modules/proxy/proxy_http.c	1998-05-28 06:56:05.000000000 +0800
+++ apache_1.3.1/src/modules/proxy/proxy_http.c	1998-07-10 03:45:56.000000000 +0800
@@ -108,13 +108,13 @@
 
     r->filename = ap_pstrcat(r->pool, "proxy:", scheme, "://", host, sport, "/",
 		   path, (search) ? "?" : "", (search) ? search : "", NULL);
     return OK;
 }
  
-static char *proxy_location_reverse_map(request_rec *r, char *url)
+static const char *proxy_location_reverse_map(request_rec *r, const char *url)
 {
     void *sconf;
     proxy_server_conf *conf;
     struct proxy_alias *ent;
     int i, l1, l2;
     char *u;
@@ -131,26 +131,26 @@
         }
     }
     return url;
 }
 
 /* Clear all connection-based headers from the incoming headers table */
-static void clear_connection(table *headers)
+static void clear_connection(pool *p, table *headers)
 {
-    char *name;
-    char *next = ap_table_get(headers, "Connection");
+    const char *name;
+    char *next = ap_pstrdup(p, ap_table_get(headers, "Connection"));
 
     ap_table_unset(headers, "Proxy-Connection");
     if (!next)
 	return;
 
     while (*next) {
 	name = next;
-	while (*next && !isspace(*next) && (*next != ','))
+	while (*next && !ap_isspace(*next) && (*next != ','))
 	    ++next;
-	while (*next && (isspace(*next) || (*next == ','))) {
+	while (*next && (ap_isspace(*next) || (*next == ','))) {
 	    *next = '\0';
 	    ++next;
 	}
 	ap_table_unset(headers, name);
     }
     ap_table_unset(headers, "Connection");
@@ -165,13 +165,14 @@
  * we return DECLINED so that we can try another proxy. (Or the direct
  * route.)
  */
 int ap_proxy_http_handler(request_rec *r, struct cache_req *c, char *url,
 		       const char *proxyhost, int proxyport)
 {
-    char *strp;
+    const char *strp;
+    char *strp2;
     const char *err, *desthost;
     int i, j, sock, len, backasswards;
     array_header *reqhdrs_arr, *resp_hdrs;
     table_entry *reqhdrs;
     struct sockaddr_in server;
     struct in_addr destaddr;
@@ -180,13 +181,13 @@
     struct hdr_entry *hdr;
     char buffer[HUGE_STRING_LEN];
     pool *p = r->pool;
     const long int zero = 0L;
     int destport = 0;
     char *destportstr = NULL;
-    char *urlptr = NULL;
+    const char *urlptr = NULL;
 
     void *sconf = r->server->module_config;
     proxy_server_conf *conf =
     (proxy_server_conf *) ap_get_module_config(sconf, &proxy_module);
     struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
     struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;
@@ -212,18 +213,18 @@
 	memcpy(q, urlptr, strp - urlptr);
 	q[strp - urlptr] = '\0';
 	urlptr = strp;
 	desthost = q;
     }
 
-    strp = strchr(desthost, ':');
-    if (strp != NULL) {
-	*(strp++) = '\0';
-	if (isdigit(*strp)) {
-	    destport = atoi(strp);
-	    destportstr = strp;
+    strp2 = strchr(desthost, ':');
+    if (strp2 != NULL) {
+	*(strp2++) = '\0';
+	if (ap_isdigit(*strp2)) {
+	    destport = atoi(strp2);
+	    destportstr = strp2;
 	}
     }
 
 /* check if ProxyBlock directive on this host */
     destaddr.s_addr = ap_inet_addr(desthost);
     for (i = 0; i < conf->noproxies->nelts; i++) {
@@ -289,13 +290,13 @@
 	else
 	    return ap_proxyerror(r, /*HTTP_BAD_GATEWAY*/ ap_pstrcat(r->pool,
 				"Could not connect to remote machine: ",
 				strerror(errno), NULL));
     }
 
-    clear_connection(r->headers_in);	/* Strip connection-based headers */
+    clear_connection(r->pool, r->headers_in);	/* Strip connection-based headers */
 
     f = ap_bcreate(p, B_RDWR | B_SOCKET);
     ap_bpushfd(f, sock, sock);
 
     ap_hard_timeout("proxy send", r);
     ap_bvputs(f, r->method, " ", proxyhost ? url : urlptr, " HTTP/1.0" CRLF,
@@ -303,13 +304,13 @@
     ap_bvputs(f, "Host: ", desthost, NULL);
     if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
 	ap_bvputs(f, ":", destportstr, CRLF, NULL);
     else
 	ap_bputs(CRLF, f);
 
-    reqhdrs_arr = table_elts(r->headers_in);
+    reqhdrs_arr = ap_table_elts(r->headers_in);
     reqhdrs = (table_entry *) reqhdrs_arr->elts;
     for (i = 0; i < reqhdrs_arr->nelts; i++) {
 	if (reqhdrs[i].key == NULL || reqhdrs[i].val == NULL
 	/* Clear out headers not to send */
 	    || !strcasecmp(reqhdrs[i].key, "Host")	/* Already sent */
 	    ||!strcasecmp(reqhdrs[i].key, "Proxy-Authorization"))
@@ -339,13 +340,13 @@
 /* Is it an HTTP/1 response?  This is buggy if we ever see an HTTP/1.10 */
     if (ap_checkmask(buffer, "HTTP/#.# ###*")) {
 /* If not an HTTP/1 messsage or if the status line was > 8192 bytes */
 	if (buffer[5] != '1' || buffer[len - 1] != '\n') {
 	    ap_bclose(f);
 	    ap_kill_timeout(r);
-	    return BAD_GATEWAY;
+	    return HTTP_BAD_GATEWAY;
 	}
 	backasswards = 0;
 	buffer[--len] = '\0';
 
 	buffer[12] = '\0';
 	r->status = atoi(&buffer[9]);
@@ -355,24 +356,26 @@
 /* read the headers. */
 /* N.B. for HTTP/1.0 clients, we have to fold line-wrapped headers */
 /* Also, take care with headers with multiple occurences. */
 
 	resp_hdrs = ap_proxy_read_headers(p, buffer, HUGE_STRING_LEN, f);
 
-	clear_connection((table *) resp_hdrs);	/* Strip Connection hdrs */
+	clear_connection(p, (table *) resp_hdrs);	/* Strip Connection hdrs */
     }
     else {
 /* an http/0.9 response */
 	backasswards = 1;
 	r->status = 200;
 	r->status_line = "200 OK";
 
 /* no headers */
 	resp_hdrs = ap_make_array(p, 2, sizeof(struct hdr_entry));
     }
 
+    c->hdrs = resp_hdrs;
+
     ap_kill_timeout(r);
 
 /*
  * HTTP/1.0 requires us to accept 3 types of dates, but only generate
  * one type
  */
@@ -455,14 +458,17 @@
     ap_bsetflag(r->connection->client, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
 #endif
 
 /* send body */
 /* if header only, then cache will be NULL */
 /* HTTP/1.0 tells us to read to EOF, rather than content-length bytes */
-    if (!r->header_only)
+    if (!r->header_only) {
+/* we need to set this for ap_proxy_send_fb()... */
+	c->cache_completion = conf->cache.cache_completion;
 	ap_proxy_send_fb(f, r, cache, c);
+    }
 
     ap_proxy_cache_tidy(c);
 
     ap_bclose(f);
 
     ap_proxy_garbage_coll(r);
diff -BEr -U 6 apache_1.3.0/src/modules/proxy/proxy_util.c apache_1.3.1/src/modules/proxy/proxy_util.c
--- apache_1.3.0/src/modules/proxy/proxy_util.c	1998-05-30 02:20:59.000000000 +0800
+++ apache_1.3.1/src/modules/proxy/proxy_util.c	1998-07-10 03:45:57.000000000 +0800
@@ -72,24 +72,24 @@
 int ap_proxy_hex2c(const char *x)
 {
     int i, ch;
 
 #ifndef CHARSET_EBCDIC
     ch = x[0];
-    if (isdigit(ch))
+    if (ap_isdigit(ch))
 	i = ch - '0';
-    else if (isupper(ch))
+    else if (ap_isupper(ch))
 	i = ch - ('A' - 10);
     else
 	i = ch - ('a' - 10);
     i <<= 4;
 
     ch = x[1];
-    if (isdigit(ch))
+    if (ap_isdigit(ch))
 	i += ch - '0';
-    else if (isupper(ch))
+    else if (ap_isupper(ch))
 	i += ch - ('A' - 10);
     else
 	i += ch - ('a' - 10);
     return i;
 #else /*CHARSET_EBCDIC*/
     return (1 == sscanf(x, "%2x", &i)) ? os_toebcdic[i&0xFF] : 0;
@@ -185,13 +185,13 @@
 		ap_proxy_c2hex(ch, &y[j]);
 		j += 2;
 		continue;
 	    }
 	}
 /* recode it, if necessary */
-	if (!isalnum(ch) && !strchr(allowed, ch)) {
+	if (!ap_isalnum(ch) && !strchr(allowed, ch)) {
 	    ap_proxy_c2hex(ch, &y[j]);
 	    j += 2;
 	}
 	else
 	    y[j] = ch;
     }
@@ -256,13 +256,13 @@
 
     strp = strrchr(host, ':');
     if (strp != NULL) {
 	*(strp++) = '\0';
 
 	for (i = 0; strp[i] != '\0'; i++)
-	    if (!isdigit(strp[i]))
+	    if (!ap_isdigit(strp[i]))
 		break;
 
 	if (i == 0 || strp[i] != '\0')
 	    return "Bad port number in URL";
 	*port = atoi(strp);
 	if (*port > 65535)
@@ -270,13 +270,13 @@
     }
     ap_str_tolower(host);		/* DNS names are case-insensitive */
     if (*host == '\0')
 	return "Missing host in URL";
 /* check hostname syntax */
     for (i = 0; host[i] != '\0'; i++)
-	if (!isdigit(host[i]) && host[i] != '.')
+	if (!ap_isdigit(host[i]) && host[i] != '.')
 	    break;
     /* must be an IP address */
 #ifdef WIN32
     if (host[i] == '\0' && (inet_addr(host) == -1))
 #else
     if (host[i] == '\0' && (ap_inet_addr(host) == -1 || inet_network(host) == -1))
@@ -301,14 +301,14 @@
  * If the date is a valid RFC 850 date or asctime() date, then it
  * is converted to the RFC 1123 format, otherwise it is not modified.
  * This routine is not very fast at doing conversions, as it uses
  * sscanf and sprintf. However, if the date is already correctly
  * formatted, then it exits very quickly.
  */
-char *
-     ap_proxy_date_canon(pool *p, char *x)
+const char *
+     ap_proxy_date_canon(pool *p, const char *x)
 {
     int wk, mday, year, hour, min, sec, mon;
     char *q, month[4], zone[4], week[4];
 
     q = strchr(x, ',');
     /* check for RFC 850 date */
@@ -350,17 +350,16 @@
     for (mon = 0; mon < 12; mon++)
 	if (strcmp(month, ap_month_snames[mon]) == 0)
 	    break;
     if (mon == 12)
 	return x;
 
-    if (strlen(x)+1 < 30)
-	x = ap_palloc(p, 30);
-    ap_snprintf(x, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", ap_day_snames[wk], mday,
+    q = ap_palloc(p, 30);
+    ap_snprintf(q, 30, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", ap_day_snames[wk], mday,
 		ap_month_snames[mon], year, hour, min, sec);
-    return x;
+    return q;
 }
 
 /*
  * Reads headers from a buffer and returns an array of headers.
  * Returns NULL on file error
  */
@@ -368,12 +367,13 @@
              ap_proxy_read_headers(pool *p, char *buffer, int size, BUFF *f)
 {
     int gotcr, len, i, j;
     array_header *resp_hdrs;
     struct hdr_entry *hdr;
     char *strp;
+    const char *strcp;
 
     resp_hdrs = ap_make_array(p, 10, sizeof(struct hdr_entry));
     hdr = NULL;
 
     gotcr = 1;
     for (;;) {
@@ -427,30 +427,35 @@
 	    gotcr = i;
 	}
     }
 
     hdr = (struct hdr_entry *) resp_hdrs->elts;
     for (i = 0; i < resp_hdrs->nelts; i++) {
-	strp = hdr[i].value;
-	j = strlen(strp);
-	while (j > 0 && (strp[j - 1] == ' ' || strp[j - 1] == '\t'))
+	strcp = hdr[i].value;
+	j = strlen(strcp);
+	while (j > 0 && (strcp[j - 1] == ' ' || strcp[j - 1] == '\t'))
 	    j--;
-	strp[j] = '\0';
+	/* Note that this is OK, coz we created the header above */
+	((char *)strcp)[j] = '\0';
     }
 
     return resp_hdrs;
 }
 
 long int ap_proxy_send_fb(BUFF *f, request_rec *r, BUFF *f2, struct cache_req *c)
 {
+    int  ok = 1;
     char buf[IOBUFSIZE];
-    long total_bytes_sent;
+    long total_bytes_rcv;
     register int n, o, w;
     conn_rec *con = r->connection;
+    int alt_to = 1;
 
-    total_bytes_sent = 0;
+    total_bytes_rcv = 0;
+    if (c)
+        c->written = 0;
 
 #ifdef CHARSET_EBCDIC
     /* The cache copy is ASCII, not EBCDIC, even for text/html) */
     ap_bsetflag(f, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
     if (f2 != NULL)
 	ap_bsetflag(f2, B_ASCII2EBCDIC|B_EBCDIC2ASCII, 0);
@@ -458,52 +463,108 @@
 #endif
 
     /* Since we are reading from one buffer and writing to another,
      * it is unsafe to do a soft_timeout here, at least until the proxy
      * has its own timeout handler which can set both buffers to EOUT.
      */
+
+    ap_kill_timeout(r);
+
+#ifdef WIN32
+    /* works fine under win32, so leave it */
     ap_hard_timeout("proxy send body", r);
+    alt_to = 0;
+#else
+    /* CHECKME! Since hard_timeout won't work in unix on sends with partial
+     * cache completion, we have to alternate between hard_timeout
+     * for reads, and soft_timeout for send.  This is because we need
+     * to get a return from ap_bwrite to be able to continue caching.
+     * BUT, if we *can't* continue anyway, just use hard_timeout.
+     */
+
+    if (c) {
+        if (c->len <= 0 || c->cache_completion == 1) {
+            ap_hard_timeout("proxy send body", r);
+            alt_to = 0;
+        }
+    } else {
+        ap_hard_timeout("proxy send body", r);
+        alt_to = 0;
+    }
+#endif
+
+    while (ok && f != NULL) {
+        if (alt_to)
+            ap_hard_timeout("proxy send body", r);
 
-    while (!con->aborted && f != NULL) {
 	n = ap_bread(f, buf, IOBUFSIZE);
+
+        if (alt_to)
+            ap_kill_timeout(r);
+        else
+            ap_reset_timeout(r);
+
 	if (n == -1) {		/* input error */
 	    if (f2 != NULL)
 		f2 = ap_proxy_cache_error(c);
 	    break;
 	}
 	if (n == 0)
 	    break;		/* EOF */
 	o = 0;
-	total_bytes_sent += n;
+	total_bytes_rcv += n;
 
-	if (f2 != NULL)
-	    if (ap_bwrite(f2, buf, n) != n)
+        if (f2 != NULL) {
+            if (ap_bwrite(f2, &buf[0], n) != n) {
 		f2 = ap_proxy_cache_error(c);
+            } else {
+                c->written += n;
+            }
+        }
 
 	while (n && !con->aborted) {
+            if (alt_to)
+                ap_soft_timeout("proxy send body", r);
+
 	    w = ap_bwrite(con->client, &buf[o], n);
+
+            if (alt_to)
+                ap_kill_timeout(r);
+            else
+                ap_reset_timeout(r);
+
 	    if (w <= 0) {
 		if (f2 != NULL) {
-		    ap_pclosef(c->req->pool, c->fp->fd);
-		    c->fp = NULL;
-		    f2 = NULL;
-		    con->aborted = 1;
-		    unlink(c->tempfile);
+                    /* when a send failure occurs, we need to decide
+                     * whether to continue loading and caching the
+                     * document, or to abort the whole thing
+                     */
+                    ok = (c->len > 0) &&
+                         (c->cache_completion > 0) &&
+                         (c->len * c->cache_completion < total_bytes_rcv);
+
+                    if (! ok) {
+                        ap_pclosef(c->req->pool, c->fp->fd);
+                        c->fp = NULL;
+                        f2 = NULL;
+                        unlink(c->tempfile);
+                    }
 		}
+                con->aborted = 1;
 		break;
 	    }
-	    ap_reset_timeout(r);	/* reset timeout after successful write */
 	    n -= w;
 	    o += w;
 	}
     }
+
     if (!con->aborted)
 	ap_bflush(con->client);
 
     ap_kill_timeout(r);
-    return total_bytes_sent;
+    return total_bytes_rcv;
 }
 
 /*
  * Read a header from the array, returning the first entry
  */
 struct hdr_entry *
@@ -523,13 +584,13 @@
 /*
  * Add to the header reply, either concatenating, or replacing existin
  * headers. It stores the pointers provided, so make sure the data
  * is not subsequently overwritten
  */
 struct hdr_entry *
-          ap_proxy_add_header(array_header *hdrs_arr, char *field, char *value,
+          ap_proxy_add_header(array_header *hdrs_arr, const char *field, const char *value,
 			   int rep)
 {
     int i;
     struct hdr_entry *hdrs;
 
     hdrs = (struct hdr_entry *) hdrs_arr->elts;
@@ -603,18 +664,18 @@
     while (list != NULL) {
 	p = strchr(list, ',');
 	if (p != NULL) {
 	    i = p - list;
 	    do
 		p++;
-	    while (isspace(*p));
+	    while (ap_isspace(*p));
 	}
 	else
 	    i = strlen(list);
 
-	while (i > 0 && isspace(list[i - 1]))
+	while (i > 0 && ap_isspace(list[i - 1]))
 	    i--;
 	if (i == len && strncasecmp(list, val, len) == 0)
 	    return 1;
 	list = p;
     }
     return 0;
@@ -731,15 +792,15 @@
     int i, ch;
     unsigned int j;
 
     for (i = 0, j = 0; i < 8; i++) {
 	ch = x[i];
 	j <<= 4;
-	if (isdigit(ch))
+	if (ap_isdigit(ch))
 	    j |= ch - '0';
-	else if (isupper(ch))
+	else if (ap_isupper(ch))
 	    j |= ch - ('A' - 10);
 	else
 	    j |= ch - ('a' - 10);
     }
     if (j == 0xffffffff)
 	return -1;		/* so that it works with 8-byte ints */
@@ -799,13 +860,13 @@
     struct hostent *hp;
     static APACHE_TLS struct hostent hpbuf;
     static APACHE_TLS u_long ipaddr;
     static APACHE_TLS char *charpbuf[2];
 
     for (i = 0; host[i] != '\0'; i++)
-	if (!isdigit(host[i]) && host[i] != '.')
+	if (!ap_isdigit(host[i]) && host[i] != '.')
 	    break;
 
     if (host[i] != '\0') {
 	hp = gethostbyname(host);
 	if (hp == NULL)
 	    return "Host not found";
@@ -825,13 +886,13 @@
 	}
     }
     *reqhp = *hp;
     return NULL;
 }
 
-static char *
+static const char *
      proxy_get_host_of_request(request_rec *r)
 {
     char *url, *user = NULL, *password = NULL, *err, *host;
     int port = -1;
 
     if (r->hostname != NULL)
@@ -879,13 +940,13 @@
     for (quads = 0; quads < 4 && *addr != '\0'; ++quads) {
 	char *tmp;
 
 	if (*addr == '/' && quads > 0)	/* netmask starts here. */
 	    break;
 
-	if (!isdigit(*addr))
+	if (!ap_isdigit(*addr))
 	    return 0;		/* no digit at start of quad */
 
 	ip_addr[quads] = strtol(addr, &tmp, 0);
 
 	if (tmp == addr)	/* expected a digit, found something else */
 	    return 0;
@@ -901,13 +962,13 @@
 	    ++addr;		/* after the 4th quad, a dot would be illegal */
     }
 
     for (This->addr.s_addr = 0, i = 0; i < quads; ++i)
 	This->addr.s_addr |= htonl(ip_addr[i] << (24 - 8 * i));
 
-    if (addr[0] == '/' && isdigit(addr[1])) {	/* net mask follows: */
+    if (addr[0] == '/' && ap_isdigit(addr[1])) {	/* net mask follows: */
 	char *tmp;
 
 	++addr;
 
 	bits = strtol(addr, &tmp, 0);
 
@@ -1044,13 +1105,13 @@
 
     /* Domain name must start with a '.' */
     if (addr[0] != '.')
 	return 0;
 
     /* rfc1035 says DNS names must consist of "[-a-zA-Z0-9]" and '.' */
-    for (i = 0; isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i)
+    for (i = 0; ap_isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i)
 	continue;
 
 #if 0
     if (addr[i] == ':') {
 	fprintf(stderr, "@@@@ handle optional port in proxy_is_domainname()\n");
 	/* @@@@ handle optional port */
@@ -1098,13 +1159,13 @@
 
     /* Host names must not start with a '.' */
     if (addr[0] == '.')
 	return 0;
 
     /* rfc1035 says DNS names must consist of "[-a-zA-Z0-9]" and '.' */
-    for (i = 0; isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i);
+    for (i = 0; ap_isalnum(addr[i]) || addr[i] == '-' || addr[i] == '.'; ++i);
 
 #if 0
     if (addr[i] == ':') {
 	fprintf(stderr, "@@@@ handle optional port in proxy_is_hostname()\n");
 	/* @@@@ handle optional port */
     }
@@ -1124,13 +1185,13 @@
 }
 
 /* Return TRUE if host "host" is equal to host2 "host2" */
 static int proxy_match_hostname(struct dirconn_entry *This, request_rec *r)
 {
     char *host = This->name;
-    char *host2 = proxy_get_host_of_request(r);
+    const char *host2 = proxy_get_host_of_request(r);
     int h2_len;
     int h1_len;
 
     if (host == NULL || host2 == NULL)
        return 0; /* oops! */
 
@@ -1162,13 +1223,13 @@
     return 1;
 }
 
 /* Return TRUE if string "str2" occurs literally in "str1" */
 static int proxy_match_word(struct dirconn_entry *This, request_rec *r)
 {
-    char *host = proxy_get_host_of_request(r);
+    const char *host = proxy_get_host_of_request(r);
     return host != NULL && strstr(host, This->name) != NULL;
 }
 
 int ap_proxy_doconnect(int sock, struct sockaddr_in *addr, request_rec *r)
 {
     int i;
Only in apache_1.3.0/src/modules/standard: Makefile
diff -BEr -U 6 apache_1.3.0/src/modules/standard/Makefile.tmpl apache_1.3.1/src/modules/standard/Makefile.tmpl
--- apache_1.3.0/src/modules/standard/Makefile.tmpl	1998-05-30 04:28:01.000000000 +0800
+++ apache_1.3.1/src/modules/standard/Makefile.tmpl	1998-07-13 19:32:46.000000000 +0800
@@ -1,183 +1,231 @@
 
 #Dependencies
 
 $(OBJS) $(OBJS_PIC): Makefile
 
 # DO NOT REMOVE
-mod_access.o: mod_access.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h $(INCDIR)/http_core.h \
+mod_access.o: mod_access.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_core.h \
  $(INCDIR)/http_config.h $(INCDIR)/http_log.h \
  $(INCDIR)/http_request.h
 mod_actions.o: mod_actions.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_core.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/http_main.h $(INCDIR)/http_log.h \
- $(INCDIR)/util_script.h
-mod_alias.o: mod_alias.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h
-mod_asis.o: mod_asis.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/http_log.h $(INCDIR)/util_script.h \
- $(INCDIR)/http_main.h $(INCDIR)/http_request.h
-mod_auth.o: mod_auth.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h
-mod_auth_anon.o: mod_auth_anon.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_request.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_main.h \
+ $(INCDIR)/http_log.h $(INCDIR)/util_script.h
+mod_alias.o: mod_alias.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h
+mod_asis.o: mod_asis.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_log.h \
+ $(INCDIR)/util_script.h $(INCDIR)/http_main.h \
  $(INCDIR)/http_request.h
+mod_auth.o: mod_auth.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_protocol.h
+mod_auth_anon.o: mod_auth_anon.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_request.h
 mod_auth_db.o: mod_auth_db.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_protocol.h
 mod_auth_dbm.o: mod_auth_dbm.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_protocol.h
 mod_autoindex.o: mod_autoindex.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_request.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_main.h \
- $(INCDIR)/util_script.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_request.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_main.h $(INCDIR)/util_script.h
 mod_cern_meta.o: mod_cern_meta.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/util_script.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_request.h
-mod_cgi.o: mod_cgi.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_core.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/http_main.h $(INCDIR)/http_log.h \
- $(INCDIR)/util_script.h $(INCDIR)/http_conf_globals.h
-mod_digest.o: mod_digest.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/util_md5.h $(INCDIR)/ap_md5.h
-mod_dir.o: mod_dir.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_request.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_main.h \
- $(INCDIR)/util_script.h
-mod_env.o: mod_env.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/util_script.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_request.h
+mod_cgi.o: mod_cgi.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_request.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_main.h \
+ $(INCDIR)/http_log.h $(INCDIR)/util_script.h \
+ $(INCDIR)/http_conf_globals.h
+mod_digest.o: mod_digest.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/util_md5.h \
+ $(INCDIR)/ap_md5.h
+mod_dir.o: mod_dir.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_request.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_main.h $(INCDIR)/util_script.h
+mod_env.o: mod_env.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h
 mod_expires.o: mod_expires.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_log.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_log.h
 mod_headers.o: mod_headers.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h
-mod_imap.o: mod_imap.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_core.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/http_main.h $(INCDIR)/http_log.h \
- $(INCDIR)/util_script.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h
+mod_imap.o: mod_imap.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_request.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_main.h \
+ $(INCDIR)/http_log.h $(INCDIR)/util_script.h
 mod_include.o: mod_include.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_core.h $(INCDIR)/http_protocol.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_main.h \
- $(INCDIR)/util_script.h
-mod_info.o: mod_info.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_log.h $(INCDIR)/http_main.h \
- $(INCDIR)/http_protocol.h $(INCDIR)/util_script.h \
- $(INCDIR)/http_conf_globals.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_request.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_protocol.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_main.h $(INCDIR)/util_script.h
+mod_info.o: mod_info.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
+ $(INCDIR)/http_main.h $(INCDIR)/http_protocol.h \
+ $(INCDIR)/util_script.h $(INCDIR)/http_conf_globals.h
 mod_log_agent.o: mod_log_agent.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_log.h
-mod_log_config.o: mod_log_config.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
  $(INCDIR)/http_log.h
+mod_log_config.o: mod_log_config.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h
 mod_log_referer.o: mod_log_referer.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_log.h
-mod_mime.o: mod_mime.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_log.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_log.h
+mod_mime.o: mod_mime.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_log.h
 mod_mime_magic.o: mod_mime_magic.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
- $(INCDIR)/http_protocol.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_request.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_log.h $(INCDIR)/http_protocol.h
 mod_negotiation.o: mod_negotiation.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_request.h \
- $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
- $(INCDIR)/util_script.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_request.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_log.h $(INCDIR)/util_script.h
 mod_rewrite.o: mod_rewrite.c mod_rewrite.h $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_request.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_conf_globals.h $(INCDIR)/http_request.h \
  $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
  $(INCDIR)/http_vhost.h
 mod_setenvif.o: mod_setenvif.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_log.h
+mod_so.o: mod_so.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
  $(INCDIR)/http_log.h
-mod_so.o: mod_so.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_log.h
 mod_speling.o: mod_speling.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_core.h $(INCDIR)/http_config.h \
- $(INCDIR)/http_log.h
-mod_status.o: mod_status.c $(INCDIR)/httpd.h $(INCDIR)/conf.h \
- $(OSDIR)/os.h $(INCDIR)/alloc.h $(INCDIR)/buff.h \
- $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h \
- $(INCDIR)/http_protocol.h $(INCDIR)/http_main.h \
- $(INCDIR)/util_script.h $(INCDIR)/scoreboard.h \
- $(INCDIR)/http_log.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_core.h \
+ $(INCDIR)/http_config.h $(INCDIR)/http_log.h
+mod_status.o: mod_status.c $(INCDIR)/httpd.h \
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h $(INCDIR)/http_protocol.h \
+ $(INCDIR)/http_main.h $(INCDIR)/util_script.h \
+ $(INCDIR)/scoreboard.h $(INCDIR)/http_log.h
 mod_unique_id.o: mod_unique_id.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_log.h \
- $(INCDIR)/multithread.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_log.h $(INCDIR)/multithread.h
 mod_userdir.o: mod_userdir.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h
 mod_usertrack.o: mod_usertrack.c $(INCDIR)/httpd.h \
- $(INCDIR)/conf.h $(OSDIR)/os.h $(INCDIR)/alloc.h \
- $(INCDIR)/buff.h $(INCDIR)/ap.h $(INCDIR)/util_uri.h \
- $(INCDIR)/http_config.h $(INCDIR)/http_core.h
+ $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ $(INCDIR)/alloc.h $(INCDIR)/buff.h $(INCDIR)/ap.h \
+ $(INCDIR)/util_uri.h $(INCDIR)/http_config.h \
+ $(INCDIR)/http_core.h
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_access.c apache_1.3.1/src/modules/standard/mod_access.c
--- apache_1.3.0/src/modules/standard/mod_access.c	1998-04-20 03:19:38.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_access.c	1998-07-09 01:47:12.000000000 +0800
@@ -135,13 +135,13 @@
 
     return NULL;
 }
 
 static int is_ip(const char *host)
 {
-    while ((*host == '.') || isdigit(*host))
+    while ((*host == '.') || ap_isdigit(*host))
 	host++;
     return (*host == '\0');
 }
 
 static const char *allow_cmd(cmd_parms *cmd, void *dv, char *from, char *where)
 {
@@ -201,13 +201,13 @@
 	    mask = 0xFFFFFFFFUL << (32 - mask);
 	    mask = htonl(mask);
 	}
 	a->x.ip.mask = mask;
 
     }
-    else if (isdigit(*where) && is_ip(where)) {
+    else if (ap_isdigit(*where) && is_ip(where)) {
 	/* legacy syntax for ip addrs: a.b.c. ==> a.b.c.0/24 for example */
 	int shift;
 	char *t;
 	int octet;
 
 	a->type = T_IP;
@@ -215,17 +215,17 @@
 	s = where;
 	a->x.ip.net = 0;
 	a->x.ip.mask = 0;
 	shift = 24;
 	while (*s) {
 	    t = s;
-	    if (!isdigit(*t)) {
+	    if (!ap_isdigit(*t)) {
 		a->type = T_FAIL;
 		return "invalid ip address";
 	    }
-	    while (isdigit(*t)) {
+	    while (ap_isdigit(*t)) {
 		++t;
 	    }
 	    if (*t == '.') {
 		*t++ = 0;
 	    }
 	    else if (*t) {
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_actions.c apache_1.3.1/src/modules/standard/mod_actions.c
--- apache_1.3.0/src/modules/standard/mod_actions.c	1998-04-11 20:00:43.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_actions.c	1998-06-13 23:23:04.000000000 +0800
@@ -156,14 +156,14 @@
 };
 
 static int action_handler(request_rec *r)
 {
     action_dir_config *conf =
     (action_dir_config *) ap_get_module_config(r->per_dir_config, &action_module);
-    char *t, *action = r->handler ? r->handler : r->content_type;
-    char *script = NULL;
+    const char *t, *action = r->handler ? r->handler : r->content_type;
+    const char *script = NULL;
 
     /* Set allowed stuff */
     if (conf->get)
 	r->allowed |= (1 << M_GET);
     if (conf->post)
 	r->allowed |= (1 << M_POST);
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_alias.c apache_1.3.1/src/modules/standard/mod_alias.c
--- apache_1.3.0/src/modules/standard/mod_alias.c	1998-05-04 10:38:43.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_alias.c	1998-07-09 01:47:13.000000000 +0800
@@ -174,13 +174,13 @@
     else if (!strcasecmp(arg1, "permanent"))
 	status = HTTP_MOVED_PERMANENTLY;
     else if (!strcasecmp(arg1, "temp"))
 	status = HTTP_MOVED_TEMPORARILY;
     else if (!strcasecmp(arg1, "seeother"))
 	status = HTTP_SEE_OTHER;
-    else if (isdigit(*arg1))
+    else if (ap_isdigit(*arg1))
 	status = atoi(arg1);
     else {
 	f = arg1;
 	url = arg2;
     }
 
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_asis.c apache_1.3.1/src/modules/standard/mod_asis.c
--- apache_1.3.0/src/modules/standard/mod_asis.c	1998-04-11 20:00:43.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_asis.c	1998-06-13 23:23:05.000000000 +0800
@@ -63,13 +63,13 @@
 #include "http_main.h"
 #include "http_request.h"
 
 static int asis_handler(request_rec *r)
 {
     FILE *f;
-    char *location;
+    const char *location;
 
     r->allowed |= (1 << M_GET);
     if (r->method_number != M_GET)
 	return DECLINED;
     if (r->finfo.st_mode == 0) {
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_auth_anon.c apache_1.3.1/src/modules/standard/mod_auth_anon.c
--- apache_1.3.0/src/modules/standard/mod_auth_anon.c	1998-04-11 20:00:44.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_auth_anon.c	1998-07-04 06:08:49.000000000 +0800
@@ -214,16 +214,16 @@
 static int anon_authenticate_basic_user(request_rec *r)
 {
     anon_auth_config_rec *sec =
     (anon_auth_config_rec *) ap_get_module_config(r->per_dir_config,
 					       &anon_auth_module);
     conn_rec *c = r->connection;
-    char *send_pw;
+    const char *sent_pw;
     int res = DECLINED;
 
-    if ((res = ap_get_basic_auth_pw(r, &send_pw)))
+    if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
 	return res;
 
     /* Ignore if we are not configured */
     if (!sec->auth_anon_passwords)
 	return DECLINED;
 
@@ -243,29 +243,29 @@
 	}
     }
     if (
     /* username is OK */
 	   (res == OK)
     /* password been filled out ? */
-	   && ((!sec->auth_anon_mustemail) || strlen(send_pw))
+	   && ((!sec->auth_anon_mustemail) || strlen(sent_pw))
     /* does the password look like an email address ? */
 	   && ((!sec->auth_anon_verifyemail)
-	       || ((strpbrk("@", send_pw) != NULL)
-		   && (strpbrk(".", send_pw) != NULL)))) {
+	       || ((strpbrk("@", sent_pw) != NULL)
+		   && (strpbrk(".", sent_pw) != NULL)))) {
 	if (sec->auth_anon_logemail && ap_is_initial_req(r)) {
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r->server,
 			"Anonymous: Passwd <%s> Accepted",
-			send_pw ? send_pw : "\'none\'");
+			sent_pw ? sent_pw : "\'none\'");
 	}
 	return OK;
     }
     else {
 	if (sec->auth_anon_authoritative) {
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
 			"Anonymous: Authoritative, Passwd <%s> not accepted",
-			send_pw ? send_pw : "\'none\'");
+			sent_pw ? sent_pw : "\'none\'");
 	    return AUTH_REQUIRED;
 	}
 	/* Drop out the bottom to return DECLINED */
     }
 
     return DECLINED;
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_auth.c apache_1.3.1/src/modules/standard/mod_auth.c
--- apache_1.3.0/src/modules/standard/mod_auth.c	1998-04-11 20:00:44.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_auth.c	1998-07-10 14:33:24.000000000 +0800
@@ -198,13 +198,14 @@
 
 static int authenticate_basic_user(request_rec *r)
 {
     auth_config_rec *sec =
     (auth_config_rec *) ap_get_module_config(r->per_dir_config, &auth_module);
     conn_rec *c = r->connection;
-    char *sent_pw, *real_pw;
+    const char *sent_pw;
+    char *real_pw;
     int res;
 
     if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
 	return res;
 
     if (!sec->auth_pwfile)
@@ -237,13 +238,13 @@
     char *user = r->connection->user;
     int m = r->method_number;
     int method_restricted = 0;
     register int x;
     const char *t, *w;
     table *grpstatus;
-    array_header *reqs_arr = ap_requires(r);
+    const array_header *reqs_arr = ap_requires(r);
     require_line *reqs;
 
     /* BUG FIX: tadc, 11-Nov-1995.  If there is no "requires" directive, 
      * then any user will do.
      */
     if (!reqs_arr)
@@ -288,12 +289,18 @@
     if (!method_restricted)
 	return OK;
 
     if (!(sec->auth_authoritative))
 	return DECLINED;
 
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
+	"access to %s failed for %s, reason: user %s not allowed access",
+	r->uri,
+	ap_get_remote_host(r->connection, r->per_dir_config, REMOTE_NAME),
+	user);
+	
     ap_note_basic_auth_failure(r);
     return AUTH_REQUIRED;
 }
 
 module MODULE_VAR_EXPORT auth_module =
 {
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_auth_db.c apache_1.3.1/src/modules/standard/mod_auth_db.c
--- apache_1.3.0/src/modules/standard/mod_auth_db.c	1998-04-11 20:00:44.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_auth_db.c	1998-07-04 06:08:50.000000000 +0800
@@ -202,13 +202,14 @@
 static int db_authenticate_basic_user(request_rec *r)
 {
     db_auth_config_rec *sec =
     (db_auth_config_rec *) ap_get_module_config(r->per_dir_config,
 					     &db_auth_module);
     conn_rec *c = r->connection;
-    char *sent_pw, *real_pw, *colon_pw;
+    const char *sent_pw;
+    char *real_pw, *colon_pw;
     int res;
 
     if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
 	return res;
 
     if (!sec->auth_dbpwfile)
@@ -243,13 +244,13 @@
     db_auth_config_rec *sec =
     (db_auth_config_rec *) ap_get_module_config(r->per_dir_config,
 					     &db_auth_module);
     char *user = r->connection->user;
     int m = r->method_number;
 
-    array_header *reqs_arr = ap_requires(r);
+    const array_header *reqs_arr = ap_requires(r);
     require_line *reqs = reqs_arr ? (require_line *) reqs_arr->elts : NULL;
 
     register int x;
     const char *t;
     char *w;
 
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_auth_dbm.c apache_1.3.1/src/modules/standard/mod_auth_dbm.c
--- apache_1.3.0/src/modules/standard/mod_auth_dbm.c	1998-04-11 20:00:44.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_auth_dbm.c	1998-07-04 06:08:50.000000000 +0800
@@ -203,13 +203,14 @@
 static int dbm_authenticate_basic_user(request_rec *r)
 {
     dbm_auth_config_rec *sec =
     (dbm_auth_config_rec *) ap_get_module_config(r->per_dir_config,
 					      &dbm_auth_module);
     conn_rec *c = r->connection;
-    char *sent_pw, *real_pw, *colon_pw;
+    const char *sent_pw;
+    char *real_pw, *colon_pw;
     int res;
 
     if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
 	return res;
 
     if (!sec->auth_dbmpwfile)
@@ -244,13 +245,13 @@
     dbm_auth_config_rec *sec =
     (dbm_auth_config_rec *) ap_get_module_config(r->per_dir_config,
 					      &dbm_auth_module);
     char *user = r->connection->user;
     int m = r->method_number;
 
-    array_header *reqs_arr = ap_requires(r);
+    const array_header *reqs_arr = ap_requires(r);
     require_line *reqs = reqs_arr ? (require_line *) reqs_arr->elts : NULL;
 
     register int x;
     const char *t;
     char *w;
 
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_autoindex.c apache_1.3.1/src/modules/standard/mod_autoindex.c
--- apache_1.3.0/src/modules/standard/mod_autoindex.c	1998-05-17 05:11:17.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_autoindex.c	1998-07-09 01:47:14.000000000 +0800
@@ -133,61 +133,82 @@
 
 #define BY_ENCODING &c_by_encoding
 #define BY_TYPE &c_by_type
 #define BY_PATH &c_by_path
 
 /*
+ * Return true if the specified string refers to the parent directory (i.e.,
+ * matches ".." or "../").  Hopefully this one call is significantly less
+ * expensive than multiple strcmp() calls.
+ */
+static ap_inline int is_parent(const char *name)
+{
+    /*
+     * Now, IFF the first two bytes are dots, and the third byte is either
+     * EOS (\0) or a slash followed by EOS, we have a match.
+     */
+    if (((name[0] == '.') && (name[1] == '.'))
+	&& ((name[2] == '\0')
+	    || ((name[2] == '/') && (name[3] == '\0')))) {
+        return 1;
+    }
+    return 0;
+}
+
+/*
  * This routine puts the standard HTML header at the top of the index page.
  * We include the DOCTYPE because we may be using features therefrom (i.e.,
  * HEIGHT and WIDTH attributes on the icons if we're FancyIndexing).
  */
 static void emit_preamble(request_rec *r, char *title)
 {
-    ap_rvputs
-	(
-	    r,
-	    "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n",
-	    "<HTML>\n <HEAD>\n  <TITLE>Index of ",
-	    title,
-	    "</TITLE>\n </HEAD>\n <BODY>\n",
-	    NULL
-	);
+    ap_rvputs(r, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">\n",
+	      "<HTML>\n <HEAD>\n  <TITLE>Index of ", title,
+	      "</TITLE>\n </HEAD>\n <BODY>\n", NULL);
 }
 
 static void push_item(array_header *arr, char *type, char *to, char *path,
 		      char *data)
 {
     struct item *p = (struct item *) ap_push_array(arr);
 
-    if (!to)
+    if (!to) {
 	to = "";
-    if (!path)
+    }
+    if (!path) {
 	path = "";
+    }
 
     p->type = type;
     p->data = data ? ap_pstrdup(arr->pool, data) : NULL;
     p->apply_path = ap_pstrcat(arr->pool, path, "*", NULL);
 
-    if ((type == BY_PATH) && (!ap_is_matchexp(to)))
+    if ((type == BY_PATH) && (!ap_is_matchexp(to))) {
 	p->apply_to = ap_pstrcat(arr->pool, "*", to, NULL);
-    else if (to)
+    }
+    else if (to) {
 	p->apply_to = ap_pstrdup(arr->pool, to);
-    else
+    }
+    else {
 	p->apply_to = NULL;
+    }
 }
 
 static const char *add_alt(cmd_parms *cmd, void *d, char *alt, char *to)
 {
-    if (cmd->info == BY_PATH)
-	if (!strcmp(to, "**DIRECTORY**"))
+    if (cmd->info == BY_PATH) {
+        if (!strcmp(to, "**DIRECTORY**")) {
 	    to = "^^DIRECTORY^^";
+	}
+    }
     if (cmd->info == BY_ENCODING) {
 	ap_str_tolower(to);
     }
 
-    push_item(((autoindex_config_rec *) d)->alt_list, cmd->info, to, cmd->path, alt);
+    push_item(((autoindex_config_rec *) d)->alt_list, cmd->info, to,
+	      cmd->path, alt);
     return NULL;
 }
 
 static const char *add_icon(cmd_parms *cmd, void *d, char *icon, char *to)
 {
     char *iconbak = ap_pstrdup(cmd->pool, icon);
@@ -200,34 +221,30 @@
 	    return "missing closing paren";
 	}
 	alt = ap_getword_nc(cmd->pool, &iconbak, ',');
 	*cl = '\0';				/* Lose closing paren */
 	add_alt(cmd, d, &alt[1], to);
     }
-    if (cmd->info == BY_PATH)
-	if (!strcmp(to, "**DIRECTORY**"))
+    if (cmd->info == BY_PATH) {
+        if (!strcmp(to, "**DIRECTORY**")) {
 	    to = "^^DIRECTORY^^";
+	}
+    }
     if (cmd->info == BY_ENCODING) {
 	ap_str_tolower(to);
     }
 
-    push_item(((autoindex_config_rec *) d)->icon_list, cmd->info, to, cmd->path,
-	      iconbak);
+    push_item(((autoindex_config_rec *) d)->icon_list, cmd->info, to,
+	      cmd->path, iconbak);
     return NULL;
 }
 
 static const char *add_desc(cmd_parms *cmd, void *d, char *desc, char *to)
 {
-    push_item
-	(
-	    ((autoindex_config_rec *) d)->desc_list,
-	    cmd->info,
-	    to,
-	    cmd->path,
-	    desc
-	);
+    push_item(((autoindex_config_rec *) d)->desc_list, cmd->info, to,
+	      cmd->path, desc);
     return NULL;
 }
 
 static const char *add_ignore(cmd_parms *cmd, void *d, char *ext)
 {
     push_item(((autoindex_config_rec *) d)->ign_list, 0, ext, cmd->path, NULL);
@@ -236,30 +253,32 @@
 
 static const char *add_header(cmd_parms *cmd, void *d, char *name)
 {
     if (strchr(name, '/')) {
 	return "HeaderName cannot contain a /";
     }
-    push_item(((autoindex_config_rec *) d)->hdr_list, 0, NULL, cmd->path, name);
+    push_item(((autoindex_config_rec *) d)->hdr_list, 0, NULL, cmd->path,
+	      name);
     return NULL;
 }
 
 static const char *add_readme(cmd_parms *cmd, void *d, char *name)
 {
     if (strchr(name, '/')) {
 	return "ReadmeName cannot contain a /";
     }
-    push_item(((autoindex_config_rec *) d)->rdme_list, 0, NULL, cmd->path, name);
+    push_item(((autoindex_config_rec *) d)->rdme_list, 0, NULL, cmd->path,
+	      name);
     return NULL;
 }
 
 
 static const char *add_opts_int(cmd_parms *cmd, void *d, int opts)
 {
-    push_item(((autoindex_config_rec *) d)->opts_list, (char *) (long) opts, NULL,
-	      cmd->path, NULL);
+    push_item(((autoindex_config_rec *) d)->opts_list, (char *) (long) opts,
+	      NULL, cmd->path, NULL);
     return NULL;
 }
 
 static const char *fancy_indexing(cmd_parms *cmd, void *d, int arg)
 {
     return add_opts_int(cmd, d, arg ? FANCY_INDEXING : 0);
@@ -270,31 +289,39 @@
     char *w;
     int opts = 0;
     autoindex_config_rec *d_cfg = (autoindex_config_rec *) d;
 
     while (optstr[0]) {
 	w = ap_getword_conf(cmd->pool, &optstr);
-	if (!strcasecmp(w, "FancyIndexing"))
+	if (!strcasecmp(w, "FancyIndexing")) {
 	    opts |= FANCY_INDEXING;
-	else if (!strcasecmp(w, "IconsAreLinks"))
+	}
+	else if (!strcasecmp(w, "IconsAreLinks")) {
 	    opts |= ICONS_ARE_LINKS;
-	else if (!strcasecmp(w, "ScanHTMLTitles"))
+	}
+	else if (!strcasecmp(w, "ScanHTMLTitles")) {
 	    opts |= SCAN_HTML_TITLES;
-	else if (!strcasecmp(w, "SuppressLastModified"))
+	}
+	else if (!strcasecmp(w, "SuppressLastModified")) {
 	    opts |= SUPPRESS_LAST_MOD;
-	else if (!strcasecmp(w, "SuppressSize"))
+	}
+	else if (!strcasecmp(w, "SuppressSize")) {
 	    opts |= SUPPRESS_SIZE;
-	else if (!strcasecmp(w, "SuppressDescription"))
+	}
+	else if (!strcasecmp(w, "SuppressDescription")) {
 	    opts |= SUPPRESS_DESC;
-	else if (!strcasecmp(w, "SuppressHTMLPreamble"))
+	}
+	else if (!strcasecmp(w, "SuppressHTMLPreamble")) {
 	    opts |= SUPPRESS_PREAMBLE;
+	}
         else if (!strcasecmp(w, "SuppressColumnSorting")) {
             opts |= SUPPRESS_COLSORT;
 	}
-	else if (!strcasecmp(w, "None"))
+	else if (!strcasecmp(w, "None")) {
 	    opts = 0;
+	}
 	else if (!strncasecmp(w, "IconWidth", 9)) {
 	    if (strchr(w, '=') != NULL) {
 		const char *x = ap_pstrdup(cmd->pool, w);
 		char *val;
 		val = ap_getword(cmd->pool, &x, '=');
 		val = ap_getword(cmd->pool, &x, '=');
@@ -313,14 +340,15 @@
 		d_cfg->icon_height = atoi(val);
 	    }
 	    else {
 		d_cfg->icon_height = DEFAULT_ICON_HEIGHT;
 	    }
 	}
-	else
+	else {
 	    return "Invalid directory indexing option";
+	}
     }
     return add_opts_int(cmd, d, opts);
 }
 
 #define DIR_CMD_PERMS OR_INDEXES
 
@@ -371,17 +399,19 @@
 
     return (void *) new;
 }
 
 static void *merge_autoindex_configs(pool *p, void *basev, void *addv)
 {
-    autoindex_config_rec *new = (autoindex_config_rec *) ap_pcalloc(p, sizeof(autoindex_config_rec));
+    autoindex_config_rec *new;
     autoindex_config_rec *base = (autoindex_config_rec *) basev;
     autoindex_config_rec *add = (autoindex_config_rec *) addv;
 
-    new->default_icon = add->default_icon ? add->default_icon:base->default_icon;
+    new = (autoindex_config_rec *) ap_pcalloc(p, sizeof(autoindex_config_rec));
+    new->default_icon = add->default_icon ? add->default_icon
+                                          : base->default_icon;
     new->icon_height = add->icon_height ? add->icon_height : base->icon_height;
     new->icon_width = add->icon_width ? add->icon_width : base->icon_width;
 
     new->alt_list = ap_append_arrays(p, add->alt_list, base->alt_list);
     new->ign_list = ap_append_arrays(p, add->ign_list, base->ign_list);
     new->hdr_list = ap_append_arrays(p, add->hdr_list, base->hdr_list);
@@ -403,51 +433,56 @@
 struct ent {
     char *name;
     char *icon;
     char *alt;
     char *desc;
     size_t size;
-    char *size_cmp;
     time_t lm;
-    char *lm_cmp;
     struct ent *next;
     int ascending;
     char key;
 };
 
 static char *find_item(request_rec *r, array_header *list, int path_only)
 {
-    char *content_type = r->content_type;
-    char *content_encoding = r->content_encoding;
+    const char *content_type = r->content_type;
+    const char *content_encoding = r->content_encoding;
     char *path = r->filename;
 
     struct item *items = (struct item *) list->elts;
     int i;
 
     for (i = 0; i < list->nelts; ++i) {
 	struct item *p = &items[i];
 
 	/* Special cased for ^^DIRECTORY^^ and ^^BLANKICON^^ */
 	if ((path[0] == '^') || (!ap_strcmp_match(path, p->apply_path))) {
-	    if (!*(p->apply_to))
+	    if (!*(p->apply_to)) {
 		return p->data;
+	    }
 	    else if (p->type == BY_PATH || path[0] == '^') {
-		if (!ap_strcmp_match(path, p->apply_to))
+	        if (!ap_strcmp_match(path, p->apply_to)) {
 		    return p->data;
+		}
 	    }
 	    else if (!path_only) {
 		if (!content_encoding) {
 		    if (p->type == BY_TYPE) {
-			if (content_type && !ap_strcasecmp_match(content_type, p->apply_to))
+			if (content_type
+			    && !ap_strcasecmp_match(content_type,
+						    p->apply_to)) {
 			    return p->data;
+			}
 		    }
 		}
 		else {
 		    if (p->type == BY_ENCODING) {
-			if (!ap_strcasecmp_match(content_encoding, p->apply_to))
+			if (!ap_strcasecmp_match(content_encoding,
+						 p->apply_to)) {
 			    return p->data;
+			}
 		    }
 		}
 	    }
 	}
     }
     return NULL;
@@ -478,29 +513,46 @@
 {
     array_header *list = d->ign_list;
     struct item *items = (struct item *) list->elts;
     char *tt;
     int i;
 
-    if ((tt = strrchr(path, '/')) == NULL)
+    if ((tt = strrchr(path, '/')) == NULL) {
 	tt = path;
+    }
     else {
 	tt++;
     }
 
     for (i = 0; i < list->nelts; ++i) {
 	struct item *p = &items[i];
 	char *ap;
 
-	if ((ap = strrchr(p->apply_to, '/')) == NULL)
+	if ((ap = strrchr(p->apply_to, '/')) == NULL) {
 	    ap = p->apply_to;
-	else
+	}
+	else {
 	    ap++;
+	}
 
-	if (!ap_strcmp_match(path, p->apply_path) && !ap_strcmp_match(tt, ap))
+#ifndef CASE_BLIND_FILESYSTEM
+	if (!ap_strcmp_match(path, p->apply_path)
+	    && !ap_strcmp_match(tt, ap)) {
 	    return 1;
+	}
+#else  /* !CASE_BLIND_FILESYSTEM */
+	/*
+	 * On some platforms, the match must be case-blind.  This is really
+	 * a factor of the filesystem involved, but we can't detect that
+	 * reliably - so we have to granularise at the OS level.
+	 */
+	if (!ap_strcasecmp_match(path, p->apply_path)
+	    && !ap_strcasecmp_match(tt, ap)) {
+	    return 1;
+	}
+#endif /* !CASE_BLIND_FILESYSTEM */
     }
     return 0;
 }
 
 static int find_opts(autoindex_config_rec * d, request_rec *r)
 {
@@ -509,14 +561,15 @@
     struct item *items = (struct item *) list->elts;
     int i;
 
     for (i = 0; i < list->nelts; ++i) {
 	struct item *p = &items[i];
 
-	if (!ap_strcmp_match(path, p->apply_path))
+	if (!ap_strcmp_match(path, p->apply_path)) {
 	    return (int) (long) p->type;
+	}
     }
     return 0;
 }
 
 /*****************************************************************
  *
@@ -524,93 +577,101 @@
  */
 
 /*
  * Look for the specified file, and pump it into the response stream if we
  * find it.
  */
-static int insert_readme(char *name, char *readme_fname, char *title, int hrule,
-			 int whichend, request_rec *r)
+static int insert_readme(char *name, char *readme_fname, char *title,
+			 int hrule, int whichend, request_rec *r)
 {
     char *fn;
     FILE *f;
     struct stat finfo;
     int plaintext = 0;
     request_rec *rr;
-    autoindex_config_rec *cfg =
-    (autoindex_config_rec *) ap_get_module_config
-    (
-	r->per_dir_config,
-	&autoindex_module
-    );
-    int autoindex_opts = find_opts(cfg, r);
+    autoindex_config_rec *cfg;
+    int autoindex_opts;
 
+    cfg = (autoindex_config_rec *) ap_get_module_config(r->per_dir_config,
+							&autoindex_module);
+    autoindex_opts = find_opts(cfg, r);
     /* XXX: this is a load of crap, it needs to do a full sub_req_lookup_uri */
     fn = ap_make_full_path(r->pool, name, readme_fname);
     fn = ap_pstrcat(r->pool, fn, ".html", NULL);
     if (stat(fn, &finfo) == -1) {
 	/* A brief fake multiviews search for README.html */
 	fn[strlen(fn) - 5] = '\0';
-	if (stat(fn, &finfo) == -1)
+	if (stat(fn, &finfo) == -1) {
 	    return 0;
+	}
 	plaintext = 1;
-	if (hrule)
+	if (hrule) {
 	    ap_rputs("<HR>\n", r);
+	}
     }
-    else if (hrule)
+    else if (hrule) {
 	ap_rputs("<HR>\n", r);
+    }
     /* XXX: when the above is rewritten properly, this necessary security
      * check will be redundant. -djg */
     rr = ap_sub_req_lookup_file(fn, r);
     if (rr->status != HTTP_OK) {
 	ap_destroy_sub_req(rr);
 	return 0;
     }
     ap_destroy_sub_req(rr);
-    if (!(f = ap_pfopen(r->pool, fn, "r")))
-	     return 0;
-    if (
-	   (whichend == FRONT_MATTER) &&
-	   (!(autoindex_opts & SUPPRESS_PREAMBLE))
-	) {
+    if (!(f = ap_pfopen(r->pool, fn, "r"))) {
+        return 0;
+    }
+    if ((whichend == FRONT_MATTER)
+	&& (!(autoindex_opts & SUPPRESS_PREAMBLE))) {
 	emit_preamble(r, title);
     }
     if (!plaintext) {
 	ap_send_fd(f, r);
     }
     else {
 	char buf[IOBUFSIZE + 1];
 	int i, n, c, ch;
 	ap_rputs("<PRE>\n", r);
 	while (!feof(f)) {
-	    do
+	    do {
 		n = fread(buf, sizeof(char), IOBUFSIZE, f);
+	    }
 	    while (n == -1 && ferror(f) && errno == EINTR);
-	    if (n == -1 || n == 0)
+	    if (n == -1 || n == 0) {
 		break;
+	    }
 	    buf[n] = '\0';
 	    c = 0;
 	    while (c < n) {
-		for (i = c; i < n; i++)
-		    if (buf[i] == '<' || buf[i] == '>' || buf[i] == '&')
+	        for (i = c; i < n; i++) {
+		    if (buf[i] == '<' || buf[i] == '>' || buf[i] == '&') {
 			break;
+		    }
+		}
 		ch = buf[i];
 		buf[i] = '\0';
 		ap_rputs(&buf[c], r);
-		if (ch == '<')
+		if (ch == '<') {
 		    ap_rputs("&lt;", r);
-		else if (ch == '>')
+		}
+		else if (ch == '>') {
 		    ap_rputs("&gt;", r);
-		else if (ch == '&')
+		}
+		else if (ch == '&') {
 		    ap_rputs("&amp;", r);
+		}
 		c = i + 1;
 	    }
 	}
     }
     ap_pfclose(r->pool, f);
-    if (plaintext)
+    if (plaintext) {
 	ap_rputs("</PRE>\n", r);
+    }
     return 1;
 }
 
 
 static char *find_title(request_rec *r)
 {
@@ -622,25 +683,27 @@
 	return NULL;
     }
     if (r->content_type
 	&& (!strcmp(r->content_type, "text/html")
 	    || !strcmp(r->content_type, INCLUDES_MAGIC_TYPE))
 	&& !r->content_encoding) {
-	if (!(thefile = ap_pfopen(r->pool, r->filename, "r")))
-	         return NULL;
+        if (!(thefile = ap_pfopen(r->pool, r->filename, "r"))) {
+	    return NULL;
+	}
 	n = fread(titlebuf, sizeof(char), MAX_STRING_LEN - 1, thefile);
 	if (n <= 0) {
 	    ap_pfclose(r->pool, thefile);
 	    return NULL;
 	}
 	titlebuf[n] = '\0';
 	for (x = 0, p = 0; titlebuf[x]; x++) {
-	    if (toupper(titlebuf[x]) == find[p]) {
+	    if (ap_toupper(titlebuf[x]) == find[p]) {
 		if (!find[++p]) {
-		    if ((p = ap_ind(&titlebuf[++x], '<')) != -1)
+		    if ((p = ap_ind(&titlebuf[++x], '<')) != -1) {
 			titlebuf[x + p] = '\0';
+		    }
 		    /* Scan for line breaks for Tanmoy's secretary */
 		    for (y = x; titlebuf[y]; y++) {
 			if ((titlebuf[y] == CR) || (titlebuf[y] == LF)) {
 			    if (y == x) {
 				x++;
 			    }
@@ -650,14 +713,15 @@
 			}
 		    }
 		    ap_pfclose(r->pool, thefile);
 		    return ap_pstrdup(r->pool, &titlebuf[x]);
 		}
 	    }
-	    else
+	    else {
 		p = 0;
+	    }
 	}
 	ap_pfclose(r->pool, thefile);
     }
     return NULL;
 }
 
@@ -665,82 +729,84 @@
 					autoindex_config_rec * d,
 					request_rec *r, char keyid,
 					char direction)
 {
     struct ent *p;
 
-    if ((name[0] == '.') && (!name[1]))
+    if ((name[0] == '.') && (!name[1])) {
 	return (NULL);
+    }
 
-    if (ignore_entry(d, ap_make_full_path(r->pool, r->filename, name)))
-	     return (NULL);
+    if (ignore_entry(d, ap_make_full_path(r->pool, r->filename, name))) {
+        return (NULL);
+    }
 
     p = (struct ent *) ap_pcalloc(r->pool, sizeof(struct ent));
     p->name = ap_pstrdup(r->pool, name);
     p->size = 0;
     p->icon = NULL;
     p->alt = NULL;
     p->desc = NULL;
     p->lm = -1;
-    p->key = toupper(keyid);
-    p->ascending = (toupper(direction) == D_ASCENDING);
+    p->key = ap_toupper(keyid);
+    p->ascending = (ap_toupper(direction) == D_ASCENDING);
 
     if (autoindex_opts & FANCY_INDEXING) {
 	request_rec *rr = ap_sub_req_lookup_file(name, r);
 
 	if (rr->finfo.st_mode != 0) {
 	    p->lm = rr->finfo.st_mtime;
 	    if (S_ISDIR(rr->finfo.st_mode)) {
-		if (!(p->icon = find_icon(d, rr, 1)))
+	        if (!(p->icon = find_icon(d, rr, 1))) {
 		    p->icon = find_default_icon(d, "^^DIRECTORY^^");
-		if (!(p->alt = find_alt(d, rr, 1)))
+		}
+		if (!(p->alt = find_alt(d, rr, 1))) {
 		    p->alt = "DIR";
+		}
 		p->size = 0;
 		p->name = ap_pstrcat(r->pool, name, "/", NULL);
 	    }
 	    else {
 		p->icon = find_icon(d, rr, 0);
 		p->alt = find_alt(d, rr, 0);
 		p->size = rr->finfo.st_size;
 	    }
 	}
 
 	p->desc = find_desc(d, rr);
 
-	if ((!p->desc) && (autoindex_opts & SCAN_HTML_TITLES))
+	if ((!p->desc) && (autoindex_opts & SCAN_HTML_TITLES)) {
 	    p->desc = ap_pstrdup(r->pool, find_title(rr));
+	}
 
 	ap_destroy_sub_req(rr);
     }
-    if (keyid == K_SIZE) {
-	p->size_cmp = ap_palloc(r->pool, 14);
-	ap_snprintf(p->size_cmp, 14, "%013d", p->size);
-    }
+    /*
+     * We don't need to take any special action for the file size key.  If
+     * we did, it would go here.
+     */
     if (keyid == K_LAST_MOD) {
-	struct tm *ts = localtime(&p->lm);
-
-	if(ts) {
-	    p->lm_cmp = ap_palloc(r->pool, 15);
-	    strftime(p->lm_cmp, 15, "%Y%m%d%H%M%S", ts);
+        if (p->lm < 0) {
+	    p->lm = 0;
 	}
-	else
-	    p->lm_cmp=NULL;
     }
     return (p);
 }
 
 static char *terminate_description(autoindex_config_rec * d, char *desc,
 				   int autoindex_opts)
 {
     int maxsize = 23;
     register int x;
 
-    if (autoindex_opts & SUPPRESS_LAST_MOD)
+    if (autoindex_opts & SUPPRESS_LAST_MOD) {
 	maxsize += 19;
-    if (autoindex_opts & SUPPRESS_SIZE)
+    }
+    if (autoindex_opts & SUPPRESS_SIZE) {
 	maxsize += 7;
+    }
 
     for (x = 0; desc[x] && (maxsize > 0 || desc[x]=='<'); x++) {
 	if (desc[x] == '<') {
 	    while (desc[x] != '>') {
 		if (!desc[x]) {
 		    maxsize = 0;
@@ -756,14 +822,15 @@
  		if (desc[x] == '\0') {
                      maxsize = 0;
                      break;
 		}
 	    }
         }
-	else
+	else {
 	    --maxsize;
+	}
     }
     if (!maxsize && desc[x] != '\0') {
 	desc[x - 1] = '>';	/* Grump. */
 	desc[x] = '\0';		/* Double Grump! */
     }
     return desc;
@@ -846,20 +913,23 @@
 
     for (x = 0; x < n; x++) {
 	char *anchor = NULL, *t = NULL, *t2 = NULL;
 
 	ap_clear_pool(scratch);
 
-	if ((!strcmp(ar[x]->name, "../")) || (!strcmp(ar[x]->name, ".."))) {
+	if (is_parent(ar[x]->name)) {
 	    t = ap_make_full_path(scratch, name, "../");
 	    ap_getparents(t);
-	    if (t[0] == '\0')
+	    if (t[0] == '\0') {
 		t = "/";
+	    }
 	    anchor = ap_pstrcat(scratch, "<A HREF=\"",
-			ap_escape_html(scratch, ap_os_escape_path(scratch, t, 0)),
-			     "\">", NULL);
+				ap_escape_html(scratch,
+					       ap_os_escape_path(scratch, t,
+								 0)),
+				"\">", NULL);
 	    t2 = "Parent Directory</A>       ";
 	}
 	else {
 	    t = ar[x]->name;
 	    len = strlen(t);
 	    if (len > 23) {
@@ -874,38 +944,38 @@
 		char buff[24] = "                       ";
 		t2 = ap_escape_html(scratch, t);
 		buff[23 - len] = '\0';
 		t2 = ap_pstrcat(scratch, t2, "</A>", buff, NULL);
 	    }
 	    anchor = ap_pstrcat(scratch, "<A HREF=\"",
-			ap_escape_html(scratch, ap_os_escape_path(scratch, t, 0)),
-			     "\">", NULL);
+				ap_escape_html(scratch,
+					       ap_os_escape_path(scratch, t,
+								 0)),
+				"\">", NULL);
 	}
 
 	if (autoindex_opts & FANCY_INDEXING) {
-	    if (autoindex_opts & ICONS_ARE_LINKS)
+	    if (autoindex_opts & ICONS_ARE_LINKS) {
 		ap_rputs(anchor, r);
+	    }
 	    if ((ar[x]->icon) || d->default_icon) {
 		ap_rvputs(r, "<IMG SRC=\"",
-		       ap_escape_html(scratch, ar[x]->icon ?
-				   ar[x]->icon : d->default_icon),
-		       "\" ALT=\"[", (ar[x]->alt ? ar[x]->alt : "   "),
-		       "]\"", NULL);
+			  ap_escape_html(scratch,
+					 ar[x]->icon ? ar[x]->icon
+					             : d->default_icon),
+			  "\" ALT=\"[", (ar[x]->alt ? ar[x]->alt : "   "),
+			  "]\"", NULL);
 		if (d->icon_width && d->icon_height) {
-		    ap_rprintf
-			(
-			    r,
-			    " HEIGHT=\"%d\" WIDTH=\"%d\"",
-			    d->icon_height,
-			    d->icon_width
-			);
+		    ap_rprintf(r, " HEIGHT=\"%d\" WIDTH=\"%d\"",
+			       d->icon_height, d->icon_width);
 		}
 		ap_rputs(">", r);
 	    }
-	    if (autoindex_opts & ICONS_ARE_LINKS)
+	    if (autoindex_opts & ICONS_ARE_LINKS) {
 		ap_rputs("</A>", r);
+	    }
 
 	    ap_rvputs(r, " ", anchor, t2, NULL);
 	    if (!(autoindex_opts & SUPPRESS_LAST_MOD)) {
 		if (ar[x]->lm != -1) {
 		    char time_str[MAX_STRING_LEN];
 		    struct tm *ts = localtime(&ar[x]->lm);
@@ -919,104 +989,88 @@
 	    if (!(autoindex_opts & SUPPRESS_SIZE)) {
 		ap_send_size(ar[x]->size, r);
 		ap_rputs("  ", r);
 	    }
 	    if (!(autoindex_opts & SUPPRESS_DESC)) {
 		if (ar[x]->desc) {
-		    ap_rputs(terminate_description(d, ar[x]->desc, autoindex_opts), r);
+		    ap_rputs(terminate_description(d, ar[x]->desc,
+						   autoindex_opts), r);
 		}
 	    }
 	}
-	else
+	else {
 	    ap_rvputs(r, "<LI> ", anchor, " ", t2, NULL);
+	}
 	ap_rputc('\n', r);
     }
     if (autoindex_opts & FANCY_INDEXING) {
 	ap_rputs("</PRE>", r);
     }
     else {
 	ap_rputs("</UL>", r);
     }
 }
 
+/*
+ * Compare two file entries according to the sort criteria.  The return
+ * is essentially a signum function value.
+ */
 
 static int dsortf(struct ent **e1, struct ent **e2)
 {
-    char *s1;
-    char *s2;
-    char *s3;
-    int result;
+    struct ent *c1;
+    struct ent *c2;
+    int result = 0;
 
     /*
-     * Choose the right values for the sort keys.
+     * First, see if either of the entries is for the parent directory.
+     * If so, that *always* sorts lower than anything else.
      */
-    switch ((*e1)->key) {
-    case K_LAST_MOD:
-	s1 = (*e1)->lm_cmp;
-	s2 = (*e2)->lm_cmp;
-	break;
-    case K_SIZE:
-	s1 = (*e1)->size_cmp;
-	s2 = (*e2)->size_cmp;
-	break;
-    case K_DESC:
-	s1 = (*e1)->desc;
-	s2 = (*e2)->desc;
-	break;
-    case K_NAME:
-    default:
-	s1 = (*e1)->name;
-	s2 = (*e2)->name;
-	break;
+    if (is_parent((*e1)->name)) {
+        return -1;
     }
-    /*
-     * If we're supposed to sort in DEscending order, reverse the arguments.
-     */
-    if (!(*e1)->ascending) {
-	s3 = s1;
-	s1 = s2;
-	s2 = s3;
+    if (is_parent((*e2)->name)) {
+        return 1;
     }
-
-    /*
-     * Take some care, here, in case one string or the other (or both) is
-     * NULL.
-     */
-
     /*
-     * Two valid strings, compare normally.
+     * All of our comparisons will be of the c1 entry against the c2 one,
+     * so assign them appropriately to take care of the ordering.
      */
-    if ((s1 != NULL) && (s2 != NULL)) {
-	result = strcmp(s1, s2);
+    if ((*e1)->ascending) {
+        c1 = *e1;
+        c2 = *e2;
     }
-    /*
-     * Two NULL strings - primary keys are equal (fake it).
-     */
-    else if ((s1 == NULL) && (s2 == NULL)) {
-	result = 0;
-    }
-    /*
-     * s1 is NULL, but s2 is a string - so s2 wins.
-     */
-    else if (s1 == NULL) {
-	result = -1;
-    }
-    /*
-     * Last case: s1 is a string and s2 is NULL, so s1 wins.
-     */
     else {
-	result = 1;
+        c1 = *e2;
+        c2 = *e1;
     }
-    /*
-     * If the keys were equal, the file name is *always* the secondary key -
-     * in ascending order.
-     */
-    if (!result) {
-	result = strcmp((*e1)->name, (*e2)->name);
+    switch (c1->key) {
+    case K_LAST_MOD:
+	if (c1->lm > c2->lm) {
+            return 1;
+        }
+        else if (c1->lm < c2->lm) {
+            return -1;
+        }
+        break;
+    case K_SIZE:
+        if (c1->size > c2->size) {
+            return 1;
+        }
+        else if (c1->size < c2->size) {
+            return -1;
+        }
+        break;
+    case K_DESC:
+        result = strcmp(c1->desc ? c1->desc : "", c2->desc ? c2->desc : "");
+        if (result) {
+            return result;
+        }
+        break;
     }
-    return result;
+    return strcmp(c1->name, c2->name);
 }
 
 
 static int index_directory(request_rec *r, autoindex_config_rec * autoindex_conf)
 {
     char *title_name = ap_escape_html(r->pool, r->uri);
@@ -1051,14 +1105,15 @@
     ap_hard_timeout("send directory", r);
 
     /* Spew HTML preamble */
 
     title_endp = title_name + strlen(title_name) - 1;
 
-    while (title_endp > title_name && *title_endp == '/')
+    while (title_endp > title_name && *title_endp == '/') {
 	*title_endp-- = '\0';
+    }
 
     if ((!(tmp = find_header(autoindex_conf, r)))
 	|| (!(insert_readme(name, tmp, title_name, NO_HRULE, FRONT_MATTER, r)))
 	) {
 	emit_preamble(r, title_name);
 	ap_rvputs(r, "<H1>Index of ", title_name, "</H1>\n", NULL);
@@ -1106,31 +1161,33 @@
 	    p->next = head;
 	    head = p;
 	    num_ent++;
 	}
     }
     if (num_ent > 0) {
-	ar = (struct ent **) ap_palloc(r->pool, num_ent * sizeof(struct ent *));
+	ar = (struct ent **) ap_palloc(r->pool,
+				       num_ent * sizeof(struct ent *));
 	p = head;
 	x = 0;
 	while (p) {
 	    ar[x++] = p;
 	    p = p->next;
 	}
 
 	qsort((void *) ar, num_ent, sizeof(struct ent *),
-	          (int (*)(const void *, const void *)) dsortf);
+	      (int (*)(const void *, const void *)) dsortf);
     }
     output_directories(ar, num_ent, autoindex_conf, r, autoindex_opts, keyid,
 		       direction);
     ap_pclosedir(r->pool, d);
 
     if ((tmp = find_readme(autoindex_conf, r))) {
 	if (!insert_readme(name, tmp, "",
-                      ((autoindex_opts & FANCY_INDEXING) ? HRULE : NO_HRULE),
-                      END_MATTER, r)) {
+			   ((autoindex_opts & FANCY_INDEXING) ? HRULE
+			                                      : NO_HRULE),
+			   END_MATTER, r)) {
 	    ap_rputs(ap_psignature("<HR>\n", r), r);
 	}
     }
     ap_rputs("</BODY></HTML>\n", r);
 
     ap_kill_timeout(r);
@@ -1138,20 +1195,22 @@
 }
 
 /* The formal handler... */
 
 static int handle_autoindex(request_rec *r)
 {
-    autoindex_config_rec *d =
-    (autoindex_config_rec *) ap_get_module_config(r->per_dir_config,
-					       &autoindex_module);
+    autoindex_config_rec *d;
     int allow_opts = ap_allow_options(r);
 
+    d = (autoindex_config_rec *) ap_get_module_config(r->per_dir_config,
+						      &autoindex_module);
+
     r->allowed |= (1 << M_GET);
-    if (r->method_number != M_GET)
+    if (r->method_number != M_GET) {
 	return DECLINED;
+    }
 
     /* OK, nothing easy.  Trot out the heavy artillery... */
 
     if (allow_opts & OPT_INDEXES) {
 	/* KLUDGE --- make the sub_req lookups happen in the right directory.
 	 * Fixing this in the sub_req_lookup functions themselves is difficult,
@@ -1162,13 +1221,13 @@
 	    r->filename = ap_pstrcat(r->pool, r->filename, "/", NULL);
 	}
 	return index_directory(r, d);
     }
     else {
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
-		    "Directory index forbidden by rule: %s", r->filename);
+		     "Directory index forbidden by rule: %s", r->filename);
 	return HTTP_FORBIDDEN;
     }
 }
 
 
 static const handler_rec autoindex_handlers[] =
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_cern_meta.c apache_1.3.1/src/modules/standard/mod_cern_meta.c
--- apache_1.3.0/src/modules/standard/mod_cern_meta.c	1998-04-11 20:00:45.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_cern_meta.c	1998-07-09 01:47:14.000000000 +0800
@@ -214,13 +214,14 @@
     return NULL;
 }
 
 
 static const command_rec cern_meta_cmds[] =
 {
-    {"MetaFiles", set_metafiles, NULL, DIR_CMD_PERMS, FLAG, NULL},
+    {"MetaFiles", set_metafiles, NULL, DIR_CMD_PERMS, FLAG,
+    "Limited to 'on' or 'off'"},
     {"MetaDir", set_metadir, NULL, DIR_CMD_PERMS, TAKE1,
      "the name of the directory containing meta files"},
     {"MetaSuffix", set_metasuffix, NULL, DIR_CMD_PERMS, TAKE1,
      "the filename suffix for meta files"},
     {NULL}
 };
@@ -253,25 +254,26 @@
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
 			"malformed header in meta file: %s", r->filename);
 	    return SERVER_ERROR;
 	}
 
 	*l++ = '\0';
-	while (*l && isspace(*l))
+	while (*l && ap_isspace(*l))
 	    ++l;
 
 	if (!strcasecmp(w, "Content-type")) {
-
+	    char *tmp;
 	    /* Nuke trailing whitespace */
 
 	    char *endp = l + strlen(l) - 1;
-	    while (endp > l && isspace(*endp))
+	    while (endp > l && ap_isspace(*endp))
 		*endp-- = '\0';
 
-	    r->content_type = ap_pstrdup(r->pool, l);
-	    ap_str_tolower(r->content_type);
+	    tmp = ap_pstrdup(r->pool, l);
+	    ap_content_type_tolower(tmp);
+	    r->content_type = tmp;
 	}
 	else if (!strcasecmp(w, "Status")) {
 	    sscanf(l, "%d", &r->status);
 	    r->status_line = ap_pstrdup(r->pool, l);
 	}
 	else {
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_cgi.c apache_1.3.1/src/modules/standard/mod_cgi.c
--- apache_1.3.0/src/modules/standard/mod_cgi.c	1998-05-29 06:09:56.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_cgi.c	1998-06-28 02:09:31.000000000 +0800
@@ -85,13 +85,13 @@
  * request came through ScriptAlias or not... so the Alias module
  * leaves a note for us.
  */
 
 static int is_scriptaliased(request_rec *r)
 {
-    char *t = ap_table_get(r->notes, "alias-forced-type");
+    const char *t = ap_table_get(r->notes, "alias-forced-type");
     return t && (!strcasecmp(t, "cgi-script"));
 }
 
 /* Configuration stuff */
 
 #define DEFAULT_LOGBYTES 10385760
@@ -190,15 +190,15 @@
 
     ap_pfclose(r->pool, f);
     return ret;
 }
 
 static int log_script(request_rec *r, cgi_server_conf * conf, int ret,
-		  char *dbuf, char *sbuf, BUFF *script_in, BUFF *script_err)
+		  char *dbuf, const char *sbuf, BUFF *script_in, BUFF *script_err)
 {
-    array_header *hdrs_arr = table_elts(r->headers_in);
+    array_header *hdrs_arr = ap_table_elts(r->headers_in);
     table_entry *hdrs = (table_entry *) hdrs_arr->elts;
     char argsbuffer[HUGE_STRING_LEN];
     FILE *f;
     int i;
     struct stat finfo;
 
@@ -230,13 +230,13 @@
     if ((r->method_number == M_POST || r->method_number == M_PUT)
 	&& *dbuf) {
 	fprintf(f, "\n%s\n", dbuf);
     }
 
     fputs("%response\n", f);
-    hdrs_arr = table_elts(r->err_headers_out);
+    hdrs_arr = ap_table_elts(r->err_headers_out);
     hdrs = (table_entry *) hdrs_arr->elts;
 
     for (i = 0; i < hdrs_arr->nelts; ++i) {
 	if (!hdrs[i].key)
 	    continue;
 	fprintf(f, "%s: %s\n", hdrs[i].key, hdrs[i].val);
@@ -488,13 +488,14 @@
     }
 
     ap_bclose(script_out);
 
     /* Handle script return... */
     if (script_in && !nph) {
-	char *location, sbuf[MAX_STRING_LEN];
+	const char *location;
+	char sbuf[MAX_STRING_LEN];
 	int ret;
 
 	if ((ret = ap_scan_script_header_err_buff(r, script_in, sbuf))) {
 	    return log_script(r, conf, ret, dbuf, sbuf, script_in, script_err);
 	}
 
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_digest.c apache_1.3.1/src/modules/standard/mod_digest.c
--- apache_1.3.0/src/modules/standard/mod_digest.c	1998-04-11 20:00:46.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_digest.c	1998-07-09 01:47:14.000000000 +0800
@@ -138,13 +138,14 @@
 {
     const char *auth_line = ap_table_get(r->headers_in,
                                     r->proxyreq ? "Proxy-Authorization"
                                     : "Authorization");
     int l;
     int s, vk = 0, vv = 0;
-    char *t, *key, *value;
+    const char *t;
+    char *key, *value;
 
     if (!(t = ap_auth_type(r)) || strcasecmp(t, "Digest"))
 	return DECLINED;
 
     if (!ap_auth_name(r)) {
 	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
@@ -193,13 +194,13 @@
 		vv++;
 	    }
 	    auth_line++;
 	    break;
 
 	case D_VALUE:
-	    if (isalnum(auth_line[0])) {
+	    if (ap_isalnum(auth_line[0])) {
 		value[vv] = auth_line[0];
 		vv++;
 	    }
 	    else if (auth_line[0] == '\"') {
 		s = D_STRING;
 	    }
@@ -221,13 +222,13 @@
 		s = D_KEY;
 	    }
 	    auth_line++;
 	    break;
 
 	case D_KEY:
-	    if (isalnum(auth_line[0])) {
+	    if (ap_isalnum(auth_line[0])) {
 		key[vk] = auth_line[0];
 		vk++;
 	    }
 	    else if (auth_line[0] == '=') {
 		key[vk] = '\0';
 		vk = 0;
@@ -317,13 +318,13 @@
     char *user = r->connection->user;
     int m = r->method_number;
     int method_restricted = 0;
     register int x;
     const char *t;
     char *w;
-    array_header *reqs_arr;
+    const array_header *reqs_arr;
     require_line *reqs;
 
     if (!(t = ap_auth_type(r)) || strcasecmp(t, "Digest"))
 	return DECLINED;
 
     reqs_arr = ap_requires(r);
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_env.c apache_1.3.1/src/modules/standard/mod_env.c
--- apache_1.3.0/src/modules/standard/mod_env.c	1998-04-11 20:00:46.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_env.c	1998-06-28 02:09:32.000000000 +0800
@@ -142,13 +142,13 @@
      *     table_unset( new_table, $unsetenv );
      * }
      */
 
     new_table = ap_copy_table(p, base->vars);
 
-    arr = table_elts(add->vars);
+    arr = ap_table_elts(add->vars);
     elts = (table_entry *)arr->elts;
 
     for (i = 0; i < arr->nelts; ++i) {
         ap_table_setn(new_table, elts[i].key, elts[i].val);
     }
 
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_expires.c apache_1.3.1/src/modules/standard/mod_expires.c
--- apache_1.3.0/src/modules/standard/mod_expires.c	1998-04-11 20:00:46.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_expires.c	1998-07-09 01:47:15.000000000 +0800
@@ -281,13 +281,13 @@
 
     /* {<num> <type>}*
      */
     while (word[0]) {
         /* <num>
          */
-        if (isdigit(word[0])) {
+        if (ap_isdigit(word[0])) {
             num = atoi(word);
         }
         else {
             return ap_pstrcat(p, "bad expires code, numeric value expected <num> '",
                            word, "'", NULL);
         };
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_imap.c apache_1.3.1/src/modules/standard/mod_imap.c
--- apache_1.3.0/src/modules/standard/mod_imap.c	1998-04-11 20:00:47.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_imap.c	1998-07-09 01:47:15.000000000 +0800
@@ -260,13 +260,13 @@
     double x_coord = -1;        /* -1 is returned if no coordinate is given */
 
     if (args == NULL) {
         return (-1);            /* in case we aren't passed anything */
     }
 
-    while (*args && !isdigit(*args) && *args != ',') {
+    while (*args && !ap_isdigit(*args) && *args != ',') {
         args++;                 /* jump to the first digit, but not past
                                    a comma or end */
     }
 
     x_coord = strtod(args, &endptr);
 
@@ -292,13 +292,13 @@
 
     if (start_of_y) {
 
         start_of_y++;           /* start looking at the character after
                                    the comma */
 
-        while (*start_of_y && !isdigit(*start_of_y)) {
+        while (*start_of_y && !ap_isdigit(*start_of_y)) {
             start_of_y++;       /* jump to the first digit, but not
                                    past the end */
 	}
 
         y_coord = strtod(start_of_y, &endptr);
 
@@ -323,13 +323,13 @@
 {
     char *strp = *string;
 
     /* assume there's no quoted part */
     *quoted_part = NULL;
 
-    while (isspace(*strp)) {
+    while (ap_isspace(*strp)) {
         strp++;               	/* go along string until non-whitespace */
     }
 
     if (*strp == '"') {       	/* if that character is a double quote */
         strp++;               	/* step over it */
 	*quoted_part = strp;  	/* note where the quoted part begins */
@@ -352,13 +352,13 @@
 {
 /* translates a value into a URL. */
     int slen, clen;
     char *string_pos = NULL;
     const char *string_pos_const = NULL;
     char *directory = NULL;
-    char *referer = NULL;
+    const char *referer = NULL;
     char *my_base;
 
     if (!strcasecmp(value, "map") || !strcasecmp(value, "menu")) {
 	return ap_construct_url(r->pool, r->uri, r);
     }
 
@@ -382,13 +382,13 @@
             value = "";      /* if 'referer' but no referring page,
                                 null the value */
         }
     }
 
     string_pos_const = value;
-    while (isalpha(*string_pos_const)) {
+    while (ap_isalpha(*string_pos_const)) {
 	string_pos_const++;           /* go along the URL from the map
                                          until a non-letter */
     }
     if (*string_pos_const == ':') {
 	/* if letters and then a colon (like http:) */
 	/* it's an absolute URL, so use it! */
@@ -743,23 +743,23 @@
 
         vertex = 0;
         while (vertex < MAXVERTS &&
                sscanf(string_pos, "%lf%*[, ]%lf",
                       &pointarray[vertex][X], &pointarray[vertex][Y]) == 2) {
             /* Now skip what we just read... we can't use ANSIism %n */
-            while (isspace(*string_pos)) {      /* past whitespace */
+            while (ap_isspace(*string_pos)) {      /* past whitespace */
                 string_pos++;
 	    }
-            while (isdigit(*string_pos)) {      /* and the 1st number */
+            while (ap_isdigit(*string_pos)) {      /* and the 1st number */
                 string_pos++;
 	    }
             string_pos++;       /* skip the ',' */
-            while (isspace(*string_pos)) {      /* past any more whitespace */
+            while (ap_isspace(*string_pos)) {      /* past any more whitespace */
                 string_pos++;
 	    }
-            while (isdigit(*string_pos)) {      /* 2nd number */
+            while (ap_isdigit(*string_pos)) {      /* 2nd number */
                 string_pos++;
 	    }
             vertex++;
         }                       /* so long as there are more vertices to
                                    read, and we have room, read them in.
                                    We start where we left off of the last
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_include.c apache_1.3.1/src/modules/standard/mod_include.c
--- apache_1.3.0/src/modules/standard/mod_include.c	1998-05-29 16:18:51.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_include.c	1998-07-09 01:47:16.000000000 +0800
@@ -306,13 +306,13 @@
             *p = *s;
             continue;
         }
 
         /* is it numeric ? */
         if (s[1] == '#') {
-            for (j = 2, val = 0; j < i && isdigit(s[j]); j++) {
+            for (j = 2, val = 0; j < i && ap_isdigit(s[j]); j++) {
                 val = val * 10 + s[j] - '0';
             }
             s += i;
             if (j < i || val <= 8 || (val >= 11 && val <= 31) ||
                 (val >= 127 && val <= 160) || val >= 256) {
                 p--;            /* no data to output */
@@ -359,21 +359,21 @@
 
     /* makes code below a little less cluttered */
     --tagbuf_len;
 
     do {                        /* skip whitespace */
         GET_CHAR(in, c, NULL, p);
-    } while (isspace(c));
+    } while (ap_isspace(c));
 
     /* tags can't start with - */
     if (c == '-') {
         GET_CHAR(in, c, NULL, p);
         if (c == '-') {
             do {
                 GET_CHAR(in, c, NULL, p);
-            } while (isspace(c));
+            } while (ap_isspace(c));
             if (c == '>') {
                 ap_cpystrn(tag, "done", tagbuf_len);
                 return tag;
             }
         }
         return NULL;            /* failed */
@@ -382,33 +382,33 @@
     /* find end of tag name */
     while (1) {
         if (t - tag == tagbuf_len) {
             *t = '\0';
             return NULL;
         }
-        if (c == '=' || isspace(c)) {
+        if (c == '=' || ap_isspace(c)) {
             break;
         }
-        *(t++) = tolower(c);
+        *(t++) = ap_tolower(c);
         GET_CHAR(in, c, NULL, p);
     }
 
     *t++ = '\0';
     tag_val = t;
 
-    while (isspace(c)) {
+    while (ap_isspace(c)) {
         GET_CHAR(in, c, NULL, p);       /* space before = */
     }
     if (c != '=') {
         ungetc(c, in);
         return NULL;
     }
 
     do {
         GET_CHAR(in, c, NULL, p);       /* space after = */
-    } while (isspace(c));
+    } while (ap_isspace(c));
 
     /* we should allow a 'name' as a value */
 
     if (c != '"' && c != '\'') {
         return NULL;
     }
@@ -447,24 +447,24 @@
     /* make room for nul terminator */
     --len;
 
     /* skip initial whitespace */
     while (1) {
         GET_CHAR(in, c, 1, p);
-        if (!isspace(c)) {
+        if (!ap_isspace(c)) {
             break;
         }
     }
     /* now get directive */
     while (1) {
 	if (d - dest == len) {
 	    return 1;
 	}
-        *d++ = tolower(c);
+        *d++ = ap_tolower(c);
         GET_CHAR(in, c, 1, p);
-        if (isspace(c)) {
+        if (ap_isspace(c)) {
             break;
         }
     }
     *d = '\0';
     return 0;
 }
@@ -521,13 +521,13 @@
                     }
 		    end_of_var_name = in;
 		    ++in;
 		}
 		else {
 		    start_of_var_name = in;
-		    while (isalnum(*in) || *in == '_') {
+		    while (ap_isalnum(*in) || *in == '_') {
 			++in;
 		    }
 		    end_of_var_name = in;
 		}
 		/* what a pain, too bad there's no table_getn where you can
 		 * pass a non-nul terminated string */
@@ -604,13 +604,13 @@
     rr->content_type = CGI_MAGIC_TYPE;
 
     /* Run it. */
 
     rr_status = ap_run_sub_req(rr);
     if (is_HTTP_REDIRECT(rr_status)) {
-        char *location = ap_table_get(rr->headers_out, "Location");
+        const char *location = ap_table_get(rr->headers_out, "Location");
         location = ap_escape_html(rr->pool, location);
         ap_rvputs(r, "<A HREF=\"", location, "\">", location, "</A>", NULL);
     }
 
     ap_destroy_sub_req(rr);
 #ifndef WIN32
@@ -890,13 +890,13 @@
 
     while (1) {
         if (!(tag_val = get_tag(r->pool, in, tag, sizeof(tag), 1))) {
             return 1;
         }
         if (!strcmp(tag, "var")) {
-            char *val = ap_table_get(r->subprocess_env, tag_val);
+            const char *val = ap_table_get(r->subprocess_env, tag_val);
 
             if (val) {
                 ap_rputs(val, r);
             }
             else {
                 ap_rputs("(none)", r);
@@ -915,12 +915,13 @@
 }
 
 #ifdef USE_PERL_SSI
 static int handle_perl(FILE *in, request_rec *r, const char *error)
 {
     char tag[MAX_STRING_LEN];
+    char parsed_string[MAX_STRING_LEN];
     char *tag_val;
     SV *sub = Nullsv;
     AV *av = newAV();
 
     if (!(ap_allow_options(r) & OPT_INCLUDES)) {
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
@@ -933,13 +934,14 @@
             break;
         }
         if (strnEQ(tag, "sub", 3)) {
             sub = newSVpv(tag_val, 0);
         }
         else if (strnEQ(tag, "arg", 3)) {
-            av_push(av, newSVpv(tag_val, 0));
+            parse_string(r, tag_val, parsed_string, sizeof(parsed_string), 0);
+            av_push(av, newSVpv(parsed_string, 0));
         }
         else if (strnEQ(tag, "done", 4)) {
             break;
         }
     }
     perl_stdout2client(r);
@@ -1147,13 +1149,13 @@
 
     /* Skip leading white space */
     if (string == (char *) NULL) {
         return (char *) NULL;
     }
     while ((ch = *string++)) {
-        if (!isspace(ch)) {
+        if (!ap_isspace(ch)) {
             break;
         }
     }
     if (ch == '\0') {
         return (char *) NULL;
     }
@@ -1236,13 +1238,13 @@
                 goto TOKEN_DONE;
             }
             token->value[next++] = ch;
             continue;
         }
         if (!qs) {
-            if (isspace(ch)) {
+            if (ap_isspace(ch)) {
                 goto TOKEN_DONE;
             }
             switch (ch) {
             case '(':
                 goto TOKEN_DONE;
             case ')':
@@ -2044,13 +2046,13 @@
 }
 
 static int handle_printenv(FILE *in, request_rec *r, const char *error)
 {
     char tag[MAX_STRING_LEN];
     char *tag_val;
-    array_header *arr = table_elts(r->subprocess_env);
+    array_header *arr = ap_table_elts(r->subprocess_env);
     table_entry *elts = (table_entry *) arr->elts;
     int i;
 
     if (!(tag_val = get_tag(r->pool, in, tag, sizeof(tag), 1))) {
         return 1;
     }
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_log_agent.c apache_1.3.1/src/modules/standard/mod_log_agent.c
--- apache_1.3.0/src/modules/standard/mod_log_agent.c	1998-05-29 16:18:51.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_log_agent.c	1998-06-15 05:10:26.000000000 +0800
@@ -141,13 +141,13 @@
 static int agent_log_transaction(request_rec *orig)
 {
     agent_log_state *cls = ap_get_module_config(orig->server->module_config,
                                              &agent_log_module);
 
     char str[HUGE_STRING_LEN];
-    char *agent;
+    const char *agent;
     request_rec *r;
 
     if (cls->agent_fd < 0)
         return OK;
 
     for (r = orig; r->next; r = r->next)
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_log_config.c apache_1.3.1/src/modules/standard/mod_log_config.c
--- apache_1.3.0/src/modules/standard/mod_log_config.c	1998-05-29 16:18:51.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_log_config.c	1998-07-09 01:47:16.000000000 +0800
@@ -212,12 +212,13 @@
  * points to the same array as config_logs in the main server, and
  * config_logs points to the array of logs defined inside this vhost,
  * which might be empty.
  */
 
 typedef struct {
+    char *default_format_string;
     array_header *default_format;
     array_header *config_logs;
     array_header *server_config_logs;
     table *formats;
 } multi_log_state;
 
@@ -229,25 +230,27 @@
  * well, use the CLF. log_fd is -1 before the log file is opened and
  * set to a valid fd after it is opened.
  */
 
 typedef struct {
     char *fname;
+    char *format_string;
     array_header *format;
     int log_fd;
 #ifdef BUFFERED_LOGS
     int outcnt;
     char outbuf[LOG_BUFSIZE];
 #endif
 } config_log_state;
 
 /*
  * Format items...
+ * Note that many of these could have ap_sprintfs replaced with static buffers.
  */
 
-typedef char *(*item_key_func) (request_rec *, char *);
+typedef const char *(*item_key_func) (request_rec *, char *);
 
 typedef struct {
     item_key_func func;
     char *arg;
     int condition_sense;
     int want_orig;
@@ -266,111 +269,111 @@
     }
     else {
         return format_integer(p, i);
     }
 }
 
-static char *constant_item(request_rec *dummy, char *stuff)
+static const char *constant_item(request_rec *dummy, char *stuff)
 {
     return stuff;
 }
 
-static char *log_remote_host(request_rec *r, char *a)
+static const char *log_remote_host(request_rec *r, char *a)
 {
-    return (char *) ap_get_remote_host(r->connection, r->per_dir_config,
+    return ap_get_remote_host(r->connection, r->per_dir_config,
                                     REMOTE_NAME);
 }
 
-static char *log_remote_address(request_rec *r, char *a)
+static const char *log_remote_address(request_rec *r, char *a)
 {
     return r->connection->remote_ip;
 }
 
-static char *log_remote_logname(request_rec *r, char *a)
+static const char *log_remote_logname(request_rec *r, char *a)
 {
-    return (char *) ap_get_remote_logname(r);
+    return ap_get_remote_logname(r);
 }
 
-static char *log_remote_user(request_rec *r, char *a)
+static const char *log_remote_user(request_rec *r, char *a)
 {
     char *rvalue = r->connection->user;
 
     if (rvalue == NULL) {
         rvalue = "-";
     }
     else if (strlen(rvalue) == 0) {
         rvalue = "\"\"";
     }
     return rvalue;
 }
 
-static char *log_request_line(request_rec *r, char *a)
+static const char *log_request_line(request_rec *r, char *a)
 {
 	    /* NOTE: If the original request contained a password, we
 	     * re-write the request line here to contain XXXXXX instead:
 	     * (note the truncation before the protocol string for HTTP/0.9 requests)
 	     * (note also that r->the_request contains the unmodified request)
 	     */
     return (r->parsed_uri.password) ? ap_pstrcat(r->pool, r->method, " ",
 					 ap_unparse_uri_components(r->pool, &r->parsed_uri, 0),
 					 r->assbackwards ? NULL : " ", r->protocol, NULL)
 					: r->the_request;
 }
 
-static char *log_request_file(request_rec *r, char *a)
+static const char *log_request_file(request_rec *r, char *a)
 {
     return r->filename;
 }
-static char *log_request_uri(request_rec *r, char *a)
+static const char *log_request_uri(request_rec *r, char *a)
 {
     return r->uri;
 }
-static char *log_status(request_rec *r, char *a)
+static const char *log_status(request_rec *r, char *a)
 {
     return pfmt(r->pool, r->status);
 }
 
-static char *log_bytes_sent(request_rec *r, char *a)
+static const char *log_bytes_sent(request_rec *r, char *a)
 {
     if (!r->sent_bodyct) {
         return "-";
     }
     else {
         long int bs;
         ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
 	return ap_psprintf(r->pool, "%ld", bs);
     }
 }
 
-static char *log_header_in(request_rec *r, char *a)
+static const char *log_header_in(request_rec *r, char *a)
 {
     return ap_table_get(r->headers_in, a);
 }
 
-static char *log_header_out(request_rec *r, char *a)
+static const char *log_header_out(request_rec *r, char *a)
 {
-    char *cp = ap_table_get(r->headers_out, a);
+    const char *cp = ap_table_get(r->headers_out, a);
     if (!strcasecmp(a, "Content-type") && r->content_type) {
         cp = r->content_type;
     }
     if (cp) {
         return cp;
     }
     return ap_table_get(r->err_headers_out, a);
 }
 
-static char *log_note(request_rec *r, char *a)
+static const char *log_note(request_rec *r, char *a)
 {
     return ap_table_get(r->notes, a);
 }
-static char *log_env_var(request_rec *r, char *a)
+static const char *log_env_var(request_rec *r, char *a)
 {
     return ap_table_get(r->subprocess_env, a);
 }
 
-static char *log_request_time(request_rec *r, char *a)
+static const char *log_request_time(request_rec *r, char *a)
 {
     int timz;
     struct tm *t;
     char tstr[MAX_STRING_LEN];
 
     t = ap_get_gmtoff(&timz);
@@ -392,31 +395,31 @@
                     "%c%.2d%.2d]", sign, timz / 60, timz % 60);
     }
 
     return ap_pstrdup(r->pool, tstr);
 }
 
-static char *log_request_duration(request_rec *r, char *a)
+static const char *log_request_duration(request_rec *r, char *a)
 {
     return ap_psprintf(r->pool, "%ld", time(NULL) - r->request_time);
 }
 
 /* These next two routines use the canonical name:port so that log
  * parsers don't need to duplicate all the vhost parsing crud.
  */
-static char *log_virtual_host(request_rec *r, char *a)
+static const char *log_virtual_host(request_rec *r, char *a)
 {
-    return ap_pstrdup(r->pool, ap_get_server_name(r));
+    return ap_get_server_name(r);
 }
 
-static char *log_server_port(request_rec *r, char *a)
+static const char *log_server_port(request_rec *r, char *a)
 {
     return ap_psprintf(r->pool, "%u", ap_get_server_port(r));
 }
 
-static char *log_child_pid(request_rec *r, char *a)
+static const char *log_child_pid(request_rec *r, char *a)
 {
     return ap_psprintf(r->pool, "%ld", (long) getpid());
 }
 
 /*****************************************************************
  *
@@ -578,13 +581,13 @@
         case '5':
         case '6':
         case '7':
         case '8':
         case '9':
             i = *s - '0';
-            while (isdigit(*++s)) {
+            while (ap_isdigit(*++s)) {
                 i = i * 10 + (*s) - '0';
             }
             if (!it->conditions) {
                 it->conditions = ap_make_array(p, 4, sizeof(int));
             }
             *(int *) ap_push_array(it->conditions) = i;
@@ -631,16 +634,16 @@
 
 /*****************************************************************
  *
  * Actually logging.
  */
 
-static char *process_item(request_rec *r, request_rec *orig,
+static const char *process_item(request_rec *r, request_rec *orig,
                           log_format_item *item)
 {
-    char *cp;
+    const char *cp;
 
     /* First, see if we need to process this thing at all... */
 
     if (item->conditions && item->conditions->nelts != 0) {
         int i;
         int *conds = (int *) item->conditions->elts;
@@ -676,13 +679,14 @@
 #endif
 
 static int config_log_transaction(request_rec *r, config_log_state *cls,
                                   array_header *default_format)
 {
     log_format_item *items;
-    char *str, **strs, *s;
+    char *str, *s;
+    const char **strs;
     int *strl;
     request_rec *orig;
     int i;
     int len = 0;
     array_header *format;
 
@@ -779,12 +783,13 @@
 
 static void *make_config_log_state(pool *p, server_rec *s)
 {
     multi_log_state *mls = (multi_log_state *) ap_palloc(p, sizeof(multi_log_state));
 
     mls->config_logs = ap_make_array(p, 1, sizeof(config_log_state));
+    mls->default_format_string = NULL;
     mls->default_format = NULL;
     mls->server_config_logs = NULL;
     mls->formats = ap_make_table(p, 4);
     ap_table_setn(mls->formats, "CLF", DEFAULT_LOG_FORMAT);
 
     return mls;
@@ -800,12 +805,13 @@
 {
     multi_log_state *base = (multi_log_state *) basev;
     multi_log_state *add = (multi_log_state *) addv;
 
     add->server_config_logs = base->config_logs;
     if (!add->default_format) {
+        add->default_format_string = base->default_format_string;
         add->default_format = base->default_format;
     }
     add->formats = ap_overlay_tables(p, base->formats, add->formats);
 
     return add;
 }
@@ -814,13 +820,12 @@
  * Set the default logfile format, or define a nickname for a format string.
  */
 static const char *log_format(cmd_parms *cmd, void *dummy, char *fmt,
                               char *name)
 {
     const char *err_string = NULL;
-    char *format;
     multi_log_state *mls = ap_get_module_config(cmd->server->module_config,
                                              &config_log_module);
 
     /*
      * If we were given two arguments, the second is a name to be given to the
      * format.  This syntax just defines the nickname - it doesn't actually
@@ -830,42 +835,34 @@
         parse_log_string(cmd->pool, fmt, &err_string);
         if (err_string == NULL) {
             ap_table_setn(mls->formats, name, fmt);
         }
     }
     else {
-        /*
-         * See if we were given a name rather than a format string.
-         */
-        format = ap_table_get(mls->formats, fmt);
-        if (format == NULL) {
-            format = fmt;
-        }
-        mls->default_format = parse_log_string(cmd->pool, format, &err_string);
+        mls->default_format_string = fmt;
+        mls->default_format = parse_log_string(cmd->pool, fmt, &err_string);
     }
     return err_string;
 }
 
 static const char *add_custom_log(cmd_parms *cmd, void *dummy, char *fn,
                                   char *fmt)
 {
     const char *err_string = NULL;
     multi_log_state *mls = ap_get_module_config(cmd->server->module_config,
                                              &config_log_module);
     config_log_state *cls;
-    char *format;
 
     cls = (config_log_state *) ap_push_array(mls->config_logs);
     cls->fname = fn;
+    cls->format_string = fmt;
     if (!fmt) {
         cls->format = NULL;
     }
     else {
-        format = ap_table_get(mls->formats, fmt);
-        format = (format != NULL) ? format : fmt;
-        cls->format = parse_log_string(cmd->pool, format, &err_string);
+        cls->format = parse_log_string(cmd->pool, fmt, &err_string);
     }
     cls->log_fd = -1;
 
     return err_string;
 }
 
@@ -932,30 +929,52 @@
 {
     int i;
     multi_log_state *mls = ap_get_module_config(s->module_config,
                                              &config_log_module);
     config_log_state *clsarray;
     const char *dummy;
+    const char *format;
+
+    if (mls->default_format_string) {
+	format = ap_table_get(mls->formats, mls->default_format_string);
+	if (format) {
+	    mls->default_format = parse_log_string(p, format, &dummy);
+	}
+    }    
 
     if (!mls->default_format) {
         mls->default_format = parse_log_string(p, DEFAULT_LOG_FORMAT, &dummy);
     }
 
     if (mls->config_logs->nelts) {
         clsarray = (config_log_state *) mls->config_logs->elts;
         for (i = 0; i < mls->config_logs->nelts; ++i) {
             config_log_state *cls = &clsarray[i];
 
+	    if (cls->format_string) {
+		format = ap_table_get(mls->formats, cls->format_string);
+		if (format) {
+		    cls->format = parse_log_string(p, format, &dummy);
+		}
+	    }
+
             cls = open_config_log(s, p, cls, mls->default_format);
         }
     }
     else if (mls->server_config_logs) {
         clsarray = (config_log_state *) mls->server_config_logs->elts;
         for (i = 0; i < mls->server_config_logs->nelts; ++i) {
             config_log_state *cls = &clsarray[i];
 
+	    if (cls->format_string) {
+		format = ap_table_get(mls->formats, cls->format_string);
+		if (format) {
+		    cls->format = parse_log_string(p, format, &dummy);
+		}
+	    }
+
             cls = open_config_log(s, p, cls, mls->default_format);
         }
     }
 
     return NULL;
 }
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_log_referer.c apache_1.3.1/src/modules/standard/mod_log_referer.c
--- apache_1.3.0/src/modules/standard/mod_log_referer.c	1998-05-29 16:18:51.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_log_referer.c	1998-06-15 05:10:27.000000000 +0800
@@ -159,13 +159,14 @@
 {
     char **ptrptr, **ptrptr2;
     referer_log_state *cls = ap_get_module_config(orig->server->module_config,
                                                &referer_log_module);
 
     char *str;
-    char *referer, *referertest;
+    const char *referer;
+    char *referertest;
     request_rec *r;
 
     if (cls->referer_fd < 0)
         return OK;
 
     for (r = orig; r->next; r = r->next)
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_mime.c apache_1.3.1/src/modules/standard/mod_mime.c
--- apache_1.3.0/src/modules/standard/mod_mime.c	1998-05-29 16:18:52.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_mime.c	1998-07-09 01:47:17.000000000 +0800
@@ -196,13 +196,13 @@
 /* MIME_HASHSIZE used to be 27 (26 chars and one "non-alpha" slot), but
  * with character sets like EBCDIC, this is insufficient because the
  * range 'a'...'z' is not contigous. Defining it as ('z'-'a'+2) is
  * equivalent to 27 in ASCII, and makes it work in EBCDIC.
  */
 #define MIME_HASHSIZE ('z'-'a'+2)
-#define hash(i) (isalpha(i) ? (tolower(i)) - 'a' : (MIME_HASHSIZE-1))
+#define hash(i) (ap_isalpha(i) ? (ap_tolower(i)) - 'a' : (MIME_HASHSIZE-1))
 
 static table *hash_buckets[MIME_HASHSIZE];
 
 static void init_mime(server_rec *s, pool *p)
 {
     configfile_t *f;
@@ -242,13 +242,15 @@
 
 static int find_ct(request_rec *r)
 {
     const char *fn = strrchr(r->filename, '/');
     mime_dir_config *conf =
     (mime_dir_config *) ap_get_module_config(r->per_dir_config, &mime_module);
-    char *ext, *type, *orighandler = r->handler;
+    char *ext;
+    const char *orighandler = r->handler;
+    const char *type;
 
     if (S_ISDIR(r->finfo.st_mode)) {
         r->content_type = DIR_MAGIC_TYPE;
         return OK;
     }
 
@@ -270,18 +272,18 @@
             r->content_type = type;
             found = 1;
         }
 
         /* Check for Content-Language */
         if ((type = ap_table_get(conf->language_types, ext))) {
-            char **new;
+            const char **new;
 
             r->content_language = type;         /* back compat. only */
             if (!r->content_languages)
                 r->content_languages = ap_make_array(r->pool, 2, sizeof(char *));
-            new = (char **) ap_push_array(r->content_languages);
+            new = (const char **) ap_push_array(r->content_languages);
             *new = type;
             found = 1;
         }
 
         /* Check for Content-Encoding */
         if ((type = ap_table_get(conf->encoding_types, ext))) {
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_mime_magic.c apache_1.3.1/src/modules/standard/mod_mime_magic.c
--- apache_1.3.0/src/modules/standard/mod_mime_magic.c	1998-05-29 06:09:57.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_mime_magic.c	1998-07-09 01:47:17.000000000 +0800
@@ -718,13 +718,13 @@
     encoding_frag = encoding_pos = encoding_len = 0;
     for (frag = req_dat->head, cur_frag = 0;
 	 frag && frag->next;
 	 frag = frag->next, cur_frag++) {
 	/* loop through the characters in the fragment */
 	for (cur_pos = 0; frag->str[cur_pos]; cur_pos++) {
-	    if (isspace(frag->str[cur_pos])) {
+	    if (ap_isspace(frag->str[cur_pos])) {
 		/* process whitespace actions for each state */
 		if (state == rsl_leading_space) {
 		    /* eat whitespace in this state */
 		    continue;
 		}
 		else if (state == rsl_type) {
@@ -810,23 +810,27 @@
 	return DECLINED;
     }
 
     /* save the info in the request record */
     if (state == rsl_subtype || state == rsl_encoding ||
 	state == rsl_encoding) {
-	r->content_type = rsl_strdup(r, type_frag, type_pos, type_len);
+        char *tmp;
+	tmp = rsl_strdup(r, type_frag, type_pos, type_len);
 	/* XXX: this could be done at config time I'm sure... but I'm
 	 * confused by all this magic_rsl stuff. -djg */
-	ap_str_tolower(r->content_type);
+	ap_content_type_tolower(tmp);
+	r->content_type = tmp;
     }
     if (state == rsl_encoding) {
-	r->content_encoding = rsl_strdup(r, encoding_frag,
+        char *tmp;
+	tmp = rsl_strdup(r, encoding_frag,
 					 encoding_pos, encoding_len);
 	/* XXX: this could be done at config time I'm sure... but I'm
 	 * confused by all this magic_rsl stuff. -djg */
-	ap_str_tolower(r->content_encoding);
+	ap_str_tolower(tmp);
+	r->content_encoding = tmp;
     }
 
     /* detect memory allocation errors */
     if (!r->content_type ||
 	(state == rsl_encoding && !r->content_encoding)) {
 	return HTTP_INTERNAL_SERVER_ERROR;
@@ -916,14 +920,13 @@
     /*
      * abandon hope, all ye who remain here
      */
     magic_rsl_puts(r, MIME_BINARY_UNKNOWN);
 }
 
-#define    EATAB {while (isascii((unsigned char) *l) && \
-              isspace((unsigned char) *l))  ++l;}
+#define    EATAB {while (ap_isspace((unsigned char) *l))  ++l;}
 
 /*
  * apprentice - load configuration from the magic file r
  *  API request record
  */
 static int apprentice(server_rec *s, pool *p)
@@ -960,13 +963,13 @@
 	if (line[0]) {
 	    line[strlen(line) - 1] = '\0';
 	}
 
 	/* skip leading whitespace */
 	ws_offset = 0;
-	while (line[ws_offset] && isspace(line[ws_offset])) {
+	while (line[ws_offset] && ap_isspace(line[ws_offset])) {
 	    ws_offset++;
 	}
 
 	/* skip blank lines */
 	if (line[ws_offset] == 0) {
 	    continue;
@@ -1003,16 +1006,16 @@
 
 #if MIME_MAGIC_DEBUG
     prevm = 0;
     ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, s,
 		MODNAME ": apprentice test");
     for (m = conf->magic; m; m = m->next) {
-	if (isprint((((unsigned long) m) >> 24) & 255) &&
-	    isprint((((unsigned long) m) >> 16) & 255) &&
-	    isprint((((unsigned long) m) >> 8) & 255) &&
-	    isprint(((unsigned long) m) & 255)) {
+	if (ap_isprint((((unsigned long) m) >> 24) & 255) &&
+	    ap_isprint((((unsigned long) m) >> 16) & 255) &&
+	    ap_isprint((((unsigned long) m) >> 8) & 255) &&
+	    ap_isprint(((unsigned long) m) & 255)) {
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, s,
 			MODNAME ": apprentice: POINTER CLOBBERED! "
 			"m=\"%c%c%c%c\" line=%d",
 			(((unsigned long) m) >> 24) & 255,
 			(((unsigned long) m) >> 16) & 255,
 			(((unsigned long) m) >> 8) & 255,
@@ -1134,13 +1137,13 @@
 	    }
 	    l++;
 	}
 	s = l;
 	if (*l == '+' || *l == '-')
 	    l++;
-	if (isdigit((unsigned char) *l)) {
+	if (ap_isdigit((unsigned char) *l)) {
 	    m->in.offset = strtol(l, &t, 0);
 	    if (*s == '-')
 		m->in.offset = -m->in.offset;
 	}
 	else
 	    t = l;
@@ -1149,13 +1152,13 @@
 			MODNAME ": missing ')' in indirect offset");
 	}
 	l = t;
     }
 
 
-    while (isascii((unsigned char) *l) && isdigit((unsigned char) *l))
+    while (ap_isdigit((unsigned char) *l))
 	++l;
     EATAB;
 
 #define NBYTE           4
 #define NSHORT          5
 #define NLONG           4
@@ -1247,14 +1250,13 @@
 	    m->reln = *l;
 	    ++l;
 	    break;
 	}
 	/* FALL THROUGH */
     default:
-	if (*l == 'x' && isascii((unsigned char) l[1]) &&
-	    isspace((unsigned char) l[1])) {
+	if (*l == 'x' && ap_isspace((unsigned char) l[1])) {
 	    m->reln = *l;
 	    ++l;
 	    goto GetDesc;	/* Bill The Cat */
 	}
 	m->reln = '=';
 	break;
@@ -1320,13 +1322,13 @@
     char *origs = s, *origp = p;
     char *pmax = p + plen - 1;
     register int c;
     register int val;
 
     while ((c = *s++) != '\0') {
-	if (isspace((unsigned char) c))
+	if (ap_isspace((unsigned char) c))
 	    break;
 	if (p >= pmax) {
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_ERR, serv,
 			MODNAME ": string too long: %s", origs);
 	    break;
 	}
@@ -1423,15 +1425,13 @@
 }
 
 
 /* Single hex char to int; -1 if not a hex char. */
 static int hextoint(int c)
 {
-    if (!isascii((unsigned char) c))
-	return -1;
-    if (isdigit((unsigned char) c))
+    if (ap_isdigit((unsigned char) c))
 	return c - '0';
     if ((c >= 'a') && (c <= 'f'))
 	return c + 10 - 'a';
     if ((c >= 'A') && (c <= 'F'))
 	return c + 10 - 'A';
     return -1;
@@ -1568,16 +1568,16 @@
 		(conf->magic && conf->magic->next) ? "set" : "NULL",
 		conf->last ? "set" : "NULL");
 #endif
 
 #if MIME_MAGIC_DEBUG
     for (m = conf->magic; m; m = m->next) {
-	if (isprint((((unsigned long) m) >> 24) & 255) &&
-	    isprint((((unsigned long) m) >> 16) & 255) &&
-	    isprint((((unsigned long) m) >> 8) & 255) &&
-	    isprint(((unsigned long) m) & 255)) {
+	if (ap_isprint((((unsigned long) m) >> 24) & 255) &&
+	    ap_isprint((((unsigned long) m) >> 16) & 255) &&
+	    ap_isprint((((unsigned long) m) >> 8) & 255) &&
+	    ap_isprint(((unsigned long) m) & 255)) {
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, r->server,
 			MODNAME ": match: POINTER CLOBBERED! "
 			"m=\"%c%c%c%c\"",
 			(((unsigned long) m) >> 24) & 255,
 			(((unsigned long) m) >> 16) & 255,
 			(((unsigned long) m) >> 8) & 255,
@@ -1989,13 +1989,13 @@
 
 /* an optimization over plain strcmp() */
 #define    STREQ(a, b)    (*(a) == *(b) && strcmp((a), (b)) == 0)
 
 static int ascmagic(request_rec *r, unsigned char *buf, int nbytes)
 {
-    int i, has_escapes = 0;
+    int has_escapes = 0;
     unsigned char *s;
     char nbuf[HOWMANY + 1];	/* one extra for terminating '\0' */
     char *token;
     register struct names *p;
     int small_nbytes;
 
@@ -2006,22 +2006,21 @@
      * disambiguate tar archives' ./file and other trash from real troff
      * input.
      */
     if (*buf == '.') {
 	unsigned char *tp = buf + 1;
 
-	while (isascii(*tp) && isspace(*tp))
+	while (ap_isspace(*tp))
 	    ++tp;		/* skip leading whitespace */
-	if ((isascii(*tp) && (isalnum(*tp) || *tp == '\\') &&
-	     isascii(*(tp + 1)) && (isalnum(*(tp + 1)) || *tp == '"'))) {
+	if ((ap_isalnum(*tp) || *tp == '\\') &&
+	     (ap_isalnum(*(tp + 1)) || *tp == '"')) {
 	    magic_rsl_puts(r, "application/x-troff");
 	    return 1;
 	}
     }
-    if ((*buf == 'c' || *buf == 'C') &&
-	isascii(*(buf + 1)) && isspace(*(buf + 1))) {
+    if ((*buf == 'c' || *buf == 'C') && ap_isspace(*(buf + 1))) {
 	/* Fortran */
 	magic_rsl_puts(r, "text/plain");
 	return 1;
     }
 
     /* look for tokens from names.h - this is expensive!, so we'll limit
@@ -2052,17 +2051,12 @@
     case 2:
 	/* POSIX tar archive */
 	magic_rsl_puts(r, "application/x-tar");
 	return 1;
     }
 
-    for (i = 0; i < nbytes; i++) {
-	if (!isascii(*(buf + i)))
-	    return 0;		/* not all ascii */
-    }
-
     /* all else fails, but it is ascii... */
     if (has_escapes) {
 	/* text with escape sequences */
 	/* we leave this open for further differentiation later */
 	magic_rsl_puts(r, "text/plain");
     }
@@ -2270,24 +2264,24 @@
  * Result is -1 if the field is invalid (all blank, or nonoctal).
  */
 static long from_oct(int digs, char *where)
 {
     register long value;
 
-    while (isspace(*where)) {	/* Skip spaces */
+    while (ap_isspace(*where)) {	/* Skip spaces */
 	where++;
 	if (--digs <= 0)
 	    return -1;		/* All blank field */
     }
     value = 0;
     while (digs > 0 && isodigit(*where)) {	/* Scan til nonoctal */
 	value = (value << 3) | (*where++ - '0');
 	--digs;
     }
 
-    if (digs > 0 && *where && !isspace(*where))
+    if (digs > 0 && *where && !ap_isspace(*where))
 	return -1;		/* Ended on non-space/nul */
 
     return value;
 }
 
 /*
@@ -2310,16 +2304,16 @@
     ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, r->server,
 		MODNAME ": revision_suffix checking %s", r->filename);
 #endif /* MIME_MAGIC_DEBUG */
 
     /* check for recognized revision suffix */
     suffix_pos = strlen(r->filename) - 1;
-    if (!isdigit(r->filename[suffix_pos])) {
+    if (!ap_isdigit(r->filename[suffix_pos])) {
 	return 0;
     }
-    while (suffix_pos >= 0 && isdigit(r->filename[suffix_pos]))
+    while (suffix_pos >= 0 && ap_isdigit(r->filename[suffix_pos]))
 	suffix_pos--;
     if (suffix_pos < 0 || r->filename[suffix_pos] != '@') {
 	return 0;
     }
 
     /* perform sub-request for the file name without the suffix */
@@ -2381,16 +2375,16 @@
 		return;
 #if MIME_MAGIC_DEBUG
 	    prevm = 0;
 	    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, s,
 			MODNAME ": magic_init 1 test");
 	    for (m = conf->magic; m; m = m->next) {
-		if (isprint((((unsigned long) m) >> 24) & 255) &&
-		    isprint((((unsigned long) m) >> 16) & 255) &&
-		    isprint((((unsigned long) m) >> 8) & 255) &&
-		    isprint(((unsigned long) m) & 255)) {
+		if (ap_isprint((((unsigned long) m) >> 24) & 255) &&
+		    ap_isprint((((unsigned long) m) >> 16) & 255) &&
+		    ap_isprint((((unsigned long) m) >> 8) & 255) &&
+		    ap_isprint(((unsigned long) m) & 255)) {
 		    ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_DEBUG, s,
 				MODNAME ": magic_init 1: POINTER CLOBBERED! "
 				"m=\"%c%c%c%c\" line=%d",
 				(((unsigned long) m) >> 24) & 255,
 				(((unsigned long) m) >> 16) & 255,
 				(((unsigned long) m) >> 8) & 255,
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_negotiation.c apache_1.3.1/src/modules/standard/mod_negotiation.c
--- apache_1.3.0/src/modules/standard/mod_negotiation.c	1998-05-31 03:15:38.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_negotiation.c	1998-07-09 01:47:18.000000000 +0800
@@ -177,13 +177,13 @@
  */
 
 typedef struct var_rec {
     request_rec *sub_req;       /* May be NULL (is, for map files) */
     char *type_name;		/* MUST be lowercase */
     char *file_name;
-    char *content_encoding;
+    const char *content_encoding;
     array_header *content_languages;    /* list of languages for this variant */
     char *content_charset;
     char *description;
 
     /* The next five items give the quality values for the dimensions
      * of negotiation for this variant. They are obtained from the
@@ -294,13 +294,13 @@
 
 /*
  * Get a single mime type entry --- one media type and parameters;
  * enter the values we recognize into the argument accept_rec
  */
 
-static char *get_entry(pool *p, accept_rec *result, char *accept_line)
+static const char *get_entry(pool *p, accept_rec *result, const char *accept_line)
 {
     result->quality = 1.0f;
     result->max_bytes = 0.0f;
     result->level = 0.0f;
     result->charset = "";
 
@@ -343,33 +343,33 @@
 
         ++accept_line;
         parm = ap_get_token(p, &accept_line, 1);
 
         /* Look for 'var = value' --- and make sure the var is in lcase. */
 
-        for (cp = parm; (*cp && !isspace(*cp) && *cp != '='); ++cp) {
-            *cp = tolower(*cp);
+        for (cp = parm; (*cp && !ap_isspace(*cp) && *cp != '='); ++cp) {
+            *cp = ap_tolower(*cp);
         }
 
         if (!*cp) {
             continue;           /* No '='; just ignore it. */
         }
 
         *cp++ = '\0';           /* Delimit var */
-        while (*cp && (isspace(*cp) || *cp == '=')) {
+        while (*cp && (ap_isspace(*cp) || *cp == '=')) {
             ++cp;
         }
 
         if (*cp == '"') {
             ++cp;
             for (end = cp;
                  (*end && *end != '\n' && *end != '\r' && *end != '\"');
                  end++);
         }
         else {
-            for (end = cp; (*end && !isspace(*end)); end++);
+            for (end = cp; (*end && !ap_isspace(*end)); end++);
         }
         if (*end) {
             *end = '\0';        /* strip ending quote or return */
         }
         ap_str_tolower(cp);
 
@@ -406,13 +406,13 @@
  *    name; q=N; charset=TEXT
  *
  * where q is only valid in Accept, Accept-Charset and Accept-Languages,
  * and charset is only valid in Accept.
  */
 
-static array_header *do_header_line(pool *p, char *accept_line)
+static array_header *do_header_line(pool *p, const char *accept_line)
 {
     array_header *accept_recs = ap_make_array(p, 40, sizeof(accept_rec));
 
     if (!accept_line) {
         return accept_recs;
     }
@@ -426,13 +426,13 @@
 }
 
 /* Given the text of the Content-Languages: line from the var map file,
  * return an array containing the languages of this variant
  */
 
-static array_header *do_languages_line(pool *p, char **lang_line)
+static array_header *do_languages_line(pool *p, const char **lang_line)
 {
     array_header *lang_recs = ap_make_array(p, 2, sizeof(char *));
 
     if (!lang_line) {
         return lang_recs;
     }
@@ -458,13 +458,13 @@
 {
     negotiation_state *new = (negotiation_state *) ap_pcalloc(r->pool,
                                                  sizeof(negotiation_state));
     accept_rec *elts;
     table *hdrs = r->headers_in;
     int i;
-    char *hdr;
+    const char *hdr;
 
     new->pool = r->pool;
     new->r = r;
     new->dir_name = ap_make_dirstr_parent(r->pool, r->filename);
 
     new->accepts = do_header_line(r->pool, ap_table_get(hdrs, "Accept"));
@@ -580,13 +580,13 @@
             return header_eof;
         }
     } while (buffer[0] == '#');
 
     /* If blank, just return it --- this ends information on this variant */
 
-    for (cp = buffer; (*cp && isspace(*cp)); ++cp) {
+    for (cp = buffer; (*cp && ap_isspace(*cp)); ++cp) {
         continue;
     }
 
     if (*cp == '\0') {
         return header_sep;
     }
@@ -601,19 +601,19 @@
         if (c == '#') {
             /* Comment line */
             while ((c = getc(map)) != EOF && c != '\n') {
                 continue;
             }
         }
-        else if (isspace(c)) {
+        else if (ap_isspace(c)) {
             /* Leading whitespace.  POSSIBLE continuation line
              * Also, possibly blank --- if so, we ungetc() the final newline
              * so that we will pick up the blank line the next time 'round.
              */
 
-            while (c != EOF && c != '\n' && isspace(c)) {
+            while (c != EOF && c != '\n' && ap_isspace(c)) {
                 c = getc(map);
             }
 
             ungetc(c, map);
 
             if (c == '\n') {
@@ -674,24 +674,24 @@
 
 static char *lcase_header_name_return_body(char *header, request_rec *r)
 {
     char *cp = header;
 
     for ( ; *cp && *cp != ':' ; ++cp) {
-        *cp = tolower(*cp);
+        *cp = ap_tolower(*cp);
     }
 
     if (!*cp) {
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
                     "Syntax error in type map --- no ':': %s", r->filename);
         return NULL;
     }
 
     do {
         ++cp;
-    } while (*cp && isspace(*cp));
+    } while (*cp && ap_isspace(*cp));
 
     if (!*cp) {
         ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r->server,
                     "Syntax error in type map --- no header body: %s",
                     r->filename);
         return NULL;
@@ -721,19 +721,21 @@
     clean_var_rec(&mime_info);
 
     do {
         hstate = get_header_line(buffer, MAX_STRING_LEN, map);
 
         if (hstate == header_seen) {
-            char *body = lcase_header_name_return_body(buffer, neg->r);
+            char *body1 = lcase_header_name_return_body(buffer, neg->r);
+	    const char *body;
 
-            if (body == NULL) {
+            if (body1 == NULL) {
                 return SERVER_ERROR;
             }
 
-            strip_paren_comments(body);
+            strip_paren_comments(body1);
+	    body=body1;
 
             if (!strncmp(buffer, "uri:", 4)) {
                 mime_info.file_name = ap_get_token(neg->pool, &body, 0);
             }
             else if (!strncmp(buffer, "content-type:", 13)) {
                 struct accept_rec accept_info;
@@ -1443,23 +1445,23 @@
  */
 
 /* is_identity_encoding is included for back-compat, but does anyone
  * use 7bit, 8bin or binary in their var files??
  */
 
-static int is_identity_encoding(char *enc)
+static int is_identity_encoding(const char *enc)
 {
     return (!enc || !enc[0] || !strcmp(enc, "7bit") || !strcmp(enc, "8bit")
             || !strcmp(enc, "binary"));
 }
 
 static void set_encoding_quality(negotiation_state *neg, var_rec *variant)
 {
     int i;
     accept_rec *accept_recs = (accept_rec *) neg->accept_encodings->elts;
-    char *enc = variant->content_encoding;
+    const char *enc = variant->content_encoding;
 
     if (!enc || is_identity_encoding(enc)) {
         return;
     }
 
     /* if no Accept: header, leave quality alone (will
@@ -1802,13 +1804,13 @@
                             int na_result)
 {
     int j;
     var_rec *avail_recs = (var_rec *) neg->avail_vars->elts;
     char *sample_type = NULL;
     char *sample_language = NULL;
-    char *sample_encoding = NULL;
+    const char *sample_encoding = NULL;
     char *sample_charset = NULL;
     int vary_by_type = 0;
     int vary_by_language = 0;
     int vary_by_charset = 0;
     int vary_by_encoding = 0;
     table *hdrs;
@@ -1970,13 +1972,13 @@
  * Otherwise, add the appropriate headers to the current response.
  */
 
 static int setup_choice_response(request_rec *r, negotiation_state *neg, var_rec *variant)
 {
     request_rec *sub_req;
-    char *sub_vary;
+    const char *sub_vary;
 
     if (!variant->sub_req) {
         int status;
 
         sub_req = ap_sub_req_lookup_file(variant->file_name, r);
         status = sub_req->status;
@@ -2229,13 +2231,13 @@
  * compatible with the final content encoding, then the token in the
  * C-E header will be whatever was specified in the AddEncoding
  * directive.
  */
 static int fix_encoding(request_rec *r)
 {
-    char *enc = r->content_encoding;
+    const char *enc = r->content_encoding;
     char *x_enc = NULL;
     array_header *accept_encodings;
     accept_rec *accept_recs;
     int i;
 
     if (!enc || !*enc) {
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_rewrite.c apache_1.3.1/src/modules/standard/mod_rewrite.c
--- apache_1.3.0/src/modules/standard/mod_rewrite.c	1998-05-29 17:19:41.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_rewrite.c	1998-07-18 23:30:46.000000000 +0800
@@ -262,22 +262,27 @@
 
     if (a->options & OPTION_INHERIT) {
         /*
          *  local directives override
          *  and anything else is inherited
          */
-        a->rewriteloglevel = overrides->rewriteloglevel != 0 ?
-                             overrides->rewriteloglevel : base->rewriteloglevel;
-        a->rewritelogfile  = overrides->rewritelogfile != NULL ?
-                             overrides->rewritelogfile : base->rewritelogfile;
-        a->rewritelogfp    = overrides->rewritelogfp != -1 ?
-                             overrides->rewritelogfp : base->rewritelogfp;
-        a->rewritelockfile = overrides->rewritelockfile != NULL ?
-                             overrides->rewritelockfile : base->rewritelockfile;
-        a->rewritelockfp   = overrides->rewritelockfp != -1 ?
-                             overrides->rewritelockfp : base->rewritelockfp;
+        a->rewriteloglevel = overrides->rewriteloglevel != 0 
+                             ? overrides->rewriteloglevel
+                             : base->rewriteloglevel;
+        a->rewritelogfile  = overrides->rewritelogfile != NULL 
+                             ? overrides->rewritelogfile
+                             : base->rewritelogfile;
+        a->rewritelogfp    = overrides->rewritelogfp != -1 
+                             ? overrides->rewritelogfp 
+                             : base->rewritelogfp;
+        a->rewritelockfile = overrides->rewritelockfile != NULL
+                             ? overrides->rewritelockfile
+                             : base->rewritelockfile;
+        a->rewritelockfp   = overrides->rewritelockfp != -1
+                             ? overrides->rewritelockfp
+                             : base->rewritelockfp;
         a->rewritemaps     = ap_append_arrays(p, overrides->rewritemaps,
                                               base->rewritemaps);
         a->rewriteconds    = ap_append_arrays(p, overrides->rewriteconds,
                                               base->rewriteconds);
         a->rewriterules    = ap_append_arrays(p, overrides->rewriterules,
                                               base->rewriterules);
@@ -316,30 +321,34 @@
     a->state           = ENGINE_DISABLED;
     a->options         = OPTION_NONE;
     a->baseurl         = NULL;
     a->rewriteconds    = ap_make_array(p, 2, sizeof(rewritecond_entry));
     a->rewriterules    = ap_make_array(p, 2, sizeof(rewriterule_entry));
 
-    if (path == NULL)
+    if (path == NULL) {
         a->directory = NULL;
+    }
     else {
         /* make sure it has a trailing slash */
-        if (path[strlen(path)-1] == '/')
+        if (path[strlen(path)-1] == '/') {
             a->directory = ap_pstrdup(p, path);
-        else
+        }
+        else {
             a->directory = ap_pstrcat(p, path, "/", NULL);
+        }
     }
 
     return (void *)a;
 }
 
 static void *config_perdir_merge(pool *p, void *basev, void *overridesv)
 {
     rewrite_perdir_conf *a, *base, *overrides;
 
-    a         = (rewrite_perdir_conf *)ap_pcalloc(p, sizeof(rewrite_perdir_conf));
+    a         = (rewrite_perdir_conf *)ap_pcalloc(p,
+                                                  sizeof(rewrite_perdir_conf));
     base      = (rewrite_perdir_conf *)basev;
     overrides = (rewrite_perdir_conf *)overridesv;
 
     a->state     = overrides->state;
     a->options   = overrides->options;
     a->directory = overrides->directory;
@@ -368,19 +377,22 @@
 
 static const char *cmd_rewriteengine(cmd_parms *cmd,
                                      rewrite_perdir_conf *dconf, int flag)
 {
     rewrite_server_conf *sconf;
 
-    sconf = (rewrite_server_conf *)
-            ap_get_module_config(cmd->server->module_config, &rewrite_module);
+    sconf = 
+        (rewrite_server_conf *)ap_get_module_config(cmd->server->module_config,
+                                                    &rewrite_module);
 
-    if (cmd->path == NULL) /* is server command */
+    if (cmd->path == NULL) { /* is server command */
         sconf->state = (flag ? ENGINE_ENABLED : ENGINE_DISABLED);
-    else                   /* is per-directory command */
+    }
+    else                   /* is per-directory command */ {
         dconf->state = (flag ? ENGINE_ENABLED : ENGINE_DISABLED);
+    }
 
     return NULL;
 }
 
 static const char *cmd_rewriteoptions(cmd_parms *cmd,
                                       rewrite_perdir_conf *dconf, char *option)
@@ -388,30 +400,34 @@
     rewrite_server_conf *sconf;
     const char *err;
 
     sconf = (rewrite_server_conf *)
             ap_get_module_config(cmd->server->module_config, &rewrite_module);
 
-    if (cmd->path == NULL) /* is server command */
+    if (cmd->path == NULL) { /* is server command */
         err = cmd_rewriteoptions_setoption(cmd->pool,
                                            &(sconf->options), option);
-    else                   /* is per-directory command */
+    }
+    else {                 /* is per-directory command */
         err = cmd_rewriteoptions_setoption(cmd->pool,
                                            &(dconf->options), option);
+    }
 
     return err;
 }
 
 static const char *cmd_rewriteoptions_setoption(pool *p, int *options,
                                                 char *name)
 {
-    if (strcasecmp(name, "inherit") == 0)
+    if (strcasecmp(name, "inherit") == 0) {
         *options |= OPTION_INHERIT;
-    else
+    }
+    else {
         return ap_pstrcat(p, "RewriteOptions: unknown option '",
-                       name, "'\n", NULL);
+                          name, "'\n", NULL);
+    }
     return NULL;
 }
 
 static const char *cmd_rewritelog(cmd_parms *cmd, void *dconf, char *a1)
 {
     rewrite_server_conf *sconf;
@@ -476,32 +492,37 @@
         new->checkfile = a2+4;
     }
     else if (strncmp(a2, "int:", 4) == 0) {
         new->type      = MAPTYPE_INT;
         new->datafile  = NULL;
         new->checkfile = NULL;
-        if (strcmp(a2+4, "tolower") == 0)
+        if (strcmp(a2+4, "tolower") == 0) {
             new->func = rewrite_mapfunc_tolower;
-        else if (strcmp(a2+4, "toupper") == 0)
+        }
+        else if (strcmp(a2+4, "toupper") == 0) {
             new->func = rewrite_mapfunc_toupper;
-        else if (sconf->state == ENGINE_ENABLED)
+        }
+        else if (sconf->state == ENGINE_ENABLED) {
             return ap_pstrcat(cmd->pool, "RewriteMap: internal map not found:",
                               a2+4, NULL);
+        }
     }
     else {
         new->type      = MAPTYPE_TXT;
         new->datafile  = a2;
         new->checkfile = a2;
     }
     new->fpin  = -1;
     new->fpout = -1;
 
     if (new->checkfile && (sconf->state == ENGINE_ENABLED)
-                       && (stat(new->checkfile, &st) == -1))
-        return ap_pstrcat(cmd->pool, "RewriteMap: map file or program not found:",
+        && (stat(new->checkfile, &st) == -1)) {
+        return ap_pstrcat(cmd->pool,
+                          "RewriteMap: map file or program not found:",
                           new->checkfile, NULL);
+    }
 
     return NULL;
 }
 
 static const char *cmd_rewritelock(cmd_parms *cmd, void *dconf, char *a1)
 {
@@ -515,18 +536,21 @@
     return NULL;
 }
 
 static const char *cmd_rewritebase(cmd_parms *cmd, rewrite_perdir_conf *dconf,
                                    char *a1)
 {
-    if (cmd->path == NULL || dconf == NULL)
+    if (cmd->path == NULL || dconf == NULL) {
         return "RewriteBase: only valid in per-directory config files";
-    if (a1[0] == '\0')
+    }
+    if (a1[0] == '\0') {
         return "RewriteBase: empty URL not allowed";
-    if (a1[0] != '/')
+    }
+    if (a1[0] != '/') {
         return "RewriteBase: argument is not a valid URL";
+    }
 
     dconf->baseurl = a1;
 
     return NULL;
 }
 
@@ -544,32 +568,37 @@
     int rc;
 
     sconf = (rewrite_server_conf *)
             ap_get_module_config(cmd->server->module_config, &rewrite_module);
 
     /*  make a new entry in the internal temporary rewrite rule list */
-    if (cmd->path == NULL)   /* is server command */
+    if (cmd->path == NULL) {   /* is server command */
         new = ap_push_array(sconf->rewriteconds);
-    else                     /* is per-directory command */
+    }
+    else {                     /* is per-directory command */
         new = ap_push_array(dconf->rewriteconds);
+    }
 
     /*  parse the argument line ourself */
-    if (parseargline(str, &a1, &a2, &a3))
+    if (parseargline(str, &a1, &a2, &a3)) {
         return ap_pstrcat(cmd->pool, "RewriteCond: bad argument line '", str,
                           "'\n", NULL);
+    }
 
     /*  arg1: the input string */
     new->input = ap_pstrdup(cmd->pool, a1);
 
     /* arg3: optional flags field
        (this have to be first parsed, because we need to
         know if the regex should be compiled with ICASE!) */
     new->flags = CONDFLAG_NONE;
     if (a3 != NULL) {
-        if ((err = cmd_rewritecond_parseflagfield(cmd->pool, new, a3)) != NULL)
+        if ((err = cmd_rewritecond_parseflagfield(cmd->pool, new,
+                                                  a3)) != NULL) {
             return err;
+        }
     }
 
     /*  arg2: the pattern
         try to compile the regexp to test if is ok */
     cp = a2;
     if (cp[0] == '!') {
@@ -577,21 +606,24 @@
         cp++;
     }
 
     /* now be careful: Under the POSIX regex library
        we can compile the pattern for case-insensitive matching,
        under the old V8 library we have to do it self via a hack */
-    if (new->flags & CONDFLAG_NOCASE)
+    if (new->flags & CONDFLAG_NOCASE) {
         rc = ((regexp = ap_pregcomp(cmd->pool, cp, REG_EXTENDED|REG_ICASE))
               == NULL);
-    else
+    }
+    else {
         rc = ((regexp = ap_pregcomp(cmd->pool, cp, REG_EXTENDED)) == NULL);
-    if (rc)
+    }
+    if (rc) {
         return ap_pstrcat(cmd->pool,
                           "RewriteCond: cannot compile regular expression '",
-              a2, "'\n", NULL);
+                          a2, "'\n", NULL);
+    }
 
     new->pattern = ap_pstrdup(cmd->pool, cp);
     new->regexp  = regexp;
 
     return NULL;
 }
@@ -605,23 +637,25 @@
     char *cp2;
     char *cp3;
     char *key;
     char *val;
     const char *err;
 
-    if (str[0] != '[' || str[strlen(str)-1] != ']')
+    if (str[0] != '[' || str[strlen(str)-1] != ']') {
         return "RewriteCond: bad flag delimiters";
+    }
 
     cp = str+1;
     str[strlen(str)-1] = ','; /* for simpler parsing */
     for ( ; *cp != '\0'; ) {
         /* skip whitespaces */
         for ( ; (*cp == ' ' || *cp == '\t') && *cp != '\0'; cp++)
             ;
-        if (*cp == '\0')
+        if (*cp == '\0') {
             break;
+        }
         cp1 = cp;
         if ((cp2 = strchr(cp, ',')) != NULL) {
             cp = cp2+1;
             for ( ; (*(cp2-1) == ' ' || *(cp2-1) == '\t'); cp2--)
                 ;
             *cp2 = '\0';
@@ -631,17 +665,19 @@
                 val = cp3+1;
             }
             else {
                 key = cp1;
                 val = "";
             }
-            if ((err = cmd_rewritecond_setflag(p, cfg, key, val)) != NULL)
+            if ((err = cmd_rewritecond_setflag(p, cfg, key, val)) != NULL) {
                 return err;
+            }
         }
-        else
+        else {
             break;
+        }
     }
 
     return NULL;
 }
 
 static const char *cmd_rewritecond_setflag(pool *p, rewritecond_entry *cfg,
@@ -674,35 +710,39 @@
     const char *err;
 
     sconf = (rewrite_server_conf *)
             ap_get_module_config(cmd->server->module_config, &rewrite_module);
 
     /*  make a new entry in the internal rewrite rule list */
-    if (cmd->path == NULL)   /* is server command */
+    if (cmd->path == NULL) {   /* is server command */
         new = ap_push_array(sconf->rewriterules);
-    else                     /* is per-directory command */
+    }
+    else {                     /* is per-directory command */
         new = ap_push_array(dconf->rewriterules);
+    }
 
     /*  parse the argument line ourself */
-    if (parseargline(str, &a1, &a2, &a3))
+    if (parseargline(str, &a1, &a2, &a3)) {
         return ap_pstrcat(cmd->pool, "RewriteRule: bad argument line '", str,
                           "'\n", NULL);
+    }
 
     /*  arg1: the pattern
      *  try to compile the regexp to test if is ok
      */
     new->flags = RULEFLAG_NONE;
     cp = a1;
     if (cp[0] == '!') {
         new->flags |= RULEFLAG_NOTMATCH;
         cp++;
     }
-    if ((regexp = ap_pregcomp(cmd->pool, cp, REG_EXTENDED)) == NULL)
+    if ((regexp = ap_pregcomp(cmd->pool, cp, REG_EXTENDED)) == NULL) {
         return ap_pstrcat(cmd->pool,
                           "RewriteRule: cannot compile regular expression '",
-              a1, "'\n", NULL);
+                          a1, "'\n", NULL);
+    }
     new->pattern = ap_pstrdup(cmd->pool, cp);
     new->regexp  = regexp;
 
     /*  arg2: the output string
      *  replace the $<N> by \<n> which is needed by the currently
      *  used Regular Expression library
@@ -712,14 +752,16 @@
     /* arg3: optional flags field */
     new->forced_mimetype = NULL;
     new->forced_responsecode = HTTP_MOVED_TEMPORARILY;
     new->env[0] = NULL;
     new->skip = 0;
     if (a3 != NULL) {
-        if ((err = cmd_rewriterule_parseflagfield(cmd->pool, new, a3)) != NULL)
+        if ((err = cmd_rewriterule_parseflagfield(cmd->pool, new,
+                                                  a3)) != NULL) {
             return err;
+        }
     }
 
     /* now, if the server or per-dir config holds an
      * array of RewriteCond entries, we take it for us
      * and clear the array
      */
@@ -746,23 +788,25 @@
     char *cp2;
     char *cp3;
     char *key;
     char *val;
     const char *err;
 
-    if (str[0] != '[' || str[strlen(str)-1] != ']')
+    if (str[0] != '[' || str[strlen(str)-1] != ']') {
         return "RewriteRule: bad flag delimiters";
+    }
 
     cp = str+1;
     str[strlen(str)-1] = ','; /* for simpler parsing */
     for ( ; *cp != '\0'; ) {
         /* skip whitespaces */
         for ( ; (*cp == ' ' || *cp == '\t') && *cp != '\0'; cp++)
             ;
-        if (*cp == '\0')
+        if (*cp == '\0') {
             break;
+        }
         cp1 = cp;
         if ((cp2 = strchr(cp, ',')) != NULL) {
             cp = cp2+1;
             for ( ; (*(cp2-1) == ' ' || *(cp2-1) == '\t'); cp2--)
                 ;
             *cp2 = '\0';
@@ -772,17 +816,19 @@
                 val = cp3+1;
             }
             else {
                 key = cp1;
                 val = "";
             }
-            if ((err = cmd_rewriterule_setflag(p, cfg, key, val)) != NULL)
+            if ((err = cmd_rewriterule_setflag(p, cfg, key, val)) != NULL) {
                 return err;
+            }
         }
-        else
+        else {
             break;
+        }
     }
 
     return NULL;
 }
 
 static const char *cmd_rewriterule_setflag(pool *p, rewriterule_entry *cfg,
@@ -792,23 +838,28 @@
     int i;
 
     if (   strcasecmp(key, "redirect") == 0
         || strcasecmp(key, "R") == 0       ) {
         cfg->flags |= RULEFLAG_FORCEREDIRECT;
         if (strlen(val) > 0) {
-            if (strcasecmp(val, "permanent") == 0)
+            if (strcasecmp(val, "permanent") == 0) {
                 status = HTTP_MOVED_PERMANENTLY;
-            else if (strcasecmp(val, "temp") == 0)
+            }
+            else if (strcasecmp(val, "temp") == 0) {
                 status = HTTP_MOVED_TEMPORARILY;
-            else if (strcasecmp(val, "seeother") == 0)
+            }
+            else if (strcasecmp(val, "seeother") == 0) {
                 status = HTTP_SEE_OTHER;
-            else if (isdigit(*val))
+            }
+            else if (ap_isdigit(*val)) {
                 status = atoi(val);
-            if (!is_HTTP_REDIRECT(status))
+            }
+            if (!is_HTTP_REDIRECT(status)) {
                 return "RewriteRule: invalid HTTP response code "
                        "for flag 'R'";
+            }
             cfg->forced_responsecode = status;
         }
     }
     else if (   strcasecmp(key, "last") == 0
              || strcasecmp(key, "L") == 0   ) {
         cfg->flags |= RULEFLAG_LASTRULE;
@@ -831,14 +882,15 @@
         for (i = 0; (cfg->env[i] != NULL) && (i < MAX_ENV_FLAGS); i++)
             ;
         if (i < MAX_ENV_FLAGS) {
             cfg->env[i] = ap_pstrdup(p, val);
             cfg->env[i+1] = NULL;
         }
-        else
-            return "RewriteRule: to many environment flags 'E'";
+        else {
+            return "RewriteRule: too many environment flags 'E'";
+        }
     }
     else if (   strcasecmp(key, "nosubreq") == 0
              || strcasecmp(key, "NS") == 0      ) {
         cfg->flags |= RULEFLAG_IGNOREONSUBREQ;
     }
     else if (   strcasecmp(key, "proxy") == 0
@@ -939,59 +991,66 @@
 */
 
 static int hook_uri2file(request_rec *r)
 {
     void *sconf;
     rewrite_server_conf *conf;
-    char *var;
+    const char *var;
     const char *thisserver;
-    char *thisport, *thisurl;
+    char *thisport;
+    const char *thisurl;
     char buf[512];
     char docroot[512];
     char *cp, *cp2;
+    const char *ccp;
     struct stat finfo;
     unsigned int port;
     int n;
     int l;
 
     /*
      *  retrieve the config structures
      */
     sconf = r->server->module_config;
-    conf  = (rewrite_server_conf *)ap_get_module_config(sconf, &rewrite_module);
+    conf  = (rewrite_server_conf *)ap_get_module_config(sconf,
+                                                        &rewrite_module);
 
     /*
      *  only do something under runtime if the engine is really enabled,
      *  else return immediately!
      */
-    if (conf->state == ENGINE_DISABLED)
+    if (conf->state == ENGINE_DISABLED) {
         return DECLINED;
+    }
 
     /*
      *  check for the ugly API case of a virtual host section where no
      *  mod_rewrite directives exists. In this situation we became no chance
      *  by the API to setup our default per-server config so we have to
      *  on-the-fly assume we have the default config. But because the default
      *  config has a disabled rewriting engine we are lucky because can
      *  just stop operating now.
      */
-    if (conf->server != r->server)
+    if (conf->server != r->server) {
         return DECLINED;
+    }
 
     /*
      *  add the SCRIPT_URL variable to the env. this is a bit complicated
      *  due to the fact that apache uses subrequests and internal redirects
      */
 
     if (r->main == NULL) {
          var = ap_pstrcat(r->pool, "REDIRECT_", ENVVAR_SCRIPT_URL, NULL);
          var = ap_table_get(r->subprocess_env, var);
-         if (var == NULL)
+         if (var == NULL) {
              ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, r->uri);
-         else
+         }
+         else {
              ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, var);
+         }
     }
     else {
          var = ap_table_get(r->main->subprocess_env, ENVVAR_SCRIPT_URL);
          ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, var);
     }
 
@@ -999,14 +1058,15 @@
      *  create the SCRIPT_URI variable for the env
      */
 
     /* add the canonical URI of this URL */
     thisserver = ap_get_server_name(r);
     port = ap_get_server_port(r);
-    if (ap_is_default_port(port, r))
+    if (ap_is_default_port(port, r)) {
         thisport = "";
+    }
     else {
         ap_snprintf(buf, sizeof(buf), ":%u", port);
         thisport = buf;
     }
     thisurl = ap_table_get(r->subprocess_env, ENVVAR_SCRIPT_URL);
 
@@ -1043,17 +1103,22 @@
                 return FORBIDDEN;
             }
 
             /* make sure the QUERY_STRING and
              * PATH_INFO parts get incorporated
              */
-            if (r->path_info != NULL)
-                r->filename = ap_pstrcat(r->pool, r->filename, r->path_info, NULL);
+            if (r->path_info != NULL) {
+                r->filename = ap_pstrcat(r->pool, r->filename,
+                                         r->path_info, NULL);
+            }
             if (r->args != NULL &&
-                r->uri == r->unparsed_uri /* see proxy_http:proxy_http_canon() */)
-                r->filename = ap_pstrcat(r->pool, r->filename, "?", r->args, NULL);
+                r->uri == r->unparsed_uri) {
+                /* see proxy_http:proxy_http_canon() */
+                r->filename = ap_pstrcat(r->pool, r->filename,
+                                         "?", r->args, NULL);
+            }
 
             /* now make sure the request gets handled by the proxy handler */
             r->proxyreq = 1;
             r->handler  = "proxy-server";
 
             rewritelog(r, 1, "go-ahead with proxy request %s [OK]",
@@ -1083,22 +1148,25 @@
                 cp2 = escape_uri(r->pool, cp);
                 *cp = '\0';
                 r->filename = ap_pstrcat(r->pool, r->filename, cp2, NULL);
             }
 
             /* append the QUERY_STRING part */
-            if (r->args != NULL)
-               r->filename = ap_pstrcat(r->pool, r->filename, "?", r->args, NULL);
+            if (r->args != NULL) {
+               r->filename = ap_pstrcat(r->pool, r->filename,
+                                        "?", r->args, NULL);
+            }
 
             /* determine HTTP redirect response code */
             if (is_HTTP_REDIRECT(r->status)) {
                 n = r->status;
                 r->status = HTTP_OK; /* make Apache kernel happy */
             }
-            else
+            else {
                 n = REDIRECT;
+            }
 
             /* now do the redirection */
             ap_table_setn(r->headers_out, "Location", r->filename);
             rewritelog(r, 1, "redirect to %s [REDIRECT/%d]", r->filename, n);
             return n;
         }
@@ -1132,14 +1200,15 @@
 #ifndef WIN32
             r->filename = expand_tildepaths(r, r->filename);
 #endif
             rewritelog(r, 2, "local path result: %s", r->filename);
 
             /* the filename has to start with a slash! */
-            if (r->filename[0] != '/')
+            if (r->filename[0] != '/') {
                 return BAD_REQUEST;
+            }
 
             /* if there is no valid prefix, we have
              * to emulate the translator from the core and
              * prefix the filename with document_root
              *
              * NOTICE:
@@ -1157,28 +1226,30 @@
              * Under real Unix systems this is no problem,
              * because we only do stat() on the first directory
              * and this gets cached by the kernel for along time!
              */
             n = prefix_stat(r->filename, &finfo);
             if (n == 0) {
-                if ((cp = ap_document_root(r)) != NULL) {
-                    l = ap_cpystrn(docroot, cp, sizeof(docroot)) - docroot;
+                if ((ccp = ap_document_root(r)) != NULL) {
+                    l = ap_cpystrn(docroot, ccp, sizeof(docroot)) - docroot;
 
                     /* always NOT have a trailing slash */
                     if (docroot[l-1] == '/') {
                         docroot[l-1] = '\0';
                     }
                     if (r->server->path
                         && !strncmp(r->filename, r->server->path,
-                                    r->server->pathlen))
+                                    r->server->pathlen)) {
                         r->filename = ap_pstrcat(r->pool, docroot,
                                                  (r->filename +
-                          r->server->pathlen), NULL);
-                    else
+                                                  r->server->pathlen), NULL);
+                    }
+                    else {
                         r->filename = ap_pstrcat(r->pool, docroot, 
-                                 r->filename, NULL);
+                                                 r->filename, NULL);
+                    }
                     rewritelog(r, 2, "prefixed with document_root to %s",
                                r->filename);
                 }
             }
 
             rewritelog(r, 1, "go-ahead with %s [OK]", r->filename);
@@ -1199,18 +1270,19 @@
 **  [used to support the forced-MIME-type feature]
 **
 */
 
 static int hook_mimetype(request_rec *r)
 {
-    char *t;
+    const char *t;
 
     /* now check if we have to force a MIME-type */
     t = ap_table_get(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR);
-    if (t == NULL)
+    if (t == NULL) {
         return DECLINED;
+    }
     else {
         rewritelog(r, 1, "force filename %s to have MIME-type '%s'",
                    r->filename, t);
         r->content_type = t;
         return OK;
     }
@@ -1228,32 +1300,36 @@
 
 static int hook_fixup(request_rec *r)
 {
     rewrite_perdir_conf *dconf;
     char *cp;
     char *cp2;
+    const char *ccp;
     char *prefix;
     int l;
     int n;
     char *ofilename;
 
-    dconf = (rewrite_perdir_conf *)
-            ap_get_module_config(r->per_dir_config, &rewrite_module);
+    dconf = (rewrite_perdir_conf *)ap_get_module_config(r->per_dir_config,
+                                                        &rewrite_module);
 
     /* if there is no per-dir config we return immediately */
-    if (dconf == NULL)
+    if (dconf == NULL) {
         return DECLINED;
+    }
 
     /* we shouldn't do anything in subrequests */
-    if (r->main != NULL)
+    if (r->main != NULL) {
         return DECLINED;
+    }
 
     /* if there are no real (i.e. no RewriteRule directives!)
        per-dir config of us, we return also immediately */
-    if (dconf->directory == NULL)
+    if (dconf->directory == NULL) {
         return DECLINED;
+    }
 
     /*
      *  only do something under runtime if the engine is really enabled,
      *  for this directory, else return immediately!
      */
     if (!(ap_allow_options(r) & (OPT_SYM_LINKS | OPT_SYM_OWNER))) {
@@ -1265,14 +1341,15 @@
         return FORBIDDEN;
     }
     else {
         /* FollowSymLinks is given, but the user can
          * still turn off the rewriting engine
          */
-        if (dconf->state == ENGINE_DISABLED)
+        if (dconf->state == ENGINE_DISABLED) {
             return DECLINED;
+        }
     }
 
     /*
      *  remember the current filename before rewriting for later check
      *  to prevent deadlooping because of internal redirects
      *  on final URL/filename which can be equal to the inital one.
@@ -1290,15 +1367,18 @@
 
             /* make sure the QUERY_STRING and
              * PATH_INFO parts get incorporated
              * (r->path_info was already appended by the
              * rewriting engine because of the per-dir context!)
              */
-            if (r->args != NULL &&
-                r->uri == r->unparsed_uri /* see proxy_http:proxy_http_canon() */)
-                r->filename = ap_pstrcat(r->pool, r->filename, "?", r->args, NULL);
+            if (r->args != NULL
+                && r->uri == r->unparsed_uri) {
+                /* see proxy_http:proxy_http_canon() */
+                r->filename = ap_pstrcat(r->pool, r->filename,
+                                         "?", r->args, NULL);
+            }
 
             /* now make sure the request gets handled by the proxy handler */
             r->proxyreq = 1;
             r->handler  = "proxy-server";
 
             rewritelog(r, 1, "[per-dir %s] go-ahead with proxy request "
@@ -1324,19 +1404,22 @@
                 for (cp = r->filename; *cp != ':' && *cp != '\0'; cp++)
                     ;
                 /* skip '://' */
                 cp += 3;
                 if ((cp = strchr(cp, '/')) != NULL) {
                     rewritelog(r, 2,
-                        "[per-dir %s] trying to replace prefix %s with %s",
-                        dconf->directory, dconf->directory, dconf->baseurl);
+                               "[per-dir %s] trying to replace "
+                               "prefix %s with %s",
+                               dconf->directory, dconf->directory,
+                               dconf->baseurl);
                     cp2 = subst_prefix_path(r, cp, dconf->directory,
                                             dconf->baseurl);
                     if (strcmp(cp2, cp) != 0) {
                         *cp = '\0';
-                        r->filename = ap_pstrcat(r->pool, r->filename, cp2, NULL);
+                        r->filename = ap_pstrcat(r->pool, r->filename,
+                                                 cp2, NULL);
                     }
                 }
             }
 
             /* now prepare the redirect... */
 
@@ -1354,37 +1437,40 @@
                 cp2 = escape_uri(r->pool, cp);
                 *cp = '\0';
                 r->filename = ap_pstrcat(r->pool, r->filename, cp2, NULL);
             }
 
             /* append the QUERY_STRING part */
-            if (r->args != NULL)
-               r->filename = ap_pstrcat(r->pool, r->filename, "?", r->args, NULL);
+            if (r->args != NULL) {
+                r->filename = ap_pstrcat(r->pool, r->filename,
+                                         "?", r->args, NULL);
+            }
 
             /* determine HTTP redirect response code */
             if (is_HTTP_REDIRECT(r->status)) {
                 n = r->status;
                 r->status = HTTP_OK; /* make Apache kernel happy */
             }
-            else
+            else {
                 n = REDIRECT;
+            }
 
             /* now do the redirection */
             ap_table_setn(r->headers_out, "Location", r->filename);
             rewritelog(r, 1, "[per-dir %s] redirect to %s [REDIRECT/%d]",
                        dconf->directory, r->filename, n);
             return n;
         }
         else if (strlen(r->filename) > 10 &&
                  strncmp(r->filename, "forbidden:", 10) == 0) {
-            /* This URLs is forced to be forbidden for the requester */
+            /* This URL is forced to be forbidden for the requester */
             return FORBIDDEN;
         }
         else if (strlen(r->filename) > 5 &&
                  strncmp(r->filename, "gone:", 5) == 0) {
-            /* This URLs is forced to be gone */
+            /* This URL is forced to be gone */
             return HTTP_GONE;
         }
         else {
             /* it was finally rewritten to a local path */
 
             /* if someone used the PASSTHROUGH flag in per-dir
@@ -1394,14 +1480,15 @@
             if (strlen(r->filename) > 12 &&
                 strncmp(r->filename, "passthrough:", 12) == 0) {
                 r->filename = ap_pstrdup(r->pool, r->filename+12);
             }
 
             /* the filename has to start with a slash! */
-            if (r->filename[0] != '/')
+            if (r->filename[0] != '/') {
                 return BAD_REQUEST;
+            }
 
             /* Check for deadlooping:
              * At this point we KNOW that at least one rewriting
              * rule was applied, but when the resulting URL is
              * the same as the initial URL, we are not allowed to
              * use the following internal redirection stuff because
@@ -1431,32 +1518,34 @@
             else {
                 /* if no explicit base-URL exists we assume
                  * that the directory prefix is also a valid URL
                  * for this webserver and only try to remove the
                  * document_root if it is prefix
                  */
-                if ((cp = ap_document_root(r)) != NULL) {
-                    prefix = ap_pstrdup(r->pool, cp);
+                if ((ccp = ap_document_root(r)) != NULL) {
+                    prefix = ap_pstrdup(r->pool, ccp);
                     /* always NOT have a trailing slash */
                     l = strlen(prefix);
                     if (prefix[l-1] == '/') {
                         prefix[l-1] = '\0';
                         l--;
                     }
                     if (strncmp(r->filename, prefix, l) == 0) {
                         rewritelog(r, 2,
-                          "[per-dir %s] strip document_root prefix: %s -> %s",
-                          dconf->directory, r->filename, r->filename+l);
-                          r->filename = ap_pstrdup(r->pool, r->filename+l);
+                                   "[per-dir %s] strip document_root "
+                                   "prefix: %s -> %s",
+                                   dconf->directory, r->filename,
+                                   r->filename+l);
+                        r->filename = ap_pstrdup(r->pool, r->filename+l);
                     }
                 }
             }
 
             /* now initiate the internal redirect */
             rewritelog(r, 1, "[per-dir %s] internal redirect with %s "
-               "[INTERNAL REDIRECT]", dconf->directory, r->filename);
+                       "[INTERNAL REDIRECT]", dconf->directory, r->filename);
             r->filename = ap_pstrcat(r->pool, "redirect:", r->filename, NULL);
             r->handler = "redirect-handler";
             return OK;
         }
     }
     else {
@@ -1475,14 +1564,15 @@
 **
 */
 
 static int handler_redirect(request_rec *r)
 {
     /* just make sure that we are really meant! */
-    if (strncmp(r->filename, "redirect:", 9) != 0)
+    if (strncmp(r->filename, "redirect:", 9) != 0) {
         return DECLINED;
+    }
 
     /* now do the internal redirect */
     ap_internal_redirect(ap_pstrcat(r->pool, r->filename+9,
                                     r->args ? "?" : NULL, r->args, NULL), r);
 
     /* and return gracefully */
@@ -1526,25 +1616,27 @@
          *  asked to do so or this is a proxy-throughput or a
          *  forced redirect rule.
          */
         if (r->main != NULL &&
             (p->flags & RULEFLAG_IGNOREONSUBREQ ||
              p->flags & RULEFLAG_PROXY          ||
-             p->flags & RULEFLAG_FORCEREDIRECT    ))
+             p->flags & RULEFLAG_FORCEREDIRECT    )) {
             continue;
+        }
 
         /*
          *  Apply the current rule.
          */
         rc = apply_rewrite_rule(r, p, perdir);
         if (rc) {
             /*
              *  Indicate a change if this was not a match-only rule.
              */
-            if (rc != 2)
+            if (rc != 2) {
                 changed = 1;
+            }
 
             /*
              *  Pass-Through Feature (`RewriteRule .. .. [PT]'):
              *  Because the Apache 1.x API is very limited we
              *  need this hack to pass the rewritten URL to other
              *  modules like mod_alias, mod_userdir, etc.
@@ -1582,23 +1674,26 @@
             }
 
             /*
              *  Stop processing also on proxy pass-through and
              *  last-rule and new-round flags.
              */
-            if (p->flags & RULEFLAG_PROXY)
+            if (p->flags & RULEFLAG_PROXY) {
                 break;
-            if (p->flags & RULEFLAG_LASTRULE)
+            }
+            if (p->flags & RULEFLAG_LASTRULE) {
                 break;
+            }
 
             /*
              *  On "new-round" flag we just start from the top of
              *  the rewriting ruleset again.
              */
-            if (p->flags & RULEFLAG_NEWROUND)
+            if (p->flags & RULEFLAG_NEWROUND) {
                 goto loop;
+            }
 
             /*
              *  If we are forced to skip N next rules, do it now.
              */
             if (p->skip > 0) {
                 s = p->skip;
@@ -1682,22 +1777,25 @@
     }
 
     /*
      *  Try to match the URI against the RewriteRule pattern
      *  and exit immeddiately if it didn't apply.
      */
-    if (perdir == NULL)
+    if (perdir == NULL) {
         rewritelog(r, 3, "applying pattern '%s' to uri '%s'",
                    p->pattern, uri);
-    else
+    }
+    else {
         rewritelog(r, 3, "[per-dir %s] applying pattern '%s' to uri '%s'",
                    perdir, p->pattern, uri);
+    }
     rc = (regexec(regexp, uri, regexp->re_nsub+1, regmatch, 0) == 0);
     if (! (( rc && !(p->flags & RULEFLAG_NOTMATCH)) ||
-           (!rc &&  (p->flags & RULEFLAG_NOTMATCH))   ) )
+           (!rc &&  (p->flags & RULEFLAG_NOTMATCH))   ) ) {
         return 0;
+    }
 
     /*
      *  Else create the RewriteRule `regsubinfo' structure which
      *  holds the substitution information.
      */
     briRR = (backrefinfo *)ap_palloc(r->pool, sizeof(backrefinfo));
@@ -1767,14 +1865,15 @@
                 failed = 1;
                 break;
             }
         }
     }
     /*  if any condition fails the complete rule fails  */
-    if (failed)
+    if (failed) {
         return 0;
+    }
 
     /*
      *  If this is a pure matching rule (`RewriteRule <pat> -')
      *  we stop processing and return immediately. The only thing
      *  we have not to forget are the environment variables
      *  (`RewriteRule <pat> - [E=...]')
@@ -1836,16 +1935,18 @@
     expand_backref_inbuffer(r->pool, newuri, sizeof(newuri), briRC, '%');
     /*  4. expand %{...} (i.e. variables) */
     expand_variables_inbuffer(r, newuri, sizeof(newuri));
     /*  5. expand ${...} (RewriteMap lookups)  */
     expand_map_lookups(r, newuri, sizeof(newuri));
     /*  and log the result... */
-    if (perdir == NULL)
+    if (perdir == NULL) {
         rewritelog(r, 2, "rewrite %s -> %s", uri, newuri);
-    else
+    }
+    else {
         rewritelog(r, 2, "[per-dir %s] rewrite %s -> %s", perdir, uri, newuri);
+    }
 
     /*
      *  Additionally do expansion for the environment variable
      *  strings (`RewriteRule .. .. [E=<string>]').
      */
     for (i = 0; p->env[i] != NULL; i++) {
@@ -1896,36 +1997,40 @@
      *  for this URL later in the Apache API. But make sure it is
      *  a fully-qualified URL. (If not it is qualified with
      *  ourself).
      */
     if (p->flags & RULEFLAG_PROXY) {
         fully_qualify_uri(r);
-        if (perdir == NULL)
+        if (perdir == NULL) {
             rewritelog(r, 2, "forcing proxy-throughput with %s", r->filename);
-        else
+        }
+        else {
             rewritelog(r, 2, "[per-dir %s] forcing proxy-throughput with %s",
                        perdir, r->filename);
+        }
         r->filename = ap_pstrcat(r->pool, "proxy:", r->filename, NULL);
         return 1;
     }
 
     /*
      *  If this rule is explicitly forced for HTTP redirection
      *  (`RewriteRule .. .. [R]') then force an external HTTP
      *  redirect. But make sure it is a fully-qualified URL. (If
      *  not it is qualified with ourself).
      */
     if (p->flags & RULEFLAG_FORCEREDIRECT) {
         fully_qualify_uri(r);
-        if (perdir == NULL)
+        if (perdir == NULL) {
             rewritelog(r, 2,
                        "explicitly forcing redirect with %s", r->filename);
-        else
+        }
+        else {
             rewritelog(r, 2,
                        "[per-dir %s] explicitly forcing redirect with %s",
                        perdir, r->filename);
+        }
         r->status = p->forced_responsecode;
         return 1;
     }
 
     /*
      *  Special Rewriting Feature: Self-Reduction
@@ -1945,20 +2050,22 @@
      */
     i = strlen(r->filename);
     if (   (i > 7 && strncasecmp(r->filename, "http://", 7)   == 0)
         || (i > 8 && strncasecmp(r->filename, "https://", 8)  == 0)
         || (i > 9 && strncasecmp(r->filename, "gopher://", 9) == 0)
         || (i > 6 && strncasecmp(r->filename, "ftp://", 6)    == 0)) {
-        if (perdir == NULL)
+        if (perdir == NULL) {
             rewritelog(r, 2,
                        "implicitly forcing redirect (rc=%d) with %s",
                        p->forced_responsecode, r->filename);
-        else
+        }
+        else {
             rewritelog(r, 2, "[per-dir %s] implicitly forcing redirect "
                        "(rc=%d) with %s", perdir, p->forced_responsecode,
                        r->filename);
+        }
         r->status = p->forced_responsecode;
         return 1;
     }
 
     /*
      *  Now we are sure it is not a fully qualified URL.  But
@@ -1981,19 +2088,21 @@
      *  the per-directory context (where the MIME-type hook was
      *  already processed) because a sub-request happens ;-)
      */
     if (p->forced_mimetype != NULL) {
         ap_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
                       p->forced_mimetype);
-        if (perdir == NULL)
+        if (perdir == NULL) {
             rewritelog(r, 2, "remember %s to have MIME-type '%s'",
                        r->filename, p->forced_mimetype);
-        else
+        }
+        else {
             rewritelog(r, 2,
                        "[per-dir %s] remember %s to have MIME-type '%s'",
                        perdir, r->filename, p->forced_mimetype);
+        }
     }
 
     /*
      *  Puuhhhhhhhh... WHAT COMPLICATED STUFF ;_)
      *  But now we're done for this particular rule.
      */
@@ -2028,32 +2137,40 @@
     /*
      *   Apply the patterns
      */
 
     rc = 0;
     if (strcmp(p->pattern, "-f") == 0) {
-        if (stat(input, &sb) == 0)
-            if (S_ISREG(sb.st_mode))
+        if (stat(input, &sb) == 0) {
+            if (S_ISREG(sb.st_mode)) {
                 rc = 1;
+            }
+        }
     }
-    else if (strcmp(p->pattern, "-s") == 0) {
-        if (stat(input, &sb) == 0)
-            if (S_ISREG(sb.st_mode) && sb.st_size > 0)
+    else if (strcmp(p->pattern, "-s ") == 0) {
+        if (stat(input, &sb) == 0) {
+            if (S_ISREG(sb.st_mode) && sb.st_size > 0) {
                 rc = 1;
+            }
+        }
     }
     else if (strcmp(p->pattern, "-l") == 0) {
 #if !defined(__EMX__) && !defined(WIN32)
-        if (lstat(input, &sb) == 0)
-            if (S_ISLNK(sb.st_mode))
+        if (lstat(input, &sb) == 0) {
+            if (S_ISLNK(sb.st_mode)) {
                 rc = 1;
+            }
+        }
 #endif
     }
     else if (strcmp(p->pattern, "-d") == 0) {
-        if (stat(input, &sb) == 0)
-            if (S_ISDIR(sb.st_mode))
+        if (stat(input, &sb) == 0) {
+            if (S_ISDIR(sb.st_mode)) {
                 rc = 1;
+            }
+        }
     }
     else if (strcmp(p->pattern, "-U") == 0) {
         /* avoid infinite subrequest recursion */
         if (strlen(input) > 0               /* nonempty path, and            */
             && (   r->main == NULL          /* - either not in a subrequest  */
                 || (   r->main->uri != NULL /* - or in a subrequest...       */
@@ -2090,14 +2207,15 @@
              */
             rsub = ap_sub_req_lookup_file(input, r);
 
             /* file exists for any result up to 2xx, no redirects */
             if (rsub->status < 300 &&
                 /* double-check that file exists since default result is 200 */
-                stat(rsub->filename, &sb) == 0)
+                stat(rsub->filename, &sb) == 0) {
                 rc = 1;
+            }
 
             /* log it */
             rewritelog(r, 5, "RewriteCond file (-F) check: path=%s "
                        "-> file=%s status=%d", input, rsub->filename, 
                        rsub->status);
 
@@ -2109,16 +2227,18 @@
         rc = (compare_lexicography(input, p->pattern+1) == 1 ? 1 : 0);
     }
     else if (strlen(p->pattern) > 1 && *(p->pattern) == '<') {
         rc = (compare_lexicography(input, p->pattern+1) == -1 ? 1 : 0);
     }
     else if (strlen(p->pattern) > 1 && *(p->pattern) == '=') {
-        if (strcmp(p->pattern+1, "\"\"") == 0)
+        if (strcmp(p->pattern+1, "\"\"") == 0) {
             rc = (*input == '\0');
-        else
+        }
+        else {
             rc = (strcmp(input, p->pattern+1) == 0 ? 1 : 0);
+        }
     }
     else {
         /* it is really a regexp pattern, so apply it */
         rc = (regexec(p->regexp, input,
                       p->regexp->re_nsub+1, regmatch,0) == 0);
 
@@ -2130,14 +2250,15 @@
             memcpy((void *)(briRC->regmatch), (void *)(regmatch),
                    sizeof(regmatch));
         }
     }
 
     /* if this is a non-matching regexp, just negate the result */
-    if (p->flags & CONDFLAG_NOTMATCH)
+    if (p->flags & CONDFLAG_NOTMATCH) {
         rc = !rc;
+    }
 
     rewritelog(r, 4, "RewriteCond: input='%s' pattern='%s%s' => %s",
                input, (p->flags & CONDFLAG_NOTMATCH ? "!" : ""),
                p->pattern, rc ? "matched" : "not-matched");
 
     /* end just return the result */
@@ -2166,24 +2287,27 @@
     char *olduri;
 
     q = strchr(r->filename, '?');
     if (q != NULL) {
         olduri = ap_pstrdup(r->pool, r->filename);
         *q++ = '\0';
-        if (qsappend)
+        if (qsappend) {
             r->args = ap_pstrcat(r->pool, q, "&", r->args, NULL);
-        else
+        }
+        else {
             r->args = ap_pstrdup(r->pool, q);
+        }
         if (strlen(r->args) == 0) {
             r->args = NULL;
             rewritelog(r, 3, "split uri=%s -> uri=%s, args=<none>", olduri,
                        r->filename);
         }
         else {
-            if (r->args[strlen(r->args)-1] == '&')
+            if (r->args[strlen(r->args)-1] == '&') {
                 r->args[strlen(r->args)-1] = '\0';
+            }
             rewritelog(r, 3, "split uri=%s -> uri=%s, args=%s", olduri,
                        r->filename, r->args);
         }
     }
     return;
 }
@@ -2203,27 +2327,27 @@
     char *hostp;
     char *url;
     char c;
     char host[LONG_STRING_LEN];
     char buf[MAX_STRING_LEN];
     char *olduri;
+    int l;
 
-#ifdef APACHE_SSL
-    if (   (!r->connection->client->ssl &&
-            strncasecmp(r->filename, "http://", 7) == 0)
-        || (r->connection->client->ssl &&
-            strncasecmp(r->filename, "https://", 8) == 0)) {
-#else
-    if (strncasecmp(r->filename, "http://", 7) == 0) {
-#endif
+    cp = ap_http_method(r);
+    l  = strlen(cp);
+    if (   strlen(r->filename) > l+3 
+        && strncasecmp(r->filename, cp, l) == 0
+        && r->filename[l]   == ':'
+        && r->filename[l+1] == '/'
+        && r->filename[l+2] == '/'             ) {
         /* there was really a rewrite to a remote path */
 
         olduri = ap_pstrdup(r->pool, r->filename); /* save for logging */
 
         /* cut the hostname and port out of the URI */
-        ap_cpystrn(buf, r->filename+strlen(ap_http_method(r))+3, sizeof(buf));
+        ap_cpystrn(buf, r->filename+(l+3), sizeof(buf));
         hostp = buf;
         for (cp = hostp; *cp != '\0' && *cp != '/' && *cp != ':'; cp++)
             ;
         if (*cp == ':') {
             /* set host */
             *cp++ = '\0';
@@ -2289,27 +2413,30 @@
           || (i > 8 && strncasecmp(r->filename, "https://", 8)  == 0)
           || (i > 9 && strncasecmp(r->filename, "gopher://", 9) == 0)
           || (i > 6 && strncasecmp(r->filename, "ftp://", 6)    == 0))) {
 
         thisserver = ap_get_server_name(r);
         port = ap_get_server_port(r);
-        if (ap_is_default_port(port,r))
+        if (ap_is_default_port(port,r)) {
             thisport = "";
+        }
         else {
             ap_snprintf(buf, sizeof(buf), ":%u", port);
             thisport = buf;
         }
 
-        if (r->filename[0] == '/')
+        if (r->filename[0] == '/') {
             r->filename = ap_psprintf(r->pool, "%s://%s%s%s",
                                       ap_http_method(r), thisserver,
                                       thisport, r->filename);
-        else
+        }
+        else {
             r->filename = ap_psprintf(r->pool, "%s://%s%s/%s",
                                       ap_http_method(r), thisserver,
                                       thisport, r->filename);
+        }
     }
     return;
 }
 
 
 /*
@@ -2320,34 +2447,39 @@
 
 static void expand_backref_inbuffer(pool *p, char *buf, int nbuf,
                                     backrefinfo *bri, char c)
 {
     int i;
 
-    if (bri->nsub < 1)
+    if (bri->nsub < 1) {
         return;
+    }
 
     if (c != '$') {
         /* safe existing $N backrefs and replace <c>N with $N backrefs */
         for (i = 0; buf[i] != '\0' && i < nbuf; i++) {
-            if (buf[i] == '$' && (buf[i+1] >= '0' && buf[i+1] <= '9'))
+            if (buf[i] == '$' && (buf[i+1] >= '0' && buf[i+1] <= '9')) {
                 buf[i++] = '\001';
-            else if (buf[i] == c && (buf[i+1] >= '0' && buf[i+1] <= '9'))
+            }
+            else if (buf[i] == c && (buf[i+1] >= '0' && buf[i+1] <= '9')) {
                 buf[i++] = '$';
+            }
         }
     }
 
     /* now apply the pregsub() function */
     ap_cpystrn(buf, ap_pregsub(p, buf, bri->source,
                          bri->nsub+1, bri->regmatch), nbuf);
 
     if (c != '$') {
         /* restore the original $N backrefs */
-        for (i = 0; buf[i] != '\0' && i < nbuf; i++)
-            if (buf[i] == '\001' && (buf[i+1] >= '0' && buf[i+1] <= '9'))
+        for (i = 0; buf[i] != '\0' && i < nbuf; i++) {
+            if (buf[i] == '\001' && (buf[i+1] >= '0' && buf[i+1] <= '9')) {
                 buf[i++] = '$';
+            }
+        }
     }
 }
 
 
 /*
 **
@@ -2364,24 +2496,26 @@
     int i, j;
 
     newuri = uri;
     if (uri != NULL && strlen(uri) > 2 && uri[0] == '/' && uri[1] == '~') {
         /* cut out the username */
         for (j = 0, i = 2; j < sizeof(user)-1
-                           && uri[i] != '\0'
-                           && uri[i] != '/'  ; )
+               && uri[i] != '\0'
+               && uri[i] != '/'  ; ) {
             user[j++] = uri[i++];
+        }
         user[j] = '\0';
 
         /* lookup username in systems passwd file */
         if ((pw = getpwnam(user)) != NULL) {
             /* ok, user was found, so expand the ~user string */
             if (uri[i] != '\0') {
                 /* ~user/anything...  has to be expanded */
-                if (pw->pw_dir[strlen(pw->pw_dir)-1] == '/')
+                if (pw->pw_dir[strlen(pw->pw_dir)-1] == '/') {
                     pw->pw_dir[strlen(pw->pw_dir)-1] = '\0';
+                }
                 newuri = ap_pstrcat(r->pool, pw->pw_dir, uri+i, NULL);
             }
             else {
                 /* only ~user has to be expanded */
                 newuri = ap_pstrdup(r->pool, pw->pw_dir);
             }
@@ -2680,19 +2814,21 @@
     char result[1024];
     char *value = NULL;
     char *cpT;
     char *curkey;
     char *curval;
 
-    if ((fp = ap_pfopen(r->pool, file, "r")) == NULL)
+    if ((fp = ap_pfopen(r->pool, file, "r")) == NULL) {
         return NULL;
+    }
 
     ap_cpystrn(output, MAPFILE_OUTPUT, sizeof(output));
     while (fgets(line, sizeof(line), fp) != NULL) {
-        if (line[strlen(line)-1] == '\n')
+        if (line[strlen(line)-1] == '\n') {
             line[strlen(line)-1] = '\0';
+        }
         if (regexec(lookup_map_txtfile_regexp, line,
                     lookup_map_txtfile_regexp->re_nsub+1,
                     lookup_map_txtfile_regmatch, 0) == 0) {
             ap_cpystrn(result, ap_pregsub(r->pool, output, line,
                     lookup_map_txtfile_regexp->re_nsub+1,
                     lookup_map_txtfile_regmatch),
@@ -2745,38 +2881,42 @@
 
     /* when `RewriteEngine off' was used in the per-server
      * context then the rewritemap-programs were not spawned.
      * In this case using such a map (usually in per-dir context)
      * is useless because it is not available.
      */
-    if (fpin == -1 || fpout == -1)
+    if (fpin == -1 || fpout == -1) {
         return NULL;
+    }
 
     /* take the lock */
     rewritelock_alloc(r);
 
     /* write out the request key */
     write(fpin, key, strlen(key));
     write(fpin, "\n", 1);
 
     /* read in the response value */
     i = 0;
     while (read(fpout, &c, 1) == 1 && (i < LONG_STRING_LEN-1)) {
-        if (c == '\n')
+        if (c == '\n') {
             break;
+        }
         buf[i++] = c;
     }
     buf[i] = '\0';
 
     /* give the lock back */
     rewritelock_free(r);
 
-    if (strcasecmp(buf, "NULL") == 0)
+    if (strcasecmp(buf, "NULL") == 0) {
         return NULL;
-    else
+    }
+    else {
         return ap_pstrdup(r->pool, buf);
+    }
 }
 
 static char *lookup_map_internal(request_rec *r,
                                  char *(*func)(request_rec *, char *),
                                  char *key)
 {
@@ -2786,23 +2926,27 @@
 }
 
 static char *rewrite_mapfunc_toupper(request_rec *r, char *key)
 {
     char *value, *cp;
 
-    for (cp = value = ap_pstrdup(r->pool, key); cp != NULL && *cp != '\0'; cp++)
-        *cp = toupper(*cp);
+    for (cp = value = ap_pstrdup(r->pool, key); cp != NULL && *cp != '\0';
+         cp++) {
+        *cp = ap_toupper(*cp);
+    }
     return value;
 }
 
 static char *rewrite_mapfunc_tolower(request_rec *r, char *key)
 {
     char *value, *cp;
 
-    for (cp = value = ap_pstrdup(r->pool, key); cp != NULL && *cp != '\0'; cp++)
-        *cp = tolower(*cp);
+    for (cp = value = ap_pstrdup(r->pool, key); cp != NULL && *cp != '\0';
+         cp++) {
+        *cp = ap_tolower(*cp);
+    }
     return value;
 }
 
 static int rewrite_rand_init_done = 0;
 
 static void rewrite_rand_init(void)
@@ -2817,42 +2961,48 @@
 static int rewrite_rand(int l, int h)
 {
     int i;
     char buf[50];
 
     rewrite_rand_init();
-    sprintf(buf, "%.0f", (((double)(rand()%RAND_MAX)/RAND_MAX)*(h-l)));
+    ap_snprintf(buf, sizeof(buf), "%.0f", 
+                (((double)(rand()%RAND_MAX)/RAND_MAX)*(h-l)));
     i = atoi(buf)+1;
     if (i < l) i = l;
     if (i > h) i = h;
     return i;
 }
 
 static char *select_random_value_part(request_rec *r, char *value)
 {
     char *buf;
     int n, i, k;
 
     /*  count number of distinct values  */
-    for (n = 1, i = 0; value[i] != '\0'; i++)
-        if (value[i] == '|')
+    for (n = 1, i = 0; value[i] != '\0'; i++) {
+        if (value[i] == '|') {
             n++;
+        }
+    }
 
     /*  when only one value we have no option to choose  */
-    if (n == 1)
+    if (n == 1) {
         return value;
+    }
 
     /*  else randomly select one  */
     k = rewrite_rand(1, n);
 
     /*  and grep it out  */
     for (n = 1, i = 0; value[i] != '\0'; i++) {
-        if (n == k)
+        if (n == k) {
             break;
-        if (value[i] == '|')
+        }
+        if (value[i] == '|') {
             n++;
+        }
     }
     buf = ap_pstrdup(r->pool, &value[i]);
     for (i = 0; buf[i] != '\0' && buf[i] != '|'; i++)
         ;
     buf[i] = '\0';
     return buf;
@@ -2879,18 +3029,21 @@
 #else
     mode_t rewritelog_mode  = ( S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH );
 #endif
 
     conf = ap_get_module_config(s->module_config, &rewrite_module);
 
-    if (conf->rewritelogfile == NULL)
+    if (conf->rewritelogfile == NULL) {
         return;
-    if (*(conf->rewritelogfile) == '\0')
+    }
+    if (*(conf->rewritelogfile) == '\0') {
         return;
-    if (conf->rewritelogfp > 0)
+    }
+    if (conf->rewritelogfp > 0) {
         return; /* virtual log shared w/ main server */
+    }
 
     fname = ap_server_root_relative(p, conf->rewritelogfile);
 
     if (*conf->rewritelogfile == '|') {
         if ((pl = ap_open_piped_log(p, conf->rewritelogfile+1)) == NULL) {
             ap_log_error(APLOG_MARK, APLOG_ERR, s, 
@@ -2928,54 +3082,64 @@
     const char *rhost;
 
     va_start(ap, text);
     conf = ap_get_module_config(r->server->module_config, &rewrite_module);
     conn = r->connection;
 
-    if (conf->rewritelogfp < 0)
+    if (conf->rewritelogfp < 0) {
         return;
-    if (conf->rewritelogfile == NULL)
+    }
+    if (conf->rewritelogfile == NULL) {
         return;
-    if (*(conf->rewritelogfile) == '\0')
+    }
+    if (*(conf->rewritelogfile) == '\0') {
         return;
+    }
 
-    if (level > conf->rewriteloglevel)
+    if (level > conf->rewriteloglevel) {
         return;
+    }
 
     if (conn->user == NULL) {
         ruser = "-";
     }
     else if (strlen(conn->user) != 0) {
         ruser = conn->user;
     }
     else {
         ruser = "\"\"";
     }
 
     rhost = ap_get_remote_host(conn, r->server->module_config, 
-			                   REMOTE_NOLOOKUP);
-    if (rhost == NULL)
+                               REMOTE_NOLOOKUP);
+    if (rhost == NULL) {
         rhost = "UNKNOWN-HOST";
+    }
 
     str1 = ap_pstrcat(r->pool, rhost, " ",
                       (conn->remote_logname != NULL ?
                       conn->remote_logname : "-"), " ",
                       ruser, NULL);
     ap_vsnprintf(str2, sizeof(str2), text, ap);
 
-    if (r->main == NULL)
+    if (r->main == NULL) {
         strcpy(type, "initial");
-    else
+    }
+    else {
         strcpy(type, "subreq");
+    }
 
-    for (i = 0, req = r; req->prev != NULL; req = req->prev)
+    for (i = 0, req = r; req->prev != NULL; req = req->prev) {
         i++;
-    if (i == 0)
+    }
+    if (i == 0) {
         redir[0] = '\0';
-    else
+    }
+    else {
         ap_snprintf(redir, sizeof(redir), "/redir#%d", i);
+    }
 
     ap_snprintf(str3, sizeof(str3),
                 "%s %s [%s/sid#%lx][rid#%lx/%s%s] (%d) %s\n", str1,
                 current_logtime(r), ap_get_server_name(r),
                 (unsigned long)(r->server), (unsigned long)r,
                 type, redir, level, str2);
@@ -2994,14 +3158,15 @@
     struct tm *t;
     char tstr[80];
     char sign;
 
     t = ap_get_gmtoff(&timz);
     sign = (timz < 0 ? '-' : '+');
-    if(timz < 0)
+    if (timz < 0) {
         timz = -timz;
+    }
 
     strftime(tstr, 80, "[%d/%b/%Y:%H:%M:%S ", t);
     ap_snprintf(tstr + strlen(tstr), 80-strlen(tstr), "%c%.2d%.2d]",
                 sign, timz/60, timz%60);
     return ap_pstrdup(r->pool, tstr);
 }
@@ -3028,14 +3193,15 @@
     rewrite_server_conf *conf;
 
     conf = ap_get_module_config(s->module_config, &rewrite_module);
 
     /* only operate if a lockfile is used */
     if (conf->rewritelockfile == NULL
-        || *(conf->rewritelockfile) == '\0')
+        || *(conf->rewritelockfile) == '\0') {
         return;
+    }
 
     /* fixup the path, especially for rewritelock_remove() */
     conf->rewritelockfile = ap_server_root_relative(p, conf->rewritelockfile);
 
     /* create the lockfile */
     unlink(conf->rewritelockfile);
@@ -3044,25 +3210,32 @@
                                          REWRITELOCK_MODE)) < 0) {
         ap_log_error(APLOG_MARK, APLOG_ERR, s,
                      "mod_rewrite: Parent could not create RewriteLock "
                      "file %s", conf->rewritelockfile);
         exit(1);
     }
+#if !defined(__EMX__) && !defined(WIN32)
+    /* make sure the childs have access to this file */
+    if (geteuid() == 0 /* is superuser */)
+        chown(conf->rewritelockfile, ap_user_id, -1 /* no gid change */);
+#endif
+
     return;
 }
 
 static void rewritelock_open(server_rec *s, pool *p)
 {
     rewrite_server_conf *conf;
 
     conf = ap_get_module_config(s->module_config, &rewrite_module);
 
     /* only operate if a lockfile is used */
     if (conf->rewritelockfile == NULL
-        || *(conf->rewritelockfile) == '\0')
+        || *(conf->rewritelockfile) == '\0') {
         return;
+    }
 
     /* open the lockfile (once per child) to get a unique fd */
     if ((conf->rewritelockfp = ap_popenf(p, conf->rewritelockfile,
                                          O_WRONLY,
                                          REWRITELOCK_MODE)) < 0) {
         ap_log_error(APLOG_MARK, APLOG_ERR, s,
@@ -3081,38 +3254,41 @@
     /* the data is really the server_rec */
     s = (server_rec *)data;
     conf = ap_get_module_config(s->module_config, &rewrite_module);
 
     /* only operate if a lockfile is used */
     if (conf->rewritelockfile == NULL
-        || *(conf->rewritelockfile) == '\0')
+        || *(conf->rewritelockfile) == '\0') {
         return;
+    }
 
     /* remove the lockfile */
     unlink(conf->rewritelockfile);
 }
 
 static void rewritelock_alloc(request_rec *r)
 {
     rewrite_server_conf *conf;
 
     conf = ap_get_module_config(r->server->module_config, &rewrite_module);
 
-    if (conf->rewritelockfp != -1)
+    if (conf->rewritelockfp != -1) {
         fd_lock(r, conf->rewritelockfp);
+    }
     return;
 }
 
 static void rewritelock_free(request_rec *r)
 {
     rewrite_server_conf *conf;
 
     conf = ap_get_module_config(r->server->module_config, &rewrite_module);
 
-    if (conf->rewritelockfp != -1)
+    if (conf->rewritelockfp != -1) {
         fd_unlock(r, conf->rewritelockfp);
+    }
     return;
 }
 
 
 /*
 ** +-------------------------------------------------------+
@@ -3136,26 +3312,29 @@
 
     conf = ap_get_module_config(s->module_config, &rewrite_module);
 
     /*  If the engine isn't turned on,
      *  don't even try to do anything.
      */
-    if (conf->state == ENGINE_DISABLED)
+    if (conf->state == ENGINE_DISABLED) {
         return;
+    }
 
     rewritemaps = conf->rewritemaps;
     entries = (rewritemap_entry *)rewritemaps->elts;
     for (i = 0; i < rewritemaps->nelts; i++) {
         map = &entries[i];
-        if (map->type != MAPTYPE_PRG)
+        if (map->type != MAPTYPE_PRG) {
             continue;
+        }
         if (map->datafile == NULL
             || *(map->datafile) == '\0'
             || map->fpin  != -1
-            || map->fpout != -1        )
+            || map->fpout != -1        ) {
             continue;
+        }
         fpin  = NULL;
         fpout = NULL;
         rc = ap_spawn_child(p, rewritemap_program_child,
                             (void *)map->datafile, kill_after_timeout,
                             &fpin, &fpout, &fperr);
         if (rc == 0 || fpin == NULL || fpout == NULL) {
@@ -3187,17 +3366,17 @@
     /*
      * Exec() the child program
      */
 #if defined(WIN32)
     /* MS Windows */
     {
-        char *pCommand;
+        char pCommand[MAX_STRING_LEN];
         STARTUPINFO si;
         PROCESS_INFORMATION pi;
 
-        pCommand = strcat(SHELL_PATH, " /C ", cmd, NULL);
+        ap_snprintf(pCommand, sizeof(pCommand), "%s /C %s", SHELL_PATH, cmd);
 
         memset(&si, 0, sizeof(si));
         memset(&pi, 0, sizeof(pi));
 
         si.cb          = sizeof(si);
         si.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
@@ -3236,14 +3415,15 @@
 
 
 static void expand_variables_inbuffer(request_rec *r, char *buf, int buf_len)
 {
     char *newbuf;
     newbuf = expand_variables(r, buf);
-    if (strcmp(newbuf, buf) != 0)
+    if (strcmp(newbuf, buf) != 0) {
         ap_cpystrn(buf, newbuf, buf_len);
+    }
     return;
 }
 
 static char *expand_variables(request_rec *r, char *str)
 {
     char output[MAX_STRING_LEN];
@@ -3434,17 +3614,19 @@
 
     /* all other env-variables from the parent Apache process */
     else if (strlen(var) > 4 && strncasecmp(var, "ENV:", 4) == 0) {
         /* first try the internal Apache notes structure */
         result = ap_table_get(r->notes, var+4);
         /* second try the internal Apache env structure  */
-        if (result == NULL)
+        if (result == NULL) {
             result = ap_table_get(r->subprocess_env, var+4);
+        }
         /* third try the external OS env */
-        if (result == NULL)
+        if (result == NULL) {
             result = getenv(var+4);
+        }
     }
 
 #define LOOKAHEAD(subrecfunc) \
         if ( \
           /* filename is safe to use */ \
           r->filename != NULL \
@@ -3512,31 +3694,35 @@
                 }
             }
         }
     }
 #endif /* ndef WIN32 */
 
-    if (result == NULL)
+    if (result == NULL) {
         return ap_pstrdup(r->pool, "");
-    else
+    }
+    else {
         return ap_pstrdup(r->pool, result);
+    }
 }
 
 static char *lookup_header(request_rec *r, const char *name)
 {
     array_header *hdrs_arr;
     table_entry *hdrs;
     int i;
 
-    hdrs_arr = table_elts(r->headers_in);
+    hdrs_arr = ap_table_elts(r->headers_in);
     hdrs = (table_entry *)hdrs_arr->elts;
     for (i = 0; i < hdrs_arr->nelts; ++i) {
-       if (hdrs[i].key == NULL)
-          continue;
-       if (strcasecmp(hdrs[i].key, name) == 0)
-          return hdrs[i].val;
+        if (hdrs[i].key == NULL) {
+            continue;
+        }
+        if (strcasecmp(hdrs[i].key, name) == 0) {
+            return hdrs[i].val;
+        }
     }
     return NULL;
 }
 
 
 
@@ -3575,21 +3761,24 @@
 static char *get_cache_string(cache *c, char *res, int mode,
                               time_t t, char *key)
 {
     cacheentry *ce;
 
     ce = retrieve_cache_string(c, res, key);
-    if (ce == NULL)
+    if (ce == NULL) {
         return NULL;
+    }
     if (mode & CACHEMODE_TS) {
-        if (t != ce->time)
+        if (t != ce->time) {
             return NULL;
+        }
     }
     else if (mode & CACHEMODE_TTL) {
-        if (t > ce->time)
+        if (t > ce->time) {
             return NULL;
+        }
     }
     return ap_pstrdup(c->pool, ce->value);
 }
 
 static void store_cache_string(cache *c, char *res, cacheentry *ce)
 {
@@ -3724,14 +3913,15 @@
 static int parseargline(char *str, char **a1, char **a2, char **a3)
 {
     char *cp;
     int isquoted;
 
 #define SKIP_WHITESPACE(cp) \
-    for ( ; *cp == ' ' || *cp == '\t'; ) \
-        cp++;
+    for ( ; *cp == ' ' || *cp == '\t'; ) { \
+        cp++; \
+    };
 
 #define CHECK_QUOTATION(cp,isquoted) \
     isquoted = 0; \
     if (*cp == '"') { \
         isquoted = 1; \
         cp++; \
@@ -3742,25 +3932,27 @@
         if (   (isquoted    && (*cp     == ' ' || *cp     == '\t')) \
             || (*cp == '\\' && (*(cp+1) == ' ' || *(cp+1) == '\t'))) { \
             cp++; \
             continue; \
         } \
         if (   (!isquoted && (*cp == ' ' || *cp == '\t')) \
-            || (isquoted  && *cp == '"')                  ) \
+            || (isquoted  && *cp == '"')                  ) { \
             break; \
+        } \
     }
 
     cp = str;
     SKIP_WHITESPACE(cp);
 
     /*  determine first argument */
     CHECK_QUOTATION(cp, isquoted);
     *a1 = cp;
     DETERMINE_NEXTSTRING(cp, isquoted);
-    if (*cp == '\0')
+    if (*cp == '\0') {
         return 1;
+    }
     *cp++ = '\0';
 
     SKIP_WHITESPACE(cp);
 
     /*  determine second argument */
     CHECK_QUOTATION(cp, isquoted);
@@ -3820,20 +4012,24 @@
 static int prefix_stat(const char *path, struct stat *sb)
 {
     char curpath[LONG_STRING_LEN];
     char *cp;
 
     ap_cpystrn(curpath, path, sizeof(curpath));
-    if (curpath[0] != '/')
+    if (curpath[0] != '/') {
         return 0;
-    if ((cp = strchr(curpath+1, '/')) != NULL)
+    }
+    if ((cp = strchr(curpath+1, '/')) != NULL) {
         *cp = '\0';
-    if (stat(curpath, sb) == 0)
+    }
+    if (stat(curpath, sb) == 0) {
         return 1;
-    else
+    }
+    else {
         return 0;
+    }
 }
 
 
 /*
 **
 **  File locking
@@ -3854,19 +4050,21 @@
     lock_it.l_start  = 0;        /* -"- */
     lock_it.l_len    = 0;        /* until end of file */
     lock_it.l_type   = F_WRLCK;  /* set exclusive/write lock */
     lock_it.l_pid    = 0;        /* pid not actually interesting */
 
     while (   ((rc = fcntl(fd, F_SETLKW, &lock_it)) < 0)
-           && (errno == EINTR)                               )
+              && (errno == EINTR)                               ) {
         continue;
+    }
 #endif
 #ifdef USE_FLOCK
     while (   ((rc = flock(fd, LOCK_EX)) < 0)
-           && (errno == EINTR)               )
+              && (errno == EINTR)               ) {
         continue;
+    }
 #endif
 #ifdef USE_LOCKING
     /* Lock the first byte, always, assume we want to append
        and seek to the end afterwards */
     lseek(fd, 0, SEEK_SET);
     rc = _locking(fd, _LK_LOCK, 1);
@@ -3920,21 +4118,25 @@
 {
     int i;
     int n1, n2;
 
     n1 = strlen(cpNum1);
     n2 = strlen(cpNum2);
-    if (n1 > n2)
+    if (n1 > n2) {
         return 1;
-    if (n1 < n2)
+    }
+    if (n1 < n2) {
         return -1;
+    }
     for (i = 0; i < n1; i++) {
-        if (cpNum1[i] > cpNum2[i])
+        if (cpNum1[i] > cpNum2[i]) {
             return 1;
-        if (cpNum1[i] < cpNum2[i])
+        }
+        if (cpNum1[i] < cpNum2[i]) {
             return -1;
+        }
     }
     return 0;
 }
 
 
 /*EOF*/
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_rewrite.h apache_1.3.1/src/modules/standard/mod_rewrite.h
--- apache_1.3.0/src/modules/standard/mod_rewrite.h	1998-05-29 16:32:40.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_rewrite.h	1998-07-13 19:32:46.000000000 +0800
@@ -104,12 +104,13 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
     /* Include from the Apache server ... */
 #include "httpd.h"
 #include "http_config.h"
+#include "http_conf_globals.h"
 #include "http_request.h"
 #include "http_core.h"
 #include "http_log.h"
 #include "http_vhost.h"
 
     /* The NDBM support:
@@ -126,13 +127,13 @@
 #endif
 #endif
 
 
     /* The locking support:
      * Try to determine whether we should use fcntl() or flock().
-     * Would be better conf.h could provide this... :-(
+     * Would be better ap_config.h could provide this... :-(
      */
 #if defined(USE_FCNTL_SERIALIZED_ACCEPT)
 #define USE_FCNTL 1
 #include <fcntl.h>
 #endif
 #if defined(USE_FLOCK_SERIALIZED_ACCEPT)
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_setenvif.c apache_1.3.1/src/modules/standard/mod_setenvif.c
--- apache_1.3.0/src/modules/standard/mod_setenvif.c	1998-05-02 19:15:13.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_setenvif.c	1998-07-10 20:58:56.000000000 +0800
@@ -155,38 +155,39 @@
 static void *merge_setenvif_config(pool *p, void *basev, void *overridesv)
 {
     sei_cfg_rec *a = ap_pcalloc(p, sizeof(sei_cfg_rec));
     sei_cfg_rec *base = basev, *overrides = overridesv;
 
     a->conditionals = ap_append_arrays(p, base->conditionals,
-                                    overrides->conditionals);
+				       overrides->conditionals);
     return a;
 }
 
-/* any non-NULL magic constant will do... used to indicate if REG_ICASE should be
- * used */
+/* any non-NULL magic constant will do... used to indicate if REG_ICASE should
+ * be used
+ */
 #define ICASE_MAGIC	((void *)(&setenvif_module))
 
 static const char *add_setenvif_core(cmd_parms *cmd, void *mconfig,
-    char *fname, const char *args)
+				     char *fname, const char *args)
 {
     char *regex;
     const char *feature;
     sei_cfg_rec *sconf = ap_get_module_config(cmd->server->module_config,
-                                           &setenvif_module);
+					      &setenvif_module);
     sei_entry *new, *entries = (sei_entry *) sconf->conditionals->elts;
     char *var;
     int i;
     int beenhere = 0;
     unsigned icase;
 
     /* get regex */
     regex = ap_getword_conf(cmd->pool, &args);
     if (!*regex) {
         return ap_pstrcat(cmd->pool, "Missing regular expression for ",
-                        cmd->cmd->name, NULL);
+			  cmd->cmd->name, NULL);
     }
 
     /*
      * If we've already got a sei_entry with the same name we want to
      * just copy the name pointer... so that later on we can compare
      * two header names just by comparing the pointers.
@@ -214,17 +215,17 @@
 
 	new = ap_push_array(sconf->conditionals);
 	new->name = fname;
 	new->regex = regex;
 	new->icase = icase;
 	new->preg = ap_pregcomp(cmd->pool, regex,
-			    (REG_EXTENDED | REG_NOSUB
-			    | (icase ? REG_ICASE : 0)));
+				(REG_EXTENDED | REG_NOSUB
+				 | (icase ? REG_ICASE : 0)));
 	if (new->preg == NULL) {
 	    return ap_pstrcat(cmd->pool, cmd->cmd->name,
-			    " regex could not be compiled.", NULL);
+			      " regex could not be compiled.", NULL);
 	}
 	new->features = ap_make_table(cmd->pool, 2);
 
 	if (!strcasecmp(fname, "remote_addr")) {
 	    new->special_type = SPECIAL_REMOTE_ADDR;
 	}
@@ -245,16 +246,17 @@
 	}
     }
     else {
 	new = &entries[i];
     }
 
-    for (;;) {
+    for ( ; ; ) {
 	feature = ap_getword_conf(cmd->pool, &args);
-	if(!*feature)
+	if (!*feature) {
 	    break;
+	}
         beenhere++;
 
         var = ap_getword(cmd->pool, &feature, '=');
         if (*feature) {
             ap_table_setn(new->features, var, feature);
         }
@@ -265,27 +267,28 @@
             ap_table_setn(new->features, var, "1");
         }
     }
 
     if (!beenhere) {
         return ap_pstrcat(cmd->pool, "Missing envariable expression for ",
-                        cmd->cmd->name, NULL);
+			  cmd->cmd->name, NULL);
     }
 
     return NULL;
 }
 
-static const char *add_setenvif(cmd_parms *cmd, void *mconfig, const char *args)
+static const char *add_setenvif(cmd_parms *cmd, void *mconfig,
+				const char *args)
 {
     char *fname;
 
     /* get header name */
     fname = ap_getword_conf(cmd->pool, &args);
     if (!*fname) {
         return ap_pstrcat(cmd->pool, "Missing header-field name for ",
-                        cmd->cmd->name, NULL);
+			  cmd->cmd->name, NULL);
     }
     return add_setenvif_core(cmd, mconfig, fname, args);
 }
 
 /*
  * This routine handles the BrowserMatch* directives.  It simply turns around
@@ -296,34 +299,36 @@
 {
     return add_setenvif_core(cmd, mconfig, "User-Agent", args);
 }
 
 static const command_rec setenvif_module_cmds[] =
 {
-    {"SetEnvIf", add_setenvif, NULL,
-     RSRC_CONF, RAW_ARGS, "A header-name, regex and a list of variables."},
-    {"SetEnvIfNoCase", add_setenvif, ICASE_MAGIC,
-     RSRC_CONF, RAW_ARGS, "a header-name, regex and a list of variables."},
-    {"BrowserMatch", add_browser, NULL,
-     RSRC_CONF, RAW_ARGS, "A browser regex and a list of variables."},
-    {"BrowserMatchNoCase", add_browser, ICASE_MAGIC,
-     RSRC_CONF, RAW_ARGS, "A browser regex and a list of variables."},
-    {NULL},
+    { "SetEnvIf", add_setenvif, NULL,
+      RSRC_CONF, RAW_ARGS, "A header-name, regex and a list of variables." },
+    { "SetEnvIfNoCase", add_setenvif, ICASE_MAGIC,
+      RSRC_CONF, RAW_ARGS, "a header-name, regex and a list of variables." },
+    { "BrowserMatch", add_browser, NULL,
+      RSRC_CONF, RAW_ARGS, "A browser regex and a list of variables." },
+    { "BrowserMatchNoCase", add_browser, ICASE_MAGIC,
+      RSRC_CONF, RAW_ARGS, "A browser regex and a list of variables." },
+    { NULL },
 };
 
 static int match_headers(request_rec *r)
 {
     server_rec *s = r->server;
-    sei_cfg_rec *sconf = (sei_cfg_rec *) ap_get_module_config(s->module_config,
-                                                           &setenvif_module);
-    sei_entry *entries = (sei_entry *) sconf->conditionals->elts;
+    sei_cfg_rec *sconf;
+    sei_entry *entries;
     table_entry *elts;
     const char *val;
     int i, j;
     char *last_name;
 
+    sconf = (sei_cfg_rec *) ap_get_module_config(s->module_config,
+						 &setenvif_module);
+    entries = (sei_entry *) sconf->conditionals->elts;
     last_name = NULL;
     val = NULL;
     for (i = 0; i < sconf->conditionals->nelts; ++i) {
         sei_entry *b = &entries[i];
 
 	/* Optimize the case where a bunch of directives in a row use the
@@ -336,13 +341,13 @@
 	    switch (b->special_type) {
 	    case SPECIAL_REMOTE_ADDR:
 		val = r->connection->remote_ip;
 		break;
 	    case SPECIAL_REMOTE_HOST:
 		val =  ap_get_remote_host(r->connection, r->per_dir_config,
-					    REMOTE_NAME);
+					  REMOTE_NAME);
 		break;
 	    case SPECIAL_REMOTE_USER:
 		val = r->connection->user;
 		break;
 	    case SPECIAL_REQUEST_URI:
 		val = r->uri;
@@ -353,18 +358,24 @@
 	    case SPECIAL_NOT:
 		val = ap_table_get(r->headers_in, b->name);
 		break;
 	    }
         }
 
-        if (!val) {
-            continue;
+	/*
+	 * A NULL value indicates that the header field or special entity
+	 * wasn't present or is undefined.  Represent that as an empty string
+	 * so that REs like "^$" will work and allow envariable setting
+	 * based on missing or empty field.
+	 */
+        if (val == NULL) {
+            val = "";
         }
 
         if (!regexec(b->preg, val, 0, NULL, 0)) {
-	    array_header *arr = table_elts(b->features);
+	    array_header *arr = ap_table_elts(b->features);
             elts = (table_entry *) arr->elts;
 
             for (j = 0; j < arr->nelts; ++j) {
                 if (!strcmp(elts[j].val, "!")) {
                     ap_table_unset(r->subprocess_env, elts[j].key);
                 }
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_speling.c apache_1.3.1/src/modules/standard/mod_speling.c
--- apache_1.3.0/src/modules/standard/mod_speling.c	1998-05-30 09:53:05.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_speling.c	1998-07-09 01:47:18.000000000 +0800
@@ -153,19 +153,19 @@
  * NOTE that is still allows only _one_ real "typo",
  * it does NOT try to correct multiple errors.
  */
 
 static sp_reason spdist(const char *s, const char *t)
 {
-    for (; tolower(*s) == tolower(*t); t++, s++)
+    for (; ap_tolower(*s) == ap_tolower(*t); t++, s++)
         if (*t == '\0')
             return SP_MISCAPITALIZED;   /* exact match (sans case) */
     if (*s) {
         if (*t) {
-            if (s[1] && t[1] && tolower(*s) == tolower(t[1]) &&
-              tolower(*t) == tolower(s[1]) && strcasecmp(s + 2, t + 2) == 0)
+            if (s[1] && t[1] && ap_tolower(*s) == ap_tolower(t[1]) &&
+              ap_tolower(*t) == ap_tolower(s[1]) && strcasecmp(s + 2, t + 2) == 0)
                 return SP_TRANSPOSITION;        /* transposition */
             if (strcasecmp(s + 1, t + 1) == 0)
                 return SP_SIMPLETYPO;   /* 1 char mismatch */
         }
         if (strcasecmp(s + 1, t) == 0)
             return SP_EXTRACHAR;        /* extra character */
@@ -319,13 +319,14 @@
         }
     }
     ap_pclosedir(r->pool, dirp);
 
     if (candidates->nelts != 0) {
         /* Wow... we found us a mispelling. Construct a fixed url */
-        char *nuri, *ref;
+        char *nuri;
+	const char *ref;
         misspelled_file *variant = (misspelled_file *) candidates->elts;
         int i;
 
         ref = ap_table_get(r->headers_in, "Referer");
 
         qsort((void *) candidates->elts, candidates->nelts,
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_status.c apache_1.3.1/src/modules/standard/mod_status.c
--- apache_1.3.0/src/modules/standard/mod_status.c	1998-05-06 11:24:20.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_status.c	1998-06-16 00:46:13.000000000 +0800
@@ -116,22 +116,22 @@
 #include "util_script.h"
 #include <time.h>
 #include "scoreboard.h"
 #include "http_log.h"
 
 #ifdef NEXT
-#if NX_CURRENT_COMPILER_RELEASE == 410
-#if __ARCHITECTURE__ == m68k
+#if (NX_CURRENT_COMPILER_RELEASE == 410)
+#ifdef m68k
 #define HZ 64
 #else
 #define HZ 100
 #endif
 #else
 #include <machine/param.h>
 #endif
-#endif
+#endif /* NEXT */
 
 #define STATUS_MAXLINE		64
 
 #define KBYTE			1024
 #define	MBYTE			1048576L
 #define	GBYTE			1073741824L
@@ -229,13 +229,13 @@
     unsigned short conn_lres;
     unsigned long bcount = 0;
     unsigned long kbcount = 0;
     long req_time;
 #if defined(NEXT)
     float tick = HZ;
-#elif !defined(WIN32)
+#elif !defined(NO_TIMES)
     float tick = sysconf(_SC_CLK_TCK);
 #endif
 #endif /* STATUS */
     int short_report = 0;
     int no_table_report = 0;
     short_score score_record;
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_unique_id.c apache_1.3.1/src/modules/standard/mod_unique_id.c
--- apache_1.3.0/src/modules/standard/mod_unique_id.c	1998-04-11 20:00:53.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_unique_id.c	1998-06-15 05:10:29.000000000 +0800
@@ -56,29 +56,30 @@
  */
 
 /*
  * mod_unique_id.c: generate a unique identifier for each request
  *
  * Original author: Dean Gaudet <dgaudet@arctic.org>
+ * UUencoding modified by: Alvaro Martinez Echevarria <alvaro@lander.es>
  */
 
 #include "httpd.h"
 #include "http_config.h"
 #include "http_log.h"
 #include "multithread.h"
 
 #ifdef MULTITHREAD
 #error sorry this module does not support multithreaded servers yet
 #endif
 
 typedef struct {
-    time_t stamp;
+    unsigned int stamp;
     unsigned int in_addr;
     unsigned int pid;
     unsigned short counter;
-}      unique_id_rec;
+} unique_id_rec;
 
 /* Comments:
  *
  * We want an identifier which is unique across all hits, everywhere.
  * "everywhere" includes multiple httpd instances on the same machine, or on
  * multiple machines.  Essentially "everywhere" should include all possible
@@ -122,41 +123,70 @@
  * field is still a time_t stamp.  By doing that, it is possible for a site to
  * have a "flag second" in which they stop all of their old-format servers,
  * wait one entire second, and then start all of their new-servers.  This
  * procedure will ensure that the new space of identifiers is completely unique
  * from the old space.  (Since the first four unencoded bytes always differ.)
  */
+/*
+ * Sun Jun  7 05:43:49 CEST 1998 -- Alvaro
+ * More comments:
+ * 1) The UUencoding prodecure is now done in a general way, avoiding the problems
+ * with sizes and paddings that can arise depending on the architecture. Now the
+ * offsets and sizes of the elements of the unique_id_rec structure are calculated
+ * in unique_id_global_init; and then used to duplicate the structure without the
+ * paddings that might exist. The multithreaded server fix should be now very easy:
+ * just add a new "tid" field to the unique_id_rec structure, and increase by one
+ * UNIQUE_ID_REC_MAX.
+ * 2) unique_id_rec.stamp has been changed from "time_t" to "unsigned int", because
+ * its size is 64bits on some platforms (linux/alpha), and this caused problems with
+ * htonl/ntohl. Well, this shouldn't be a problem till year 2106.
+ */
 
 static unsigned global_in_addr;
 
 static APACHE_TLS unique_id_rec cur_unique_id;
 
+/*
+ * Number of elements in the structure unique_id_rec.
+ */
+#define UNIQUE_ID_REC_MAX 4
+
+static unsigned short unique_id_rec_offset[UNIQUE_ID_REC_MAX],
+                      unique_id_rec_size[UNIQUE_ID_REC_MAX],
+                      unique_id_rec_total_size,
+                      unique_id_rec_size_uu;
+
 static void unique_id_global_init(server_rec *s, pool *p)
 {
 #ifndef MAXHOSTNAMELEN
 #define MAXHOSTNAMELEN 256
 #endif
     char str[MAXHOSTNAMELEN + 1];
     struct hostent *hent;
 #ifndef NO_GETTIMEOFDAY
     struct timeval tv;
 #endif
 
     /*
-     * First of all, verify some assumptions that have been made about the
-     * contents of unique_id_rec.  We do it this way because it isn't
-     * affected by trailing padding.
+     * Calculate the sizes and offsets in cur_unique_id.
      */
-    if (XtOffsetOf(unique_id_rec, counter) + sizeof(cur_unique_id.counter)
-        != 14) {
-        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ALERT, s,
-                    "mod_unique_id: sorry the size assumptions are wrong "
-                    "in mod_unique_id.c, please remove it from your server "
-                    "or fix the code!");
-        exit(1);
-    }
+    unique_id_rec_offset[0] = XtOffsetOf(unique_id_rec, stamp);
+    unique_id_rec_size[0] = sizeof(cur_unique_id.stamp);
+    unique_id_rec_offset[1] = XtOffsetOf(unique_id_rec, in_addr);
+    unique_id_rec_size[1] = sizeof(cur_unique_id.in_addr);
+    unique_id_rec_offset[2] = XtOffsetOf(unique_id_rec, pid);
+    unique_id_rec_size[2] = sizeof(cur_unique_id.pid);
+    unique_id_rec_offset[3] = XtOffsetOf(unique_id_rec, counter);
+    unique_id_rec_size[3] = sizeof(cur_unique_id.counter);
+    unique_id_rec_total_size = unique_id_rec_size[0] + unique_id_rec_size[1] +
+                               unique_id_rec_size[2] + unique_id_rec_size[3];
+
+    /*
+     * Calculate the size of the structure when uuencoded.
+     */
+    unique_id_rec_size_uu = (unique_id_rec_total_size*8+5)/6;
 
     /*
      * Now get the global in_addr.  Note that it is not sufficient to use one
      * of the addresses from the main_server, since those aren't as likely to
      * be unique as the physical address of the machine
      */
@@ -259,13 +289,13 @@
 
     /*
      * We must always use network ordering for these bytes, so that
      * identifiers are comparable between machines of different byte
      * orderings.  Note in_addr is already in network order.
      */
-    cur_unique_id.pid = htons(cur_unique_id.pid);
+    cur_unique_id.pid = htonl(cur_unique_id.pid);
     cur_unique_id.counter = htons(cur_unique_id.counter);
 }
 
 /* NOTE: This is *NOT* the same encoding used by uuencode ... the last two
  * characters should be + and /.  But those two characters have very special
  * meanings in URLs, and we want to make it easy to use identifiers in
@@ -278,56 +308,69 @@
     'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
     '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '@', '-',
 };
 
 static int gen_unique_id(request_rec *r)
 {
-    /* when we uuencode it will take 19 bytes plus \0 */
-    char str[19 + 1];
-    const unsigned char *x;
+    char *str;
+    /*
+     * Buffer padded with two final bytes, used to copy the unique_id_red
+     * structure without the internal paddings that it could have.
+     */
+    struct {
+	unique_id_rec foo;
+	unsigned char pad[2];
+    } paddedbuf;
+    unsigned char *x,*y;
     unsigned short counter;
-    char *e;
+    const char *e;
+    int i,j,k;
 
     /* copy the unique_id if this is an internal redirect (we're never
      * actually called for sub requests, so we don't need to test for
      * them) */
     if (r->prev && (e = ap_table_get(r->subprocess_env, "REDIRECT_UNIQUE_ID"))) {
 	ap_table_setn(r->subprocess_env, "UNIQUE_ID", e);
 	return DECLINED;
     }
 
-    cur_unique_id.stamp = htonl(r->request_time);
+    cur_unique_id.stamp = htonl((unsigned int)r->request_time);
 
-    /* do the uuencoding */
-    x = (const unsigned char *) &cur_unique_id;
-    str[0] = uuencoder[x[0] >> 2];
-    str[1] = uuencoder[((x[0] & 0x03) << 4) | ((x[1] & 0xf0) >> 4)];
-    str[2] = uuencoder[((x[1] & 0x0f) << 2) | ((x[2] & 0xc0) >> 6)];
-    str[3] = uuencoder[x[2] & 0x3f];
-    x += 3;
-    str[4] = uuencoder[x[0] >> 2];
-    str[5] = uuencoder[((x[0] & 0x03) << 4) | ((x[1] & 0xf0) >> 4)];
-    str[6] = uuencoder[((x[1] & 0x0f) << 2) | ((x[2] & 0xc0) >> 6)];
-    str[7] = uuencoder[x[2] & 0x3f];
-    x += 3;
-    str[8] = uuencoder[x[0] >> 2];
-    str[9] = uuencoder[((x[0] & 0x03) << 4) | ((x[1] & 0xf0) >> 4)];
-    str[10] = uuencoder[((x[1] & 0x0f) << 2) | ((x[2] & 0xc0) >> 6)];
-    str[11] = uuencoder[x[2] & 0x3f];
-    x += 3;
-    str[12] = uuencoder[x[0] >> 2];
-    str[13] = uuencoder[((x[0] & 0x03) << 4) | ((x[1] & 0xf0) >> 4)];
-    str[14] = uuencoder[((x[1] & 0x0f) << 2) | ((x[2] & 0xc0) >> 6)];
-    str[15] = uuencoder[x[2] & 0x3f];
-    x += 3;
-    str[16] = uuencoder[x[0] >> 2];
-    str[17] = uuencoder[((x[0] & 0x03) << 4) | ((x[1] & 0xf0) >> 4)];
-    str[18] = uuencoder[((x[1] & 0x0f) << 2) | ((0 & 0xc0) >> 6)];
-    str[19] = '\0';
+    /* we'll use a temporal buffer to avoid uuencoding the possible internal
+     * paddings of the original structure */
+    x = (unsigned char *) &paddedbuf;
+    y = (unsigned char *) &cur_unique_id;
+    k = 0;
+    for (i = 0; i < UNIQUE_ID_REC_MAX; i++) {
+        y = ((unsigned char *) &cur_unique_id) + unique_id_rec_offset[i];
+        for (j = 0; j < unique_id_rec_size[i]; j++, k++) {
+            x[k] = y[j];
+        }
+    }
+    /*
+     * We reset two more bytes just in case padding is needed for the uuencoding.
+     */
+    x[k++] = '\0';
+    x[k++] = '\0';
+    
+    /* alloc str and do the uuencoding */
+    str = (char *)ap_palloc(r->pool, unique_id_rec_size_uu + 1);
+    k = 0;
+    for (i = 0; i < unique_id_rec_total_size; i += 3) {
+        y = x + i;
+        str[k++] = uuencoder[y[0] >> 2];
+        str[k++] = uuencoder[((y[0] & 0x03) << 4) | ((y[1] & 0xf0) >> 4)];
+        if (k == unique_id_rec_size_uu) break;
+        str[k++] = uuencoder[((y[1] & 0x0f) << 2) | ((y[2] & 0xc0) >> 6)];
+        if (k == unique_id_rec_size_uu) break;
+        str[k++] = uuencoder[y[2] & 0x3f];
+    }
+    str[k++] = '\0';
 
-    ap_table_setn(r->subprocess_env, "UNIQUE_ID", ap_pstrdup(r->pool, str));
+    /* set the environment variable */
+    ap_table_setn(r->subprocess_env, "UNIQUE_ID", str);
 
     /* and increment the identifier for the next call */
     counter = ntohs(cur_unique_id.counter) + 1;
     cur_unique_id.counter = htons(counter);
 
     return DECLINED;
diff -BEr -U 6 apache_1.3.0/src/modules/standard/mod_usertrack.c apache_1.3.1/src/modules/standard/mod_usertrack.c
--- apache_1.3.0/src/modules/standard/mod_usertrack.c	1998-04-11 20:00:53.000000000 +0800
+++ apache_1.3.1/src/modules/standard/mod_usertrack.c	1998-07-09 01:47:19.000000000 +0800
@@ -134,42 +134,38 @@
     struct timeval tv;
     struct timezone tz = {0, 0};
 #endif
     /* 1024 == hardcoded constant */
     char cookiebuf[1024];
     char *new_cookie;
-    char *dot;
     const char *rname = ap_get_remote_host(r->connection, r->per_dir_config,
 					REMOTE_NAME);
 
-    if ((dot = strchr(rname, '.')))
-        *dot = '\0';            /* First bit of hostname */
-
 #if defined(NO_GETTIMEOFDAY) && !defined(NO_TIMES)
 /* We lack gettimeofday(), so we must use time() to obtain the epoch
    seconds, and then times() to obtain CPU clock ticks (milliseconds).
    Combine this together to obtain a hopefully unique cookie ID. */
 
     mpe_times = times(&mpe_tms);
 
-    ap_snprintf(cookiebuf, sizeof(cookiebuf), "%s%d%ld%ld", rname, (int) getpid(),
+    ap_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%d%ld%ld", rname, (int) getpid(),
                 (long) r->request_time, (long) mpe_tms.tms_utime);
 #elif defined(WIN32)
     /*
      * We lack gettimeofday() and we lack times(). So we'll use a combination
      * of time() and GetTickCount(), which returns milliseconds since Windows
      * was started. It should be relatively unique.
      */
 
-    ap_snprintf(cookiebuf, sizeof(cookiebuf), "%s%d%ld%ld", rname, (int) getpid(),
+    ap_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%d%ld%ld", rname, (int) getpid(),
                 (long) r->request_time, (long) GetTickCount());
 
 #else
     gettimeofday(&tv, &tz);
 
-    ap_snprintf(cookiebuf, sizeof(cookiebuf), "%s%d%ld%d", rname, (int) getpid(),
+    ap_snprintf(cookiebuf, sizeof(cookiebuf), "%s.%d%ld%d", rname, (int) getpid(),
                 (long) tv.tv_sec, (int) tv.tv_usec / 1000);
 #endif
 
     if (cls->expires) {
         struct tm *tms;
         time_t when = r->request_time + cls->expires;
@@ -203,13 +199,13 @@
 }
 
 static int spot_cookie(request_rec *r)
 {
     int *enable = (int *) ap_get_module_config(r->per_dir_config,
                                             &usertrack_module);
-    char *cookie;
+    const char *cookie;
     char *value;
 
     if (!*enable)
         return DECLINED;
 
     if ((cookie = ap_table_get(r->headers_in, "Cookie")))
@@ -258,13 +254,13 @@
                                               &usertrack_module);
     time_t factor, modifier = 0;
     time_t num = 0;
     char *word;
 
     /* The simple case first - all numbers (we assume) */
-    if (isdigit(arg[0]) && isdigit(arg[strlen(arg) - 1])) {
+    if (ap_isdigit(arg[0]) && ap_isdigit(arg[strlen(arg) - 1])) {
         cls->expires = atol(arg);
         return NULL;
     }
 
     /*
      * The harder case - stolen from mod_expires 
@@ -277,13 +273,13 @@
         word = ap_getword_conf(parms->pool, &arg);
     };
 
     /* {<num> <type>}* */
     while (word[0]) {
         /* <num> */
-	if (isdigit(word[0]))
+	if (ap_isdigit(word[0]))
             num = atoi(word);
         else
             return "bad expires code, numeric value expected.";
 
         /* <type> */
         word = ap_getword_conf(parms->pool, &arg);
Only in apache_1.3.0/src: modules.c
diff -BEr -U 6 apache_1.3.0/src/os/bs2000/bs2login.c apache_1.3.1/src/os/bs2000/bs2login.c
--- apache_1.3.0/src/os/bs2000/bs2login.c	1998-05-05 06:18:24.000000000 +0800
+++ apache_1.3.1/src/os/bs2000/bs2login.c	1998-07-09 01:47:24.000000000 +0800
@@ -115,13 +115,13 @@
     memset (&lcl_data, '\0', sizeof lcl_data);
 
     /* BS2000 requires the user name to be in upper case for authentication */
     ap_snprintf(lcl_data.username, sizeof lcl_data.username,
 		"%s", user_name);
     for (cp = lcl_data.username; *cp; ++cp) {
-	*cp = toupper(*cp);
+	*cp = ap_toupper(*cp);
     }
 
     if (bs2000_authfile == NULL) {
 	ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, server,
 		     "Use the 'BS2000AuthFile <passwdfile>' directive to specify "
 		     "an authorization file for User %s",
diff -BEr -U 6 apache_1.3.0/src/os/bs2000/ebcdic.c apache_1.3.1/src/os/bs2000/ebcdic.c
--- apache_1.3.0/src/os/bs2000/ebcdic.c	1998-05-13 23:31:01.000000000 +0800
+++ apache_1.3.1/src/os/bs2000/ebcdic.c	1998-07-13 19:32:47.000000000 +0800
@@ -54,13 +54,13 @@
  * project, please see <http://www.apache.org/>.
  *
  */
 
 
 #ifdef CHARSET_EBCDIC
-#include "conf.h"
+#include "ap_config.h"
 #include "ebcdic.h"
 /*
 	   Initial Port for  Apache-1.3 by <Martin.Kraemer@Mch.SNI.De>
 
 "BS2000 OSD" is a POSIX on a main frame.
 It is made by Siemens Nixdorf AG, Germany.
diff -BEr -U 6 apache_1.3.0/src/os/bs2000/os.h apache_1.3.1/src/os/bs2000/os.h
--- apache_1.3.0/src/os/bs2000/os.h	1998-05-07 20:24:27.000000000 +0800
+++ apache_1.3.1/src/os/bs2000/os.h	1998-07-13 19:32:47.000000000 +0800
@@ -6,13 +6,13 @@
 /*
  * This file in included in all Apache source code. It contains definitions
  * of facilities available on _this_ operating system (HAVE_* macros),
  * and prototypes of OS specific functions defined in os.c or os-inline.c
  */
 
-#include "conf.h"
+#include "ap_config.h"
 
 #if !defined(INLINE) && defined(USE_GNU_INLINE)
 /* Compiler supports inline, so include the inlineable functions as
  * part of the header
  */
 #define INLINE extern ap_inline
diff -BEr -U 6 apache_1.3.0/src/os/bs2000/os-inline.c apache_1.3.1/src/os/bs2000/os-inline.c
--- apache_1.3.0/src/os/bs2000/os-inline.c	1998-04-14 02:05:17.000000000 +0800
+++ apache_1.3.1/src/os/bs2000/os-inline.c	1998-07-13 19:32:47.000000000 +0800
@@ -18,13 +18,13 @@
  */
 
 #ifndef INLINE
 #define INLINE
 
 /* Anything required only when compiling */
-#include "conf.h"
+#include "ap_config.h"
 
 #endif
 
 INLINE int ap_os_is_path_absolute(const char *file)
 {
   return (file && file[0] == '/' ? 1 : 0);
diff -BEr -U 6 apache_1.3.0/src/os/emx/os-inline.c apache_1.3.1/src/os/emx/os-inline.c
--- apache_1.3.0/src/os/emx/os-inline.c	1998-04-14 02:05:18.000000000 +0800
+++ apache_1.3.1/src/os/emx/os-inline.c	1998-07-13 19:32:48.000000000 +0800
@@ -18,13 +18,13 @@
  */
 
 #ifndef INLINE
 #define INLINE
 
 /* Anything required only when compiling */
-#include "conf.h"
+#include "ap_config.h"
 
 #endif
 
 INLINE int ap_os_is_path_absolute(const char *file)
 {
   /* For now, just do the same check that http_request.c and mod_alias.c
Only in apache_1.3.0/src/os/unix: libos.a
Only in apache_1.3.0/src/os/unix: Makefile
diff -BEr -U 6 apache_1.3.0/src/os/unix/Makefile.tmpl apache_1.3.1/src/os/unix/Makefile.tmpl
--- apache_1.3.0/src/os/unix/Makefile.tmpl	1998-05-10 21:04:38.000000000 +0800
+++ apache_1.3.1/src/os/unix/Makefile.tmpl	1998-07-13 19:32:49.000000000 +0800
@@ -36,8 +36,12 @@
 	    && rm Makefile.new
 
 $(OBJS): Makefile
 
 # DO NOT REMOVE
 os-aix-dso.o: os-aix-dso.c
-os-inline.o: os-inline.c $(INCDIR)/conf.h $(OSDIR)/os.h
-os.o: os.c $(INCDIR)/conf.h $(OSDIR)/os.h os.h
+os-inline.o: os-inline.c $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
+ $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h
+os.o: os.c $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h \
+ os.h
diff -BEr -U 6 apache_1.3.0/src/os/unix/os.c apache_1.3.1/src/os/unix/os.c
--- apache_1.3.0/src/os/unix/os.c	1998-04-28 16:42:11.000000000 +0800
+++ apache_1.3.1/src/os/unix/os.c	1998-07-13 19:32:49.000000000 +0800
@@ -1,12 +1,12 @@
 /*
  * This file will include OS specific functions which are not inlineable.
  * Any inlineable functions should be defined in os-inline.c instead.
  */
 
-#include "conf.h"
+#include "ap_config.h"
 #include "os.h"
 
 
 /* some linkers complain unless there's at least one function in each
  * .o file... and extra prototype is for gcc -Wmissing-prototypes
  */
@@ -32,15 +32,15 @@
     shl_t handle;
     handle = shl_load(path, BIND_IMMEDIATE|BIND_VERBOSE|BIND_NOSTART, 0L);
     return (void *)handle;
 #else
 #if defined(OSF1) ||\
     (defined(__FreeBSD_version) && (__FreeBSD_version >= 220000))
-    return dlopen((char *)path, RTLD_NOW);
+    return dlopen((char *)path, RTLD_NOW | RTLD_GLOBAL);
 #else
-    return dlopen(path, RTLD_NOW);
+    return dlopen(path, RTLD_NOW | RTLD_GLOBAL);
 #endif
 #endif
 }
 
 void ap_os_dso_unload(void *handle) 
 {
diff -BEr -U 6 apache_1.3.0/src/os/unix/os.h apache_1.3.1/src/os/unix/os.h
--- apache_1.3.0/src/os/unix/os.h	1998-05-14 09:22:52.000000000 +0800
+++ apache_1.3.1/src/os/unix/os.h	1998-07-13 19:32:49.000000000 +0800
@@ -55,12 +55,14 @@
  *
  */
 
 #ifndef APACHE_OS_H
 #define APACHE_OS_H
 
+#include "ap_config.h"
+
 #define PLATFORM "Unix"
 
 /*
  * This file in included in all Apache source code. It contains definitions
  * of facilities available on _this_ operating system (HAVE_* macros),
  * and prototypes of OS specific functions defined in os.c or os-inline.c
@@ -84,23 +86,12 @@
 /*
  *  Abstraction layer for loading
  *  Apache modules under run-time via 
  *  dynamic shared object (DSO) mechanism
  */
 
-#if defined(HPUX) || defined(HPUX10)
-#define HAVE_DL_H 1
-#endif
-
-#if defined(LINUX) || defined(__FreeBSD__) ||\
-    defined(__OpenBSD__) || defined(__NetBSD__) || \
-    defined(SOLARIS2) || defined(__bsdi__) || \
-    defined(IRIX) || defined(SVR4) || defined(OSF1)
-#define HAVE_DLFCN_H 1
-#endif
-
 #ifdef HAVE_DL_H
 #include <dl.h>
 #endif
 
 #ifdef HAVE_DLFCN_H
 #include <dlfcn.h>
@@ -116,12 +107,16 @@
  * system doesn't support RTLD_NOW.
  */
 #ifndef RTLD_NOW
 #define RTLD_NOW 1
 #endif
 
+#ifndef RTLD_GLOBAL
+#define RTLD_GLOBAL 0
+#endif
+
 #if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
 #define DLSYM_NEEDS_UNDERSCORE
 #endif
 
 #define     ap_os_dso_handle_t  void *
 void *      ap_os_dso_load(const char *);
diff -BEr -U 6 apache_1.3.0/src/os/unix/os-inline.c apache_1.3.1/src/os/unix/os-inline.c
--- apache_1.3.0/src/os/unix/os-inline.c	1998-04-14 02:05:19.000000000 +0800
+++ apache_1.3.1/src/os/unix/os-inline.c	1998-07-13 19:32:49.000000000 +0800
@@ -18,13 +18,13 @@
  */
 
 #ifndef INLINE
 #define INLINE
 
 /* Anything required only when compiling */
-#include "conf.h"
+#include "ap_config.h"
 
 #endif
 
 INLINE int ap_os_is_path_absolute(const char *file)
 {
   return file[0] == '/';
Only in apache_1.3.0/src/os/unix: os-inline.o
Only in apache_1.3.0/src/os/unix: os.o
diff -BEr -U 6 apache_1.3.0/src/os/win32/installer/apache.iwz apache_1.3.1/src/os/win32/installer/apache.iwz
--- apache_1.3.0/src/os/win32/installer/apache.iwz	1998-05-30 02:21:09.000000000 +0800
+++ apache_1.3.1/src/os/win32/installer/apache.iwz	1998-07-19 06:57:34.000000000 +0800
@@ -43,15 +43,15 @@
 LangDir=LANG\ENG\
 
 [VisualDesign]
 AppName=Apache
 AppExe=
 AppExeFile=
-Version=1.3b7
+Version=1.3.1
 Company=Apache Group
-Title=Apache Web Server 1.3b7
+Title=Apache Web Server 1.3.1
 TitleType=1
 BackgrndBmp=
 BackgrndAlign=4
 Backgrnd=1
 BackgrndColor=10
 Uninstall=1
@@ -96,13 +96,13 @@
 Component6Name=Required Directories
 Component6Description=
 Component6GroupList=26 28 29 30 
 
 [Groups]
 Groups=30
-Group1Size=321233
+Group1Size=314310
 Group1Files=10
 Group1Name=Program Executables
 Group1Dir=<INSTALLDIR>
 Group1Update=0
 Group1TargetOS=-1
 Group1File1=C:\Apache\Apache.exe
@@ -112,13 +112,13 @@
 Group1File5=C:\Apache\CHANGES
 Group1File6=C:\Apache\KEYS
 Group1File7=C:\Apache\LICENSE
 Group1File8=C:\Apache\README
 Group1File9=C:\Apache\README.NT
 Group1File10=C:\apache\Makefile.tmpl
-Group2Size=132608
+Group2Size=133120
 Group2Files=10
 Group2Name=Additional Modules
 Group2Dir=<INSTALLDIR>\modules
 Group2Update=0
 Group2TargetOS=-1
 Group2File1=C:\Apache\modules\ApacheModuleDigest.dll
@@ -128,33 +128,33 @@
 Group2File5=C:\Apache\modules\ApacheModuleHeaders.dll
 Group2File6=C:\Apache\modules\ApacheModuleProxy.dll
 Group2File7=C:\Apache\modules\ApacheModuleSpeling.dll
 Group2File8=C:\Apache\modules\ApacheModuleStatus.dll
 Group2File9=C:\Apache\modules\ApacheModuleUserTrack.dll
 Group2File10=C:\apache\modules\ApacheModuleRewrite.dll
-Group3Size=35900
+Group3Size=36285
 Group3Files=6
 Group3Name=Configuration Files
 Group3Dir=<INSTALLDIR>\.tmp
 Group3Update=0
 Group3TargetOS=-1
 Group3File1=C:\Apache\conf\httpd.conf-dist-win
 Group3File2=C:\Apache\conf\access.conf-dist-win
 Group3File3=C:\Apache\conf\magic
 Group3File4=C:\Apache\conf\mime.types
 Group3File5=C:\Apache\conf\srm.conf-dist-win
 Group3File6=C:\apache\conf\highperformance.conf-dist
-Group4Size=4004
+Group4Size=3999
 Group4Files=2
 Group4Name=Initial Document Root Files
 Group4Dir=<INSTALLDIR>\.tmp
-Group4Update=0
+Group4Update=1
 Group4TargetOS=-1
-Group4File1=C:\Apache\htdocs\apache_pb.gif
-Group4File2=C:\Apache\htdocs\index.html
-Group5Size=241011
+Group4File1=C:\Apache\htdocs\index.html
+Group4File2=C:\apache\htdocs\apache_pb.gif
+Group5Size=249224
 Group5Files=31
 Group5Name=Manual
 Group5Dir=<INSTALLDIR>\htdocs\manual
 Group5Update=0
 Group5TargetOS=-1
 Group5File1=C:\Apache\htdocs\manual\bind.html
@@ -185,13 +185,13 @@
 Group5File26=C:\Apache\htdocs\manual\suexec.html
 Group5File27=C:\Apache\htdocs\manual\unixware.html
 Group5File28=C:\Apache\htdocs\manual\upgrading_to_1_3.html
 Group5File29=C:\Apache\htdocs\manual\windows.html
 Group5File30=C:\apache\htdocs\manual\ebcdic.html
 Group5File31=C:\apache\htdocs\manual\dso.html
-Group6Size=42700
+Group6Size=42478
 Group6Files=8
 Group6Name=images
 Group6Dir=[Manual]\images
 Group6Update=0
 Group6TargetOS=-1
 Group6File1=C:\Apache\htdocs\manual\images\custom_errordocs.gif
@@ -199,13 +199,13 @@
 Group6File3=C:\Apache\htdocs\manual\images\index.gif
 Group6File4=C:\Apache\htdocs\manual\images\sub.gif
 Group6File5=C:\apache\htdocs\manual\images\mod_rewrite_fig1.fig
 Group6File6=C:\apache\htdocs\manual\images\mod_rewrite_fig1.gif
 Group6File7=C:\apache\htdocs\manual\images\mod_rewrite_fig2.fig
 Group6File8=C:\apache\htdocs\manual\images\mod_rewrite_fig2.gif
-Group7Size=307167
+Group7Size=314221
 Group7Files=21
 Group7Name=misc
 Group7Dir=[Manual]\misc
 Group7Update=0
 Group7TargetOS=-1
 Group7File1=C:\Apache\htdocs\manual\misc\API.html
@@ -226,13 +226,13 @@
 Group7File16=C:\Apache\htdocs\manual\misc\perf-hp.html
 Group7File17=C:\Apache\htdocs\manual\misc\perf-tuning.html
 Group7File18=C:\Apache\htdocs\manual\misc\perf.html
 Group7File19=C:\Apache\htdocs\manual\misc\security_tips.html
 Group7File20=C:\Apache\htdocs\manual\misc\vif-info.html
 Group7File21=C:\Apache\htdocs\manual\misc\windoz_keepalive.html
-Group8Size=505646
+Group8Size=517858
 Group8Files=48
 Group8Name=mod
 Group8Dir=[Manual]\mod
 Group8Update=0
 Group8TargetOS=-1
 Group8File1=C:\Apache\htdocs\manual\mod\core.html
@@ -280,13 +280,13 @@
 Group8File43=C:\Apache\htdocs\manual\mod\mod_speling.html
 Group8File44=C:\Apache\htdocs\manual\mod\mod_status.html
 Group8File45=C:\Apache\htdocs\manual\mod\mod_unique_id.html
 Group8File46=C:\Apache\htdocs\manual\mod\mod_userdir.html
 Group8File47=C:\Apache\htdocs\manual\mod\mod_usertrack.html
 Group8File48=C:\apache\htdocs\manual\mod\mod_mmap_static.html
-Group9Size=96846
+Group9Size=99426
 Group9Files=12
 Group9Name=vhosts
 Group9Dir=[Manual]\vhosts
 Group9Update=0
 Group9TargetOS=-1
 Group9File1=C:\Apache\htdocs\manual\vhosts\details.html
@@ -298,13 +298,13 @@
 Group9File7=C:\Apache\htdocs\manual\vhosts\host.html
 Group9File8=C:\Apache\htdocs\manual\vhosts\index.html
 Group9File9=C:\Apache\htdocs\manual\vhosts\ip-based.html
 Group9File10=C:\Apache\htdocs\manual\vhosts\name-based.html
 Group9File11=C:\Apache\htdocs\manual\vhosts\vhosts-in-depth.html
 Group9File12=C:\Apache\htdocs\manual\vhosts\virtual-host.html
-Group10Size=408744
+Group10Size=413062
 Group10Files=16
 Group10Name=src
 Group10Dir=<INSTALLDIR>\src
 Group10Update=0
 Group10TargetOS=-1
 Group10File1=C:\Apache\src\.gdbinit
@@ -335,13 +335,13 @@
 Group11File4=C:\Apache\src\ap\ap_execve.c
 Group11File5=C:\Apache\src\ap\ap_signal.c
 Group11File6=C:\Apache\src\ap\ap_slack.c
 Group11File7=C:\Apache\src\ap\ap_snprintf.c
 Group11File8=C:\Apache\src\ap\ap_strings.c
 Group11File9=C:\Apache\src\ap\Makefile.tmpl
-Group12Size=222033
+Group12Size=222241
 Group12Files=25
 Group12Name=include
 Group12Dir=[src]\include
 Group12Update=0
 Group12TargetOS=-1
 Group12File1=C:\Apache\src\include\alloc.h
@@ -366,13 +366,13 @@
 Group12File20=C:\Apache\src\include\scoreboard.h
 Group12File21=C:\Apache\src\include\util_date.h
 Group12File22=C:\Apache\src\include\util_md5.h
 Group12File23=C:\Apache\src\include\util_script.h
 Group12File24=C:\apache\src\include\compat.h
 Group12File25=C:\apache\src\include\util_uri.h
-Group13Size=725383
+Group13Size=728100
 Group13Files=25
 Group13Name=main
 Group13Dir=[src]\main
 Group13Update=0
 Group13TargetOS=-1
 Group13File1=C:\apache\src\main\.indent.pro
@@ -397,13 +397,13 @@
 Group13File20=C:\apache\src\main\rfc1413.c
 Group13File21=C:\apache\src\main\util.c
 Group13File22=C:\apache\src\main\util_date.c
 Group13File23=C:\apache\src\main\util_md5.c
 Group13File24=C:\apache\src\main\util_script.c
 Group13File25=C:\apache\src\main\util_uri.c
-Group14Size=922
+Group14Size=895
 Group14Files=1
 Group14Name=modules
 Group14Dir=[src]\modules
 Group14Update=0
 Group14TargetOS=-1
 Group14File1=C:\Apache\src\modules\README
@@ -428,13 +428,13 @@
 Group17Files=1
 Group17Name=extra
 Group17Dir=[modules]\extra
 Group17Update=0
 Group17TargetOS=-1
 Group17File1=C:\Apache\src\modules\extra\Makefile.tmpl
-Group18Size=181532
+Group18Size=181989
 Group18Files=12
 Group18Name=proxy
 Group18Dir=[modules]\proxy
 Group18Update=0
 Group18TargetOS=-1
 Group18File1=C:\apache\src\modules\proxy\.indent.pro
@@ -446,13 +446,13 @@
 Group18File7=C:\apache\src\modules\proxy\mod_proxy.h
 Group18File8=C:\apache\src\modules\proxy\proxy_cache.c
 Group18File9=C:\apache\src\modules\proxy\proxy_connect.c
 Group18File10=C:\apache\src\modules\proxy\proxy_ftp.c
 Group18File11=C:\apache\src\modules\proxy\proxy_http.c
 Group18File12=C:\apache\src\modules\proxy\proxy_util.c
-Group19Size=809249
+Group19Size=810699
 Group19Files=37
 Group19Name=standard
 Group19Dir=[modules]\standard
 Group19Update=0
 Group19TargetOS=-1
 Group19File1=C:\apache\src\modules\standard\.indent.pro
@@ -520,13 +520,13 @@
 Group20File20=C:\Apache\src\regex\regexec.c
 Group20File21=C:\Apache\src\regex\regfree.c
 Group20File22=C:\Apache\src\regex\split.c
 Group20File23=C:\Apache\src\regex\tests
 Group20File24=C:\Apache\src\regex\utils.h
 Group20File25=C:\Apache\src\regex\WHATSNEW
-Group21Size=168611
+Group21Size=168805
 Group21Files=26
 Group21Name=support
 Group21Dir=[src]\support
 Group21Update=0
 Group21TargetOS=-1
 Group21File1=C:\apache\src\support\.indent.pro
@@ -558,13 +558,13 @@
 Group22Size=0
 Group22Files=0
 Group22Name=os
 Group22Dir=[src]\os
 Group22Update=0
 Group22TargetOS=-1
-Group23Size=194596
+Group23Size=194599
 Group23Files=43
 Group23Name=win32
 Group23Dir=[os]\win32
 Group23Update=0
 Group23TargetOS=-1
 Group23File1=C:\apache\src\os\win32\ApacheModuleAuthAnon.dsp
@@ -627,17 +627,17 @@
 Group26Size=0
 Group26Files=0
 Group26Name=logs
 Group26Dir=<INSTALLDIR>\logs
 Group26Update=0
 Group26TargetOS=-1
-Group27Size=36913
+Group27Size=37074
 Group27Files=76
 Group27Name=icons
 Group27Dir=<INSTALLDIR>\icons
-Group27Update=0
+Group27Update=1
 Group27TargetOS=-1
 Group27File1=C:\apache\icons\a.gif
 Group27File2=C:\apache\icons\alert.black.gif
 Group27File3=C:\apache\icons\alert.red.gif
 Group27File4=C:\apache\icons\apache_pb.gif
 Group27File5=C:\apache\icons\back.gif
@@ -715,18 +715,19 @@
 Group28Size=0
 Group28Files=0
 Group28Name=conf
 Group28Dir=<INSTALLDIR>\conf
 Group28Update=0
 Group28TargetOS=-1
-Group29Size=0
-Group29Files=0
+Group29Size=2326
+Group29Files=1
 Group29Name=htdocs
 Group29Dir=<INSTALLDIR>\htdocs
 Group29Update=0
 Group29TargetOS=-1
+Group29File1=C:\apache\htdocs\apache_pb.gif
 Group30Size=0
 Group30Files=0
 Group30Name=cgi-bin
 Group30Dir=<INSTALLDIR>\cgi-bin
 Group30Update=0
 Group30TargetOS=-1
@@ -791,13 +792,13 @@
 Reg8Vals=1
 Reg9Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group\Apache
 Reg9Val1Type=0
 Reg9Val1Name=(Default)
 Reg9Val1Data=(value not set)
 Reg9Vals=1
-Reg10Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group\Apache\1.3 beta
+Reg10Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group\Apache\1.3.1
 Reg10Val1Type=0
 Reg10Val1Name=(Default)
 Reg10Val1Data=(value not set)
 Reg10Val2Type=0
 Reg10Val2Name=ServerRoot
 Reg10Val2Data=<INSTALLDIR>
@@ -805,14 +806,14 @@
 Regs=10
 
 [Registry]
 Reg1Path=HKEY_LOCAL_MACHINE\SOFTWARE
 Reg2Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group
 Reg3Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group\Apache
-Reg4Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group\Apache\1.3 beta
-Reg5Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group\Apache\1.3 beta
+Reg4Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group\Apache\1.3.1
+Reg5Path=HKEY_LOCAL_MACHINE\SOFTWARE\Apache Group\Apache\1.3.1
 Reg5ValName=ServerRoot
 Reg5ValType=0
 Reg5ValData=<INSTALLDIR>
 Regs=5
 
 [Icons]
diff -BEr -U 6 apache_1.3.0/src/os/win32/mod_isapi.c apache_1.3.1/src/os/win32/mod_isapi.c
--- apache_1.3.0/src/os/win32/mod_isapi.c	1998-05-09 23:09:31.000000000 +0800
+++ apache_1.3.1/src/os/win32/mod_isapi.c	1998-07-09 01:47:24.000000000 +0800
@@ -294,13 +294,13 @@
 #pragma optimize("",on)
 
 BOOL WINAPI GetServerVariable (HCONN hConn, LPSTR lpszVariableName,
 			       LPVOID lpvBuffer, LPDWORD lpdwSizeofBuffer) {
     request_rec *r = ((isapi_cid *)hConn)->r;
     table *e = r->subprocess_env;
-    char *result;
+    const char *result;
     
     /* Mostly, we just grab it from the environment, but there are
      * a couple of special cases
      */
 
     if (!strcasecmp(lpszVariableName, "UNMAPPED_REMOTE_USER")) {
@@ -456,27 +456,29 @@
 		ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
 			    "ISA sent invalid headers", r->filename);
 		return FALSE;
 	    }
 
 	    *value++ = '\0';
-	    while (*value && isspace(*value)) ++value;
+	    while (*value && ap_isspace(*value)) ++value;
 
 	    /* Check all the special-case headers. Similar to what
 	     * scan_script_header() does (see that function for
 	     * more detail)
 	     */
 
 	    if (!strcasecmp(data, "Content-Type")) {
+		char *tmp;
 		/* Nuke trailing whitespace */
 		
 		char *endp = value + strlen(value) - 1;
-		while (endp > value && isspace(*endp)) *endp-- = '\0';
+		while (endp > value && ap_isspace(*endp)) *endp-- = '\0';
             
-		r->content_type = ap_pstrdup (r->pool, value);
-		ap_str_tolower(r->content_type);
+		tmp = ap_pstrdup (r->pool, value);
+		ap_str_tolower(tmp);
+		r->content_type = tmp;
 	    }
 	    else if (!strcasecmp(data, "Content-Length")) {
 		ap_table_set(r->headers_out, data, value);
 	    }
 	    else if (!strcasecmp(data, "Transfer-Encoding")) {
 		ap_table_set(r->headers_out, data, value);
diff -BEr -U 6 apache_1.3.0/src/os/win32/multithread.c apache_1.3.1/src/os/win32/multithread.c
--- apache_1.3.0/src/os/win32/multithread.c	1998-04-11 20:01:06.000000000 +0800
+++ apache_1.3.1/src/os/win32/multithread.c	1998-07-13 19:32:51.000000000 +0800
@@ -1,8 +1,8 @@
 
-#include "conf.h"
+#include "ap_config.h"
 #include "multithread.h"
 
 #ifdef WIN32
 #include <process.h>
 #include <assert.h>
 
diff -BEr -U 6 apache_1.3.0/src/os/win32/os.h apache_1.3.1/src/os/win32/os.h
--- apache_1.3.0/src/os/win32/os.h	1998-05-07 20:24:31.000000000 +0800
+++ apache_1.3.1/src/os/win32/os.h	1998-07-13 19:32:51.000000000 +0800
@@ -19,19 +19,19 @@
 
 #define STATUS
 #define WIN32_LEAN_AND_MEAN
 #ifndef STRICT
  #define STRICT
 #endif
-#define NO_UNISTD_H
+#define CASE_BLIND_FILESYSTEM
 #define NO_WRITEV
 #define NO_SETSID
 #define NO_USE_SIGACTION
 #define NO_TIMES
 #define NO_GETTIMEOFDAY
-//#define NEED_PROCESS_H    although we do, this is specially handled in conf.h
+//#define NEED_PROCESS_H    although we do, this is specially handled in ap_config.h
 #define USE_LONGJMP
 #define HAVE_MMAP
 #define USE_MMAP_SCOREBOARD
 #define MULTITHREAD
 #define HAVE_CANONICAL_FILENAME
 typedef int uid_t;
diff -BEr -U 6 apache_1.3.0/src/os/win32/registry.c apache_1.3.1/src/os/win32/registry.c
--- apache_1.3.0/src/os/win32/registry.c	1998-06-02 06:18:44.000000000 +0800
+++ apache_1.3.1/src/os/win32/registry.c	1998-07-19 06:57:31.000000000 +0800
@@ -25,13 +25,13 @@
  * VERSION will be the same across all beta releases for a particular
  * major release, but will change when the final release is made.
  */
 
 #define VENDOR   "Apache Group"
 #define SOFTWARE "Apache"
-#define VERSION  "1.3.0"
+#define VERSION  "1.3.1"
 
 #define REGKEY "SOFTWARE\\" VENDOR "\\" SOFTWARE "\\" VERSION
 
 /*
  * The Windows API registry key functions don't set the last error
  * value (the windows equivalent of errno). So we need to set it
diff -BEr -U 6 apache_1.3.0/src/os/win32/util_win32.c apache_1.3.1/src/os/win32/util_win32.c
--- apache_1.3.0/src/os/win32/util_win32.c	1998-05-09 23:00:50.000000000 +0800
+++ apache_1.3.1/src/os/win32/util_win32.c	1998-07-13 15:06:16.000000000 +0800
@@ -1,20 +1,28 @@
 #include <windows.h>
 #include <sys/stat.h>
 #include <stdarg.h>
 
 #include "httpd.h"
+#include "http_log.h"
 
-static void sub_canonical_filename(char *szCanon, unsigned nCanon, const char *szFile)
+/* Returns TRUE if the path is real, FALSE if it is PATH_INFO */
+static BOOL sub_canonical_filename(char *szCanon, unsigned nCanon, const char *szFile)
 {
     char buf[HUGE_STRING_LEN];
     int n;
     char *szFilePart;
+    char *s;
+    int nSlashes;
     WIN32_FIND_DATA d;
     HANDLE h;
 
+    s=strrchr(szFile,'\\');
+    for(nSlashes=0 ; s > szFile && s[-1] == '\\' ; ++nSlashes,--s)
+	;
+
     n = GetFullPathName(szFile, sizeof buf, buf, &szFilePart);
     ap_assert(n);
     ap_assert(n < sizeof buf);
 
     /* If we have \\machine\share, convert to \\machine\share\ */
     if (buf[0] == '\\' && buf[1] == '\\') {
@@ -33,94 +41,133 @@
     }
 
     if (szFilePart < buf+3) {
 	ap_assert(strlen(buf) < nCanon);
         strcpy(szCanon, buf);
 	if(szCanon[0] != '\\') { /* a \ at the start means it is UNC, otherwise it is x: */
-	    ap_assert(isalpha(szCanon[0]));
+	    ap_assert(ap_isalpha(szCanon[0]));
 	    ap_assert(szCanon[1] == ':');
 	    szCanon[2] = '/';
 	}
 	else {
 	    char *s;
 
 	    ap_assert(szCanon[1] == '\\');
 	    for(s=szCanon ; *s ; ++s)
 		if(*s == '\\')
 		    *s='/';
 	}
-        return;
+        return TRUE;
     }
     if (szFilePart != buf+3) {
         char b2[_MAX_PATH];
+	char b3[_MAX_PATH];
         ap_assert(szFilePart > buf+3);
+	/* avoid SEGVs on things like "Directory *" */
+	ap_assert(s >= szFile && "this is a known bug");
+
+	memcpy(b3,szFile,s-szFile);
+	b3[s-szFile]='\0';
 
-        szFilePart[-1]='\0';
-        sub_canonical_filename(b2, sizeof b2, buf);
+//        szFilePart[-1]='\0';
+        sub_canonical_filename(b2, sizeof b2, b3);
 
 	ap_assert(strlen(b2)+1 < nCanon);
         strcpy(szCanon, b2);
         strcat(szCanon, "/");
     }
     else {
 	ap_assert(strlen(buf) < nCanon);
         strcpy(szCanon, buf);
         szCanon[2] = '/';
         szCanon[3] = '\0';
     }
     if (h == INVALID_HANDLE_VALUE) {
-	ap_assert(strlen(szCanon)+strlen(szFilePart) < nCanon);
+	ap_assert(strlen(szCanon)+strlen(szFilePart)+nSlashes < nCanon);
+	for(n=0 ; n < nSlashes ; ++n)
+	    strcat(szCanon, "/");
         strcat(szCanon, szFilePart);
+	return FALSE;
     }
     else {
 	ap_assert(strlen(szCanon)+strlen(d.cFileName) < nCanon);
         strlwr(d.cFileName);
         strcat(szCanon, d.cFileName);
+	return TRUE;
     }
 }
 
-/* UNC requires backslashes, hence the conversion before canonicalisation. Not sure how
- * many backslashes (could be that \\machine\share\some/path/is/ok for example). For now, do
- * them all.
+/* UNC requires backslashes, hence the conversion before canonicalisation. 
+ * Not sure how * many backslashes (could be that 
+ * \\machine\share\some/path/is/ok for example). For now, do them all.
  */
 API_EXPORT(char *) ap_os_canonical_filename(pool *pPool, const char *szFile)
 {
     char buf[HUGE_STRING_LEN];
     char b2[HUGE_STRING_LEN];
-    char *s;
+    const char *s;
+    char *d;
+    int nSlashes;
 
     ap_assert(strlen(szFile) < sizeof b2);
-    strcpy(b2,szFile);
-    for(s=b2 ; *s ; ++s)
+
+    /* Eliminate directories consisting of three or more dots.
+       These act like ".." but are not detected by other machinery.
+       Also get rid of trailing .s on any path component, which are ignored by the filesystem.
+       Simultaneously, rewrite / to \.
+       This is a bit of a kludge - Ben.
+    */
+    for(s=szFile,d=b2 ; (*d=*s) ; ++d,++s) {
 	if(*s == '/')
-	    *s='\\';
+	    *d='\\';
+	if(*s == '.' && (s[1] == '/' || s[1] == '\\' || !s[1])) {
+	    while(*d == '.')
+		--d;
+	    if(*d == '\\')
+		--d;
+	    }
+	}
+    // Finally, a trailing slash(es) screws thing, so blow them away
+    for(nSlashes=0 ; d > b2 && d[-1] == '\\' ; --d,++nSlashes)
+	;
+    /* XXXX this breaks '/' and 'c:/' cases */
+    *d='\0';
 
     sub_canonical_filename(buf, sizeof buf, b2);
-    buf[0]=tolower(buf[0]);
 
-    if (*szFile && szFile[strlen(szFile)-1] == '/' && buf[strlen(buf)-1] != '/') {
-	ap_assert(strlen(buf)+1 < sizeof buf);
+    buf[0]=ap_tolower(buf[0]);
+
+    ap_assert(strlen(buf)+nSlashes < sizeof buf);
+    while(nSlashes--)
         strcat(buf, "/");
-    }
 
     return ap_pstrdup(pPool, buf);
 }
 
 /* Win95 doesn't like trailing /s. NT and Unix don't mind. This works 
  * around the problem.
- * Errr... except if it is UNC and we are referring to the root of the UNC, we MUST have
- * a trailing \ and we can't use /s. Jeez. Not sure if this refers to all UNCs or just roots,
+ * Errr... except if it is UNC and we are referring to the root of 
+ * the UNC, we MUST have a trailing \ and we can't use /s. Jeez. 
+ * Not sure if this refers to all UNCs or just roots,
  * but I'm going to fix it for all cases for now. (Ben)
  */
 
 #undef stat
 API_EXPORT(int) os_stat(const char *szPath, struct stat *pStat)
 {
     int n;
 
-    ap_assert(szPath[1] == ':' || szPath[1] == '/');	// we are dealing with either UNC or a drive
+    /* be sure it is has a drive letter or is a UNC path; everything
+     * _must_ be canonicalized before getting to this point.  
+     */
+    if (szPath[1] != ':' && szPath[1] != '/') {
+	ap_log_error(APLOG_MARK, APLOG_ERR, NULL, 
+	    "Invalid path in os_stat: \"%s\", should have a drive letter "
+	    "or be a UNC path", szPath);
+	return (-1);
+    }
 
     if(szPath[0] == '/') {
 	char buf[_MAX_PATH];
 	char *s;
 	int nSlashes=0;
 
diff -BEr -U 6 apache_1.3.0/src/PORTING apache_1.3.1/src/PORTING
--- apache_1.3.0/src/PORTING	1998-05-09 11:25:41.000000000 +0800
+++ apache_1.3.1/src/PORTING	1998-07-13 20:35:51.000000000 +0800
@@ -94,13 +94,13 @@
 When all else fails, it's time to hack some code. The source itself
 is generic enough that most ports are incredibly easy. No matter
 what, however, there are 2 source files that need to be updated
 for the port:
 
    ./Configure
-   ./include/conf.h
+   ./include/ap_config.h
 
 Configure:
 ==========
 Configure concerns itself with determining the OS-type for the
 build and setting up a few Makefile variables for the build. The
 most important are 'OS' and 'CFLAGS'. For example, when Configure
@@ -114,27 +114,27 @@
 	LDFLAGS="$LDFLAGS -s"
 	DEF_WANTHSREGEX=no
 	;;
 
 The 'OS' variable is used to define the system Apache is being built
 for. You will also note that 'CFLAGS' defines "-DAUX". In this case,
-'AUX' is a magic cookie used by the Apache code (mainly conf.h [see
+'AUX' is a magic cookie used by the Apache code (mainly ap_config.h [see
 below]) to handle OS-specific code. Each code that has and requires
 such OS-specific code will require a unique "system cookie" defined
 in 'CFLAGS'. You will also note that Configure also goes ahead and
 predefines the LIBS and LDFLAGS Makefile variables.
 
 DEF_WANTHSREGEX indicates the "default" setting of the WANTHSREGEX rule.
 If left undefined it'll default to yes.  Yes means the src/regex/
 directory, containing Henry Spencer's regex library will be used rather
 than any system supplied regex.  It's been our experience that system
 supplied regex libraries are generally buggy, and should be avoided.
 
-conf.h:
+ap_config.h:
 =======
-The Apache code, specifically in conf.h, uses a variety of #defines to
+The Apache code, specifically in ap_config.h, uses a variety of #defines to
 control how the code is compiled and what options are available for each
 supported OS. One of the hardest parts about the porting process is
 determining which of the following are applicable for your system and
 setup. This time using the example of AIX, we see:
 
    #elif defined(AIX)
@@ -149,13 +149,13 @@
 
 The above lines describe which functions,  capabilities and specifics
 are required for Apache to build and run under IBM AIX (the #undefs
 are not strictly required, but are a Good Idea anyway).
 
 The following several lines provide a list and short description
-of these #defines. By correctly #defining the ones you need in conf.h
+of these #defines. By correctly #defining the ones you need in ap_config.h
 (wrapped by the above mentioned "system cookie"), you can fine tune the
 build for your OS.
 
 --
 
  NEED_*:
@@ -180,25 +180,29 @@
     HAVE_SHMGET:
       The OS has a working shmget() (SystemV shared memory) implementation
 
     HAVE_GMTOFF:
       Define if the OS's tm struct has the tm_gmtoff element
 
-    HAVE_RESOURCE:
-      Define if the OS supports the getrlimit()/setrlimit() functions
-
     HAVE_CRYPT_H:
-      Define if the OS has the <crypt.h> header file.
+      Defined if the OS has the <crypt.h> header file. This is set
+      automatically during the Configure process and stored in the
+      src/include/ap_config_auto.h header file.
 
     HAVE_SYS_SELECT_H:
-      Define if the OS has the <sys/select.h> header file.
+      Defined if the OS has the <sys/select.h> header file. This is
+      set automatically during the Configure process and stored in the
+      src/include/ap_config_auto.h header file.
 
     HAVE_SYS_RESOURCE_H:
-      Define if the OS has and supports the getrlimit/setrlimit
+      Defined if the OS has and supports the getrlimit/setrlimit
       family. Apache uses this to determine if RLIMIT_CPU|VMEM|DATA|RLIMIT
-      is found and used.
+      is found and used. This also assumes that the getrlimit()/setrlimit()
+      functions are available as well. This is set automatically during the
+      Configure process and stored in the src/include/ap_config_auto.h header
+      file.
 --
 
  USE_*:
   These #defines are used for functions and ability that aren't exactly
   required but should be used.
 
@@ -335,23 +339,28 @@
        Amount to move sbrk() breakpoint, if required, before attaching
        shared-memory segment.
 
       NET_SIZE_T:
        Some functions such as accept(), getsockname(), getpeername() take
        an int *len on some architectures and a size_t *len on others.
-       If left undefined apache will default it to int.
+       If left undefined apache will default it to int.  See
+       include/ap_config.h for a description of NET_SIZE_T.
 
       NEED_HASHBANG_EMUL:
        The execve()/etc. functions on this platform do not deal with #!,
        so it must be emulated by Apache.
 
       SYS_SIGLIST
        Should be defined to point to a const char * const * array of
        signal descriptions.  This is frequently sys_siglist or
        _sys_siglist, defined in <signals.h>
 
+      ap_wait_t
+       The type used for wait()/waitpid()/... status parameter.  Usually
+       int.
+
 -----------
 Conclusion:
 -----------
 The above hints, and a good understanding of your OS and Apache, will
 go a LONG way in helping you get Apache built and running on your
 OS. If you have a port, PLEASE send Email to 'Apache@Apache.Org',
diff -BEr -U 6 apache_1.3.0/src/regex/debug.c apache_1.3.1/src/regex/debug.c
--- apache_1.3.0/src/regex/debug.c	1998-02-05 02:18:53.000000000 +0800
+++ apache_1.3.1/src/regex/debug.c	1998-07-09 01:47:26.000000000 +0800
@@ -231,12 +231,12 @@
 static char *			/* -> representation */
 regchar(ch)
 int ch;
 {
 	static char buf[10];
 
-	if (isprint(ch) || ch == ' ')
+	if (ap_isprint(ch) || ch == ' ')
 		sprintf(buf, "%c", ch);
 	else
 		sprintf(buf, "\\%o", ch);
 	return(buf);
 }
diff -BEr -U 6 apache_1.3.0/src/regex/engine.c apache_1.3.1/src/regex/engine.c
--- apache_1.3.0/src/regex/engine.c	1997-02-17 12:52:40.000000000 +0800
+++ apache_1.3.1/src/regex/engine.c	1998-07-13 19:32:52.000000000 +0800
@@ -43,12 +43,13 @@
 	states fresh;		/* states for a fresh start */
 	states tmp;		/* temporary */
 	states empty;		/* empty set of states */
 };
 
 #include "engine.ih"
+#include "ap_ctype.h"
 
 #ifdef REDEBUG
 #define	SP(t, s, c)	print(m, t, s, c, stdout)
 #define	AT(t, p1, p2, s1, s2)	at(m, t, p1, p2, s1, s2)
 #define	NOTE(str)	{ if (m->eflags&REG_TRACE) printf("=%s\n", (str)); }
 #else
@@ -996,13 +997,13 @@
 static char *			/* -> representation */
 pchar(ch)
 int ch;
 {
 	static char pbuf[10];
 
-	if (isprint(ch) || ch == ' ')
+	if (ap_isprint(ch) || ch == ' ')
 		sprintf(pbuf, "%c", ch);
 	else
 		sprintf(pbuf, "\\%o", ch);
 	return(pbuf);
 }
 #endif
diff -BEr -U 6 apache_1.3.0/src/regex/engine.ih apache_1.3.1/src/regex/engine.ih
--- apache_1.3.0/src/regex/engine.ih	1997-07-09 02:05:39.000000000 +0800
+++ apache_1.3.1/src/regex/engine.ih	1998-07-13 19:32:52.000000000 +0800
@@ -1,6 +1,8 @@
+/* DON'T EVEN THINK ABOUT EDITING THIS, go see regex/Makefile,
+ * search for mkh */
 /* ========= begin header generated by ./mkh ========= */
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* === engine.c === */
Only in apache_1.3.0/src/regex: libregex.a
Only in apache_1.3.0/src/regex: Makefile
diff -BEr -U 6 apache_1.3.0/src/regex/mkh apache_1.3.1/src/regex/mkh
--- apache_1.3.0/src/regex/mkh	1997-11-05 20:48:25.000000000 +0800
+++ apache_1.3.1/src/regex/mkh	1998-07-09 08:04:56.000000000 +0800
@@ -45,12 +45,14 @@
 		;;
 	*)	break
 		;;
 	esac
 done
 
+echo "/* DON'T EVEN THINK ABOUT EDITING THIS, go see regex/Makefile,"
+echo " * search for mkh */"
 if test " $ifndef" != " "
 then
 	echo "#ifndef $ifndef"
 	echo "#define	$ifndef	/* never again */"
 fi
 echo "/* ========= begin header generated by $0 ========= */"
diff -BEr -U 6 apache_1.3.0/src/regex/regcomp.c apache_1.3.1/src/regex/regcomp.c
--- apache_1.3.0/src/regex/regcomp.c	1998-02-05 02:18:53.000000000 +0800
+++ apache_1.3.1/src/regex/regcomp.c	1998-07-13 19:32:52.000000000 +0800
@@ -3,12 +3,13 @@
 #include <string.h>
 #include <ctype.h>
 #include <limits.h>
 #include <stdlib.h>
 
 #include "hsregex.h"
+#include "ap_ctype.h"
 #include "utils.h"
 #include "regex2.h"
 
 #include "cclass.h"
 #include "cname.h"
 
@@ -307,25 +308,25 @@
 	case '\\':
 		REQUIRE(MORE(), REG_EESCAPE);
 		c = GETNEXT();
 		ordinary(p, c);
 		break;
 	case '{':		/* okay as ordinary except if digit follows */
-		REQUIRE(!MORE() || !isdigit(PEEK()), REG_BADRPT);
+		REQUIRE(!MORE() || !ap_isdigit(PEEK()), REG_BADRPT);
 		/* FALLTHROUGH */
 	default:
 		ordinary(p, c);
 		break;
 	}
 
 	if (!MORE())
 		return;
 	c = PEEK();
 	/* we call { a repetition if followed by a digit */
 	if (!( c == '*' || c == '+' || c == '?' ||
-				(c == '{' && MORE2() && isdigit(PEEK2())) ))
+				(c == '{' && MORE2() && ap_isdigit(PEEK2())) ))
 		return;		/* no repetition, we're done */
 	NEXT1();
 
 	REQUIRE(!wascaret, REG_BADRPT);
 	switch (c) {
 	case '*':	/* implemented as +? */
@@ -348,13 +349,13 @@
 		AHEAD(THERE());			/* ...so fix it */
 		ASTERN(O_CH, THERETHERE());
 		break;
 	case '{':
 		count = p_count(p);
 		if (EAT(',')) {
-			if (isdigit(PEEK())) {
+			if (ap_isdigit(PEEK())) {
 				count2 = p_count(p);
 				REQUIRE(count <= count2, REG_BADBR);
 			} else		/* single number with comma */
 				count2 = INFINITY;
 		} else		/* just a single number */
 			count2 = count;
@@ -369,13 +370,13 @@
 	}
 
 	if (!MORE())
 		return;
 	c = PEEK();
 	if (!( c == '*' || c == '+' || c == '?' ||
-				(c == '{' && MORE2() && isdigit(PEEK2())) ) )
+				(c == '{' && MORE2() && ap_isdigit(PEEK2())) ) )
 		return;
 	SETERROR(REG_BADRPT);
 }
 
 /*
  - p_str - string (no metacharacters) "parser"
@@ -526,13 +527,13 @@
 		ASTERN(O_PLUS, pos);
 		INSERT(OQUEST_, pos);
 		ASTERN(O_QUEST, pos);
 	} else if (EATTWO('\\', '{')) {
 		count = p_count(p);
 		if (EAT(',')) {
-			if (MORE() && isdigit(PEEK())) {
+			if (MORE() && ap_isdigit(PEEK())) {
 				count2 = p_count(p);
 				REQUIRE(count <= count2, REG_BADBR);
 			} else		/* single number with comma */
 				count2 = INFINITY;
 		} else		/* just a single number */
 			count2 = count;
@@ -557,13 +558,13 @@
 p_count(p)
 register struct parse *p;
 {
 	register int count = 0;
 	register int ndigits = 0;
 
-	while (MORE() && isdigit(PEEK()) && count <= DUPMAX) {
+	while (MORE() && ap_isdigit(PEEK()) && count <= DUPMAX) {
 		count = count*10 + (GETNEXT() - '0');
 		ndigits++;
 	}
 
 	REQUIRE(ndigits > 0 && count <= DUPMAX, REG_BADBR);
 	return(count);
@@ -612,13 +613,13 @@
 
 	if (p->g->cflags&REG_ICASE) {
 		register int i;
 		register int ci;
 
 		for (i = p->g->csetsize - 1; i >= 0; i--)
-			if (CHIN(cs, i) && isalpha(i)) {
+			if (CHIN(cs, i) && ap_isalpha(i)) {
 				ci = othercase(i);
 				if (ci != i)
 					CHadd(cs, ci);
 			}
 		if (cs->multis != NULL)
 			mccase(p, cs);
@@ -724,13 +725,13 @@
 	register char *sp = p->next;
 	register struct cclass *cp;
 	register size_t len;
 	register char *u;
 	register char c;
 
-	while (MORE() && isalpha(PEEK()))
+	while (MORE() && ap_isalpha(PEEK()))
 		NEXT1();
 	len = p->next - sp;
 	for (cp = cclasses; cp->name != NULL; cp++)
 		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
 			break;
 	if (cp->name == NULL) {
@@ -817,17 +818,17 @@
  == static char othercase(int ch);
  */
 static char			/* if no counterpart, return ch */
 othercase(ch)
 int ch;
 {
-	assert(isalpha(ch));
-	if (isupper(ch))
-		return(tolower(ch));
-	else if (islower(ch))
-		return(toupper(ch));
+	assert(ap_isalpha(ch));
+	if (ap_isupper(ch))
+		return(ap_tolower(ch));
+	else if (ap_islower(ch))
+		return(ap_toupper(ch));
 	else			/* peculiar, but could happen */
 		return(ch);
 }
 
 /*
  - bothcases - emit a dualcase version of a two-case character
@@ -864,13 +865,13 @@
 ordinary(p, ch)
 register struct parse *p;
 register int ch;
 {
 	register cat_t *cap = p->g->categories;
 
-	if ((p->g->cflags&REG_ICASE) && isalpha(ch) && othercase(ch) != ch)
+	if ((p->g->cflags&REG_ICASE) && ap_isalpha(ch) && othercase(ch) != ch)
 		bothcases(p, ch);
 	else {
 		EMIT(OCHAR, (unsigned char)ch);
 		if (cap[ch] == 0)
 			cap[ch] = p->g->ncategories++;
 	}
diff -BEr -U 6 apache_1.3.0/src/regex/regcomp.ih apache_1.3.1/src/regex/regcomp.ih
--- apache_1.3.0/src/regex/regcomp.ih	2017-09-16 12:06:56.634163832 +0800
+++ apache_1.3.1/src/regex/regcomp.ih	1998-07-13 19:32:55.000000000 +0800
@@ -1,6 +1,8 @@
+/* DON'T EVEN THINK ABOUT EDITING THIS, go see regex/Makefile,
+ * search for mkh */
 /* ========= begin header generated by ./mkh ========= */
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* === regcomp.c === */
Only in apache_1.3.0/src/regex: regcomp.o
diff -BEr -U 6 apache_1.3.0/src/regex/regerror.ih apache_1.3.1/src/regex/regerror.ih
--- apache_1.3.0/src/regex/regerror.ih	2017-09-16 12:06:56.794163826 +0800
+++ apache_1.3.1/src/regex/regerror.ih	1998-07-13 19:32:56.000000000 +0800
@@ -1,6 +1,8 @@
+/* DON'T EVEN THINK ABOUT EDITING THIS, go see regex/Makefile,
+ * search for mkh */
 /* ========= begin header generated by ./mkh ========= */
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* === regerror.c === */
Only in apache_1.3.0/src/regex: regerror.o
diff -BEr -U 6 apache_1.3.0/src/regex/regex2.h apache_1.3.1/src/regex/regex2.h
--- apache_1.3.0/src/regex/regex2.h	1997-07-16 08:41:25.000000000 +0800
+++ apache_1.3.1/src/regex/regex2.h	1998-07-09 08:04:56.000000000 +0800
@@ -1,13 +1,15 @@
 /*
  * First, the stuff that ends up in the outside-world include file
+ = #ifndef API_EXPORT
  = #ifdef WIN32
  = #define API_EXPORT(type)    __declspec(dllexport) type __stdcall
  = #else
  = #define API_EXPORT(type)    type
  = #endif
+ = #endif
  =
  = typedef off_t regoff_t;
  = typedef struct {
  = 	int re_magic;
  = 	size_t re_nsub;		// number of parenthesized subexpressions
  = 	const char *re_endp;	// end pointer for REG_PEND
@@ -132,7 +134,7 @@
 	/* catspace must be last */
 	cat_t catspace[1];	/* actually [NC] */
 };
 
 /* misc utilities */
 #define	OUT	(CHAR_MAX+1)	/* a non-character value */
-#define	ISWORD(c)	(isalnum(c) || (c) == '_')
+#define	ISWORD(c)	(ap_isalnum(c) || (c) == '_')
Only in apache_1.3.0/src/regex: regexec.o
Only in apache_1.3.0/src/regex: regfree.o
diff -BEr -U 6 apache_1.3.0/src/support/ab.c apache_1.3.1/src/support/ab.c
--- apache_1.3.0/src/support/ab.c	1998-04-22 04:14:05.000000000 +0800
+++ apache_1.3.1/src/support/ab.c	1998-07-16 02:33:12.000000000 +0800
@@ -86,13 +86,13 @@
 
 /*  -------------------------------------------------------------------- */
 
 /* affects include files on Solaris */
 #define BSD_COMP
 
-#include "conf.h"
+#include "ap_config.h"
 #include <fcntl.h>
 #include <sys/time.h>
 
 /* ------------------- DEFINITIONS -------------------------- */
 
 /* maximum number of requests on a time limited test */
@@ -228,28 +228,28 @@
     printf("Server Hostname:        %s\n", hostname);
     printf("Server Port:            %d\n", port);
     printf("\n");
     printf("Document Path:          %s\n", path);
     printf("Document Length:        %d bytes\n", doclen);
     printf("\n");
-    printf("Concurency Level:       %d\n", concurrency);
+    printf("Concurrency Level:      %d\n", concurrency);
     printf("Time taken for tests:   %d.%03d seconds\n",
            timetaken / 1000, timetaken % 1000);
     printf("Complete requests:      %d\n", done);
     printf("Failed requests:        %d\n", bad);
     if (bad)
         printf("   (Connect: %d, Length: %d, Exceptions: %d)\n",
                err_conn, err_length, err_except);
     if (keepalive)
         printf("Keep-Alive requests:    %d\n", doneka);
-    printf("Total transfered:       %d bytes\n", totalread);
-    printf("HTML transfered:        %d bytes\n", totalbread);
+    printf("Total transferred:      %d bytes\n", totalread);
+    printf("HTML transferred:       %d bytes\n", totalbread);
 
     /* avoid divide by zero */
     if (timetaken) {
-        printf("Requests per seconds:   %.2f\n", 1000 * (float) (done) / timetaken);
+        printf("Requests per second:    %.2f\n", 1000 * (float) (done) / timetaken);
         printf("Transfer rate:          %.2f kb/s\n",
                (float) (totalread) / timetaken);
     }
 
     {
         /* work out connection times */
@@ -548,13 +548,13 @@
             output_results();
         }
 
         /* Timeout of 30 seconds. */
         timeout.tv_sec = 30;
         timeout.tv_usec = 0;
-        n = select(256, &sel_read, &sel_write, &sel_except, &timeout);
+        n = ap_select(FD_SETSIZE, &sel_read, &sel_write, &sel_except, &timeout);
         if (!n) {
             printf("\nServer timed out\n\n");
             exit(1);
         }
         if (n < 1)
             err("select");
diff -BEr -U 6 apache_1.3.0/src/support/apachectl apache_1.3.1/src/support/apachectl
--- apache_1.3.0/src/support/apachectl	1998-03-31 20:53:46.000000000 +0800
+++ apache_1.3.1/src/support/apachectl	1998-07-17 05:25:54.000000000 +0800
@@ -9,12 +9,13 @@
 #	2 - usage error
 #	3 - httpd could not be started
 #	4 - httpd could not be stopped
 #	5 - httpd could not be started during a restart
 #	6 - httpd could not be restarted during a restart
 #	7 - httpd could not be restarted during a graceful restart
+#	8 - configuration syntax error
 #
 # When multiple arguments are given, only the error from the _last_
 # one is reported.  Run "apachectl help" for usage info
 #
 #
 # |||||||||||||||||||| START CONFIGURATION SECTION  ||||||||||||||||||||
@@ -46,19 +47,18 @@
 
 for ARG in $@ $ARGS
 do
     # check for pidfile
     if [ -f $PIDFILE ] ; then
 	PID=`cat $PIDFILE`
-	PS=`ps -p $PID 2>/dev/null | tail -1 | grep $PID`
-	if [ "x$PS" = "x" ]; then
-	    STATUS="httpd (pid $PID?) not running"
-	    RUNNING=0
-	else
+	if kill -0 $PID; then
 	    STATUS="httpd (pid $PID) running"
 	    RUNNING=1
+	else
+	    STATUS="httpd (pid $PID?) not running"
+	    RUNNING=0
 	fi
     else
 	STATUS="httpd (no pid file) not running"
 	RUNNING=0
     fi
 
@@ -94,16 +94,22 @@
 		echo "$0 $ARG: httpd started"
 	    else
 		echo "$0 $ARG: httpd could not be started"
 		ERROR=5
 	    fi
 	else
-	    if kill -HUP $PID ; then
-		echo "$0 $ARG: httpd restarted"
+	    if $HTTPD -t >/dev/null 2>&1; then
+		if kill -HUP $PID ; then
+		    echo "$0 $ARG: httpd restarted"
+		else
+		    echo "$0 $ARG: httpd could not be restarted"
+		    ERROR=6
+		fi
 	    else
-		echo "$0 $ARG: httpd could not be restarted"
+		echo "$0 $ARG: configuration broken, ignoring restart"
+		echo "$0 $ARG: (run 'apachectl configtest' for details)"
 		ERROR=6
 	    fi
 	fi
 	;;
     graceful)
 	if [ $RUNNING -eq 0 ]; then
@@ -112,37 +118,51 @@
 		echo "$0 $ARG: httpd started"
 	    else
 		echo "$0 $ARG: httpd could not be started"
 		ERROR=5
 	    fi
 	else
-	    if kill -USR1 $PID ; then
-		echo "$0 $ARG: httpd gracefully restarted"
+	    if $HTTPD -t >/dev/null 2>&1; then
+		if kill -USR1 $PID ; then
+		    echo "$0 $ARG: httpd gracefully restarted"
+		else
+		    echo "$0 $ARG: httpd could not be restarted"
+		    ERROR=7
+		fi
 	    else
-		echo "$0 $ARG: httpd could not be restarted"
+		echo "$0 $ARG: configuration broken, ignoring restart"
+		echo "$0 $ARG: (run 'apachectl configtest' for details)"
 		ERROR=7
 	    fi
 	fi
 	;;
     status)
-	$LYNX $STATUSURL | awk '  { if (/current process/) { print; exit } else print } '
+	$LYNX $STATUSURL | awk ' /process$/ { print; exit } { print } '
 	;;
     fullstatus)
 	$LYNX $STATUSURL
 	;;
+    configtest)
+	if $HTTPD -t; then
+	    :
+	else
+	    ERROR=8
+	fi
+	;;
     *)
-	echo "usage: $0 (start|stop|restart|fullstatus|status|graceful|help)"
+	echo "usage: $0 (start|stop|restart|fullstatus|status|graceful|configtest|help)"
 	cat <<EOF
 
 start      - start httpd
 stop       - stop httpd
 restart    - restart httpd if running by sending a SIGHUP or start if 
              not running
 fullstatus - dump a full status screen; requires lynx and mod_status enabled
 status     - dump a short status screen; requires lynx and mod_status enabled
 graceful   - do a graceful restart by sending a SIGUSR1 or start if not running
+configtest - do a configuration syntax test
 help       - this screen
 
 EOF
 	ERROR=2
     ;;
 
diff -BEr -U 6 apache_1.3.0/src/support/apachectl.1 apache_1.3.1/src/support/apachectl.1
--- apache_1.3.0/src/support/apachectl.1	1998-03-31 20:53:46.000000000 +0800
+++ apache_1.3.1/src/support/apachectl.1	1998-06-10 20:08:51.000000000 +0800
@@ -89,12 +89,15 @@
 .BI stop
 Stops the Apache daemon.
 .TP
 .BI restart
 Restarts the Apache daemon by sending it a SIGHUP.  If the daemon
 is not running, it is started.
+This command automatically checks the configuration files via 
+.BI configtest
+before initiating the restart to make sure Apache doesn't die.
 .TP
 .BI fullstatus
 Displays a full status report from 
 .B mod_status. 
 For this to work, you need to have mod_status enabled on your server 
 and a text-based browser such as \fIlynx\fP available on your system.  The
@@ -108,15 +111,23 @@
 .TP
 .BI graceful
 Gracefully restarts the Apache daemon by sending it a SIGUSR1.  If
 the daemon is not running, it is started.  This differs from a
 normal restart in that currently open connections are not aborted.
 A side effect is that old log files will not be closed immediately.
-This means that if used in a log rotation script, a substantial
-delay may be necessary to ensure that the old log files are closed
-before processing them.
+This means that if used in a log rotation script, a substantial delay may be
+necessary to ensure that the old log files are closed before processing them.
+This command automatically checks the configuration files via 
+.BI configtest
+before initiating the restart to make sure Apache doesn't die.
+.TP
+.BI configtest
+Run a configuration file syntax test. It parses the configuration
+files and either reports 
+.B "Syntax Ok"
+or detailed information about the particular syntax error.
 .TP
 .BI help
 Displays a short help message.
 .SH SEE ALSO
 .BR httpd(8)
 .
diff -BEr -U 6 apache_1.3.0/src/support/htdigest.c apache_1.3.1/src/support/htdigest.c
--- apache_1.3.0/src/support/htdigest.c	1998-04-22 04:14:05.000000000 +0800
+++ apache_1.3.1/src/support/htdigest.c	1998-07-13 19:32:58.000000000 +0800
@@ -7,13 +7,13 @@
 /*
  * htdigest.c: simple program for manipulating digest passwd file for Apache
  *
  * by Alexei Kosut, based on htpasswd.c, by Rob McCool
  */
 
-#include "conf.h"
+#include "ap_config.h"
 #include <sys/types.h>
 #ifdef MPE
 #include <signal.h>
 #else
 #include <sys/signal.h>
 #endif
diff -BEr -U 6 apache_1.3.0/src/support/htpasswd.c apache_1.3.1/src/support/htpasswd.c
--- apache_1.3.0/src/support/htpasswd.c	1998-04-22 04:14:06.000000000 +0800
+++ apache_1.3.1/src/support/htpasswd.c	1998-07-13 19:32:58.000000000 +0800
@@ -7,13 +7,13 @@
 /*
  * htpasswd.c: simple program for manipulating password file for NCSA httpd
  * 
  * Rob McCool
  */
 
-#include "conf.h"
+#include "ap_config.h"
 #include <sys/types.h>
 #include <signal.h>
 
 #ifndef CHARSET_EBCDIC
 #define LF 10
 #define CR 13
@@ -158,13 +158,13 @@
 
     tn = NULL;
     signal(SIGINT, (void (*)()) interrupted);
     if (argc == 4) {
 	if (strcmp(argv[1], "-c"))
 	    usage();
-	if (!(tfp = fopen(argv[2], "w"))) {
+      if (!(tfp = fopen(argv[2], "w+"))) {
 	    fprintf(stderr, "Could not open passwd file %s for writing.\n",
 		    argv[2]);
 	    perror("fopen");
 	    exit(1);
 	}
 	printf("Adding password for %s.\n", argv[3]);
@@ -173,18 +173,18 @@
 	exit(0);
     }
     else if (argc != 3)
 	usage();
 
     tn = tmpnam(NULL);
-    if (!(tfp = fopen(tn, "w"))) {
+    if (!(tfp = fopen(tn, "w+"))) {
 	fprintf(stderr, "Could not open temp file.\n");
 	exit(1);
     }
 
-    if (!(f = fopen(argv[1], "r"))) {
+    if (!(f = fopen(argv[1], "r+"))) {
 	fprintf(stderr,
 		"Could not open passwd file %s for reading.\n", argv[1]);
 	fprintf(stderr, "Use -c option to create new one.\n");
 	exit(1);
     }
     strcpy(user, argv[2]);
@@ -208,17 +208,21 @@
 	}
     }
     if (!found) {
 	printf("Adding user %s\n", user);
 	add_password(user, tfp);
     }
+/*
+* make a copy from the tmp file to the actual file
+*/  
+        rewind(f);
+        rewind(tfp);
+        while ( fgets(command,MAX_STRING_LEN,tfp) != NULL)
+        {
+                fputs(command,f);
+        } 
+
     fclose(f);
     fclose(tfp);
-#if defined(__EMX__) || defined(WIN32)
-    sprintf(command, "copy \"%s\" \"%s\"", tn, argv[1]);
-#else
-    sprintf(command, "cp %s %s", tn, argv[1]);
-#endif
-    system(command);
     unlink(tn);
     exit(0);
 }
diff -BEr -U 6 apache_1.3.0/src/support/httpd.8 apache_1.3.1/src/support/httpd.8
--- apache_1.3.0/src/support/httpd.8	1998-05-12 19:14:31.000000000 +0800
+++ apache_1.3.1/src/support/httpd.8	1998-06-16 11:37:32.000000000 +0800
@@ -66,12 +66,14 @@
 ] [
 .BI \-f " config"
 ] [
 .BI \-C " directive"
 ] [
 .BI \-c " directive"
+] [
+.BI \-D " parameter"
 ]
 
 .B httpd 
 [
 .B \-h
 ] 
@@ -135,23 +137,33 @@
 .BI \-C " directive"
 Process the configuration \fIdirective\fP before reading config files.
 .TP
 .BI \-c " directive"
 Process the configuration \fIdirective\fP after reading config files.
 .TP
+.BI \-D " parameter"
+Sets a configuration \fIparameter\fP which can be used with
+<IfDefine>...</IfDefine> sections in the configuration files
+to conditionally skip or process commands.
+.TP
 .B \-h
 Output a list of directives together with expected arguments and
 places where the directive is valid.
 .TP
 .B \-l
 Output a list of modules compiled into the server.
 .TP
 .B \-S
 Show the settings as parsed from the config file (currently only shows the
 virtualhost settings).
 .TP
+.B \-t
+Run syntax tests for configuration files only. The program immediately exits
+after these syntax parsing with either a return code of 0 (Syntax OK) or
+return code not equal to 0 (Syntax Error).
+.TP
 .B \-X
 Run in single-process mode, for internal debugging purposes only; the daemon
 does not detach from the terminal or fork any children. Do NOT use this mode
 to provide ordinary web service.
 .TP
 .B \-v
diff -BEr -U 6 apache_1.3.0/src/support/httpd.exp apache_1.3.1/src/support/httpd.exp
--- apache_1.3.0/src/support/httpd.exp	1998-05-22 14:58:28.000000000 +0800
+++ apache_1.3.1/src/support/httpd.exp	1998-06-10 20:40:26.000000000 +0800
@@ -34,12 +34,13 @@
 ap_bpushfd
 ap_bputs
 ap_bread
 ap_bsetflag
 ap_bsetopt
 ap_bskiplf
+ap_bspawn_child
 ap_bvputs
 ap_bwrite
 ap_bytes_in_free_blocks
 ap_bytes_in_pool
 ap_call_exec
 ap_can_exec
@@ -59,12 +60,13 @@
 ap_clear_module_list
 ap_clear_pool
 ap_clear_table
 ap_close_piped_log
 ap_construct_server
 ap_construct_url
+ap_content_type_tolower
 ap_copy_array
 ap_copy_array_hdr
 ap_copy_table
 ap_core_reorder_directories
 ap_coredump_dir
 ap_count_dirs
@@ -296,14 +298,13 @@
 ap_show_modules
 ap_signal
 ap_slack
 ap_snprintf
 ap_soft_timeout
 ap_some_auth_required
-ap_spawn_child_err
-ap_spawn_child_err_buff
+ap_spawn_child
 ap_srm_command_loop
 ap_standalone
 ap_start_restart
 ap_start_shutdown
 ap_str_tolower
 ap_strcasecmp_match
diff -BEr -U 6 apache_1.3.0/src/support/logresolve.c apache_1.3.1/src/support/logresolve.c
--- apache_1.3.0/src/support/logresolve.c	1998-05-28 19:23:13.000000000 +0800
+++ apache_1.3.1/src/support/logresolve.c	1998-07-13 19:32:58.000000000 +0800
@@ -36,13 +36,13 @@
  * The -c option causes logresolve to apply the same check as httpd
  * compiled with -DMAXIMUM_DNS; after finding the hostname from the IP
  * address, it looks up the IP addresses for the hostname and checks
  * that one of these matches the original address.
  */
 
-#include "conf.h"
+#include "ap_config.h"
 #include <sys/types.h>
 
 #include <ctype.h>
 
 #ifndef MPE
 #include <arpa/inet.h>
@@ -285,13 +285,13 @@
 		exit(1);
 	    }
 	    i++;
 	    statfile = argv[i];
 	}
 	else {
-	    fprintf(stderr, "Usage: logresolve [-s statfile] [-c] < input > output");
+	    fprintf(stderr, "Usage: logresolve [-s statfile] [-c] < input > output\n");
 	    exit(0);
 	}
     }
 
 
     for (i = 0; i < BUCKETS; i++)
Only in apache_1.3.0/src/support: Makefile
diff -BEr -U 6 apache_1.3.0/src/support/Makefile.tmpl apache_1.3.1/src/support/Makefile.tmpl
--- apache_1.3.0/src/support/Makefile.tmpl	1998-05-30 02:21:15.000000000 +0800
+++ apache_1.3.1/src/support/Makefile.tmpl	1998-07-13 19:32:57.000000000 +0800
@@ -59,13 +59,22 @@
 
 #Dependencies
 
 $(OBJS): Makefile
 
 # DO NOT REMOVE
-ab.o: ab.c $(INCDIR)/conf.h $(OSDIR)/os.h
-htdigest.o: htdigest.c $(INCDIR)/conf.h $(OSDIR)/os.h \
- ../main/md5c.c $(INCDIR)/ap_md5.h
-htpasswd.o: htpasswd.c $(INCDIR)/conf.h $(OSDIR)/os.h
-logresolve.o: logresolve.c $(INCDIR)/conf.h $(OSDIR)/os.h
-rotatelogs.o: rotatelogs.c $(INCDIR)/conf.h $(OSDIR)/os.h
-suexec.o: suexec.c $(INCDIR)/conf.h $(OSDIR)/os.h suexec.h
+ab.o: ab.c $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h
+htdigest.o: htdigest.c $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h ../main/md5c.c $(INCDIR)/ap_md5.h
+htpasswd.o: htpasswd.c $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h
+logresolve.o: logresolve.c $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h
+rotatelogs.o: rotatelogs.c $(INCDIR)/ap_config.h \
+ $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
+ $(INCDIR)/hsregex.h
+suexec.o: suexec.c $(INCDIR)/ap_config.h $(INCDIR)/ap_config_auto.h \
+ $(OSDIR)/os.h $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h suexec.h
diff -BEr -U 6 apache_1.3.0/src/support/rotatelogs.8 apache_1.3.1/src/support/rotatelogs.8
--- apache_1.3.0/src/support/rotatelogs.8	1998-03-31 20:53:54.000000000 +0800
+++ apache_1.3.1/src/support/rotatelogs.8	1998-06-12 18:10:58.000000000 +0800
@@ -61,13 +61,13 @@
 .SH DESCRIPTION
 .B rotatelogs
 is a simple program for use in conjunction with Apache's piped logfile
 feature which can be used like this:
 
 .fi
-   TansferLog "|rotatelogs /path/to/logs/access_log 86400"
+   TransferLog "|rotatelogs /path/to/logs/access_log 86400"
 .mf
 
 This creates the files /path/to/logs/access_log.nnnn where nnnn is the system
 time at which the log nominally starts (this time will always be a multiple of
 the rotation time, so you can synchronize cron scripts with it).  At the end
 of each rotation time (here after 24 hours) a new log is started.
diff -BEr -U 6 apache_1.3.0/src/support/rotatelogs.c apache_1.3.1/src/support/rotatelogs.c
--- apache_1.3.0/src/support/rotatelogs.c	1998-04-22 04:14:06.000000000 +0800
+++ apache_1.3.1/src/support/rotatelogs.c	1998-07-13 19:32:58.000000000 +0800
@@ -7,13 +7,13 @@
  */
 
 
 #define BUFSIZE		65536
 #define MAX_PATH	1024
 
-#include "conf.h"
+#include "ap_config.h"
 #include <time.h>
 #include <errno.h>
 #include <fcntl.h>
 
 int main (int argc, char **argv)
 {
diff -BEr -U 6 apache_1.3.0/src/support/suexec.c apache_1.3.1/src/support/suexec.c
--- apache_1.3.0/src/support/suexec.c	1998-04-22 04:14:06.000000000 +0800
+++ apache_1.3.1/src/support/suexec.c	1998-07-13 19:32:59.000000000 +0800
@@ -68,13 +68,13 @@
  *
  ***********************************************************************
  *
  *
  */
 
-#include "conf.h"
+#include "ap_config.h"
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 
 #include <stdarg.h>
 
@@ -158,18 +158,19 @@
 static void err_output(const char *fmt, va_list ap)
 {
 #ifdef LOG_EXEC
     time_t timevar;
     struct tm *lt;
 
-    if (!log)
+    if (!log) {
 	if ((log = fopen(LOG_EXEC, "a")) == NULL) {
 	    fprintf(stderr, "failed to open log file\n");
 	    perror("fopen");
 	    exit(1);
 	}
+    }
 
     time(&timevar);
     lt = localtime(&timevar);
 
     fprintf(log, "[%d-%.2d-%.2d %.2d:%.2d:%.2d]: ",
 	    lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday,
@@ -201,24 +202,25 @@
     char **ep;
     int cidx = 0;
     int idx;
 
 
     if ((cleanenv = (char **) calloc(AP_ENVBUF, sizeof(char *))) == NULL) {
-	log_err("failed to malloc env mem\n");
+        log_err("failed to malloc memory for environment\n");
 	exit(120);
     }
 
     for (ep = environ; *ep && cidx < AP_ENVBUF; ep++) {
 	if (!strncmp(*ep, "HTTP_", 5)) {
 	    cleanenv[cidx] = *ep;
 	    cidx++;
 	}
 	else {
 	    for (idx = 0; safe_env_lst[idx]; idx++) {
-		if (!strncmp(*ep, safe_env_lst[idx], strlen(safe_env_lst[idx]))) {
+		if (!strncmp(*ep, safe_env_lst[idx],
+			     strlen(safe_env_lst[idx]))) {
 		    cleanenv[cidx] = *ep;
 		    cidx++;
 		    break;
 		}
 	    }
 	}
@@ -236,14 +238,14 @@
     int userdir = 0;		/* ~userdir flag             */
     uid_t uid;			/* user information          */
     gid_t gid;			/* target group placeholder  */
     char *target_uname;		/* target user name          */
     char *target_gname;		/* target group name         */
     char *target_homedir;	/* target home directory     */
-    char *actual_uname;		/* actual user name            */
-    char *actual_gname;		/* actual group name           */
+    char *actual_uname;		/* actual user name          */
+    char *actual_gname;		/* actual group name         */
     char *prog;			/* name of this program      */
     char *cmd;			/* command to be executed    */
     char cwd[AP_MAXPATH];	/* current working directory */
     char dwd[AP_MAXPATH];	/* docroot working directory */
     struct passwd *pw;		/* password entry holder     */
     struct group *gr;		/* group entry holder        */
@@ -280,18 +280,18 @@
      * is the user allowed to do so as defined in
      * suexec.h.  If not the allowed user, error out.
      */
 #ifdef _OSD_POSIX
     /* User name comparisons are case insensitive on BS2000/OSD */
     if (strcasecmp(HTTPD_USER, pw->pw_name)) {
-	log_err("user mismatch (%s)\n", pw->pw_name);
+        log_err("user mismatch (%s instead of %s)\n", pw->pw_name, HTTPD_USER);
 	exit(103);
     }
 #else  /*_OSD_POSIX*/
     if (strcmp(HTTPD_USER, pw->pw_name)) {
-	log_err("user mismatch (%s)\n", pw->pw_name);
+        log_err("user mismatch (%s instead of %s)\n", pw->pw_name, HTTPD_USER);
 	exit(103);
     }
 #endif /*_OSD_POSIX*/
 
     /*
      * Check for a leading '/' (absolute path) in the command to be executed,
@@ -347,13 +347,13 @@
     target_homedir = strdup(pw->pw_dir);
 
     /*
      * Log the transaction here to be sure we have an open log 
      * before we setuid().
      */
-    log_err("uid: (%s/%s) gid: (%s/%s) %s\n",
+    log_err("uid: (%s/%s) gid: (%s/%s) cmd: %s\n",
 	    target_uname, actual_uname,
 	    target_gname, actual_gname,
 	    cmd);
 
     /*
      * Error out if attempt is made to execute as root or as
@@ -473,13 +473,14 @@
      * the name/group of the cwd or the program.
      */
     if ((uid != dir_info.st_uid) ||
 	(gid != dir_info.st_gid) ||
 	(uid != prg_info.st_uid) ||
 	(gid != prg_info.st_gid)) {
-	log_err("target uid/gid (%ld/%ld) mismatch with directory (%ld/%ld) or program (%ld/%ld)\n",
+	log_err("target uid/gid (%ld/%ld) mismatch "
+		"with directory (%ld/%ld) or program (%ld/%ld)\n",
 		uid, gid,
 		dir_info.st_uid, dir_info.st_gid,
 		prg_info.st_uid, prg_info.st_gid);
 	exit(120);
     }
     /*
